all right um so a few years ago I wanted to see if it was possible to implement coroutines using C++ 17 um this is the result the the entire implementation is around um 200 lines of code and I also wrote some taste cases which I mean oh you don't see it okay so once again yeah this is this is the implementation and here are the taste cases um and apparently it still runs and works so oh okay so what you're about to see some truly horrible code and I apologized before it so be prepared so if we talk about cortin since we need two things coroutine is a function that we can puse and we can resume um there are many ways to implement resume here you can see three of them like um inlay jump or computed goto um the problem is that none of them is available on msvc x64 which was the platform that I'm using so instead I wrote an assembly procedure that smashes the r address and this is how I implemented resume so this assembly procedure simply has a move that moves from the register of the return address to from the register of the argument to the return address and then it returns so it essentially jumps um and this is used to to implement the resume so when we enter the cod in we first check if we need to resume somewhere and then we resume to it um but the problem is that after after assuming the compiler may assume that some variables are in the registers which might not be the case because we're jumping to an arbitrary instruction so again I wrote an empty um assembly procedure just to force the um the compiler to reload the the variables again and so after yelding um we need to call this procedure to to reload the variables to to the registers then I again abused the return address to find out where we stopped to get the address from where we need to resume to um by creating a no inline function and using the built-in return address and now we have a working puse and resume so we can puse anywhere store the return address and when we go back to the function we can resume to where we stopped um the the entire um stack and parameters are all in the vars variable that the the cor routin takes as parameter and for making it um a little bit nicer I used macros but another uh property of Co routines is that we need to manage lifetime so here if we ELD in the middle and then go back if we exit the function by returning the variables will be destroyed um which is not good so um I created a struct that contains that will contain all the the the variables in the coroutine frame and then I create um I declare a new frame which inherits from the previous frame and add another variable so that we can calculate um the entire the the size of all the the current variables in the Corin frame all right so counter is a struct that recursively inherits from itself um and this um frame T we can use this Frame macro to get the the value of the last counter and get the current um cortin frame and then after um yeah and so when we we instead of declaring a variable we need to declare like a new coroutine frames that contains the variable as a data member and once again we can wrap it in macros just to make the code a little bit more nicer um we also need a way to find out the the entire Space Storage for the coroutine frame so um for every variable we also um so the the cortin function takes an i template parameter and we can use it to pass out the storage requirements for each one of the um the co routine frame types and finally the storage is the maximum of all the the cin frame requirements um we also need some weight to clean up so every frame has functions to to clean up after himself and destroy the variable and destroy the the variables of the the frame that it inherits from and there are two um two structs to stop propagation so that it doesn't go all the way and um destroy variables in in different Scopes and so we need to add call to the um lifetime cleaning uh functions so once again I used Macos and this is the code uh finally you can see an example of how the co how how it looks like I mean this is pretty disgusting but it works thank [Applause] you