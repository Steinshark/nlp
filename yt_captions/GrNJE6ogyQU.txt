Hello and welcome to mCoding where we try to get just a little bit 
 better at programming every episode. I'm James Murphy. I'm using an experimental editor theme today. So let me know if it's better or worse than usual. Today we're talking about the 
 algorithm that I affectionately call "fast_pow." If you're a long-time viewer, you might remember that I've had a video about efficient exponentiation before. That video is more about how to find the least 
 number of multiplications possible to raise something to a small power. "fast_pow," on the other hand, is a general 
 algorithm to raise things to very large powers. Of course, if there's a "fast_pow," 
 there's probably a "slow_pow,". And that's the one you'd 
 probably come up with on your first try. To raise x to the nth power, 
 we start with one and multiply by x n times. That means it takes n multiplies overall 
 in order to raise something to the nth power. The idea for "fast_pow" is that x to the n is 
 approximately equal to x to the n over 2 squared. If n is even, that's exactly correct. And if n is odd, then we just need 
 to multiply by another single x. This is great because it phrases the 
 answer to the problem "What's x to the n?" in terms of the 
 solution to "What's x to the n over 2?" A problem of half the size. This lends itself to a very 
 simple and elegant recursive solution. So let's see how to turn this into "fast_pow." We start off with our base case, which is that 
 raising something to the zeroth power always gives 1. Feel free to argue in the comments  about  
  whether this does the right thing for x equals zero. If you disagree, you could always raise an exception. We're going to need half the value of 
 n and the remainder after division by 2. A bit of Python trivia, though: if you 
 need both the quotient and remainder, this is not the best way to do it. Python has this built-in called "divmod" that gives 
 you both the quotient and remainder at the same time. If you're wondering why Python would have a single 
 function that gives you both the quotient and remainder instead of just expecting you to use 
 divide by 2 and then mod 2, a lot of integer long division 
 algorithms, like the one that you learned in school, produce the remainder as sort of just a 
 byproduct of the algorithm. So if you compute and divide by something, 
 you actually get n mod the same something for free. Of course, bitwise operations 
 also work since we're using two here. But in general, even if you're not using 2, 
 "divmod" can give you both at the same time. Moving on, we  
recursively compute x to half the power, Then square that answer and multiply 
 by x one more time if there was a remainder. Otherwise, just return the result. It's simple, there's a great core idea. 
 It's very elegant. And it's pretty easy to code up. This is something you could 
 learn as your first recursive algorithm. By the way, other people call 
 this algorithm "exponentiation by squaring,". But that's a pretty lame name. 
 So I'm going to call it "fast_pow." So anyway, instead of using n multiplications, 
 it only uses about log n multiplications.   There are plenty of ways that you could 
 take this code and tweak it to go slightly faster. And that's not really the direction 
 that I want to take this in. After all, Python already has 
 a built-in exponentiation operator. And as you could probably guess,  
 "fast_pow" is not that fast compared to it. Although that's due in part  
 to the fact that the built-in exponentiation operator uses "fast_pow" or some 
 more sophisticated modification of it. Now, the direction that I want to take this in is: What if we allow x to be 
 something other than an integer. And what if we allow a different kind of multiplication? This idea and this algorithm don't 
 really depend on integers or multiplication. And recognizing this allows 
 "fast_pow" to be a more general algorithm. We'll still stick to non-negative integer powers. But other than that, let's 
 see what else we actually used. So let's just parameterize this function 
 by the kind of multiplication that we want to do. We'll do this by adding two  
  new arguments: "multiply" and "identity." We'll use "multiply" in place of anywhere 
that we were going to use the star operator. And we'll use "identity" in place of 1 
 because 1 was really specific to integers. So if we raise something to the zeroth 
 power, we need to return the identity instead of 1. The division here is division of the power n, not of x. So that is still integer division. We can still recursively use "fast_pow". But we can't use star equals here. Star equals is effectively just 
 saying result is result times result. That's squaring the value. So let's replace squaring the 
 value with multiplying the value with itself. Same thing goes here; instead 
 of using the star operator to multiply, we'll use the mul operator to multiply. And don't forget to pass the new arguments here. Now, in order to use our more general "fast_pow" we need to define this multiplication and identity. If we wanted to check our implementation, we could define our multiplication 
 function to just take two arguments and use the built-in multiplication. The identity for this 
is the one that we had here before. Run it now and all of our asserts pass. 1 to the power of 100 is 1. 5 cubed is 125. And 2 to the 11th is 2048. So what other kinds of 
 multiplications and identity can I pass in? We just need a multiplication where 
 we're allowed to put parentheses wherever we want. That's called associativity. The other property that we used is that 
 multiplying by the identity doesn't change the value. We actually don't care about commutativity 
 because we're always multiplying by the same number. Reordering them doesn't change anything. So we need associativity and an identity element. Well instead of multiplication another associative 
 operator that we have is addition. It doesn't matter where you put the 
 parentheses when you do addition of integers. But one is not the element 
 that does nothing for addition. If we want adding something
 to do nothing, then we should use zero. Well, then what's "fast_pow" going 
 to give us in this case. 1 to the power 100 is giving us 100. 5 to the power 3 is giving us 15. And 2 to the 11 is giving us 22. Read those numbers again and you realize 
 that it's actually just doing regular multiplication. That's right. "fast_pow" on addition gives multiplication. 1 times a 100 is a 100. 5 times 3 is 15 and 2 times 11 is 22. This is happening because although we 
 named it 'pow' for power like multiplication what we're really doing is repeated application. So repeated application of 
 multiplication is exponentiation. But repeated application 
 of addition is multiplication. If I repeatedly add 5 to itself 
 three times that's the same as 5 times 3. Let's test your intuition. If we still took multiplication 
 to mean the built-in plus operator And we took our identity to be the empty string, then what would the 
 empty string to the power of 100 be? What would 'a' to the 11 be? And what would 'abc' cubed be? Answer coming in 3 Answer coming in 3 2 Answer coming in 3 2 1. The empty string to the 100 is the empty string. a to the 11 is 11 a's. And 'abc' cubed is just 'abcabcabc'. Once Again repeated addition is 
 basically giving us a form of multiplication. Multiplication for strings 
 means repeat this that many times. This is even consistent 
 with Python's built-in multiplication. So if you've ever wondered why a 
 hundred times the empty string is even allowed, Hopefully, this gives you an idea that it's 
 because there's some deeper underlying structure there. So, I mean cool story, bro. 
 But is this actually useful for anything? So far, we've seen a slower version of 
 the built-in exponentiation operator for integers. And an even slower version of the 
 multiplication operator for integers and for strings. There's pretty much no way that we're 
 going to be able to build the speed of a Python built-in using something in pure Python. So, we need to think about 
 expensive operations that are not built into Python. You got it. Here's an example 
 I think you're really going to like. Let's start by importing NumPy. Then let's take our multiplication to be convolution. Convolution is an extremely important 
 operation especially in Signal processing. And it has a lot of the same 
 properties that the basic multiplication does. In particular, it is associative. But there's a problem. If you've ever looked at the 
 Wikipedia article for convolution, you'll see all kinds of mathematical jargon 
 about something called an approximation to the identity. Why doesn't Wikipedia just tell me 
 what the identity is for the multiplication? Well, that's because there is no identity for convolution. At least not for real numbers. Now technically we're on a computer. And the discrete convolution does actually have an identity. But for this example, we're going 
 to be modeling something continuous. And the continuous convolution does not have an identity. So, it'd be kind of susque to use the 
 discrete version of the identity for convolution here. If we can, we should just not use an identity. So first, we need to modify our algorithm. If you had an identity the kind of algebraic 
 structure we were working with before is called a monoid. But we can actually get away with even less. If there's no identity, like there isn't for convolution, then we can still do 'fast_pow'. We just need to change our base case. This is called a semi-group structure by the way if you just have associativity 
 and not necessarily even an identity. So we change our base case. We now no longer allow raising to the zeroth power. We just assume or raise 
 an exception if you want that the smallest power that 
 we're going to feed to this function is 1. x to the power one is just x. That one is always available. Once again, division here is division 
 of the power and the power is an integer. We no longer have to pass the identity. And voila. Our 'fast_pow' is now 
 complete and in its most general form. As long as you're not raising to the power zero, 
 this is still going to give all the same answers as before. But now we no longer have to specify an identity. Now let's get back to the convolution. We no longer need the identity. Then I'm going to take some samples. And use a discrete approximation of 
 the uniform distribution between 0 and 1. Let's pull in matplotlib and plot it. When we plot it, we just see 
 a flat line which is what we expect because it's the uniform distribution. Every point is as likely as every other point. Now get ready for the very cool surprise. What do we get when we use 
 convolution as our multiplication? And raise the uniform 
 distribution to the 30th power? Are you ready? Well, what do you know! Doesn't that look familiar?  Doesn't that just look so much like a bell curve? And there's no tricks here. There's no e to the minus x squared anywhere inside. You can run the example yourself. Let's put that in a loop and see it go slowly. At n equals zero, we just see the uniform distribution. Then we see a triangle. And then each subsequent convolution seems 
 to give something more and more normal distribution like. Albeit, shifting further and 
 further to the right and getting squished. And the really cool fact is that this doesn't 
 even depend on using the uniform distribution. You could pick any initial distribution that you want. Here, I just took some random formula. 2 * x minus x squared plus 1 for those X is bigger than 0.5 minus 1 for those X's less than 0.1. So, this formula isn't even continuous. Divide out by the sum to make the sum equal to 1. So it's a probability distribution. And then look at what happens 
 when we do the iterated convolutions. As you can see, the blue line, 
 the initial distribution wasn't even continuous. But after just a few iterations, we're seeing 
 that same normal distribution looking shape again. If you think this is cool, 
 you should really get into probability. The theorem I play here is the central limit theorem. And the reason that this 
 is somehow related to convolutions  is that the distribution of a 
 sum of independent random variables is given by the convolution of their distributions. But that's maybe for a different video. In any case, I hope you liked "fast_pow". And importantly, I hope this shows you some 
 of the potential benefits of being able to take an algorithm. And reduce it down to its fundamental pieces. Abstract away the details that you don't really care about. Is there some underlying structure there 
 that makes sense in a more general context? So while "fast_pow" itself is quite a 
simple example. Some of the craziest, most useful results and very cool optimizations come from abstracting things in the same way that we did in this video. Usually with a little more math, though. Thank you to my patrons and donors for supporting me. If you liked the video, don't forget to subscribe. And if you especially like the video, 
 please consider becoming a patron on Patreon. My company is mCoding. We do consulting, contracting, training, 
 interview practice, code reviews, that kind of thing. If you're interested in working 
 with me, please check out mcoding.io. Don't forget to slap that like 
 button. And I'll see you next time!