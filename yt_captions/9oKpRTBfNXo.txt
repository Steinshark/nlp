we've done a couple of videos on binary search big fan right you know it's great it has some pros and cons one of the pros is that look UPS very very fast one of the cons is you have to sort the data and there are lots of other data structures available to us that we could use but serve slightly different purposes and again they have pros and cons as well so today we're going to start looking at hashmaps or hash sets depending on how you're using them which are a very different way of storing your data but they're very very popular so for example if you've used python the dictionary is implemented as a hash map almost all languages will have a data structure that does or multiple data structures that does something like this because of the benefits that they have for storing data and looking up very very quickly so let's think a bit about the speed of binary search let's put aside the fact that we had to sort the data that was a bit of a pain it takes a long time but once the data is sorted the lookup if you remember is O log n so it's log that's how it scales right yeah that's how it scales so if your size of your data is n if your list doubles in size your log two of n only goes up by one right which basically means you have to do one additional lookup which is of no real concern right for most computers so it means that it's scales very very well with the size of your data now that log two of n is good right what's better is log is 01 right o1 says it doesn't mean that you only have to do one operation right that's I think a common misconception it it just means that there is no relationship between the speed of lookup really and the number of elements in your list so if your list is 100 elements or a thousand elements it's still just the same amount of computation you have to to do that lookup right so o1 is obviously the ideal case and there are some data structures that offer you this you would think why would you use binary search then well each of these have their pros and cons but I just wanted to talk about hashsets today or hashmaps because they are one of these data structures right and they are very very popular what is a hash we've talked about cryptographic hashes before hash function takes some string right let's say a BC and it turns it into some fixed length string that's not usually three long these sort of hashes that we're looking at today are a little bit different they are a numerical code that represents some object in memory that we're trying to put into our data structure so a hashset is essentially a large list of numbers indexed by their hash rather than by themselves so you might have a very large list of numbers right and this is zero and this is one and this is two and this is three dot dot dot dot dot all the way up to the maximum size of your set so let's say 10,000 right so I'm going to do 9999 here now I nearly made a mistake so now these are not your actual values these are the hashes of those values so you have let's say you have a string or you have an object or a class or you have a number you hash it into here and it comes out as four four and then you can put your object in here right and when you have object two comes along and you get you compute a hash on it and it and it comes up as 770 so down here somewhere you have this object you know with 770 as his hash let's talk about how his hash is calculated if you have an integer right and you want your hash to also be an integer then there is no there's nothing to do right the hash is the number okay that works well if you have something for example if you're trying to return a 32bit hash value and you've got a 64-bit number then what you would commonly do is take the two hares and EXO them together and then for a string you have to do a computation that combines each of the characters for every position in the string for example and so the more complicated your object perhaps the more complicated hash is we're going to look at integers today just because for Simplicity but it these are usually quite fast and they're not they don't have to be cryptographically secure right but the same restrictions that we've talked about previously on on you know cryptographic hashes they don't hold here what we're looking for here is a broadly good distribution of our values around this list so it's a bit of a way of kind of like boiling it down or abbreviating yes it's like a sort of fingerprint yes but very very simplistic one we'll talk about what happens when two objects have the same hash in a moment but you're not absolutely concerned about that right it does it's going to happen I mean the thing to think about is if we've got our list of numbers here it's only 10,000 long and we've got 12,000 different objects if we find a way of hashing them into this list of 10,000 numbers by definition some of them are going to have the same hash right um and in fact this is what we would normally do so normally you will hash set would have a capacity right in this case 10,000 and so we actually calculate that the actual hash lookup value right is going to be the hash of our integer hash of I which is going to be itself or some other complicated way of doing it mod remember mod yeah it's come back mod our capacity which I'm just going to right C right like this so mod 10,000 or something like this and this means that if your number is 12,000 it's going to loop back around to be 2,000 on this set and it also means that broadly speaking as long as your original hashes are fairly uniform in their distribution their positions on this are also going to be fairly uniform right and that avoids too many too many values clumping around zero for example and no one nothing at four right that's the idea so how do we deal with collisions because that will happen right and if you have a imagine collisions where two things boil down be the same imagine that you had a capacity that was equal to the number of possible values you could have and you had a hashing function that always gave unique values then we wouldn't have any collisions right because they'd all just go into you know into the correct place and that'll be fine that is unlikely to happen because you know there's issues of memory for example we want to put 1.2 billion items into our set you might not have a maximum capacity of 1 you might but in even then your hash function might not be perfect and you know for Strings and things might produce the same hash for some complicated strings so we're going to get some collisions so what do you do well this is what you do when you when you insert something into this you say okay what what is the hash of this value mod C so let's say that that gives us a value of four right so we come in here and we look oh hang on a minute there's already something in the four so what we do is we create a little list at this at this position where we have object two like you see like this now this list is a slower data structure because we're doing that linear search but it's only got two objects in it so this is much much faster so we have another object object four that's coming up this time and maybe it has a hash of two so we put in a new one and that's fine object in here and then we have another one so this gets appended onto here object two I'm giving them all the same names my nameing convention is rubbish you just hold lots of little lists at each of these indices such that anything that has the same hand hash just gets put into this short list into if your hash function is good and so everything is is is reasonably well distributed then you'll find that you have roughly the same number in each bucket that's kind of the idea now what's the speed of lookup of this well in the best case it's 01 because you say okay is 17 in the data set you hash it it comes out of 17 let's say you look and there is always not an object there and it's so you're done that's all you have to do in a slightly worst case you have a short list that you have to look through right in the in the absolute worst casee you have all of the items have received the same hash and so you have literally a list of length n here right so in a sense the best case scenario for a hash set is 01 and the worst case is o n but you rarely see o right if you've given any thought to your design right at all okay and so and it doesn't tend to happen if if you are looking for the hash 17 why is that quicker than looking for 17 in say an AR raay like not right and that's that's really interesting so one of the downsides of a hash is it there is a bit of memory and a bit of computational overhead this 01 in some sense is ever slightly worse than the o01 array lookup that you would do where you just index at 17 but for that to work you would have to know that you were only ever going to see indices that were numbers and were between these two values right so it might be that you have that exact situation right you know you're only going to have one between a number between zero and 10,000 and so and you're never going to have duplicates and you're never going to have collisions so just have an array right you don't need to use a hashset you don't need to use a dictionary in Python to do that which is why we have lists so again it comes back to that idea of think a little bit about why you're using a specific data structure right just because you can have a list of keys like this and and Associated values or not doesn't mean you just have to right and so um indexing just straight off using a number is always going to be the fastest way of doing it I've had to go implementing this in p and let's have a look so I implemented this as a short class now of course you'd be ill advised to use this class right because it's a perfectly good set in Python right which is called a set and you can use that and it implements this but mostly in C and it's much much faster so definitely use that um let's just draw a brief distinction between the two types A hashset is one where you store only the numbers and you're essentially trying to work out what's in there and what's not in there and you can do things you can do standard set notation things from mathematics so for example intersection of sets the union of sets and things like this um this was for a long time in Python implemented literally as a dictionary um it's just you never used for values a dictionary is where you have your set of keys which are this hashmap and then they link to something that has a value like an index in a book it is so your hashes are your index into your element right so a set doesn't have the actual element it just has the indices right they they are both implemented often in very very similar ways because they're essentially the same data structure it's just one of them then has a pointer to something else and perhaps we can look at extending this to dictionaries in a different video I partially implemented a class here called hashset it has a capacity which is the essentially the size of the underlying data structure that we're using which is a which is a list and I initialize that data to have nothing in it right so just be a long list of nothing where when we start to put elements in we can create a little entry there and then there's really only a few functions we have to implement I'm not implementing most of the set functions because you know I've got other things to do but there's an you want to be able to add an item ideally you want to be able to remove an item although I haven't implemented this and you want to use the contains function to be able to use the in keyword so remember when we were doing binary search we we tested against um whether something was in 17 was in our list we'll be able to do that on this set we'll be able to say is 17 in our set so how do we implement this well actually there's very little code involved python implements an underlying hash function that you can use rather than writing your own every time right you could write your own if you were very if you had had a specific data structure you were very worried about and you wanted maximum speed um in Python the hash of an integer is just the integer we knew we knew this a hash of a string will be calculated in a different way but will still give you a number right it could be very large and it could be positive or negative but it will be a number in this case we're only really looking at integers for the sake of simplicity so at the beginning of AD I'm going to have our integer I that I'm trying to add into our hash set we're going to create the hash of I and then we're going to call H mod the capacity of our data so that we can run this on a very small hashset with very few bins or a very large hashset with lots and lots of bins and then actually deciding whether something's already in the data is quite easy we look up the data element at the correct index which is given by hash our hash mod the capacity and then we say if it's not none which means that there's already something in there we append it to the list that's in there we add it onto the list if it is none we just create a new little list at that location with our single line item in it and then really the contains function is exactly the same so in Python if you implement this underscore underscore contains function what you're doing is is allowing it to use the in keyword essentially and so we're going to say okay we're going to create our hash in the exact same way we're going to again calculate the modulo so that we are within our capacity limit and then we just say Okay is the data at that location none if it's not can we find our value we're looking for in that little list right and hopefully that list isn't too long so we can just use the in keyword which will just be a little linear search but it won't take too long there are better ways to implement hashmaps right than this this is a demonstration of a kind of minimum Bare Bones implementation that does work at least as far as I know I've also written a print function so I can see what's in this in the uh in the set so let's test it out right so I'm going to run python minus IM map. piy okay we're in Python and we have our hash set now so we're going to create a new one how many elements do we want to test it with same numbers again or slightly fewer just for say save ourselves some time all right so ruce let's say our hash set H is equal to a hash set with a maximum size of let's say a million elements right what does this mean well it means that our underlying data structure is only a million in size it doesn't mean we can only store a million elements because some of them just might have the same hash right um You can really store as many elements as you want but of course the more you store Beyond Your Capacity the more more collisions you're going to have the slower it will get right so let's create an now our random in Array of um in fact let's let's just do our numbers like we did before right so that's much much easier so let's say we have our list which is equal to I for I in range and then let's say we're going to put 10 million in there right so that means we're going to have around 10 in each of our bins right which means there short linear search for a lookup but not anything like a linear search across across 10 million elements so if I look at if I look at list first 10 items then you have n to n so now we can see we can add all these items into our hash set right which is a little bit of a slow proces but shouldn't be too bad so we can say for uh integer in uh list h. add I and it's just going to go off and do that by the way if you use the actual python set it's much much faster right it's faster because it has finished now just just not that it's not that bad it's faster because this should be done in low level C code right what I'm doing is a lot of intermediate python code checking variables going back to C coming back again there's a lot of waiting around for things that happen Okay so now we can see if 17 is in our hashset so we can say 17 in h and it says true right and that works and it worked really really quickly even though we've got a 10 million value so we can find is's another one in there so we could say you know 999,999 in h it is now if we take that out of a list just like we you know we've done before so we could say okay so LS so hash I can't take it out of the list cuz I didn't I didn't implement the remove function did I um well let's just implement it quickly now uh you can speed fast forward this bit um it's going to be exactly the same as our insert function except we're going to delete it instead in h yeah okay so I've I've I've now added a remove function this will teach me to be lazy um where is very very similar to the ad function except instead of a um appending a new item to a list we're going to remove it from that list if it's there okay so now let's test this out so we we know that 999999 is in h so let's now remove it from H h. remove right that seems to have done something so now can we say a uh 999999 in h false right and actually if we look at the data structure we can see that so if we go um if we do hash on of 999999 it should be the same number again because we already said that hashes in Python just return a number for an integer so now let's look at our data structure at that location so if we look at the what what we'll find is we'll find all the numbers that module over capacity are the same are 999999 so let's have a quick look so if we go H do data at nine one shouldn't normally look at the internals of a data structure like this but sometimes it's useful for learning you can see we've got 1, 999,999 we also have 2, 999,9 all the increments of a million right on this value okay except for 999,999 which we removed and I'm now wishing I picked a shorter number to say but anyway so a hash set is is an extremely useful um data structure right so in Python using a set will allow you to to very quickly find what numbers are in what lists finding the numbers that are common between two lists and things like this is extremely useful perhaps the extended version is the one you see most of all which is the dictionary right so in a dictionary we now add to these indices we add an actual item that we can add so you have key value Pairs and this hashmap is perhaps something to look at next time global trading firm and computer file supporter James straet have made a little puzzle for us all here it is it involves placing numbers in this Manhattan grid representing skyscrapers and you got to figure out what Heights of skyscrapers block other ones does it look like something you could crack now the puzzle's just for fun but it is aimed at drawing a bit of attention to Jane Street's summer am event which is going to be in New York that's the Academy of math and programming now this is something for recent high school graduates to come to New York and immerse themselves in things like Game Theory programming data anal analysis all that good stuff and it's aimed at opening doors to students who perhaps have faced barriers to getting Advanced stem education opportunities like this it's an amazing program and it's a very generous opportunity there are more details in the video description it's well worth a look and by the way you don't have to complete the skyscraper puzzle to apply that's just something they've made for fun and you can do the puzzle even if you're not interested in the thing if you want to find out more there's going to be links in all the usual places you know the video description comments things you can click on check it out and thanks to Jane Street for supporting this [Music] episode