last time we looked at the problem or the uh great advantage if you like of using intermediate codes as a staging point in our compilers and we spent a lot of effort talking about how to improve your compiler but still on the same machine but with an intermediate code step i would strongly advise you to watch that video first because what we're now going to find in this next one we're doing is we're just changing the rules slightly instead of b star improved binary we're moving from b prime to b double prime we are generating a different binary for a completely different architecture but we are using the front ends that we've already established that get us as far as intermediate code what we're now talking about is how can i produce a new back end and you'll find that the diagrams i draw are remarkably similar to the ones on a single machine for improving yourself so do watch that one first unless you're utterly sure that you've taken in every single thing you said and then we can go on the adventure of just how intermediate codes are pretty well vital for porting compilers in the last video we used this as our home base if you like our master referral point for everything that we were trying to do we had source codes for two vital pieces and then compiled the versions of them over here what we're going to find with this one is yes we'll still be having an h compiler written in h producing intermediate code the thing that's going to change this time is instead of saying things like take my intermediate code and write a compiler for it that produces b prime i'll be saying take that write it in high-level language of your choice but make the binary it produces be for our brand new machine that we can't wait to get some software working on so that b prime will start becoming b double prime and whereas in the previous episode we were obsessed with getting really high quality b prime we got to be prime star even better we're not going to be as obsessed this time with improving the quality of any binary although that's possible in the end what we are concerned with is this time saying i don't want better binary for the old machine i want some brand new binary b double dash for the new machine and i don't care how rubbish it is initially i just want to get some binary for the new machine working and established what we can say about any cross compiler is it's going to look like this it's going to be h our chosen high level language it is going to originally be written in b prime but it's going to produce b double prime and if you want an actual example referring back to previous episodes for this we were in a situation where our h was c the original binary it was running on on a pdp 11 and our b double prime over here was z80 binary so there you are then that's a generic form of any cross compiler there's my actual example of my first encounter with cross compilation the bigger question is how does this help you if you start saying well instead of just sending boatloads of code across to that new machine i having no real control over it what happens if i want to sort of you know yeah i always did think of it in this term send an expeditionary force onto the foreign machine set up a few outposts do a little bit more on the foreign land then just unload the binary that's been sent on a boat actually set up a binary factory on your newly conquered land you say well yes and actually having an intermediate code helps that this is the one new piece of software you need to write since everything is working to intermediate code now it's a non-optional intermediate stage your front end of your compilers will quite cheerfully be producing i all you need to do to get something started on your new machine is to write something in a high level language which takes intermediate code but produces b double dashed at the other side so that's your intervention point let me say again it is a worthwhile step to do because the difference in detail between a pdp-11 binary and a z80 binary is pretty considerable and if you don't use intermediate codes you have to go right back to square one and think oh i've got to create a binary from scratch all over again but i've got to get in there in that code generator try and throw the old one away you say is there anything i can learn from this and just out of nowhere bridge the gap between your high level language and your new b double dash which you've got what we're saying is it's a lot simpler if you break it into two parts leave the front end as it is on the other machine for the moment and it's producing eye at you like mad what you need is a new back end so we're in a situation now that as i've made clear any cross compiler is going to be running on your old machine to start with producing binary code for some other new machine so what we've now got to do is revisit all we did before we said here's how the transformation chain works with intermediate codes if all you want to do is to improve the quality of the coding for your home machine b prime this is similar but different now we're going to say instead of producing better quality binary for this home machine we want to produce brand new binary but for a foreign and different machine and we want to know exactly what processes we're going to have to go through similar to before but a little bit different in detail so hold tight this is what we have to do we've got this new piece of software something that takes an intermediate code we know the spec of that we can ratchet in h our chosen high level language it's always a good thing but we know that eventually that thing has got to be compiled out down to binary but it's going to produce b double dash we take our new piece of software and we compile it now notice that is my original h2 intermediate compiler that runs on the old machine but i'm using it to compile this new thing we know what we're gonna get and i want write it out up here h gets translated into i via this so we are going to end up with i b double dash but the h has gone through to i so we've now got a piece of software that takes in i is running on i but produces b double dash don't forget that there is as the fourth component in our chain always available to us an intermediate code compiler that takes it down to binary now we want back from the beginnings of time the original component number four which is that so i've written an i interpreter in i it produces b double dash but from work on the old machine i've got something that takes i runs on b prime or b dash produces b dash net result of all of that what do we end up with we end up with i b double dash b dash so that is the result if you like of compiling the intermediate code right down to binary we've now got of really well it is close to being wonderful but not quite it's an intermediate code compiler it produces super duper new b double dash for the new machine slide drawback is it runs on the binary for the older machine so we're almost we've established our bridgehead but we're not quite invaded yet because what we'd love to do is to get this thing down here saying b double dash it's just a question again of feeding the right thing back into itself we've got i written in i producing b double dash we've compiled that with an i b dash b dash and we've ended up with this intermediate code producing b double dash written in b dash what do you do now that you've got this executable answer final stage feed it back to itself take the original thing and do it one more time if you take this look i i b double dash and feed it into your newly created binary i running on b prime how are let trumpet sound you have finally achieved what you wanted to achieve which is that goes through there and you end up with i b double dash b double dash in my original set out of pieces of componentry you need i had one two three and four and looking back at it now what we have got is that this is the equivalent of four look back in the early days when we only had one machine you needed an i compiler to take i into binary prime binary prime there what we've now done with all this jiggery pokery with t diagrams is we have produced ourselves an i b double prime b double prime it is totally on the new machine now it doesn't rely on b prime at all now again those of you who have soldiered how shall we say really soldiered hard on the previous episodes of this will now recognize that this is the same old story you want to have the binary you are running on being of the same quality as the best binary you can produce except now it's not so much best binary it's new binary rather than generating new binary for the new machine off the old hardware can you feed yourself back to yourself enough so that eventually you end up with something that is totally happy on the new machine and doesn't need old machine support in terms of b prime at all anymore so that's been a bit of a marathon folks we've uh we've mounted our galleys we've invaded the distant shore we've finally had enough coal compressors on our head that we think we're clear what we've done but if you just go over this carefully for yourself and draw yourself lots of t diagrams or better still make yourself some t-diagram shapes and just experiment with them until you're quite happy with uh with what you're doing and i hope it's been convincing that although it is messy at times it is so much easier when you move to a new machine to say all i need to write to get myself going is an intermediate code compiler i don't need to redo the whole chain that can be backfilled as we go along but i could take the existing front end and port it into being a new front end simply if i've got the back end tools that can produce b double prime forming it's as simple as that really an executable binary the net effect of slotting that t diagram against here slightly downwards is to show you that the c you've written gets converted into binary and the net output from this process it produces out a program that you probably store in the