what is up guys in today's video we're going to be talking about arm assembly stack management by the end of this video you'll be able to write arm assembly that uses functions where they use the stack for memory storage to be able to do this we first have to talk about what is a stack a stack is a basic structure in computer science similar to a stack of plates in your kitchen you're able to push and pop elements onto and from the stack which makes it a first in last out data structure so for example here we'll see that every item on the stack is equal width at four bytes and you have this arrow here that points to the top of the stack when i push an item onto the stack that arrow that points to the top of the stack goes up by four bytes and this new item is put on top then to remove an item from the stack i pop it off the item goes away and that error goes down this is a very simple structure without the computer engineering aspects of it so how does a stack apply to computer engineering and assembly well when people say the stack in assembly they're referring to an area in ram where programs put their local variables and control flow information during code execution the processor actually has two registers that point to the top and bottom of a stack frame a stack frame is just a chunk of the stack where one function is living so for example over here on the right we have this area here the area between fp which points to the bottom of the stack frame and sp which points to the top of the stack frame is the stack frame for one function in this example this is a stack frame for main it is important to note that the top of the stack is actually a lower address so as your stack gets bigger the address of sp gets more and more negative or lower so to be able to write assembly that does this we have to actually understand this idea of calling conventions so a calling convention is an agreement between two parties when you're writing code we'll be talking about two functions the caller and the collie so i've written this toy code here a function main calls a function other function in this example main is the caller and other function and up here is the call e the calling convention on arm asserts that the callee will preserve non-volatile registers if they're used basically what this means is that when main gives code control to other function when it gets out of other function it expects that registers 4 through 11 were put back in the same state also it's expected that the call callee other function will return code control back to main once its code execution is complete so basically it expects after return a gets ran code execution will go to the next line in the code which is line 13 return 0. it's very important to note that because this will determine the assembly output of the function so this code here that i'm circling produces this assembly here what we're actually going to do is we're going to walk through this assembly and kind of draw the stack here doing this will allow us to understand what's happening under the hood and better enable us to write assembly that uses stack frames so we're going to assume that the stack is in this state right so like i said before the frame pointer at the bottom and the stack pointer at the top constitute the stack frame for main currently the program counter is at this instruction here move into r0 the number one and it's getting ready to execute the other function right so that's this call this line here line 12. so we're going to click forward it runs the code branch and link to other function the branch in link all it does is it gives code control to other function and what the link does is it says put into the link register the address of the next instruction to be ran right so at this time the link register on the processor points to the next instruction that needs to be ran very important to remember that so we're gonna have this arrow here pointing to where a link register points to good so code execution goes to other function and it runs the push the frame pointer and link register operation it's important to note that the frame pointer is register 11 and link register is register 14. it's going to put the registers on the stack in ascending order so link register goes first the frame pointer goes it goes next and don't forget every time we push onto the stack the stack pointer goes up right so we used to point to four and now we point to the old frame pointer then we're gonna run this instruction here we say add four to the stack pointer and put it into the frame pointer and basically that's going to move the bottom of the stack we're getting ready to create that new frame it's moving it a little higher it's pointing to the bottom over here where link register points so this next instruction the subtract 8 from sp and store and sp instruction sub sp sp8 that is creating room on the stack for other function to have its own variables so you can see here when it does the rest of the uh the function local variables in the function are referred to as frame pointer relative so it's saying point to the frame pointer minus eight so that's minus four minus eight that's a local variable the frame point or minus eight again local variables all of the memory operations are happening frame pointer relative so other function gets ran it does that print f right it printfs the number that we give it and eventually we get to the point where we're now collapsing the stack frame so what it does is it says subtract four from fp which points to here remember subtractions go up and put that into sp and then we're going to pop off the stack back into the frame pointer and the program counter so this old fp becomes the new fp and then the link register which is pointing to the instruction that needs to get ran is what goes into pc so these two things get popped off the stack it's very important to recognize that and through that code execution gets put back to where the link register points and the stack frame is back in its old position i always like to do those visualizations we're talking about the stack i think it makes things a lot easier if you can see it kind of happening instruction by instruction and i think visualizing it like this makes it very easy so what we're going to do now is we're going to hop over to my dev environment we are going to write some code to actually implement this in assembly by ourselves let's make it happen before we get started i just want to say it looks like about 84 of you watching right now are probably not subscribed if you are not subscribed do me a favor hit that sub button really helps me out be alerted whenever i put out a new video about low level topics with that let's get rolling okay so now we're back in the dev environment um what we're going to do for this tutorial is we are going to use the hello world code that we use in the previous tutorials all my other videos and what we're going to do is instead of having the right syscall and the exit syscall just happen here we're actually going to create functions for them that start will call and we'll set up stack frames so that they have memory space in those functions that we can use so the first edit we're going to make is we need to create two labels right so we're going to do a hello world label that describes the area of the code where the right syscall happens and then we have the exit syscall this actually makes no change to our code at all it behaves exactly the same all we have now is a human readable label in the assembly and a debug symbol will actually populate in the elf um okay cool so that didn't change anything what we want to do is do a branch in link well that's a call in arm to hello world the idea being that hello world will execute it will return control back to the caller as we talked about start and then we'll be able to branch and execute exit so this also will work not the way we want it to um what actually happens here is branch and link to hello world happens and then hello world just runs all the way through and exits and that's it so what we want to do now is set up a stack frame on hello world where we a preserve and return link register control back to pc and also where we create room for hello world to do variable storage so as we talked about we need to first preserve all the non-volatile registers which are r4 through 11 and what's cool about arm assembly is that we can literally just type r4 through r11 in one instruction and that's actually valid arm it's pretty cool and then finally we need to preserve lr because at this point the link register points to line eight here we need to make sure that we preserve that so when we pop lr into pc the code continues to run properly so now that we've pushed all these variables onto the stack we have fp way down at the bottom of the stack frame and we have sp way at the top so we need to move into fp sp so what this actually does i'll have a little graphic pop up over here um this brings sp and fp up to the same level right so now fp and sp both point to the top of the stack where all these items live now we need to do the subtract instruction and remember this subtract instruction is what gives hello world stack frame it space to do memory storage so we're going to do is we're going to do sub into sp from sp hex 40. so this is actually going to give hello world hex 40 or 64 bytes of memory to work with when it's doing its operations right so now that we have that room we can do memory storage onto the stack i can say for example load into register r1 and remember r1 is a volatile register so we can do whatever we want with it um load the number hex one two three seven okay great and then we can store that number r1 onto the frame pointer minus excuse me minus hex 10 right so what we're actually doing is we're saying take this number put it into register and then store that register onto our stack pretty cool right and make sure it's all compiles and assemblies and all that good stuff oh excuse me great and it still works just to be expected but again there's no code control coolness happening here it's all just jumping right here and executing or exiting rather so the way we have to get control back to start which we want it to do is we need to do something like this we need to make sure that we pop all the elements off of the stack the way that we push them the way that we have to do that is first we have to move into sp the frame pointer so what that does is it brings sp from way up at the top of the top of our stack remember because we subtracted it by 40 and it makes it up at the same level at fp and at this point fp points to r4 through r11 and lr and then once we do that we're able to pop off of the stack all those same registers exactly as we found them oh and actually so instead of lr we don't want to pop into lr we want lr to become pc that's the difference so link register at this point points to line eight we want the value of the link register to become the program counter which is actually a legal arm instruction really really cool boom so it works we're not done 100 yet so what's happening here right now is hello world is getting called hello world is setting up a stack frame making room for itself putting a variable on the stack because it wants to because why not we're in assembly lane we can do whatever we want um it's doing that right syscall and then it deconstructs its stack frame and it pops off all the registers and goes back to exit and then exit gets called and exit does does its magic right and we're going to set up a little baby stack frame for this one this is also valid because we are not using r4 through r11 so we actually can just push fp and lr and no one really cares um and we're not going to set up any variable space here because we're not going to put any variables in the stack so we pop fp pc this is a pointless instruction because for the time we we can't ever get here because the program should have exited if it doesn't what will actually happen is we will uh yeah so this code will run forever actually if this exit code doesn't get get executed it'll pop the fp and the pc on from the stack that will call hello world and then hello world will run through here and then it'll crash so it'll actually run one time more and then crash um but anyway so what have we done we have written arm assembly that uses two function calls each of the functions in its own way sets up a stack frame and in one of the functions we're able to actually use that stack frame for local variable storage anyway guys that is it for this video i hope you learned something if you did do me a favor hit subscribe hit like leave a comment with what you want to see next and i'll see you guys next week for the next video keep on learning stay sharp bye-bye