and we get started with the next talk for meeting C++ 2023 right now we will have Vladimir veski talk about dependency injection patterns efficiency and usability um really interesting topic please take it away Vladimir thank you very much yans uh thank you and thank you very much for being here uh my name is Vladimir vishki I would like to offer this talk that is called dependent in injection patterns efficiency and usability uh material from the stock was originally prepared to be a part of uh test driven development of embedded and system level software presentation for Accu uh this year uh it did not fit there because of the time frame liation uh so it was extracted and reworked extended uh to become a separate uh talk U it's still influenced by testing topic and offers some overview of the basics of dependency injection techniques uh that are available in C++ and reviews it from the usability including testability and efficiency perspective I think the most of the talk is so belongs to Back to Basics level but there will be also some Advanced Parts as well so why dependency injection is important yes so we are following some design principles and practices when we are designing our software yes so um those or we are encouraged to follow those design principles in practices uh those uh principles in practice can be decomposition decoupling some something like single responsibility principle separation of concerns and the overlap there is that following different motivation and different criterias we split some functionality into smaller parts and dependency injection is important because it allows to reassemble those reduced um units into more complex parts of software uh dependenc injection State principle states that the units they should not be dependent on concrete types but they should be dependent on some abstractions and those design principles they are important because if we follow them yes so we can achieve some minimalist items that is easier to implement and modify we have some items with clear requirements and interfaces uh we can reuse those units or items so we if we decouple uh the uh so we can reassemble them into another system or if we decouple them from the platform we we then can reuse them on another platform so this enables pability also testability decoupled components they generally require simple tests and they can be developed independently in test driven test driven environment uh using test driven development yes so uh if we focus on testability the mock testing it's fundamentally based on decoupling um and dependency injection principles so we provide more implementation of dependencies that perform some test specific um actions or have some test specific behavior and this we are doing for testing of our implementation yeah so the composition would prevent this that makes the decomposition crucial and the testability it is really well connected with portability and reusability because we are developing some component in the testing environment and then we Port it into production environment and re use it there um to reason about applicability of different dependency injection techniques in different areas where C++ is used we need to probably review some specific specifics of those areas um here are some examples uh we uh can have some low latency applications those applications they are designed for maximum runtime efficiency and typically have some hot paths or some part of the application that is the most performance critical one and the layout there is uh on this hot path is typically AES static so that means that it is known as compil we also have some embedded applications those applications are typical they they can be limited um in some in resources so they can require some optimization for ation size also it is possible that the computational power of the platform will not be there will be no abudance of this computational power I would say and still there will be necessity to achieve some runtime efficiency there uh program structure there is also typical aesthetic so the we also have some user applications of that are quite often built using some objectoriented Frameworks so we can have some UI Frameworks remote procedure calls Frameworks uh some database accesses uh those uh also those application can be designed to have some Dynamic plug-in architecture we also have some software that can be built on top of the system apis um and provide some extra um services for upper layer uh applications we can call some platform software and they are typically based on those system apis like posix Windows or some board sdks and embedded so um to reason about the applicability of dependence injection techniques we will consider those U the requirements from those domains that we just kind of reviewed for example for us it's important if the dependency injection would introduce some runtime um dependent injection technique will introduce some runtime or size overhead uh if it will be applicable for runtime injection plus we also are interested if the uh dependence injection Tech technique can be suitable for mock testing if it will really enhance the testability and also of course what is important is general usability and what is the boiler plate overhead so is it really require how much code is needed to really enable some uh dependent injection based on some technique um from efficiency point of view uh of course it is important to mention that of course runtime characteristic they will depend on platform and generated code and the generated code it would depend on target architecture compiler program structure optimization features Etc so um we will review the code generation patterns uh we'll observe them to reason about and runtime impact of some design decisions and for this we will review code generated uh for x86 64 architecture mostly by Big Three compilers yes so by GCC Clank and Microsoft Visual C compilers for with different optimization options so we will build uh generate code with optimization for execution speed uh this is 03 for GCC Clank and O2 for Microsoft compiler and we also uh we'll also see what code will be generated if we use the optimization for the um executable size so OS for the um Clank and GCC and one for the Microsoft Visual C we will use Tri code samples uh that will be enough so the trival code samples of basically single translation units where all dependent and dependent and dependency code they will be located in really in one single translation unit this would be enough for the purpose of this presentation um we will look at the overhead like in Direction extra Cod that will um uh that will be generated and of course this relative overhead it can be unnoticeable for some types of applications um on the other side it can be very critical in some other settings and of course U I just wanted to mention and this is important to um highlight that evaluation of design decisions of course as with any other decisions that are involving uh performance considerations yes so those decisions they should be evaluated um and the tradeoff that should be done they should be evaluated based on uh measurements in Project Specific environment yes so um now about the dependencies in C++ programs yes so what are the dependencies what we can be dependent on so uh typically if we apply the composition we can so some functionality then can be placed in classes typically some functionality with the state uh and so we can be dependent on the object of this objects of this those classes or some functionality can they also be placed in Standalone functions typically without the state yes so we can also be dependent on some functions um and dependency injection techniques that are available in uh C++ language they are uh in on on language level are the inheritance based rent and polymorphism uh polymorphic function rappers we also have um inherited from C the function pointers that are still can be used and also we have static work compil and polymorphism yes uh so let's first start with inheritance based runtime polymorphism uh technically uh it is based on the principle that the client code should be dependent on class with virtual functions then concrete implementation U is injected so the class that implements those virtual functions and uh this is a well documented practice why because it overlaps with objectoriented design uses the same language features um and U aler I would say that uh um here it is reviewed from slightly different perspective U as more like a decoupling uh technique than actually object oriented design uh feature yes so how the uh code that uses this technique would look like yes so in best case the dependency is specified using so called interface this is not a language feature yes so interface but I uh mean that this is a class that only has pure viral function so there is no implementation in the class it just specifies the contract and the uh dependent code just uh accepts uh the this uh interface in my case it does this by reference because it clearly specifies that the dependency is needed for the function yes and um also the interface can also be uh declared in a way that it can also specify what kind of ownership is then implied for example here the interface has the protected uh Destructor that prevents the destruction of the inherited uh injected object from uh using this interface so this clearly so this first of all it prevents and also specifies um uh that so prevents the destruction plus it specifies that the ownership is not passed into the function yes so the ownership is still controlled by the client code um the dependency implementation it then needs to inherit from the interface and uh provide the implementation of the virtual functions so here we have some basic implementation that just forwards the data so in our example uh s I did not specify this we have some backend and this back end has an output method and here we have the file output that just forwards the uh data into the file um if we would like to slightly modify this implementation for example would like um this file to be passed as a reference from somewhere as from outside or uh just use a different stream we will need to have another implementation or use some templates but anyway we will need to have a different assotiation of uh the uh dependency implementation if we will need to uh have some Dum implementation that will be doing nothing like just will not perform any output we'll need to have another type as well and um if we need to forward a standalone function uh we will then also need to have it wrapped into another type yes so here we have another implementation that just forwards the call to the Standalone function uh like here so uh unfortunately uh this would be required From testability perspective uh this is also well documented practice because it is typical for object oriented design as well so we have uh we can implement the mock uh object the mock class and then we can inject it instead of our production implementation setting up some expectations and specifying the behavior that is specific for the test um let's have a look at what our at what code will be generated if we use this dependenc injection technique to uh for this purpose I'm using um as I already mentioned very simple uh sample so I will have some interface and a simple implementation that will be just we'll have two methods and it will just forward the calls to some um C functions this would be done to uh to use those C functions as a markers within the generated code that will be immediately visible and the code just um in so the one interface method uh that is called interface method will be just calling this C function that alone C function and multiplying the result by 1,000 and another uh interface method that is called like is really called another interface method will be just calling uh another function and just uh forwarding the parameter to it uh so the argument to it and the uh client code that will be using this dependency it uh will have uh the following logic so it will call the interface method and then depending on the if the flag is set um it will call it will either return The Returned value if it if the flag uh is set to true or we'll call the second interface method uh interesting detail here I will be always specifying flag to be true so making this code unreachable so we this will be used as also a marker of the level of optimization of the client code as well so if this code will not be present then we can see that this code was optimized away um and um to enable the dependent injection using this technique yes we create the instance of our dependency and just make the call passing this dependency into our function I have multiple Calles here to uh affect the compiler decision for inlining uh okay so the code that will be generated for this trivial sample with optimization for Speed will look like this for GCC and Clank uh the Cod is optimized so we see that uh this do something function was in lined the Cs were D virtualized and non-reachable paths are removed there is no uh calls that are unreachable here in the runtime at the same time if we look at the code that is generated by uh msvc uh we will see that it emits the instructions that correspond to indirect function calls yes so that we it is not uh uh it is it it it did not optimize those um uh Dynamic features away if we look at the code that will be generated by GCC but for the optimization for the executable size we'll also notice that the inlining is not happening here anymore and the function body remains at as it is so having those um calls and uh has the underlaying so has the code that corresponds to the underlaying implementation of this virtual code so we have indirect calls here as well um at the same time if we change the platform and build the code for arm platform with the same GCC compiler and also optimization for executable size we will see that it will optimize those uh virtual calls way uh if we add the a bit a couple of more calls to one of the interface methods we will see that Clank for optimization uh for uh runtime efficiency will also start emitting some indirect calls what does it show so it illustrates my initial statement about uh the fact that the compiler so and the the way what code will be generated it really is affected by multiple different factors and uh this should be definitely considered uh another question would be I'm mentioning here this in direction is it a problem at all and the answer is it depends because so this inir calls they can introduce performance penalty in case of Target mispredictions this can be mitigated by Advanced Hardware uh if so depending on the predictability of Target and the predictability of execution flows so if generally speaking if the calls are always coming to the same uh location then it will be predictable but if Hardware has this functionality plus overall number of operations to really implement those IND Direction so this uh Dynamic features of uh uh the of those virtual calls it will it is uh those number of those operations is greater than the number of operations that are needed to perform just a direct call plus uh those operations they include those multiple um memory accesses in form of the uh this point of chasing kind of multiple consecutive memory accesses and of course real life impact would depend uh on Project parameters and requirements but it's important to understand what is happening under the hood of the uh if some techniques are used also uh one more uh detail is that uh the uh if the dependency and dependent code are located in different translation units then also most likely the um IND direction will be uh emitted uh for example here this GCC with the optimization for Speed it still um implements those indirect calls so some virtual function calls and this can be um optimized by link time optimization if those dependencies are can be resolved during link time this is an important uh feature that also should not be neglected yes so here we see that those indirect calls they were substituted by direct calls during the link time okay so to summarize uh inheritance-based runtime polymorphism advantages so we see that yes so it works for runtime injection that is suitable for various cases where we need a dynamic configuration or when we need to use some Dynamic levers and plugins uh we also can achieve a separation of compilation units so the whole and all and isolation uh of implementation details yes so we can have the whole definition and declaration everything to be sealed in uh the source file and only the uh interface can be exposed this uh this is an advantage of course yeah so um on the other side of course those this technique also has limitations yes so the new types they should be introduced to implement various behavior and those virtual method resolution uh if it is uh not optimized way it introduces xra executable Cod and indirect calls um next technique that is available for us uh we have also polymorphic function wrappers so this is based on type Erasure and the standard supporting facility that enables this and standard is uh St function there are also some Alternatives including non allocating Alternatives so for example estl fix function or sg14 place function those they do not uh need to allocate on the Heap for captal list uh so that makes it suitable uh for uh in the environments where the hip location can be Sy critical um generally uh the Cod that would be dependent U on the polymorphic FR repa so would look like that so it accepts this the object rep object and can call it using cooperator and the call operator will have the signature that is specified here as template arguments um the client code can then has a lot of flexible ways of specifying the dependency implementation for example it can be just simplified it can be just specified using Lambda expression Lambda function uh there can be for example here some file object is captured and then some output is forwarded to that so this is the alternatives for our process data implementation that we had before in the previous section we here we're just forward to the file we do not need to um create some other types we can specify just another Lambda function if we just want to have the file created here uh in the uh body of the Lambda function locally yeah so we can also just forward the Standalone function here or uh write the simple Lambda expression just to specify that no operation should be done yes so this uh is really convenient because there is no necessity to introduce new types inherit from anything so there can be just simple implementation that is injected this really Pro uh provides a really loose coupling uh between dependent and dependency a dependent called inde dependency uh the for this this technique is phrased also important to mention that it works very well for um as a some form of substitution of a single method interfaces for example we can have a function like store records that require some format for record or write of record and this would be probably some single method interfaces but we can just provide a simple function so our function repper that will uh store the implementation of this functionality uh similar thing with some um IP address resolver that can be just injected into some function that implements connection to host um also can be used to implement some C function like here in the L configuration there is a necessity to U uh to create some plugins based on the name and we can just in inject this functionality into the L configuration file for testability it's quite convenient way um because we can just simply regardless of what is injected in production code here we can just U inject so forward the calls to some mock object that we can capture uh for the tests uh for the uh examples of the test code I'm using U I'm using the uh g g gas g Mo framework or uh we can just uh just forward the uh mock object by reference uh if it has the implementation of the cooperator so offer it will still need to to forward the call because we cannot mock just the call Operator but uh generally it is uh convenient because regardless of what we injected including also Standalone functions we still can check that the calls uh were correct yes just injecting the mock object and from uh efficiency point of view let's look at uh the code that will be generated for this technique we are using here again our do something function that has the same logic we call one fun one rapper object then um in case of the if uh the flag is not set we can call another one and those are the two reppers that are injected and we inject uh the same logic that we had before so we just uh have a repper that multiplies the result of some Standalone C function and we inject some C function directly because we uh are not anyhow altering its result or we just need to forward uh the argument to and uh if we look at the C that is generated this is the C that is generated by GCC for um runtime efficiency optimization we see that there is a massive overhead here uh the a lot of cod is generated and there is in Direction here there is there are also some checks because the uh because the object should throw if it does not uh hold the function if it's empty we also have U some uh resolution of what is really stored there because so we have here the U typ raure implementation um so we see that yeah there is a clear um tradeoff between uh usability and some uh performance here interesting detail that Clank actually has a feature it can optimize this away so it really optimizes well those rppers uh especially St function it also can optimize away the um the Alternatives like estl e STL function fixed function but with STD function really uh performs the uh so works very well but this is where uh the injected type is really known during the compile time so again in a in a very um simple trivial case but unfortunately yeah this is the unique feature a Microsoft compiler will produce something similar to what GCC GCC uh generated so some um overview yes so some some summary polymorphic function reppers they definitely have advantages yes so so we do not need to introduce new types uh their dependency can simply be adapted using Lambda Expressions uh translation units uh they can be separated as well because uh because the uh the type that is stored in the function is erased so that means that it also can be impl can be hidden and only the function can be then just provided to the client code so the the reper can be provided to to the client code and uh it's of course applicable for runtime injection so it can be injected on runtime and we can also inject Standalone functions without necessity to rep it so okay uh still we saw that it has some limitations yes so it introduced runtime overhead uh we saw that there are some indirect calls uh plus some extra logic it is unlikely to be optimized there are some exceptions but uh yes this is still a quite a unique feature and uh we need one reper object for interface method yes so if the interfaces are more complex uh and in some cases they are so it might might be uh not well scalable okay so uh function pointers is the next uh technique and of runtime technique uh that is available in C++ programs this is based uh so this is a technique that is available since C language is inherited from C uh but it is still used especially in the areas where C++ um needs to interact with C code uh the idea is that the pointers to functions are just passed to dependent code uh it is very widely used in um embedded and lowlevel software and it enables polymorphism in C programs so uh how does it look like so the to use this technique we typically pass either a single function pointer or we can aggregate several function pointers in the structure um like here and then we just pass it uh into the function so this is of the technique that is really can be seen A Lot in C cold C++ version can be slightly modified and modernized so we can have this left to right uh function pointers declarations using this add pointer TLS uh but the kind of uh usage will look the same yes so we can pass uh these set of so not the set but just actual disaggregation table of containing those function pointers and then we just call them indirectly um what is quite important um unfortunately this is quite rare the case but the uh those um aggregated function pointers they also can be Associated uh with some context and this context it can be just uh passed in form of void pointer to the uh dependent code and dependent code then can call uh the uh the functions just passing this context into those functions this could uh provide possibility to really associate some data with the function calls and significantly enhance interoperability between C++ and C code because this can then the call can then be associated with some object and uh if the C and C++ code are cool designed to work together then this is the uh implementation so design design detail that shouldn't be neglected it really simplifies interoperability um okay let's look at what code is generated for for functions uh for function pointers we can have uh the so our sample code is again the same we are using the standalone C functions we also have this rapper to alter the result of the function call uh here and we are just assigning those so we are initializing this function pointers within the uh structure using this repper here uh for yeah instead of just a a direct call because we need to multiply the result by 1,000 and uh here we are using C++ 20 feature designated initializers so they are now available unfortunately only starting from C++ 20 but of course it makes Cod uh more readable and actually safer yes so that we really specify proper U that we initialize proper Fields here and then we make multiple calls again and we can see that even um uh or for yeah we provide the function pointers here so we yeah we can see that uh it is uh well handled by the compilers all of the compilers they uh eliminated the IND directions the so and also all eliminated this unreachable C so they optimize the client code uh well yes some of the compilers also optimized the mathematical um expression here we had multiple additions there and it takes out the multiplication then um so just producing more efficient mathematical expression um unfortunately if we start experimenting with different uh parameters we will have same effects that we saw uh for the um inheritance based rent and polymorphism for example here if we uh built by GCC for with optimization for executable we again see that the do something function will not be unlined and the uh body of the function will contain those indirect calls to the function so and the reper function that was inlined uh in our previous example now is not in lined anymore so there is a so again uh we see that yes the um uh underlaying implementation and this is like an explicit IND Direction because we are using the function pointers here it can then uh this this implementation can just stay in the code depending on how compiler is optimizing this and this is again uh a simple very a simple trivial Cod sample where everything is visible for compiler on compile time single translation unit okay uh the advantages yes of the function pointers technique so we uh it works for C code it can be used for uh Standalone functions and um and can be used for runtime injection as well yes so this is those are the U the primary advantages on the other hand it they introduce indir Co overhead if not optimized away yes U that can this overhead can this IND Direction can prevent compile optimization uh further compiler optimization and also function pointer they are not associated with an object if not designed to accept this context yes uh so that means that if we need to from these functions uh we need to have uh we need to associate some data with those function calls for example some State we will need to use single TS including we will including test scenarios where we will need to have some single ton mocks uh this is not uh very very good yeah okay so generally the technique uh seems to be applicable for uh interaction with cold but unlikely to be really useful in the C++ programs where other options are available okay so now a couple words in general about optimizations for the runtime polymorphism and for different options that involve this front and polymorphism that we mentioned before so we can see that optimizations those like remove of in Direction in lining they're not guaranteed yeah so they are features of the tooling and sometimes they can happen or not and we saw the different cases where these optimization is actually was impossible did not happen um if dependencies can be resolved only at runtime then of course uh then we will have the uh in Direction because this is how this dynamic binding is implemented if dependencies um can be resolved in link time then lto is POS if is possible if it is available and should not be neglected um if dependencies and dependent code allocated in a single translation units the way in the way that we use in our examples this can provide a maximum uh level of visibility for compiler and enable the maximum level of optimization possibilities but generally it defies the dynamic features of those techniques and also defies a source code isolation um so as a summary for runtime polymorphism um I just wanted to mention that still the usage of those techniques is inevitable for some types of applications because they support the uh really uh runtime uh dependency injection they really can provide high level of dependency asola we can hide the implementation details um split the uh translation units hide the dependencies in source code we can um but they can introduce the runtime and size overhead even for programs with static structure we uh saw that we have some application types that have static structure that primarily have static structure at the same time they prioritize performance uh alternative for runtime um dependent injection techniques can be something that is not based on the IND Direction but uh still has the limitations but that can be um acceptable for the types of application where performance is more important the alternative uh that is definitely uh should be mentioned is a static or compound and polymorphism the uh idea behind it is that the dependent code has to be generic yes so it should be either function or clust blate and that dependency type is specified uh as a template argument and dependency and dependent code just uh need to be compatible that means that template parameter substitution should not fail as a simple example here we have our process data function uh where now it's called generic process data and it uh is template now a function template now and it accepts something generally speaking Yeah that can be uh called passing the data as parameter um then the use cases for this type of injection can look visually very similar to what we had with polymorphic function reppers yeah so here we also can specify the some Lambda expression so we can inject some closures uh we can also inject the Standalone functions we can inject the uh we can yeah simply have the same Lambda functions that we used before the difference here is that that those are all different instantiations of the um function template so those are all different uh instances of the function that are called here having different dependency types um from performance point of view and the generated code here U let's do another experiment so here we again have the same layout of the client code of the dependent code we have two functions and uh we pass those functions in one case we pass this again this rapper in another uh case we pass the function directly and the generated code uh will look uh so will be optimized yes so we can see that again all free compilers for optimization for runtime um runtime efficiency for uh runtime speed uh will uh optimize this well yes so again U eliminate in direction again uh unfort for if we use the uh change the optimization parameters like here GCC for size we can notice that the we will again see similar layout as we saw when we used the function pointers we'll see some IND Direction and this is happening uh because actually we injected the function pointers so we here pass the function pointers into our function template and this uh affected of course the generated Cod because the dependency type would be really like a like a a function pointer so that means uh we the call was not in lined and the function pointers St just stayed the same way as they were kind of provided into the tempate so here the functions are injected it is visible from the uh from the um that were deduced by the compiler so um alternatively If instead of passing the function and of directly we can rep the calls to the function into Lambda expressions and Lambda functions and inject the corresponding uh closure objects and in this case if we just do it like this we the code that will be generated will not contain any indirection because there was none in the source code there were no uh indirection because the function PES were not involved only direct calls were performed in the call operators of the closures that were generated so here we see that the code is optimized yes so that the dependent function is in lined the wrapper still still is not inlined but there are no indirect calls this is an detail because it is also kind of highlights the feature that if we are using this different types of static polymorphism then the type of dependency can also affect the generated code uh okay so we were talking about uh generic function but we also can have of course so about the function template we can also have class template um here we just need to provide the um so there should be a template parameters that would correspond to the dependency types s and they should be then injected uh in this case by reference uh estd reference repper might be required here if we need to provide some copy or and assignment operations otherwise it will not work instead of uh multiple dependencies one single class that uh implements this API provides this functionality can be injected yes so here we combine two different um methods and just made some dependency type we require that the dependency type just Implement both of them yes so something like this and we also can have uh our interface is be adjusted depending on some declarations within the dependency type so for example here the return type will dependent on the nested value type declaration from dependency type um if we uh to our if we implement the forwarding Constructor to our dependent class that would be just forwarding the dependency dependencies uh based on the value category of the uh of the provided dependency yes and then also supplement uh the Declaration with the template argument deduction guide that would link the parameters of the forwarding constructed to the parameters of the class template we can enable possibility uh that the dependency can be then injected uh using left or left value or a value references and it can be then either shared by reference or just owned by the dependent class so the use case for this um in our simple model will look like this there will be possibility to either pass the parameter by L value reference or just by our value reference here in case of temporary or we can use move here uh the um example of the application of this technique um I will provide in the next section but a couple of more details here so of course if we use this approach then we will need to use this remove reference here because we uh if the type can be deduced as a reference then we need to remove it to get access to the ne nested declaration and before that we discussed that we have we have um U we need to have the dependency type be compatible with the dependent code this is uh not very descriptive uh C++ 20 offers option to really specify that within the code so we can use Concepts to describe the dependency type for example here we generally require that the our dependency type has the methods called some function and another function and that they are related in the way that the type that so that the return type of the first method should uh be accepted as a parameter by the second method yes and this is um will then allow to verify the dependency without instantiation of dependent code it will also be more descriptive because it really specifies some form of the contract it then will provide better Diagnostics because the uh constraint uh this constraints verification Diagnostics is generally better than the one that is provided when the template instantiation fails so and it will allow independent uh development of dependent of the dependency uh code it will not require the uh so the uh presence of the dependent code to really verify uh to to verify conformance to the contract and then this concept generally can be used uh everywhere where we uh specify the template parameter constraining uh it's uh just Contra constraining it okay uh now short example how these techniques techniques can be combined this uh compile time techniques um let's look at these class that is the synchronized deck that uh is generally some form of adapter that uses some container as a backend storage and provides some synchronized R safe access to it so here we have like P we have Push method that uh needs to uh lock some synchronization primitive that is also uh the type of which is also specified as a tempate parameter and uh we need to develop this logic and also we need to verify and uh test it so here the backend type is spef and the synchronization primitive type they are constrained using Concepts so we those Concepts they can be specified like this for mtic or for everything that behaves like mtic we can use a concept called locable there is so this would correspond to the lockable named requirement so there is no concept like this in a standard Library so far but we can Implement one everything that can be locked and then loock is uh corresponds to the named requirement lockable and we uh can also specify concept that is called St St St stack like accessible this is will uh require perents of the methods that will allow efficient implementation of the stack so we require that the stor that the container that will be used as back end has those methods so in this case is slightly more complex but in uh we need push back probably P back but we are here limiting only what we need in this example um everything that would correspond to the lockable concept will be compatible with these standard facilities like scop lock or unique lock um here we use one and we need to take this Lo before we uh actually access the container the proper contract we can verify just in the unit test environment by providing some mock implementation of vector and mutex so here we have the mo that have the push back method for vector and lock and lock for for the mutex and if we implement the same technique that we mentioned before that we have the forwarding Constructor and deduction guide so here the types and so the types uh of the um to the arguments of the Constructor uh will then specify and Define the uh arguments of the whole class template so we can then just if this is implemented then we can uh just instantiate our adapter using the types uh and using the object uh our mock objects that will be then injected instead of uh real production dependen so here we constructed passing those uh references to the SM objects and then they are then become arguments of the synchronized tech class temp plate so having this we can then just simply specify our expectation that the calls to lock push back and unlock is happening in sequence then we trigger our API function of synchronized Tech and we need to and if everything is um correct then we can pass the test the potential issue that can be found here for example if we have this uh temporary uh lock we forget to if we uh forget uh to give a name to it then it will exist only on this line so that means that lock and unlock will be happening before the push back is happening so we can verify the contract and as we have also default parameters for uh so default types for to parameters and also we have default Constructor we can still create our synchronized stack just providing the value type that we want to store here and then the default types will be used in another case it will be vector and uh just a sub mutex if we would like to adapt already existing objects then we also can use it similar in a way similar to our Vector to similar to the way how we did this with the mock objects before okay so Last Detail that I wanted to mention we saw that we are quite Limited in the way how we can uh how we can um inject the Standalone functions as dependencies or for it sometimes it is necessary because they can Implement some logic that uh can uh be uh that that first of all should be sometimes should be substituted by some uh mocks for testability in some cases it just really should be a should be dependent uh on the some environment and for example on the platform so we can inject the platform dependent API for example uh and we saw that we can do this using the function pointers we can do this using the polymorphic fashion wrappers but those are those runtime techniques that can introduce the in directions we saw before yeah so um alternative to this is to wrap those SKS into some uh into uh the some into methods of some objects that we can um inject instead so we see s an example where we just WRA it into the um closure Co operator yes so using the Lambda function uh another way is just yes to try to attach those Standalone functions and wrap them into the methods of some stru that we can then also inject uh in the class of function template in this case we forward uh those calls to the C function or another function this can be generalized to avoid uh some potential uh defects in the forwarding of arguments or uh or in the forwarding of return value so generally we can U use the perfect forwarding here just to simply forward everything that will be f everything that will be passed for the class method to the Standalone function this can also be then um uh just wrapped in some um mro definition here so this would allow some form of uh attaching of the Standalone functions to the to some class here we are using our macro and this would uh be expanded to something like this and this also enables the testability so if we have some code that is dependent on some API attaching those to to the to an object and injecting the mock instead head of the uh real um implementation that really forwards to the production API can then be used to test the dependent code so with still there is no polymorphism U like runtime polymorphism involved here there are no function pointers involved here the Cod remains suitable for fur the compiler optimization okay so couple of uh couple of words as a summary for static polymorphism so we see that the indirect calls they can be avoided it provides really good potential for U in linning and further optimizations so uh and it can be used to substitute dependencies on concrete types so we do not need to be dependent on some interfaces like on the on the on the function with on the classes with virtual functions we also do not involve type rasia somehow here so we can just have already implemented concrete types and we can just inject them they just should follow some contract but limitations are also quite obvious yes so the dependent code it has to be generic uh the dependency injection is only happening on compile time so it's static Su only for suitable for static code only the dependent code and depend Tendencies um they also have to be in a single translation unit yes so this can increase compilation time this also like a separation of source code is um maybe not the best in that case but it supports compile optimization because it provides a good visibility for compiler yes uh if we look at the um compile time injection from test driven development perspective then we can notice that it enables some form of top down design design approach yeah when we have some form of the dependency inversion so we can Define the interfaces uh using the concepts yeah so um in some way yes so uh that means that the code for dependency can be then uh so the code the dependent code can then be developed independently and uh the concept will specify the contract for for dependencies yeah so um and also apart from top down approach it also enables bottom up approach when we already have some um components that we would like to use u in some code and instead of using those existing components we can start building our code using some mock implementations to verify the logic that we are developing without being dependent on these concrete types and then in production environment we then can inject those so this was demonstrated by our examples with the vector on mutex and um we can really achieve some decomposition without runtime overhead so if we need to have some decomposition for to increase the stability uh without sacrificing the uh runtime efficiency this can be achieved uh using compile time or static polymorphism so short summary uh yes so runtime uh techniques they are suitable for dynamic program structure uh because of this yeah the way how it is implemented there can be some extra code and the direction that can be unacceptable for performance critical areas this should be considered we have their dependency on compil optimization capabilities so generally if compilers can remove this and Direction viralize calls if they're out link optimization is available static of polymorphism uh it does not involve any IND directional virtual calls it is unlikely to inhibit compile optimization so but it's suitable for static program Parts only um short the summary for performance considerations yes so it is important to reiterate again that the design decisions they are always should be based on uh measurement in the specific settings where the Cod will be really running behavior of tooling can be different yes so the tooling that is used in the project it should always be considered in a concrete project yes so the uh of course runtime and uh size overhead it depends on compiled optimization so the proper options they always should they should be used the proper compiler options yes and compile ER optimization can be inhibited by IND direction that what we saw um those compile time solutions they do not introduc in Direction uh if we not explicitly uh in if we are not exp injecting the function pointers yes so we need to be careful here but generally the compile injection is not based on a direction and it is unlikely to block this compile optim the compile optimization effort and yes compile we can say that compound and polymorphism is preferred for decomposition of the functionality on some application hot path um I mentioned at the beginning so there was another talk uh test driven development of embedded and system level software for which some of this material was prepared it is more focused on test driven development of course and it has more details from test driven development perspective so if there is interest for that uh then please also uh refer to it uh that's all from my side uh thank you very much for attention and if you have any questions let's discuss them thank you for your talk this was really uh nice to hear about dependency inse sections and the various patterns for it and C code and comparisons um very interesting um if you have any questions that you didn't get answered during the talk I want to generally talk to Vladimir he'll be available on the Louch and this is kind of the last talk for today at the conference so um you know take your time and Vladimir will be in the launch for the next 20 30 minutes um if you thank you very much go there for your talk and with that I'm going to end um this live stream