hello everyone last episode we got a bit sidetracked creating the logic for this little display here which just takes whatever binary data we have and translates it into a more human friendly format I think it's going to have been worth the effort though because now when we work with things like the forward register that we built a while back we're able to actually see what data is stored inside of it so if we input one zero zero one for instance and then enable the store signal and pause the clock we can see the value 9 showing up over here now what I'd like to experiment with and try to figure out today is how we're going to handle taking data like this and moving it around inside our little simulated computer so that different components are all able to talk to one another so I've added in a second register here and I'm just going to finish connecting it up to the inputs and the clock signal quickly we can then give it its own store signal so that we can put whatever value we want in there let's maybe do 0 1 1 0 this time and I'll turn on the store signal pulse the clock and there we have it but now what about transferring data between the registers for example say we want reveal to take whatever is stored in this first register and copy it into the second in that case this register would be receiving data from two different places and so we'd need some way of selecting whichever data source we're interested in at the moment we have actually done something like this before if we just open up one of these forward registers and then open up one of the one bit registers inside you might recall this little construction we made as we can see this takes in two separate sources of data there's the current value stored in the flip flop coming in here and there's the input value coming in over here then if this store signal is off we can see that the fast data source is selected and the Second Source is ignored and the opposite would be true if the store signal was on so this is called a data selector or a multiplexer and let's quickly make a version of this that selects between two 4-bit values instead so we can again just use an and gate well four of them this time to zero out the first data source if the select signal is not off and another four to zero out the second data source if the select signal is off we then simply altogether the corresponding bits from the two sources and output the result that should work but let's be thorough and adjust it quickly so I'll put one zero zero one on this first input and 0 1 1 0 and the second and now using the select signal we can see that we're able to choose which of those we want going through to the output so super simple but extremely useful all right we can now head back to our two registers here and let's bring in our new multiplexer chip we can then connect up the output from register a as the first forward input and this data here as the second 4-bit input finally of course we'll need a new control signal for choosing which of those two sources should be selected with that'll set up we should be able to copy the nine that's currently stored in register a over into register B and so let's quickly try pulsing the clock and that seems to have worked of course we can still store whatever data we want directly into B simply by changing the select signal and running the clock again so using using a multiplexer like this is one way we could handle the transfer of data between different components but there's a bit of a problem imagine we have just four components Each of which needs to be able to receive data from any of the other three we could build a slightly larger version of our multiplexer to handle this so here the other three chips would all send their data to chip a and there'd be some selection signals to choose between those which I've left out here just for Simplicity then of course chip B wants access to all that data as well so it could have its own multiplexer and same goes for chip c and d as well the problem with this approach really is just the obscene amount of wires you're going to have running all over the place and while it's conceptually very simple I think it might end up being a bit confusing to keep track of what's going on so it'd definitely be nice if we could use a more minimalistic approach what we could try doing instead is creating a set of shared wires for transferring data called a bus these bus lines can run through the confusion wherever they're needed and any of the chips can read data from the bus or write data onto the bus for anyone else to read once like caveat there though is that while all the chips can read from the bus simultaneously only one chip can actually write data to the bus at a time otherwise there's going to be conflicting data and we'll look into that a bit more in a minute one solution to this problem would be to use a multiplexer we could have one big one over here and instead of any of the chips writing to the bus directly they could all send their outputs to the multiplexer which would permit only one of the data sources onto the bus at a time since there are four sources to choose from here we'd need two selection signals to cover all the possibilities and let's just wire this up quickly and then output the results onto the bus currently the data from chip c is going onto the bus I wired them up in a bit of a strange order but anyway we could change the selection signal here to let the output from Chip a through instead or from Chip B or lastly from Chip D this is a good solution I'd say but it is a bit awkward that we have to run all our wires to this giant multiplexer it would be really nice at least in terms of keeping our wires tidy if each chip could just put its data onto the bus right where it is to better understand the problem with this and how we might get around it I'd like to venture out into the real world for a moment and take a look at this little 4-bit register looking at its data sheet we have power and ground pins of course and then these here are our four data input and output pins there's also a clock input over here and a reset input here which we don't have in our simulated version but it just clears the data to zero then at the bottom somewhat confusingly we have these two pins together making up the store signal they both need to be zero in order for the store signal to be on and I'm sure there's a good reason for that but I have no idea what it is finally at the top are these two inputs which like the store signal are really just a single input and what it does well we'll get there in a minute first of all though I've got some wiring to do hopefully I'm selling the software key my grasp on this stuff is still extremely tenuous I've been thinking though about making some sort of series to explore the world of electronics in more depth because I do find it extremely fascinating so let me know if that sounds a little interesting in any case I've finished setting this up here so let's now use these tiny switches to enter some data then I've set the store signal to just always be enabled for this example so all we need to do is make the clock signal go from low to high and we can see that our data has been loaded into the register just to fully test that this is working though let's try entering something else like zero one one zero and clock that in all right that's looking good so now the first thing I want to do here is just quickly remind ourselves what these ones and zeros we're working with all the time actually represent these little green LEDs are all connected to ground at the top so the ones that are on must have been electrically connected to the Power Pin inside the chip meaning that a one just represents a connection to a high voltage somewhere around 5 volts in this case on the other hand then a0 represents a connection to a low voltage something at least close to zero volts so I'd imagine that the lights that are off should be connected to the ground pin inside of the chip we can confirm if that's actually the case by just grabbing one of the lights that's off and turning it around to connect to the power rail up here instead and we can see it does light up so it must be connected to ground on the other end this kind of output is called a push pull output because by connecting to power 401 or ground for a zero it allows current to flow in either direction which I guess is kind of like pushing and pulling electrons there are other types of outputs with various trade-offs but let's just focus on this kind for today so returning to the simulation for a moment let's say we have some chip that's outputting a one onto the bus Which as we've just seen is essentially connecting it to its power pin and another chip that's outputting a zero onto the bus essentially connecting it to its ground pin what we have now is a very low resistance path between the two which means it will get an excessive amount of current flowing potentially damaging some components and causing glitches due to unexpected data on the bus this undesirable stage is called a bus contention and in the simulation it's just represented with an annoying flickering to show you that something's gone wrong and the bus doesn't know what value it's supposed to be to solve this problem let's return to our mystery input over here all this does is simply allow us to control whether the outputs are enabled or not so I've wired up this button on the left to act as a disable outputs button and if I press that we can see that all the lights turn off inside of the chip all the outputs which previously were connected to either power or ground become essentially disconnected instead this third possible State neither one nor zero goes by different names such as floating or high impedance or tristated but the point is that if these outputs were connected to a bus they would no longer be having any effect on it and so some other chip would now be free to put its data onto the bus instead I'd like to take a very quick look at how this works so imagine that this here is one of the outputs from our chip the basic idea is that internally the output is connected to two transistors then if the chip wants to Output a one there'd be some logic to turn on this transistor here which provides a connection to the Power Pin on the other hand if the chip monster output is zero it would turn on the other transistor which provides a connection to the ground pin Ally if the chip is asked to disable its outputs then it will just make sure that neither transistor is on which means that the output is effectively disconnected because when the transistors are off they're going to be extremely reluctant to let any current flow through them just to demonstrate this a bit better because zero and disconnected look exactly the same here let's imagine that our output isn't going to a light but rather to the input of some other chip now what can happen in this disconnected stage is that some sort of electrical noise can come along and interfere with that input causing it to randomly float from zero to one or vice versa if we're outputting a zero here though for example we can see that that little bit of noise is no longer able to interfere with the input because we're providing this strong connection to ground all right hopefully that makes some sort of sense but in any case let's head back to the simulation where I've quickly programmed in a new type of built-in chip called a Tri-State buffer with this we can connect up an input and an enable signal and all this does is output whatever value it receives as input so either 0 or 1. unless of course the enabled signal is turned off in which case it goes into this third disconnected state that I've been hopping on about so just for convenience let's make a little chip that has an output enable signal along with four data inputs which it can then pass through four of these new Tri-State buffers I'll then wire up the output enable signal to each of the buffers and then of course to wire up their outputs this gives us a nice easy way to take our nibble which is the name for half a byte or four bits of data and disable it or enable it depending on whether we want it going onto the bus or not so let's save this chip quickly and we can maybe just call it our bus buffer then going back to our little test here let's try using that to replace this one big multiplexer so we can see which approach we like better [Music] now instead of these two selection signals we're going to need an output enable signal for each chip so that is going to require some extra wires but on the right side it'll at least be possible to give them meaningful names now I know I put these in a bit of a strange order here but I just wanted to be able to connect them up without getting too many wires crossed anyway let's try this out quickly so starting at the bottom I'll enable the output of Chip B then let's switch to D and then C and finally chip a so that's looking pretty good I'd say although one potential Pitfall with this approach is that unlike with the multiplexer we could mess up and have multiple chips trying to Output their data simultaneously related to that when I was reading the data sheet of that 4-bit register we were playing with I was interested to learn that it was designed so that disabling the outputs would take effect slightly more quickly than enabling them to minimize the chance of a conflict thankfully we don't have to worry about any of these subtle timing considerations from the safety of our simulation so let's try working with this three-state bus approach because I think it's going to make it a lot easier to stay organized especially in the future if we're working with more than just a handful of chips I'd like to test the setup with our actual chips though so I've set up some inputs over here starting with four data inputs then some output enable signals some other control signals and finally the clock let's create a 4-bit bus quickly and then we can grab one of our buffers and use it to allow this incoming data here onto the bus if the data output signal is enabled then let's also bring in two four bit registers which can get their data from the bus and also put data route onto the bus then to do some simple maths let's bring in our little ALU now this is a bit awkward because it takes in two 4-bit numbers so instead of using the bus let's make an exception here and just let it go its inputs directly from our two registers it can then put the result out onto the bus though okay there are just a few control signals that need to be wired up so I'll do that quickly we're almost running out of workspace here already so I'm going to have to make some more upgrades to the program soon but I'll worry about that later for now let's just connect the clock to our two registers and then it's time to see if this works so we can enter some data and output it onto the bus then let's tell register a to store that value and pulse the clock so that it actually happens all right then let's maybe try using our ALU to add the contents of the two registers together and store the results in register B here so first of all let's make sure that only the ALU is allowed to put its data on the bus we can then tell register B to store whatever value is currently on the bus and then to make that happen let's pulse the clock again all right so we've just solved the very complex math problem three plus zero thrilling stuff let's run the clock a few more times to just keep adding the value in register a to the value in register B [Music] okay we've ended up with 15 in here and now I want to try copying this value into register a so let's set that up quickly we want the output from register B on the bus we want to store it in register a and finally as always we'll pulse the clock everything seems to be working which is nice but for completeness let's also try storing a value perhaps 0 1 1 0 directly into the B register [Music] and we can see the value 6 is shown up in there as a final test I'd like to try subtracting this value in B from the value in a and then storing the results of that calculation into register a to do that we'll want the output from the ALU on the bus again and we'll need to tell it to perform the subtraction this time then we want that result stored in register a and with that set up let's pulse the clock one last time and there we have our answer so we've managed to build possibly the least powerful and most annoying to use calculator in the world meaning things can only improve from here that's all for today though so until next time cheers [Music]