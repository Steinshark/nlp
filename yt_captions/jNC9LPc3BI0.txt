I've got a question for you Sean how many things can a computer do at once yeah well I I feel like is I don't know if you've ever watched Qi where the big Bell goes up above your head and go you've got it wrong for viewers you've not seen as a quiz show where yeah that you you're lulled into answering the obvious answer but I'm going to say only [Music] one only one thing at a time well that's a great answer and um certainly was true in the sort of 80s there are different ways that computers can do more than one thing at a time there's a sort of human level thing where uh the computer is doing one thing at a time but it's switching between them so quick that you don't notice and so as far as you're concerned you've got your word processor over here you're playing your music and all that kind of stuff you're like hey it's doing all these things at once it's not right then modern computers have got actually got separate CPUs inside of them and so it can actually be doing two completely separate things at once because you've got one process are doing one thing another processor doing nothing that's great we're not going to talk about that today inside of one CPU itself so just a single processor with a single stream of instructions that's come down our little pipeline how many things can it do at a time and again you might think once well we have talked a little bit about some of the processes that are able to look and see if there are two instructions coming down one after another that aren't related to each other then actually I can hand them to two separate parts of of the chip so that I can do an ADD and a multiply at the same time or two ads if I've got two adding units or things like that and that by and large is how CPUs nowadays work so the laptop that I'm on right now talking to you on has actually got 10 independent units in each CPU and I have four CPUs in the laptop so in theory I could be doing 40 instructions like actually executing them at once and that's not even including the ones that are all queued up in the pipeline ready to go so that's one of the reasons that computers have felt and gotten faster over like the last decade or so even though you've probably not noticed that the speed you know the the gigahertz of the computer hasn't really gone up all that much you know we've sort of stuck at two to three GHz but somehow the computers are getting faster still and that's because they're getting smarter about doing more than one thing at a time so how on Earth can the computer do this right it's it's maybe true Ral if somehow you can look down the pipeline and see that there are two instructions coming that have been decoded and turned into some kind of representation of like what what I need to do um and one of them is an add with A and B and the other ones a multiply with d and e so like they don't overlap with each other maybe a very simple circuit can say well okay I can run those two things together but then as soon as something needs the result of the multiply or the result of the ad now suddenly the chip is like well how do I know when I can run the the next instruction because I've got this sort of tangle of instructions that may be dependent on each other and so today we're going to look at what might be going on inside the CPU and I'm going to a very simplified version of this first and foremost and then maybe we'll talk about some of the more complicated issues that we hit because it gets very complicated very quick but um I'm going to start with a sort of a motivating example of something that you might want to do we've been sort of doing Fibonacci to death with all of these various examples here so I'm coming up with something slightly different slightly more sophisticated as now moving into you know the late ' 90s early ORS what about if we wanted to get the distance between two points in two dimensional space something like that right the formula for that is like the distance or R for result is equal to the square root of the distance between the X's so X1 - X2 all squar plus y1 - Y2 the distance between the two points Y and I can't this is now turning into an episode of bad number file sorry and you can't even read my my handwriting there let me try and get it at least upright I must post you some green bar paper at some point you do need to give me some yeah yeah or I'll come and pick some up when I when I come and see you um so yeah we've got this this relatively um straightforward equation and this is basically a bit of Pythagoras but kind of reworked right exactly that yes yes you could rearrange this and work it out as being yeah as you say Pythagoras but it's the difference between two things squared plus the difference of two other things squared and then the result of that is all square rooted and we get the distance and maybe we're doing some kind of game we want to see how far away the player is from the thing he wants to pick up and then if he's below some threshold we going to give him 100 points or something like that it's only motivating in as much as I'm interested in like computer graphics and and games and things like that it's not really doesn't really matter what it is so what first of all we need to turn this into something that our our CPU can execute a sequence of instructions that it can execute and each each I'm not going to use real um assembly this time around we're just going to sort of do abstract type stuff just to get the gist of get Pudo assembly pseudo assembly exactly we've just invented here first um so um so the rules of my assembly are that there's always going to be each step has one output and maybe two one or two inputs to it and it has an operation associated with it and I'm going to give myself an infinite amount of registers or variables or whatever and I'm just going to assume that X1 X2 y1 and Y2 are things that are already existing and have been the program before this part has provided them and put them into registers called x1x2 or something like that okay so again very pseudo so the first thing I need to do um and now we're going sort of now we're doing a compiler we're writing our own compiler by you know in our head it's like well what's the first thing you would do as a human well the first thing I would do is I would do the inside of this bracket here and I'd say some kind of thing like temporary T1 so I'm just giving a temporary name to the result of X1 - X2 T1 = X1 - x 2 that's this part here the the inside of the the parentheses and I'm going to say T2 is T1 * T1 that's squaring that value that was inside the first X1 - X2 so T2 is essentially X1 - X2 all squared we're going to do the same over here for y so T3 = y1 - Y 2 T4 = T3 * T3 and then finally well not finally penultimately it's always dangerous to use words like finally isn't it it's like and next next yeah next is best right yeah yes T5 now I'm going to sum those two things so what have we got here we've got the X1 - X2 squ is in T2 y1 - Y 2 is in T4 so T2 plus T4 is what now the sum of those two things and then finally R is going to be equal to the square root of T5 and I'm going to assume our our CPU can do a square root even though that's one of the more complicated things you might do modern CPUs really can do but so what we've got here we've got this array of 1 2 3 4 five six pseudo instructions pseudo assembly instructions M and um a naive processor such as we've been discussing so far would see these in sequence one after another and so it would do let's just say one tick it does the X1 - X2 next one does squared next one Yus Y 2 next one's doing the square uh T5 is adding those two things together and then finally we're doing uh the square root so assuming some mythical machine that can do each of these in one cycle each this takes six CPU Cycles mhm which is a hard thing to say uh but there is some parallelism in this there are actually things that we could be doing at the same time so for example if we had two uh arithmetic units if we had two parts of the system that could be doing either adds or subtracts or multip wi then um you and I know that we could do X1 - X2 at the same time that y1 - Y2 they're totally independent of each other but they're they're sort of separated in space here by quite a few instructions so you know you'd have to be quite smart this our pairing thing that we talked about with uh one of the earlier videos the Sega Dreamcast which is my favorite game console to work on had an Hitachi sh4 processor that could do two things at once wouldn't work because T1 instruction and T2 instruction can't run at the same time because the t2 needs the results of T1 so it would stop waiting and it might be able to do something clever here but we're going to ignore that for now right so this is time to get a prop out Hey so uh thankfully there are six instructions here and thankfully my children who no longer use this have a whiteboard that's got uh the days of the week on and then that gives us one and all the dog hairs excuse me that's fine so we're going to assume that those instructions which which I'm going to put over here so I can remember what they are this genuinely is like a whiteboard or a scoreboard um in in the literature I'm actually mixing two things together there's a thing called a reservation station and there's a thing called a reorder buffer and we're going to be sort of looking at both of those combined just because it makes it easier as a human but in terms of the real Chip real estate there's other clever things going on but what's going to happen is as the instructions that are coming down the pipeline have been decoded as they roll off the end of the the the production line just after they've been decoded they're put into uh a sequence of tables rows so I'm going to write them in like this so T1 is here the operation so this is register the result register where the answer is going to go this is the operation that needs to be done here are the two inputs and a state over here tells me whether this row is done or what what state it's in so to start with T1 is going to come in it's going to have an operation of subtract input one is going to be X1 now we already know what X1 is so let's just say what is X1 let's say X1 has the value of 5 X2 has the value of 10 y1 is 1 and y 2 is two so we actually know the actual values of those coming in so as we go into the beginning of writing into this table um if we already know the numbers instead of putting the name of the register here we're going to actually put the values into this little table slot here so um as T1 comes in so X1 - X2 so input one is five input two is 10 and this the state well this instruction is actually ready to execute because we know where the results going and we know what the two inputs are so this is ready I'm going to put ready in this I'm I'm going to go through the table and do all six of these at once um realistically speaking these this is happening as they're falling off the end of the pipeline but the pipeline runs so fast that we can actually get lots of them into this before the um the the robots again I haven't really spoken about the robots this time the robots with their abacuses start looking at this table to say hey is there something for me to do yeah which is going to be the next step so T2 here is going to be uh the operation is multiply input one well we don't know the value at the point at which this is coming off the end of the table we don't know the value of these things so I'm going to write T1 as a sort of placeholder to say hey when we know what the value of T1 is um and then T1 is the other operand for that and then the state for this one is waiting like we're waiting for the result for the inputs to become ready and then we're going to go down the rest of these T3 minus y1 is 1 Y 2 is two this one's ready oh look you can already see now that we're starting to discover things that could run right now T4 is multiply T3 T3 waiting uh T5 so this is adding the result of and again T4 and T2 and this one's waiting and then lastly the result R um square root and it just has one input which is T5 and then there's no input here this's also waiting okay so assuming that this is all coming off the the conveyor belt and this is filled in are however many robots that we've got that can use their Abacus or whatever uh to do the work their job is to just look at this and look for anything that's ready and then say hey I'm working on that now and take it off um and you can see that it doesn't matter which sequence they're doing they could actually start with T3 if they wanted to even though that was much later in this in the in the Stream of instructions they could start working on that and so what happens when they work on it so let's assume um our two robots one picks T1 because it's ready and so now it's being you know worked on oh when I'm can't work on this but it's like you know being processing and this one's also being processing by another robot they're going to go off and they're going to do so what is the result of T1 uh T1 is 5 - 10 which is of course minus 5 which is an awkward number for me to have picked so when the first instruction has completed two things happen so the robot who has this minus5 now knows what the value of T1 actually is so he Now searches through the whole rest of this table and anytime he finds a T1 he replaces it with the actual value that he's now found so now when uh this one comes in we put I'm going to cross it out and hopefully you can do something nice with with Graphics afterwards we're going to put minus5 in here and minus5 in here and then having done that we check to see are we still waiting for anything in this instruction if we are we leave it waiting but if not it becomes ready so this is now ready because we've now written in all of the values MH that we need we're waiting for yeah we don't need to do anything else at this point right um so now the robot has finished you can say this instruction is completed this this one has been done so no one needs to look at this ever again and he can go off and search for more work and of course if he starts immediately searching for work he'll discover that now he can do this second instruction but simultaneously the second robot has finished the T3 he's done uh 1 - why did I make everything negative that was a terrible idea so he's done 1 minus 2 this instruction is now complete anywhere I see T3 I can now replace with minus one so I'm going to do minus one minus one uh has this become ready yes it is so this is now ready and again now he's finished he's going to look for work and the only piece of work he can do is this one assuming sorry now this guy would I suppose the first robot would have immediately picked this one up and said yeah he's working on this one second robot goes okay now T4 is ready mhm oh double Yes W is working on it i' keep to my own consistent view here so um I now I'm going to try and remember how many clock Cycles we've been ticking so the first one we completed T1 and T3 together the second one we're doing T2 and T4 together uh so um let's assume our uh Second Step uh the - 5 * -5 is + 25 isn't it yeah so we know now the value of T2 is 25 so first robot finishes doing his multiplication comes in replaces T2 with 25 M is this instruction ready to go no we're still waiting for T4 okay and now actually if we the the the robot was looking for work he hasn't got anything to do nothing else is ready they're either being worked on by the other robot or or there's um or we're waiting still so this is kind of not being able to do anything useful this but and then that's one of the reasons why you know I said the laptop has 10 of these units in there most of them are sat idle most of the time because there isn't that much work that isn't interrelated with it itself um but our second uh robot finishes -1 * -1 is + one hopefully um so he writes in one here uh this one obviously now is ready this instruction is ready it's ready one of the two robots you know coint TOS uh picks up this piece of work works on it gets the answer 26 puts the answer 6 down in here for the T5 and then we can go and do our square root and of course once that's finished we've got the value of R hooray so obviously I've picked something which is hopefully motivating because it's a real world thing that we might want to do and it was just small enough to fit on my little board here with all the horrible SC scribbling and scrolling on it um yeah so there's an interesting sort of second part to this that is obviously we've got this table of six um I've written C for complete and I should have written C for complete and all these other ones as we completed them here there's a kind of final step to this so we've done all these things in in a higgledy piggledy order and you could imagine that in modern CPUs this table is not 6 entries long it's something like 100 150 entries long so they can have up to 150 instructions in flight and obviously there are much more complicated dependency change so like a square root for example will take quite a long time quite a lot of sequence um uh clock ticks before it's ready and you could imagine if the program continued Beyond here and we were like doing the squ um the excuse me the distance of some other point then we could start doing all the ads and squares and ads and squares for lots of other things while we're still waiting and maybe you're summing all of these these distances up at the end and then suddenly that L that instructions waiting for all these square roots to finish is stuck there this table is completely filled with things that have been done but not completed yet um not not retired which is this last stage so um in order to finally get everything back in the right sequence so that the the outside world doesn't see things happening in the wrong order there is a final process and now we've added a a new robot on the end of the very very end of the production line um and he's responsible for going down this table in the strict sequence that the program was written and committing the values of T12 maybe the permanent register file inside the CPU these are like internal to this kind of in inside side part this might be an instruction that writes to memory I've I've glossed over that CU that gets very quick complicated very quickly with aling and stuff but um so the retirement stage effectively commits each instruction to say now it's been done and that has to only be done in strict program order and if there's anything waiting we have to stop there until that instruction has completed the important part of this is um what I've written out here is just a sequence of instructions now as we've talked about as you started with this whole discussion um Branch prediction is a really important part of what allows us to fill up this Pipeline with a bunch of instructions without necessarily knowing ahead of time which way the pipeline is going to be going which the flow of in instructions are going to be going and of course I haven't written any branches in here because it makes my life a 100 times easier but let's just assume one of these instructions was a branch so ignore what's on here for now let's just assume this third instruction down here was a branch that was predicted to be taken which means that the fetcher would have pic uh would have fetched the instructions for where the branch went to in this slot and then the one after that and then the one after that as we're running down here when we actually execute that Branch we have to check to see whether we got it right or not if we got it right no harm no foul we just carry on fine we're done but if we got it wrong we know that we you know previously we talked about like throwing everything off the production line and um and saying okay we we're we're done now we have to start again well we've already potentially done some work after the branch yeah right because this you know this maybe this Branch was conditional on the result of a square root in which case it's waiting around for like a 100 cycles for that square root to finish and and we don't know whether or not we got it right or not but meanwhile we've carried on past it and we're doing all this extra work and that's where this retirement stage comes in really handy because we haven't retired anything after the branch yet because we only strictly retire things in the order they came in once we know that the answer is correct and so if we predict the branch wrong we just go oops we do throw off the pipeline the bit in front of us the bit that's fetching it all that gets thrown in the work but all of these sorry thrown off the production line into the into the bin and we start again fetching but also any of these further instructions that are after the point of the branch have to be discarded but that's fine because they never got committed anywhere they never got written back out to memory they never got written out to the real register file and so we can throw all that work away pretty straightforwardly and then just carry on with the newly fetched version once the pipeline fills back up again in this new slot afterwards so this table this reorder buffer and this whole idea of committing as we go forward gives us the mechanism by which we can speculate which instructions are going to be run and then undo them because it's as if they never happened if we never committed them even though we've done the work for it a processor that can do more than one thing at a time is called a super scaler processor and then this which is a bit like that the the Hitachi sh4 thing that we talked about with in one of the earlier videos and it's like some of the earlier pentiums could do like two things at a time um but now we've added this this capability to our system this is called outof order execution it allows multiple units to happen it allows multiple things to go on and more importantly the actual execution part can happen in an arbitrary order provided it U follows the rules of don't run an instruction till you know the inputs are have been completed and as long as nobody outside of the CPU ever notices that this uh this kind of reordering has happened because the external visible results come out in strict program order we still get the benefit of everything without like having strange weird time traveling things going on this is a bit like the kind of looking inside the Sausage Factory most people put you know see the food go in one end and see the sausage come out the other end but we're looking inside the sausage to see how it works right exactly right exactly right and the most of the time we don't even know that this is happening we don't need to have to care that it's happening um as a programmer even someone who spends a whole bunch of time worrying about the performance of their code you generally don't have to worry about this kind of stuff but it's absolutely fascinating the the reason where why it became sort of more on people's radar is that what if sake of argument what if there was something that couldn't be undone that was sort of ahead of us in the pipeline um what if there was something that we could view on the outside world even when we roll back and went oops the branch predictor made a mistake we rolled back to this point um but you know we ran some code that really we shouldn't have run the predictor was was was wrong um and it turns out there is one thing that isn't rolled back exactly perfectly by this system and it's to do with the way memory works and the way that cashes work which we haven't talked about in this series but that because you can measure externally the the um the performance of the cache and see if it's faster or slower depending on whether it's been used recently and if one of these instructions ahead of you read from a cache then that would speed up something that you would see later on you've kind of primed the cach and that can't be rolled back once it's been pulled into the cach by a read that that you shouldn't have done then um that's that's a sort of permanent effect um now you can suddenly see how uh things like Spectre uh uh which the specula speculative attack on security if as long as you can coers the branch predictor into letting you temporarily mispredict go the wrong way run some code that you weren't supposed to run supposedly it's all undone but if you can contrive it so that um the uh the bit that was running that you shouldn't have run has a noticeable effect in the cache then you can take advantage of it and run it we should see the message hello so it's getting the data various things and we see here hell therefore we can calculate the lighting effects and it's why I'm able to have a shadow here because what we would do