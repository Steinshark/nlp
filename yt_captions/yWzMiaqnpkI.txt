Hello and welcome. I'm James Murphy.  And welcome to the mind-bending world of Python metaclasses. Metaclasses let you break barriers and assumptions that you had about Python. Consider the example of function overloads. If you've spent a little bit of time with Python, then you know that Python doesn't have function overloads. Here, I try to define this function f three different times. But actually the second definition just overwrites the first and the third overwrites the second. So, at the end here, there's just one copy of f, the last one. You could see this by trying to call the function with just one argument. If you do, you end up with an error. The typing module has a decorator named overload. But that doesn't actually solve the problem.  So, I would still get an error if I were to run this. But what if I told you that with a metaclass you can actually get true overloading. Just to show you how awesome metaclasses are, that's exactly what I did. Now, when I run the example, if I call f with an int, it calls the int overload. If I call f with a string, it calls the string overload. And if I call it with multiple arguments, it calls the two argument overload. I know what you're thinking. This is nothing short of mind-bending, face-melting wizardry and you're not totally wrong. Before we can understand this example, let's go back and understand just what is a metaclass in the first place. Oh and by the way, I'm giving out some professional licenses to PyCharm that's this editor that I always use in my videos. Be sure to stick around at the end to see how you can get a chance at winning a professional license for free. Every object in Python has a type. 42 is an int, hello is a string, the empty list is a list and an instance of my class A is an A. Classes allow you to make instances of that class. But classes are also objects themselves. So, what's the type of a class? In all of these examples, the type of the class is a type which kind of makes sense. And just like 42 is an instance of an int, int is an instance of a type. At runtime, I can use int to create new integer objects. And just the same, at runtime, I can use type to create new type objects. By the way, if you're wondering about what's the difference between a type and a class, in Python 3 there's no difference. So, If I say something is a type or something is a class, I mean exactly the same thing. As concepts of the language, type and class are identical. But literally in the language, they mean different things. class is a keyword which you use for constructing types. It turns out that a class definition is actually just syntactic sugar for a specific way of calling the type constructor. Instead of using a normal class definition, I could equally well call the type constructor directly doing something like this. I just need the name of the type, a tuple of bases that it's inheriting from and then I run the class body and then store those definitions from the class body in a dictionary called the namespace then I feed those things into the type constructor and out pops a new class A. A slightly more accurate picture would look something like this though. Again, I need the name and bases of the class, then the namespace or class dictionary is created using this double under prepare method. The body of the class just gets treated as code which gets executed directly in this new dictionary namespace. Metaclasses are a point of customization in this class creation process. A metaclass is just a class that inherits from the type class. That means, just like type, the job of a metaclass is to create classes. By defining our own metaclass, we'll be able to customize things like how the class namespace is created using prepare or things that happen in the init or new methods of the metaclass. The default metaclass, if you don't specify, is type. So, by changing the metaclass of a class, that means we're just going to substitute our metaclass in everywhere that you see type here. Here's the simplest possible example of metaclass. Here, I just have a blank class. As we've already seen, if I create an instance of the class, the type of a is capital A, the class. But the type of the class is type. Now, let's change the metaclass. A metaclass is just a class that inherits from type. You can change the metaclass of a class just by specifying it as a keyword argument in the class definition. So, the type of capital A is now my metaclass, instead of type. This gives another way to think about what a metaclass is. A metaclass is just the type of a type or the class of a class. If you want to know at runtime what's the metaclass of a class, then just call type on the actual class. Calling type on an instance little a, tells you what class created the little a. So, little a was created by big A. Similarly, the big A itself was created by the metaclass. So, type of big A is the metaclass. Here's a simple example. LoadTimeMeta automatically adds a new variable onto the class when it's created. It just computes how many seconds after some initial base time the class was created and then stores that as a class variable. Whatever we do in new, we do eventually need to make a super call and pass all of the arguments up to type so that it can actually create the class. And here, we can see that we actually do have the class_load_time automatically added into the class. If I didn't have LoadTimeMeta as the metaclass, then this would just crash because that wouldn't be defined. Another extremely important property of metaclasses is that, they are inherited. B inherits the metaclass of A and therefore it automatically has its own class_load_time. Notice that, the class_load_time is different than the one in A. So, it's not just looking up the value that was in A. This is an important distinction between how metaclasses are used and how something like a class decorator would be used. You could use a class decorator to add something simple like this: just a class variable onto the class. But you wouldn't be able to make that property inheritable. If you're not doing something that's supposed to apply to a whole hierarchy of classes, then there's a good chance that it could just be done using class decorators. So, what's an example where you would want to modify an entire class hierarchy? Well, how about a familiar example: abstract base classes. Here's a stripped-down version of how abstract base classes in Python actually work. Basically, you just inherit from ABC and then you mark some functions with abstract method. As long as there is at least one function that's still marked abstract, you're not allowed to create an instance of the class. So, I wouldn't be allowed to create an a because f and g are abstract. But then I define class B that inherits from A and defines concrete implementations for f and g. So, I would be able to create an instance of B. First, this abstract method decorator. Well, all it really does is set a secret attribute called isabstract equal to true on the function and then return it back. Then in the metaclass, we override dunder call. Dunder call is called whenever you try to create an instance of the class. The default implementation of dunder call is just going to call new to create the object and then initialize it using the init method. In ABCMeta, we just change that. First, we get a list of all the methods that are still marked abstract and then if there are any that are still marked abstract then we just refuse to create an instance. Otherwise, we just use super to call the normal instantiation process. Another common thing that you'll see is, creating basically a blank class that does nothing but inherit from the metaclass. Doing this allows your users to inherit from that class to change the metaclass without even knowing it. It's mostly just a convenience factor. The ABC example was kind of mundane. All it did is prevent instantiation of a class. It didn't really modify anything during class creation. And that's how a lot of metaclasses are. They do just pretty mundane things. Metaclasses alone are not this big scary thing that you have to be confused about. So, how did metaclasses get their face-melting, gut-punching reputation? There's no limit to what you can do with metaclasses. So naturally, they start to harbor all of your most mind-bending ideas. So, let's get to it. How do I add function overloads into Python using a metaclass? The key to all of this is the prepare method. During the creation of a class like A, the body of the class is executed. And the local variables that are defined in the body are saved into a dictionary. If you define a prepare method, then its return value is used as that dictionary.  In a normal dictionary, if I set f to be this function and then set it again to be this function and then set it again to be this function, at the end of it, it would just be this last function. The value of f would just be this last thing. But what if I created my own dictionary that when you set a value multiple times, it doesn't just overwrite the previous value. Instead, it creates a list of all the values that it's seen. That's the basic idea of this overload dictionary. So, that's what I do. First thing the overload decorator just sets the secret value dunder overload to true. Then in the overload dictionary, if it sees something with dunder overload equal to true, it's going to store those values in a list. I actually define my own OverloadList which is just used to tell the difference between whether someone was just trying to store a normal list as a class variable versus if someone's trying to overload functions. The first time that I try to set a value for a given key in the overload dictionary, I either just put in the value as normal if it's not marked as overloaded or I put it in a singleton overload list. If I try to set a value for a key that already exists in my overload dictionary, and that key is associated with an overload list then I just append the value to the list. So, every time I define an overload function f, it just gets appended onto this list. If I try to set a value in a key that's not associated with an overload list, then I just overwrite it like a normal dictionary does. Here's how you could use an overload dictionary. Here, I define an overload function f and then I just set some values in the dictionary. So, I set the key a to be two different values. But in the final dictionary, it just has the last value because none of these values were marked as overload. Since f is marked as overload, when I add it to the dictionary twice, instead of overwriting the previous one, it creates a list and keeps track of both of them. So, by changing A's metaclass to OverloadMeta and marking the functions as overload, now when I execute the class body, all three of those definitions of functions are going to be stored. So by using the overload dictionary, I can keep track of all the functions but they're just stored in a list. So, at runtime, how do I actually call one of the functions? That's what new accomplishes. The namespace that gets passed to new is going to be this overload dictionary that was created in the prepare method after the body of the class has executed. What I can do is just look through the namespace and replace any overload lists with overload descriptors. Descriptors are what famously allow you to quote own the dot in Python. A descriptor is any class that defines a dunder get, set or delete method. If you set some value of a class equal to a descriptor, it changes how gets and sets on that value work. If I create an s and then execute s dot some_val equals 5, it'll actually call the descriptor's set method with the instance being s and the value being 5. Similarly, s dot some_val will call the get method. If you've ever wondered about how @property works, this is exactly what it's doing. So, a descriptor will let me intercept attribute access on a class. So, let's make an overload descriptor. When you try to look up an overload descriptor, it'll return to you a callable thing that knows how to pick one of the functions in the overload list. The overload descriptor takes in the list of possible function overloads. It also stores the signatures of all those functions using the inspect module. When you try to access the overload descriptor, I'm going to return some kind of object that's bound to the instance that knows about all of the overloads. I have to split things up into another class because attribute access the time when you access this function doesn't have to be the same time when you call the function. This acts exactly the same way that normal function lookup behaves. Here, if I have a class A with a function f, I can assign a variable func to a dot f. But if little a is an instance of the class and I try to store funk equals a dot f, then func is going to be this bound method. This bound method just remembers the little a so that when you call it, it calls basically a dot f with whatever arguments you pass in. When you construct a bound overload dispatcher, it just remembers the instance and a bunch of other things like which overloads and their signatures. When you go to actually call the dispatcher, it uses some algorithm best_match in order to decide which of the functions in the overload list is the best match. Then it goes ahead and calls that function with its remembered instance and the same args and keyword args. I just did the simplest possible thing for finding the best match. Basically, loop over all the possible overloads, try to bind the arguments to the signature and the first one that passes and matches the types then I just call that the best match. So, let's see it in action. A is a class with metaclass overload meta. It has three overloads of the function f. One takes an int, one takes a string and one takes two arguments. Looking at capital A dot f, we see that it's an overload with three functions in it. But for little a dot f, it returns a bound overload dispatcher. So, this object remembers little a and when you call it, it will call one of the three functions with little a and whatever other parameters. When I call little a.f(1), it calls the int overload. a.f("hello") calls the string overload, a.f(1, 2) calls the two argument overload and a.f(None) doesn't match any of the signatures so it raises a no matching overload exception. Well, as you could probably guess, using descriptors and checking signatures and type checking at runtime, it's a big slowdown. Let's compare an overload class versus just a function that checks its arguments and does two different things based off of that. In this case, using this overload framework is basically causing a 1.5 times slowdown. So, that's not very good. If I change the implementation to something quick like just returning 0, then it turns out to be 81 times slower. So yeah, doing all this signature inspecting and type checking at runtime is extremely expensive. Now I know the overload thing was the coolest part of the video but I can't let you go without letting you know about another application: Code Generation. This is not how data classes are actually implemented in Python. They're implemented using decorators. But here's just an example of another way you could do it. Let's define a DataClassMeta(type). When you construct a new class, it looks for any annotations on the class. Then it makes an init function. By that, I mean it makes a string which is the string representation of the init function. So, I make the literal code text from this make init function based off of the annotations and then I just go ahead and execute that code. That allows me to do something like this where I just define annotations on a function and then it defines the init function for me. The possibilities with code generation and reflection are basically infinite. So, I'm not going to get much more into that. But I just wanted to wet your appetite a little bit. Alrighty. That's all I've got. Stick around if you want to hear the rules for the giveaway. So, I'm giving away two professional licenses for PyCharm and two professional licenses for CLion, their C and C++ editor. In order to have a chance to win you must like the video, you must be a subscriber of mine and you must make a comment with either #python #clion or both in the comment. It must be a top level comment, not a reply to someone else's comment. You can post multiple comments. But doing so isn't going to increase your chances of winning. Winners will be chosen randomly one week from the date this video is posted. Good luck.