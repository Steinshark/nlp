uh good afternoon everyone uh as philly paris said my name is david zalewski and uh i will be talking today about how to pass and how to return uh it's you know the whole talk is more of a free exploration of how compilers see the objects uh and how they pass them in between different functions whether it's uh passing as an argument or whether it's returning from a function the talk is also about how we as programmers could use those insights or how we can use the knowledge that comes with with the knowledge of how compilers work uh to program better and to optimize the code a bit better so it's a fairly technical talk uh it's going to be a lot about compilers about uh the memory organization about the apis uh for this talk uh i used a couple of compilers so i used the three major actually four major compilers on the market uh all of them in the 64-bit architecture compiled for x86 so for the intel architecture gc clank and icc uh running on linux and microsoft of microsoft compiler compiling for windows and through windows 64-bit architecture and of course i use compiler explorer for it so all of the examples were compiled with the maximum optimization setting and with the newest standard with the c plus plus 20 standard in mind now there are so many ways of passing to a function and returning from a function right uh you can pass by value also what's called by passing by value uh you can pass by reference or by a pointer by an r value reference there are also constant variants of all those passing possibilities so you can pass by accounts reference const rv reference which doesn't make much sense but you can do it nevertheless and actually you can do the same with returning right you can return by valuable reference you can also qualify those references or those pointers to constant whatever you want now let's start with a bold statement everything is passed and returned by value in reality that's how the compilers work and that's how the computers work now what's a value might differ it's either a full binary representation of an object that you have in mind a memory address of a binary representation of an object commonly known as a pointer or as a reference but under the hood it's just a pointer so thus an address of a binary representation whether it's that one or another it's always passed by value so that's how the computers work under the hood right now before i start i have to do a small refresher on the memory model and on the api so we are on the same board when it comes to how computer works and i'm gonna start with a very simple example when you have just two functions a main function and that function for simplicity uh i am talking about the system 5 api so the api that's used by linux and unix everywhere basically a 64-bit version of it and in this api or in for these compilers that work like this for long has eight bucks which is pretty important because it simplifies our thinking so the main function declares two variables and initializes them a and b they're both long so they occupy eight bits now the conventional wisdom will tell us that in such a case the compiler will emit code which will put those constants on the stack a and b in this order and a short disclaimer normally the stacks grow downwards but for this talk i let them go upwards because it's just more natural to think about stacks growing upwards than downwards so the compiler is going to emit code which will put those two variables stuck next comes passing the arguments to the function and to pass arguments function in the system 5 api you are gonna put those values into the registers into the rdi and rsi register 19 and 23 are going to get copied over there now in the next step the function is going to be called and since it's a pretty easy function the arguments are already there basically it's going to be like if it's super optimized maybe two three instructions depending on how how well you are doing uh the result of calling the function so of adding those two numbers will go into the array x register with the return register so 42 is going to be stored there and as a final uh the compiler will emit code that will initialize the sum variable and again the sum variable will be put on the stack so it's gonna end over there and for now i'm ignoring printf it's pretend it's not there now that's how the conventional model works uh in reality it's going to look a bit different so when you compile this piece of code with any kind of optimizations turned on be it 01 or any higher the code is going to be something like this the variables a and b are going to be initialized directly in the registers so there will be no stack usage whatsoever rdi and errors i are going to be in the registers the sum function is going to be inlined and since it's inlined the addition will be just one instruction and the result will go directly to the register array x and finally now we have space for printf uh after some shuffling of the registers the registers will be prepared for the next function call to the printf and the number to be printed is going to be stored in the rsi rdi will hold the address of the formatting string and array x will hold the number 0 which is the variable arguments to the printf and the function will be called now things get more interesting when you deal with what's called oversized object so those are objects that cannot be passed through the registers because they are too big they don't fit in one or two registers and on microsoft or for windows api it's actually older objects the size doesn't matter as long as it's greater than one it cannot be split over registers when it's bigger like in this case we have a structure vector 3d three long variables inside so the total size is 24 bytes and we have a function which both takes two arguments by value and returns by value now the rest of the code is exactly the same as before so i declare two variables two vector variables and i call the function which directly initializes uh a sum variable in the main function so what's the compiler going to emit this time now the variables are definitely going to be stored on the stack so v1 and v2 are going to land on the stack there is no other way they're too big for registers in the next step the compiler will create the sum variable also on the stack and the address of the sum variable will be passed in the rdi register to the colli so our function our sum function will get us its first argument the address the return address actually where it should store the result this is what happens when this object is too big to fit in the ras register in the return register so you have to basically pass the address of where the function should store the result next the copies will be made of a and b uh on the stack because those variables are going to those arguments are going to be passed on the stacks and they're just you know simply copies being made there is no other way around it and finally when the sum function where the sorry add function is called it's going to add both vectors a and b arguments store the result in the return object which address was passed to it by the main function and also stored a result store the address of the return object in the rx register this is by convention despite the fact that the caller knows where the return object is because it has the address of it it's the address is still basically copied and returned in the rx register so that's how it works and it works very similar on the microsoft architecture so this is your memory model and api 101 for today's talk uh generally speaking on linux and or unix you can pass up to six integer or pointers arguments in registers and you can also pass bigger objects in registers like those that are for example 16 bytes long as long as there are trivial objects microsoft is a bit less you can only have four registers which you can use for passing arguments the rest has to go on the stack all the oversized objects everything else also goes on the stack and non-trivial objects so those that have user-defined special member functions also go on the stack you cannot pass them through their registers anymore the return value always goes into their error ax register and this is true both for system five and for microsoft x64 a small remark if the object that you are returning is too big to fit into the array x then the return address or the address of this object is going to be passed by the folder to the colli in the first argument so the first register in the argument let's say q is going to be used for the address of the returned object and that's the end of the intro now let's go to to the mid of the today's presentation and we are gonna start word returning by value now returning by value conceptually is quite easy right you have some function and it returns a value and this is the simplest possible case notice so we have a return object we are talking and a return object is something that the function returns and it's actually initialized with what's called what's known nowadays in c plus plus with a pr value so the return object here mark with some type it's somewhere there is initialized with a pr value there is directly the arguments or the object itself is part of the return statement and further the return object of the function is used to initialize some other object the color side right now the conventional wisdom or basically that the mental model that you have to that you need to have when you see something like this the old mental model is something like this in the return statement some object temporary is created now later on it's either copy or move into the return object and finally when the function returns to the caller it cop it's copied one more time to initialize the object on the color side now this is the old story it's it's not like you know a new discovery that it's way too many copies there are two copies created in this scenario uh and this shouldn't be the case and already years ago there were compilers which could optimize those copies away this is a piece uh michael tiemann uh from the 90s where he already mentioned that at least two compilers that he then knew one of them being seafront their one gnu c plus plus could optimize away the copies so they could basically realize that the temporal shouldn't be there and place the newly created object directly at the address that was passed to them by the caller so something that you've already seen on some slides previously and now the trick was uh as uh mentioned by scott meyers in more effective c plus plus again 90s to return the constructor arguments instead of objects so what scormers here meant is that you shouldn't return named objects that you create in your function you should return uh basically an object directly so you should return it what's nowadays known as a r value he called it returning constructor arguments and in modern syntax it looks more or less like this like you put garlic braces and you it really looks like returning just the function the constructor arguments now to test the hypothesis that it truly works and to show how it really works i have two different test types or i prepared two different test types and they're quite different from each other the first one is the trival test type it's a trivial string which is so i mean it looks like a c structure almost right it has a length and as an array as a member and it's only trival it's also an aggregate uh it's also oversized so it's definitely bigger than what can be passed comfortably in the registers uh what's worth about it or the worst points a point about it is despite the fact that it's trivial it's also very expensive to move or in fact it's impossible to move you cannot move it it can be only copied right there is no really cheap move for it so let's see how the compilers perform on a very simple task of returning such an object or actually and initialize a new variable with it so i have a new variable string variable which i want to initialize with the return value with the return object returned by my colleague now compilers are smart here so compilers when they see this piece of code will prepare a piece of stack which fits the string variable and pass their address of this object on the stack to the collie so to the red value and the quarry will directly initialize the return object in place without any temporaries on the way now all compilers agree the object is created by the colli directly on the stack at the target location there is a full return value optimization full copiation now all compilers besides the microsoft compiler and and it's really true now msvc does something else and it kind of it's not shocking but it's a bit weird msvc misses one of the optimizations it creates two objects on the stack one for the string variable and that's correct that's what the other compilers also did but it also creates a temporary object t1 and this is the place where the return value will go so in a way it does exactly what michael mentioned in in c plus gems right it's uh it passes an address over uh of the place where the temporary or where the return object should be created as it should be as it should be done now the colli creates the object in this location because that's what it's told to do and then returns to the caller and unfortunately the caller performs a full binary copy of it now this is expensive here it's not that expensive it's only 40 bytes and using the xm the mmx registers it can be really done very quickly but it's expensive nevertheless imagine that this object was much bigger like hundreds of bytes it would take time so the table which i'm going to build while talk looks like this for a trivial object that's very expensive to go to move and for very simple case when i'm basically returning a pr value all the compilers besides msvc perform full copy slash move elision there is nothing happening there besides the last one now the second test class that i'm using in this talk is a non-trivial test type it's again a string and it's a kind of a string which you will teach to your students when you teach the basics of of c plus plus uh it's a dynamically allocated string or it uses dynamic memory uh allocation to allocate a car array it also has a size inside which you can see there and it follows the rule of five so there are all the special member functions are user defined and perform a full copy estimate constructor or assignment construction and there is a destructor uh so this is a non-trivial test type it's not an aggregate it's non-trival but it's very cheap to move it's only 16 bytes and copying the 16 bytes is enough to move the object right let's see how this one performs or how the compilers perform on this object now if i put the same code to the test as in the previous case luckily all the compilers do wonderfully so all of them will will create an object on the stack a placeholder basically for our string variable plus the address of it in the rda or rcx register and the colli is going to directly create the object that it's uh that it returns in place so there is a full copy illusion on all compilers like really all compilers no questions asked all of them perform exactly just like the standard dictates now why is it possible and how does it work under the hood because that's that's a kind of a quite curious story using exactly the same scheme that i showed before when i was told how our mental model looks like when we talk about returning something by value from a function uh basically in c plus plus 11 already or even 4c plus plus 11 it worked like this some type temporary was created in the return statement or could have been created and then a copy or move of it will align it when creating the return object and one more time when initializing a variable notice that twice in this chain an object is initialized from the pr value so some type this return object here is initialized from the pr value here and the object this variable here is initialized from the pr var that's returned by the function so the copies could have been alighted under one condition that either the copy construct or the move constructor which was alighted existed so they had to be members of the class and they had to be accessible otherwise the copy illusion could couldn't kick in uh c plus plus 17 introduced a change in it in c 17 nothing is created at this place the pr value that's there is just like oh your idlpr value that was hanging around and it's automatically or pass to the next step in the chain and since there is no need really to create here an object this pr value is again automatically forwarded one step further and here at this moment it materializes into the object and this object is then created with this pr value now this is called this mechanism is called the delayed temporary materialization so the temporary is our pr value and it gets materialized only at the end of the chain this is also mandatory in c plus 17. c plus plus 17 mandates then in those two cases copy elision slash move elision is mandatory so when the object uh when a return object is initialized from a pr value or when an object when a new variable is initialized from a pr value like this copy elision is mandatory which was before only optional in c plus 11. another change is in c plus plus 17 the copy and move constructors don't have to be there so even for objects that don't have a copy of a move constructor copy illusion can kick in uh in both cases actually any side effects of the copy or a move constructor if it's there are ignored now which lists to the next question what happens in cases that are not mandated by the standard um you know c plus plus 17 requires a copyright in this case specific case but what happens when we go a step further so when instead of returning or creating the return object directly from a pr value we have a named object in the function well it's an l value right and we are returning it it's a different story now it's totally optional to light any copy or move in this case in c 17 if it happens side effects can be ignored but it's optional to actually highlight the copies so let's put those to the test and to simulate somehow or to be able to show how it can work i came up with this kind of a nice function there is a named object inside it's a result object just for simplicity i called it result and then introduced a bit of randomness into the process so depending on the random outcome and of course talking we are not talking about how random the standard round is here it doesn't really matter it's still random for the purpose of this talk or random enough we might assign another value to the result and as an extra challenge there to return statements in the functions so we don't return trust in one place there are two return statements the rest doesn't really change so i still initialize my string variable directly from the value from the object returned by the red value function now this was also identified as an issue many years ago and michael timon in his article which was published or republished in c platform gems already mentioned that the really smart compiler could notice that result was only feeding the return value and see through it and optimize it away he also proposed another solution which never cut it to the language or made it through to the language which was extending the language by basically annotating your function with like an what looks like an extra return statement uh the compiler which variable you attend intend to return so which variable is going to be used as your return value now we don't have it but we have something else and the good news is that some compilers do agree on some compilers at least on clank and gcc we get a full copy allegiance so even in this difficult case the address or the string is created on the stack and the address of it is passed to the collie and the colleague is able to directly create an object in place and this is even for this non-trivial you know red value function which has an l value inside everything just happens in the place pointed to by the color now icc and msvc do something else like totally something else what icc does so the intel compiler is this it begins exactly like clank or gc so it creates a string variable the stack puts the address of it as a return object address into the rdi register and calls the colleague calls the red value function now the red value function actually creates another variable uh an allo l value on the stack uh it populates it with something depending on the random outcome and then at the end because it was past the address of the return object it makes a full copy of it so it copies from the result to the string and that's the end uh msvc does actually steps up a game a bit let's call it like this msvc does the following it creates a string variable on the stack it's empty in the beginning nothing's there it also creates a temporary for the return object for the collie and passes the address of this temporary to the corey to the red value function now the colli creates one more variable the result variable which was declared within the function and you know initializes it changes its value depending on the random outcome and then when it's decided that it's the end of the story it copies the value of the result into the temporary location into the temporary object and of course returns the address of this temporary in the array x register now when the function returns to the caller it makes one more copy it copies the object object from the temporary back to the str to the string variable so in total there are two copies from the msvc and one copy for the icc whereas gcc and clank managed to fully avoid anything is this a difference yes it's a huge difference it's for bigger object it can be you know a deal breaker whether you make a copy here or not make a copy at least two compilers now that are now on market perform very well two of them a bit worse let's say and again this is not mandatory right so remember this copy elision wasn't mandatory so it could have happened now the next one is using the proper string with the same scenario so my toy string which is non-trivial but very cheap to move and let's see how this one goes now in the beginning we initialize as usually the placeholder for the string variable and we put the address of the compiler puts the address of the string variable into the rdi register now next the callee feels in the place and allocates a piece of memory in the process because it holds a dynamic resource and everything seems to be well wired together now at least for clunk gc and icc of them agree that copy is fully alighted there is no copy no move whatsoever so the object is created directly in place uh on the color or basically on the where it should belong to uh anything that happens in between so even if a memory needs to be destroyed in the process in the red value function it's not visible to the caller now msvc disagrees on this approach msvc does something that's already hinted in the previous case when i was talking about the trival string it introduces a string variable first on the stack passes it the address of it and the register now the function the koli creates a new object the result object on the stack and also partially on the hip because you know it needs to allocate it and then makes a copy of it but you know it's actually a bit smarter it's a i call it a copy because what it truly does is a move construction but it omits pieces of this move construction so it ignores pieces of it knowing that the stack where the result resides is never going to be used again so doesn't have to zero for example or assign a new pointer to the string of the result but nevertheless it you know formally it moves constructs the string from the result and the copy is aligned and actually that's pretty good you know that's exactly what should happen in this case uh there is only one move construction in this whole chain and nothing else uh so pretty well if you ask me it's a cheap object you know 16 bytes doesn't really matter so that's how it looks like and let's let's basically call it differently i before had trivial non-trivial but what i really mean is something that's cheap movable and something that's very expensive to move for basically move is equal to a copy and where a binary representation of an object can be actually copied also to create a new object so you don't need a copy constructor on a copy assignment operator to create a copy plus a binary copy is enough which is not the case for the non-trivial string here and let's also instead of having the full annotation what just you know focus on how many copies are performed or moves and as you can see two compilers perform very well on both tasks on actually all four different tasks they manage to align all the copies and all the moves icc is performing reasonably well msvc is performing not that great especially for the object that is not cheap to move it always creates a full binary copy at least one sometimes even twice now that being said let's step up the game we can do something much more fancy instead of what i had before so instead of just returning an object from a function and constructing a new object direct from the return value we can do this so there is a function which is exactly the same as before it just creates a string and returns it but now instead of creating the string from the value returned by the function we assign the return value to an already existing variable it's an assignment it's not a construction uh and actually this is you know a totally different case it's not mandated by the standard that a copy is selected there actually it's super difficult to light a copy there because how can you you know not copy so let's see what the compilers have to say about this assignment and if they are able to optimize something away now something when i started doing this this investigation actually i started with with making this kind of a table so this is what i expected based on the results on the or of the investigation so far uh i expected that for the trival objects for so for them not that for the expensive to move object there will be a full copy construction for all the compilers and for the cheaply movable object there will be a move sorry copy assignment and for the cheaply movable uh object there will be a move assignment when i do this one and this is just impossible to avoid i also expected that msvc is going to be doing a bit worse and it will be creating an unnecessary copy or an unnecessary move for the case when i'm returning an l value so when i return a named object now the reality was quite surprising that's roughly the reality as you will see some compilers manage to avoid a lot or manage to avoid moves and copies in places when you wouldn't expect it and the first one which is super surprising is this one so to see an icc for a trivial object which is very expensive to move fully managed to avoid any copy or move when there is an assignment now how do they do it it starts with this one right so the trigger string needs to be constructed and it has a value and then a magic happens instead of creating like another object or another placeholder for a return value those compilers do pass the address of the already existing variable and already existing object the function to the red value which in turn constructs the new object at the target location so both compilers are actually able to three through the mist notice that this is a trivial object it doesn't have a user defined special member function and that making a binary copy so just you know think that bits is enough to create a new instance there is no destructor call nothing like this they don't have to worry about it so just overwriting the old values and we are good to go right that's what they do and that works wonderfully so it surprised me a bit and what surprised me even more are those things and notice that i how i mark it on this in this table is a check mark slash move assignment because kind of both it depends heavily on the conditions and i must say gcc is a bit better with it so gcc is a bit more uh advanced or when it comes to or i wouldn't say advanced but it's it can see through the mist again better than clank and optimize away a bit more also when this object is a bit bigger because i also did experiments with a bit bigger non-trivial object where it had some you know big storage inside just in terms of an array member variable nevertheless how do they do it and i must say that the code that you are seeing on the slides is a simplified version of the code that i was using here it's a piece of reality as an extra challenge after instantiating an object string object there is a print statement which prints the string so i am sure that the compiler doesn't optimize too many things away and only then there is an assignment so how do gcc and clank actually approach this problem now both of them do first create an object and they you know create them in the usual way allocating the space and passing the address of it in the ldi register to that colleague notice that the object is already fully constructed right it's something there it's also an object that manages a dynamic resource so there is a destructor call and now you know you there is a bit of a confusion coming like how can it work uh because when the callee overrides the stack uh then the co the program won't be able to delete the old resource right now luckily those compilers are pretty smart and save the address of the dynamic resource of the piece of the memory block on the hip in the rbx or the rbp register depending on the compiler for client kits rbax now to be honest actually there is nothing on the stack the stack is empty in the beginning and anything that's there is actually this rbx register even the size is optimized away and 18 doesn't even appear in the program so far so now you can see it's quite easy for the colleague to create an object in this place the caller just simply can create an object populate the stack fill it in with the pointer or whatever it wants whatever it fits proper at this at this moment and while corey returns after creating the object the caller simply frees the memory block previously allocated at the first line so previously allocated for the object that existed and this is i must say pretty cool uh and i'm gonna show something that clank does uh gcc does it in a bit let's say uh less obvious way but what clank does i mean officially there is a move assignment somewhere there right and the move assignment is implemented in this very classic way uh with the comparison of pointers and you know leaving the moved from object in the valid state now what clank does is actually ignores mode of most of the move constructor it's not even there the delete part of the move constructor goes to the color so the color is responsible for deleting the old resource this piece is actually done by the red valve function it assigns the new values new proper values to the string object and the rest of it is not even there so there is no zeroing of of of the moved from object nothing like this gcc doesn't omit those but clank does as a comparison icc does everything it even uses the if this is not other comparison inside but this is a clank optimizes everything away that's all what's left out of the move assignment operator and this is pretty amazing if you ask me this just shows how good the optimizing compilers are even for this non-trivial case fairly complex scenario they're able to basically you know remove 80 percent of the work out of the machine code so to sum it up uh that's where we are now uh for assigning or a return object to an already existing variable that's how our table will look like uh general speaking is much worse when we than previously and that's to be expected it's a much more complex scenario however gcc is doing remarkably well on these test cases it manages to optimize fully any copy or any move almost in all the scenarios and clan is clunk is like on the second place doing actually also very well i was particularly impressed by how it optimized away the code that was not needed or not used with the usual third and the fourth place as in the previous case icc and msvc and msvc again does make two copies in the same case as previously so when i was returning an l value and this time it's also making two times a move of an object for a non-trivial object when i'm returning an l value previously it was doing just one move uh so that's how it works and up till now what we've talked about what i've shown is that copy and move elision is guaranteed since c plus 17 for pr values but it doesn't always happen msvc doesn't do it and in one specific case when it should be doing it at least that's what i've seen in the testing that i've done and i still have like a small suspicion that maybe i've done something wrong sometimes copy and move allegiance works also for l values so when you return an l value from a function some compilers manage to align it then and surprisingly sometimes even the whole change of copy symbols can be eliminated with multiple assignments on the way which is unbelievable now which leads to the second part and a bit shorter part of this talk passing by value uh what do we mean when we pass by value well i guess something like this right we create an object of some type and then we just you know prompt it into the function call and this function is taking a value so what happens a full copy of an object is made that's how we think about it right and i must say uh here we kind of have no choice no this object exists there uh somewhere we cannot auto magically move it or or propagate a pr value or whatever this object is there it might be used later on we cannot just discard it we have to make a copy and the compilers do agree actually not so surprisingly compilers do agree for example when we pass a non-trivial object a proper string by value what does happen well a string is created on the stack with a dynamic dynamic piece of resource allocated together with it then in the next step when the by value is called and the string is passed on as an argument a copy of it is created for the argument a full copy uh constructor and the address of the argument is passed to the collie and there is no way around it all the compilers like really all the compilers fully agree there is a constructor and a copy constructor two times new two times delete no way around it now the curious things start to happen when we have when we have our trivial string so the thing which actually you know a full binary representation is already a full object so when you instantiate or when you copy an object it's enough to copy the bytes you don't have to do anything else right it's a trivial object uh also not that easy to move so what do the compilers do i mean typically they do something like this we instantiate we create a new variable it's a string variable then we make a copy of it on the stack it's a big oversized object it's going to appear on the stack and then we call the function and we pass the address actually we don't pass the address sorry it's on the stack so we don't even pass the address uh the the function just knows that the objects is on the stack and it's gonna call the printf uh by passing the right pointer to the printf function and at least this is what gcc and msvc do now clank and icc take a different approach and this was again something that surprised me a lot now clank and icc see through the fingers so they notice that actually this object is passed there and not really changed so what they do is create an object on the stack the string object on the stack and then the coil call by value without creating a copy and you know that by value is it sees the stack it sees the object on the stack and it simply uses the already existing object to print the string using the printf function and returns to the color so there is no copy being made whatsoever when you pass by value in this case it truly does happen for clank and icc with a small trap if you don't have this line in between if there is anything between the object creation and calling the function a copy will be made no way around it and this is super surprising and i will tell you why it's so surprising i'm only printing the length of this string it's 22 right you can see it the number 22 is there on the screen so when i'm not printing this thing when i this line is removed the code that is emitted by the compilers by both uh compilers and this is actually an optimized code already with some of the things no it's not optimized sorry it's not inlined so what happens is uh there is a place created on the stack 40 bytes because this is the size of the string and this 40 bytes get initialized uh with just a constant value that i passed in the constructor and then the by value is called so this is what happens when there is no printf so you might think how does printf disturb this kind of optimization that there is no copy and i must tell you i have no idea because if the printf is added there the compiler rearranges the code and what it will do is something like this there will be still a part where the string is created and when the copy of string so the argument is created on the stack there will be still the part when the by value is called and that's the bottom part now before all of this happens there is a call to the print f but this call uses as constant 22. so the compiler could see that 22 is there it's a constant it's just a number calls printf even before anything is created with the number 22 passed as an argument to the printf function and only then starts creating the string and making a copy of a string as an argument and this is you know super surprising that the compiler wasn't able to optimize away a copy when it was able to do it and when the printf wasn't there it totally doesn't influence it nevertheless that what happens so what do we learn from it when you have to sum it up when i have to sum it up that neither passing nor returning by value means always making a copy and surprisingly not even passing by value means making a copy because the compiler's aggressively avoid copies and moves and when it comes to returning it's it's really crazy i didn't expect it that it happens in to such an extent nowadays another takeaway is instead of benchmarking sometimes look at the machine code that's generated because there are hidden gems there and you know you might get insight that sometimes just removing a line of code like this printf statement uh that i've shown you a moment ago might save you a lot of overhead so be careful what you're doing in what order you're doing it uh compilers sometimes do crazy and surprising optimizations now to close this talk uh you know i want to just show you one more as thing said there are so many ways to pass something to a function i've talked extensively about value passing so the talk was about compilers values right and functions instead of passing by value you can of course pass by reference by an r value reference or by a pointer be it a constant pointer or a non-constant pointer whatever it is in all of those cases a compiler will generate exactly the same code so from the point of view of the compiler all those functions look exactly the same it doesn't matter how you pass what you do pass is a pointer to an object on the stack most likely in this case in the rdi register and that's all nothing else nothing more so in the end all non-trivial objects which need a special user-defined special member function will be passed by a pointer and that concludes my talk so thanks for listening and it's time for the answers so i will shift if i manage to thank you very much for the wonderful talk i think we have five more minutes before fubillo kicks us out of that stream so if there are any questions we haven't answered uh uh david has nothing until then i think he will be available on the tables for further questions right yes okay can you see the q a or should i read the question i'm not switching to the q a and i can see there are questions so i'm going to read them through starting with the first one material skill what happens if the copy constructor would perform side effects that's probably bad style from a programmer point of view if it comes to returning something or basically when you are creating a new object from a pr value or you return a pr value as a part of your return statement then the compilers are allowed to ignore any side effects and they do ignore any side effects when you pass something to a function by value then yeah copy constructor will be called anyway because it's not allowed you are not allowed to optimize it unless you pass a pr value and then i guess uh i don't test i do remember as fires remember it can be again ignored yes there is a specific reason for printf i was analyzing lots of assembly code and believe me uh honey or not it's it's much much easier to understand how printf works than i see outstream uh when you look at assembly generated so that's the reason um i used the newest version so the newest release versions tomos keys this is your question which is c clank version and so one i used in the slides uh the newest available release version on the uh the compare explorer so clank13 and the rest i forgot sorry it's on the first slide also so yes uh that's a curious question uh like for example if uh okay i will first read the question because otherwise dennis uh uh your question if some of the findings regarding msvc might have changed i could believe that yes uh because i not i even today i read a discussion about it uh that msvc doesn't uh because of the api actually that it has the windows the api that windows uses uh objects are not allowed for example to be passed in the registers so they have to be passed on the stack which is always expensive uh when compared to the registers and there are other queries like this when it comes to why mvc is making copies i don't know and i don't know i hopefully when the new compilers pop out i will check it i hope that they optimize it away some of those copies dennis sorry that your question moved to the bottom uh i don't remember what the microsoft uses rdi and rssi it uses other registers by default i guess that you know when you design an api it's it's a trade-off how much do you allocate to passing arguments and how much you allocate to be freely available uh to to do your calculations within a function right uh so i've no idea i don't remember what they use it for as far as i remember the fast call star and so on conventions do not apply anymore to the 64-bit api of microsoft and the last question did i intentionally yes uh a bit intentionally i didn't really want to talk about it so msvc uh yes it's true those functions differ in msvc uh and by value is really lengthy so i i omitted uh on purpose and i think there are no more questions so thanks again for listening to the talk i hope you enjoyed it i will still be oh no there is i haven't seen it goron not in the testing that i've done and the testing that i've done for objects that i i mean you know you have to also think about it uh a bit what i was doing as i said one of the object was expensive to move and i pretty much think i i don't think i know that microsoft or that compilers when microsoft was or microsoft compiler was making a copy it was actually moving the object but because the move of this object defaults to a copy there was no optimization of it so it was trivial but nevertheless a full binary copy of it had to be made and since it's you know it was 40 bytes so unfortunately it was there and you could see it when for a non-trivial type it was actually optimizing away on the other hand not always right so sometimes it was making a copy nevertheless which was also actually i think a move under the hood but it just looked like a copy so it performs it but it does it a bit worse because it always explicitly moves slash copies an object instead of just constructing it constructing it in place so both clank gc and ic are a step ahead they pass the address of the variable that they want to create from the return object and you know it's directly created there instead of being moved there or copied there uh i think there are all the questions so far so thanks again for hanging around with me and listening to the talk uh i hope you enjoyed it i will still be at the table for a couple of minutes and uh you all have a nice conference