hello everyone welcome to my talk thank you very much for coming my name is Timo dumla we're going to be talking about t plus 23 today this is an updated version of my uh keynote at cppcon which I gave a couple months ago uh just to warn you all this is actually a 90 minute talk so I gave I had permission from Jens to talk for a little bit longer today so this is going to be a 90 minute talk but if you do need to leave the room earlier because you didn't know it's going to be a 90 minute talk then that's totally fine by me um just so that you know what's happening um so this is going to be a talk about css23 who am I why am I talking about t plus um I do three different things that have to do with C plus uh the most important one is of course my job I work at jetbrains I'm a developer Advocate at jetbrains um we have lots of developer products such as c-line which is our c plus IDE reshar by C plus plus which is our Visual Studio plugin and then also Rider which is the idefor.net and also for unreal game engine development so we have a booth just right outside this room please come and check it out and talk to us and also please come to the talk of my colleague Anastasia kazakova tomorrow um the other thing that I do that has to do with C plus plus is I worked in the audio industry particularly the music production software industry for about a decade had you know many different jobs there uh the last thing that I did was a few years ago I co-founded a music tech company called cradle which is still active just released this product just a few days ago uh it's called the spirit it's a vocal processor sounds really cool there's a lot of C plus plus going on under the hood there and then the third thing that I do that has to do with C plus plus is I have been involved in the iso C plus plus standards committee now since I think 2016. that's like six years um so it's not quite as long as some other members of the committee some of which have been uh on the committee for over two decades so I'm not one of those people with a gray beard that you see on on those older pictures of the committee but you will find me on the on these ones which are more recent so this is when we completed C plus plus 17 and when we completed C plus 20 whenever you know we're done with a new standard every three years they take this group picture this last one was from um the Prague community meeting in February 2020 organized by Hana thank you very much it was awesome um and now we are actually in very near another finalized release cycle with CBS has 23 we're not quite there yet so the final meeting for the osas 23 is going to be in February in Issaquah so we're just a few months away from um finalizing C plus 23. um and team at this point is already feature complete so yeah that's really cool actually since July this year it's feature complete we have a feature free so now we're just fixing bugs issues uh we had a meeting uh standards committee meeting just last week in this beautiful place Kona Hawaii it was great I fixed a lot of issues in the standard you think this is actually a picture from last week you think you know how awesome is it to have a standards committee meeting in the tropical island in November well let me tell you it's not actually like this because yes it's like this outside but you know what you're doing is you're stuck for six days and then you know windowless air-conditioned room talking about C plus plus voiding so don't really doesn't really matter whether it's on a tropical island or in Antarctica you wouldn't be able to tell the difference and also they turn the AC to freezing so oh well um so yeah we have another one of those um in February and then he is going to be done so we have a very very uh good uh image of what C plus 23 is going to look like it's practically done we're just ironing out a few last bugs so it's a very good time to talk about C plus plus 23 and so I thought okay I want to talk about css3 how should I do this and so um I actually gave a talk here on this stage three years ago about C plus 20. and what I did back then I called it t plus 20 the small things so I talked about I think 20 or even 25 different features it was a little bit of a firehouse talk about like all the different small features that that c plus 20 had um and it was a fun talk but it was kind of not very deep because you don't really have time to go into a lot of depth with these features and so um I wanted to do something different so um one year later two years ago here at this conference that was the um hang on let me let me tell you this first so um I'm kind of interested more in in kind of these uh deep features that really change what we do with the language and and so so the way I see C plus plus is kind of like a like a toolbox so you have your sauce there you have your hammers you have your screwdrivers and then if you look at the screwdrivers you have your uh you know Phillips screwdrivers you have the slot screwdrivers you have the um I don't know Torx screwdrivers and then somebody goes ahead and invents the pentalobe screwdriver which is really good for turning pentalobe screws and it feels to me that that this is kind of a lot of the features we add to the standard are kind of like this they're like very specialized things to do a very specialized thing and if you have exactly that problem uh you're going to reach for it and it's good you know pentalobe screwdrivers are useful but um that's kind of not really what I'm interested in what I mean what I'm interested in is kind of like those things like the cordless electric screwdriver right so you can just grab one of those and instead of turning the screw with your hand you can now just go and that's it right and so a lot of people are going to find that useful it doesn't matter what you're trying to do or what kind of screw you're trying to turn that's going to have a huge impact on on how you write C plus plus and so um one year later that was the first pandemic version of meeting C plus plus I gave this talk about C plus 20 which I named how deep is 20 changes the way you write code and today I shamelessly stole the title for that talk for this talk except I said it's 23 now um so in that talk I talked about just four features the four big features of cfs20 core teams Concepts ranges and modules and so those four features are really very fundamentally change uh the way we write code the way you think about C plus plus right because these four features change how we think about functions how we think about uh templates how we think about algorithms and how we think about compiling and deploying our code right so these are very very fundamental things that every CSR developer has to do and so um today I want to talk about css23 so we don't quite have features of that magnitude in C plus 23. but we do have features that will have a huge impact on on the average Superstars developer so I wanna I wanna see what those are and maybe we can find similarly to what I did two years ago we can't find four features that are going to be really impactful so let's go in and look at what's there so if you go to CPP reference I'm sure some of you have seen this or are familiar with this CPP reference has this page which is called typos compiler support where it lists what features of every standard are supported by which compiler and there's this really long list so so here for C plus 23 this is the list for core language features and you know which compiler which implements which and so it's quite a long list you know even though C plus 23 is kind of a smaller release than 0.20 the list is actually quite long and then there's another list with C plus 20 key Library function so this is everything that's new in the C plus 20 standard library and it's an even longer list right it's really quite a long list and and if you zoom out you see how long the list actually is so that's all the new stuff and if you just look at the leftmost column then you just get basically a list of all the new features and I can kind of take that and explode that into a slide exceptionally it doesn't it doesn't really fit on a slide actually so it fits on three slides this is one slide with all the new language stuff and then we have two slides one and two with all the new library stuff right so that's quite a lot it's definitely um more than I could talk about uh in any talk definitely a 90-minute talk so what we need to do is we need to kind of reduce that list down until we have a shorter list of the actual things that you want to talk about that are going to be really really impactful so let's try and do this let's try and reduce this list so this is the list of language features and let's just go ahead and remove everything that's kind of a deprecation underprication removal of something or clarification of something um and let's just get rid of that and then let's do the same um for the standard Library stuff so page one page two so our list got a little bit shorter and then um we're going to go back to the first slide of the library features and remove everything where something just got kind of tweaked we added a no accept here we added a const export there we added like a new Constructor somewhere you know these are good additions but they're not really big impactful features that kind of tweaks so I wanna just not talk about that today in this talk because this talk is about impactful uh big features so let's remove that and also on the second page and and then um there is a huge uh kind of bucket of features which is everything has to do with ranges so on the first page and here even more on the second page you see quite a lot of stuff has been added to ranges we actually have a study group just for ranges on the um on the committee and they have done fantastic work so uh Rangers got got a lot more a lot more features in C plus 23. but I'm not a Rangers expert so I would say it's kind of its own kind of subset of the language which is really interesting but it deserves its own talk I'm not really a Rangers expert and also arguably it's great but it's kind of adding to something that we added ranges and C plus 20 so it kind of expands on something that we started in 20. it's not completely new right it's like an addition so let's remove all the all the ranges related stuff and then there's another big bucket of features um in the language which is um there's been a lot of work going on about text encoding and unicode all of those things so we also have a study group for that sg16 and they have done fantastic uh work um as well um I hear that we still don't quite got it right so there's still some things about Unicode and text that don't quite uh work but you know we're getting there a lot of people are Unicode experts or character encoding experts on the committee here's one of those people current time if you don't know who that is he gave a fantastic talk actually at cbpcon 2019 this is just a five minute lightning talk about text which is fantastic it's one of my favorite lighting talks of all time so um I recommend you watch it if you want to watch something fun in five minutes this is really cool and in that five minute talk he managed to convince me that um a takes us really hard and B you know we still we still uh didn't quite get it right so um I don't think it's time yet to talk about text and C plus plus um in a talk like this and you know if it was I I wouldn't be a good person to do this I think quarantine would be a much better person to do this so so let me just go ahead and and not talk about the text stuff now even though there's some really good stuff in there and so um there's other features that that we we got in simplest 23 that are also kind of improvements of existing features right so not really completely new stuff so there's things like um class 10 bit argument deduction which now works with inherited Constructors so if you're inheriting Constructors you don't need to write deduction guides anymore and you get them for free or lambdas for example uh you know how if you don't have parameters you don't have to write the param paren but if you have mutable then you do so now you don't anymore so you know all these like improvements of existing features which you will kind of discover along the way as you use them so again I wouldn't say they're like massive impactful features they're kind of improvement so um I'm not going to talk about any of those today even though it's really good stuff and so also for the standard Library uh I'm not going to talk about anything where we added functionality to like an existing class or an existing facility even though it's great but it's not completely new so let me remove those things and also on the second page and now um you see the list got quite a lot shorter so now actually everything fits on one slide so so this is the slide and and now those are the features that are really completely new like not additions or improvements but completely new features in simplest 23. and so this list is still a bit too long so so let me try and Whittle down the list a little bit further so um hash warning Dev the annuity plus 23 but compilers have supported them for ages so arguably not completely new um labels at the end of compiled statements it's kind of a c compatibility feature not going to talk about that if constable arguably kind of a bit of a cleanup from C plus 20 where we introduced this constant evaluated but it's kind of a bit weird so so this is better literal suffix for size T yeah this is cool we now have a suffix where you can write a size T literal for signed and unsigned and it's Z and use it so that's that we talked about it it's good um requirements for optional extended floating point oh this is a cool one so um we now have stud float 16t and float32t and Float 64t so like fixed size floating Point types so it's a little bit like the fixed size integer types like stood View and 64 underscore t or something like this except so for floating Point types and except the integer ones they can be type depths these are guaranteed to be their own type so really cool for numeric stuff uh excellent material for numerix talk that's not today's talk and then there's Auto parent X and auto curly X which I looked at that and I thought um oh this is kind of a yeah I don't quite understand this this seems to be kind of a very Niche expert expert feature but then it was pointed out to me that this is actually really cool and it opens up API design in very very interesting ways and I was like ah I need to look into this but um I don't quite understand um you know the kind of how you would use this in API designs so I think I need to catch up on that and maybe mention it in another talk so also not going to talk about this attribute assume this is something that's very close to my heart I have spent three years standardizing this it was hard but we got it and see it says 23. so this is basically a feature where you can say assume expression and then the uh the compiler can assume that this expression is true without checking it and then optimize based on that assumption so that's very cool feature if you write very low latency high performance code and you just squeeze the you know last nanoseconds of performance out of this particular uh piece of code where the compiler the optimizer doesn't quite understand what it is that you want so this is now kind of a portable way to do this it's cool but it's also very very dangerous right so you can easily just introduce undefined Behavior into your program and then everything goes off the rails and you get super weird stuff so it's a very sharp knife that you need to be careful with and that's also this feature still unreachable which is kind of related um so this is really cool but it's again a very very specialized expert only feature which is very easy to misuse and so I don't think most developers should ever look at those so I'm not going to talk about them today even though even though I like that and I've worked on that myself um so and then these ones here are also new features which are not dangerous or you know expert only necessarily but they're very specialized they're like these uh like the pentalobe screwdriver yes you will reach for them if you have this very specific a problem you will reach for that specific tool but I would say most developers will probably not have to deal with most of those so so gonna you're gonna like look reach for them and look them up you know if and when you need them but um not for today and and so this is what we're left with I think these are like the really big new features in CBS 23 this is kind of the meat and so we're getting closer to our kind of four features that that you want to talk about today I know it's a very long intro but bear with me so um this is kind of the meat um how do we how do we approach this so uh we have standard Library modules here and we have the generator so obviously those are both pretty awesome but also those are kind of stuff you should have done in cbs20 right so standard Library modules it's awesome danila talked about this earlier today it's great but it's kind of you know we should have done this when we introduced modules um it's the generator also some you know first rudimentary Library support for core routines in particular for this generator use case which really should have done with C plus 20 so I've been we're not kind of catching up adding support for stuff into your system here that we added in cs20 so not really something completely new even though it's very cool and very important and then also these um I would say um they're great libraries and if you if you so you have step Trace Library we've only function and those contiguous layout associative containers flat map and Flat set they're very good if you want to be you know cash friendly so um those are very good libraries and you will reach for them when you need them but they're kind of self-contained they're like this thing they're not really touching other parts of the language too much so um I'm gonna talk about those and I'm gonna talk about the remaining four so now you're left with four features and I would say that these they really have a lot of you know consequences you know they they they're interesting in a sense that they're touching different parts of the language different use cases and I think those are the four features that are going to be most impactful and significant for the average sleeper SAS developer so these are the four that we're going to talk about for the rest of this talk let's dive in and talk about the first one which is producing this so reducing this is by far the biggest language feature that is new in C plus 23. it's a paper that's been in development for a while this is the actual proposal uh so Ben bendeen one of the co-authors told me that he was thinking about something like this since when he sorry since 2013 and then there were a couple other people who were thinking about the similar problem around the same time and they teamed up and they started working on this so this feature has been just hating for quite a while and finally we got it in a standard so Ben one of the co-authors actually gave a fantastic talk at cppcon last year which is called deducing this patterns which is one hour just about deducing this so this is as of right now I think the ultimate reference for this so if you want to know more watch this I don't have a whole hour to talk just about this feature so I'm gonna be you know not quite as exhaustive as Ben was but hopefully I can get across why did you think this is cool what you can use it for why why it's important for you so this is a quote by Johnny the creator of C plus plus uh when you consider whether you know something is a good addition to the standard his rule of thumb was it's a good feature proposal if it solves at least two unrelated problems at the same time and it turns out deducing this solves at least three problems at the same time and maybe four or five so it looks like it's a really really good it really kind of matches that that requirement you know that's a pretty high bar but but that definitely definitely matches it but that's that's good addition to the standard so what is it using this how does this work uh let's observe that if we have a class um it has member functions and we can overload a member function on whether or not the object itself the the this right uh whether or not that's const okay so that's hopefully not surprising to anybody in this room um you can overload them whether this is constant on const um something slightly more subtle something that we can do since C plus 11 is that we can overload a member function on whether the object itself the this that you call this member function on is an L value or an R value right so these are these ref qualifiers that we have since 11 and we can actually overload also on all combinations of those right ref construf ref construct ref there's also volatile which probably most people don't need but you can overload on those on those things and so um what did you think this gives you like the first level is that it just gives you a different syntax to write the same thing so with reducing this exactly the same thing would be written like this so observe that on the left it's kind of a little bit weird right so you are talking about the this pointer which is kind of the the implicit first parameter of every member function but the way you specify whether it's ref or construct or whatever it's kind of this weird syntax but the thing is at the end right um so so with the new syntax on the right hand side you make this implicit first parameter of every member function so you make it an explicit parameter and you write this as the actual first parameter of the function signature and to distinguish it from a normal parameter you put this uh keyword in the beginning and then the rest is just normal parameter declaration syntax and so so this is just just a different Syntax for the thing on the left when you make this uh parameter explicit and because now we're using just regular parameter declaration syntax we can give this parameter a name we can name itself for example that's what python people do that's that's cool right but you can name it whatever self is just a good convention and because it's just function declarations index if you want to um you can do something really cool and this is the bit that you couldn't do before instead of writing out four overloads you can actually template on what the type of this actually is and then it looks like that right so now instead of having four overloads you have one template and then you can call it with a const object or a non-const object or whatever and it's going to deduce you know what the type actually is for you using just the normal rules of function template argument deduction the ones that we had since the 90s didn't change them but now you can deduce the type of this using using function template parameter reduction and so because it's just a function template you can also use this alternative syntax here which we got since 0.20 if you don't need to name the type you can just write Auto and so so this is this is what do you think this is and now let's look at what you can do with it because it's really cool it's kind of a very small addition to the specification if you look in the wording of the standard but it has all these wide reaching consequences kind of ripples through the whole language and lets you do all of these cool cool new things and so one kind of very obvious thing is that it gets rid of duplication or in some cases actually quadruplication so what you have to do in C plus 20 and before a lot of the time you actually have to write out these overloads and so for example this is something you hit when you implement something like optional it has um member function value which Returns the value of the object that's stored inside the optional and it's kind of really just one function it does one thing but because you have all these different cases our value r value Quant non-cons and the return value needs to be different in every case you end up writing out these four overloads right and so you end up duplicating or quad duplicating essentially the same function by the four times which is not good we don't like that right but it turns out nasiba's 20 there isn't really a good way to to remove this quadruplication right so what we could do is instead of writing the same function four times you can write it once and then the other three call the fourth but then because the parameter types don't match and return types don't match you have to use these really ugly casts and it's really ugly and so the other thing you can do is you can Factor it out into a private implementation function and then you you call this from from the other four which is also kind of not great um or another thing that you can do which is probably what most people end up doing is you just omit some of these four you just don't don't Implement all four of them and then that's really the worst option because then you sacrifice either const correctness or your sacrifice um performance because you're going to make unnecessary copies if you didn't implement the move variations or you sacrifice both const correctness and performance if you just Implement you know one and so so um this is not good but and C plus 25 we don't have to worry about this anymore we don't have to do it like this anymore because we can just template on the type of this and we can write one implementation which is now a template and that's going to cover all of those cases right you can write a generic implementation and whether or not it's ref or ref or constant non-conscious it's just going to work in all these cases right and so here you have this uh did you deduced this uh parameter here so um that's cool there's another thing that this allows you to do it makes crtp a lot simpler so crtp is the qsd recurring template pattern and I'm sure many of you have heard about this has been around for a while it's one of those really weird things that you to get your head around when you when you learn when you learn C plus plus so it's been around since the 90s I think the term crtp was actually coined by Jim copping in 95. the concept is not even exclusive to C plus plus it's been around since the 80s um if you like type theorists know about this it's called f-bounded polymorphism so it's basically a generic type that's parameterized on the type that it actually is that's kind of what it is in type Theory um and we have it in C plus plus and and it's useful so I'm just going to talk quickly about the classic crtp pattern let's say you have um a type counter which under the hood is just an integer but you don't want it to be an integer you want it to be a strong type with a strongly typed interface so you you hide the integer somewhere in the private section and you have like get value and set value and you make it a Class Type okay and so yeah that's pretty straightforward and and then you say okay well it's a counter I want to be able to increment it and so you add these uh increment operators here and you implement them um and then um and then you can use it right so you have a you have this counter you can now increment it using prefix or postfix increment operators and you can get the value out okay so that's very easy now let's say we have a completely unrelated class which is also some kind of strong type depth for an integer let's call it age maybe we have a class that represents an age of a person and it has a slightly different interface it has like a different integer type under the hood and maybe it has a Constructor you can initialize it with the value whatever um but you can also increment it right so every time somebody has a birthday you increment the age so you have the same increment operators right so you have this duplication here you implement the same stuff and so um crtp gives us a way to get rid of this duplication right so what you can now do is you can Factor this out and into a base class and you don't want to have like a classic virtual like runtime polymorphism inheritance hierarchy here because those classes are completely unrelated but but you still want to somehow Factor this out into a base so what you can do is you can do the crtp mix-in where you have a a base class that is templated on the type that's going to be deriving from it right and then you you stick the implementation of these operators in there so now we have incremental Base Class it's templated on what's going to be deriving from it and then and then in the in the counter and age classes we have to do this weird thing where uh we have to derive it from incrementable we have to pass the derived class down to the base class as a as a template argument right so it's kind of a bit weird so I could never remember when I was learning this like is the base templated on the derived or the derived template is on the base it's kind of a bit unintuitive um and so the other thing um if you want to access anything from the derived class in the Base Class you can do it so it's a little bit like like virtual functions but it's all at compile time and in order to make this work you have to write this weird incantation with the static cast to derived and I'm sure you've seen this and so so um it works you know we've been using it since the 90s um but it's it's not ideal right so um there's actually a bug on this slide can somebody tell me where the bug is yes very well spotted sitting in the first row um yes so we we copy pasted the code and we just accidentally derived from the wrong we passed the wrong derived class down to the base class right and so and so that's going to compile okay it's going to run it's probably not going to do what you want because it's undefined Behavior Okay so not great you can get around this you can you can like um make the Constructor of the Base Class private and make the right thing a friend and do all of these things but like overall if you consider like the last 10 slides or so like the ergonomics of this feature are not great I think we would probably all agree on that um and so so um let's see what this would look like with deducing this um so we're deducing this um you can now make this uh make the this parameter explicit right so we can we can do this thing we can write this Auto self and now that's the this object here and uh so the cool thing about this this is really important is that the what do you think this does it deduces the most derived like actual type um like the most derived type that's fully known at compile time so if it knows that compile time that this is actually going to be derived like a counter on H that's the type that's going to derive right so it's going to derive the fully uh derived type sorry deduce that's the word it's going to deduce the template argument reaction it's going to deduce the fully derived type so it's going to deduce counter or H and that means you don't need to write this weird incantation anymore we don't have to study cursor to derive because it's already derived template argument deduction already deduced that type for you so that's really really important and so then we don't need the template stuff anymore this all just goes away we don't need to template anything on anything anymore and now it just looks like this right so it's a lot easier um and so um and so yeah we don't need this template stuff anymore like this whole crtp thing just goes away and you can just just write a member function that gives you a pointer to this which is the fully derived type and then you just use it okay so that's a lot easier so um there are a couple things about this there's one thing in particular I want to mention that Ben Ben Dean didn't mention in his CPP Contour which is um what this lets you do is it lets you actually now um I have a reference to base class and you can you can bind an object of derived to a reference to base so you cannot do this with crtp because the crtp the base class is a template right so with this you can write this and it's kind of weird because it looks like runtime polymorphism right it looks very much like this is a polymorphic object but it's not right because it's compile time polymorphism and so this looks like virtual function polymorphism but it's not that it's not going to work and so if you try to increment like the the reference to to base it's it's going to give you a compiler error um so you know the type theorist would say that F bound like deducing this um replaces uh intrusive uses of f bounded polymorphism which is where you use the derived functionality from inside the class but it doesn't replace a kind of non-intrusive usages where you deduce where you use the derived functionality from the outside so that just won't work um so you know there maybe there is a way to to kind of make that not compile at compile time maybe with some concept stuff like not yet sure what the best way is to do that I would I would say best practice on this is still emerging but I think it's kind of a bogus argument I don't think this is a problem because you wouldn't use incrementable as a base class right you wouldn't you wouldn't pass a reference to incrementable into a function because it's not it's not a base class in the sense that animal and cat and dog are right it's just a bag of functionality and the fact that counter derives them incrementable is just an implementation detail so incrementable would probably live somewhere in a detailed namespace or something like that so I don't think I don't think this is the problem but it's good to be aware of that that you know you kind of form this reference but it's actually not going to do anything useful and so there's there's other stuff you can do with reducing this which is really cool you can um you can put a concept in there so you can uh constrain a member function on the type of the class itself that it's a member function of this is not something you can do with C plus 20. the other thing you can do is you can pass this by value to its own member functions that's also pretty cool so Ben talks a little bit more in his talk about that like both of those things they enable like really cool new kind of programming patterns that I don't have time to talk about now but if you're curious check out Ben Dean's talk and I think by now there's probably a few more blog posts on the topic somewhere so it's pretty cool um I want to talk today about another thing that um using this lets you do it that's your right recursive lambdas and how cool is that all right so so let's talk about why you can't really do this today or how you can do this today so let's let's go with factorial that's like the canonical recursive function I guess and don't actually Implement factorial in this way obviously but I think it's a good example so here's a naive implementation of factorial with alumna does this compile does this work no why not um so yeah the compiler error is um you cannot use f from inside its own initializer you haven't defined F yet so you can't use f to initialize F right so you can't do that um which is unfortunate um we can get around it like how could we get around this in C plus 20 any ideas okay that's the advanced version that's a much simpler way we can do this we can we can make it a stiff function so that works right you can you can declare function and then capture it by reference and then use it inside the Lambda that works it's not great right because that function has all this overhead like it it's it's a big it's a function of it's an object right so it might it has all this type Erasure Machinery inside it might allocate memory I mean probably not in this case but um it's probably not a good solution it's like overhead that you don't need but uh you can do what the gentleman in the back said you can make it a parameter so uh you can um you cannot refer to the Lambda from inside the Lambda body but you can parameterize the the Lambda on the function that's going to be calling recursively okay and then you can pass the Lambda to itself as that parameter okay so that works in t plus 20. um but it's kind of weird right so now you have to um uh you have to you can't just make it a normal function call so you have to call the Lambda and pass the Lambda itself into itself you can you can actually Factor this out and you can you can do another Lambda which does that for you then you get what's called a y combinator but then you need this extra helper to do that so it's not really great but you probably see where this is going now right so so if you have deducing this we don't have to have an explicit parameter to pass the Lambda to itself because we have this parameter which already is the Lambda right because a Lambda it's a closure type that the compiler generated for you the closure type is just a Class Type uh the the body of the Lambda is operator param paren the call parameter which is just a member function of that class type which the compiler generated for you because it's just a member function of a class type you can obviously pass the object itself to its member function using this new syntax and now this is just a normal function call and this just works how cool is that it's cool right now you you could say okay this is just the toy example like why would we ever want to do this in practice well here's an example actually again from pending's talk which I find really cool um here's here's a use case so let's say this is classic C plus plus job interview question let's say we want to do three traversals so we have a binary a tree uh which we're going to implement just with the variant right so every every tree is either relief or and you know sorry or or a node but like a left tree and a right tree and then it's kind of recursive so we would just want to now recursively Traverse the Stream and so uh what we can do is we can do this trick which um I've talked about in my Lambda Lambda idioms talk and it's on the CPP reference and I'm sure some of you have seen this it's kind of by now relatively popular idiom so what you can do is you can have this overload set where you inherit from a bunch of functions and then you make those functions base classes so you kind of have a very attic pack of Base classes and then that's an aggregate right because it has nothing else in there so it's just an Aggregate and the base classes are the elements so you can initialize it with aggregate initialization with the curly braces and then you inherit the call operator from all of the of these base classes so you get this overload set and so we create an open and if you create an overload set that's really good for stud variant right so we can do stit visit on a stud variant and give it an overload set and it's going to call the correct overload on the correct type depending on what variant is at the time right and so we can create this overload set and give it to lambdas one for leaves and one for nodes and leaves just it's just one leaf it just counts it and the node version recurs this into the subtrees and calls itself recursively and then in the end you get this recursive tree traversal here and the the important thing is why this works is because I hear in this overload for for node so we do this uh deducing this thing but did you think this is going to deduce the fully derived type so the type of this const Auto self in this Lambda is not going to be the Lambda it's going to be the whole thing the whole overload set okay that's going to be the type and so if we call it recursively down there it's gonna it's gonna call the whole overload set and so if it's a leaf it's going to call the leaf version recursively so and that's why this works is this well let's clear okay this is cool so so next time you you're interviewing for a C plus plus job and somebody asks you to implement tree traversal you can do this and really impress your interview however if you if you do want to do this I recommend you have a cutting edge compiler that can actually compile us um I think as of right now only the Microsoft compiler can do this like neither GC nor clang implement this yet but hopefully they will be because it's now in the new standard all right give me a second all right so we come to the second part I'm going to talk about still expected State expected is also really really cool so this is also a paper that has been in in development for quite a while and it um it went through 12 revisions first version of this paper was seen by the C plus Committee in 2016 I think but the idea is actually much older it comes from a talk by Andrew alexandresca from 2012. um and so so the reason it's really important I think is because um error handling is one of those cross-cutting concerns you know it's like logging error handling there's a handful of those where like every project has to deal with error handling at some point right every developer has to deal with error handling at some point so you need to like really think about how you want to do this because it's really very very difficult to kind of put that into your project like after the fact and so we have a few mechanisms for error handling and C plus plus there have been countless talks at this conference and other conferences given about different kinds of error handlings and all the trade-offs so I'm not going to rehash this whole discussion but I think is that expected really plays an interesting role like it occupies like a very interesting spot in this space of how do we do error handling in C plus and now we have it in the standard so I think I think it's it's really cool so let's let's do like a quick overview of like how is that expect that fits into the picture here so let's say we have a function which is going to um pause the string and then and then pass like a string that represents a floating Point number and it's going to pass that string and return the number okay very easy maybe you need that if you're implementing like a lecture for a programming language or you know calculator or whatever so so this is our function here it gets a string View and it gives you a double back okay very easy we're not going to implement the functionality ourselves you're going to use studroidard which is the function that actually does the thing except it has like a bit of an awkward interface but so we're going to just wrap it basically here so if you haven't heard about stir chart now you have it does exactly this you give it a string it gives you back a double okay so so this is our function and then if you want to use it we're just going to call it on a string and we get the number back and we reprint it okay now obviously this string is not a number okay so you see it's not a number so what's going to happen what is this actually going to print anybody knows sorry what no no zero exactly if it doesn't know if it can't pass the string it just returns zero so this is going to print zero and so now we don't have any idea whether it printed zero because the string actually contains a zero or whether it printed zero because you put a wrong string in there right so we need to do some error handling so the default mechanism for error handling in C plus plus is exceptions that's what you know every that's like Brianna recommends that's what a lot of other books recommend this is the default mechanism we have for error handling and C plus plus so let's do this with exceptions so um so study actually has this weird interface like it actually um if if it didn't pass so it gives you back kind of the the beginning of the string and the end of the string when it was done parsing and if those are the same then it didn't do any pausing so that's the way you figure out that something went wrong in there so you can compare begin and end and if they're the same you know okay there was an arrow in there so you can throw an exception and then there's actually another error that can happen your number your string can be just too too big it it's not going to fit into double you can write one e 900 999 right and that's not a number that fits into the type double and then you get another error uh Returns the Special Value huge vowel and you can also capture that and you can throw another exception right if that happens and then on the uh the user side you have to wrap this whole thing into a try block and then you have to catch different exceptions you can handle them okay so this is we all know how to do this so on the one hand this is great right because you have the happy path and the error path like nicely separated you can also like you know if you don't do the try catch here um you know it's going to be you can handle it you can throw it like unwind the stack you can be handled somewhere else further up the cold stack so this is really great for cases where something exceptional happens and you need to like stop whatever you're doing and you know do something else I bought everything this is great however in this case this is probably not an exceptional thing this is probably something that's going to happen quite often right it's not really an exception it's more like something that can happen in your code right so you don't want to pay all this overhead because exceptions they don't have typically on Modern platforms and your runtime overhead on the happy path but they do have an overhead a significant overhead and both runtime and also binary size if you do if you do have an exception right so so you have to store all this information for unwinding the stack so your binary gets big so it's a problem on embedded systems if you want to have a small binary size and also the error path is going to be really slow because during an exception is a dynamic memory allocation right so you can also not do this for example if you if you do some low latency stuff or real-time stuff you can't call stuff which allocates memory right so and you want to do this if if something bad happens you need to give up but in this case it's just normal usage so you don't want to pay for this overhead and on some systems you can't actually surveys uh consistently say that about half of all super soft developers don't use exceptions either in some parts of their code or nowhere in their code right so exceptions have downsides and you know we'll see what we can do is we can do what the C people do we can return an error code right and then it's kind of nice because it forces you to check for the area right and there's no runtime overhead here anymore this is like the maximally efficient solution so you check for the error code and if the if there's no error code if the return value is okay then you can you can do your thing but it's kind of weird right because now the error handling takes over the function signature right so the return value is now just the error code and the actual return value is encoded in this in-out parameter so you have to create the double first and then pass it in by non-const reference and then so it's kind of this really weird awkward interface so in CBS 17 we got set optional is that optional is in my opinion much much better much cleaner and Stat optional is um great if you have either a value or you don't and the reason why you don't have a value is either obvious or unimportant right so so in all of those cases set option was fantastic it's not really a good error handling mechanism though we're gonna we're gonna see why so here instead of returning a double you're returning an optional double so this is now a very clean function signature again and then on the usage side we have to take this optional we have to check if there's a value in there and if there is if we dereference it we get the value out if there isn't we do our error handling so uh you know it is this is nice and clean um however we now lost the information about the error here there's two different things that can happen but the only thing we can do um if something goes wrong is you can just return an empty optional right so that's the error state so we don't have a way to propagate which of these two errors actually happened but maybe you want to let your users know you know was it an overflow or was it an invalid string and with an optional you can't do this and and this is where expected comes in so if you return an expected so where optional is either a value or nothing and expected is either a value or an error okay so now we're returning an expected and it's actually very similar to an optional in in the way the way you use it so if you want to construct one with a value you have this implicit conversion from value to expected so there's no syntactic overhead for the happy path you just return your value and then for the error path there is a little bit of syntactic overhead you have to then if you want to construct an error you explicitly uh have to construct it but still unexpected I should also say that the error the second template parameter is not doesn't have to be an exception type it can be any type it can be a string or something else it just can't be avoid um and so you create the error version with that unexpected and then on the user side it's very similar to optional you can compare it to Bool you can convert it to Bool and if it's true there is a value inside you can dereference it but if there isn't you now have this new function called dot error which with which you can get the error out right and now you can do the error handling like this and so so this is the API you can construct it with the value you can construct it with just the default Constructor and it's going to give you a default constructed value and then you can construct the error state with unexpected um and then this is all the same as with optional you have an operator Bool you have dot has value which is the same and then you have you can dereference it you can do dot value you can do uh dot value or that's all the same as with optional but you also now have this new thing here dot error which lets you get the error out okay and so this is I think very straightforward and actually this is such an obvious thing that I think most like Frameworks or you know certain companies I've worked at they had a very similar type always somewhere right so so we had boost outcome and Juice result and lots of other Frameworks have something very very similar um the difference now though is that it's now in the standard so now not only do we have this functionality that we probably already had but we have a vocabulary type which is in the standard which we can all agree on this is the the way we can do this now and so the cool thing about that is if different libraries and different apis agree on you're going to use stood expected then you can do monadic error handling across API boundaries and that's really cool and this is something you couldn't really do before and this is where it really impacts C plus plus I think in a significant way let me let me show you what I mean so let's say we have a vector of integers and we want to just add them all up okay this is the stuff at the bottom and then the way we add them all up as we call stood accumulate that's an algorithm in a standard Library and then at the top is the implementation of that accumulate that's in the standard library right so it just kind of takes two operators and yes we can do this with ranges but you know this is not the topic of the talk today you get the two operators you just operate iterate over the whole range and you call the operation on every element you kind of add them all up the operation in this case is is addition um and so so this is straightforward but what do we have what if we want to handle uh uh integer overflows right so signed integers can overflow that's undefined Behavior if you add up a million integers that's maybe going to happen so you want to cut catch that case you want to catch the case of integers overflowing let's still accumulate how can we do this today so what you want to do is you want to accumulate the basically short circuits if there is integer overflow and just abort what it's doing and and just return an error okay and so with stood accumulate the only way we can do this today is we can throw exceptions because soot accumulate has no other way to terminate the loop okay so the only way we can do this is we can pass our own custom Edition which you can do with the Lambda here and just check for the Overflow manually and for the underflow as well and then if that happens throw an exception and then that's gonna that's gonna short-circuit to accumulate but then again we're paying for all the overhead of exceptions and there are situations where you don't want to do that and so what's that expected what we can do is we can Define our addition in such a way that instead of returning the kind of added integer it returns an expected of an integer or a numeric error okay so this is now the new return type for our Lambda and now whenever the error happens we just return and start unexpected and now in the accumulate implementation the way we modify this is that we say well we're going to apply the operation we're going to add up the next two integers but then that's going to give us an expected that's the Lambda and then we're going to check if that's a value and then we just continue but if there's no value we have an error and let me just return the error back out right so we terminate the loop and we just return the error and so the only ugly thing about this is that um accumulate actually can have a different uh the type of the return can be different from the type of the numbers that you're adding right so you can add num integers but then get a long out or something so what we need to do is we need to um this is the kind of ugly bit of template meta programming here is we take we have to take the return value of the Lambda which is like int or expect or error like expected of into error unpack the return type of the Lambda take the error out construct a new expected type and put with the value type of the accumulate and put the same error type back in there so this is kind of the ugly template meter programming here the only reason it's acne is because I really wanted to fit this on one slide if you factor this out into its own meta function you can make it a little like a lot nicer but then it's going to be it's going to be longer um and so the really interesting thing here is note that the error type never appears at the top the top doesn't care about what the error type is it's completely generic on what the arrow type is it's just the stood expected of something and something okay so so this is kind of generic uh kind of error propagation across API boundaries where the different libraries don't care about what the error type is you can do that with expected I think that's really cool okay now you might you might think okay what is this numeric error thing here so is this like a base class of these two errors here and wouldn't this mean that we get slicing because we now pass only the base class if and so yes don't do this with inheritance you can do something a lot better we can make numeric error a variant of the different eras um that that we can get and we can stick that variant into the expected and that's a really really powerful pattern that allows you to do something else which is pretty cool so um it allows you to have like different types of errors and different layers of your stack let's say I don't know we have a parser we implemented parser for some kind of language and then we have on different levels of the thing we can have different errors we can have a file read error and then later we got the file you're parsing it so we can have a pause error so what you can do is you can just kind of accumulate these different errors in a variant and then pass it up and then at the point where you um you you do the error handling um The Happy path you just check if there's a value if there is you just do your processing but if there is an error now you can you can have to do this the visit on the variant we saw this earlier right and then we can have different lambdas or function objects handling the different error cases you can do this with wizard and this is actually really nice um and so so the cool thing is also that the wizard actually forces you to implement all the overloads so now maybe you have a new layer somewhere in your in your stack where maybe you get your code that you want to pass from the network and then that can error out and so you introduce a network error somewhere deep in your stack so you just add that to your variant and then you're going to get compiler errors all the way up and you have to add this network error everywhere and then at the site where you do error handling you also get an error because you need to add the network error here as well and so you add a Lambda here to handle this case you can't forget to handle this case because the compiler is not going to let you and here you can either handle the network or you can rethrow the error right and pass it further up and so this kind of looks like try catch now right except you don't pay for any of the overhead of exceptions it's all very very efficient so this actually is most similar to probably something like Java checked exceptions if anybody's familiar with that um how do I put this it's not universally accepted that this is the best error handling mechanism in the world let's put it diplomatically but there are cases where this is a good way of doing it and and now it's expected let's let's see do it in this way so there's actually one more thing um there's these monadic functions were expected which optional has and and expected now also has them and then or else transform and then also transform error and error or that lets you kind of chain things like that so you know you can uh this is like a from the paper you can you can have a expected and then if if if it's an error you can just have a continuation where you do something with the error or if it's a value you do something with the value and it kind of short circuits whenever you have an error here here's a kind of more real world example here from John John wakeley you can you can give it kind of lambdas at each stage and it's going to pass the value into the Lambda or the error into the Lambda and can write these continuations and so we thought for a while that we wouldn't get less than C plus 23 um it would have to wait for 26 but actually in Kona at the meeting last week we uh actually voted this into CSS 23. so this staff actually did get into CBS 23 after all at the last minute we we added it so I'm very happy about that so now it's also consistent but optional which also has these so that's expected and I I hope I expect that it's going to pop up in uh many different code bases because it's a very good erranding mechanism in many cases um come to the third section of the talk Emily span an empty span that's my personal favorite that is literally my favorite feature in C plus 23. and so if you do anything that has to do with scientific Computing or Graphics or I don't know signal processing or any other kind of number crunching this is really really cool and and it's going to change everything so um this is a paper that's been in development for also a very long time it went through 18 revisions it has a very long list of authors people have worked on this for a long time and then we didn't get it into 17 we just about didn't get it in the super fast 20 but then it turns out that there's a lot more work to be done and then we did manage finally to get it in the C plus 23 and now it's on the standard and it's really really awesome and let me tell you why MD span is awesome and they need to like rewind a little bit tell you a little bit of a personal story so this is me many young me many years ago this is before I worked on Ides or developer tools and this was before I was doing music software this was actually before I knew anything about C plus um so at the time I was in in working in astrophysics um so this is the leibniz institute for astrophysic in Potsdam which is where I used to work many many years ago and um it's not so far from here and so so um the things we were doing there were these numerical simulations of of the universe basically um and so so the DDA here is you look at large-scale structure of the universe so like galaxies and and Beyond kind of Galaxy clusters and like kind of the really big large-scale structure so so what you do is you you want to have a numerical simulation of how the large scale structure of the universe evolves so what you do is you have a box they have a cubic box which is hundreds of millions of light years across so like one Galaxy is basically one pixel in there and then uh you put in some initial conditions which you get from the cosmic microwave background some kind of gaussian noise with some constraints in there and then you put in uh you say this is just gas and then you put in the equations for hydrodynamics for how gas behaves that's the one thing the next thing you put in is um the equations for Gravity so this gas is kind of self-gravitating and the third thing you put in is Cosmic expansion because the universe expands and then you just throw all that in you get a bunch of differential equations you can solve numerically and then you just evolve the system and you get something like this and then you you look at this and see if it looks anything like you know the large scale structure we see with the telescope and if it does then your theory is correct and you can write papers about it and all of that stuff and so so I've been doing this for a while and and so we have these um sorry I have not been doing this for a while now but I used to do this many years ago um and so what you do there is you have this 3D box and you track quantities like density velocity and stuff like that and so so uh you need lots of arrays multi-dimensional arrays you have 1D arrays 2D arrays 3D arrays most commonly you actually have in this particular use case for the arrays uh because you have 3D and then the fourth dimension is what's the quantity you're looking at is it density is a temperature and so on and so later I found out I went into audio it's the same thing you have like samples and and channels and frames and it's essentially it's just a 2d array with your data and then if you go to image processing it's there's also lots of multi-dimensional arrays there so it's kind of you you need the stuff and so when I was doing astrophysics back back in the day I didn't know anything about C plus plus that wasn't really a thing um I was studying physics and so everybody around me was using fortrans so I was also using fortrans so Fortran was actually the first programming language that I learned it was never meant to become a programmer that came later just had to deal with Fortran at the time so that was my first programming language and here's how you deal with multi-dimensional arrays and Fortran who here knows Fortran or has done stuff with Fortran okay yeah a few people okay cool so so this is Fortran 95 this is what I was using at the time so multi-dimensional race and Fortune are actually really cool because it's a built-in data type it's native data type so programming with multi-dimensional rays and Fortune is actually really beautiful here's how you declare a 3D array and then you have a loop and then you Loop over the array and then you do something like in this case we write some number into every element that has something to do with the indices it doesn't really matter but you just kind of loop over the whole thing and um so this is nice because it's a native data type you can just multiply the whole 3D array with a number and it's going to multiply every element with that number write that out you don't have to write a loop it just does it you can you can print the whole thing and again that's just natively supported so that's actually nice because C plus 23 we got formatted output for ranges Now new and C plus 23 that's that's one of the like newest ranges things that I didn't talk about we just got in csr23 well guess what fortnite could do it in the 60s right so um so this is a static array um we can also have a dynamic array allocated on the Heap so you just say it's allocatable and then you allocate it and then you use it you don't have to worry about deleting it again it's going to automatically do it when it goes out of scope so so rays and Fortran are really beautiful and now then so I was doing this for a while and then I changed projects within this astrophysics Institute and and I got to work on a code base that was written in C so that was the only other language that anybody in that field was using at the time it was either fortune or c and Fort at C was kind of the weird new one and so um and so uh so this is how you this is how you use static multi-dimensional arrays uh in C this is okay right but but um if you want to do Dynamic arrays and see this is how I was taught by my supervisor to do multi-dimensional arrays and c and this pattern was all over the code base there was like 100 repetitions of this all over the whole the whole code and so you have to you have to uh declare this pointer to pointer to pointer if you have three dimensions and then you have to do this Loop or you malloc every Dimensions like kind of in a particular way and to this day it breaks my brain like in what order to do this and how to write this Loop and I can't quite get it right and then this is the code that actually does anything useful this is just our loop as before and then you have to free because it's C you have to manually free every dimension in the reverse order in which you're allocated in right so that's quite horrible um uh actually much later I found out this isn't even in C this is not a great way to do this like because you have these two problems here you you have so uh these like multiple indirections right because you have pointer to point to the pointer and the other problem is that your data is probably not going to be contiguous because you do these like separate uh mallocs there so in C A much cleverer way to do this would be to um allocate a 1D array which is going to be the whole data which is this thing here and then you you iterate over it with 3D indices and you just pretend that it is a 3D array right and then you have this formula there how to get from the 3D indices that you're looping over to the 1D index and the 1D array that you actually allocated right so this is kind of the formula there and so if you're now not in C but in C plus plus then you can say okay so I can maybe make it a class and I can stick this formula into an operator parampara and then you just give the indices you know as parameters to that operator and it's going to return your reference to the correct element and then you stick that whole thing into a class and you make that class a template you template it on the value on the on the element type and then you have some kind of multi-array template class template who here has written a class like this okay that's like half of the room I have written this type of thing maybe five times in my career um it gets really fun if you want to template it also on the number of Dimensions because then all your functions are like variatric templates and then if you have if some of your extends are known at compile time you want to get the optimizations right because you know how long the dimension is and then you like everything becomes context for as well and then it becomes really fun and like it becomes really hard to do this right and so so the cool thing about NV span is that they basically solved all the problems in this space and we don't have to worry about it ever again we can just use it in in the standard and so um earlier this year biander actually wrote an email to the mailing list of the C plus plus committee and he gave me permission to put this here on the slide he was like can anybody recommend the Chris tutorial for MD span and he followed it up with an email saying but I really like is a short introduction for non-experts and so um so here's my attempt this is my attempt at a short 10-minute introduction to MD span so let's say again we we have we have allocated and 1D array this is just a block of data okay so it's still the same as in the C example and now what we can do is we can create an MD span which is going to wrap this data and look at it as if it were a 3D array so we just declare an empty span we give it a pointer to the data and then we give it the four the three extents of the three dimensions okay and then we can just use it we can we can write a loop and so there's three things that are interesting about this um one is it heavily relies on ctet class template argument deduction so you don't have to write MD span angle brackets blah blah blah blah blah um it's just going to deduce it automatically from from the the Constructor arguments this is number one number two is it uses the multi-dimensional square bracket operator which is a new thing in C plus 23 so this is an example where we added a core language feature to support a library feature which we don't do that very often but this is one of those examples and you can use this also now for for your own classes right you have this square bracket operator with uh with multiple indices like previously you couldn't do this you could do square bracket operators kind of multiple in a row but it was really difficult you had to like pass around these proxy types and anybody has done this this is not nice and so so now you have this this is much better and the third thing that's important here is that mdspan doesn't own the data so MD span is like it's like span you know it's but the multi-dimensional version of it so it's just it's a view into the data basically but it's not owning it so the the array is actually allocated outside so you can have a different empty span looking at the same data and pretending it was a 2d array with a different shape and as long as it's the same kind of size of underlying data it's going to work just fine you have this dot rank function which is going to give you the number of Dimensions so three or two in this case and then you have this extense object so you can specify the extents and you can do it explicitly and this is really so so if if you if you just want to give it the extent you can do it like that but this is very interesting if you have a mixture of static and dynamic extent so some of your extents are known a compile time others are only known at runtime and so now we can create this extends object explicitly you can say Okay so the index tab is in it's very important it's not the element type it's the index type uh you can actually use signed integers in there so you can have negative indices this is also you can do cool stuff with this a different topic um so we have indices and the the First Dimension is size four the second is size four and the third one is run time size and then you just pass that into the empty span when you construct it or you can also put that in as a template parameter that's the other thing you can do and and then you can construct the MB span and you can give it the pointer and either only the extent of the dimensions that are known at runtime like this and and the static ones they're already known or you can give it all three extents again but then you have to make sure that the the ones you specify for the static dimensions are actually matched the ones that you specified as a static extent otherwise you get UB so you need to be careful with that um and so there's also this case when audio extends are Dynamic and then instead of typing this out you have this very handy type def D extends which means we'll extensor Dynamic so you just give it the index type and the number of dimensions and so MB spine actually has four template arguments um the first one is the element size sorry the element type so that's pretty obvious the second one is the extents we just talked about this the third one is also very interesting that's the layout policy and that's basically how you get from the multi-dimensional indices in the NB span to the one-dimensional index and the underlying array so that's this formula of how you get from i j k to like the index and the underlying data and so there's different layouts that are possible right so there's you know these two they're very popular we have in CNC plus we have row major order where kind of the last Dimension is the contiguous one and then in Fortran is the other way around we have column major order and so um anybody who's used both languages knows that kind of you have this they're doing it in this opposite way and so MD span calls them layout right and layout left and why did they not call them raw major order and column major order well actually it does make sense uh in raw major order which one is the fastest running Dimension the one that's contiguous is the rightmost one right the one at the very right that's the dimension that's going to be the the contiguous one the fastest running one so it's layout right in a column major order which dimension is the fastest running one that's the leftmost one so it's layout left so I think it's pretty easy to remember so we can just use a custom layer we can just see we have a bunch of standard layouts so we have layout right that's the default you can check what's going on we have this dot stride which gives you the stride of every Dimension you notice here that the the last Dimension has strike one so that's the contiguous one if you do layout left this is what you want to do if you get the array from Fortran you do layout left and then the First Dimension is the one that has spread one but then you need to be careful that if you Loop over it like in C plus plus you need to invert the loop right you need to invert which index is where otherwise you're going to be not looping contiguously and that's going to be slow so uh you have a bunch of standard layouts but you can also customize it you can write your own layout and that's really really cool because depending on your use case if you do image processing maybe you want to do some kind of tile layer because you just look at you know one part of your image at a time and then this is going to be the most catch friendly way you can you can do that right so you want to implement a layout like this or there's other layouts like there's a hillbot curve it's another mapping from multi-dimple Dimensions into one dimension this is a two-dimensional about curve this is a three-dimensional feel about curve and when I was doing this astrophysics simulation we actually had 3D hillbot Curves in there and I wish we had NB span back then because it would have made it so much easier to write this um and those layers they don't even have to be contiguous they don't even have to be unique you can have you know different indices mapping into the same place and memory for example if you have something like a symmetric Matrix right so so that you have top half and the bottom half and they kind of store the same stuff so so you can only store the bottom half in memory and whenever anybody indexes into the top half you just redirect them to the bottom half and then you only need half the memory right so that's very efficient and so so I actually went in and and implemented just as an exercise I just implemented this kind of symmetric Matrix I just store the bottom half layout because I just wanted to know how to do it and I just sat down with basically just the paper the MB span paper and the reference implementation of MB span from Cocos and it took me about an hour to figure this out so it's not difficult it's not black magic and so I wrote this code this is literally like if you copy paste it into the compiler it's it's literally going to work this is like the the the code that I got to work so so what you have to do is you have to write this layout class and you just can plug it into Mb span as a third template parameter so you because it's a matrix I I say now okay it has to be two-dimensional I only care about two-dimensional matrices in this case so I have a required Clause rank as two and then here I need to make sure that it's um it's symmetric I do this trick here where um if all extents are known at compile time so the number of dynamic extents is zero then we can do a static assert that they're the same if at least one dimension is only known runtime you need to do a runtime search that the extends are equal right so it's a square Matrix that's the thing you need to check it it's a square Matrix that the two extents are equal and then scrolling down this is the magic this is the formula how you map from the top half into the bottom half you just swap the indices if it's the top half and then this is the formula that gets you into the right place and the contiguous array and then there's a little bit of boilerplate I had to write to tell the MD span the required span size that's like the the size of the underlying array which it needs to know and then there's these other thingies to let it know whether the layout is unique exhaustive and strided so exhaustive means every combination of indices Maps somewhere and unique is uh like two combinations of indices mapped into a different place and memory which is false in this case and this works this compiles this works if you would put it into a library you would need to make it a little bit more complete you would probably have a copy Constructor and operator equals equals an assignment and all of the stuff in my case I didn't need that because my test code didn't use those things but you probably want to want to add those two if if you want to put it in the library or something like that um and so this is the third template argument of MB span and this is really really cool there is a fourth argument here which is the default access sorry the accessor policy and that's if you then found your element how do you access it and the default accessor just returns your reference to to that that element but you might want to do something else there you might want to access it through an atomic graph if you want to do it from multiple threads in a weight-free way or GPU people use it to access data on the GPU and you can write your custom accessor for that and so that's also really powerful and I would say access for known owning types like spats and we span they're kind of like allocators for owning types like containers it's most of the time you don't have to worry about them but if you do have a use case where you need to customize that you really really need to because there's no other way to do it so so that's really cool this is MB span uh there's talks that go into more detail uh there's a talk by Bryce levelbach who did a talk earlier this year one hour just about MD span I think was it Nevin Lieber who did a talk about MD's Planet this year's cppcon so that's kind of more material about this popping up so if you do want to dive deeper you can do that for example here Bryce he talks about how to use empty span and algorithms why mbspan doesn't have iterators and what you do instead and it's it's a it's deep topic so if you're interested watch these talks um there's also another feature coming up at 26 which didn't make it for 23 which is empty array that's the owning version so MD arrays jmd span what Vector is to span right this is like the owning version and I'm very happy that so we're going to hopefully get this in 0.26 but I'm very happy that we standardized the non-owning version first because this is the more generic one right if you have an array that comes from a piece of Fortran code you can do it with a non-owning version but this one is not going to be very helpful so we got the generic kind of non-owning version um in super 23 and that's really cool and with this we come to the last uh promise you not very long part of my talk which is the print and it's the print is is going to change the world quite literally because it's going to change how we write hello world no we didn't change that for 30 years or something so this is really really exciting this is a paper by uh Victor zverevich and that paper also went through many many revisions 14 revisions and was in development for quite a while like all the other features that I've talked about today and so yeah this is this is going to change hello world this is this is really cool so if you open any programming book about C plus plus obviously hello world is the first thing you're going to see um this is I just took be honest be honest book and this is literally the first code snippet in that book it is hello world and hello world is everywhere if I open up my favorite IDE and I just open a new project right so I say I want to see bus pass executable and this is what I get so again hello world that's like the default program that does something right so interestingly sea lion gives me something slightly different than Diana's book it adds the state endral here and the return zero whereas Biana has backslash n and no return so let's not talk about those things let's talk about what else is wrong with this code so let's see how let's do a code review here so what what's wrong here so so let's see how it has quite a few problems so let's see how it is notorious for bad performance right it's slow it has this really weird interface as well like it has this left shift operator and it has this like zoo of IO manipulators that you kind of need to know about so for example if you print a Bool what is this going to print one exactly print one what you need to do to make it print true yeah good stood pool Alpha what header is the bull Alpha in Mayo manip no it's not it's an include IO stream actually but others like stood set W which is the one you need to set the field with that's an ioma nib so you kind of have to remember this this is really really uh kind of awkward um so it's the blue Alpha but that's not even the worst but the worst but is this so if I do this in English it's obviously going to print hello world but English is not my first language English is not my second language German is my second language but German is also not my first language my first language is actually Russian I was born in Russia and so if I want to write hello world in my mother tongue what am I going to get so on Mac OS it's going to print the right thing on Windows I got this and I didn't make this up I copy pasted this from uh from what's actually happened so this is my Mac here this works but I have a Windows machine at home and I tried this and this is literally what happened and I just copy pasted that into the slide so this is what it actually prints so what's going on here so we have the source encoding we have the execution encoding so the source encoding in this case is utf-8 the execution encoding is probably utf-8 or utf-16 depending on which compiler Flags they're using with Visual Studio but actually uh it doesn't matter what compiler Flags I'm using because I don't get a useful output in any case because it gets sent to the terminal terminal doesn't care about either the source encoding or the execution encoding the the terminals page code page 437 and code page 47 is you get this and and yeah basically so stutcl just takes the string uh sends it over as a bag of bytes and then the terminal does whatever it wants and on Windows it does it does that and so so that's very unfortunate you know this this is kind of one of the reasons why the python people laugh at us right because they're you know it's it just works okay so so uh we kind of partially solve the problem in C plus plus uh 20 we introduced that format as the format does a lot of things right it does handle Unicode properly this is good it does handle things like the bull it prints Bool it does the right thing if you wanted to print one instead of true you you have a Syntax for format specifiers which is you know similar to print F but different you use this colon but it can do everything printf can do and more right so it's a modern version of that so you can print I don't know stood Chrono days of the week or whatever and it just works out of the box with set format and you can also write your own custom formatters and it's a beautiful Library um it's also a lot safer than printf so if for example it's a printf you know if if you it's run runtime bar arcs right so if you omit an argument then you get like weird undefined Behavior or security vulnerabilities or stuff like that uh stud format gives you a compile error right so it's all check the compile time and the other nice thing is that the io stream always puts like pulls in locales which is a nightmare if you care about binary size so the format doesn't use Lookouts At All by default you have to explicitly specify that you want to use the Locale uh you can you can specify that by explicitly passing it a Locale and only then does it care about locales and yes it's going to do the right thing it does have support for it but it's opt-in rather than opt out or rather opt-in rather than you have to have it and you have to have all this junk and your binary um and so so so stood format is great but um we can now reasonably deal with strings and unicode and all of that inside our app but in C plus 20 we still don't have any way to get it out how do we print this so what you end up doing is you end up doing this in the end again right so so this is the this is the this is one way to get the string out in zip20 and that's just not great for many reasons right so first of all you're creating a temporary string which you don't need and you call Operator left shift left shift which is a function call that you don't need and then you have already a formatted string and then you do formatted output on a string that's already formatted and that's also kind of just a waste of CPU Cycles it's it's not a good solution and and you can do this more efficiently but then you have to go deep and know what you're doing and it becomes ugly and complicated and C plus 23 everything is great because we have the print and it's just going to do the right thing and we can forget about IO streams and never never mention them again and so print is just going to do the right thing and it's even going to do the right thing on windows with the terminal because if you look into the standard the way it's specified is that it says well if you have Unicode and and you are on something that can handle Unicode then it will call the correct system specific API which Windows has for the terminal to display you know to handle that Unicode so so you get consistent glyphs whenever you it's possible on all of across all of these systems uh and even in the windows terminal so so it just works and so the other nice thing about the print is that it kind of it's built on top of that format so all of the nice things about statforma just automatically transfer just that Sprint Print right so yes it handles Unicode it has the same language for um format the script as this format has it has the same um kind of safety in the sense that arguments are checked that compile time excuse me arguments I checked at compile time you have the same thing that it doesn't pull in local Health unless you really want to and another nice thing that it has it can also print to other streams not just to see out you can give its.cr or whatever other stream as a first optional kind of that's a different overload first argument and then it's going to print without that stream right so so print solves all these problems and we don't have to ever ever mentions to see out again so so this is actually the new hello world we changed and see the system key how how you write hello world except actually we changed it twice because as you learned from Daniella this morning we now have standard Library modules so we can also get rid of the hash included instead right Imports and so this is the new hello world except that um there's actually one more thing you still have to backslash n in there right so it still doesn't print the the the kind of new line character at the end automatically but we do have a thing for that now as well and simple 23 we have stood print line and that's going to automatically print a new line for you as well and we have that too so um I'm actually really curious which one of the two should be like the new canonical way of writing hello world maybe we can do a quick vote who likes the first version okay a couple people who who like this likes the second version all right so so okay that's very unanimous so I hereby declare the second version the new official way to write hello world NC plus plus and that is how C plus 33 changes the way you write code thank you and I think I overran even the 90 minutes that Jens gave me so apologies and I guess we don't have time for questions but I'll be around uh you can find me at the Japanese Booth all day tomorrow as well so please talk to me and thank you and apologies for keeping you here for so long [Applause]