the buffer overflow the infamous hacking concept that has been plaguing the cyber security Community since its Inception attacks leveraging buffer overflows have been the cause of thousands of hacks leading to the theft of personal information by cyber criminals that is eventually sold on the dark web but how to buffer overflows work why have computers historically been so prone to buffer overflows and how does buffer overflow give a hacker access to your computer and is there any way to stop them so what is a buffer overflow as the name implies a buffer overflow is on a buffer of memory is allocated for a particular data type something in the logic of the program goes wrong and more memory fills the buffer and the buffer has room for hence it is overflowed one of the most commonly seen buffer overflows originates from how strings are stored in C a string in C like this one is just an array of ASCII characters and we can create a string with this line of code when we go to print it the string prints out and everything works out just fine but how does the program know when to stop printing why doesn't it just print all of the data after the string too this is where things in C start to get a little weird you would think the answer is well obviously the length of the string is encoded near the string so printf just reads that number as the length well that's actually not the case remember how I said that strings are just an array of ASCII characters well yeah that's all they are the only way functions know that they've reached the end of a string is if they had a special character called the null bite if they don't hit that null bite they'll just keep going unfortunately strings that just keep going apply not only to displaying information but also getting information from the user this is where the hacking begins a well-known vulnerable function get S does just this it just keeps going in this code here when I create a buffer for a 64 byte string and use get S to get a string from the user at first everything seems fine if I give the program more than 64 bytes this is where things start to get a little weird because get S doesn't know the length of my buffer or the length of the input string get S will read more than 64 bytes eventually after 70 or so bytes my program begins to behave non-deterministically and eventually crashes get S is so dangerous that even the man page entry for get S says get S is dangerous and it should not be used but who cares how can data leaving a buffer give a hacker control of my computer hackers can abuse the buffer overflow by taking advantage of how functions call each other here I have some code function main calls function add on the right I have a diagram depicting memory in the program the structure is referred to as the stack when add gets called by main a few things happen first the arguments to add get pushed onto the top of the stack that's the numbers X and Y ad will use these later as arguments into its function after that the processor needs to remember where in Maine to go after ad returns this is referred to as the return address which is also pushed onto the top of the stack once all of the data is put on top of the stack add gets ran and add makes room for its local variables above all that other data add runs and eventually the program returns into main where the function got called do you see the problem if the called function ad has a buffer overflow in it the return address into main can get overwritten pointing to code that wasn't originally supposed to get ran let's look at a different program this is a secure server well not really but to get into the server it checks your password against a password that we can't see here in the code if you get the password right you get a shell on the server seems pretty simple but look how we're checking the password the first function that gets called is get S remember how the return address from Main was put onto the stack well now if we overflow the password buffer we can overwrite the return address and return directly to the debug function and get a shell without knowing the password our server has just been hacked that's pretty cool but if we've just stopped using get S does the problem go away no the unbounded string vulnerability is actually found in the a lot of other string operations in C including stir copy scanf s printf among a bunch of other functions now don't let this stuff scare you computer security has come a long way over the last 20 years with mitigations that make most of this code really safe even with the use of these dirty functions but those mitigations have taken entire other video to discuss [Music] when you're coding code defensively don't trust the input of the user at all assume they'll never play by the rules and set limits on how much data they're allowed to give you with n variants of functions like stir and copy and SN printf or if you want to try hacking in a legal ethical way go play a capture the flag or a CTF here I'll show you Pico CTF one of my favorites ctfs are a great way to be exposed to code vulnerabilities not only for the hacking's sake but also so that you can make your code more defensive before you start hacking away leave a like and then go watch this video on how these 14 characters will crash your computer