uh good morning everybody and welcome to my talk about lambadas the title is uh it's not as ambitious as you can see we are not going to tame lambas today we are just going to tame lambda's uniqueness so it's a bit less ambitious topic but I think it's not enough time in one hour to time lambdas um it's an experiment this talk in that sense that I noticed it if I prepare too much for the talk then I'm going too fast if I don't prepare enough then I'm surprised by my own slides so I try to hit the sweet spot and we'll see how it goes this time uh let's first talk about what this talk is not about I mean let's let's define the terms right so it's not about functional programming despite the fact that we are you're going to hear lambdas all the time uh it's not about type Theory it's not about you know duck typing versus static typing or like empty versus bottom types or whatever we are not going to cover these things it's definitely not a metaprogramming talk no no meta programming uh this is not about it I'm not going to explain it I'm going to not going to lead you through this and it's also not about performance optimization I I mean I'm not an expert in it whatsoever we are not going to look into the code into the assembly or something like this um you know so just you know what what awaits you so what this talk is about uh basically about this one right uh it's a clear statement of a problem uh that's how it Works in C++ or to put it more formally uh it's about that two lambdas that are synthetically and semantically exactly the same and I really promise you there are no hidden zero WID spaces somewhere thrown into it in uni code exactly two same lambdas you deal type them compare them the types they're not the same right uh and there is a good reason for it and uh obviously uh and we'll come to it uh but it creates all sorts of problems right you cannot for example put a couple of lambdas that look almost the same I mean what what difference does it make where I outut my my strings into a vector it it's not going to work out of the box uh despite lambdas being the same uh what's even worse you cannot do things like like that one you cannot deal type A Lambda and use this time type for example in your class uh to deare a data member it's not going to work because you know it's just this one unique Lambda there and you cannot have another Lambda even with exactly the same uh function type or corresponding function type and use it there so it's not going to work and as I said there are always good reasons for it uh and usually we can find those good reasons in the standard right uh so the good reason in the standard says that basically I mean it's not a reason but it's a kind of an exp explanation of the fact or a statement of the fact is that each Lambda expression uh basically produces a closure type and this closure type is a unique Class Type uh also unnamed uh and that's it so the key word here is unique so to define the problem a bit further uh this is what you get if you write a Lambda that does nothing and this is almost the simplest Lambda you can get you could skip the the the the middle brackets right uh what the compiler really sees is something like not really your Lambda but a closure so it defines a closure type that corresponds to your Lambda expression and it might look something like this on a modern C++ 17 let's say uh there will be a default Constructor in your closure type and then will there will be a function call Operator that does pretty much nothing uh you write another Lambda next to it and again a closure type appears uh notice the key difference the names there are different names different types right uh no matter what you try there are different types you cannot exchange them or use them exchangeably uh this is not the ideal situation and many languages took a different way like if you look at C or Java or python or python is duct typing but let's say talk about strongly type languages like C or Java you can use lambas exchangeably it's not a problem but they hide it be behind interfaces in C Shar they don't do sorry in C++ they don't do it uh there are solutions as many of you are aware there are luckily plenty of solutions right to the problem like for example simple lambdas behave quite well and by simple lambdas I mean non-capturing lambdas if you have a non-capturing Lambda you can just put a plus in front of every Lambda and if they have the same function signatures no problem whatsoever right uh it looks weird and if you if it's the first time you see a plus in front of Lambda uh that I understand the confusion I was also confused when I saw it but basically triggers conversion to a function pointer right so nothing else uh if you decal type such a Lambda with a plus in front of it what you will get is a function pointer with the corresponding signature or with the corresponding type so it's a function it's a it's a pointer to a function that takes string View and returns a void great how does it work under the hood well something like this so when you write a Lambda that doesn't capture anything uh it can be directly converted into the function pointer so let's introduce a simple function pointer uh type and alas declaration so it's a bit easier to comprehend what's going on and and somewhere in this closure type there will be a conversion operator to the function pointer which will be returning a static function pointer because you need a static function to to to be able to convert to a function pointer right if you have like a member function that's no go that's a different Beast so there will be some static function defined uh you don't see it obviously it's not like all of the things really are there but let's assume they are there and what the static function is doing is something very simple it's creating a default instance of your lum or sorry or your closure type and calls the function operator on it a function call operator on it so nothing really special happens there something you you know easy peasy everybody can understand what's going on um this also kind of works when you introduce generic lambdas to the mix uh kind of because this doesn't work uh doesn't work because it's a generic Lambda so it cannot be directly I mean it can be converted but now there there is a problem with type deduction for the vector the vector doesn't know what what really want from it uh it cannot deduce the type because the types of the corresponding function pointers are not matching especially the last one there is no function pointer yet there is only a a function template right somewhere inside this Lambda in inside this closure type but you can help the vector uh just Define the type yourself type it strongly with the time uh argument and you're done and in fact you can skip the pluses now because they're not needed anymore right so you can get rid of them uh and still it's just fine it compiles it works out of the box uh so that's fine that's those are let's say the easy situations are those are the situations we know how to work around uh where it gets complex is when you start capturing lambdas are very often capturing lambdas and they're not behaving well and in that sense sense that uh whatever you try now it's not going to work whether you put pluses minuses or whatever I mean add zero even to it it's not going to work and the reason is that once you try something like this uh you're going to get an error which basically tells you that there is no match for the operator plus anymore and no match for the operator plus you know you have to interpret the errors of course if you are in C++ simply means that you cannot convert it to the function pointer anymore there is no conversion to the function pointer so the plus doesn't work out of the box why not uh well it's it's it's purely like okay it's not hypothetical because but that what might happen in the compiler right when you capture something you can imagine then when you try to capture something into the Lambda then your closure type will have a corresponding member variable of the same type as you capture uh it doesn't have to work like this but it might be great uh there will be a Constructor to which you have no access of course uh but you can imagine there is a Constructor that takes this uh an argument of the type that you capture and initializes the member and now the big question is what do you put in the static member function what do you put as an argument to the Constructor in the static member function there is no default value that you can come up with right so uh this cannot work simply you cannot provide some discon verion to a function pointer just because of this so this doesn't work and I mean it's it's good right it's good because we don't want function pointers anyway right you don't want to declare a reference to an array of function pointers that takes a string and return nothing like this uh because your C++ Persona shakes when it sees it and and that's correct that's a correct response to something like this so we don't want function pointers anyway uh what we want is our C++ code code that's clear that's simple that's it doesn't have pointers everywhere and weird types uh so let's dissect it one by one let's imagine a scenario or let's take something like this um as a scenario that you have three different lambdas very simple lambdas or at least one of them is a very simple one we know how to work with it right it converts nicely to a function pointer no reason no problems whatsoever another one that captures something uh also doesn't do much right captures a stream and outputs something to it and the other one that's a bit more complex uh it captures by by move actually right so it moves an output file stream into the Lambda sorry for it that's my voice problems um and drinking doesn't help so we'll see uh it's mutable by the way because it has to be mutable whereas streaming something to the output file stream uh and changing the file stream and and now we have to think about what we are going to do with it how are we going to deal with such lambdas or this variety of lambdas that seemingly should work together but they don't uh the question you have to ask yourself then is what am I doing with lambdas or what happens to my lambdas and there are couple of answers right and generally speaking you either pass them to functions or you put them into containers or generally you know pass them around or you put them into containers so there are two scenarios that you have to consider one is the easy one the other one is not so easy uh let's start with the easy one and this is passing to functions because when you pass to functions you have options there are many options and the number one options which should pop to your mind is just passing uh through a function template so instead of using functions switch to templates uh we love static taping we we basically like static polymorphis because it's a form of static polymorphism right when you declare a function template that accepts an arbitrary Lambda and you're done and there are many ways to do it uh you can for example pass by reference uh which is not such a bad idea considering that our last Lambda two logs is a move only Lambda you can only move it so let's pass by reference it works out of the box uh you can also pass by copy if you want doesn't really matter then you have to of course take care uh that you do it correct corly uh and in this case it means that this Lambda has to be moved into the function because otherwise it's not going to really work uh and you're kind of done with it there is no other magic to it I mean it's going to work out of the box whatever you do uh you might hit some you know Corner cases but still no problem whatsoever there is another option uh C++ 11 came with C++ standard function and you can use St function for it right so St function is a a type erase type which DRS another cable whatever the cable is it can be a Lambda let's use it uh it's similar easy uh basically the code almost can go with no changes as compared to the previous one the only difference is uh instead of having a template a function template now we have a normal function but we have to maybe predefine the type or make a type alas for the readability right some something like this it's a function that or any cable that returns nothing and takes us to string we are good to go so let's go um uh with a small exception or actually a compilation error it's not going to work because s function requires that your type is copy constructable and this Lambda is not copy constructable it can be only moved into uh something right so even despite the fact that you are moving it doesn't matter State function Works only on types that are copy constructible luckily if you are on a compiler and a library that supports it nowadays we have move only function uh which you can use instead and which respects some things that the St function didn't respect even uh like the con propagation for example uh a b bit better type if you ask me uh if you move only function everything works no problems what ever the code will compile uh and no surprises will await you so we basically have two options either pass by template or pass by St move only function or St function depending on your needs how do they compare because you know you might have heard some gossips that St function is not efficient uh so let's see how they compare for different benchmarks or four different simple benchmarks uh the Baseline the number one is just you know calling a couple of lambdas so we Define 16 lambdas there are easy lambdas on purpose all of them work on Long Long don't perform any complex arithmetical operations some of them do capture some of them do not uh some of them mutate uh the captured values some of them do not doesn't really matter what matters is that generally speaking those lambdas are extremely fast to execute so there is even no division in them uh so The Benchmark the Baseline is lambdas and direct call to lambdas uh the second Benchmark just to compare is functions with exactly the same bodies as the lambdas which we call also directly and then the third and the fourth benchmarks are the corresponding things that you've just seen so one calling through a function template or cing through an intermediate St function or St move only function uh for the benchmarks I was uh on Linux with the 6.2 kernel and I think tiger Lake processor uh I don't know I don't think it's really revalence this in this case but let's keep it like this and unfortunately I couldn't measure it for msvc because msvc was uh uh protesting about my other things that I'm going to show later on so it couldn't quite deal with some code and and then it would be incomplete so I'm only comparing Clank and just see uh the Baseline is 1.0 so it's 100% And you can see that actually as long as you're using templates are good most likely because you know lambdas are con expert by default if they can be con exper and then you pass by template your all your code is going to be inl optimize away uh it's going to be blazing fast why passing by by template by copy is even faster than direct Lambda calls don't ask me it's not an optimization talk I didn't look into it uh but the lesson to be learned is indeed calling via the St function is awfully slow uh you lose a lot of performance uh and you know might be important if you have thousands of lambdas here we only had 16 of them let's move forward because there is another issue that's of importance like what happens when you put lambdas in contain ERS this is a much harder issue than just passing around to functions or passing lambdas around and for that one let's expand a little our let's say zoo of lambdas we have very simple lambdas this time uh we have lambdas that have exactly the same body notice that those two lambdas share the body in a way they only differ in what they capture and then we have the lambdas like we've had before so a Lambda that's that's a move only Lambda or a Lambda that's even not really following your interface in a way right so it takes two different arguments instead of just one as all the other lambdas and with this one we can build you know a nice uh 2x two table so we have different situations like your lambas might have the same signature different signature same body or different body depending on this there are different solutions and and actually the easiest one is the same type signature and the same body because if this happens if this is your case you can just use a factory um I mean obviously you cannot do something like this like what you can see on the slide it won't even compile right uh you cannot put those two lambdas that have exactly the same bodies they just different in the captures into the vector won't compile but what you can do is create a a very simple Factory like this it's a Lambda Factory right it returns Lambda uh this Lambda the make output it can be also a function but notice that make Lambda is not a generic Lambda or not a function template it's just a simple Lambda so the one that's being returned there is a unique one it's a totally unique Lambda one of them and only one closure T which generated it's a basically a haug of how to pass different arguments to this non-existing uh Constructor of a Lambda this will work out of the box if you do something like this no problems whatsoever you are done uh for a bit more complex things like per perhaps you have things that or lambdas that capture by move or by copy and especially by move I think by by move is is the worst one here uh you might tried different approaches because this code won't even compile now anymore and the reason being uh this Vector is initialized from the state initializer list and state initialize list items cannot be removed from so uh and we have moveed only lambdas right so this this is this is a problem uh luckily you can solve it either using the old approach which I don't have it uh because this uses iterators with some deal type or if you are on a fairly modern compiler you can use ranges for it uh create like a container of your streams and then transform the container of streams into the into the container of lambdas and you're done it's going to work it's really going to work uh the St s ranges two only works on msvc nowadays uh but you can write this function yourself or this uh this view adapter I think it's a view adapter right or something like this uh so kind of problems solved at least for the very very simple case when we have lambdas that share the body shape the type signature uh the other one I I mean I included it only for the completeness because it's really no problem if you have totally different lambdas where the differ in the signatures doesn't matter if they have the same body or not we all know the solutions there are design patterns for it right you just make some adapter for it and you're done you adapt one interface to another interface so it's it's really not an issue I would say so imagine like this Lambda is a good Lambda right it it has the correct type we are good to go but this Lambda is not a good Lambda it has an incorrect signature or text incorrect arguments you just drop it into another Lambda or whatever you want and you adapt it uh to your interface uh and you delegate the problem to your colleague basically because once you've done it uh your colleague has to deal uh with this problem like uh we have same type signature and I mean function type signature or the corresponding function type signature and different bodies and we want to put them into a container right we cannot use templates I mean there there is really no unfortunately there is no trick to do it with templates at least not easily uh but we can use of course the old good solution the St function or the St move only function function right that will work out of the box type eraser uh no problems whatsoever so let's do it let's do it let's put our lambdas into a vector of St functions uh I mean obviously not St functions because now I have a lot of move only lambdas so we have to use move only function but it's going to work you don't have to worry about it you don't have to do anything special it's going to work it's going to compile and it's going to do what you intended to do let's Benchmark because you know benchmarking is the is the source of our wisdom about how good are things going only three benchmarks this time and the first one is still the same as previously so you know it's still my Baseline Benchmark in a way that I'm calling the lambdas directly because the compiler can apply lots of Tricks then uh especially Clank is aggressively doing con expert so calculations uh in inline all those lambdas right so that's great the next one is basically introducing an array of function pointers so I convert all my lambdas and those are kind of prepared lambdas because I told you some of them are capturing and you cannot do it so I made sure that they didn't capture they did some other tricks to re reference other variables but what's going on here is that I I have an layer of indirection I have an array of function pointers instead of direct calls to lambdas and finally my third benchmark putting or using the stood move only function and calling the lambdas uh one by one and by the way I'm using Google Benchmark for it so I think that yeah uh a detail but that's what happened okay the results uh as expected it's a disaster in a way right uh uh it's a disaster because we are introducing a lot of indirection uh you can even see I mean Clank is still kind of okay right it's it's not that bad but GCC is doing a very bad job and you can even see the slowdown in the array of function pointers it comes from this one level of indirection then instead of inlining your function the address of the co col has to Bel loaded and and it has to be C right so that's that's costly operation uh all those calls returning uh stock adjustments and so on slowdowns are horrible uh and you can actually see as especially in the Clank case that there is some slowdown because of the array in Direction and there is additional slowdown because of the St function it's like almost a factor of two that it's going even slower so what's the reason the array pointer in direction is quite clear right that's the penalty we are paying the other the other penalty we are paying is things that happen under the hood in the St function or stood move only function there might be a hip allocation it's not there by the way uh are very simple lambdas but what we do is we are either getting virtual function calls or some function pointer in Direction because of the type eraser okay just a quick question Who here ever implemented a type erase type uh type that's great that's great for those who haven't don't worry uh you will will be able to if you haven't heard the talk yesterday of CLA because he was talking about type eraser there are two slides about type eraser 101 it's the simplest form of type eraser uh used for cbles that you can make in my opinion because you know I was ambitious I thought that the implementers of the standard Library kind of screwed up with the St move only move only function and I can do it better uh I was hopeful at least I implemented it in total I think if eight different ways of type erasing even relying on undefined behavior um and the simplest one that is easy to show is something like this so there is an in place Lambda uh a structure that will rope a Lambda expression what it has inside is a storage for Lambda because I have to store the Lambda somewhere it's a fixed storage no Heap allocation so I have to limit of course my Lambda size and then there are two pointers one to invoke a Lambda and one to destroy the Lambda you have to take care of destroying the Lambda because you own the Lambda you will construct it in the storage and you have to invoke it uh so there are two pointers uh and notice that both of those pointers if you look at the types so so how the types are defined are taking the pointer to our storage uh as a function argument as the first function argument so this is a type eraser uh piece there is an operator for calling which basically forwards the arguments uh to the Lambda in the storage and there is a Destructor that calls the distruct and that's all I mean that's not all because you also need to initialize the destruct and the invoke and nowadays that's fairly easy I mean before before lambdas it was really not that Heap let's say to do it nowadays it's fairly easy you just write a Constructor that takes an arbitrary Lambda and in initialize the invoke pointer with a Lambda expression that's automatically converted to the function pointer it's not capturing Lambda so you can do it it takes the pointer to our storage and then basically casts the storage to the Lambda type that we are aware of and passes the argument to it for destroy it's roughly the same it takes the pointer to the storage casts the storage to the Lambda type and calls the destructor in it uh which basically means we only have to create the Lambda in the body and that's all right so we are creating really constructing the Lambda in place into the storage of bites uh so I was ambitious right I said I was ambitious and that's that's actually the fast implementation I made uh relying on undefined Behavior didn't pay off but this was the fastest implementation so that's the Benchmark number four and I quickly learned that standard Library implementat us are smart people and all my two weeks effort went to nothing so that's not the way to go don't do it generally speaking this especially the St move over only function is really fast uh you hardly can beat it maybe in some special circumstance stances uh St function is a bit slower this one you can beat but St move only function and this is The Benchmark of the St move only function it's a slideware so the not the full name is mentioned there it's faster generally speaking don't go this way uh so what's the solution I mean um obviously there must be some way of doing it faster right because otherwise I wouldn't be having this talk uh three questions mark what can you do about it what we really want is is at least what I would really what I really wanted to have is something like this this kind of syntax that I can for example create uh a container of functors with the same signatures like in this case put them in and then maybe call all of them let's say for the beginner just call all of them and as a result I expect to get a St array or St tole doesn't really matter right what I get just some result with the calculations so that's what I want and the the way to it is actually not that it's quite bumpy so so let's go through it uh remember when I told you in the beginning that this talk is not really about uh meta programming right yeah don't worry don't worry that's unfortunate side effect of working with uh this kind of things so it's static polymorphism so there will be some parameter pcks showing up but uh we'll try to get through it slowly who remembers overloaded here yeah it's a favorite type who was shocked when he or she or they saw it the first time I was shocked I I didn't understand it so uh overloaded is a fancy type that's comes with st visit and with uh with the tupal right so we can have a visitor pattern and call us to visit only tup and pass the overloaded to it and it will visit your your Tuple or variant sorry variant uh how does it work well it works kind of easy uh there is an overloaded it's a class type and it inherits from multiple other types this is what the three dots do right so I inherit from some TS and since I am most likely inheriting from things that can be called I also expose their function call operators all of them those this parameter pack means that I am exposing all of them I'm using all of them uh there is also most likely like a deduction uh guide for it uh on the older versions of C++ needed that basically tells you that if I am creating an overloaded uh from those types please instantiate and overloaded of those types that's it otherwise the compiler couldn't figure it out before right and that's all it allows you to create all kind of code like for example this one uh an overloaded of two different lambdas with totally different function type signatures and confuse your younger colleagues with code like this right uh obviously it prints down answer is 42 uh because first we call the first Lambda then we call the second Lambda and that's what you get uh cool stuff to do uh cool stuff to to work with uh but we can put it or bring it uh to a higher level there will be types and PS a lot of them um for those of you I I think most of you are familiar with the pack right but this is a parameter pack it means that can be multiple lambdas and uh that's not the end of the story you're going to see a lot of it because I will be using multiple lambdas so I need parameter packs a lot uh the other one that you're are going to see a lot is something like our uh uh parenthesis Arc dot dot dot this is a way in C++ or communicating that I have a function type basically that returns R and takes arguments arcs and that can be many arguments uh you can also see a closure of it's a concept and that I use quite a lot uh to kind of constrain what's a load with my container so it's not a very complex concept it basically checks whether I'm really dealing with a class type that has a function call Operator that has this signature and nothing else so I have to make sure that it's there uh and with that being said uh we can move to the functors and to the implementation of the functors how would you do it and how it fares on the on the Seas of performance uh unfortunately we need a bit more than just overloaded so first of all we need a primary template you can see it up there right template uh type name do do not struct functors with no definition uh it's needed uh because later on uh we are dealing with multiple parameter packs in in one template and that's not that's only allowed for template specializ specializations so we need a primary template somewhere and then you need to specialize it a disclaimer it's also needed because your lum as can be mutable or not mutable right and a mutable Lambda means that it's a non-const member function that you get an unmut Lambda the default means your function call Operator in the Lambda is const you should be distinguishing between those two I'm not doing it because it's slideware and that would explode the number of slides so I only take the easy case or my lambdas are by default like mutable I basically kind of neglect the constants of lambdas exactly the same road that stood function to actually and that's why it's bad uh nevertheless you should do it and that's why you also should have template specializations uh the next step is obviously constructing right uh I'm using the concept here so I'm constraining the types that the Constructor can take to only the closure types that are acceptable for my R and arcs uh and then the body is pretty simple I mean this is this is kind of the whole Constructor I just need to initial I the base classes nothing else I am noticed that I am inheriting privately from lambdas you are allowed to inherit from closure types uh so the only thing you need to do is initialize your base classes and you do it like this you just forward the lambdas uh to the base class Constructors you're done and because we are building a container and every good container has a size we are going to put the size there uh by using the size of dot dot dot lambdas it returns basically the number of lambdas that we are kind of storing here right it's a storage it's a hidden storage um great um unfortunately uh because it's a we are dealing with multiple parameter PS uh arcs and lambdas we also need a deduction guide it's not going to work without it and specifically we have to tell the compiler that when we are calling the Constructor with some lambdas passed into it uh the type that it install iates has to be something like what you can see on the right hand side uh there are two uh meta functions used there a forbidden word I know I promise I wouldn't be using them but it's a meta function uh one that basically picks up the head of or the first element in the Lambda list because I need to pick it up and the other one that deduces the type of the functional operator from the Lambda expression so it picks the first Lambda in the Lambda list and and deduces the type I need it because that's how I instantiate my uh structure functors and then the lambdas with this beautiful piece of code we can already do a lot uh specifically we can do something like this uh I mean it's not really much because we could also do it with overloaded just with much less code uh but it's needed for the functionality that we're are going to implement later on and if you deal type it you are going to see that there is the functors of void string view so this is the argument type and the return type and then decal type to see out deal type to log okay the next step every single container should support adding elements to it right uh so we need a push back function uh because otherwise yeah what's the use of it if it's like fully static uh fair warning it's still partially static we are talking about static polymorphism so you cannot fully make make it fully Dynamic and you're going to see why or how in a moment push back takes more lambdas no surprise there uh because I can push back more than one Lambda at once obviously uh just for the fun of it uh so again it's a function template uh you cannot do it anywhere anyway else let's say so we protect ourself against uh let's say foreign lambdas that don't adhere to our interface and the return type of it will be obviously unfortunately a new type so we cannot just at lambdas we are going to create a new type that's that's that's the only solution to it because notice that we are inheriting from lambdas which means that our new closure has to inherit from old lambdas plus the new lambdas that we are putting to it so it's going to look something like this uh that's what we are returning um that's yeah static polymorphis unfortunately uh the once we know what we are returning and the only difference is that we are actually adding the more lambdas to the pack right nothing else uh in the functors uh the implementation is pretty trivial then uh first of all or second of all we have to forward the lambdas that we are pushing back uh to the Constructor of the functors and first of all we want to make a copy of the lambdas that we already own or that already are there and the copy is made by statically casting ourselves to all the lambdas that we have um and expanding it right so that looks pretty much like this more of this coming unfortunately uh notice this one uh who knows what this means like just rise your hands yeah it's not a very common feature like of C++ uh it basically uh means that this function will be called uh or this push back will be called only when my factors I am calling it on uh is an L value right so uh why is it needed well because sometimes I am transforming types I want to destroy the previous instance and I want to destroy the previous type or sometimes I also cannot just make a copy you know some lambdas are not copyable so you cannot make a copy of it that's why you overload something like this for the r references this push back will be called when the functors you call it on is an R value and the only difference or the substantial difference here is that now we are moving our current lambdas that we own into the new instance or into the new functors uh I'm only showing how it works when you move because that's the interesting part so imagine that we first construct these two funs with two lambdas into it uh and then this crucial part this is basically casting the existing two fun to an R value reference and we push back a new thing and we obtain a totally new type so you have to assign it to a new variable that's kind of a restricting Factor but hey that's the static polymorphis for you uh this will work now the important question is how do you call this thing right because you cannot just call it like with overloaded uh you you you cannot do this this is not going to work all the lambdas have the same function signatures uh this is an ambiguity if you try to call something like this so this is not going to cut it you have to bake your own version of calling and let's start with the simple example so calling all the lambdas because this is kind of something sometimes you want to do it like invoke everything that's in your container one by one that's easy and started with the very easy case so I I try to walk you through it through the steps of how it's been done I'm taking the string view not the arguments and I only inherit from L one Lambda so that's that's a bit easier that's the starting point first of all you have to tell the compiler that you want to use the Lambda and the Lambda function call Operator you inherit from so you have to cast yourself or your current instance to the Lambda that's easy and then you pass string to it and that's pretty much the whole implementation of it if you have a string View and inherit from one Lambda but this doesn't end here like first of all we have multiple lambdas not just one uh which means that we have to do something like this this is an expansion or a fault expression over comma basically what it will do it will call all the lambas one by one uh there is also this matter of having the string there string view instead of arguments so let's fix it uh more parameter packs and notice actually there is a design decision I made which might not be the good one and I going to keep it like this I'm always forwarding the arguments might be a bad thing depending on on your use case especially if you're moving from those argument in your first Lambda already so I'm doing it like this here because forwarding is not only used for for moving uh my I mean there are Escape roots from it you can have an argument proxy for example to solve the issue of of moving things out no problem anyways this this works like a charm uh especially if your return type is a void so you have to protect yourself because if your return type is not a void uh it's something else then you put another overload for the operator when R is different than void and then you just return an array and inside you call all the lambdas this is solved this works now and uh is it good we'll see in a moment you don't want only this one I guess you also want to be able to call lambdas like any way you want right so you might want want to add onto it with something like calling individual lambdas that's doable but we need an extra function that's I'm not going to go through this function it's a get function that basically returns you a reference to the I Lambda that you inherit from so you can directly call it it's a helpful little function right it uses the end type T which picks up the end type of lambdas so we can nicely cast to it and return the reference to it it's easier to call so I'm going to use get a lot because it simplifies code now important thing to remember it just returns you the it Lambda or actually the custard version of your current instance to the it Lambda reference uh with this one the rest is easy peasy uh I mean the calling of any lambdas notice it's again a function template we are still in the static or template territory there is no other I mean we are going to come to it later so what we do here um is something like first of all we can take either one I or multiple or I followed by is so multiple indices you might call one Lambda or you might call it multiple Lambda and you specify them by indices uh so you check it with if con exper if there is only I passed to this template then it's easy you just cast yourself to the it Lambda forward the argument and return it you're done and notice I am only doing it for the cases now where the return type is not void I'm not going to cover the other one anymore uh in the second case well there is not much difference besides lot of dots uh what you returning is an array first you cast to the I Lambda because this is the first I that you want to get and then you cast by expanding the PC again to the rest of the lambdas and it works like a charm like you can do something like this you want to just call zero and second you're done uh benchmarks because that's important right so how our newly baked uh call operators perform especially calling all the lambdas or calling some of the lambdas and by some of the lambdas I actually mean all of the lambdas but one by one right so uh because that I have to call all the lambdas anyway to compare uh great they actually do quite okay uh much much better than St function right uh you can see that there is like negligible increase in the per I mean decrease in the performers for Clank uh and actually for GC it's also not that bad assuming that it started much better than Clank so it's great and now I hope that you Cote me on on a lie because I promised you something different that I delivered uh I basically can do this right uh but that's not what you wanted really we started with something like this we wanted Dynamic fully Dynamic dispatch we wanted to dynamically tell which Lambda to call at the run time uh and what you are having here is not runtime this is compile time you have to at compile time decide which you're going to call and that's not always the scenario that's not always the use case right sometimes you just want to do something like this is it possible uh well there is there is some piece of bad news let's start with the bad news so imagine that you want to just have like f e something like your index access operator right and call the lambas the bad news is uh the signature or no this is the good news let's say the the first line of the function is pretty easy it's just a function call operator and that's the end of the good news uh so we are taking an index to the index operator uh the bad news is that this one actually it's still not the bad news it has to return a Lambda because it has to return a cable right we are calling what this one returns so let's use a Lambda for this that's going to that you can call on uh and now the bad news you cannot just do this uh you cannot just do this one you cannot use piggyback on the get function that we implemented before uh and the reason is well it's not usable in the as a constant or in a constant context right the I so you have to do something else luckily there is a solution you just use something like this and your problem is solved uh it works right and with this let's go to the bench no joke uh let's talk about the invoke map so uh because this is basically the magic right that happens under the hood you cannot directly call the lambdas but the best next thing you can do is is basically bake out your kind of on dispatch array or something like this at the compile time uh the whole idea is that this invoke map is an array of the size of your lambdas obviously that inside will have ways of calling your lambdas so it will have like for example 16 elements and each element will call the corresponding Lambda um notice that I have to pass the this parameter to it right that this as the first argument to it because otherwise it's not going to work uh the invoke map itself is quite easy it's an array of function pointers that take a reference to functors and the arguments and and that's all the implementation is horrific uh but I'm going to show it very quickly nevertheless uh and uh so let's do with the easy part uh let's start with the easy part somewhere in the middle uh because you want to construct a a map of invokers that will be like returning the static cast to the end type of I I mean is Lambda so there is some index happening inside I am casting the self which is the reference to the functors to the I Lambda and then calling the operator on it that's the easy part uh the rest is really horrific uh because this has to be red into a Lambda expression with a pack expansion because I am creating a lot of those lambdas inside uh and there is most likely another Lambda on top of it because I need an index SE sequence and as I said it's not a meta programming talk so I'm not going to explain the details of it uh take we can talk about it later on and finally we generate the index sequence uh the giz of it is it creates like a dispatch array right a static dispatch array for that that calls or your Lambda in any way you want and you can use it uh and it will work with this really it will work uh you can even extend it to something like this because nowadays we can pass more than one argument to the index access right so you can have something like this uh is implementation actually it's the same implementation that you've seen before for the static one variant of it uh a very similar one so you take an index and more indices if there are no more indices we just return what we returned previously you know a Lambda that under the hood calls the invoke map and otherwise if there are more indices well then we construct it like a big invoker uh that can call all the lambdas that you mentioned all of this works and and now the big question is how does it perform right uh because it's really important and again there is a good news and a bad news and you are going to get both news together together uh and this is the news right uh so Clank automatically is able to optimize everything away I don't know how it does it because there are multiple level of indirection I think it does it because it's all con exper basically St happens at compile time Clank is amazing at it GCC not so much on the other hand notice that actually you are winning a lot on the GCC in all the other cases only when you're really using this like Dynamic index dispatch then you're back to the performance of St function so it's not that bad right generally speaking you are winning in many scenarios can you win even more can you use something that will make it a bit faster the answer is yes you can uh I'm going to back move back to it notice that this is a costly operation like each time I using the index access some lambdas are created under the hood and returned to you so this at run time costs a lots of time you can cach it in a way you can cach it by creating before you go there some kind of invokers and you can do it statically which is not that interesting because the static is already fast so you get like an invokers to the zero and the second Lambda for example uh and you just call it uh and you can do it dynamically you can get invokers by passing Dynamic indices to it and it will return you an object that you can reuse multiple times but it already contains all the Lambda which are expensive to construct so let's do it uh the implementations are actually very easy this time because there is nothing there we are just basically forwarding our calls to either get is for the static case or to the invoke map so it's returning to the lambadas that can be called later on it's in a way the same as our index access Operator just named differently and this this will make it work and uh there is again U actually now it's only a good news when you use something like this either in the static variant static polymorphis or compile time variant or the dynamic variant you are going to see winds I don't know how but Clank is becoming faster than direct Lambda code don't ask me it's I repeatedly did it I think it's just doing more con exper calculations under the hood so because remember I was doing the long long so that's the reason uh but also on GCC we are winning a lot of time if you know or if you can cat somehow what you are going to be calling later on you have a win of at least three times as compared to the St function version which is a lot right right this is like a three times win uh still a bit slower than direct Lambda calls but we are now in the acceptable territory and of course for Clank it's it's like magic right uh all of the sudden it inlines everything and don't ask me uh I I looked at generated assembly and I gave up because it we I mean yeah we don't have that much time right so and uh so that's it that's the last Benchmark um you can see basically the takeaways you can program something like a Lambda container that will work with lambdas that will be faster than any solutions that you can directly use in the State Library uh thank you with this and that's the end of my talk so thank you for [Applause] visiting and there is time for questions yes so um I've done something similar uh really good talk by the way before I say anything else thank you so have you tried or have you thought of that you can convert a pointer to uh a member of a base class implicitly to appoint to a member of a derive class yeah so when you derive from a bunch of lambdas they all of those function call function call operators are implicitly convertible to a member of a derive class so you can just hold those in an array I haven't but thank you for the T so that will that will clear away all of that stuff you can just make an array of it I like this slide you can make I was proud of it so but but I I will try it thank you for the tip yeah like it it will all be Conex for if you do that okay yeah I will try it then and try how it works uh hey um really cool so the GCC problem let's call it um have you tried making the function that creates the array const eval instead of const exper uh it won't work well just the oh the one that creates the array no I haven't cuz it is possible GCC I have I have okay it didn't help didn't really help so unfortunately didn't hi hi hi thank you thank you for the talk very very interesting um so this container is still kind of static yeah uh if you want to have it also dynamically uh re um move things move lambdas into it dynamically or remove them are you back to function or is there maybe some trick maybe you can type erase the contain there are tricks to do it but they're very ugly you can hide the whole container be uh I think that I came to the conclusion that the only way to do it is hide the whole container behind a type erase type again okay okay and uh yeah exactly and then it's kind of doable and how it fares against the container a bit worse but then you're still a better off than because you only have one in direction for all your subsequent calls in a way so if you do it smartly but it's really ugly I I don't like it so okay okay thanks so we have one question from the internet have you any comparison Benchmark on compile times no uh it no but it compiles fast on my machine so no uh but that's a good one especially if you have lot of those right so uh it might be interesting uh one day I will try it for sure uh so thanks again uh and have a good lunch I would say