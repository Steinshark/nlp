so thank you very much so welcome everybody to the first session of today welcome to calling functions and you might imagine this is a pretty basic topic which however i feel is fitting for saturday morning so um grab a cup of coffee relax and join me for 60 minutes in calling uh functions allow me to start to introduce myself a little deeper so my name is klaus i indeed use your plus plus trainings um and do consulting in c plus and apparently this is not enough c plus plus for me i'm also writing c plus plus my free time for instance i'm the author of the play c plus math library and as you just mentioned i'm also the uh one of the four organizers of the municipal user group however let's um go into the topic today i really want to go through all the details in calling functions so we will go through entire sequence of steps that are done when you try to call a function now i set all the details of course i'm limited to 16 minutes this makes this particularly challenging um and so unfortunately i cannot really go into all the steps so i will talk about name lookup unfortunately will not talk about template argument deduction i will talk about overload resolution the excess labels function template specializations i'll unfortunately skip virtual dispatch and i'll call about deleting functions um we'll in this um in this course talk about the basic mechanics we'll also talk about all these keywords the the terms that we use when we um call functions all right this talk does a couple of things so it focuses on the basic mechanics of calling functions i also tried to point out the surprising details the things where i realized that people in my classes are usually very surprised and i'll also try to give you further references whenever necessary however it's just 60 minutes so this talk will not show all possible examples all possible cases it will also mention every single detail every possible combination of things and i do not try to be bleeding edge you will actually see the cc plus 20 syntax in i think a couple of places but it's not about the latest standard it's really about the basic mechanics um to have at least one talk out there that can be used as a comprehensive learning material so let's dive into what you what happens if you call a function the very first step that we do is called name lookup it's called name lookup so the compiler looks for names might find anything functions models variables types etc the compiler trust tries to find everything that is has a given name and build something that we call an overload set it might also find a couple of templates of course we cannot call templates directly we have to instantiate them and these instantiations might be used to extend the overlet set some templates however might not be directly callable or not might not work out the instantiation might fail still this might not necessarily be flagged as an era this is what we call sphinae just to mention it here i unfortunately cannot go into detail into this now when we have an overlap set including potentially template instantiations then of course at some point we have to decide which function is the one that we truly call this is the the task of overload resolution so the overload resolution um boils things down to viable candidates and finally to a best match once we found the best match then we should check the excess labels because it might be that from a certain call point the function is not accessible then also it could be that the selected function is a function resulting from a function template which might mean that we might have to look for function template specializations or it could be perhaps a virtual function in that case we should determine the real function to call of course this happens then at runtime and last but not least perhaps the function that we have selected is deleted explicitly meaning by means of equal delete this is also something we have to check so this is exactly the stack of individual steps that we now deal with before we get started one last very very important remark and i believe this is key to understanding a lot of the things that happen this call stack or this this this sequence of steps is a strict one-way straight once we have found a set of functions and then later find that none of them work will never go back to a previous step so if name lookup succeeds it is a step that is done and if you later detect any kind of error it is a hard compilation error no turning back uh to any previous step all right so let's dive into the individual steps and of course let's start with name lookup as the name suggests we are looking for anything with a given name so in this little example i start with first a function f that takes a double i call this function one and i have a namespace n one that contains a second function f that one takes it in and i call this function2 now in the main function i first of all call f with a 1.0 and surprisingly it will call function1 we call this unqualified lookup we just ask for calling the most reasonable function f which however means that if it would call f with a 42 prep surprisingly does not call function 2 but also calls function function1 unqualified lookup looks from the call site in the according surrounding namespaces which in this case is not namespace n1 but only the global namespace i cannot see the function in nssn1 so the function one is the only option that i have at this point so despite the fact that i have to convert the int to double function one is called it's the only function available if i really want to call a function in the namespace n1 i have to say so by means of qualified lookup so n1 conf triggers this qualified lookup i now find the function f in the namespace n1 this qualified lookup will find anything that is visible within name namespace n1 explicitly which means if i now imagine that there is no function f in the name source n1 then this third call would suddenly result in a compilation error there simply is no function f or anything called f in namespace n1 so this is now a hard compilation error which is quite reasonable we ask for n1 there is nothing let's assume that we get function f with an int back so function two is back but we also have a function g and h function g calls f with a 1.0 meaning a double value with qualified lookup res function h calls f with 1.0 with unqualified lookup if in the main function i call g do a qualified lookup then this call to f in g will result in calling function2 interestingly despite the fact that i have a double value it will convert the double into an int and call function 2. the reason is that officially function 2 is hiding function 1. and exactly the same thing is happening if i call h so whether i use qualified lookup or unqualified lookup both will result into calling function2 function2 is set to hide function one even though there is kind of two the compiler stops after having found the function f in names with n1 so this happens in the call to to h so the unqualified lookup it will find function f here it will not continue looking for any other function f because it's happy that it has found a function with the according name so this just is not visible anymore function two hides function one and this is even true if function f takes an argument that it's not really reasonable from the call side so we pass double values in both cases in the first case of course it's a completion error because i'm asking for this if this f doesn't apply however it's also a compilation error if i call if unqualified from the function h again the compiler only finds function two it does not see function one which now might be the one that i'm looking for it only finds this f and only later in the overlord resolution we actually detect that this is not a function that i could call with a double but as i said before this entire sequence of steps is a one-way street at this point we only find this f and if we later detect any kind of error it is a hard error we do not go back and try to look for any other function all right the same problem at least a similar problem appears if i have a a variable f in the names n1 then both of these calls again are ill-formed it's called name lookup i could look for anything that is called f that could be types they could be variables but of course they could also be functions but if anything else but function is called f this might result in some kind of name ambiguity and the call would be ill-formed so again the variable 2 now heights because it has the same name the function 1. let's assume that i call g this time there's only function 1. now of course for the sake of completeness this will result in a completion error there is no function f in namespace n1 and if i call h this now will call function1 unqualified there is no function f in the namespace n1 so if the compiler turns up empty in a certain scope it continues into the next scope and this is where it now finally finds function one function one is finally called not from this however qualified lookup is very specific unqualified lookup is the thing that works in this situation now let's assume that i get the function to back but this time i do not explicitly call n1f but colon callnf which is a shortcut for calling something in the global namespace in this case this function here will resolve to the global function so this will call function1 with qualified lookup the second call the call from h calls two that means a fun qualified lookup so hopefully these examples give you some idea um how function hiding works and the difference between qualified and unqualified lookup let's assume that we have a third function f a function f that takes a double in namespace n1 however it is defined after function g and h despite the fact that i now have a function f that takes a double still g resolves to function one and h will still resolve to function two function three is never considered this is because it is defined after you know even declared after the call site so function three is not involved in this particular um situation it cannot be called let's make this a little more interesting let's add a struct f s and this s comes with another function f that takes an end this is now my function 3. it also has a function g which calls f with a 1.0 this call to f assuming that i have an s and call g will primarily first of all resolve to the third function function three this is the first function that the compiler finds it finds something in the current scope the scope of the function call and this is the only function that makes sense at this point so again i convert the 1.0 to an int and function 3 is called now in this context function 3 hides functions 2 and 1. again function 4 does not play a role in this context if i get rid of function 3 then there is no f in s which means the compiler continues looking in the next scope which would be the names with n1 function2 is found and function 2 is ultimately called again by converting a double internet and again function 4 is not considered but function two again hides function one and if i get rid of function two then last but not least i would indeed call function one again by means of unqualified lookup and again function four is never considered this explains something that i realize is pretty surprising for a lot of people especially people that come from java and c-sharp let's assume that we have a base class with two virtual functions called f the first one takes it in the second one takes a double and the functions one and two now and this base class is derived from in this in this class so class derived is a base and introduces a third function f this one takes a double 2 and of course it overwrites function 2. so i'm function 3. i create a derived object and i call f with an integer and now surprisingly does not call function one this will resolve to function three exactly because of the reasons that i explained before in this case i know the static type due to the static type i know that this is the derived object so i start looking in this scope and a compiler does find a function f function three however it is satisfied at this point it does not continue looking into the next scope which would be the base class scope it only picks function three and so this is the only function that later is a viable candidate and so the function three is called function one is never visible function three hides function one and two and this indeed is very surprising to people from almost any other language but this is exactly how it works in c plus so do remember that we have this hiding effect and it is especially um let's say scary in the context of the ref classes now there is one other mechanism that we can use to call um functions so let's assume that i have a function f double in the global natures again my function one that i have a function f that takes an in namespace n one that again i have a struct s in the namespace n1 but also a function f that takes an s this is now my function three in the main function i create an n1s and call f from everything that i've said so far function 3 would never be considered because it is declared after um the struct s however still in this context function 3 is indeed called because it's the right function to be called and this mechanism is called argument dependent lookup my argument is an n1 column s this s is from the nasus n1 and in that case the entire namespace n1 is considered and i try to find a function that matches best for this s and so function 3 is indeed selected which is of course great because only after i know s i can define the function f that takes an s this mechanism also works in this context i now added a function template g that takes any kind of t and this t is put it's used to call a function f if in the main function i call g with s it's a little s here then i instantiate the function template with capital s and of course would call f with an s also in this case i would call function 3 based on argument dependent lookup and that also of course at the point where i implement or declare g i have not seen the the namespace n1 or the function that takes an s still it works thanks to argument dependent lookup if however i would introduce a fourth function a function f that takes an s in the global namespace then interestingly our disc is called here which result in an ambiguous function call argument dependent lookup also considers the home name space of the given argument hence the name argument dependent lookup but it also considers all the functions that are defined in the the namespace that i would usually find so the compiler sees function four but it also due to adl finds function 3 and both are equal well matched there's no better function here and so the compiler cannot decide which one is better you have to disambiguate somehow perhaps by means of qualified lookup so remember that adl only works for user defined types only when i introduced s my own type adl kicked in for built in types which means instable floats etc the regular rules apply no adl is used here now pretty important distinction only class types and user-defined type gets the benefit of adl this however also brings me to something that you should remember so let's say that again we have namespace n1 with an s this time i introduced a swap function that takes s not 2s let us swap of course in some function template g i get two values the same type and i call swap on them i call g with 2s of course i would like to call function1 but because i use qualified lookup at this point std swap stood swap would be called this is not exactly what i have in mind here though there is probably something special about swapping an s i would like that function one is called i should not um explicitly qualify this call with stdcon colon but instead i should say using stdswap and call swap unqualified this using enables the compiler to choose sdd swap but else the unqualified call is enabling me to use adl so argument dependent lookup only works in user types and only if you do not call a function qualified so prefer unqualified name lookup to qualified name lookup simply because um this enables adl and the core guideline c165 is using for customization points now swap is usually one of the functions that would like to call unqualified because it is one of these customization points all right then the last thing about name lookup that i would like to show you is something that we call two face lookup in a glow in a space i can half my function one my function f that takes a double i have the function g from before but i also now introduce function two that takes an end i have an s i have the fs again my function 3 which i first of all call indirectly by means of calling g so this is the adl lookup example i call function three by means of argument dependent lookup however if i now call this function template g with a 42 then this does not call function two as many people would expect this now calls function one 42 is an int basic type fundamental type and the fundamental type is basically uh the the basic rules the fundamental rules are applied to this kind of type this function is not seen has not been declared at the point where i call this function and despite the fact that this is of course instantiated only down here still the regular rules apply so only function one is an option at this point so only function one can be considered may be considered and the function one must be called so no adl but the regular roots all right there's no question so far so i simply continue with the next step which would be argument dependent uh template argument direction template argument deduction is a pretty interesting topic itself but seriously complex and unfortunately in the 60 minutes i don't have time to really go through all the possibilities in argument and argument and template argument deduction so i leave it to an expert i would recommend scott myers talk about this topic from cppcon 2014 c plus plus type deduction and why you care this is actually a pretty amazing talk despite the fact that it sounds like a very dry very um boring topic still he made this a pretty entertaining talk so really recommend it if you're interested in how this mechanism works i mentioned before that when we instantiate some function templates we might actually encounter compilation errors that still are not flagged as a completion error this mechanism is called sphine also part of the step and again i do not have a lot of time to do this myself but there is a one hour talk just on that topic given by arthur atwaya in uh at cppcon 2017 a soup saw of spinae cna is a pretty complex topic but still i think arthur managed to introduce this in a beginner-friendly way so a really in recommended talk so i now assume that we have instantiated function templates as needed we've extended our overload set and we've come we come to the next step overload resolution the task of the overload resolution is now to figure out which one function we truly call and this step is split into two other smaller steps first we compile a list of what we call viable candidates so we may have a lot of additional functions but not all of them are actually reasonable and so we strip down this overlord set to viable functions what is a viable function well for instance assuming that we have um this call to f with a 42 then a variable function is of course a function it takes an int this is what we call an exact or identity match this works also if we would take this by reference this also would work this is what we call a trivial conversion we add a const standard conversions the functions that would be callable by means of standard conversions also work and so with functions that would require me to do some user-defined conversions so a function that takes a widget but a widget that can be constructed by means of an integer also viable functions that take several arguments but have used default arguments viable candidates functions that are constrained by c bluster's 20 concepts but constrained such that the constrained matches are viable candidates and last but not least functions that virtually take anything take an ellipsis argument um this is also a viable candidate non-viable candidate would be a function that takes less parameters like this f that takes no parameter of course functions take more than one uh functions that take arguments that i cannot converge then into for instance a string and of course also functions that are constrained such that the constraint would be violated like this function that only takes flooding point values so i discard all the functions all the candidates that are non-viable and i'm left with a set of viable candidates and now i have to select the best match from this list of viable candidates so i have to determine which one is the best match that's the real task the complex part of overload resolution and this really is a very very complex matter in itself um so i can only be brief about this and to give you an idea how this works i will just use a single argument at the end i try to give you an idea how this works for us multiple arguments but let's stick to a single one first i have a lot of possibilities first indeed we could have something that is called an exacto identity match this would be perfect this would definitely work it would also work if i just have to add something like a const a trivial conversion the compiler considers these two db rank one functions possibly the best thing that could happen then of course the next best thing is something that is a conversion but a special one a promotion and a promotion can be mixed with a travel conversion also this is what the compiler considers to be rank two i'll explain in a second what a promotion truly is then the next level would be a standard conversion i can aim to double you've seen this before or perhaps the standard conversion followed by trivial conversion this is what the compiler considers rank three and then there is more possibilities perhaps there's user-defined conversions and of course user-defined conversions and trivial conversions or perhaps user-defined conversions and standard conversions officially this doesn't have rank but we might imagine that this is like a rank four and an ellipse's argument would be the final step like the rank five the worst thing that could possibly happen at least priority so let's take a look at a couple of examples let's say that inline function i have an integer and i call a function f with an int this is my two viable functions i have a function f that takes into f and i have a double function one is considered to be a rank one function at identity match i have an n it takes an end perfect in order to call function two i would have to convert from an into double this is deemed to be a standard conversion therefore in this particular case function one wins which is obvious hopefully but now i add a third function a function after takes a constant interef function one still is an identity match function two still is a standard conversion but function three now also is identified as a rank one function so at this point i would have a tie between function one and two function one and three luckily there is a tie breaker because intuitively we actually realize that function one is probably better suited i have a mutable int i should call function one the standard defines a couple of tiebreakers and since i believe cp reference to be a little easier to understand i now go to overload resolution in cpp reference and we scroll down quite a bit it's a pretty lengthy article to this particular point here so ranking of implicit uh conversion sequences and uh note 3. a standard conversion sequence s1 is better than the standard conversion sequence s2 if now we scroll down a little bit uh a little more if both s1 and s2 are binding to reference parameter only different in top level cv qualification and as one's type is less cv qualified than s2s interestingly gives exactly the same example as we've just seen so the example where i have a mutable int this function and that function and standard says explicitly in this particular case function one is preferred they're both rank one but due to this type breaker i have a preference so function function1 is called if however the compiler cannot really find the best match because two functions are basically equally well matched then the call is set to be ambiguous so i have an int again i call f but this time the two functions that i have take float and double both functions are rank three both are um considered standard conversions although of course different standard conversions but still rank three there is no tie breaker there is no special rule so this is an ambiguous function call the compiler will not prefer one of these two functions you have to be explicit you might have to convert the integer into float or double explicitly right in order to see which function you truly want to call there is a special and pretty interesting ambiguity because between a num template and a template so let's assume that i have a function f that takes an int and i have a function template which is constrained to integral values only if i pass an integer then in the second step that i mentioned before template argument deduction the second function is instantiated to take an int so essentially this function template results in this function now these two are very very very similar if not even equal and a compiler would consider both of them identity matches so both are rank one also in this situation we need a tiebreaker and also this is something we find if you scroll down to the best viable function section f1 is determined to be a better function than f2 if implicit conversions for all arguments of f1 are not worse than the implicit conversions for all arguments of f2 and f1 is a num template function while f2 is a template function a template specialization so the num template is indeed preferred in our example this uh the second function results from a function template the first one does not and so this calls function one which is something to keep in mind indeed this situation now only of course only applies to identity matches templates tend to be instantiated as identity matches and so as soon as this is not an identity match anymore the template would be preferred but in this situation it's the non-template so the second level the second rank is called promotions and there's only very very small set of conversions that a compiler considers to be special so for instance an unsigned short can be converted to an unsending or rent depending on the platform or sure it can be converted to lint a char can be converted to nint or unsent in depending on a platform and a bool can be converted to an int this is the so-called integral conversions and this is all of them there's nothing else that is considered special and there's only one floating point promotion float can be converted to double if i would convert a flow to long double for instance it would not be promotion yes sure the floater also is extended it gets bigger but still it is not considered to be promotion but a standard conversion so two examples here if i have two functions one takes an into one takes a double but i have a short that i pass to f then um of course this calls function one now function one is considered to be an integral promotion rank two function two is only a standard conversion so i call function one because of a lower rank it is a conversion but a special one if however i use a float down here so four point one four point two f i pass this to the function then suddenly the first function would be a standard conversion and the second one would be a promotion so the second one suddenly is better fit for the given argument function two is called if it is not a promotion and it is you know like uh float to long double or any any other kind of integral corrosion like in transcending it's just a standard conversion there's of course integral conversions floating point conversions then i can convert integral numbers to floating point numbers and floating point numbers to integral numbers the special kinds of pointer conversions of course derived base conversions and at any point it can be converted to void pointer and i can convert booleans um two boolean in many ways there's a lot of possibilities but it is only considered rank three so for instance i have an unsigned int i pass it to f and it is converted into a double so of course this calls function 1 by means of a standard conversion if i have a function f that takes an end it also is considered a standard conversion and a call function one is function one now if however i now have these two possibilities the function that takes a double and the function takes an int and i pass an unsigned int then maybe people tend to assume that this calls function two which doesn't this results in an ambiguous function call both functions the first and the second one are considered to be standard conversions both have rank three and there is no tiebreaker or special rule that would make function two a better candidate so indeed in this situation there is an ambiguous function call you have to be specific again which function you want to call now one example of about class hierarchies let's assume we have a class a struct a which is used um as a base class for b and b in turn is used as a base class for c i have two functions if one takes an a pointer one takes a b pointer but i pass a pointer to a c and in this case indeed function one would be pointer conversion rank three and function two would be a pointer conversion also rank three if there would be no tie breaker they would be equally well matched but of course function two is better and there is a special tie breaker this would call function two because we intuitively would also consider this as a better conversion it's the closest pointer um so more fitting to a for a c pointer if it's not a standard conversion either then it can only be a user-defined conversion and user-defined conversions are provided by means of constructors and conversion operators so if a class um struct of course also has constructors that take some arguments and that they're not explicit and if the or if the class would introduce conversion operators that are also not explicitly set to explicit then these operations can be used for conversions for instance in this call i now have a struct widget that allows me to create it by means of an int again f2f when a function takes along one function takes a widget i'm passing an int however both functions are viable the second one is viable because i could convert the int into widget by means of this constructor and so i could indeed call this the function but function 1 is considered to be a standard conversion and function 2 is only a user defined conversion so in this example function 1 wins but as soon of course as function 1 is not there anymore function 2 is called so this is something that we um also find in this subsection ranking of implicit conversion sequences a standard conversion sequence is always better than a user-defined conversion sequence or an ellipsis conversion sequence so user-defined is indeed only considered something like rank four it's not officially a rank four rank four doesn't exist but this is what you can consider to be so let's consider a couple of user-defined conversions i have a struct widget takes uh it has two constructors one takes an int one takes a double a constructor one and two i have a function after takes widget and i pass an integer to this function f then yes this function f is called by means of calling the first constructor the first constructor is considered to be a user-defined conversion just one user-defined conversion then i have a widget the second constructor is also viable but it requires me to do user-defined conversion from into widget and also the int has to be converted from inch to double which is an additional standard conversion this is more expensive it is considered less suited so function one is selected if i have a short and pass this to function f also function one is called this time because i have a user-defined conversion plus a promotion whereas the second function still is a user-defined conversion plus a standard conversion so function one again is a little better because the sequence of conversions is cheaper in the sense that it has a lower rank so again calls function one which is better matched so also this is described here you have to scroll down to node 4. a user-defined conversion sequence u1 is better than the user-defined conversion sequence u2 if they call the same constructor slash user-defined conversion function or initialize the same class with aggregate initialization and in either case the second standard conversion sequence in u1 is better than the second standard conversion sequence in u2 so user defined conversions have the same rank and then it is decided based on what else do i have to do so this is not all the details as i said before but it should give you a pretty good idea how it works with a single parameter now how does a compiler decide on a best match if you have multiple parameters well essentially it is just applying the same rules to every single argument if you have two functions to to choose from then only if one function is considered better for at least one argument and is equally good for all the other arguments then the function is the best match this function would be selected else the function would be ambiguous so allow me to give you an example again let's assume that i have two functions f the first takes three integers the second takes an end and two doubles and i totally agree this is a little contrived now but it should really give you an idea how this is evaluated so the first argument is nint in both cases this function takes an end so for both functions outbreak the first argument is a rank one the second argument is a short for the first function this would actually be a rank two meaning a promotion whereas it would only be a conversion standard conversion for the second function which is a rank 3. the third argument is an unsigned int which you said before would be a standard conversion for the first but also for the second function in total function one is a little better it is equal in the first and third argument but it is better in the second argument and so in this case function one is called it's considered to be the best match if i change the arguments a little bit if i pass the node as a third argument then again the first two would be considered rank one the second argument would be rank two and rank three uh respectively but now for the first function the third argument would be a conversion standard conversion whereas the sec for the second function would be promotion now there's no obvious winner anymore and it doesn't matter how many um things are validated is better as soon as there's one thing that contradicts one argument where a function of the first function and one argument with the other functions better it is already an ambiguous function call again you have to make explicit which of these two functions you would call but of course i would generally stay away from this kind of situation so prevent complex overloads to overloading situations that may result in surprises during overload resolution it's definitely best to implement things as obvious as possible and i would also forward you to um the core guideline c1363 overload only for operations that are roughly equivalent so if they're both called f they should basically do similar things um it should not be weird to decide which one is indeed better matched all right so i see a couple of questions um the first question actually applies to the the name lookup so will adl apply for typedefs any name any name that you define so a typedef or as a type alias would be a name would introduce a name um this name might be found might actually interfere with your um with your collar and the second question can you please repeat what makes the two-face lookup special example looked rather similar to the one that was shown before adl um allow me to go back to this special case which is [Music] this example no so i have to go back to exactly the right slide let me figure yeah so two-phase lookup the special thing about this uh scenario was that the function template is instantiated here inside main and at this point of course everything has been seen already function one and two still for fundamental types the regular rules apply which means function two is not selected i perhaps highlight it specifically because some compilers in the past actually did this wrong they would have called function 2 although strictly speaking it would have been forbidden with new compilers the modern versions or modern implementations you would have no problem at all so it will always work it will do the right thing but you should of course have an idea why it does the right thing okay so i hope this answers these two questions which means we can move on to the next step so we have dealt with overlap resolution which is one of the most complex steps indeed and we go now on to excess labels you might know yawn and say oh my this is a simple thing this is just something obvious perhaps not also here i find a lot of misconceptions with my students because it is perhaps not entirely intuitive so let's consider this example i have a class object with two functions f the first function f is defined in the public section of the class i call this function one it just takes an int and the function f that takes a double is defined in the private section function2 i now create an object somewhere some call site and i call obj dot f with a 1.0 at least 50 percent of people usually predict that this would call function one because it's public it's the only public function in the scenario it does not this results in a compilation error um function two is selected but then of course the compiler realizes that this function is declared private and cannot be called so this results in a so-called excess violation the reason is that the steps are really performed in the order i've explained before first i figure out if if there's any function called f and indeed the compiler in the name lookup step finds two functions called f then of course there's no templates involved so we go to overload resolution the compiler decides that function 2 is the best match in this scenario the argument is 1.0 function 2 expects a double this is an identity match rank 1 function 2 is selected only afterwards the compiler checks this access level and finds that this function is private so i just said what it really is and also the the headline shows it it's an excess label this is not a visibility label the private section of a class is not v is not invisible it's not like nobody can see it everything inside a class is visible i just cannot access it and so it doesn't matter what you do in the private section and also of course in the protected section of the class because it might interfere with your call resolution yeah any in other name and or any overload in the in the other section might uh interfere and so please do not consider a class or any object as something made of stone where there's only a couple of windows and doors where you can reach through now please consider this like a class object anything everything is made of class you can see through the entire thing you just cannot access things and this is one of the reasons why there will be a new keyword in c plus 20 which is class so you will be able to express very clearly what this truly is it's a class object and of course now don't take my word for it there is no keyword in in c plus 20 that is called class i just think this is a tremendous um um a very nice way to remember what it truly is yeah so no no keywords don't worry still nice way to remember it all right so remember that everything inside a class is visible public protect and private are merely excess labels and with this we go to the next step okay let me answer the question at the end since i have only 10 minutes left officially let me quickly go into function template specialization this is something that also is pretty complex in itself but let me make the point of why function template specializations might not be the thing that you're looking for i have three functions now first first of all i have a function template function template one that takes a t then i specialize this function template for char pointers [Music] and then i introduce a third function again a function template that takes a t pointer in the main function i actually um initialize the char pointer something and i call f no this will not call the second function the specialization this will resolve to function three function template specializations are only considered after some base template function based template has already been considered so initially the compiler only chooses between one and three and of course in this context function 3 is better matched since function 2 the specialization belongs to the function template 1 it is not considered afterwards so function template 3 is called it's not function 2. however this changes if i reverse the order if suddenly this function template specialization is defined last it is actually a specialization of the second function template so function two now suddenly belongs to function three and now with the same call suddenly i call function function2 function template 3 is selected first then i actually try to find any kind of specialization the compiler now considers the specialization too and indeed it's a better match it is called so function template specialization is different from overloading an overlap set is considered in the in the overlay resolution phase but function template specialization happens later now this resolution is delayed and so perhaps this is indeed a little special and it probably is also special because it is pretty tricky if i for instance would just define this differently if i would for instance make this a function um template specialization that explicitly mentions char pointer then because of that certainly it is especially safe in a function function template one again and again function three would be called so here that one in the middle so function template specialization is indeed tricky um prefer function overloading to function template specialization and if you do it um you really should know what you're doing this is a very very short intro to that there is a brilliant talk about function c plus function templates by uh walter brown i recommend the c plus person c version it's close to one and a half hours so 120 approximately um it explains a lot of details very technical but a very very nice coverage of all these details which leaves us with two um points only original dispatch which however i'm gonna skip simply because um this might be the one that is obvious how it works and also stefan has already covered this topic pretty well so i referred to you refer you to core c plus plus 4 of n something that you find at youtube this is where stefan explains in detail how virtual functions work the virtual dispatch in general what changes you have to experience in classes so you will experience in classes when you introduce virtual functions cetera really well documented which only leaves us with the last step deleting functions which interestingly is not what many people consider to be so i have two functions two functions f again the first one takes an integer the second one takes a double and the second one is deleted explicitly in the main function i call function f with a 42 and it's called function 1 of course if i however call function f with a 1.0 this will not call function 1 but it will result in a compilation error that tells you that function 2 has been explicitly deleted equal delete does not mean that the function is gone equal delete is basically similar to defining a function without giving it a function body so you basically say here is function um two but actually you cannot call it i explicitly prohibit you to call it and so if you try to call it this will result in a compilation error so it reads like it's gone it's deleted but considered more like an equal disable you explicitly disable this function and this may be pretty interesting okay cutlet first equal delete doesn't delete the function but declares it as a call any attempt to call a function will result in a compilation error this is pretty interesting consequences in classes because for instance we could delete our move constructor so right in the main function i first of all create a default widget w1 and then i try to move w1 into w2 this will not call the copy construct instead but this will result in a compilation error that tells you that move has been prohibited has been explicitly deleted if you really want to get rid of move you should not declare it at all then and only then the copy constructor can be used as a fallback which is indeed a very interesting twist in the rule of five that also nicolaesitis on day one has already mentioned the rule 5 tells us that we should either define all of the functions or actually this is a different guidelines to 20. we should not define any of them but if you really want to delete get rid of the move operations then you should not declare them you should probably fall back to the rule of three now they should not appear in your class at all which is just something again to to remember one of the twists that equal delete um brings you all right and with it i have covered the entire call stack or the entire step sequence of steps when calling function so we have covered name lookup overload resolution unfortunately skip template argument deduction we've talked about access labels function template specialization and deleting functions and of course this was only a 60-minute kind of superficial walkthrough but still i hope that this helps to better understand how compilers actually resolve function calls with this thank you very much for um getting up early on saturday and i will try to um answer a couple of more questions so dennis asks can see blossom's 20 modules change the explained rules for access levels if only the public function f is exported if you indeed call a function from a point where you cannot see the rest this may make a difference if you only export a specific function then yes inside the class however of of course it is different inside the class um you will always have the behavior that i explained before so explicitly exporting yes um but in as soon as it's visible you will fall back to the the thing that you've seen the things that i explained before okay what's the reason that access levels are checked after ovulation not before it so it is indeed checked after the overdose resolution because bjornik's tristrip in the very beginning was um actually very very concerned that um else it might be confusing and i know this is perhaps now um surprising that every guess it might not be confusing but what he wanted to prevent is that calls to the same function certainly have different meaning so if i call a function from within the class it should result in the same effect as is a call it from outside the class so the private keywords or the protected keywords should not change the way um function resolution works and this is why it is called after now else i would call one the public function in one case and a private function in the other case this might be surprising also in a different way all right and last question do the same rules apply for function pointers either resolution of word so some example follows the same steps as we're calling for with an int directly absolutely however it does not probably follow the same rules as you might now consider it assigning to the function pointer follows the same rules so if you select a function somehow and assign this to the function pointer it compiles to figure out which function you assigned at this function pointer but as soon as you have assigned to the function pointer the decision which function you're pointing to has already been made so if you now pass the int um it will always call a function that has been bound to this pointer so um yes initially with the assignment it definitely follows the rules whatever is visible right now etc etc um but calling the function is a straightforward process of just calling the thing that you've already selected okay one more question if i may um isn't leaving such fallback to copy construct available going to make the code less expressive we expect that using stood move should not make a copy well um that is of course now starting to be philosophical this is the rules that we have today of course we could argue that it would be much nicer if the rules would be different but this is just what we have to deal with today so um perhaps you're right perhaps it's better it would be better but just this is just the way it is so unfortunately you cannot um really tell you different things here all right indeed i hope this was helpful to perhaps clarify a couple of points where we never were quite sure thank you very much again for getting up on sunday um morning a saturday morning of course and um enjoy the rest of the conference thank you