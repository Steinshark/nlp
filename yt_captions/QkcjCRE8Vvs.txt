I do not use a debugger I don't use the debugger either okay so I'm kind of excited about this article I learned a program with basic I learned with Q basic back when I was 12. I would write elaborate programs and run them invariably invariably they would surprise me by invariable is that the right word at this point invariably isn't it inevitably uh they would surprise me by failing to do what I expect I would struggle for a time but I had eventually give up and just accept that whatever bugs I had created were there to stay it would take me a decade to learn how to produce reliable and useful software to this day I still get angry with people who take it for granted that software should do what they expect without fail I can be on this team I can definitely be on that team because you know what it is kind of like software is really hard and to just assume that it's always going to be fantastic yeah come on it's very hard to get right uh in any case I eventually graduated to something better turbo Pascal turbo Pascal was a great programming language coupled with fantastic programming environment that is comparable in many ways to Modern integrated development environments Ides yet it is three decades old it had something impressive you could use a debugger what this means is that you could run through a program line by line watching what happened to variables you could set break points where the program would Halt and give you control recently Chris wellin wrote about Borland C plus plus an environment from the 90s I made a couple of test projects built in random with different options and poked around with the debugger the debugger is actually pretty decent especially for the 1990s okay okay at this time I thought that programming with a debugger was the future all right all right decades later I program in various languages C JavaScript go Java C plus plus Python and I almost never use a debugger I use fancy tools sanitizer static anal analyzers continuous integration git flow Synergy teamwork uh and I certainly do use tools that are called debuggers like GDB but I almost never step through my programs line by line watching variable value values I almost never set breakpoints I know I say almost because there are cases where a debugger is the right tool mostly on simple or quick and dirty projects in the context where my brain is overwhelmed because I do not fully Master the language or the code this being said I do not recall the last time I used a debugger as a debugger to step through code I have a vague recollection of doing so to debug a dirty piece of JavaScript yeah I can say I don't remember the last time I debugged I probably debug I probably debug about once a month I'm probably a once a month debugger user I'd say that that is pretty fair I'm not alone in five minutes I was able to find several famous programmers who took positions against debuggers or reported barely using them Linus Robert Uncle Bob John Graham Cunningham or cunning hates the buggers Brian Carrigan and Rob Pike let's go the auth the author of python Guido van brosive uh has been quoting saying that he uses print statements for 90 of his debugging love it all look at that this is good I should make it clear that I do not think that there is one objective truth regarding tools it is true that our tools shape us but there is a complex set of interactions between how you work what you do who you work with what other tools you are using and so forth whatever works for you might be best I you know I'm always I always have this huge hesitation right here whenever I hear this phrase whatever works for you might be best if that was the case I'm gonna be real here I would still be on netbeans and I would not have learned Vim because you know what changing Ides was a huge Slowdown changing from what I was used to text editing into using Vim was a huge slowdown right there was plenty of things that did not work best for me but I've heard that it could become better to use if I give it time and so there are you know I I don't want you to get stuck on this line always explore to make sure you're doing things the best and once you have comprehensive knowledge on the thing then pick the thing that works best for you okay just want to be clear about that however the fact that Linus who is in charge of a critical piece of our infrastructure made a 15 million lines of code the Linux kernel does not use a debugger tells us something about debuggers anyhow so why did I stop using debuggers debuggers were conceived in an era where we worked on moderately small projects with simple processors and no threads no out of order execution simple compilers relatively small problems and no formal testing I feel like John Carmack has like the exact opposite to say about debuggers I I think with game programming and really good debuggers there's probably things here that are completely missing in this in this statement but I think this is probably also the environment that you work in I think web is much less useful with debuggers than say something like that so I could be on I could be on both teams here for what I do I feel that debuggers do not scale okay okay uh there is only so much time in life you either write code or you do something else like running line by line through the code doing something else means one rethinking your code so that it is easier to maintain or less buggy too adding smarter tests so that in the future bugs are readily identified effortlessly investing your time in this manner makes your code better in a lasting manner whereas debugging your code line by line fixes one tiny problem without improving your process or your future Diagnostics the larger and more complex the project gets the less useful the debugger gets okay okay interesting hypothesis interesting hypothesis I don't necessarily agree with this hypothesis but it's still interesting I like anyone that comes up with like a rule right I love the idea of trying to apply rules to life right and so what he's trying to say is that you know there's a scaling Factor uh I disagree with the statement but interesting will your debugger scale to hundreds of processes and uh terabytes of data with trillions of closely related instructions okay that I mean that none of this is real I work on probably one of the larger projects that anybody probably works with in general which I have millions of Records no one gets into the trillions okay no no one's in the trillions here my ultimate goal when I worked on a difficult project is that when problems arise there as they always do it should require almost no effort to pinpoint and fix the problem relying on a debugger as your first line of defense can be a bad investment you should always try to improve your let's say always improve your code first okay I like what he's saying so one of the big things I've been kind of really trying to put into practice is preemptive debugging logging that I turn on when there's a problem and what I mean by that is that there's a lot of things you can debug but there's only so many useful things you should debug you know what I mean and so when a problem happens I can run it once with debugging guess where the guests were effectively the problem is and go okay this is the problem I can fix this right away the problem with this statement is that how do you fix all the bugs that show up some people don't know how to fix problems without debugging I've always been kind of a a logger kind of person you know what I mean you can't uh log every variable every uh call stack every frame exactly you can't do that every time there's times where it's like conditionally it's like a it only happens under certain conditions and so you should know these things you know what I mean Rob Pike one of the authors of the go language once came to a similar conclusion if you dive into the bug you tend to fix the local issue in the code but if you really think about the bug first how the bug came to be you often find and correct a higher level problem in the code that will improve the design and prevent further bugs again I wonder if this is all I mean sometimes I have a hard time believing this because sometimes my bugs are just because I'm like I you know I'm just I'm a grunt brain right I'm just like me thought cases three turns out case is four foreign I'm just stupid right like I I just did I just didn't get it correct at all um I don't want to be misunderstood however we need to use tools better better tools so that we can program ever uh more sophisticated software ever running through the code line by line checking the values of your variables is no way to scale up in complexity and it encounters the wrong kind of designs this is I mean it's a really it's a it feels like a hot take do you guys feel like this is a pretty hot day because I like I'm in total agreeance that I don't think debuggers are a great first line of defense but I I don't feel like he's making a great argument for this you should get Casey to talk about this I I love Casey I would get Casey to talk about this we'll get Casey to talk about that how does that sound here we're gonna go like this Twitter because Casey's been whispering me okay Casey and we've been trying to find a co-react I got something for us to react to want to join question mark we'll post this on Twitter we'll send it now I like Casey a whole bunch everybody you know what to do you know what to do okay do the things you got to do okay um but yeah he wants to come on and talk about uh stuff I want him to come on and talk about stuff I feel like this could be a really fun experience um let me end with this quote that sums up my uh sentiment debuggers don't remove bugs they only show them in slow motion correct further reading bending on an experienced game developer who worked on Goldeneye let's go favorite game come on tell me GoldenEye has not done so much for you GoldenEye greatest game potentially Medal of Honor Starcraft let's go Diablo what World of Warcraft wow he's played he's did these are a lot of games that I loved wrote in 2018 the principal problem with debugging is that it doesn't scale in order to catch bugs we often need a uh to be able to run with sufficiently large and representative data sets when we're at this point the debugger is usually a crude tool to use using a debugger doesn't scale types and tools and tests do okay so this actually is a good okay so I think I understand more what he's trying to say here this makes a lot more sense and what I mean by this is that I had this problem where I was having a bit of a memory issue because I was categorizing every single piece of memory created in in a JavaScript engine into what source file was creating them where so that way we could actually say whose functions were the worst offenders versus the you know not the worst offenders for identifying memory problems or memory gross it was ultimately a failed tool but nonetheless I had a problem the problem here is that when you run any JavaScript program that's especially using react you're creating a million pieces of memory like every five seconds so to be able to go through that and really find a set of problems with a debugger turned out to be super super hard whereas really good logging followed just by awking and setting was actually a way way easier way to do to find the problems than anything else I don't know personal opinion once it reaches a certain scale I find it hard to use tools sometimes sometimes not always sometimes because I didn't know the conditions in which the thing was going to break so that's part of the problem which is like when you don't know the conditions in which a program is going to break you can't set a conditional breakpoint and this function is going to be called 900 times zizo hey bro I just want to hear my name on a video hey hey bro come on get my name out okay see so now shut up and give me a sub for that anyways uh you're now immortalize these though I hope you like that okay you're gonna be in a video I hope you enjoyed appearing in a video that way hey Mastermind how you doing remember when I used to call you master mindio hope you're doing well how's the kiddos uh but real talk um this profiling count as a debugger no because profiling is inherently not a debugger action right you do a bunch of stuff and then you look at the output uh it's different anyways um he could be in a short marker uh say my name as a short go back about 30 seconds we'll try we'll try it out all right well that's all I really have to say about this is that I do think that there are better ways to debug certain sets of problems that don't involve debugging or at least not right away now when I found the memory issue in which there was a point in which I could see the bad thing happening then I put a debugger in a a uh what's it called a conditional break point that made sense and then at that point I already narrowed down the problem and I was able to see the problem and then I could see how I could fix it because I could investigate in the whole stack so was there a good reason to to use the debugger for me there was a good reason but I couldn't even find the bug with a debugger until I got to the problem you know what I mean it was like it took a while right because the problem and the bug were in two different places you know what I mean uh it was tricky this is also pre-recorded if you're wondering this is obviously a pre-recording right here AI generated pre-recording live action the name is I also don't use debuggers but I don't necessarily agree with this article okay uh Daniel I I don't but I appreciate the article agenda