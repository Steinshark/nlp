so we're going to talk mostly about the classes we write uh and uh you're probably familiar with the uh pitch giant peit metaphor from from uh one of the herb stocks um there there's all sorts of classes we usually write um either utility wrappers function objects uh all sorts of typ characteres and polymorphic behaving types containers and of course value classes your plain old structs without any funny pointers inside but some are more special than others uh and what I'm going to try to um explain is some of the characteristics of these uh types of classes and some of the unexpected behaviors that can arise from from using them in in weird ways so uh I did talk about this topic a while back uh five years ago actually uh and um start some real good conversation back then and uh this year I've been asked to revisit thep the topic uh and that's that's why I'm doing this so I'm going to start with this uh funny quote uh from Titus good types are all alike every poorly designed type is poorly U defined in its own way um and it of course it it alludes to the famous quote from to stream so why regular types why are we talking about this um so we shall see that uh regular types naturally appear as necessary foundational blocks in in programming uh and I'm going to try to uh take you with me on an investigation to see how they appear in in the standard library in specification in requirements uh and even in uh modern C++ in in Concepts and and and similar ideas but even before C++ 20 Concepts uh we've seen these things in in in in all sorts of guidelines including the core CPP guidelines uh we have C11 make concrete types regular um Regular types uh this is quoting from from the guideline regular types are easier to understand and reason about than types that are not regular um the C++ built-in types are regular so are the standard Library classes such as string Vector map and so on uh and concrete classes without assignment inequality can be defined but they should be rare and we have required template arguments to be at least semi-regular um for uh similar reasons including uh comprehension so we have guidelines we have conference talks we have books I'm going to mention uh one or two and they talk about these Concepts and uh I it all goes back to an fairly old paper by now it's 25 years old uh and it's the Alexander stepanov paper from 98 um fundamentals of generic programming where it talks about uh STL and it designs uh its design principles and so my talk is not just about regular types um it it goes um and investigates values primarily objects Concepts um we're going to focus on ordering relations requirements equality equality is going to be a big part of this discour whole part semantics for objects uh of course object lifetimes uh and I already mentioned some uh some of the guidelines and spans multiple um C++ um versions because we have things coming in in the library uh that make use of these Concepts so uh I do recommend um by the way uh the slides are going to be uh peppered throughout with links and references to uh videos and articles uh so when you get the slides after this if you're inclined to investigate some of these things further uh just follow the links uh I do recommend that you watch this uh two parts series of talks uh by Titus Winters on Modern C++ API design uh specific uh especially uh part two um and uh where discussed um type families and um combination of type properties in good type designs and of course designing overload sets and other things so good all around but let's start with the beginning um anyone seen this series of lectures by Alexander stepanov I see just two hands okay uh so four algorithmic Journeys if you uh Google for it it's actually three they cut it short so these are the the three tracks um it's fairly long so I do warn you if you're not really into this thing it's it's very long um there is a a sort of condensed uh Readers Digest version um on the internet in written form um if you want something like that so if you don't have the patience to follow uh 32 hours of video content and trust me you cannot watch it on 1.5x on YouTube uh I do recommend uh the book format so the book format for the lecture series uh is this one from mathematics to generic programming and it sort of goes through uh 4,000 years of mathematic more or less uh following um from Egyptian multiplication and following basically a core algorithm like gcd in multiple incarnations uh and how uh investigations in its nature and structure um gave yeld to new new fields in mathematics and new ways of reasoning and structuring mathematical Concepts and uh up to sort of modern times uh where we have incarnations of this kind of work in modern um cryptology uh before we get started uh let's just uh we have to nail down some common vocabulary because some of these terms are sort of overloaded and can be confusing so I'm going to use terminology from um elements of programming so um a datum is a finite sequence of zeros and ones and can represent anything a value type is a correspondence between a species and a set of datums a value is a datm together with its interpretation function so an integer as 32bit to complement big endan let's say that's a value and mind you a value cannot change we're talking here about the abstract concept of the value let's say five five is a value it cannot change um some laws and correspondence uh to equality if a value is uniquely represented equality implies representational equality sort of makes sense and if a value type is not ambiguous representation equality implies equality so the other way around uh but this ambiguous thing needs to be settled a bit more and an object and I don't mean here like o object uh object is a representation of a concrete entity as a value in computer memory so it's address and and length so where it leaves in memory uh and an object has a state that is the value of that of the domain of those value types so an object has a state which is a value and of course the state of the object can change so what we store in memory at a particular location if we store a five or if we later update it to 10 that is something that can change so the object the location in memory uh and the type is a set of values with the same interpretation function and operations on those values we're sort of familiar with this concept ccept and the concept is a collection of similar types um and we're going to see what we mean by similar what we expect from them um so all these come all these terminologies and and definitions come from uh elements of programming um it's a I would say one of the foundational books uh of our field um I know not everyone is uh familiar with it uh even fewer people have read it uh from the people who read it I always hear that um it's impenetrable or that uh they couldn't understand anything or that um it's it's too difficult or too abstract or to mathematical um and I get it I get it uh you sort of it's good that if you try to read it in progression and you sort of have to do multiple passes and uh your understanding of the concepts within will be gradual when you come back to it and reread some some of the things there if you want to like a Gateway version to that um maybe you can start with this shock uh which definitely very few people know about so uh mathematics does matter um so it's greatest common measure the last uh 2,000 uh years um very very good um Gateway into um into EOP so you can start that way at least it worked for me but you might say Okay um all this intro all this mathematical uh uh why should I care about that i' I've been working for n years programming uh and I didn't do didn't need any EOP or math uh stuff to uh to help me and uh the reason why things just work for you is because other people have thought about these uh hard Concepts uh and encoded them either in the type system or in the libraries that you're using uh so that it feels naturally intuitive to you so it's not for free it's not like I don't care uh it's somebody else's problem uh sure it was somebody else's problem and you're using the fruits of those um struggles and and and and rigorous design sometimes rigorous um but I would argue that uh you should care and I'm going to show why um so it's basically 4,000 years of mathematics mathematics leading to this paper which I mentioned already uh and the reason why you should care even if you're using components that have been designed uh to make it easier for you is that some sometimes those components May Fail you uh and you may uh Miss why uh you might have surprising results uh you might have weird Behavior Uh and this is where your understanding of the world or that system or that design uh will will start to fall apart and you'll you'll get lost on why that happened we already got a hint of that uh in this morning's keynote by Cavin I'm going to mention it concretely later on so generic programming depends on the composition of programs into components which may be developed separately combined arbitrarily subject to well defined interfaces okay all nice and good sounds like uh the good uh the good stuff that all trainers preach uh and among the interfaces of Interest the most pervasively and unconsciously used are the fun Al operations common to all C++ built-in types as extended to user defined types for example copy Constructors assignment and equality why am I quoting these parts of that paper uh and it goes on we must investigate the relations which must hold among these operations to preserve consistency with their uh semantics for building types and with the expectations of programmers and this is why I'm quoting these parts because they what the types that we design and the the the types that we're consuming the the the functions that we're using the algorithms from the standard library that we're consuming make some assumptions uh and if we're using them fulfilling those assumptions or if we're using them sort of in contract on on how they're supposed to use and uh if if the types we're designing or the types that we're extending or the types that we're using with let's say STL algorithms satisfy those assumptions those requirements then things will just work uh and also it's about uniformity and meeting the expectations like even if we design something that works but if it works very differently than other things that people are used to then it breaks expectations and might be surprising even if it does the right thing if it even does the the thing that you document uh so we we strive for uh consistency with built-in types or the STL vocabulary types uh intuition and expectation of programmers and of course mathematical Concepts that are established we cannot um reuse a concept like I don't know less than or plus to mean something radically different than what people expect from years of logic or mathematics so we want a foundation powerful enough to support any sophisticated programming test but simple and intuitive to reason about okay um we might see okay Simplicity that's overrated our problems are complex we're building complicated things um we deal with C++ we're used to things being difficult um I sort of disagree with this yes we're building very complex things but they're all built out of very simple things and or at least they should be so uh things that we can reason about because it's very hard for us to to reason about complex things and especially um relationships between uh many moving parts and complex systems are very very difficult to reason about so Simplicity is a good goal uh and the way to achieve that is build smaller things that we can understand and relations between those things that are unsurprising and this is where regular types come in at least one side of the the story and I would say I would argue an important part of the design um by the way uh if you want uh a more modern take on uh fundamentals of generic programming by stepanov the 98 paper if you want a newer let's say uh version of it uh mentioning modern C++ and sort of a modern interpretation of that paper I do recommend this one by Titus Winters so um it's a it's a good synthesis and it makes a case for regular types as well of course and was one of The Inspirations for for my talk um okay it mentions some of the new additions like stream View and span I'm going to mention those as well so let's go back to the roots STL and its design principles uh again who has seen this presentation by Alexander stepanov this one is fairly well known aside um as opposed to the other one from Smart friends no nobody okay then should really really watch this one okay uh so um I would say this is the as best as I could describe it is the manifesto of STL uh so if you're a big fan of STL if you're using it if if you want to understand uh how we got to this design and and why why some of these parts are designed in certain way maybe it feels weird to you um then this is the Tok that you should watch okay I'm going to try to extract uh the the highlights from from that almost to our presentation so fundamental principles of STL systematically identifying and organizing useful algorithms or data structures finding the most General representation of algorithms using whole part value semantics for data structures and I'm going to revisit this item because it's very important using uh abstraction of addresses like iterators as interface between algorithms and data structures this by by now these are not no longer surprising things but back in in 9394 these were like groundbreaking things uh and usually algorithms are associated with a set of common properties of operations for example uh plus uh multiplication mean Max these are all associative operations um so that means you can reorder operands and that means you can easily uh paralyze um the operations built out of these operation these kinds of operation chains uh and we have concrete examples of these things like accumulate or transform reduce so STL data structures again I'm taking you back to that uh stepanov Manifesto video that I I recommended uh STL data structures extend the the semantics of C structures no no surprise there this is the part that sort of trips people two objects should never intersect uh and what I mean by that they should model separate entity is and separate lifetimes and this is where we sometimes fail in our designs and this is tied to uh the whole part semantics that I mentioned earlier uh and when we copy a hole we we copy all its parts uh when the hole is destroyed all the parts are destroyed uh two things are equal when they're have the same number number of parts and their respective parts are recursively equal and so on uh these all sound noncontroversial things I would believe uh I don't think anyone would want to argue these points but we sometimes fail miserably at modeling these things uh when we're designing stuff because of of shortcuts of or convenience uh we might just add something in in in our type or we might feel the need for some sort of connection that we need to to establish between our types in in in the systems we design so we although we strive maybe for these things we we sometimes fail uh I I do recommend how how many of you are familiar with uh Hilo programming language or formerly known as Val well just one hand okay uh I I'm not advocating that that you go learn it or use it but I I would say that it's very instructive to to uh read about its principles and and again um there's it has a nice website there's there have been very nice articles about it um and some presentations I highly recommend this one uh by Dave Abrahams I I hope people are familiar with Dave Abrahams by now um so this talk covers at length uh some some of the ideas of whole part semantics and how they relate to uh the design of of Hyo um and formerly known as Val so you can figure it out that if it has or at least had Val in its name the language is very much about value semantics uh so the talk um will um present some of the um ideas of using pure uh value systems uh some of the things some of the learnings from Swift uh what worked what could have been done better some of the limitations of uh producing an industrial designing an industrial programming language that needs to um integrate into existing ecosystem and some of the the limitations um they had with Swift and the path the the at least Fresh Start uh that Hilo can can get anyway a a very good uh my opinion very good uh exposition of building value systems and and and and working with a value oriented uh programming language uh so again that um Manifesto presentation by stepanov mentions uh introduces mainly programmers to generic programming principles because back then it wasn't as popular as it is now and it talks about um abstraction penalty which uh in early 90s was a really big thing so um some of the abstractions that STL introduced came with the runtime cast um so many of these went away of course uh as um STL implementations got better and compilers got better at figuring things out um of course we have to deal with so the the stepanov talks about some of these drawbacks uh including implementation in the interface early binding uh horrible error messages up to this date I would say um duck typing uh some some Sur surprises when when using these algorithms for example it might they might work with existing type that you're using in a system and fail to work when when you change some of the behavior of that type or if you're introducing a new type in the system might surprise that it stops working so and the reason why these surprises U appear is that we need to fully specify the requirements uh on on algorithm types uh and up until recently the have been formulated in documentation form um but very few people actually bother to to look up these things and they're all documented in uh in in the language specification and you can browse them on CPP reference of course uh and these named requirements were sort of the informal expectation of the STL so that what they offer the tools they offer you actually work uh and if you satisfy the expectation of each of those um uh algorithms or data structures because some of these apply to data structures as well then it will they will just work but if we fail to meet one of these requirements surprises uh do appear uh so named requirements are used in the normative text of the standard to Define these expectations uh and some of these most of these have been formalized using C++ 20 Concepts uh and they sort of look this way uh now um so um just a few examples these are not all of them we can see them a bunch of them that we're going to analyze uh today uh like uh equality comparable um totally ordered St quick ordering we see regular and semi-regular as well so now they're fully formalized and they appear in the actual implementations of STL and they're actually checked by the compiler uh so it's sort of more difficult to to stray from the right path I would say but um it's it still might be surprising when you get uh sure the the the the diagnostic message would be far better now um but you still need to understand the concepts and why you broke that requirement because it will tell you that you don't satisfy that requirement but you still have to figure out how does how does that relate to the thing to whatever my vocabulary type my my my thing that I'm using with that algorithm uh so for more specification of Concepts makes possible to verify that template argument satisfy expectations of the template during overload resolution and template specialization blah blah blah sounds very technical uh what is important is that each concept is a predicate that is evaluated at compile time and BEC becomes part of the interface uh of the template where it's used as a constraint so you might say I usually don't design these things I'm consuming them uh and if I'm using it wrong I'll get the diagnostic message and I'll I'll deal with it uh so sure you can you can get by um but at at some point when you'll expose uh either similar functionality yourself uh and you might not be a library developer necessarily but you might expose similar uh functionality uh in in in your application code again you're going to run into the same problem because people are going to expect the same kind of behavior from your code that they see from the standard Library uh so they they would expect uh uniformity in behavior um and again when you're designing your your own types that you plug in or if you're extending existing functionality you you'll have to deal with these Concepts anyway and I'm going to pick um just one algorithm sort because I'm I assume it's one of the most popular ones in the STL and we already see that we have a a compare predicate there uh so what are the requirements for a compare type that we have plugged in into into into standard sort well it's U first of all needs to be a callable um which means it's we expect it to be a function object um and we expect it to be a predicate which means it returns a Boolean value and it sort of needs to be a binary predicate because we need to compare two things at a time so intuitive this is what we expect to be there and we sort of expect a a signature similar like like this one where we we take two iterators and we have to decide which one goes first but the big question here is what kind of ordering relationship is needed for the elements of the collection so the stuff that we apply sort on let's say we're sorting a a vector uh of T's what do those t's have to be or how do those t's need to behave so that it works and uh I mentioned Kevin's keynote this morning uh did you all remember the uh do you all remember the the set example with nans that was a fun one right uh just a refresher and for the the ones who are seeing this video uh on on YouTube so Kevin showed uh a set of um floating Point numbers where uh we inserted some some numbers and at some point we inserted a nan uh and then we we asked about okay what's the size of the set yeah uh and the other way around we inserted the Nan first and then we inserted some numbers what's the size of the set u and uh or we called uh we call the count function and to see how many nans do we have in the set and so on and all sorts of of interesting uh answers that were certainly unexpected by the audience and the reason why uh those were anecdotical um and you might say I'm not I'm never going to insert nans in a set or uh I'm never going to try to sort a vector that might contain a nan well I'm I'm not going to be so sure about that so if you're dealing with floating Point numbers at some point some Nan values is going to sneak up on you and you're going to end up uh with an N value in a vector and then you're going to sort it or you're the the standard set example that Kevin gave does the same thing it it tries to keep unique values and and it tries to achieve that using the less than operator that I'm going to talk about so again we're using a type in Kevin example it was floating Point number that doesn't be behave like we expected to and it sort of breaks that contract just for some special values like for Nan for example so it and it breaks some uh fundamental properties that are expected some fundamental requirements on that the algorithm imposes or the data structure for standard set example imposes the same kind of um U requirement is broken for both and it it it works 99% of the time but when it fails it's going to be really ugly to see why so um I asked about compare is partial ordering uh enough um now uh I have just a very simple example there of uh 2D points where we can we cannot decide an or ordering relationship between uh all Point combinations for example P2 and P3 we can we can state for certain in that example that P2 is less than P3 given the predicate that we defined the predicate is the one under the the picture uh whereas for P1 and P2 or P1 and P3 when we try to compare them using the same predicate uh we cannot establish an ordering relationship um we say that it's undecided according to this predicate and we we the the formal way we State this is that the the two points P1 and P2 are equivalent with regards to this predicate because we cannot decide which one goes first and it's not a defect of the point it's the the way we decided to compare them the predicate that we're using and that might be an external thing for example if we're providing the predicate as a Lambda or power function to into the sort algorithm or it might be a built-in like if that structure implements a less than Behavior so it it might might come intrinsically from the type or be provided externally so it turns out that partial ordering is not enough for for sorting to work uh we actually what we're missing and we can clearly see from from that example um where the points were equivalent uh is that we're missing transitivity of equivalence and this is what comes in to complete all the a axioms required to form strict week ordering and yes STL expects strict week ordering it's the very same thing that is broken for nans uh and kevn actually explained that uh this stems from the fact that uh the the result of comparing n nans with other floating Point numbers is uh is is defined but it's not what what you expect uh from St we quing so it's sort of it's not a defect so what comparing Nan to uh FL to another floating Point number is defined by the triple I standards to to give as a predicate as a Boolean result is well defined but it doesn't match up with the expectation of or or the the the requirement of the algorithm so it breaks strictly ordering uh and equivalence like I said um it just means that we cannot decide so it's exactly the the red um red segments in the picture so we cannot decide which one goes first according to our comp predicate so formally yes I warned you it's good it's math so formally these are the uh axioms that need to be need to be satisfied by something to be strict weak ordering compliant um I think we're accustomed to seeing these in like fifth grade or sixth grade math uh they're not exactly something new um so IR reflexivity anti Symmetry transitivity and yes we also need transitivity of equivalence and it's sort of maybe U maybe a bit harder to follow because we have like a configurable comparator like comp everywhere but if you if you squint and you instead of comp you think about less than then it's going to make uh a lot more sense but that's sort of a more strict uh concept than strict we ordering so yeah strict week ordering is actually formalized since C++ 20 so it's this concept uh and its implementation is exactly what you expect uh with that uh table of aums so it just codifies uh the the four properties required there and like I said it's far easier I think this is what a uh a fifth grader would recognize uh from from a math class uh so if we if we look at it with less than so it's no longer generic comparator then um this is the less than comparable concept which is a different concept it's a stronger requirement uh than than strict week ordering um all right so going back to all those named requirements um we talked about less than uh there's one more uh one more equality comparable that um I want to cover and this turns out to be one of the most important ones uh and again um this should not be a surprise uh for uh um a kid learning math in school uh they might not like it but uh this is this is what we're taught very early on about equality and I I would say the meets the expectations I don't think anyone sort of mistakes this or or deliberately tries to break any of these assumptions when when thinking about equality uh and uh if we look at uh the formal definition using C++ 20 Concepts uh we can see how equality comparable concept is defined uh it uses an intermediate thing uh weak equality comparable with so it has the same two types that's just a more generic form so we can see that it tests the exact same properties that we had in the table so if we look at the table uh of the formal specification and the implementation of the concept really this is the actual implementation in C++ 20 uh so this is what uh codifies those axioms uh now I want to just a bit about um the difference between equality and equivalence because I I would say this is where we sort of mudy the waters many times when we Define stuff so um for for types that Define uh equality and less than comparable uh STL makes a clear distinction between equality and equivalence uh where equality is what we generally mean when we put that equal equal sign between stuff uh an equivalence is that thing we seen early on uh when we talked about um um partial ordering when I show the example example with with the three three points uh in the picture there so equivalence means when we cannot decide either way when we cannot say that a we say a less than b no B less than a no so then we say they're equivalent with regards to to to this predicate to less than uh whereas equality means um more means identity in many cases so equality is a special case of equivalence um and formally we say that equality is both an equivalence relations and a partial order but that's just mathematical mumbo jumbo uh so comp in in total ordering I I told you that when we try to refine things and use less than uh instead of that generic comp in we had in the axioms then we're we're actually building something something a bit stronger which is a strict total ordering uh this is what you come to expect from for example natural numbers um uh and uh the equivalence relations and its equivalence classes partition the elements of the set that are totally ordered uh and if we look at the uh totally ordered uh concept as it's defined we see that it it exactly matches the mathematical definitions now there's a it's it's no longer a a documentation story for STL at this point like H you should know these math concepts or you should satisfy these requirements that are do documented but you should read that documentation now they're actually codified now uh with actual C++ that the compilers can actually check and produce Diagnostics about uh and they very closely model what we see in those uh math tables so STL assumes equality is always defined or at least equivalence so uh we we we can sometimes squint and say okay uh I'm building an equivalence relation here and it works so equivalence is is more than enough for uh all STL algorithms and data structures to actually work uh but we generally mean equality when we Implement them uh there are many cases where it it makes total sense to implement equivalence which is different than equality uh can anyone suggest an example of equivalence that is not equality we that we frequently deal with for example if we we're trying to uh compare case insensitive some strings yeah so we say okay for the purpose of this operation I'm I'm doing a search I'm searching a string I I I don't care about it if it matches the case I I'm satisfied with a case in sensitive match for so for my purposes in in this workflow in this operation I they're equivalent but in reality they're not equivalent right they're different representations of they're different strings okay so STL algorithms assume regular data structures so that's why I'm making all the fuss about regular that's why we're having this uh uh presentation uh so STL was written with regularity as its basis and we see we're going to see that even the standard broke that contract that assumption so what is regular because I've been talking about ordering relations and requirements and Concepts but I didn't specify the the the regular concept so we have to again uh this is the uh I'm talking about EOP terminology here so elements of programming regular and semi-regular so semi-regular default constructible move constructible copy constructible and so on blah blah blah all these properties yeah we usually want all of them uh special uh special mention for uh default constructible one might make a case that asking for a type to be default constructible is not really requirement for something to be regular but it's usually what STL does for its types um formally this is how it's defined in C++ 20 again this is actual C++ code no longer words from the standard uh and regular just adds one more thing equality comparable to that so regular it just means semi-regular plus equality that's why uh I said equality uh is so important and it's so difficult to Define sometimes uh and we're going to see that and this is the again C++ 20 Concepts um implementation for the named requirement but equality and defining equality is hard it's very hard sometimes depending on the thing we're trying to model uh this is again a quote from from the generics programming fundamentals of genics programming paper two objects are equal if their corresponding parts are equally applied recursively including remote parts but not comparing their addresses excluding inessential components and excluding components which identify related objects mouthful uh what that means is that U and even stepanov said that it's h sort of even this definition although it looks complicated and complete it's it's hand wavy so it's defining qualities really hard and it's it's hard especially when our types are not well structured remember when I referenced whole part semantics of objects and lifetimes and overlapping parts and so on things that we should uh be careful when designing types all those things complicate what equality means for those types or even if we can Define equality or equivalence for them um special mention here for uh C++ 20 uh three-way comparison which uh helps a lot helps a lot um it brings consistency it eliminates a lot of boiler plate of course but it adds complexity so it removes complexity from your code that stuff that you need to write but it adds complexity in terms of the mental model and the stuff that you need to know now so three-way comparison doesn't just return like bull like true false or 0o minus one plus one or stuff that we've seen before it it it it deals in in relation strength and again uh it ties back to the things that I mentioned earlier those named requirements for how we uh how we order things so it's all about the ordering relationship that we can establish over the te's that this um space operator uh is is synthesized for so we need to be very explicit about the kind of ordering that we expect uh and and use and be very careful of weak equality uh so yeah um it provides this handy syntactic sugar um it gives us some gateways to um more efficient implementations so we can uh separately specify equality and inequal inequality for for our types and in combination with the uh synthetized um spaceship operator and this is to deal with um more complex cases where an optimally uh a more optimal implementation of equality can be provided separately than the generic uh ordering relationship that's uh synthesized for the spaceship operator if you want to see a lot of interesting uh examples of uh these kinds of optimization opportunities and what it what it means to Define to default synthesize this operator for types i' do recommend that you read the original paper for uh for for this the link is there uh and if you're into videos content this is by far the best presentation on on the three-way comparison uh out there in my opinion uh link is at the bottom so sometimes we just want a value uh who who has seen the herbs keynote at this year's CPP con it's already online by the way oh that's a quarter of the room uh way better than I expected okay so uh ignore the CPP front stuff and all the future looking things uh what I do care about is that uh herb show the way to formalize that something is a plain value and of course using the traditional Point example so the word value carries the meaning and and and it's it's it's it's right there in the code so it shows the clear intent and uh there's no like way around it like documenting that this is a value it codif codifies this uh anyway I thought it was a a nice touch um so again sometimes we just want a value but be before we get too far with fancy cpp2 stuff future looking successor things or uh if we were looking at C++ 23 or 26 and uh we we have a few things from from older C++ by now uh for example uh option of t so um I'm not asking for a show hands I I think everyone should be using optional by now I hope you can uh it's old enough I hope everyone has access to stuff like optional um so um it it has become a a common vocabulary type and why this matters is because optional extends T's ordering operations so if your T defines and you those stuff optional will extend these uh these things so um as if they're T so when you're comparing optional of stuff uh if they will compare as as if you compare your t's within uh and of course it it saves you a lot of error checking and stuff uh so it's good all around special uh mention here for optional of t-f uh this one you don't have access to unless you're using like a a separate Library implementation um I have um my opinions on this I think it's it's something that we need um it it provides rebinding shallow con deep comparison all good stuff um I'm optimistic I still think we can get it uh there are people actively pursuing this so I'm I'm still optimistic but in the meantime there are implementations out there and I always say um learn learn from others if you don't know what you're doing look over the fence so this is a a rust talk uh I go into a lot of details of these kinds of things for examples with using continuations and and the the monadic extensions for optional that's a separate presentation that I have so uh another one again should be fairly accessible to everyone by now I hope everyone is at least on C++ 17 uh fingers crossed um I'm not going to do a poll because I'm scared of the answer uh string view uh again not going to explain why it does uh what's important is that um it's a continuous sequence of char like objects and it's a constant thing so the underlying buffer is constant right this that's the important bit uh and string this succeeds admirably at at at being a droing replacement for a const string gra that's what it was designed for uh it was designed to be a glue code to be used at at your interface boundaries to be used in in as function arguments as glue code as your duck type for interconnecting all sorts of different string types you have in your system and so on so it's all good all around but I I think it's it was the first um STL type that actually broke some assumptions for C++ programmers because it was sort of weird uh because it it looks like a value type it looks like looks like a string sometimes behaves like a const string graph uh in when when used with function arguments uh so it it looks like a value type uh it can be cheaply copied around so it sort of tricks you that it's a value but it's actually not a value and it's not actually a reference either uh so it's sort of weird uh somewhere in between like a like a borrow type that you you use um uh when when constructing your functions so um bar types are references to existing objects they lack ownership they're usually shortlived um they generally can do without an assignment operator oo this is where it gets interesting because it ties to defining equality uh they can generally appear in arguments okay um unsafe to store them it's basically the same kinds of gutes that we have for references but now they're sneaked into this thing that looks more decent or less scary uh but it's just as scary as references right uh the interesting bits that are relevant to our uh equality discussion and type regularity is that string view is assignable uh assign has shallow semantics because the underlying strings are immutable right meanwhile comparison has deep semantics because it actually does a lexicographic compare so this is what you would expect you would expect to compare the underlying strings not some pointers right um so um when the underlying data type is extant and it's constant like it is for string view uh we can sort of squint and say h this typee sort of behaves as if it's regular although it doesn't satisfy all the requirements of a regular type strictly but it sort of looks regular so uh if we're using it properly in function arguments um because the we have no surprises with under the underlying buffer because it's a constant thing that we're pointing to we're not expected to modify things we cannot modify it through the string View and so on it sort of behaves as as a regular type but then we have this and this one is really weird because it sort of looks like string view but the underlying buffer is no longer constant and we're not expected to to to be constant that's we're trying to do something to it that's why we're we're using that span we're not just reading it uh so yeah so I'm going to skip the the r I expect people know uh so what would stepanov do so turns out with span uh we actually almost screw it up uh when when we standardizing very late in the process we actually sort of fix it uh so the question is should span be regular um and by the way that's the paper that dealt with all the nasty details uh so uh obvious things okay the meaning of copy construction and copy assignment is to copy the value of the object um okay we've covered this already uh copy assignment in equality should be go together okay when designing try to be regular okay that's the manifesto that's what we're trying to achieve when we design span right make it all these things say make it regular right but what does really happen so assignment is shallow so it just does pointer and size that's what all all we copy because span is meant to be cheap to pass around so it is shallow that's part of its design we could make equality deep and maybe compare elements as if we're using standard equal on them uh just like we do with string view right this is what string view does so the again the intuition of the programmer is okay I know string view I've been using string view I get how it works I'm using span now okay I think it works the same so uh these first two bullet points just say span behaves like string view however string view can't modify the elements it points to right we've said that already so a shallow copy of string is similar to a copy andri optimization that's a just a consequence but is span really a value can we consider span a value or is just convenience structure that we manipulate memory with and and and Traverse memory and refer to memory can we say is if it's a value or not conceptually I mean uh and if so do we need to do a deep compare uh so span sort of tries to act like a collection so it sort of tries to act like a vector we can even construct easily stuff from from collections so it's it's sort of tries to behave as if it's of a collection it has similarly named functions and it's sort of almost there uh but it's not a collection not really it's not it's not a collection and it's definitely not regular according to any of the semantics that we defined for what regular means uh more than this I would say span has reference semantics uh and arguably maybe it should have gotten a more explicit name like span ref or span PTR or something I don't know um I guess span is more appealing as a name so getting back to to equality so equality implies deep const logical const as extending to all its parts as per the definition in in elements of programming so we expect if we Define equality to mean deep con because it would be very surprising if we Define it any other way so all parts all the things that constitute part of the value should participate in the equality operator right right equality operator should do the same things that we do when we copy things right when you copy things we copy stuff right and we expect to compare that stuff to say okay what we copied we got the same thing right according to whatever copy whatever equality means for that thing but again span is not really a value um so deep equality means the value of the span and elements it spans not just pointer and length that's what deep means right so if we want span to act like a lightweight representation of it elements we need to have like a shallow shallow equality just like we do for smart pointers by the way that's what smart pointers do so shallow const means shallow uh equality but shallow equality quality might be really confusing especially like if you're trying to to meet what you know like okay I know how string view works and I expect span to work the same way so it's sort of I don't know a bit surprising so finally the the what we got was a compromise thing so and the compromise was to remove equality all together and uh because we just couldn't figure out an a way that that makes sense and it just works so I I think it was the right thing to do remove the operator all together but definitely uh definitely is it's a strange thing and it's definitely no longer regular right that's what regular means regular means equality comparable uh so so it it it's sort of not a not a value not a container it's it's a strange Beast uh so it and it's semi-regular at best um I I I chuckled when I saw this uh picture from quarantine u a few years back and by the way if you want to like a really gnarly details about span do read this article it's it's very good so for for non-owning reference types uh like string span you need more contextual information working with them to to understand these Concepts shallow compare mutability how we Define equality and so on so uh it's it's it's a lot of it's a lot of work so I would say uh it it also has some implications when when dealing with uh uh when dealing with these types so I would say my call to action would be uh um make your types regular when you can uh model them as closely as what you have in the standard Library not span right think of strings think of standard vectors think of integers so uh that's what you should try to aim for so um sometimes yes we need to define utility stuff like string View and span because they're just convenient but I would say those should be the exception rather than uh the rule okay uh I don't have time for question on record but the program is over so we have plenty of time to chat in the hallways or uh over drinks thanks