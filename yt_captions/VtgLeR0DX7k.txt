so you might be wondering why is this not the prime engine I mean maybe you're thinking wow this guy looks kind of like the prime engine flip cut this part out but the problem is prime has been in the valley you may have seen him it's a day in the life of an engineer that accidentally stayed up all night um and now he's at twitchcon BR um so you've got discount Prime uh the interns are running the startup right now while the CEO's away so we're going to react to some different arti Les today so chat you can all say hello to YouTube hopefully my javascript's faster than your rest GC your D alic and let your threads down let's talk performance I go over some of the performance trade-offs that are made with different approaches but the moral of the story is that performance is complicated and very use case dependent nice it depends called it one of the primary trade-offs considerations is CPU vers memory but the memory side of that equation can get very complicated one of the most enjoyable at least from my point of view parts of being a software architect is mentoring developers and help expose them to New Concepts and larger implications of technical decisions nice uh that's good this is actually good uh way better that your software architect actually helps other developers in your company to understand what's happening right and that they actually are like doing something instead of just like sitting all by themselves not not doing anything um it's also fun uh it's also a fun to Foster okay nice that one's not on me it's also fun to foster a learning environment by occasionally letting a Brash Dev fall in their face a bit of the pay forward from when I was young Brash develper nice nice that's really good uh one of the most oh I already read this paragraph a perfect example is when a green Dev challenges your recommendations reality being an architect you will always make the wrong choice in others eyes true lots of people no matter what the choices made will just be against it because their boss said so just be honest chat you know that you're in inclined to not like when someone else makes the choice instead of what you do even if you would have made the same choice at the same t uh go to bet that their approach is the best approach I know far from everything but I've been around long enough to see a sucker all right unfortunately I'm going to like this article I think I can already tell uh that I think I'm going to like this article even though it's saying javascript's faster than rust so I feel conflicted as my first time solo reacting on this channel of course it's going to be I'm going to like the article and Prime's going to hate me but okay how could I resist I'll take that bet and then years later I'll write a post about it this oh this is this is great I love this yeah I'll let you make a bad choice so I can write a blog post about it later gigachad all right the bet I honestly don't remember the specifics it's been a few years but I do recall that I recommended using nodejs primarily based on the knowledge set of an existing team available libraries and other technical debt that makes sense that one's the clearest reason that you would continue using nodejs a pretty Junior Dev I don't know what his looks have to do with it but that's fine wanted to show off their fancy new Bachelors of computer science and show off their Mad Skills maybe they knew I only minored in computer science and assumed I was simply unaware of how computers actually worked to be fair after 20 years I have come to believe they are just magic uh this is a common scenario chat if you want people to not like you at your job when you're the new person you come in and you just act like everyone else is an idiot not a good strategy okay not a good strategy I would recommend being nice and listening especially when you're young you'll learn a lot and the people who know stuff will like you a lot more so it's just just a little side life Pro tip we do those in the middle of the Articles right I don't just I'm not just a screen reader the names the teen the claim was something along the lines of the standard C++ is faster than JavaScript I mean technically JavaScript is just C++ you know the V8 runtime well you know sometimes I do some stuff with the V8 runtime in the uh countered by my stereotypically architect response of it depends nice maybe I should be a software architect I say it depends a lot in fact recently I was almost cancelled for saying it depends because I said someone shouldn't just only try and get a job by quote building in public and having an online presence and I was told that applying to jobs through job application sites was a waste of time because I said it depends on the person and their situation and sometimes you do get jobs from applying to regular job posts and someone told me that that was a terrible take and I should be ashamed of myself um so but apparently I could be a software architect cuz I like to say it depends even though that's uh I know I should be just ashamed that I would think of saying basically you might want to apply for jobs the normal way as well people do uh sometimes get hired through that process should have just bought a fake mustach I know sorry you should always be ashamed of fear that's that's a separate argument but also true the claim was something along oh yeah we already read this actually this time for real um more probably optimize C+ perform better than optimize JavaScript as there is inescapable overhead and running JavaScript well you could probably compile it down to a static program get to FR to really really try needless say I like a good challenge and the result the surprise that the jav solution was a bit faster than C++ program and more importantly from an architectural point of view had the benefit that it was fully maintainable by the existing team so this is true so as someone I'll be honest chat I'll be honest as someone who has snuck rust into their job um it was through a series of really really tricky moves that eventually made rust a ser serious part of my day job um it's it's true that people are terrified to just touch any part of that program and I actually had good technical reasons and good like architectural reasons for why we would have chosen rust and why it's still working and running and stuff like that right but but people are just terrified about it because it's rust so this is something if you're actually trying to get something done at your work you do have to thinking about this possibility of being maintained by the existing team not that the people aren't smart enough to learn it necessarily or anything like that just that people are afraid and then therefore they don't want to do it and then it just stays there and never chains so uh let the choir hold their tongues and scratch their heads at the same time yeah I bet you can't do it to be honest I wasn't 100% sure that it would win but based on the specific use cases likely dependence on dynamically sized memory objects and the developers inexperience I took an educated guess okay so yes uh this this part uh will definitely play into into this problem uh which so maybe the title is just clickbait but that's fine wait how if you can't guess why don't worry in my experience most devs wouldn't know why either the result flies in the face of the common rule of thumb that compiled language are fashion than interpreted and static profession NVM but this is just a rule of Thum true um there are no always or Nevers what's it always or every time I don't know whatever but uh you got to look around and be curious okay surprised that a junior Dev can't make a good C++ program yeah yeah um there's some confounding problems to this just don't do allocations optimize this keyword in my BP as a naive C++ program can quickly go off the rails I would even say not just a naive C++ program in my experience you could just remove this part A C++ program can quickly go off the rate on the other hand node.js leveraging the C++ cbas V8 and libuv libraries true as pre-at sorry I as I said before some would argue JavaScript is just C++ it's just a DSL for C++ node V8 blah blah blah pre-at sorry has made a lot of strides with optimizing dumb JS to run fast meaning there are well it's like no need to be redundant meaning there are cases where naive JS can beat naive C++ but it's obviously more complicated than that this is like in some ways kind of a tautology right in the sense that like yeah um you can write bad code in all the languages right you can always write bad code in all the languages some languages make it easier to write bad code some some would just make it harder uh to write bad code of some kinds but you can make at least bad code in the sense of not performant right this is literally yeah we're we're reacting to an article right now and look at this we even have chat up here so so that you can say wow this is literally primagen stream where's the meat of the article um that's we're going to find out I guess nice Prim never select the first and last I'm I'm trying to be as authentic as possible as authentic as possible uh okay so oh yeah the memory most developers should be familiar with the ideas of stacks and heaps but many don't go deeper than the surface level characteristics like a stack is linear and a happens a pile pointers or something like that um chat have yeah okay so that's true so they also probably missed that they these are just Concepts and there are other approaches with multiple implementations low-level Hardware typically doesn't know what a heap is as software defines how memory is managed and the choices made can have massive impacts on the performance characteristics of the file program um okay so you don't want to know about this blah blah blah that's fine uh yeah so this is definitely true I would say most developers don't go deeper than surface level I would say most developers just never think about memory right right like is that a fair like if you're just taking all developers like most developers probably just don't even think about memory and when they do they think about it like completely wrong like they're worried about putting stuff inside a list when they have like 10 users you know what I mean they're like oh we can't use a list cuz like and keep that around CU we have like 10 users you know uh but that's okay so so agreed so far agreed so far agreed which as I said before I'm feeling bad that I'm agreeing with my JavaScript is faster than your rust okay technically so far it's only been C++ though okay so far we've only had C++ all right the cheat garbage collection sure no JS Sol takes longer to start has to load and run the script through its jit compiler but once it's loaded it has a secret Edge it's garbage collected okay I don't think that's a secret like I'm not I'm not convinced that's a secret feature of no JS everyone's like surprised they're up up down down AB left right left right and they're like dude I unlocked the secret garbage collection inside no. JS before I was manually managing my Js memory in the C++ program on the other hand the app routinely created dynamically sized objects in the Heat and then deleted them oh no I can't can't believe Prime's not here it's literally going to be about reusing memory this is like Prime's favorite JavaScript trick it's literally avoid allocations avoid allocations is literally his favorite [Laughter] one oh just make it object w i just reuse the object that way it won't free the memory we don't have to get the C you just have them in a circular oh my goodness I'm sorry Prime sorry for reading this one uh too bad I guess next time don't go to twitchcon without me um okay so they alcate and dealate the memory Heap over and over again this is generally not fast true memory things are slow chat memory things are slow okay um it depends heavily on what algorithm is used in the allocator yep in many cases D alic is particularly slow and sanitized Alex aren't the cheap either okay yeah so basically um it's not free to get new memory and if you're manually managing your C++ program right if you're thinking about it then you're you're going to just be like opening and closing the same memory you're going to be alloing and dealling Malik stands for memory allocation right by the way Prime um malic and in the JS one the garbage collector is going to kind of cheat right so the cheat occurs because the program runs once and exits no JS runs the script allocates all the memory needed but actual removals are postponed for the garbage collector to take care of wait so what is this just some random script I still don't know what the problem is that they're solving so they haven't told us any details about the problem right am I am I missing something um now garbage question ishly better or worse than other man memory management strategies true but in the case of this proov it pro proved beneficial as it actually never ran this is not even like a long running wait what it's not even like a long running process or anything it's just literally like they they just ran a script one time not even enough to trigger garbage collection and then their mem then they're trying to figure out which one's faster or slower why would you even write a C++ thing well okay so why would you even write C++ but then like besides that why would you write C++ like for this problem okay all right now I'm getting confused does come at a cost no JS process us more memory than C++ and the class trade of less he more memory blah blah blah it was a good trade to win the bet does this count the whole thing too even no JS like starting up what is this problem cuz I don't know the B only worked because the vro a naive strategy implemented correctly a quick way to win would be to add a memory leak purposefully keeping all the allocations memory it would likely use less memory than nodejs and still be significantly [Laughter] faster what is this what is this question oh I've been debated by micro benchmarks this is almost as unbelievable as trut um no he's pre read this also brings up an issue with benchmarks often they use a single metric like Ops for seconds this is JS C++ perfect example blah blah blah yeah turns out you need to know more than what some naive Benchmark did blah blah blah okay uh modern day entered rust thank goodness finally rust is one of my go-to languages nowadays nice it's got a lot of great modern features is fast has a great memory model and it generally leads to safe codes and unsafe communities it has drawbacks for sure compile time is still an issue and it's got some weird semantics here and there but in general I highly recommend it you can have a lot of control over how memory is managed in Rust but the stack memory follows in ownership model which creates this trademark safety T why not put safety as a TM also is this officially endorsed by the foundation one of the projects I'm currently working on is a fast function as a service host written in Russ that executes WM WM functions it's designed to securely execute isolated functions very quickly minimizing the overhead of using functions as a service okay chat I'm embarrassed honestly I'm thinking about turning this article off imag imagine not typing it's fast like what is even the point of having dumb acronyms and so many things like blazingly fast like this it it's a it's shameful really it's shameful uh it's pretty fast able to get 90k clean requests per second per core better yet it can do those total reference memory 20 megab okay what does that have to do no JS C++ while use no JS as my Benchmark for reasonable performance go is used as the dream Target it literally seems like Prime wrote this uh it's hard to compare to a language designed for web services while adding the overhead of fast and early versions of the program weren't promising even though they use less than 10% of the memory of no JS while it's common to focus on getting something working before optimizing it's not a great feeling to put a ton of work using a fast language only to get beat by novice JavaScript okay so wait use JS in my Ben I'm so con confused this thing runs functions but somehow the job it what does it even do B was pretty clear early on is the memory management each guest function was allocated an array of memory there's a lot of overhead between allocating within the function and also copying data to and from the function's memory and the hosts because of the dynamic data being thrown on the allocator was being hammered from all directions the solution cheat sort of okay so I'm still I'm confused so I guess I'm doing a good job of being reacting like Prime now I think so we'll keep reading and if it doesn't make sense we'll just finish the article and I'll go on a rant about how I don't like jsx now and I do like go templating so that in two weeks when I change my mind then we'll have more content so fundamentally a heap is just a memory that an allocator manages the mapping for the program requests n units of memory and the allocator will find it in available memory pool or Crystal give more memory store store that the units are in use and then return the location pointer of that memory when the program is is done with that memory it tells the allocator and the allocator then updates his mapping to know these units are now available simple right the issue starts to arise when allocating a bunch of different size units of memory with different lifetimes you're going to end up with a lot of fragmentation that amplifies the cost of allocating new memory sure okay this is where he starts the performance going kick in as it's basically its own program just to figure out where to store things obviously there isn't one solution to this problem there are lots of different allocation algorithms from buddies to slabs to blocks each approach has trade-offs meaning you can choose one that fits your use case or just choose the default one like most people do okay so I guess the fast is the thing that's choosing the how the allocator is going to work or something that's what part that I don't really get so I guess he's R in thing that's going to do that I'm not sure okay now for cheating you don't have to choose just one approach and for fast you can go LAX on the per run diic and just clear the whole heap after each run you can use different allocators for different parts of the function lifestyle for example example a knit versus run this allows either a clean function reset to the exact same memor run or a stateful one maintain State between runs and have each case optimized using a different memory strategy so you have this fast and he's saying you start a function you run it and then you finish and he's saying if you have a knit you just clear everything at the end and run right you do this and then you keep the memory so he's saying for a bunch of of the key ones for run you're not okay I'm not sure okay we'll keep reading so allows either or stateful one yep okay so uh for mine we end up building a dynamic allocator that chooses the allocation algorithm based on usage that choice persists between runs for low usage functions seeming the majority of functions thus far uh yeah low usage functions that's because probably chat is using the surface service and you guys don't have any users so like all of your stuff would be low usage a naive stack allocator is used that just maintains a single pointer to the next free slot when dallo is called if the unit is the last one on the stack it will just roll back the pointer otherwise it's a no op sure when the function has completed the pointer is set to zero makes sense makes sense it so uh for those of you who don't get that uh basically what's happening is like can I do another one of these um you have like your block of memory right here you just have a pointer the pointer keeps moving as you alloc new stuff you never free anything and then when it's done you just move the pointer back here so this is just like a linear allocator this there's also another Heap Us in the run time that is the host function shared memory same Dynamic allocation Str allows for writing directly the function memory bypassing the copy step in early versions this means that the io gets directly copied from the colonel to the guest byp passing the host function okay nice nice um after opens stations the rust function as a service end up being 70% faster once again this is embarrassing while using 90% less memory than our reference node.js but the key is after optimizations the initial implementation was slower did require placing some restrictions on the walls and functions to work though they those are transparently applied during compilation with rare incompatibilities okay um the major benefit of the rust implantation is the low memory footprint all the extra Ram can be used for things like caching and distributing man stores even faster by reducing IO blah blah blah that's great we do have more optimization slated but mostly involve changes to the host layer that have some major security implications they also aren't directly related to memory management performance but they do give plenty of fodder for the rust is faster than node Camp conclusion not really sure same all right we're still I'm still agreeing with this article there's a couple of points um memory management is interesting and every approach has trade-offs true tradeoffs are something that you will not find out about on x.com it's possible to reach huge performance get uh gains by playing with different strategies also true I still use and recommend both no. JS and rust for different purposes so no win here either uh JavaScript is wonderfully portable and works wonderfully for a bunch of cloud native scenarios but Russ is a great choice when performance really matters okay my JavaScript is faster than your Russ I'm still getting some mix messages and whenever I say JavaScript I actually mean typescript I'm not a Savage Dre um although man I don't know no bill JS coming back the end of the day you got to choose the best stack for your situation is rarely a simple answer but understanding the different characteristics of different Stacks can surely help uh starting drama with dhh all performance no trade-offs exactly exactly lisby okay so what I see here this pretty good article overall the reason that JavaScript was faster for this kind of problem is because we built an entire ecosystem around one shot functions as a service or serverless or all this other stuff because JavaScript sucks at running for a long time so this like whole thing is only a problem that you would want to have functions as a service primarily because your original framework suck at running and running performant for a long time so there you go so it's like rust doesn't work that good at this problem CU it's a dumb problem to have there you go there's my hot take um I I gave my best take of what prime did unless it's a good hot take then it's my idea okay deeper tone yeah we can do that yeah yeah yeah yeah that's my hot take guys chroot chroot chroot um yeah I'm just not going to twitchcon so I can Farm Prime zerus that's true talk about how you hate typescript all right uh typescripts the best also it's bad the name the teen