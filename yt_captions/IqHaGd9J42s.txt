hey hey it's probably time to stop recommending clean color is this not the most like milk toast take you can have it should just be called stop recommending clean code you know maybe we should consider possibly not doing clean code you know we're gonna get in there okay we're gonna get in there and I'm gonna just say this stop recommending clean code okay it may not be possible for us to ever reach empirical definition of good code or clean code absolutely which means to say that any one person's opinion about another person's opinions about clean code are necessarily highly subjective this is true this is very very true and by the way I did forget to say some thank yous flip take this out flip take this out flip take this out hey dwarzi thank you very much for that and uh Prozac thank you for those gifted Subs I appreciate that okay I appreciate that sorry I didn't say thank you to begin with all right oh shoot I don't even know where we're at all right let's see pick up from here okay there we go there we go all right I cannot review Robert C Martin's 2008 book clean code from your perspective only mine foreign code still don't like it uh that said the major problem I have with clean Cloud clean code is that a lot of the example code in the book is just Dreadful asterisk in chapter three functions Martin gives a variety of advice for writing functions well probably the strongest single piece of advice in this chapter is that function should be not mixed levels of abstraction they should not perform both high level and low-level tasks because of this because this is confusing and muddles the function's responsibility I like that take that's a good take I mean really your functions should approach close to single responsibility approach and what I mean by that is that you know when someone gets really into clean code or really into things you start seeing this really like almost like Lego level dissemination of how information works and it gets super spread thin and sometimes that's really hard to work with right there's like there's a level of abstraction there's a level of things you should be doing that you know like there's definitely a curve there's too much like atomization it gets difficult and too little atomization it gets difficult but there's like a middle ground where it's or it's really nice personally what I find my general rule of thumb is this is that a function should do a concept that's like my general rule of thumb and if this concept comes and if if inner Concepts come up many times I will refactor out that inner concept into its own thing but in general I keep at a conceptual level what it should be doing so that means if I need to go fetch all the video frames for a video sort them and give you the highest you know the the the highest encoding time for a video frame then what I'll do is I will actually do all those in a single method right if that's what I'm doing because that's just like that's just the concept I'm just going to do that and until I need the fetch video frames many times I'm not going to pull that out right like I just kind of keep it into this really you know whatever there's a there's a let's see let's see there's other valid stuff in this chapter Martin says that function functions responsibility I must let's see they should not perform both high level and low level tasks because this is confusing and models the function's responsibility there's other valid stuff in this chapter Martin says that the function name should be descriptive and consistent and should uh be verb phrases and should be chosen carefully I probably don't choose these things as carefully I'm not sure if I do verb phrases well this seems really loud wow that this is oddly loud uh you know I don't know how well I named my functions because a quarter of the time I just want to say you know like these nuts jokes and it kind of ruins my ability to name good functions you know what I mean does that ever happen to you where it's like you should be responsible but instead you're naming it Deez Nuts later TJ later teach uh he says that functions should do exactly one thing and do it well which I agree with provided that we aren't too dogmatic about what we Define as one thing yeah so I'm on this Camp uh we have to understand that plenty of cases this can be highly impractical he says the functions should not have side effects I disagree with that and he provides really a great example and that let's see and that output arguments are to be avoided in favor of return values yeah I would agree that output arguments are generally a bad idea generally a bad idea you know what I mean generally uh but sometimes they're not uh he says that function should uh generally let's say you should either be commands which do something or queries which answer something but not both okay this is all reasonable entry level advice yeah yeah I kind of go I go kind of back and forth right it's I I whenever like the tool I'm building right now we're up to like 40 000 lines of code most of it is is just like a bunch of Legos and then I build up this then I have these like entry point these functions these commands you can run and those tend not to be very you know those tend to be a bunch of stuff all kind of muddled together and that seems really reasonable because like when it comes to like these it's almost like UI code it's just like you kind of just gotta do a bunch of to get this thing done and breaking up any further is really inconvenient so I always have this hard time of when do you break this rule because there is a time you should break the rule and it's not obvious and sometimes it's even better to break the rule intentionally when the thing is small and grow it as you wanted to you know what I mean uh but mix into this chapter there are more questionable assertions Martin says that Boolean plague arguments are a bad practice they could be they can be annoying uh which I agree with uh because in an unadored true or false in the source code is no Pagan unclear version of explicit is sweet and is not sweet yeah but Martin's reasoning is rather that Boolean arguments mean that the function does more than one thing which it shouldn't uh yeah I disagree with his take reasoning why I don't I generally do try to avoid booleans because they truly are confusing and every time I do a Boolean flag it's not that they are confusing it only takes a moment right like I think a lot of these things that are written really don't have in perspective something like a uh you know like something like an LSP that's just gonna help you right away so you know exactly what you're getting right and so Boolean Flags don't bother me because I pop it up and I can see right away you know do this thing and I can see right there and I go okay this is this is what that Boolean flag does but the problem with it is that whenever I write a function like that inevitably it seems like I always have to abstract it further and I have to add yet another Boolean flag it always seems like I've done something wrong and I can't describe exactly why it's like a named argument effectively and so I have this problem where I I know that it's wrong I just can't it's a hint I I just can't quite tell what the thing is that's wrong and so mine I don't know Martin says that it should be possible to read a single source file from top to bottom as a narrative with a with the level of abstraction each function descending as we read on each function calling out to further functions down this is far from universally relevant many source files I would even say most source files cannot be neatly hierarchorized uh in this way yeah I'd agree with that even for the ones which can an idea let us tribulo jump from function to function Yes again I wouldn't organize it that way generally I try to organize things in a very simple manner right like type definitions up top functions down low right as simple as that like I don't I don't try to be super dogmatic about things I try to Define functions that I use within the function lower down I think that's a good practice in general but that's about it you'll understand soon that every language you've ever used is trash yep every language you've ever used is trash specifically JavaScript um he says that code duplication may be the root of all evil in software that's always the miscode you know people have never quoted that phrase correct we gotta get someone has to be able to quote this thing correct at some point one of us is going to do it correctly uh and fiercely Advocates dry at the at that let's see at the time this was quite the standard advice in more recent times however we generally understand that a little duplication isn't the worst thing in the world it can be clear and it can be avoided let's see it can avoid cheaper than wrong abstraction yes so I totally agree with this that you should never never do this I did this for a decade like a decade dry is the root of all bad code dry is the root of all bad code for 100 because what ends up happening is that you consistently and can like continually abstract things it's so annoying it's so annoying uh then it gets weird Martin says that function should not be large enough to hold the nested control structures conditionals and loops how do you ever program then equivalently they should not be indented more than two levels he says that block should be one line long consisting probably of single function calls he says that the ideal function has zero arguments but has no side effects and that the function just three arguments is confusing and difficult to test more bizarrely Martin asserts that the ideal function is two to four lines of code long this piece of advice is actually placed at the start of the chapter it's the first and most important rule I actually find all of this incorrect virtually everything he says is incorrect my general rule of thumb is set an 80 column limit right here by setting an 80 column limit you're going to know when you're probably indented too much and I do mean that this 80 column limit is going to give an early warning sign that you've exceeded a an amount of indentation that maybe isn't worth it it's also a reason why I don't use two space indenting two space indenting just makes me write more nested code because I just have I have more space to go and so I just use this as a soft rule for myself right so this is a soft rule right here for me to just know how much to do right uh I find that um you know I like it yeah and when is a function too big I don't have a strong opinion on when a function is too big I don't I have no opinion on when a function's too big a function is too big when it has too many Concepts and I'm fine with the function with two concepts sometimes you know sometimes you gotta do it zero argument thing only makes sense in a world in which you're just you're strictly building basic nothings a hundred lines is too long is it is it I don't know I can't tell you what's too long right it it's hard it depends on what you're doing uh let's see the first rule of functions is that they should be small then the second rule of functions is that they should be smaller than that that is not an assertion I can justify I can't provide any references to uh to research that shows very small functions are better I find it the opposite in fact just me and my general Outlook of life I find this more confusing significantly what I can tell you is that nearly for four decades I have written functions of all sizes and I've written a nasty 3 000 line Abominations I've written scans of functions with 100 to 300 line range and I've written a functions that were 20 to 30 lines uh what the experience has taught me uh through long trial and error is that function should be very small yes and when Ken when Kent back showed me the code I was struck by how small the functions were I was used to functions in uh in swing programs that took up miles of vertical space every function in this program was just two or three or four lines long each was transparently obvious each told a story and how each LED you down to the next compelling order that's how short functions should be you know it's again I I feel like this advice is is totally lacking a bunch of stuff I don't know about that like here's a good example say you have a complex type of crash report type and you need to display the crash report like that function that displays it say in a CLI application it could be it it could be quite a few long lines long because clis that are just printing stuff out you could have many log statements to get to that point and you you may have to do a bunch of little assertions all the way through it feels like is that bad is that good I don't know right uh of all things like let's see like all of this sounds like hyperbole a case for source to function instead of one long ones can certainly be made but we assume that Martin doesn't literally mean that every function in our entire application must be four lines or less yeah uh and let's see but the book is being absolutely serious about this all of this device culminates in the following source code list at the end of the chapter okay here we go do I zoom out to see it see like this stuff I hate this kind of stuff when I look at this this kind of code right here like emotionally hurts me because there's so much context I have to set up in my brain to understand what's happening do you know what I mean like if we just look at this one uh include setup page like look at this include setup Pages include which calls this which if it is this it has to do this or it has to do this like you have to hold a huge amount of context in your head and I do not believe in any sort of way this is easier to follow right right like that kind of like this hyper like this hyper smallifying of code it becomes ten thousand times harder honestly how hard would this have been if you would have taken here let me just go like this all right so here's that code how much easier would it have been if I would have just done something like this right I don't even know what include page does what does that do includes page setup all right uh right like you kind of you kind of just know what's happening right here I didn't have to jump five functions to figure out what the hell's happening right or is that both oh it is both you're right it is both there you go I'd have to find out what the hell's happening you know what I mean like this is just so much easier to read than several functions of jumping but that's if it's used everywhere then you abstract that concept but it first has to be used everywhere right that's why Martin Fowler has this really a beautiful thing which is when you repeat yourself three times then refactor right that's a beautiful rule like and here's the deal how do you know this is repeating itself like it's it's incredibly difficult to figure out this one is not repeating so this is not a repeat this is not a repeat you have to use function references to figure it out if it's repeating itself so I do not like I hate that stuff I hate it I'll say it again this is Martin's own code written in his personal standards uh this is an ideal presented to us as a learning example this is true this is an ideal right uh I will confess at this stage I like my Java skills or let's see uh that my Java skills are dated in Rusty almost dated as Rusty as this book and which is from 2008 but surely even in 2008 this code was illegible trash I would agree uh Let's ignore the uh wild card in Port first the class name set up teardown includer is Dreadful it is at least a noun phrase as all the class names should be but it's a noun verb phrase the strangled kind of class name you should invariably get when you get working on a strict object oriented code where everything has to be a class but sometimes the thing you really just need is a simple gosh dang function dude for real setup teardown includer this doesn't make any sense inside the class we have two public static methods uh as before plus one private Constructor plus 15 private methods of the 15 private methods 13 of them are either let's see let's see 13 of them either have side effects they modify the variables uh which were not passed into them as arguments such as build this which have side effects on new page content or call out to other methods which have side effects such as include which calls this only is test page find inherit page looks for side effect free they still make the use of variables which aren't passed into them page data and test page respectively but oh my goodness yeah it's such a it this is such a cluster Festival right this is a great function I'm fine with that function there you go that's a great one right there I'm fine with that um but some of these things are just so painful like all of this stuff is just so like this is so hard to read I just hate this idea of clean code anyways at this point you might reason that maybe Martin's definition of side effect doesn't include member variables of the object whose method that we're called uh if the if we take this definition then five member variables page data is sweet test page new page content page color all implicitly passed to every private method call and they are considered fair game any private method is free to do anything they like of these variables exactly so another this is more of a stab against oop which is the effect of methods and what they have implicitly passed them can be very large and it can you know classes can be very tricky I like classes don't get me wrong but they can also be Trixie but Martin's own definition contradicts this from the earlier in the chapter side effects are lies your function promises to do one thing but it does another hidden thing sometimes it will make unexpected changes to variables of its own class sometimes it'll make them uh to the parameters passed into the function or to the system globals in either case they are devious and damaging mistruths and often result in strange temporal coupling and Order dependencies I'm not a you know I I'm fine with functions mutating state of a class am I the only one is that crazy is that crazy of me to think that put the ass back in class hell yeah is that is that crazy of me to think that I don't know I like this definition I agree with this definition it's useful definition but it enables us to reason about what the function does that with some degree of confidence uh he said unexpected I mean it's always unexpected because you don't know what something does until you know what it it does is that a truthism yeah uh by referring to only as inputs and outputs I agree it's bad for a function to make unexpected changes to the variables of its own class I mean is there any unexpected changes so why does Martin Martin's own code clean code do nothing but this rather than have a method passed arguments to one another method Martin makes a distressing habit of having the first method set a member variable in which the second method or some of the other methods then reads back that makes it incredibly hard to figure out what any of this code does yes because of all these incredibly tiny methods do almost nothing and works exclusively through side effects agreed cascading side effect programs are very difficult let's just look at another one of his private methods this dot is okay so render sets the suite if it's a test page include this return this one get the H bill so you can imagine that this and let's see that someone enters a kitchen because they want to show you how to make a cup of coffee as you watch carefully they flick on the switch in the wall the switch looks like a light switch but none of the lights in the kitchen turn on or off next they open a cabinet and take down a mug to set up set on the worktop and then tap it twice with a teaspoon they wait 30 seconds and finally they reach behind the refrigerator where you can't see and pull out a different mug this one is full of fresh copy what just happened what was the flickering switch for what tapping empty mug part procedure where did the coffee come from that's what like this coat is like why does render have a side effect of setting the value of this is sweet when when is this is sweet red back in test page and include yes it does in both in neither if it does yes okay so that is really good point which is if you look right here this right here is used further down which just becomes confusing right so but not only that but it it sets like it sets the state of this thing until someone sets it differently right like that's also super confusing like this whole stuff Java I love it uh Martin changes in this very chapter that uh that it makes sense to break a function down into smaller functions if you can extract another function from the name uh with a name that is not merely a restatement of its implementation but then it gives us this is test page I agree I agree with that oh have I skipped something let's see how would you unit test this method well you can't it's not a unit it can't be separated from side effects that it has on other parts of the code and what's up with the indentation and where are the dang braces exactly dude I always think about that dang braces I didn't want to say anything but yes I agree is number larger than 10. oh no uh private Wiki a page a find inherited page you know I used a program like this I did I was affected by Clean code I went to college during the clean code phase I was in the Java phase I did all this I was getting a master's in software engineering at once and it was all like this and I used to write code like this and I just hated my life and I couldn't figure out why I hated it a half dozen others that say okay let's see there's at least one questionable aspect of this code isn't Martin's fault the fact that page data contents get destroyed unlike the member variables is Suite test blah blah blah blah page data is not actually uh ours to modify it's originally passed in at the top level render methods by an external caller the render method does a lot of work and ultimately returns a string of HTML however during the work as side effects page data is destructively modified huh surely it'd be preferred to create a brand new page data object with our desires uh our desired modifications and leave the original untouched if the caller tries to use page data for something else afterwards they might be very surprised about what happened to the contents but this is how the original code behaved prior to the refactoring and the behavior could uh could be intentional Martin has preserved the behavior though he has buried it effective uh very effectively interesting I used to get harassed by middle management and Junior devs about the need to have clean code and they won culture of culture battles for a while yeah it's true some of the mild puzzles uh yeah okay so this is just like a whole bunch let's see is there something more okay anyways let's do this pretty much clean code mixes together a disarming combination of strong Timeless advice and advice which is Highly Questionable or dated or both much of the book is no longer of much use there are multiple chapters which are basically filler focus on laborious work examples of refactoring java code there's a whole chapter of examples of refactoring java code oh there's a whole chapter examining the internals of J unit this book is from 2008 so you can imagine how relevant that is now there's a whole chapter on formatting yeah pick a sensible standard formatter yeah why would you even do that why would you ever yeah the content uh focuses most exclusively on object-oriented code to the exclusion of other programming paradigms object oriented programming was very fashionable at the time yep it was was a huge promotion of oo having uh invented three of the five principles which make up solid and having popularized the term but totally absence of functional programming techniques or even simple code or procedural code was regrettable even then and has only grown yeah I love procedural code real talk I love procedural code procedural code is fantastic I love it I love procedural code anyone that you know this this whole idea that that somehow it's bad like there's this notion that I had in my head that it's bad and I realized I don't think it's bad at all like a lot of stuff you can do can be does done procedural and it's great you know what I mean it's fine oop is disgusting rust is procedural yeah pretty much most things are procedural they're not quite functional most people think what they're doing is functional they're actually doing is procedural uh it's very very interesting step one do this step step two do this step step three you did stuff procedural code is just like do X do y do Z dude a doobie Deuces do d the end right pretty much see as procedural Max yeah it's a little see you can kind of turn into functional anyways the book focuses on Java code to the exclusion of other programming languages even other object oriented programming language Java's popular yes it was very popular and at the time of the writing the book this makes sense yep I agree with that I agree with all that but the book's overall use of java is very dated well yeah it's because Java's changed so much uh this kind of thing is unavoidable programming books date legendary legendarily poorly twolys always makes a word difficult to read uh that's part of the reason why clean code was recommended read at one time and now is uh now I think the pendulum is swinging back in the opposite direction yeah but even at that time even the 2008 era Java much the code is bad there's another chapter on unit testing that there's a a lot of based good basic stuff in the in this chapter about unit testing should be fast independent and repeatable about how unit tests should enable more confident refactoring I really am really not sold on that one about how unites should be about voluminous as uh code under tests but strictly simpler to read and comprehend so I have some pretty general rules about code unit testing unit testing should be as declarative as possible right I think that's very very important uh if you find yourself doing logic in unit tests you've pretty much you've jumped the shark in the usefulness uh three unit tests are almost exclusively not useful during refactoring and the reason why I say that is because when you refactor you change the unit almost always and so more functional level or integrational level testing tends to be way better for refactoring if you have really good integration level tests that tests the entirety of your program you can go nuts then you're doing unit test wrong not necessarily unit tests literally mean units right like it can just be a function that does something complicated I test stuff at the function level but when I refactor often that function goes away in principle because it's I vastly changed the orthogonal nature of my program and thus unit tests are unuseful I don't think that level of testing is useful for refactoring I've never thought it was useful at the function level but I do find integration tests amazing for refactoring because they always just keep doing the same thing our writing good unit tests I learned a lot yeah you can I mean I'd have to look at what it has to say I test on a live server I think live servers is really good agreed with you when you say refactor you need to change all the tests anyways you need to change the test so often anyone that says you don't have to change tests I just feel like you haven't refactored enough oh crap oh crap oh people I got I gotta I gotta go I got a meeting we can't finish the article good article but I can't finish the article gotta go I'm gonna just pick almost picked Pokeman I'm gonna do Christopher Titus Tech we're gonna go right here we're gonna take this I gotta go I gotta go I'm late oh shoot oh shoot meaning run