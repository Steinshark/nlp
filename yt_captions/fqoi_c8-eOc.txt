clean code is slow but you need it anyways I've already begun to disagree with the article I'm going to turn I'm gonna I'm gonna calm myself down I'm not gonna I'm gonna read this with an open mind I'm gonna read it with an open mind okay I'm gonna read it very open okay here we go so open beware clean code can clean anything all images really you know you could have just chat Jeopardy I'm always so confused why people always have these like unsplash and all this you know you can just you can just you can just Dolly this image this is it really that crazy uh in case you haven't heard something really interesting is happening in the programming software development scene on Twitter it all started from one of Casey moratori's video on performance aware programming by the way that video clean code bad performance was an excellent video if you have not watched that video you are truly missing out on a great great video Even though I don't agree with all the things he said and I do think that he's gaming the system a little bit on the measurements nonetheless I think what he's doing is fantastic absolutely love this one okay if you haven't seen it please go check that one out it's aptly titled clean code horrible performance look at that I know it's so well I memorized it it's sent from Casey's own criticism of modern software uh that runs at less than 120th of efficiency this is a valid concern considering inefficiencies are the reason we can't get nice things and also the reason why John Carmack left meta then Uncle Bob I.E Robert C Martin chimed in and had a very thorough and educational discussion with Casey using GitHub the discussion is still going on as of this day it also spawned a thread on Hacker News okay okay okay okay okay I have seen let's see uh I have seen this video and I think although he is correct he wasn't really painting the whole picture correctly I take from his video that polymorphism and excessive single responsibility principle are slow and thus bad which is true in a way since with polymorphism uh there are costs for V table lookups and indirection and not to mention it will make the function and or data uh scattered around and not near each other so it will cause L1 and L2 CPU cache misses the big thing for me is that it doesn't just cause L1 and L2 cache misses when you got data all spread around just even like how clean code suggests doing it it also scattered around for my L1 and l2s you know what I mean like it's very hard to hold in your head these very clean architectures is that you end up having just so much functionality spread throughout the code that I personally find it is very very difficult for me personally to understand I don't have a very big L1 cache maybe I'm just too stupid for software engineering people always tell me that when I say learn to type fast because it will help you be able to be a better software engineer because you'll be able to explore more code I always get the same comment back which is you just aren't planning enough ahead anyone that tells you this just simply means that they're that they're not very good at software engineering maybe I'm not maybe I'm not a good software engineer me personally I just can't hold that much in my head I can never plan ahead very well every time I try to do clean code every time I try to extract stuff every time I try to abstract stuff I always end up regretting it in some way or another and it just ends up causing a refactor that's larger than the one that I initially started that I could have just started with and so it's just been one of these things where I'm really trying to uncomplicate my life and I've been doing so for quite a few years at this point that's not clean code fault of course it's clean code fault clean code has some restrictions and requirements for how you organize your items and I often find breaking those principles can make things really easy that's an L1 cache take okay maybe maybe I'm an L1 cache take I don't know extracting a function into multiple private helper functions may also cause cash misses so do inline functions unfortunately polymorphism is the heart of solid principle and one of the key principles of clean code I will say though that I do enjoy a good strategy pattern from time to time not gonna lie to him I'm a I like a good strategy pattern okay so do I always adhere to this no sometimes you know sometimes you gotta do this plus let's just be real here I often am programming in typescript at my job and you know this whole idea of dynamic versus status dispatch polymorphic all that that kind of goes out the window when you're programming JavaScript because it has to do everything crazy because that's JavaScript you know what I mean that's just JavaScript it's just crazy uh all right look at this really thinking on his computer look at all that thought performance is indeed important efficiency and performance are pretty crucial in performance critical software like games and embedded systems since no one would want to buy a 10 FPS game or a slow embedded device I would argue it's also critical on things like Twitter Twitter uh it's gotten a lot a lot lot better in the last few months but just yesterday using it on my phone I use the web app it just crashed the page crashes because it it just ends up using too much memory and then also starts slowing down you can start seeing the animation slow and eventually over a course of time it just crashes and explodes so I would argue that it's actually pretty important in a lot more cases than simply embedded devices maybe not nanosecond important or micro second important but memory usage and efficiency are still very very important they might also be important for backend uh back ends to uh to server content as fast as possible you gotta server that content boys uh and an inefficient app for instance will make your device slow and hot and consume more energy than it should for the back end it might also add to the cost of cores and and or memories and uh or additional services and you know you end up having to get a lot more machines a lot of stuff I'd reckon this will be something to think about in the future since startups can't really spend more than they should the operational cost would be smaller if you can make efficient code Fair take uh there are many ways to make your code perform it first choose the right algorithm this may be the easiest one choosing the right algorithm might be a difference in getting your code to run uh like the flash or Eeyore um so this is actually a really interesting one I would I would almost go with the opposite here which is reach for an array sooner than you are currently reaching for an array what you have a set of 20 items and you want to see are they included or not use an array don't use don't use a set right like there's like all these things that can end up happening that it's actually better to just use an array almost always like start there and then go from somewhere else I can even be like a dynamic array in the sense that yeah let's see yeah this is just a faster yeah um it's one of those funny things that people just don't realize is that often you use complicated data structures because the O of n is cheaper but the Practical reality is that your oven comes with a constant that's like ten thousand and so it's like yeah does that really matter when my other constant's 10 and it's N squared it doesn't really matter for like a long long long long long long long long long time oh yeah friendship ended with set you should love a race next we can uh we can get help from the hardware itself like using L1 and 2 uh caches or CPUs to make your code run faster again we're speaking a foreign language to javascripters uh L1 Cache can run a hundred times faster uh than your RAM and L2 can run 25 times faster but to do that we must know how the function and data are laid out in memory since you need them to be close to one another for a cache to take effect we can do this using data oriented design or entity component system patterns you can read this link if you want to I've always wanted to implement a little bit more ECS I did like a rough version of an ECS pattern in uh in JavaScript a while back and it was really cool and I'd like to do more of that you know what I mean it was kind of fun just learning about it we can also get help from the CPUs instruction uh or instruction set extensions like MMX SSE or AVX phrases and understand instructions never said once by JavaScript developers airplane all right but clean code is an is also important there are also paths to pursue that uh than pursuing only performance I have seen a lot of badly written and unreadable codes and most of them are from my time as a game developer as you know game developers are notorious for pursuing performance code because it means you can push for more content quality trisk count textures Etc to make the game look better without jeopardizing FPS okay that makes sense um but I believe that if your only concern is performance you may end up with buggy uh and product like the source engine in the infamous coconut jpeg I've always wanted to read this article the infamous coconut jpeg this is something I want to know about right why does this break when the coconut is gone why why is it God where did it go uh is probably the result of a violation of the separation of concerned single responsibility principle so if you change one part of the code it might affect another part that has nothing to do with it uh with the parts you are working on the same happens with me and Blackberry Messenger there is a class in BBM iOS called bb bb messenger what is what are we talking about we are forbidden to touch this class if not necessary if we do not if we do need to work on it thread carefully because it might break things BlackBerry still exists what is BlackBerry Messenger is this real Blackberry Boomer you know I'm a fan of blackberries I got a bush in my backyard but Blackberry Messenger I've never even heard of what is this uh they're a cyber security company now is their name cyberdyne uh performance code is not the easiest to read and maintain if any it's uh it's often the opposite try looking at the quake's fast inverse Square code to get the idea although not all code is that obscure uh I feel like this is kind of this is kind of an unfair thing to point out the fast inverse Square Biz that went on was an incredible hack to make video games even possible Right like you really couldn't do these 3D games with much Fidelity at all without like sucking out every last programming instruction of all time it uses float magic yeah then mantissa is getting abused in that one but it's just like that's kind of it's kind of like a silly thing to point out the world's most extravagant performance hack as a reason why you shouldn't do it for maintainability like you can write a lot of performance-based code without uh without going to this level uh and second off um it's not John Carmack that wrote this it's it's his teammate it's not John Romero it's not John Carmack it's the other guy I don't remember who the other guy is but it's the other guy can't go to the Moon because it's hard yeah clean coat and other modern programming principles are mostly concerned with development process rather than performance they are used to cut programming time rather than performance their goal is to make the code more readable testable robust extensible and maintainable sometimes most of the time at the cost of performance the reason is processor and memory are cheaper than development and maintenance time and so adding a pro a processor and memory is recommended to compensate for the lack of efficient clean code creates um I'm kind of on the fence about this one because I think you can still make good code I still think you can make maintainable code and you don't have to follow clean code I think people use this term clean code to literally mean code that looks easy to maintain those aren't the same thing right clean code is in of itself a specific methodology for setting up everything you reach for abstraction first you don't inline stuff right it is like there's like this whole set of things you have to do in the clean code world that is different than code in which is clean you can write pretty good performance code that isn't crazy right that really totally breaks down the whole the whole notion of clean code and I think that that's okay uh I've tried writing clean code can't understand the code base anymore yeah I mean for me personally for me personally I find that when I have a very clean Code system for me to understand the system takes significantly more amount of time and I can think of one that just uh just recently in my tenure at Netflix even when we were doing this image processing and image grabbing uh for all the different tests and different assets we're doing for our Originals uh there was an entire system we built that was all very very clean code principled in Java for the servers remember we use Java and I I real talk it it took me a long ass time even pick I learned those patterns I learned them and it was still super hard for me to maintain everything required to understand what was happening eventually obviously I got part of it down and I could do some things and I could edit some stuff but nonetheless it was extremely hard for me to to understand what was happening and at the end of the day it was all reaching for how to generate a URL but there was thousands of lines of abstraction and some of it needed some of it for the pure sake that it was Java because of just how Java was this was 1.7 days uh but then you know it goes from there skill issue yeah no it was full skill issue you can quote me on that one you could definitely you could definitely say that it was a skill skill issue how much uh lines of code was it it wasn't the lines of code that makes it hard it's the abstraction that makes it hard when everything's a strategy pattern when everything is behind a wall of some level of abstraction for you to get to the thing that actually is doing the work just requires two to three extra hops in your IDE so you go to each line of code and you have to jump okay this thing is this okay it comes from here but okay it's config is generated from this thing but that thing depends on okay it's actually an abstract Builder Factory so it okay that means oh and then you're like you're you're doing this jump where you're actually having to build build build now I understand what went into it rather than you know sometimes sometimes it's okay to just have a few things in line to avoid the sake of abstraction I do I like the idea that you should never really jump more than once or twice go to definition once you've done a two level go to definition jump I think you have inherently built something that's too complex do a poll on how many people actually read clean code yeah I think Uncle Bob has a lot of good takes I'm not I'm not I don't want to dunk on Uncle Bob I don't wanna I don't want to break or anything but he's uh you know recently been responding to a lot of my tweets okay I think we might become best friends at any moment uh do you actually clean code did you read the book uh let's see yes I read the book and like liked oh my goodness uh ambivalent dis no I know Reed good hot dog there you go and so for me the biggest problem with a clean coat always comes down to the same thing which is not about performance even for me it's about maintain maintainability I find it extremely hard to maintain once you reach a certain level uh ban everyone who doesn't agree with me please um I actually recently saw a tweet uh Theo said something nice to me and uh someone within the comments was just like you know primes gonna probably do this I don't even want to say what it exactly was but he said something effectively like that the moment he disagrees with me though I know he's gonna do it I'm gonna absolutely hate him you're just like damn whatever where's the option to start the book and never finished probably under the uh disliked thing uh how to answer the poll you're gonna have to figure that out all right clean code uh oh yeah the let's see hold on uh I have to say when I switched my career from game developer to mobile iOS mainly uh developer and kmk Labs video I got a pretty big shock because the Paradigm in the office was different so I've uh had a pretty hard time keeping up clean and maintainable obtainable as preferred over performance the game the development process uh speed is more than I uh than the end products uh but still is an acceptable value so I've got to learn about clean code solid clean architecture tdd model view view model extreme programming Etc agile kanban scrum manager what does scrum do who's scrub why is there a scrum guy why are we talking about rugby I don't get this agile uh the result is enormous though the development process is better it is arguably faster we've got fewer bugs the team members can hop in and do their work in a class without worrying that they might affect the other people's work the code is easy to read and the cognitive load on the brain is lighter we can extend features easily and we can test them all easily okay okay I mean there's a lot of questions I have here which I don't think you can answer easily which is I've been in code bases that are clean code that are extremely hard I've been in clean code code bases that are extremely easy uh both following the same principles uh both doing the same thing it's just that there comes certain problems which I think are arguably harder no matter what I've been in code bases that aren't nothing to do with clean code and it was simple to go through uh code bases that had nothing to do with clean code and they were impossible to go through I don't I I'm just not convinced any there's no correlation I don't think between maintainability and perfectly following clean code I don't think you can say that it's more maintainable I don't think you can say you can deliver features faster I just simply don't believe it uh being pragmatic and flexible is the key we must mind both the performance and the cleanliness of our code the code's cleanliness readability extensibility and robustness are more important than performance since most of our routines are not the resource intensive we can get away with some performance reduction and put in better structured code this works except if we consider the burden our code will cause on our users devices how will it drain the battery make it hot Etc uh but we must understand which part of our app needs performance it is usually the deepest layers of our apps awareness called hundreds and uh thousands and hundreds of thousands of millions of times yeah like react right I mean this is why I always harp on react react is just it is your core of your application and it's lacking in performance it's massive lacking in performance does weigh things down then we discard clean code for some performance enhancing methodology I don't even think you have to do that I think you can do things without doing uh without any of this so in a way uh other than clean code part right clean code as in the proper clean code Capital C clean code uh know the basics we do not need to understand what is happening inside the computer deeply we must know what is happening under the hood good enough to judge how to work around our code we also need to know the basics of our language and tools know your domain domain and software engineering commonly refers to the subject area on which the application is intended to imply duh uh by having a deep understanding of the domain we can understand what certain code is trying to tackle and then we can code it uh to better suit the domain's needs uh for instance in the domain of Hospital queuing app we don't need nanoseconds performance so it's better to reduce our development time instead it's different from a video game domain where we must render in real time but with that or but even with that some parts of the code need to do the opposite maybe real-time rendering of the queue number of for the hospital queuing app needs performance more and you know like all these things like I still don't necessarily buy it I I like K like again going back to Casey I what I really enjoy about Casey's take is that he does something called he called it non-pessimized code right where effectively what he's doing is instead of by the way thank you for the level four hype train okay I'm trying to read an article here I can't even like respond to this uh instead of always reaching for like say this extensibility whatever tool that you know this person's saying instead reaching for just not don't pessimize your code are you doing something that is completely ridiculous right are you doing something are you adding a bunch of abstraction are you doing all this for the the in case future result in which you may at some point in the future have to change the code that's probably not the best choice to make just write your code in a plain straightforward fashion do you know what I mean like if you do that you can you can you can avoid a huge amount of performance problems just writing it as simply as possible I like clean codes so much that is why I take my computer in the bath of me feels biscal I don't recommend for anybody else yes premature optimization is possible in both performance and abstraction and I think that's where the whole clean code thing gets its problem is that it it puts on a way you should approach things that is it just feels a little uh little impossible you know what I mean uh the problem with clean code is that the bucket term for people assigned to whatever they think is clean yes all meaning has been lost and the term uh gaslighting uh used for everything yes it's like the term gaslighting that's not actually used based off the movie Gaslight in which you're trying to drive somebody Crazy by telling them that reality isn't reality and constantly and slowly poking at them clean coats that sloths should be a toolkit not a religion well unfortunately this is programming since uh the large majority of programmers have forfeited traditional religion they instead have taken up the mantle of vimin Emax slash clean code and solid and wet ass code bases wet ass programming and so that's their new religion they need something to fight over and so this is what we've done it's pretty great it's pretty fantastic the Vim is in fact religion this is true uh my religion is Arch plus neov MC there you go I think it's unfair uh uh that chip uh Engineers work their asses off to fit billions of transistors onto a small piece of sand just for software Engineers to uh waste it you know for me this doesn't hit home you know what I mean I get what you're saying sorry emacs uh as the Lord intended uh Vim is not a religion Vim is the one true path and to suggest that others might be uh its peers is heresy there you go thank you Judo can you correct pick please all right I don't uh let's read let's read this thing right here uh do abstractions correctly with proper domain knowledge you can create a strategy for approaching the problem after that you have to do abstractions on the problem abstractions can Define as hiding complexity and unneeded information for given context and just make making what uh the ones more relevant abstraction uh in this case is not just abstraction as in object-oriented programming that is just one kind of abstraction variable types are abstractions they are abstracting the bits that constitute the actual value in memory naming a variable is an abstraction the abstraction it is abstracting an unknown variable into something more relevant to the current context of the variable operations and functions are abstractions of register instructions okay so this is the the idea of this um foreign this is like the world's most Bland take no no offense I mean this is like you just said a lot of words without actually saying anything um the pro okay do abstractions correctly I'm gonna say this don't abstract until you have a damn good reason to there you go abstract correctly I just gave it to you I just gave it to you you know what sit in a single file put 15 functions in that file do that until you kind of hit that point where you're feeling I'm a little frustrated with my code right there's like this thing that ends up happening and you can feel it you know when it's happening and that's a good time to rethink you know what I mean you got to give it a little bit of time you gotta let it cook that's right you let it cook a little bit hey I just copy and pasted the function changed some bits I'm gonna let that sit for a second because you know we're just starting out we're just exploring I don't like that but let it cook so I'm gonna go for a little bit I'm gonna go for a little bit I'm gonna kind of experience things and then once all of a sudden at some point you're gonna go okay here's the actual problem the actual problem isn't those two functions it's the actual problem's way over here I'm gonna go fix over here because now I understand the abstraction and then you can move on just don't abstract too quickly wait for a damn good reason to a real real good reason to uh let's see be pragmatic at the end of the day programming aims to deliver a solution to the users in the form of an app most certainly we need to deliver what the user wants out of our apps or games maybe they want performance game with more than 100 FPS or maybe they want an app with lots of features reliable reliable less buggy and deliver ASAP uh we should be Pro pragmatic with the tools that we have because users don't care how we do our job you know the saying with a hammer and nails yeah don't do that so what you're suggesting is a hammer nail approach to the hammer and nails avoidance um again I'm not really getting anything out of this one you know what I mean there's the I think that even the most Ardent person that thinks that things should be pretty much done one way even in their own little subsection still is pragmatic about the various things they take you know what I mean and so this whole like idea of being pragmatic there's like a level you know people aren't avoiding pragmatism because they think because they're like I'm an art and supporter of only this way but they think that the other way almost always is an incorrect way of doing things and it will cause more headaches it's almost never an argument of pragmatism it's always an argument of familiarity or ability to kind of deal with a certain type of ecosystem um okay cool I've had uh abstraction of the Degen Community thank you I I might be the abstraction I might be more of like the extraction of the Degen Community um write everything in basic hell yeah um I think that uh clean code is just not needed uh at least that type of thing but here's the deal I'm gonna give I'm gonna give a weird take at the end of this if your entire team is doing clean code and all about it learn to do clean code if your entire team wants nothing to do with clean code don't do cling code yeah uh clean code is not needed but solid principle is good yeah in general uh in general solid principles are good like you got to know you got you should mostly do that you should you should try to make sure that you separate out you know you just do a couple little things and it's pretty good um I like it I I generally just program that way it's better to just do what is currently being done then do what you feel is the best that's usually my take on CL on working with a team is when I work with the team I just follow whatever they do right well it doesn't matter what they do I just follow that you know what I mean and if something is particularly egregious I might try to refactor it and give it a shot see what people think I usually talk to people though normally because the thing is when you start refactoring something you don't realize why it is right so you have to talk to people and I'll ask hey can I refactor this part and often people be like oh yeah it's terrible or well be careful because there's actually a lot of thorns in there and you'll probably end up at the same conclusion I've done that and I've ended up at the same conclusion you know what I mean I've been there I've been there I've done that uh talk to the team yeah exactly set aside time to do that it's just it's just better okay hey you know what the name is I don't do clean code uh but I think Uncle Bob is he's probably a pretty good guy and solid is pretty nice you know what I mean