get to see that many people early in the morning on the further the conference actually that's felt great so we'll talk about kind of standard C plus plus tool set whatever it means I mean like uh that's a little bit maybe a tricky title because I personally do not believe we have a standard C plus plus toolset but we'll try to find out if we have something at least close to it so uh we're gonna talk about different aspects of the tools today and like what we have and what are the trends so for those who don't know me so my name is Anastasia kazakova so I work for jab brains before jailbrains I spent eight years in like CNC plus development for embedded systems we're mostly doing like Telecom networking devices we were doing the policy controller for 4G LTE networks so all kind of you know funny stuff when you launch the 4G network for the first time in the country that was fun but then I moved to their brains I mostly do not I don't do like C plus plus in production code and working as a product marketing manager but with my C plus plus background just try and help the team and do our best for C plus plus developers and you can find me on Twitter and I'm always ready to answer any questions you have around the tools or just like talks or whatever um so let's try and figure out what is actually the tool set at least like how I do understand it I'll try to explain it right now so for me the tool set actually that's all the tools we have for the language like literally everything however you can split them into essential tools and as I call them complementary tools essential tools are the tools without which you actually can develop because you can't do any civil plus development without a compiler because you actually need to compile the code yeah and like to then to run it so standard library is also essential to me you kind of can and try deal without it I mean like game developers used to use their own standard Library that's fine it has this experience but usually you kind of need at least something from the standard Library so I do count standard Library as an essential tooling here um project model and build systems again it's like you might deal with just compilation flags and just compile your code but it's much easier especially if you have a huge project to deal with like project model or some build system at least something just so you just don't write all your compilation Flags in the command line for the huge projects um dependency manager again I do count it as an essential even though if that means for you just put your library into the project so you at least doing some dependency manager so you're finding the proper package with the proper version put it maybe into your source code compile it with the whole source code that's also kind of dependency manager maybe not the best way to deal with it but still and like yeah the debugger here again so you might be debugging with like printing some variable values that's also like debugging techniques there's also something you use and like the language might help you and the tool set might help you with some like maybe Standalone debugger but that's still essential tooling analyzer is like complementary tools so you literally don't need it if you just build the code and run it so or debug it it's better if you have it and you like running the code checks and you like trying to figure out if you may be running into some potential issues and all that like the other stuff like unit testing framework and all the other tools they're very very important but I also count them as complementary that doesn't mean that you don't need them but just you can survive without them on the first stage but later you still might need them let's briefly see how the other languages are doing so just a brief overview across like maybe a couple of languages so Java uh it has actually I would say one Kampala like chavak is uh either you take it from the like Oracle official runtime or GDK doesn't matter the compiler is literally the same they were uh like there are actually a few more compilers for Jello they are not that popular the most popular one probably is the eclipse compiler for Java and I wanted to mention it here because it's very specific it was especially created for the ID needs so it's quite close to my heart I kind of understand what they were trying to achieve there because the biggest features of this uh ECG compiler were probably that they can run the code which has some blocks which doesn't compile so it's fine uh so and also it can do the incremental builds and since it was actually created for the ID for Eclipse so uh by the time you finish writing the code it will be already compiled so that was kinda uh compiler close to the language engine uh in the ID so it's close how the regular language engines are working inside the IDS so it's a little bit different from the regular compiler philosophy but kind of uh close to yeah to ID needs so that was done by Clips I guessed it kind of abandoned it so it still exists but they're not like putting too much efforts indeed so Java class library is Rich and like usually when the people feel Envy in C plus plus they usually feel Envy towards you know Java because they have this huge library and they can literally get anything out of it um in terms of uh build systems and project models so they still have several like um and is kinda more or less abundant so I'm I it's like used by a small portion of Java developers like Maven and Gradle are the top two probably and Maven is kind of more popular but still Bridle has its audience so the numbers are quite different like 20 percent came from our Japanese developer ecosystem and 49 came from J Rebel survey I guess both are biased so the truth is somewhere in between so I put it just through the dash um yeah and J unit is just like if you need to do the tests with Java like some basic tasks you just take the G Unit um Ruby it's a little bit tricky because like it doesn't need a compiler kind it's an interpreter so it's a different philosophy uh they have like several of them uh and they have because that's like you can do an interpreter you can do jit and you can do some other techniques here there are several implementations so MRI is the original implementation for Ruby internal from the like Ruby offer it's also called C Ruby uh yarv is like yet another Ruby VM I guess that's something which the Ruby offer is right now developing so it's some new thing like J Ruby for gvm Rubinos based on lvm like iron ruby4.net so there were several implementations uh interesting fact I don't know how many of you know what's the real Singularity means for Ruby anyone here no okay so um you've probably heard that there is this Ruby on Rails framework it's very popular I mean like it's used by 86 or something like that percent of the Ruby developers and it's very complex it has some it uses some Ruby specific features quite many of them and it's actually hard to compile it properly and so Ruby like real Singularity for Ruby means so if you can compile Ruby on Rails then like your compiler is good enough and as far as I know they're just not that many compilers that pass pass the test it's just MRI and yarf and also I guess like J Ruby and Rubinos so the others are kind of good but they are not passing the real Singularity so Ruby developers they just don't take them seriously if the compiler doesn't pass that they don't need it um anyway like uh they have a fantastic package management approach so they have Ruby games they have bundler which I guess it was a third party tool but it's somehow now the official part of the ecosystem and it's used like by 90 of the Ruby developers um and yeah I respect for tests they also have some other Frameworks uh but that just depends on the Frameworks and specific areas you are using the Ruby at uh Swift uh it's fantastic example from Apple I mean like apple just maintains everything I mean like they have the Swift tool chain you just get it from Apple uh you have the Swift compiler it's like lvm based but you'd better take it like from this Swift to chain and the same story with actual ldb so you uh can't use just a regular ledb you have to take the Swift tool chain take the compiler from it take the debugger from it and everything just working like a charm for you they have Source kit which is like an language server protocol and there are lots of analyzers and the source kit is like also providing some code analysis and you can build some tooling on top of it there is this approach for Suite when you can actually not just debug your code but you can like play around it with the playgrounds or redevelop print Loop approach when you just you know it's kind of like an interpreter so you play with the code and it's got interpreted and you see the result um Swift package manager SPM was specifically created for Swift cacao Bots are still popular but the main reason I guess is that they were the top package manager for objective c Objective C plus plus and the people just keep using it for a swift but I see the trend that the Swift developers who came from Objective C background and who are using cucopos they are kind of migrating to SPM because SPM is official so everyone were expected actually that when the Swift were was announced everyone I guess was expecting Apple to buy the company behind the cocoa pots and just you know get it official but surprisingly they didn't do that so they maintained their SPM and so now there are two but I guess SPM will kind of win in the future unfortunately cacao Parts is actually quite nice and like your exitus is just the main framework and the example which is closer to like our house as C plus plus developers and which I think is a perfect example here because to me raste echo system in terms of the tool set is kind of Ideal I mean you have Rusty compiler that's it that's just one compiler you have cargo which is a build system and also a package manager I mean like it does incredible job for you so it downloads compiles distributes uploads all the packages so you don't have actually to care about anything so it takes the packages from the official red like registry it like compiles everything in your project so you just say like I need this package of like this version um raster from T are very popular for matter they also have kind of standard rust analyzer that's again the LSP thing like the language server protocol uh based analyzer um interesting fact that due to our surveys like 60 of the rust developers they do debug via the printing function or via the special debug macro which rust has so they kinda also has the proper they have the proper Standalone debugger but they mostly not using it and yeah the the for tasks they just enable the special model for a cargo and just use it so this ecosystem is very very simple and straightforward and in terms of the C plus plus tool set so you you might feel about rust differently but the tool set is actually ideal I mean like they have everything very very standard very open to everyone so it's not like first for Swift it's also standard but it's maintained by Apple and you like never know how it goes and it's just their decision for us it's more like open to the community but still standard which is good um why at all the standard two set matters actually to start quicker with the language because when the when like someone who is coming to the language or to the project you just enable everything you set the development environment easily like maybe it's a Docker container or some other way to distribute the standard environment you just enable everything and the person is just using some standard thing he or she got used to so there are no like questions if this compiler working differently or how to work with this build system I've never worked with it so standard tool set kind of makes the things easier it helps with some like unifications and like indeed makes the onboarding much easier and also it helps with adoption of the good practices because when you have a standard unit testing framework or maybe even a couple but they are kind of standard you know how to use them through like some official package managers with some like um build system which everyone around you like is using then it's easier for you to start because if to start with the unit tests you need to you know spend couple of hours digging through the whole internet trying to find a proper unit testing framework then for a couple of hours trying to learn how to enable it big chances somewhere in the middle you will just say okay I don't need unit tests at all um so standard two set indeed makes the life a little bit easier and like kind of increases the chances that you'll be using like good tooling and good practices it doesn't mean that it has to be just one tool for everything no but you just need to have kind of standard tool set even if there are like several tools for the purposes so um yeah and if you don't have you have like some conflicts and inconsistencies which uh like makes your life harder and you probably don't want that from the tool set uh let's talk about some interesting thing here about like some uh things not directly related to maybe the tool set as like compiler debugger build system but some other types of inconsistencies you might run into C plus plus and uh if you don't have a standard approach here you also might run into trouble or at least you need some tools which will help you and this is like the syntax style and um I like this thing about C plus plus actually that we can do things in different ways so that we have many opportunities to express ourselves but sometimes the issue is that expressing ourselves in different ways inside one project inside why one team makes the things difficult for our colleagues and the typical examples is the syntax style and C plus plus where we have different approaches to writing the code like just four examples here like almost always out approach when you try to put you know outer specifier almost everywhere or like the opposite Camp which says that like yeah when the type is evident we have to put the outer uh and not in other cases or don't do that for numeric types so this is just the uh several ways of using the outer across your code then also yeah this is like kind of very known like West Coast vs East Coast you probably have heard about it so that's about the way where to place con specifier before or after the type it applies to so also two different ways of writing const uh trailing return type approach is interesting because trillion return type appeared like mostly for expressing the type for lambdas but then some people say like maybe you have to use it everywhere I mean and we have to convert our like regular return type into the trailing return type for the function and there are people who say in the like no we have to use it only like for these cases where we can't live without it or we have to use it everywhere and yeah sometimes it even comes to different styles used in different areas like an example is that simple plus core guidelines they say that when you override a function you have to put either override or like final and you don't have to put virtual and Unreal Engine guiding standard like which is used by Unreal Engine game engine they explicitly say that our virtual has to be put explicitly well you don't need it but like the guidelines say that you have to do that and it's interesting because they're a completely conflicting with the core guidelines here uh so anyway like uh when we decided to support all these syntax style rules the actually the list of settings is twice longer it just doesn't fits the uh to the slide I mean I just wanted to show you that we have many many things in the syntax style which we can do differently so and in terms of the standard tool set you need to have like in this case it's mostly the analyzer which we'll be checking these rules for you um if you want some standard approach across the whole code base because like if someone is using these rules differently in the same code base is probably not good um so yeah for that you kind of need some tool which will be applying the standard approach and so like doing the things like um like yeah for example converting the trailing to the trailing return type for you automatically Maybe um like another thing here about the package management struggle I think like we all know about it but just to show you some statistics so that came from uh developer ecosystem survey by chair brains from 2021 so when we ask people uh how do they manage different party libraries in C plus uh you can find kind of see that like one fourth of the developers they just have the library source code as part of their build so like and I guess the package managers are these numbers in the bottom I mean like VC package and Conan and whatever the people use like some nougats some build to approach but like most of the people they just rely on a system package manager or just try to download some pre-built libraries or just like yeah compile the libraries through their instructions okay so C plus plus where we actually now with the tool set let's try to figure out I have to say that for the C plus two set to explain it I really like this slide from Bryce talk from C plus now uh where he was showing like the he was talking about this standard Library so again some kind of a standard tool set here is the standard library and what actually belongs to it and he was talking about the universality of the language and how C plus plus is used in different areas and he the language has to adopt to all these platforms all these paradigms and all these like types of problems the users are solving so for that for sure we probably can't just have one you know standard set of tools like one standard compiler one star build system I don't think it's possible because we are solving different types of problems so in that sense for example rust is mostly used for like some small utilities or some specific like types of applications so it's not used like for this variety of applications so maybe for us it's okay to have these standard tool set but for C plus plus I don't think we'll be able to unify to that extent and probably we don't need that um interestingly back in 20 uh 2015 so when we were starting our C plus plus tool said jab brains we were kind of young and naive but we were trying to make the tools right so we started tools creation from the survey so we actually were trying to do some research on what is the standard tool set people are using because we needed it for prioritization so we needed to start with something in the tool and we saw the whole variety of like build system compilers debuggers and we say we said okay like we we will do the survey we will do the research we're trying to we'll try to figure out like the popular set of like compiler build tool and debugger and we'll start with it and then the others will come later and so at that time for us the winner was like GCC cmake and GDB it's like changed quite um quite fast after we started the tools like Clank started to grow significantly but like yeah at that time so for for sure like on Mac the set was different it was clunk on Mac for sure so we started doing Clank at the same time as GCC support so that was fine for us but generally yeah it was interesting to interested in experience to figure out what is the standard tool set um okay so since I started talking about the compilers um actually in C plus plus we have quite many compilers and that's not all of them here so uh maybe just to name you know the the biggest names so obviously we have like Clank GCC and amazing and also Intel compiler which now exists like in two versions like Intel old compiler and Intel based on lvm so it's kinda Clank but with Intel optimizations um so they migrated quite recently to lvm architecture uh like to lvm uh back end for the compiler so they have their reasons for that uh partially because they see how lvm evolves in terms of the new language feature support and they just probably don't want to support everything from scratch inside Intel compiler but just want to do the specific optimizations and of course there is a huge pack of the embedded compilers compilers for embedded development I'm just you know naming here like kale and IR which are like probably the two big compilers in this area but there are many many compilers there like GCC based compilers and some specific compilers from the vendors there are lots of them like I came from the embedded area and I know like how different these compilers could be and sometimes there are not compatible with like the compilers we know in general like GCC or Clank okay so but what uh do developers actually use so these this is actually quite new statistic this is coming from 2022 survey we haven't published the results yet they will be coming somehow in maybe a month or so but I already took the numbers from it so these are the numbers from this year so and uh in terms of the compiler it's not a surprise that GCC is winning because there are many people who are like using GCC based compiler especially in like embedded so they're like selecting GCC here Clank and Clank CL uh this year we actually put it as a separate compiler because we had many questions before if I should select Clank or msvc if I'm using Clank CL and that's a good question actually so I decided just to put it as a separate option um in like and Intel is also split into two and you can see that Intel lvm is actually adoption is growing quite fast I mean like I would expect that they will be much bigger next year and the regular Intel will probably fall down because Intel themselves they encourage people to migrate to the new compiler uh and yeah some like more specific compilers for microcontrollers I just aggregated all of them here to this seven percent and some custom compilers uh whatever it means to three percent interestingly like the story with the compilers in C plus is that we have different defaults on different like operation systems like obviously on Linux you are more about GCC on Mac OS you kind of used to Clank but like apple clunk is not regular clunk I mean like it's completely different it's usually like way behind the uh Clank you can just download and build on your machine and it has like some apple stuff in it but that's at least the compiler you get with your like operation system with xcode with xcode build tools you just have it uh so you don't need to install anything specifically and I don't think there is like a default for Windows I mean like Microsoft compiler is kind of default but you need first to install it so it's not coming with the Windows installation for you and there are other options for Windows but like they they are not that nicely working like I mean uh mingw and C green is usually a pain if you're trying to configure them like not just compile a simple hello world but just do some regular stuff I mean have some libraries you always struggle if that's the case like Clank cell yeah is mostly popular if you would like to use Clank on Windows it's now at accessible to use Clank from just lvm on Windows without like big issues with libraries and windows age and whatever but it's still a pain to configure it properly actually you need to use some MCS libraries and the stuff um yeah so and I have to say that if you take Game Dev area for example the Microsoft compiler will be dominating the market like it's used across the whole Game Dev so all game deaf engines are relying on Ms built they are doing their work with Microsoft's compiler and it was easily you can't easily compile with Clank because you will have the console SDK which is not like compatible with Clank for example it's quite often is compatible just with msvc so just no one in the Game Dev will be trying that I mean like there are a few attempts like Unreal Engine actually announce that you can compile with Clank on Windows because you can actually use Clank on other platforms so why not try and compile on Windows but that's a pain I mean in terms of the libraries okay um a few other things about how the compilers are different the easy thing is the compiler options and like while GCC and Clank there are very similar in terms of options like Microsoft compiler is completely different an easy thing if you try to enable the all the extra you do that differently for Microsoft compiler and GCC and Clan compiler so if you know how to do that for one compiler that doesn't mean that you know how to do that for other and that's usually a pain for people I mean like unification of the options kind of help uh because like if you know how the options work for one Kampala then you probably can just apply your knowledge to another compiler um in terms of these C plus plus standards support the story is even more interesting because like for a very very long time adoption in Clank were just uh pleasantly fast for the new features but with C plus 20 somehow Microsoft is ahead of others right now so it's literally nearly got everything in this table just few features left while GCC Clank are still behind and that happened I guess mostly with C plus 20 so I haven't observed this big Trend before that Microsoft is actually doing a great work of adopting DC plus 20. and uh yeah I guess probably just because they really need it I mean like when you really need something and you're maintaining the compiler probably you can yeah boost the development and the client and GCC kind of behind hopefully they they will catch up so there are more or less doing that but still but uh think about the Clank is actually it's not just a compiler so compared to like if you take GCC or if you take mspc Clank is actually a whole ecosystem of lvm which is used in other tools in many ways like there is lip Clank and Clank D and this language server protocol which is used Often by vendors Like Us in Ides when we maintain some other tooling based on this clang D because it actually provides you a nice AST like syntax tree from which you can you can navigate through it and do some maybe changes like refactorings or something based on it so it's nice provider and a nice language engine and it's often used these days I mean like uh nearly all modern C plus plus IDs except uh like Visual Studio I use an uh Clank Clank D actually now to some extent maybe not as the main language engine but at least as a complementary language engine like we do that for C line uh in resharper we're only using like Clank tidy not as a language engine but just as analyzer but literally everyone like does that because it's easier to maintain like the community maintains the language engine kinda for you because they bring the new features for you and you just have to do your work on top clang analyzer and Clank tidy are kind of the most popular tools for analyzing the C plus plus code I also like part of this ecosystem like Clank format um like IDs as I told you before so yeah everything that actually needs the EST they are using the Clank ecosystem right now and these infrastructure and that's good so yeah Clank is kind of a basis for the rest of the C plus tools so it's not just a compiler okay so what's going on with the build systems let's take a look kind of an obvious picture right now uh it was not like that seven years ago like cmake was very very close uh to like Amazon build and make files but right now it's used by the majority of the C plus developers there are still people who are only using others like again Game Dev is targeted on like Windows echo system so it's about Amazon's built like and like Microsoft compiler embedded developers are more about make files and like outer tools so they started using uh C make but it's not uh like the top tool for them right now um the others like are kind of like in behind basil has its like audience mostly driven by like Google uh Mason also has some audience and like some others um so yeah and if you see how it all evolved Through The Years you can see a huge boost for cmake which happened at some point of time so these uh here I just collected the developer ecosystem results from 2017 to 2022 which we like maintain for all these years and how it all changed and you can actually notice that in the beginning in 2017 Amaze built was the top uh project model build system for C plus plus but then the simple the cmake has started growing blazingly fast and it's now like a top and uh I wanted just to quote price from the same talk from C plus plus now when he was talking about the standard Library so like you want a standard simplest build system you got one it's called cmic you may like it or dislike but it's it's kind of standard so we still have others for different cases it might be uh bigger usage like in Game Dev but it's kind of standard and if we talk about the cmake adoption and how it's actually adopted across like different tools I see now that there are more libraries coming to simex so quite often if you find an open source library on GitHub quite likely uh there will be some cimic in there so you can kind of try and maintain it and use it via the cmake package managers are also like good friends of cmake like both Conan and VC package are IDs are now supporting cmic I guess all of them I mean like Microsoft edits cmake support and actually evolves it a lot so it's like uh I mean like it's not like I must built in Visual Studio but it's like a good quality of support for cmic and all the others like we started our Ides like we started c-line from scratch on Cemex so it's like the First Citizens um and like others also have support for CMA Cloud uh cute actually migrated in q6 from qmake to cmake that was a big move for them so they kind of abandoned a q make and moved to cmake embedded developers surprisingly finally moving to cmake as well like they were mostly about make files and outer tools but you can um notice right now this trend like uh The Zephyr erthos so airtos this like open source real-time operating systems uh so it's on cmake Nordic semiconductor who are providing these NRF microcontrollers they're very popular for for example if you use the Bluetooth mouse quite often that's a Nordic semiconductor microcontroller inside so uh they actually migrated the whole SDK to cmake so that that was a huge move for them a couple of years ago uh boost even had some you know cmake effort didn't make it so they kind of abandoned the effort but at least they tried I mean like good try um cmake file API was actually a huge move for simc because that gave an opportunity for every tool vendor to work properly with cmic because before that when you were working with cmic you had to actually run the whole cimic and like you know pass the output but CMC file API is actually this black box which tells you all the information about the project and like for example if you integrate in cmake into your ID you just communicate with cmake via the cmake file API and that's much better much easier and like you have just less errors because you are doing the proper API calls not parsing some you know creepy output and simic presets were actually a huge milestone for cemek which I do hope will like just give another booster to make even more because the presets actually if you don't know that's a way to configure your cmake in some standard way which you can share with your colleagues so you just have these presets files and you just describe what tool chain you are using there so how you like all this configuration and build uh steps in the cmake are done and you can just share these files into repository there are like two types of files the types of files you can share in the repository and then your local files so you still can do some customizations for your local case the presets were driven by Microsoft again a lot there was a huge collaboration between Microsoft and kitware and uh presets were released in like I guess more than a year ago already so maybe a couple of years already um and they evolve somehow they're still young I mean they still break the compatibility with every new version of the presets so it's hard to you know kind of migrate from one preset version to another I guess it's four or five already the fifth version of the preset I guess is the the latest one right now but I might be wrong uh so yeah but it's it's the easy way to have the configurable builds which you can share across the team so it's a good way to configure and uh but cmake is a language uh sorry saying this for the record but it's crap I mean like as a language it's really hard uh it's good for quizzes literally and I remember the Fantastic talk from Mateos and you probably noticed CPP now is one of my favorite conferences I like a lot of talks from it but materials from ipam he was doing a talk several years ago at the online version of CPP now uh it was called like C make and Conan three years later and first part of the talk he dedicated to the quiz and I have to blame myself I try to do that but I failed completely I mean like he was asking questions about like if you set this variable to this value and then you do like uh if class operator with this value what would be the result I mean like to realize that in a language you have like ignore not found and off values working as false that's a hard language but like if you cook a try then it gives you the power but it's like in terms of the language it's not easy and if uh to confirm that it's not easy I have to say that in C line recently we actually released a cmake debugger just imagine you have a build system for which you need a debugger to write a proper build system code but the people actually need it it's one of the most popular feature of the recent release we're now doing because the people say oh we now have a debugger we can just debug the Simi code like see the values of the variables like all the targets environment variables and we also like inline in some values in the editor and now it's much easier to understand what's going on in my CMA code like yeah it's a good helper but like yeah we need a debugger for the build system it's hard and okay um another story I like can't avoid here is cmake and modulus because uh C plus plus 20 model is great feature but to adopt it we need the tools and I see some kind of for disappointment in the community because when we first ask the people in developer ecosystem survey couple of years ago when just the standard was released uh which big features of this plus 20 you're gonna use quite soon like in the next six months the majority was select and modulus so there was a huge excitement and now when we ask them like concepts are kind of trending because the people are okay we'll wait for tools because they realize that they can't use modulus it's a great feature but they don't have any tooling um but some people do the the the great work here so um like uh compilers actually started implementing models but that was not enough because the people were like okay I have to put some shitty compiler Flags how to do that properly it doesn't work for me reliably and it differs from one compiler to another compiler so they were kind of waiting for the build system to support it it was the build to first I guess which kind of they announced that they have some support and they have some working example but I don't think that many people are using build too uh but when cmake said that yeah they're doing some job towards modulus that was a bigger excitement and with together with Microsoft they finally released this kind of approach when you can use cmic plus Visual Studio generator and then you can kind of build modulus but it's a little bit tricky way because you just build them as a regular C plus plus files you don't get what's going on with these models because you're just trying to build models files with your regular source files and then some magic happens inside so probably not a very straightforward way if you want to understand how you build your models and what what you are actually doing there okay let's take compiler flux so we actually this is a working example it works with Clank for us I've failed actually to make a working example with GCC to be honest with you I followed all the instructions how to build models with GCC compiler flux at least on Mac and I felt it doesn't work for me maybe I'm doing something wrong so but for Clank that kind of works so like you just put all kind of creepy flags and you kind of build a model and then you get like everything there is like not a very big c make that's just one function out of it but you can do that there are some issues I mean like I recently ran into issue with the clan compiler when I was building model modulus on my Mac and then I updated the Mac OS and it got some like uh new Target architecture um when building the modulus I removed the whole build director where everything was built I mean like literally cleaned everything just you know delete it and was trying to rebuild it from scratch and I still got some conflicts of the architectures between the models and my source files I don't know why it looks like Clank was just saving some information somewhere outside of my project I have no idea where so I just put the proper architecture as a Kampala flag and forced it to rebuild the model with this architecture but that looks like a bug to me in the it was like Clank 15. so hopefully they will address it but at least you can do that and even better cmic just released free 25 uh like literally this week the release candidate was just a couple of weeks ago and they released it with like quite silently at the stage of release candidate They just added some modular support there it was not in the release notes we just noticed that there were some examples which appeared on the Cemex side and then in the release they finally announced it so these are the working example actually from cmake we made it work so we made it like work on I guess at least Windows maybe Mac as well I don't remember maybe not all the platforms but yeah it's kind of working they have more examples in the repository so you can actually now build models for cmic you can notice this creepy file set variable and I do not understand there like approach but they just put all models file into some variable they called file set and that's where you have the models I don't know where the naming is coming from while file set and we were very much surprised because they didn't propagate this variable to the cmake file API in 325 they fixed it for 326 so I we don't get this information in like ID for example from the cmake file API with 325 but like yeah it seems they're doing some work around it so maybe it's not the best attempt from them but like it works um okay um now like coming from the build system to the dependency managers because they're kind of close uh this is like similar data I was showing before but I will just add some uh historical data here uh like not the historical but the sorry the areas splits because I wanted to show you what is the situation in the embedded because this is the area where uh which kind of shows like the blue is the overall data and the green is the data from the embedded developers and you can see that there are even less using the uh some like standard two not the standard tools but like some tools like VC package or Conan so they're more like compiling all the things as part of their builds and they have lots of libraries and many of them are distributed by the vendor so I guess you can actually try and put this into the package manager from the vendor because the libraries are kind of provided by the vendor and they're more or less standard at least um as a some specific version so it's interesting to me if they actually move because I think if embedded tries to do that and tries to move to package management I guess that will drive the package management for others as well because like yeah these people if they move to something new that's a huge step um about a little bit more about the other tools I have to say here so clunk format and it's literally the standard formatting tools right now so if you find any repository on GitHub quite often you have the Clank format config file in it so you just download the repository you run Clank format and you get the same formatting as the offer of the repository on the team behind it uh we're having in mind and that's good actually so that you can have this tender formatting uh there are some interesting things about the Clank format that while it is the part of the lvm ecosystem it still has this fuzzy parser so to have the performance benefits they're kind of not using the proper parsing like the Clank compiler so and sometimes some people can notice the differences I mean like you compile the things in one way but then you understand the Clank format treats it differently and the people even got used to it and now if you like if in our two sometimes we do not call the Clank format directly but just mimic it so like map in the the config file and then call calling our own formatter with the same settings and we realized that we are doing the things differently and the people say like oh no the Clank forward behaves differently so you have to behave like the Clank format they were like okay we're just trying to behave like a normal compiler who just bars the code correctly but probably we have to fix that for you because you got used to how the Clank firmer does that um and also like the big issue with the Clank format is that they are breaking compatibility between versions and that even comes quite often come to the situation when they have the parameter for example which had in the config file values like yes or no and then it was converted to some enum value next version so your config file is completely broken so you have to use the proper version of the client format for which this config file was created because otherwise quite often you are running tissues and I know many companies who are saying to us like uh yeah we're using the specific version of the Clank format where I stick to it because otherwise we have issues with the compatibility um okay like my favorite topic is code analysis um I like it a lot and uh this is also the data from this year the question we ask is what kind of the code analysis tools and guideline enforcement you are using and like the majority of the people are using either none which is set or the ID built in which is good because the IDS can now do a good job for you and they have lots of tools built in so you just rely on what the tools provide to you that's fine I mean like Visual Studio or our tools we have lots of code analysis tooling built in so you can just rely on it and like yeah no surprise that the lvm ecosystem is dominating for the rest like Clank tidy Clank format which people still consider like a code analysis while it's not clang analyzer and then comes the rest I actually cut those analyzers which have like less than three percent but there are quite many of them as well like there are more coming here um okay so um talking about the code analysis like indeed the client ID is kind of Baseline so many many people are using Clank tidy it's integrated in many tools uh you can now even maybe you don't know that you're using Clank tidy but you're using it I mean like if it's integrating into your IDE you might have noticed that there are some checks but you maybe even don't know if they're coming from Clank tidy or some other analyzer you just have them that's good uh they they have like lots of checks like modernized checks or query guidelines checks or some specific checks like submitted to Google and the good thing about the Clank type is that you can actually do some custom check which is great I mean like you can write your custom check in your company and then build the custom binary of your Clank tidy with your custom check put it to like some tooling storage you have and like run this Clank tidy on your like Ci or a developer's machine every time and have your specific chat this is great so this is a good thing um also like in the modern tooling with the code analysis you can now have the great uh like a lot of information coming out of the data flow analysis more more and more tools are now trying to integrate data flow analysis so we started in our tools like in C line several years ago I know others who are doing the data flow analysis so and it's literally the code analysis which goes beyond the compiler uh like abilities because it analyzes the possible values and how they flow through the code so you can do that inside the function scope or you can do that inside the translation unit scope like uh in C line we are doing uh like local as function scope or Global as translation unit scope but there is even a like proof of concept how to do this cross-translation unit analysis there is a checker from Ericsson which they presented at some of the lvm meetings long time ago and there is like some description how to do that in clang so it's not like widely used by any known code analyzer but at least there is a proof of concept that you can do that cross-translation unit but usually yeah it's mostly in the scope of the translation unit and you can actually check and look for many things here so the DFA so it actually takes into account like the function parameters and arguments the return values The Filling Global various and it actually outputs the value ranges for the variables and later you can do this assumptions like you possibly have like a dangling pointer well there are issues with lifetimes or the indexes out of scope or there is an unreachable code or endless loop or endless recursion whatever so you can do this Chucks on top of this knowledge foreign also in terms of code analysis so like there are lots of uh for C plus plus and like C there's lots of analyzers uh for which are the main specific and that's good because like if you're working with cute for example you have crazy which not just takes the general C plus plus code but it understands all these signals the cudas so and you are doing the checks based on this like matter information about what it actually is all I can Unreal Engine there is a real header tool which understands this uh macro system which Unreal Engine is using for reflection because yeah we still don't have a reflection in the language so all the game engines are just struggling and using some some implementation so Unreal Engine uses macros and they have this specific analyzer which is kind of using this meta information about what this macros are what they have to have and just provide you some maybe possible warnings and there are lots of analyzers specific to embed it I mean like there are lots of checkers and of course like we are actually good at doing code analysis because we have like some tools on CI like there is a very popular tools from sonar Source um so we also started doing a job brains also some tools like kadana which is also called analysis on CI and that's actually a different type of the workflow so it's not just like you're working as a developer with your code and you would like to run some checks probably you don't need to run them on CI unless they're uh like platform specific and you can do that on the local machine or they're just quite greedy in terms of resources or time and then you probably need to run them on CI but quite often CI checks are just the health check for the whole project so like you have the projects and there you have the constant code analysis running like maybe daily or once per week on the CI and someone in the team uh I would say like some manager I mean like Tech lead or someone so it's checking how the project is doing so what what's happening there so this kind of management and health check tool and it's good for open source projects like if everyone is just contributing to it and you have some constant CI configured so you run the code analysis just to make sure that the project is doing good and so these tools which work with code analysis on CI quite often they help annotating like the pull requests and like helping you to to do the things or like do some code reviews for them and actually uh I talk a lot about it in a different talk so you can take a look at my talk from simpleplus now and I guess sooner will be the recording of the new version from NDC Tech town where I have the whole talk dedicated to code analysis in modern C plus so I don't want to spend more time on this right now and maybe just a few slides I would like to discuss in the end is about the unit testing and actually unit testing practices are quite popular among all developers so this is just the statistics from the journal developers not just C plus plus so like for 75 percent of all developers in the world say the testing plays an integral role in their development and like 67 percent are using some kind of a unit test which is kind of good um and there are other types of testing the people are also used to if you look at the C plus plus world so we have uh like in C and C plus plus both we have several Frameworks which are quite popular so we have the and we had actually the Google test like we had them for ages um they were like before like pre-package management area I would say even in this current form in its current shape and C plus plus it was usually a pain to get Google tests into your project because you had to find it download it put it into your project compile with the proper flags and they even had this feq at the Google side when they were explicitly saying please compile the whole library with your flags as you do need for your project so that you don't have any conflicts in terms of the compilation Flags um like right now I guess every decent package manager just that's the first thing they add the Google test but it's still not that easy it's not just like one button pressed but it works for like and you can see for the majority of the C plus plus developers and in 2022 even they have the big Erasure uh for Google test catch is also there but with the catch I guess the story was when it was the header only it was I guess it was super popular I saw how it was growing blazingly fast um but with version two like catch two 3.0 I guess like that's a creepy name for the version but like yeah catch two 3.0 they move to the different distribution models so like they are distributed via the statically compiled Library so it's not header only anymore they have their reasons they do explain in the release notes that they are kind of becoming more profound and they are adding more advanced features and they just don't want everyone to you know get it as a header included so that's fine but it looks like the developers who were using cash they were quite often using it because it was header only and they were a little bit disappointed so I'm not sure how it's gonna go further but I see that the Grove actually slowed down a little bit this year uh boost tests uh they are kind of still popular CPP unit someone is still using them doctast is there but it's not that popular but it's a good uh you know approach uh because it's quite often considered as uh now as an alternative for catch being a header only and yeah there was a great talk with a clean code yesterday which I really enjoyed and that's probably the direction we need I mean like we probably need to have proper Mac free uh macro free uh unit testing framework which is based on like reflection and introspection the clean code which was presented here at this conference yesterday was exactly about that there's an attempt to make a unit testing framework via the reflection which is like macro free approach so and it's good probably like we'll we'll get there one day hopefully um just yeah just do tests don't fall into this category um and just the last thing uh since we were talking about the tasks there are also as a part of the tool set there is also the code coverage tools and you can do coverage in like different ways you can do the line coverage so calculating like how many lines of code are covered or in terms of the statements or you can do the branch coverage where you just check uh what's going on uh through all the branches and there are several like more or less standard tooling like lvm coverage and gcuff like one is mostly used with Clank and one is mostly used for GCC you can still use them like gcaf you can do via the Clank as well uh they have different flags so you just need to configure them properly and you need to take into account some differences like gcaf and lvm cup for example they do take compiler generated branches differently like gcaf takes them into account so you have to understand that if you're doing the branch coverage you might get different results with lvm curve and g-cuff because gcaf will be taking compilation branches into account so you just get different numbers so you you have to understand what you're doing but that's generally a kind of good advice so yeah but the tools are kind of standard I mean like those who are trying to do coverage like you can to take them and get the result okay and probably just the last one to long term treat uh so uh trying to summarize what we have currently in this plus ecosystem so do we have a standard C plus plus two set not in the sense of like Swift rust but we kind of have lots of tools which are more or less standard commonly used for different use cases and sometimes of this kind of standard for this specific area and like do we miss some tools definitely yes the package managers is a good example or the macro free unit testing framework we probably have to do that um can we unify more for sure there's also a room for improvement and we can like integrate tools which with each other and do a better job here so and yeah this is mostly it there are some links I have here and I will publish the presentation so you can just click these links and not you know copy anything from here and that's it thank you [Music] yeah and like if you have some questions I guess we still have maybe a couple of minutes to answer and then I can answer you know privately I think you can just raise your hand and that guys they have microphones so feel free to ask and like I'm here at jab brain's Booth so if you have any questions just feel free to come I'll be happy to answer I'm here for the whole day okay then thank you and have a great day [Applause]