hey rust won't save you but its ideas will update after receiving some constructive feedback the example errors were fixed glitch B I know you're in the audience how much of it percentage wise was constructive feedback are we talking like nine out of 10 constructive feedback or we talking like half so much hate I just dude isn't it wild that you you you you took the time you write something you know I haven't read this yet I assume you're going to put out some ideas and you know that everyone makes mistakes right everybody makes a few mistakes along the way and it's just like ain't no way and they're going to come hard in on you it's just the worst and that phrase come hard in on you probably doesn't make my case very well but hey that's the words I chose so deal with it recently I came across this article titled rust won't save us an analysis of 223's known exploited vulnerabilities being the clickbait that it is I clicked nice job uh quick background on me I've worked in cyber security for almost 10 years I know cyber security way more than I know development my day job is securing infrastructure and code an article like this picks pequs my interest uh I've been writing programs in Rust for a few years now okay so you're experienced by the way glitch just just like to kind of clarify where this is are you uh full-time writing rust or just like hobbiest writing rust for the last few years because I'd be in the hobbiest writing rust for the last few years not really full-time so that means I Arc mutex my hash Maps that's I think you could gauge Yourself by do you use Arch arc mutexes on your hash Maps I ship rust to prod okay whoa you ship rust to prod okay that's unusual you participate in the clickbait I know he did participate in the clickbait but it's awesome tldr rust was made to solve memory related vulnerabilities and issues but that only makes up 19.5% of the most exploited vulnerabilities in 2023 routing and path abuse exploits tied for second place with memory vulnerabilities followed by default [Laughter] Secrets what what was that low-level there was a low there was a low-level learning tweet that was so good about this exact exact same thing let's see if I can find it really quickly oh yeah right here memory and safety will fix computer security also password right right effing there during the Super Bowl this is a shot of the Super Bowl the password it's right there super secret oh bye it's memory issues are the worst uh request smuggling and weak encryption oh really weak encryption I'm curious about this one because I know there's a probably a lot of old services that use like what RSA 2 two something four something8 something and they're just like one generation away from quantum computers just destroying them uh the most abused exploit insecure exposed functions EF that sounds like something the government would say at 48.8% I don't know what uh insecure exposed functions let's maybe it'll explain it the Artic goes on to making the most generic recommendations any cyber SEC professional would already know vendors uh vendors one develop the depth of knowledge of your engineers in the framework they use two Harden standardize and audit the use of those Frameworks across products three enable and expose uh verbose logging for your products I mean this is just a really great thing to to debug and be careful of your logger you use you don't want that log for but this is actually really good I mean this is just great piece of advice by the way but this is also the most generic meaningless advice I've ever heard in my entire lifetime one don't have skill issues two make sure everybody else doesn't have skill issues three don't forget to log developer one uh assume all code you write is reachable from an unauthenticated context that's pretty good that's good good thing for uh non-sec people to think about uh practice uh defense in-depth programming and don't make it easy for an attacker to Shell out I one time accidentally created a bug that would take down Netflix with a simple while loop and I'm talking about like would take down Netflix permanently you could not fix it there was no fixing it I did that you couldn't roll back you couldn't yeah I did that it was called they in fact I even got I it even got its own personal name I personally got named and got a logo for the type of attack I AC created okay not many people get this okay not many people get the opportunity to write a service so bad that it literally could destroy all of Netflix but that was my code it was my code it was my code but it to be fair it wasn't my idea to be fair I just made the code and then I discovered that it was a problem and I started sending send out secret emails really long ago and then it caught fire and then it turns out a bunch of people started jumping in and then it it got there I started sending out emails in like 2015 like oh I think something might be wrong here I think I just created I created a while loop and I destroyed all of staging and so I was like boys and girls we got ourselves a problem uh researchers one look for bugs in plac Frameworks come together cool that's a good story therefore rust won't save us there is much truth to that and the advice given by the article is also correct but it doesn't dig into why rust was made in the first place it doesn't ask the question can we reduce eliminate IE abuse similar to how we reduced memory vulnerabilities looking at if what are insecure function uh exposed functions exactly let's take a look at the m definition the product provides an application programming interface API or similar similar interface for interacting with external actors but the interface includes A Dangerous Method or function that is not properly restricted this weakness can lead to a wide variety of resultant weaknesses depending on the behavior of the exposed method it can apply to any number of Technologies and approaches such as ActiveX controls Java functions IO uh inversion of control what is this oh is this IO controls IO controls I read this as ioc and then I was like wait a second ioc timelines that ain't right uh input output controls and so on uh the exposure can occur in a few different ways a function SL me method was never intended to be exposed to outside actors the function SL method was only intended to be accessible to a limited set of actors such as internet based access from a single website if is access to a functions that outside world should never have had access to in the first place IO cuddles is that what people call them IO cuddles I would call them IO controls IO cuddles really weird let's take a look at an example from the Mitre page public remove move database string database name damn that is a this is a this is a this is a hell this is I would never write this this code should just not exist can we all agree that that code seems terrifying um it just seems terrifying I love how it's void yeah it's void let's see statement create statement drop database database name squeal exception all right nice in this example we have a Java method remove database that will delete a database with the name specified in the parameter the problem is this method should never have been public by declaring it public the rest of the application has access to this method even though it should be restricted remove database yeah private okay yes Java has a few key wordss for deciding the level of access to the rest of the code base public protected private yeah I guess having it I mean accidentally exposing all Atomic pieces can can can lead to a a bad situation but again if let's say you're doing a database per user squeal light approach I'm going to literally write this code this week or next week because I'm going to be doing a squeal light implementation of a per user database for Vim APM and guess what I mean this is just like this is the kind of stuff you have to have because if somebody wants their data removed I mean I'm going to have a way to remove your data and that involves drop dropping your personal database you know what I mean uh Java has a few keywords for deciding the level of access oh yeah we already read that now let's take the same example and see what it would be like in Rust public function remove database it's still there rust only has Pub as a keyword for determining whether an item has public or private scope by default all rust code is inherently private in Java if no met modifier is added its scope level uh Java assumes it has package private access which is a package level rather than an item level there similar esque in other words visibility control in Rust is explicit and controlled through the pub modifier Java's visibility control is implicit if no modifier is specified allowing Access Control based on their location within the code base if a modifier is specified then it is explicit interesting okay in order for rust uh function to be public we would have to declare it as this yes with the word Pub okay interesting you can say the same thing about go unless if you capitalize the [Laughter] access this example is simple scoping error or laziness uh it's easy to miss but rust is less likely to make you a make this mistake okay so it's private by default big deal there's other ways of improperly accessing functions and abusing them we're going to look at this atlassian Confluence vulnerability how can we potentially solve it what was the problem the application insecurely exposed an endpoint server info action bootstrap status provider application config setup config false or setup complete equals false that allows modification to the server's configuration State setting this state to false allows an attacker to re-enter an application setup uh and add an administrative user dang we must note that the class Comm atlassian Confluence core actions server info actions extend Class C atlassian Confluence core action uh Confluence action support this will be important during the exploit exploitation so it's it's Java's fault really Russ doesn't have inheritance which makes it less likely to accidentally inherit unintended behavior from parent class instead rust offers other mechanisms for code reuse and polymorphism the decision to admit inheritance from rust by its designers simplifies the language reducing a potential for I mean this is just a funny phrase to say can we just take a moment and laugh at least a little bit that the phrase simplifies rust it's funny I mean it's funny okay it's funny uh reducing the potential for inheritance related issues such as the diamond problem problem or fragile Base Class problem fragile Bas this is this is all my base classes I've ever written every time I write a base class it becomes fragile I swear encourages composition over an inheritance provide trait-based polymorphism as an alternative allowing you to define a behavior that types can Implement dude fragile bass class dude I got way too many ribbons for not winning and now look my bass classes suck inheritance can be useful in certain context but rust design philosophy prioritizes Simplicity safety and expressive leaning in favor of composition traits and other language features we know that we can Leverage The xw Works 2 feature of supplying HTTP parameter to call Setter methods on objects we need to identify an unauthenticated endpoint whose action object also exposes a suitable get method that will allow us to access the application configuration remember the class this thing seen uh during diffing we explore the base class it inherits from this one if bootstrap status provider equals null then we create a new instance we returned the provider nice nice we can see this class has a getter method this which returns this instance uh we're looking for uh in turn as a getter method get application config which returns applications configuration okay yeah get the app there we go isn't this code just beautiful by the way can we all just take a moment and just look don't you love tracing through delegates like aren delegates one of your most favorite things ever like who doesn't love a good runtime decision finally we can see the class uh implements the setter method no I don't public synchronized void setup complete all right we get this set Russ approach to mutability would have helped here if you want Setters to be mutable then you need to make that explicit yes I do love this I do think one of Russ best decisions ever and I think this is any programming language's best decision ever is all variabl the default action of any variable or any method is non- mutating you have to opt in to mutating I like that I do like it uh why opt into mutating uh because you have to be extremely explicit in how you use something you do I think that that I think it's a much better opt in and that also gives you a key idea to all places that will change by looking at your code right that's it's one of the weaknesses I consider in go is that if you have any variable declared you don't know which ones are mutated and which ones aren't just by looking at it I think there's just something that it it kind of you default immutability is the best default I think it's a pretty good default I do like it uh progress released a security advisory uh for their uh moveit transfer application which detailed a squeal injection leading to a remote code execution and urg customers to update the latest version the vulnerability this at the time of release was believed to have exploited in the wild as a zero day dating back at least 30 days the function that extracts X seock transaction headers to compare its value to the folded ad by folder ad by path nice job calling it a folder Windows user here has a bug it yeah Windows user wrote it that's why will incorrectly extract headers that end in x clock transaction so an attacker can trick the function by passing the request uh into the machine to aspx oh yeah definitely definitely Windows look at that Windows go by providing a header such say XX lock oh interesting and additionally provide the correctly formatted header with our own arbitrary transaction to be executed uh by the Machine 2 aspx endpoint nice you know remote execution that's defined by header seems like a crazy idea can we just take a moment here and just just pour one out to somebody that's like the only way forward you can just say what function you want to call using Russ HP header header name would have caught this error since the header's past uh would not have been treated as a string but a but a known type header this HTP lib is used in almost every rust web framework for header parsing the right way to do header parsing in Rust requires creating a header name and using that to get a header rather than treating the header names as strings this one advantage of rust type system it's designed to be expressive allowing developers to express complex ideas and patterns into concise and readable manner I don't know much about this one this header name thing I thought header name was just from string I always just thought it was a pain in the ass more than anything else uh rust memory safety it's worth uh noting that rust eliminates most memory corruption issues which would take care of 20% of vulnerabilities exploded in 2023 this is a pretty huge when you think about the reports Microsoft and Google have dropped stating 70% of their vulnerabilities were memory safety related Russ doesn't even have null I do love this I do love the idea of not having null I that's one thing I really do wish we had more of you know what I mean I wish we had more of this and go uh we won't uh be having null pointer exceptions issues in Rust anytime soon sorry Java well unless you un RP I mean I mean if you if you unwrap the hero we need the the only problem I have to say about this is that it's really convenient not to have to worry about null your code just looks more simple but the inverse is that if you do have options around everything that could be null you also have to lift it out constantly and then you have this whole problem with lifting out and not coping or getting a reference to it and lifetimes and this and that there's like a lot of things you do have to think about it's it's definitely not like a free tradeoff right it really is not a free trade-off at all and like this right here expect this should not be none I mean that's great and all except for if your expect is incorrect that thread crashes it's gone forever the here what we need the average developer is more concerned with shipping the product now and worrying about fixing bugs later than how security can be designed from the uh from the start security is an afterthought in many processes uh something that gets bolted on for security to work it has to be there from the start you can't add the egg onto the C onto your cake once it's baked you need to add it to the mixture pretty decent analogy I like that I like that security is a process of layering many defensive techniques on top of each other in an effort to thwart attackers it's a constant cat and mouse game the hero we need isn't rust rust won't address all vulnerabilities and magically fix them however rust has inherent qualities from its design philosophy to make it safer to use in the average language that is our hero rust may not save us but the ideas it embodies will private by default immutability by default type safety check at compile time static typing is what I would say because people argue that typescript is type safe it's D I mean it's not complet it's not completely type safe a type A a static typed language truly is where you get the safety from borrow Checker and ownership model reducing memory corruption yeah this I mean this is really interesting uh safe abstractions and idiomatic patterns that prevent common security vulnerabilities agreed you still have like a whole scho of vulnerabilities that just do exist though uh sound type system yeah agreed on strong static typing yeah yeah yeah yeah yeah yeah uh rust design philosophy is a step in the right direction I pretty much agree with almost everything here uh the borrow Checker I'm I'm still out I'm still out the door on I really think o camel in the in the world of borrow checking has it right which is the default is you just use it like a a a garbage collected language but if you wish to have these axes of certain ways to kind of model how you're using something the reference or the mutability isn't a part of its type it's a part of the function signature so it's like orthogonal to the desire of it which means that you can opt into almost all the borrow Checker and own ownership models like goodnesses without having to have all the pain in the ass when you don't need it and that's what I I think that's one thing I think o camel did just so much better right it's so much better that way a Russ design philosophy is a step in the right direction Russ doesn't rely on the developer to put the uh in the place uh all the details it lifts responsibility from the developer so they can worry more on developing and less on safety and correctness imagine using a language that prevents all these kinds of vulnerabilities why do we talk around or about around programming languages as if there isn't a way to improve their inherent security by Design as well besides all the recommendations horizon horizon horizon oh my I can't believe how bad I just read that flip take that take that out don't make me look like an idiot flip besides all the recommendations Horizon made programming languages should also be among them we should expect all of our languages to be safer flip keep it in dude I can't my brain just like totally just flip zoom in flip make it a short do a Barr roll flip um I mean I think there's a lot of things that rust does well the memory stuff is really interesting and if you're an operating system and obviously that like that that class of memory bugs is really important I think the problem with all of this and I'm just going to be completely real here is that the average user is taking clerk Dev and having a login they're saving their data to something like turo some offbox data place they're writing their front end and back end in the same language and all they're caring about is showing some rectangles on the screen and so a lot of this just feels so abstract and away from them that they're like login problems no I just use clerk. that's not my problem oh like don't do this well I just use these function I just use like like a templated string so I don't have injection problems and they and they're just so far away from these security problems they just don't think they really exist for them and so that's where I kind of learned that a lot of this just doesn't matter it's it's actually one of the reasons why I'm doing go over rust is that I love love really good performance I love really correct programs but people don't care they're not going to make a switch because the investment cost is really high but go is really easy the investment cost is really low you can probably on average bring more developers from JavaScript is the only thing that should ever exist into okay I understand why we have static typed language is using something like go than using something like rust if that makes sense now there's obviously things that we should use R for like I I don't want to use embedded devices that aren't that aren't like safe right I I would prefer to use rust cuz I don't want some something that's supposed to stop when my finger touches it like a saw blade get hit with some undoing of Gull and explode and continue to chop off my finger right so I I would prefer rust in those situations right like I I think we all know that there's there's certain things we want people aware uh care about performance I made a cool website with go and small JS bundle and my friends told me bro just use react and fetch data on the client it's that easy so I mean that's kind of where I'm at on these things like people offset all the places in which safety is needed to another like a third party service F the saw stop guy that's right PCO but I mean I mean it people off they they they they they they they Farm out where they need safety you know and so I think a lot of this just doesn't hit home until you're in a large enough company that this hits home in and that's you know again this is why I've been just promoting go mores because I feel like this is it's it's a lot easier to make people want to opt in and learn something that they can be very productive in like they are productive in typescript almost immediately like honestly one day in Rust and you'll be pretty much as efficient as you are in typescript maybe two days and there's a couple of things that are difficult about it why do I love rust I really love the type system you know I'm not going to lie to you no I I'm a huge fan of pedantic masturbation so with rust you can just you can just you can type masturbate all you want same with typescript go just says Nah you're not going to do that you're not that guy pal you're not that guy rust isn't that hard honestly the compiler is the most helpful compiler I've ever seen I know I know people say this uh and this is just a really bad thing to say and what I mean by that is simple rust is simple hard rust is is hard go ahead really I want you to go make a database I want the I want you to pass around trait objects and I want you to do that in in in async world yeah like you build a little command line that takes in a string does some manipulation and sends it back out easy easy right that's not that's not even a thing right that's not even a thing it's of course it's simple the borrow Checker fundamentally is simple it's once you get past that that all of a sudden it becomes difficult the new async r book explains it very well okay very interesting I like I might have to check that out what's the best language for async oh go is because go does not have async O8 go does not have async weight or red blue functions it just simply has uh gof Funk your s and um G Funk yourselves channels and mutexes honestly it's it's it's the best it is it really is it really is the it is the best a weight groups fantastic it truly is one of the best ways to handle people love Elixir too so maybe Elixir could be great I just I don't have any I don't have the ability to to speak on Elixir concretely so I I don't want to I don't want to talk about it if that makes sense I just know that people love it and it appears to be really really really real sexy there you go but I I do really I do really truly believe that go has the best async model atomics and locks is uh is a great book I thought it was an okay book it's okay that's kind of where I landed I was reading the Rust book from CS Brown and that book convinced me that the compiler is not really your friend sometimes yeah JavaScript is not not a good async await JavaScript suffers from the pro what's special about Go's async model it doesn't I just I dog I just I I just told you about function coloring and Che what dog I I like I just I just sit it is a Zoolander moment oh my goodness you can read minds anyways uh Hey the name it's the primagen but why male models but why male models a Jen