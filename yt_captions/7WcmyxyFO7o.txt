hi everyone in the SWAT series we're going to look at Poisson disk sampling which is a technique for generating tightly packed points which are all some minimum distance away from one another will also expand on this to support points of different sizes this can be used for example to procedurally place objects in a scene so how do we generate these points the simplest implementation would be to keep picking random points and for each new point look at the distances to all the existing points if the new point is within the radius of any of them simply discard it and try again this is really an efficient so to speed things up we're going to create a grid where the diagonal length of each cell is equal to the radius that we want to maintain around each point this means that no matter where the point is inside the cell it's radius is guaranteed to cover the entirety of that cell this is important because it means that there's only space for a single point inside each cell we can also see that no matter where the point is its radius cannot extend past this 5x5 block of cells around it so that means that instead of looking at a new points distance from all existing points like I showed earlier we only need to look at the points that lie inside this 5x5 block of cells okay let's get started so in unity I'm going to create a new C shop script called pass on disk sampling and I will open that up I'm going to make this a static class so I need to get rid of all of this monobehaviour stuff and instead I'm going to have a public static method returning a list of vector twos I'll call the something like generate points and for the parameters we're going to want a float for the radius and a vector two for the size of the region that were sampling the points from so I'll just call this the sample region size alright now first thing I want to do is calculate the size of the cells of the grid so if this here is one of the cells remember that we want the diagonal to be equal to the radius and I'll just label the two sides ss so we know the radio sets the value that were being given in our function and we want to calculate s so we know from Pythagoras that in a right angle triangle our squared is equal to the sum of the two sides both squared so we can just write that as R squared is equal to 2's squared and we're trying to solve for s so let's divide both sides by two to get s squared is equal to R squared divided by two and now we can just take the square root of both sides to get s is equal to the square root of R squared over two or slightly simplified s is equal to R divided by the square root of two so in the generate points method I'll say float cell size is equal to the radius divided by my theft or square root of two okay next I'm going to create a 2d array of integers for the grid and here we're going to need to know how many cells they are on the x and y axes so this will just be the number of times that the cell size fits into the sample region size so I can just divide sample region size dot X divided by the cell size and some of the region size dot Y divided by the cell size and I want to round those both up to integers so I'll use the math F dot seal to enter function like so alright then I mean to have a list of vector twos to hold all of the points that we generate so I said that equal to a new list of attitudes so what this grid is going to do is it will tell us for each cell what the index of the point in the points list is that lies in that cell now I say index but since our grid starts outch initialized to all zeros and I should agree say that zero means that there's no point in that cell and then one means that it's the point with an index of zero two means it's point with an index of one and so on alright now I'm going to need a second list of vector twos and this is going to be what I'll call the spawn points so the idea is that when we add a new point to the points list we're also going to add it as a new spawn point and then we're going to try add future points around that spawn point if we've tried a bunch of times and we can't find anywhere to fit a new point around that spawn point and we'll remove it from the spawn points list so to get things started off I'm listening to add a starting point as our spawn point so I'll say spawn point start add and it's gonna be a point anywhere inside of the sample region but I'll just add it in the middle so sample region size divided by 2 all right now we'll do a loop while the spawn points list is not empty so while the count is greater than 0 we want to pick a random spawn point so I'll say int spawn index is equal to random dot range between 0 and spawn points dot count and then I'll say vector to spawn Center is equal to spawn points with an index of that spawn index now as I was saying earlier we want to try a bunch of times to spawn a new point some way around the spawn center and if we fail to find a place to put the new point then we're going to remove this spawn point from the list but of course the question is how many times should we try before we reject the spawn point and for that I'm actually just gonna make it a another parameter of the function I have an inch num samples before rejection and I'll give that a default value of 30 so obviously one can speed up the algorithm by reducing that number but then at the points run the risk of not being as tightly packed all right so here we're going to have a loop for and I equal to 0 I less than um samples before rejection I plus plus and share we want to pick a random direction so I'll start by creating a random angle so this is gonna be equal to random dot value to the random number between 0 and 1 and I'll multiply that by math F dot pi multiplied by 2 so in radians that gives us any possible angle and then we can create a vector to Direction equal to a new vector 2 and we'll have the sine of the angle on the x-axis and the cosine of the angle on the y-axis all right now to create a vector 2 for our candidate point this is equal to the spawn center plus the direction x random dot range between the radius and two times the radius so the reason we have the radius as the minimum value is so that we guarantee that we're spawning the candidate outside of the point that's already at the spawn center all right now we want to figure out whether or not to accept this candidate point simply say if and I'm now going to call a method that we haven't created yet called is valid and I'll pass in the candidate point and if that's true then we want to add the candidate point to the points list we also want to add it as a new spawn point and then we want to record which cell it ends up in so let's say grid and then on the x-axis this will be candidate at X divided by the cell size and really need to cast this to an integer and we'll do the same thing for the y-axis cast to an integer candidate dot Y divided by the cell size and we'll be setting the grid at that sort of cell location equal to the index of the point so points dot count remembering again that this is the one based index not the zero base 10 X all right so now that our candidate has been accepted we can break out of the loop and then outside of this loop we want to say that if no candidate was accepted then remove the spawn point from the spawn points list so in order to know whether or not a point was accepted we really need to create a bool up here and we'll call this candidate accepted the default value of false and now if we have a valid candidate point I'll set candidate accepted equal to true and then outside of the loop we can say if no candidate was accepted then spawn points don't remove at spawn index all right then at the end of all of this we can just return the point list now all that remains for us to do is implement this is valid method so let's come down here static boo is valid taking an a vector2 for the candidate point and then it's going to need a bunch of other things as well now we want to know the sample region size as well as the cell size and we'll also need access to the points list and also the 2d integer array that is the grid all right now the first thing I wanna check is that the candidate pointer actually lies within the sample region so I'll say if candidate dot X is greater than or equal to 0 and candidate dot X is less than the sample region size dot X and then same thing for the y-axis candidate dot y greater than or equal to 0 and candidate @ y less than some of the region size dot y so if that's all true then it is inside the sample region otherwise I'm just gonna return false immediately because it's not a valid point then what I'd like to do in here is figure out which cell the candidate point lies in so that we can search the surrounding cells so I'll have int cell X is equal to cast an inch candidate X divided by cell size and then same thing for cell y this is equal to int candidate or Y divided by cell size all right now in order to search this 5x5 block around the cell we'll need to start on the x-axis two cells to the left and end two cells to the right so I'll create an INT search start x this is equal to sell X minus two but now we have to make sure that this doesn't go out of bounds of our grid so I'll set this equal to whatever is larger between zero and cell X minus two so it can never go below zero and then I'll have an int search end X which is equal to whatever is smaller between cell X plus two and the number of cells on the x-axis of the grid minus one so grid dot get length with an index of zero minus one all right now I'm just going to copy pasted this for the y-axis so I'll call this search start Y and such and why replace LX with cell Y and get length zero with get length one all right I'm now going to need two for loops to loop over this block of cells so I'll have 4 into X equal to search start X while X is less than or equal to such end X I think current X by one and same thing for the y-axis for y equal to search start Y y less than or equal to search end y y plus plus we can then get the index of the point in that cell call this int point index is equal to grid X comma y -1 so if the point index is equal to negative one that means there's no point in that cell so let's do a check for that I'll say if point index is not equal to negative one then I want to find the distance between the candidate point and that point I'll say float distance is equal to candidate minus the point in the points list with that index and get the magnitude of that fracture now I'll test if this is less than the radiance so if distance is less than radius and I'm just going to add the radius as a parameter to the function here could calculate it from the cell science but anyway if that's the case and the candidate is too close to the point and we're going to return false and if we get through at this entire block of cells and we haven't been too close to any of the points then we can return true all right then just as a little optimization getting the swear magnitude is cheaper than getting the magnitude so I'll just rename this to square distance and compare it to the squared radius all right so now we just need to pass all of the correct arguments here into the is valid function so it needs the sample region size it wants the cell size the radius the list of points and the grid all right so the algorithm should be working now all that remains is to test it so to do that I'm gonna go into unity create a new C sharp script I'll just call this chest and I'll create a empty game object to assign that to all right I'm going to open that up and in here I'm gonna have a public float radius I'll set that to one a public vector two for the region size outside that equal to vector 2.1 by default and then a public int rejection samples which shall set to 30 and then really I want a list of vector twos for the points and then I'm going to have a on validate method so this is called our when values are changed in the inspector and some other times as well but that's the main reason we're interested in it so he'll just say that points is equal to pass on disk sampling generate points and I'll pass in the radius the region size and the rejection samples all right now to visualize this I'm going to have an under aw gizmos method and y'all say that if the points list is not equal to null then I want to loop over ish so for each vector to point in the points list I'm going to draw a sphere there so gizmos dot draw sphere at point and instead of actually using the radius I'm going to have a separate value called the display radius and I'll just create that over here public float display radius I'll set that to 1 by default as well it also just like to draw this region size so back in on draw gizmos I'll say gizmos dot draw wire cube passing in region size over to has the center and region size as the size all right shall save that go back into unity and which was come to compile and once it does we go into 2d mode shell and I'm just going to disable the camera in the direction of light because those are kind of getting in the way and let me turn that stuff off so now we should be able to increase the region size and see our points filling it up now in order for these points to be valid the center of each point mustn't be inside the radius of any of the other points that's a little difficult to see so what I'll do is I'll have the display radius and then we can tell that it's valid just because none of the radii overlap each other all right so I can now increase this even more can get a nice bunch of points here and we can decrease the display radius to just see how that looks as a sort of field of points and I think the distribution looks very nice we can also try reducing the rejection samples and as I said this will make the algorithm run faster but it may result in points that are less tightly packed and you can see if we get really low we might even end up with some huge empty areas so you can I play with that depending on your needs all right that is everything for this episode in the next video we're going to look at supporting points with different radii so until then Cheers