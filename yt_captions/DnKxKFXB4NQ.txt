hello and welcome today i wanted to share 
with you what in my opinion is the single   most useful decorator in python taking a look at 
the code that's already written here first we have   a function which computes the nth fibonacci 
number and it does so in a recursive fashion   so it's extremely inefficient next in 
our main function we have just a loop   going through 400 numbers just printing 
out the number and the ith fibonacci number   and then at the end we print done now if i 
were to actually run this code you would see   that while the first few go very quickly it starts 
grinding to a halt around 31 32 33 and essentially   each number after that takes twice as long as 
the number before it and this is because of the   you know bad implementation of the 
fibonacci function that we've given here   the main problem with this implementation 
is that when i compute fib of n minus 1 well   part of that computation is to compute 
fib of n minus 2. so i'm doing a lot of   repeated work here every level down i'm going 
to be repeating work that has already been done   and then just was thrown away in a different 
function call an easy way to fix this is just by   remembering values that have already been computed 
and that's what the decorator does so my favorite   decorator in python is the cache decorator from 
the functools library so functools is a built-in so you don't have to install anything and 
then you just hit your fibonacci function   with cache and now let's go 
ahead and try running it again   you see it goes through all 400 of them 
immediately and the reason for that was   that even though we have this very inefficient 
definition what cache does is it just remembers   all of the values of the function that it's 
computed before so if you compute fib of 398   then when i compute fib of 399 it looks up fib of 
398 and 397 and it says oh i've already computed   both of those things instead of recomputing 
them using this recursive definition it will   just use the value that it's remembered from 
the previous time that you've run the function   so i find this to be extremely useful because 
it allows you to avoid repeated computations   there's also a variant of cache called lru 
cache lru stands for least recently used   and it does essentially the same thing but 
instead of storing all previous values of   the function that you've called it with it only 
stores a certain number of them so let's just   replace this with an lru cache and give it a 
max size of say five this means that it's just   going to store the five most recent values of 
the function that i've called now if i'm just   running up values of the function in a for loop 
like this then that's plenty just to do this   so still if i run the function it completes just 
as fast as before and this way i'm only using a   little bit more memory but it's a huge speed 
up compared to when there was no cache at all   so i found myself using cache or lru cache 
in a lot of different projects just anywhere   where i can see myself accidentally repeating 
computations that might take a long time that's   a great place to just throw it in a cache or an 
lru cache you don't have to do any other work   and it can provide a lot of speed up 
if you know the right place to use it