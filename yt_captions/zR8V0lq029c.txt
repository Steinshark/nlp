we've done a series of hardware videos with dr bagley about various different parts of cpus and things like this and one of the things he'd mentioned during one of the videos is something that i believe you want to tell us a bit more about the the wheeler jump yes the wheeler jump david wheeler very very talented computer scientists excellent lateral thinking i didn't know him very well i knew him very slightly maybe met him four or five times but uh you just had to be impressed that he as a computer pioneer had to grapple with the fact that very early computers did not have enough registers in their cpus registers are just like tiny bits of memory tiny bit of memory but within the central processor unit they could be built of much faster technology than main memory so typically you know like with the arm chip at user level you'd end up with 16 general purpose registers one or two of those might be set aside to use for all sorts of useful things and one of the useful things was the idea of you're running through your program you want to jump into a subroutine to calculate a sign or to print out hello world or something like that you don't want it to be running linearly on your program you want to jump into it and jump back out of it again so you could use it several times in your program from several different places you could jump in and jump back out now david wheeler is credited with this idea of inventing the subroutine and saying well yeah when people want to calculate sign of something they don't want to have to replicate in their program the coding for sign in six different places might make it go faster and of course some of you will know that if you write macros you can force it to do that sacrifice a lot more code for faster speed but no to keep it clean you basically say i want this piece of code to be separate but jumpable into and jump back outable from back to where you came from so before you jump in at the moment of the joint you've got to say where am i coming from whose responsibility is it to remember that and in modern cpus you would have a link register of some sort that remembers didn't have that in the very early days but boy did it dawn on them that you needed it so if you didn't have a link register how on earth were you going to get into and out of your subroutine so let's say you're coming from 70 shall we say location 70 something like that right now on this particular occasion therefore when you get back out of that subroutine you don't want to go back to 70 itself because you'd end up in an endless loop of jumping back into yourself you want to go to the instruction just beyond 70. but you want to get back out you want to remember 70 add well depending on the architecture you add 1 2 4 depending whether it's a byte machine a word machine whatever but you add a small number onto that address and say that's where i want to get back to the instruction after where i jumped from and and the problem is that you've got nowhere to say well on modern machines 70 would be saved in a link register maybe register number 14 or something you say jump to subroutine the moment you say it it automatically remembers where you're jumping from and puts it in the link register so when you want to come back out you say here i am on this architecture where's my link register number 14. let's look at its contents oh it says 70. and uh i'm on a 32-bit machine with four bytes to the word so that's uh i want to jump for beyond 70 or if it's you know like headsack it might be one or two beyond but you want to just jump back to where you came from slightly adjusted with a little amount added and it is that link register that saves you from going insane now back in the early days of david wheeler and this exact machine he had to do this for oh golly i wish i had an extra register but i haven't what register have i got that's in use all the time that might if i'm very careful serve me all right and the answer is the arithmetic accumulator every time you loaded a number into the accumulator or did some arithmetic the answer stays in the accumulator okay so here's the deal we're going to use the arithmetic accumulator as the means of remembering where we came from so here you are at location 70 in the early edsac machine what do you have to do so you have to add 70 to 0 or something yes ex basically yes you're jumping from 70 okay 70 has got to be in the accumulator at the moment of jump and then you do an unconditional branch instruction to get to the start of the subroutine fine but you wake up in that subroutine your first job is to preserve your link to get back you must not do any arithmetic because you feel like it duty calls you must save off your return link somewhere safe right because um if you don't you won't be able to get back but you have no spare so we've got nowhere to say no spare registers to save it yeah you might think so but how about this suppose at the bottom of your subroutine there is a branch instruction a dummy one which is basically going to say branch or jump back to where i came from but where i came from must be a literal correct address and in the accumulator is 70. so what you then have to do is knowing the length of your subroutine and its addresses and knowing where the return instruction is planted as a dummy you've basically got to turn 70 into 7274 whatever it is to make it go back to the next instruction after where you came from and you must literally plant that instruction and shock horror overwrite your own program code at the bottom of this subroutine so that the dummy jump which has probably got zeros left in it now becomes jump back to location 72 shall we say but you are actually altering memory now can you imagine if that goes wrong how to debug a program that's trampling all over itself and jumping back to the wrong address you know code gets altered all the time right can you give us some sense of how sacrosanct these lines of code are when it's running well coda may seem to alter itself all the time but it's usually altering itself by manipulating registers in the cpu not physically overwriting memory in your main memory store so it's okay to obviously change the value for variables and and all of that but actually changing those lines of code should be changing variables is fine that's data you're allowed to change data what you're not allowed to do is to treat a program instruction bit pattern as if it was just a piece of data and to patch something on top of it to re now you can do this on z80s i've tried doing it if you get very simple chips there's no protection mechanisms they'll let you do anything you want and you just hang yourself fine more advanced chips now and particularly operating systems make use of this give you an ability to mark which pieces of memory are read-only and are not to be overwritten and that way you can stay fairly sane although you've left behind a polluted piece of code saying jump back to 72 the next time you come into this routine maybe having jumped from 256 shall we say you've now got to remember 256 in the accumulator the moment you get in there you adjust it ever so slightly to come back to 258 or whatever it is and you plan that instruction to overwrite the jump back to 72 which is still there literally inside your code so every single call you make into that subroutine the link back has to overwrite whatever usage it had before and plant it in exactly the right place to get back you can see now why the most headsack2 came along all of a sudden these had link registers all of this early experience just showed the pioneers what the next generation of machinery had to have and that's how the importance of link registers became obvious it will have occurred to you of course sean i think i've got this right that doing it the day david wheeler way with the wheeler jump right you successively at the end of your routine writing back and patching it with the address you need to get back to that's fine and it will work but what does that not enable you to do it begins with an r a further oh recursion yeah one of the reasons for wanting a more general um mechanism for doing it is you can't do recursion with the wheeler method because you've only got one place in memory at the end of the subroutine where you patch back a new return address what you need with recursion is to have several return addresses all waiting to be used queued up not queued up stacked up on a stack so that's the other thing recursion is obviously a very particular special case but does this wheeler jump not even allow you to do branches in branches oh you can do that yes yes you can do that but but actually having um you know a thing call itself since you've textually only got one copy of the routine just one you're not able to replicate the text in any way there's no ability to do that you can only damage that one return address just the one that means that no next realization from being a pioneer is my golly we've got to be able to do recursion my golly we need more general purpose registers and and all this kind of stuff and oh also wouldn't it be nice to put a marker on memory saying don't let anybody overwrite this and actually have it hardware imposed not just by people's good nature and this depends on the value being fetched from there i'm just going to show this as an arrow here but the next instruction load r2 comma c well that doesn't depend on anything except