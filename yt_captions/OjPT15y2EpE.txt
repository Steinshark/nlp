Hello and welcome. I'm James Murphy. In this video, we're going to learn how to programmatically traverse your Python code from within Python itself. Then we'll use that ability to help us write custom checks for our code to prevent us from making common errors and keep our code quality high. Basically, the goal is to write a custom plugin for flake8. flake8 is what's called a linter. It runs on your source code and then tells you if there's anything wrong. In this case, it didn't find anything wrong with the cool_module. However, if we add an unused variable into our function and then run the linter again, it'll complain. Local variable x is assigned but never used. Linters can also warn you about stylistic or other code style things. Like, in this case, it's telling me that there's no newline at the end of the file. A linter like flake8 already has a ton of really good rules built into it and for those that you don't like you can just turn them off. But what can you do if you want to add your own rule? Let's say, just for example purposes that, you want to disallow local imports in functions. There's nothing necessarily wrong with having an import inside a function. But sometimes, these function level imports are used as a crutch to avoid cyclic dependency issues. Basically, a local import might be hiding a deeper architectural issue and we just want to prevent that. But then, we run into a kind of big issue. If I asked you to find all the local imports in a module, how would you do it? You may reach for regular expressions and try to match sort of the form of what a local import looks like. But even for this simple task of finding local imports, trying to do it with a regular expression is going to be an absolute nightmare. The issue with trying to use a regular expression is that text is not the natural way that we think about Python code. I don't think about these concepts in terms of the literal characters that make them up. Instead, I think on a more abstract level in terms of classes, functions, for-loops etc. Well, the good news is that Python itself also thinks this way and it can expose this data to you. We can see this representation of the data using the ast module. When I run ast on my cool_module, this is what it looks like. It shows me I have a module whose body starts with a function definition of a function named cool with an argument named n and so on. This is called an abstract syntax tree. And it's exactly the kind of data structure that we need in order to analyze our Python source code. Running the ast module on a source file will print out the abstract syntax tree. But we can also import ast from within our own code and access that tree at runtime. In this example, we read the code from the source module. Then we pass it to the ast.parse() function This gives us back an in-memory representation of the tree. Printing out the node that we get, we see the top level module object. All these ast objects have an underscore fields attribute. So, you can see what things are inside of them. You can also find this in the docs for the ast module. So, we see a module has a body field. Printing that out, we see the body is made of a list of statements, in this case, just one function definition. We can dig further and further and get things like the name, arguments or body of the function definition. Everything that you see in this printout of the ast, we can actually now access from runtime. So, I start with the top level node object and then I could say node.body get the zeroth element that says function definition and then dot name if I wanted to see what the name was. So, this is great. This tree like structure is now what allows us to traverse our Python code in terms of Python constructs rather than literal characters. ast also provides this NodeVisitor class that we're meant to derive from. A node visitor makes it really easy for us to walk through the entire tree and visit all of the nodes. So here, we call visit on the root node and what visit is going to do is, we'll just print out the node and then we call this generic_visit which will visit all of the children of this node.  Here's the output. You can see it starts with the module then goes into the function definition. And basically, we get a single call for every single node in the tree. But normally, when you're linting your code and you have a specific rule in mind, it doesn't just apply to every kind of object. It doesn't apply to modules and classes and functions. Maybe, I have a rule about a common error involving for-loops. In that case, instead of visiting everything, I can just say visit_For. Now, when I run the code, I only get two calls because there were only two for-loops in the cool_module. You can look it up in the ast docs for what all these names are. But basically, there's one for every single possible Python construct. Okay, back to the goal. I want to warn if there's any import inside of a function. I'm confident that if I could get flake8 to call my code, then I would be able to find all the local imports. So, how do I get flake8 to call my code? It's actually surprisingly simple. I'll make a class for my plugin and then give it a name and version. This name and version are required and they're going to show up in the help text. Then make an init function that takes an argument named tree. flake8 will inspect the signature and know to pass the ast here. flake8 will construct my plugin and then call run. And run is supposed to yield any errors that it finds. Here, I just want to see it run. So, I'm just yielding nothing. Then we create this dot flake8 configuration file in order to tell flake8 where our plugin is. It uses a standard ini file format. Create this block for local-plugins and then we're going to be creating an extension. You could tell it about multiple extensions like this. But for now, let's just stick to one. On the left side, you tell it what code prefix all of your errors are going to use. In this case, I'm using, like, mcoding 1. So, I'm saying that all of my errors are going to start with MCOD1, so like, MCOD100, MCOD101 and so on. Then on the right hand side, use the dotted path to the module. In this case, the module is just in the same directory. And then, a colon followed by the name of the class. Since my module is not in an installed package in the current virtual environment, I just need to tell flake8 using this paths equals current directory to look in the current directory for plugins. Otherwise, it's going to complain that it can't find the flake8_mcoding module And if we go ahead and run flake8 on our cool_module, we see the running text that we printed out from the plugin. Okay, our plugin is running but it currently doesn't do anything. It just yields no errors. So, how do we yield an error? flake8 expects you to yield errors as 4 tuples including the line_number, the column offset, the message of the error and the class. The line number_column and message are pretty self-explanatory. So, what's this class thing? Well, it's actually not used for anything at all. It's just completely ignored. But it does have to be there and I generally just return the class that generated the error. Just to see if everything's working, we'll just try always yielding an error, say, at line one at offset zero. Running flake8 on the cool_module, we now see our custom error. Note that, your error messages must start with the prefix that you specified in the configuration file, or they'll be ignored. The prefix I specified was MCOD1. If I change that to a MCOD2 and run it again, then I no longer see the error. Let's change it back. But that's just something to be aware of. Getting back to the goal of finding imports inside of functions, let's make a NodeVisitor and try to find them. My NodeVisitor initializes an empty list of errors and will populate that whenever it finds an import inside of a function. We'll use visit_FunctionDef to find all the function nodes. Starting from a function definition node, finding a local import is pretty easy. We just loop over all the children in the body of the function. Then if any child node is an instance of either an Import node or an ImportFrom node, then we found a local import. Then, we just create and append the error. Note that, every node has a line number and offset. So, we can just forward those on to our error. Here we're using the line number and offset of either the Import or ImportFrom statement. After visiting all the function definitions, all the errors will be stored in this list. So, now all we need to do is call our visitor from our plugin. Our plugin will create the visitor. Then we'll start the visiting process and pass in the root of the ast. Finally, we yield all the errors that the visitor had stored. Running flake8 on the cool_module now correctly shows us the error that we aren't allowed to use a local import and it even gets the line and call number correct. Okay, this works. We accomplished the goal. But we wouldn't want to create many different visitors if we had many different rules that we wanted to add to our linter. Traversing the entire ast is extremely expensive if you have a large codebase. I would actually refactor this a little bit in order to make it easier to add multiple checks without traversing the tree multiple times. So, what I did here was, I extracted basically the body of the check that was actually doing the checking to see if anything was wrong with the tree and I extracted that into a check function. I wrap it up in a class and put the message as a class attribute. So, for every kind of new check that I want to write, I just make a new class, I give it a message and a check function. I have the check function pass the list of errors that it's supposed to append to. Then in our node visitor, I just call the check function of every check class that I want to run. If you want to add options to your plugin like adding a strict flag or something like that, you can also do that. In your plugin, just create a @staticmethod add_options that takes an option_manager. You can import the option manager like this. If you've ever used argparse, then option manager will be very familiar to you. It's basically a thin wrapper around argparse. So, if I wanted to add some fancy variable as an option, then I would do it like this. Specify the flag that you want. What's the type of the variable? What's the name of the variable? This is going to show up in the help text. Give it a default value. This allows people to set it from their configuration file and specify any help text. At this point, if you run flake8 with --help, you'll see the documentation for your plugin. We see the --some-fancy-variable, the name n and our description. In order to get the values of any specified options, you need to add this parse_options function. It's another @staticmethod and it takes an options parameter which is an actual argparse.Namespace. Any variables you set will now just be attributes of this options variable. So, if you wanted to say enable strict mode or something based off of an option, you just set that as a flag here. And this gets called before the run method gets called. So, all of your options and whatever you set will be available before the run happens. If you want to test your knowledge, here's some homework. First problem: Write a plugin to warn against any use of eval. Don't worry about sneaky cases. Just check for literal eval. Next problem: Forbid the creation of any new metaclasses. And lastly: Write a plugin that for multiple assignments forbids multiple uses of the same name. This is a popular confusing example to throw around. Let's forbid it. The name a is used multiple times here and we don't want to allow that. See my video if you'd like an explanation of how multiple assignment works. And finally, if you're really serious about writing your own linting rules, you should really package your linting code. Right now, all of this code is just depending on all these files being in the same directory. That's very flaky. For a real project, I would recommend packaging your custom rules, so that you can just pip install them. See my video on automated testing if you'd like to get up to speed on how to package your projects. As always, thank you for watching. And thank you to my patrons 
and donors for supporting me. See you next time.