there we go there we go here and I'm going to play this at slightly faster one 125 P you have tensors tensors are ND an end dimensional grid of numbers yeah very simple you can do plus and other operators on them it's all totally fine but why do you need to clone a tensor sometimes have you ever run into that uh yeah okay and so why is that why do you need to clone a tensor it's the usual object thing that's in Python so in Python and just like with Java and many other languages this isn't unique to python in Python it has a thing called reference semantics which is the nerdy way of explaining this and what that means is you actually have a pointer to a thing instead of the thing yeah now this for those that aren't like in the SeaWorld and just have only ever programmed JavaScript that's I'm sure like half my chat is just that person uh have you ever notice that you pass an object to a function and then you edit that F that object and then it's edited for the person on the outside that's because what you have isn't the value itself you're passing a pointer into the function function anytime you invoke a function it co it copies right this is why it's called pass by copy you copy the values being handed in and the thing you're handing in is not the object itself so the object isn't being copied instead you're passing in a pointer you're passing in a number and that number gets copied and so it's like free it's like for freezy and then boom you just got a copied number now that number still pointing to the same thing and bada bing bada boom yeah passing by reference by value yeah Bada Bing is Du to a bunch of implementation details that you don't want to go into but in Swift you have this thing called value sematics and so when you have a tensor in Swift it is a value if you copy it it looks like you have a unque copy it's like the easiest way to describe it right is you just got to think of everything is passed by copy it's just what are you passing in that's why in go if you pass in a non- reference you get that sweet copy right you get copies in go right if you don't pass by reference you get a copy right or am I wrong on that one yeah yeah yeah you just get you get passed by copy everything is passed by copy like that's real life real life is passed by copy so when you pass a reference you still are copying you're just copying an integer an INT 32 in 64 whatever your your architecture is and bada bing bada boom it's easy peasy pump pump pumpkin seedy lemon squeezy however you want to say it and if you go change one of those copies then uh it doesn't update the other one because you just made a copy of this thing someone isn't isn't an array AR a reference someone said that passing by like maps by whatever it's it's it's passing by their reference is already underneath the hood they're they're not values their their references that's C++ no like that's yeah this guy's really happy about this this stuff well just just trying to give like a basic understanding to people and there's PL there's probably plenty of exceptions and variations to the rule and there's probably a better way to explain it but just trying to give somebody that has never even thought about the fact that when you pass an object to another function you can edit it like you got to remember there's people that have never thought about that once in the world it doesn't make any sense to them what do you mean we're not passing by value that's because in reality we're not passing by value right that's not that's not what's happening right you do it can be difficult it's it's difficult the very first time you learn about it so that that's like highly error prone in uh at least computer science math disciplines that's week that's like the first week of programming 101 that is for people who aren't in today's mod remember computer science is largely dying computer science isn't the same thing as programming they are different and so people that don't go to CS 101 where they have to learn about the layout of an integer and they have to learn about how things are working underneath the hood then yeah that's just what happens they don't understand it they they're confused by the concept cep programming and CS are very different CS you can largely do on a whiteboard I wouldn't program on a whiteboard other than for an interview you know what I'm talking about you know when you're trying to get a job to show that you're good at programing just do it on a white part about python that like the the thing you would expect to behave like math like math it doesn't behave like math and in fact uh quietly doesn't behave like math and then can ruin the entirety of your math exactly well and then it puts you in debugging land again yeah right now now you just want to get something done and you're like wait wait a second where need where do I need to put clone in what level of this stack I only use Python to take a CSV and make a pretty matte plot lib graph out of it and I still use chat jippy for it okay I used to like battle my way through my once every six-month requirement now I use them all the time I just go chat jippy I have this CSV with these headers and these values I need to put them all on I know it's cringe and based it is cringe like honestly as someone who constantly tells you to learn how to learn someone that constantly tries to tell you how to like understand the tools you use Python is still this thing inside of me where I just I just simply use jippy to solve all my problems okay and before that I used to like learn it like try to learn it as little as possible all right I'm sorry I am that person it makes me feel bad it's a duality I understand everyone needs to take a shortcut you cannot learn everything and it's okay to not learn everything you just need to draw the line that's good enough for you the problem is is people draw the line way too early so that's why I'm so hard on everybody saying you need to do it you need to do it you need to do it that's because people don't pick any battles it's not that they pick battles they pick zero battles so it's like you definitely want to pick some battles Sweat Equity is good which is very complicated which I thought I was reusing somebody's library and now I need to understand it to know where to clone a thing right and hard to debug by the way exactly right and so this is where programming languages really matter right so in Swift having value sematics so that um both you get the benefit of math working like math right but also the efficiency that comes with certain advantages there certain implementation details there really benefit you as a programmer right SOI the value sematics like how how do you know that a thing should be treated like a value yeah so so Swift uh has a pretty strong culture and good language support for defining values and so if you have an array so tensors are one example that that machine learning folks are very used to um just think about AR unfortunately I don't have I don't know what to a tensor I have never used tensor flow I quit doing my uh Masters in in machine learning before tensorflow Pi P torch any of these things so therefore I don't really know what he's trying to say you know I've I've hand I've handrolled my own MLPs rbfs and fizzes and Colony optimizations all that kind of crap but I've never really done anything beyond that uh tensors are just linear algebra they're just n dimensional Rays okay okay interesting and then you just do a whole bunch of linear algebra on them that's all it is it's just it just has so so by so when he says value semantics you get this n-dimensional array that gets copied because that's how I'm curious what value semantics are in what he's trying to say because I I know all those words but I don't know what Swift is trying to do arrays same thing where you have an array you put U you create an array you put two or three or four things into it and then you pass it off to another function M what happens if that that uh function adds some more things to it well you'll see it on the side that you pass it in right this is called reference sematics now what if you pass an array off to a function it Scrolls it away in some dictionary or some other data structure somewhere right well it thought that you just handed it that array then you return back and that that that reference to that array still exists in the caller and they go and put more stuff in it we're about to hit rust aren't we at any moment here we go rust can we go rust mentioned rust mentioned rust mentioned here we go right the the person you handed it off to may have thought they had the only reference to that and so they didn't know what they that this was going to change underneath the covers and so this is where you end up having to do clone so like I was past a thing I'm not sure if I have the only version of it so now I have to clone it so what value sematics does is it allows you to say hey I have a z Swift it defaults to value sematics for so default to value sematics and then because most things should be Val then it makes sense for that to be the default and one of the important things about that is that arrays and dictionaries and all these other collections or aggregations of other things also have value sematics and so when you pass this around uh to different parts of your program you don't have to do these defensive copies and so this is this is great for two sides right it's great because you define away the bug which is a big deal for productivity the number one thing mean practically in Swift does Swift handle things like rust in the sense that when you hand off the value of an array the function that receives the array is the new owner they have I know they have some sort of ownership model or something like ownership is it pass by copy that's going on here copy on right it's a cow is it copy by default does it copy things in arrays uh is copied in Rust wait what arrays are aren't copied and rust you can pass an array you can lose your ownership of the array they Arc they do atomic reference counting or do they just do reference counting oh they they and they do copy by rights interesting so they're all cows I'm a Rancher so I understand this are they open Cows they do copy by MIT does that even mean okay they do cow I get it didn't the rust Creator work on Swift I do not know a cow is by default that doesn't uh sound that great I mean I I like the idea the thing that I'm a little bit confused about obviously that means that you have to there there must be some sort of like pass by reference thing so that way when it does the reference counting and rights both people share that so there must be it must be like some sort of there must be some sort of cow what Cal copy on right right there must be something what do Cal copy on right uh so there must be a little bit more right it's also good for performance because when you're doing a clone so you pass the array down to the thing it's like I don't know if anybody else has it I have to clone it well you just did a copy of a bunch of data it could be big and then it could be that the thing that called you is not keeping track of the old thing so you just made a copy of it and you may not have had to yeah and so the way the value sematics work is in Swift is it uses this thing called copy on right which means that you get you get the benefit of safety and performance and it has another special trick because um if you think of certain languages like Java for example they have immutable strings and so what they're trying to do is they provide Val mantics by having pure immutability functional languages have pure immutability in lots of different places and this provides a much safer model than it provides by semantics um the problem with this is if you have immutability everything is expensive everything requires a copy um for example great by the way great take right here I I do like this this is a much more practical take I do like Swift I actually want to learn how to use Swift and I would like to build some servers with Swift and try to get it um but I I like this so copy on right I I'm curious how you do like shared shared references ones where two people can can mutate or two functions can mutate a value without having a CO like without the copy on right so there must be obviously some way you can do some sort of shared semantics as well I assume two two copies one function in out okay in Java if you have a string X and A String y you pend them together we have to allocate a new string to hold okay you the function is mutable okay if they're mutable cool well and Str strings in Java are immutable and if there's there's optimizations for short ones and it's complicated but but generally uh think about them as a separate allocation and so when you pend them together you have to go allocate a third thing because somebody might have a pointer to either of the other ones right and you can't go change them so you have to go allocate a third thing um because of the beauty of how the Swift VI SMX system works out if you have a string in Swift and you say hey put in X right and they say append on y z w it knows that there's only one reference to that and so it can do an in place update nice so you're not allocating tons of stuff on the side you're not you don't have all those problems when you pass it off you can know you have the only reference if you pass it off to multiple different people but nobody changes it they can all share the same thing you get a lot of benefit of of purely mutable design I I do like this o camel o camel has like you know o camel is different but the same in the sense that you're less worried about ownership and more worried about who mutates and I I I like that kind of idea I I like what I'm hearing I like this I think again I think Swift has all the things that I want in a language right now o camel is my current new love that I can't wait to really learn and become great at but I see myself wanting Swift because Swift does have I keep writing as seeing it the problem is I assume you can write Swift without xcode you can write it in in Vim uh you can do whatever you want to do a tailor yeah I'm a Swifty I'm clearly I'm a Swifty okay I'm a Swifty X CH more like it thick but powerful like a really nice sweet spot that I haven't seen in other languages yeah that's like I thought I thought there was going to be a philosophical like narrative here that you're going to have to pay a cost for it it sounds like uh I think value semantics is beneficial for easing of debugging or minimizing the risk of Errors like bringing the errors closer to the source um bringing the symptom of the error closer to the source of the error however you say thaty say you're saying there's not a performance cost either if you implement correctly well so there there's trade-offs with everything and so if you are doing L stuff then sometimes you can notice cost but then what you're doing is you're saying what is the right default so um coming back to user interface when when you talk about programming languages one of the m m i I do want to throw that out there that I I like the idea that mutability is not a type I know that's like one of Russ thing lifetimes affect the type mutability affects the type and so you have this like there there's just a lot of difficulty when it comes to working with certain things and so I like this idea of having these different because a problem with lifetimes being part of the type is that the moment that your type needs a lifetime everything that references your type needs a lifetime and then it keeps on bleeding outwards right and so that's why I like these ideas of what it I like reference counting with copy and right like I like all these ideas because it takes all of that overhead off your plate so you can still write just as efficient code you don't have to be not efficient but you can you get the ease of not having anything else right like you don't have to you get the ease of being able to update specific parts to do all this extra stuff that has to hold on to references and then it kind of falls back into something else cleaning up I like that I think that's a perfect medium I'm very happy about it major things that Swift does that makes people love it medium that is not obvious when it comes to designing language is this UI principle of progressive disclosure of complexity okay so Swift like many languages is very powerful the question is when do you have to learn the power as a user so Swift like python allows you start with like print hello world MH right certain other languages uh start with like public static void main class like all the ceremony right not other languages uh that would be Java okay I mean other languages yeah right and so you go to teach you teach a new person hey wel welcome to this new thing let's talk about Public Access Control classes string system.out printland like packages like right and so instead if you take this and you say hey we need you need we need packages you know modules we need we need powerful things like classes we need data structures we need like all these things heard it here first powerful things like classes Get Wrecked functional Bros Get Wrecked get screwed get get methed the question is how do you factor the how do you make it so that the normal case scenario is you're dealing with things that work the right way the right way give you good performance the right by default but then as a power user if you want to dive down to it you have full c c performance full control over lowle pointers you call Malik if you want I don't think they're called classes in functional programming aren't they called what are they called like type something or others it's it's the the word type exists in it what is it called what is it called in type A type class yeah there you go type class it's a little different there's no extends keyword which is good okay I I you know I just want a struct that can I I can put methods on okay that's all I want and when I want more methods I want to add it and sometimes I want a type that is just literally another type and I want to be able to add methods to just that that's one reason why I'm I I it it Go has not been a complete disaster there's a lot of good things about go because go I can just take an array of something make it into my own type add some methods to that type and then I have a convenient way to do stuff with it you can do you can do you can do uh you can do the same thing with other stuff like I like composability go Go's mid go is mid go is 100% mid go is the most mid language ever and that's what makes it great it's just like python python is the best worst language ever created go is the most mid language created and rust is the most by the way language created and hasell is the most white paper language ever created you'll notice that each one has different strengths like if you're using hasal maybe you won't ever write actual code but you'll definitely have a white paper at the end and the the pl the Applause and the adulations of all the other hasal nerds out there so it's a trade-off it's genuinely a tradeoff on what you want to do work or white papers call Malik this is not recommended on the first page of every tutorial but it's actually really important when you want to get work done right and so being able to have that is really the design in programing language design and design is really really hard it's something that I think a lot of people kind of uh outside of UI again a lot of people just think is uh subjective like there's nothing you know it's just like Curly braces or whatever it's just like somebody's preference but actually good design is something you can feel I agree with that I like that very very good like And subscribe subscribed liked this is great I like that again it just makes me more and more and more want to learn Swift I feel like there's just been this long running I want to learn Swift thing I just don't what it is cuz I I I I like I like what I've read about Swift I've never used it enough to actually like it or know anything about it I just feel like I could like it and I feel like that that's kind of exciting right it it feels exciting knowing that there's more things out there to go learn that you can be excited about right I like that I like that feeling I like that we're in an industry where you can still be excited and learn new things just saying it makes me EXC it makes me excite Swift is slow right slower than Haskell I would not imagine it's slower than Haskell right I I I would not imagine it's slower than Hask I think that's probably uh the the grass is always greener on the other side of the fence yeah that's true until you until you use rust and then you realize that everything else's desolate landscape and and rust is this lush green grass that you go and lay in and you can never leave the green grass because once you've laid in that green grass all of the grass is nothing but just thorny thistles and Briars and everything terrible and then there absolutely no way and then the foundation says get off my Lord and then all the sudden you hate life we saw it happen we've seen it happen a Jen