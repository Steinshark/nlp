Hello and welcome everyone. I'm James Murphy. This GUI is created with the Dear ImGui GUI library. It's a minimalistic, easy to use but highly functional library. It can do menus, it can add and remove new windows on the fly, thanks to my patrons and donors by the way, it can nest regions within each other, you can have buttons and tool tips, menus of these sub windows, pop-ups, modal pop-ups, drag and drop, tabs, tables and so much more. Here's a demo image of some of the more creative things you can do. But ImGui is a C++ library and this is a Python video. If your project is already in C++, then great. It's really easy to use. But there are a lot of great features and libraries of Python that are really just wrappers around C code or C++ code. Take NumPy or Pandas or most of the built-in functions in Python for example. Well, we're in luck. Enter pyimgui. pyimgui is an easy to install Python wrapper around ImGui. There's some basic boilerplate code you can copy paste to get things started. You need to initialize the library, ask the operating system for a window, in this case, I'm using the glfw library. tell ImGui that you want to render to that window, pick your favorite font or just use the default and then like most graphical applications, the rest of the time is spent in some kind of render loop. Each iteration of the render loop is pretty simple. We process any mouse or keyboard inputs and start a new frame. Clear the screen. Then here's where you're going to put most of your ImGui commands that define the GUI. After all the commands then you render. These frame_commands are going to hold all the actual interesting GUI logic. That's all the boilerplate you need. If we didn't put anything else, we basically just get this blank window. Now, look how easy it is to add a new window to your GUI. You just say begin and give it a name. Put whatever it is you want inside the window and then call end. That's all it takes and now we have a window. Windows are draggable, resizable and collapsible by default. Of course, there are extra flags and things that you can do to change how it behaves. Let's go ahead and add a main menu bar that has, like, a file close. And this is all it takes. I say begin_main_menu_bar which is going to return to me a boolean of whether or not the menu is displayed. If the menu is displayed, then I make a file menu. In the file menu, I make a quit item. Every frame when this runs, this returns to me whether or not it was clicked or selected. And then if you click quit, I just exit. We run it and now we have our file menu. This Ctrl+Q is just shortcut text. It doesn't actually do anything though. If I want to actually make the Ctrl+Q shortcut work globally, then I can just do this. This get_io object exposes keyboard and mouse events and state to you. So, I just check if Ctrl and the Q key are down and then exit. As you can hopefully see by now, the appeal of ImGui is how little code you actually have to write in order to get something extremely functional. And one of its biggest selling points is, its declarative style. In a lot of GUI frameworks, you have to start with some kind of initialization method where you specify all of the possible different widgets and menus and things that you're going to have. Then you would hook up some kind of event handlers that will enable and disable components depending on what you do. But with ImGui, you don't have to do any of that. If I want a button that when you click it, it opens a pop-up, I just say: if button, open_popup. Then I check if the popup is open and put whatever I want inside. And there you have it. Click, popup. I never needed to create a button object or set up any event handlers. I just read the ImGui commands top to bottom and do anything that I need to do as it happens. You just declare what you want to see and let ImGui take care of the widget bookkeeping. As it stands, ImGui and pyimgui are already great libraries. I'd recommend them to anyone who wants a quick and easy way to get a GUI up and running. But at its heart, ImGui is a C++ library and some of the C++isms are leaking through here. Every time I begin a window, I need to make sure to end it. Begin a popup, then you need to remember to end it. But only if the if returned true. And there are a whole bunch of these components that I declare with some begin something and then I need to remember to end them. I have a resource that I open and then need to remember to manually close. Does that sound like a familiar pattern to you? It's kind of like writing to a file. I need to open the file, write to it and then call close. Except I guess, if you forget to close a file, that might not be that much of an issue. You might not even notice it depending on the program. But let's say, I forget to end this popup. Well, everything is fine until the popup is supposed to appear. Then I get a crash. So, unlike with closing files, if you want the render loop to continue, You absolutely must close every begin with its corresponding end. Okay. So, just get better at programming. Don't forget your ends. Well, that is a generally convincing argument but that's still not good enough. Besides the fact that it's annoying to have to remember sometimes it's not possible due to exceptions. What if I was supposed to read this popup text from a file but the file got deleted. I can even try to catch the exception. But at that point, it's too late. Even with the except Exception, when I click the button, I still get a crash. And notice, it did catch that exception. The exception that crashed the program was a different one. The exception that crashed the program was from when the render method at the end of the render loop goes in and tries to consolidate everything. And it notices that there was one extra begin that had no end. And it doesn't know how to fix that. So, it has to just give up and crash. This would be the same story as if you were using a file. You open it, you write to it and then some exception occurs. Well, then the file doesn't get closed. But Python has a solution for this. It's context managers, the with statement. I say with open as file. Then I can do my using. And then even if an exception is raised, the file will still be closed. Well, that's exactly what I want for the pyimgui library. I want to say with window, forget about the end. I want that to happen automatically and then just indent everything. I want to say with begin popup as popup, if the popup's opened do whatever, and even if there's an exception, I want to make sure that in all cases the proper end function is called. Okay. Well, ImGui is an open source library. Let's do it. Even though it's an open source project, I'm not trying to steamroll over someone's garden here. So first, I made an issue on their Github. I explain my reasoning and use case. I explain what I'd like to be able to write. And I go over a potential implementation of how this could be achieved. And look at that, we get the go ahead from the project maintainer. Step two: Create my own fork of the library and clone it. I create a new branch for the feature that I'm adding. Make sure that you're branching off of the development branch, not the master branch. With ImGui, these were hundreds of commits apart. So, make sure you're using the right one. This is ImGui's main file. It is incredibly long, thousands and thousands and thousands of lines. It looks like we have eleven thousand something lines here. And it's not just eleven thousand lines of Python, it's eleven thousand lines of Cython. Cython is an implementation of Python that compiles into C or C++ code. It also allows you to import and call raw C and C++ functions from within Python. This is what allows us to use ImGui at all. Remember, it's a C++ library. Cython allows you to write normal Python code. But it also allows you to write this weird mixture of C like Python code. Here, we define a class DrawList. But we use this cdef keyword. This is going to tell Cython to create a C extension class instead of a normal Python class. This is not meant to be a Cython tutorial. Cython is a huge topic. I just want to wet your appetite a little bit and show you some of the things that can be done. Anything that uses the cdef keyword is going to use C rather than Python under the hood. That allows you to manipulate things like pointers that you couldn't manipulate in raw Python. You can also mark functions with cdef. Functions marked this way can only be called from within other Cython code. That means this method would not be accessible to regular Python. This can actually be a really good thing because cdef functions and variables and so on can call each other and use each other without ever returning control back to the Python interpreter. If I have two cdef integers, I can add them and that addition will happen in C. Cython also makes it easy to convert back and forth between Python objects and C counterparts. Notice, here's a function that says it takes a float width. Now, this is not using the normal variable annotation syntax. This is special Cython syntax. This is a normal Python function. And Cython will actually try to convert whatever you pass as this argument into a float. So, if you pass in a Python float, it will unwrap that value and give you the C floating point value out of it. And if you try to return a C float back to Python land, it will get wrapped up in a Python object. Let's get back on task. Here's the begin function that starts a window. And here's the end function. Besides, like a 100 lines of documentation, these are actually really really short functions. I basically just call the raw C version of the function and then return its value. There's a little bit of finessing since the raw C version actually uses out parameters in order to fill this value of whether or not it was opened. The C library returns to whether or not the window was expanded and then it uses an out parameter to tell you whether or not the window was opened. And end is even simpler. It just calls the raw C ImGui end function Here's the idea. Right now, this is just returning a tuple of two booleans. My idea is to instead return a tuple like object that has the same information but also has enter and exit methods for with support. So, let's construct this class. First off, we want it to be fast. We're going to use a cdef class. I preface the class name with an underscore to indicate that you should not be trying to create one of these from Python. This is a private implementation detail of ImGui. I have this explicitly inherit from object. This is just because ImGui is trying to support Python 2.7. My original proposal used things like typing named tuples. But because they want to support all the way back to Python 2.7, I'm going to do it the old school way I make expanded and opened. These are going to be the two tuple values begin was already returning. I mark them as bools. So, they'll automatically be converted to Python booleans. And I mark them as readonly. What this does is, it allows Python code to access these attributes. But it only allows them to read them not write to them. I could use a regular init but I'm going to use this cinit. This is just for a trick I know to make it fast. You could just as well just use regular init. Then the heart and soul of the proposal enter and exit methods. This is what allows you to use the with statement. It's pretty typical for enter to just return self. Then in the exit method, we always just call the cimgui's end function. regardless of whether or not there was an exception or whatever. If there was an exception, it will call this function and then just continue propagating the exception. Next, I'm going to add a get item and iter. Personally, I don't think this class should have these methods. But it's too late. pyimgui is an existing library that already has lots of users. Prior to this point, the return value of begin was a tuple. So, it needs to maintain that behavior in order to not break old code. So, we definitely need to be able to index into the tuple and the iter method is for allowing variable unpacking. Then since I'm such an upstanding citizen, I write a repr for the class. And that's basically all the functionality that we need. So, we declared our attributes in a little funny way. We used cinit instead of init. But then everything else is kind of just a regular class. So, now let's use our begin end as the return value instead of just a tuple. I just take whatever the existing return value was and wrap it in my BeginEnd class. But remember that speed hack I mentioned. Well, instead of instantiating the class the normal way, we're going to use the dunder new method. For sneaky reasons, this is going to be faster. Also, we didn't define a regular init. So, we can't call it. And that's all we have to do for the begin function. Now I just grep for all the def begins that there are in the file and this is the work that I have cut out for me. What I showed you was what I had to do for begin. Now I just need to repeat it for the other 17 others. And there are so many of these. I know there's no way I can do it without making a typo so I actually made test cases for all of them. My process was to write test cases for one of the pairs check that the tests fail then I would implement the new functionality, recompile and run the tests to see that they pass or didn't. Finally, I would add an updated working version of my demo using the with statement to see that everything is working. Then so on and so forth for the next set of tests and the next set of tests and the next set of tests And so on. So, this is actually, I'm recording this at the very end and these are all the test cases. Just so you can see what it would look like, first I set cythonize with coverage equal to one With this on, it'll compile in debug mode and the compilations will go way faster. Then I pip install the current directory which will trigger the Cython build. It still took 30 seconds or so to compile but that's just how it goes. Then I just run py test on my test file. And all 61 tests pass. And let's head back to our example from before. Remember I had this window where I click a button and I get a popup and it crashes. Well, now we're using the with statement. So, even though we're raising the exception which we do catch here, we should find that the end popup will be correctly called and we won't get a crash. So, we click the button and we see caught exception no crash. And then once the popup goes away, then that stuff stops printing out. All right, great. Just one more thing before submitting the pull requests. We just need to update the doc- ...