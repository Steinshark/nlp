hello uh i'm chris thank you dance for the introduction and welcome to uh to a session about name tuples a potential c plus plus 20 improvement over std tuples so i hope you will enjoy that one this session is um about the dream which i've been having for a while and you know one night i just woke up and tried to implement it and make it happen so it's this session also will explain why you cannot have you know awesome things yet in simplest plus planning but it is let me unlock on a tuner so so hopefully that makes sense and without further ado uh let's begin and yeah everything is powered by the compiler explorer links will be provided and everything is c 20 standard compliant and might be checked online if you don't mind i will try to take the questions at the end but don't feel free to ask them at any time just put a slide number if you can see it on the right bottom corner so that i can refer to that so what's the motivation so name tuples are coming from python python is actually using them very often and the reason why they introduced that it's mainly because the name tuples in python requires indexing it by a number so you know like in c plus plus we have to get zero on or by type uh if it's possible in python with the same case uh tuples has to be accessed by the index so that's why they introduce name typicals and you know i was talking about this dream i was thinking about what's wrong with our tuples and how we can improve them and one of the things which we definitely would like to have is the names because the names of fields make the whole game you know are the game changer so what what are the main issues with the sdx googles when we create the sd dual pro like that so far no issues when we try to get it by type however that ain't gonna work because the type is ambiguous in that case so x and y are both ends and the tuple is created from both two ends so when we try to get it that will be ambiguous type and we'll get hard error it's not even a nice error message as well so all of that is not great because you would like to get an x and y potentially you know accessing by by the type is good if you have a strong types which i encourage everyone to use but sometimes you just don't have this ability when you're using third party libraries or anything like that which doesn't provide you the strong types and unique types in in that matter also when we're assessing it by the value we have the same case as in python get zero and get one that's fine however if we put the y and x in the wrong order well we won't get what we actually wanted what we really want to write is i want an x and on the y like in a strand the same with structure bindings which is c plus plus 17 edition which is awesome right because we can destructure the 2.92 elements however we still have to maintain the x and y so we can imagine that it started from x and y and you know someone changed it in the future and then you know all the code breaks again so that's big issues which i haven't seen with the std tuples and we have so far there are obviously other issues like get two in that case when we have two elements which you when we try to access the third one will give us and not spin a friendly arrow so we cannot do substitution failure is not an error what i mean by cena is the fact that we cannot do really a tmp with the tuples because we always get the hard error and horrors will just break and won't be discarded by the compiler what is a huge benefit of potential tuple implementations of the structs because tracts are awesome and we'll take a look into subtyping versus it's called draw polymorphism which will discover the std tuples and name tuples actually and already invested it was is the fact that std tuple could be actually packed properly so if you have here t1 which is of it which has types of end shortened char the size of it will be eight bytes because they packed in an order right so and and short and char it's four two and one on x 86 architecture however if you put them in a different order and notice here it's like we didn't change the type we just changed the order then immediately the size become 12 because of the alignment so you can imagine that how awesome would that be that would be if the tuple itself could pack it for us with the policy for example you say too cool i want the packed size because i do care about performance for example another layout or i don't and i would be able to switch that accordingly however cd2 pull doesn't it doesn't provide that this feature it is a bummer so i'll say anybody's dream is like i don't know how many uh of you have you know coding dreams i'm i'm one of those people who sometimes dreams sometimes dream about coding and then i wake up in the you know at 2 a.m and try to implement those things so one night i actually gone and tried to implement the city to pull improvement in super plus 20. so what i saw what was the dream about that's what i would like to write i would like to write a tuple which has x and y and access it by name t dot x t d y i would really like that and that would give a you know really handy interface towards tuples there's no mistakes here if i you know get zero get one there's nothing like that we accessed by nam we produce it by name we initialize it by name i like it if you call z or z it's gonna be fine the knight to poland will be a constraint not satisfied in my in my dream sometimes german concepts too if i want the type of it i would just do decal type of that tuple and then i can initialize it with the names and the order doesn't matter because both of them are unique types because they are named so we just initialize things by name so the order doesn't matter we can initialize x y or y x which has some benefits in some cases yeah that's one of the main use cases i would like to print the people right you can do that somehow in c plus plus 20 or 17 with the structure bindings and kind of like magic get approached but the problem is that you can't get the names of variables you can only get the types and pick those without static deflection we cannot do anything about it at the moment unless we use negatives or similar approach so print it i would like you to print x and y and and that would be awesome that'll be awesome you know those cases others yeah i also would like to play some json so for example i would like to implement it i would like to implement it to json function uh which takes a tuple and just produce adjacent out of it you know simple static reflection use cases now obviously tons of other genes one can imagine for example a std vector of of t and we can query a database using those names and you can imagine here that select x and y are compile time strings which will be accessed from the tuple because the tuple has the names as well associated to the field numbers so that opens up so many potential features to do with you know when you think about static reflection all of them will be enabled by that and that obviously will require the result so you know talking about concepts having its final friendly would be great as well so that's artificial syntax in which we could do requires on tx that will actually work in subspace 20 but let's imagine that we have the x and y accessible from the tuple xmi will pass the requirement and that wouldn't we can easily you know spin it away if you want to with concept also it's the idea that we would be able to conceptify it with the raw poly markers which we'll discuss later by saying that this tuple requires was like if you're familiar with extensible haskell project or javascript extensible approaches you'll notice that it's very similar that you have a concept in which you say what kind of names have to be in it and then you can query those by by names because you know that all of them will be satisfying so on the first line x and y names are part of the tuple but on the second one x and z are not because only x is there and that is not yeah my dream was also about this packing i would really like to have eight in both sizes in both cases so t1 and t2 would be packed accordingly to what is like the most efficiently as possible so that would be great to have and last but not least modify and access it by name is always something which would be would be great to have as well as being able to easily extend a tuple with another tuple so that's like modeling inheritance so we have a tuple t and then we extend it with z equals 10 and we get to a new tuple which is t2 which which has x y and z so that's also really nice to have so that's the goal the goal is to make the dream come true to make the name two polls in c plus 20. so let's take a look what we can do the gold versus the reality that's not the solution but that's what we potentially could do you know exploring the potential solution space if you have static reflection yes please we will be able to simply do that in the structs and get an x and y and types as well no issues here there are some problems with um creating a struct like return type with the return statement because you cannot like introduce them in place but they could kind of you know deal with it in most cases so static deflection would would help us a lot and probably name tuple wouldn't be as important as they are in c plus plus 20 but static deflection is not coming anytime soon so we'll see additional approach would be to create the name to pull and put a name into a type instead of the variable or with the variables or so that we can have this access by x or y but that requires duplications and also the conversions because we have different type when we have an end uh that's always a difficult view for for [Music] integral types because we cannot inherit from them so we have to you know kind of manipulate a strong type so that's not super simple but it's doable um however it requires it's not dry don't repeat yourself and we do repeat it ourselves all the time and we need to require the implicit conversions to to support the types additionally if you're being at cpcon there was a talk about metastract which is very similar to the second approach it's kind of a combination of both but we have all these duplications by having a meta struct which has a member fields member types fields uh it still requires annotating still requires compression but this is more dry so that's the solution space which we could go about there's one more option and that would be the name table what about if you use the c plus plus 20 features in order to implement a named tuple with liftoffs so you can imagine that we create a name tuple and here we will take a look at underscore t later on so just keep that in mind we have an x which is equals 4 and y which is equals 2. the types are being deduced so x will be an end y will be an end the name will be x and y and we'll have a name table so if we uh decline an a tuple which is constructed this way which is four and two as an end we'll get a kind of this meta strike tuple which will have an arc of x and then and y of n so you can imagine here that it's basically a boilerplate removal of writing this record which you also can write you can write name to call with angle brackets but if you want to avoid angle bracket and use designated initializer with underscore t i think that that's a nicer and then we can initialize it with [Music] our designated initializer kind of approach the order doesn't matter as before because we have unique types because the types are arc of x and and arc of y and then we can access by name so here you notice this accessing it from the in index uh square bracket operator kind of thin the name and that allows us actually to improve much over the the tuple because tuple requires don't get std get uh to be part of it and why it's not part of the tuple itself it's because uh in the dependent context you would have to put template on it so you'd have t dot template get in some cases in some cases wouldn't require that depending on how how you access it where you are and in that case when you have the square bracket operator we always are not required to do the template so so it's nice and we can access it by name and name is a you know compile-time string here when we get the z we get we'll try to get a z we'll get a nice compil time error that the constraint is not satisfied from the concept it's obviously printable and because that's the case we can use also put a name on the tuple itself so not to see x and y and we say oh that's a point there's a point and then we can access all the things by the field by the names and print it as well additionally we can actually also adapt and name the extract so we have a point x and y and we would like to just put the names on it so we've been basically dry you can do that notice the only difference is here that instead of quotes from the point which you know kind of creates an anonymous tuple struct kind of thing we do at a type which is the point and we still initialize it with x and y and that will fail in case they won't match as with the zagnite initializers and when we compare them we can access them by the names we can also access them by by the names of the string involved too and when we print it we'll get the same result notice that we get the point as well being printed so all of that it's [Music] pretty handy for especially all the use cases which we discovered so i think that's pretty cool obviously we can do the json as well there's nothing stopping us because we have all the names and fields available we can do the get zero and one because it's a tuple so name tuple you know kind of builds on std tuple so we would like to have the compatibility between those types so we can do that and we'll take a look how difficult is a city to implement structure planning for your custom types so that will work but the issue will remain if you mistaken it so the structure binding is probably not desired unless kind of in unsafe mode uh with the name tables we can modify it by name this you know overloads and the cons upload and overload so there's not been uh really stopping us from using that the only difference is that we have to access it by this uh udl user defined literally instead of x and y which would be perfect but unfortunately we cannot do that and let's go out of this truck we can extend it as in our you know perfect example we can put a t and z and um and just t will be extended by by that we will get a new tuple which has everything from t and also the set uh concept also would work because we would just find a way so here it's actually working code in which you can verify that the concept is satisfied you have to propagate it through the lambda in order to not to get the hard error but that's the way you can easily verify that concepts are satisfied and we can also deal with rocky morpheus who extends uh just basically the same as the dream so regarding that there's a huge difference between well maybe not a huge difference but there's a difference between subtyping uh and dropper demo office repo morphing is the kind of polymorphy that allows to write programs that are polymorphic on the record field types which that arose it is very popular in you know languages which don't have tracks and i'm like skipping languages but you can imagine here that we have a print which you know use this extensible kind of pattern which we say something which has an x and y names can be passed into that in that case will be this name temple and then we can say x and y so you can do that with the concept in sequence cosplani as well but the problem of the concept is that you would have to put a name on them and here you can just put the names into the extents theme concept so that's kind of handy because we avoid a lot of boilerplate and that will print x y as expected and in the second case that would be just dismissed because although it satisfied the concept of x and y it's not really printed on the next line and if you try to access and pass the song something which doesn't have y i will just say the concept isn't satisfied because extent requires axmr so what's the difference between subtyping subtyping is something which we use very often in c plus plus we have extracts which have fields and then we extend their own tracks and the problem here is that we have a lot of boilerplate if you want to do kind of these polymorphies uh when you want to print a human that's fine when you want to do it the employee but what about the fish if you want to add a fish like should we extend human that doesn't make much sense so then we would have to put additional entity and like a lot of boilerplate just to make it happen so step typing is good but it also has negatives and also doesn't support the names in our case so the name tuples we can actually do something like uh height and weight height and weight as a named parameters and they will be defaulted to uh sdna or whatever you want by default it's a policy for that and then the employee human um uh we'll add the salary as we have in the line on the top but instead of passing a human to the print we pass a concept which just have to satisfy hey you just have to have the names for hide and go and in in that case employee will just be printed and fish is just a name to paul which has both names as well so i hope that uh that's appealing uh and finally uh we can make it packed as well so and you can imagine and because it's not distract the field members are not coupled to to the order in any shape or form because we define the layout once when we put names and values into the tuple and then the typical underlying communication may pick the most optimized layout if you want it via policy and in that case both of them will be properly sorted by the type size of the type and both of them will have eight bytes which is which is great for the performance and the code layout in some cases so i'll just take a look quickly and if there are any outstanding question although i said [Music] okay well i don't see any outstanding super important questions uh besides that there was an echo in the beginning which i heard as well sorry about that let's take a look at the implementation then yeah so it will be an implementation you simplify with c plus plus 20 around 100 lines of code and we'll use a few c plus plus 20 concepts which we'll probably enjoy because they're super fun so if you just want to implement the name tuple would you have the size of one because they've been antistruct we can just do that because std24 will satisfy our requirement here so there's nothing really special for that and we have you know a bit of that pain that we implemented something what about if you want to support more things uh like the name time is you know a udl which we really want to to have a unique type for and that will be allowed uh if c plus plus 20. we could have done it in previous um not really equity standards but the compilers which are accessible right now besides except uh visual studio however it required us to use the ignore extension for doing so so c plus plus one is the first standard which allows us to get uh udls for unique types of strings and pass them around as well with entertp so thank you for that plus plus 20. so in case uh here uh we can compare you can see that name t is convertible to stringview and will give us the same name and also the types will be different so that's the main part which is important because when you try to access it by the index operator we have to get to a different name and a different type because otherwise you know having a let's say string view wouldn't help us because it'll be ambiguous type like in case of the tuples so in order to do something simple 20 the first approach we could take a kind of insult 17 as well would be just to put alter and and try to put the string into it however we cannot do that because we will get an error message which is kind of leading us into oh we can actually put the string into it but that's not the case that's for parsing the numbers uh like 42 underscore uh and which will be 42 meters or something like that then we can just parse it and return a different type if we want so there is a proposal and that's a blue background something to remember which passed and was voted out to sequence plus 20 from the young which notice here the udl which is passing instead of auto a basic fixed string which is not part of the standard however you can imagine that we can pass something which is a non-type template parameter that's what it's called in the standard terminology which means that we can not only pass types we can also pass objects around and that's how we can create the udl with the string so the hello underscore udl will propagate the string into kickstream online on the line above and that's where we can get the name and the name would be also unique type so how to implement this fixed string that's a requirement for weight from our perspective we just need to have a different type and as well as it has to be convertible to stream view so that we can print it so that's a basic implementation which can be found in the standard of proposals not in the standards in the proposals for for that it just takes the fixed stream it has a seat at a deduction guide for the from the charcoal strap size and now to see that we have a size on it and that's why we need this spaceship operator to compare different different fixed strings because the mounting would be different so in the compiler implementation for the fixed string actually will be fixed string of abc of uh na me in that case and that will be visible and the type would be different but we need this patient operator in order to uh which is defaulted which you know enables all those magic uh outlet magic and also make them mangling possible so that's the implementation of it hopefully we'll be in the next standard and we'll be able to just leverage it so how we implement this operator let's put a an arc which we've seen before which takes just the name and here notice that we pass the fixed string into it and we return something which we we support operator for the string conversion which takes the the data and the size and after that we can just create the udl which takes the fixed string and return the name let's just notice a it should be not our concordant data should be named from cone later sorry and our name control size so what will happen here when we do deco type of x and y on the bottom the types will be different because in the compiler representation will be arc of x and arc of y and that's the implementation detail of the compiler it will differ from dc to cloud to amazonbc but the main point here is that will be unique and also the conversion to stream will also work so that's great we have name t right now we want to assign it to the value so the requirements and tests are here that we we do name underscore t equals 42 and then we can get the name and the value so in order to do that uh we'll create the operator udl underscore t let's assume the type would be any for the you know usually we would like to have a policy for that or you can disallow you know random types but for the simplicity of this example we just put the stdn on it so an art will have name and value as we discussed before and this assignment operator will be overloaded yeah we have to do that sorry however it's a handy handy way of assigning the value right so so in case of the arc which by default the udl would be instantiated with the name and the t value will be n then we overload it with the assignment operator and we'll get a rewinded type which has the name and the new type and we'll assign this value right to it so right now we have this udl uh assignment as well we can then implement named support with both x and y for example how to do that well the simplest way of doing it it's much simpler than in case of std tuple because std tuple requires to have the the numbers because we have to uh because the types might not be unique so so if you pass two ends we cannot just simply inherit from twins because they'll be ambiguous and be ambiguous base however in our case the types also have a name in it so they will have to be unique because we don't support the same names twice because they'll be to be at least weird so in that case we can simply inherit from the tss which we have so we have a name tuple sorry again we have a c add and after that we can simply inherit from all the types and initialize them and then we just have to implement index operator for modification and access so i hope that makes sense how to do that part that's an exciting kind of a part of the talk where we try to access the name so in order to do that let's implement a get with the stream with the tick string and then we'll just use it as an underlying implementation while we want the get uh it will be described later because that will be required for the structured bindings so you have this get which is a very simple implementation of something which takes an arc of the name and t value and it's just a specialization of of get so [Music] and you will return the value so we have an arc and you can imagine that since we inherited from sorry so let me replace that let's probably that doesn't clear so since we the name totally inherits from all the types which are arc of name and the value so art of end and x arc of y and then sorry [Music] then if we pass it to the get function which is like that if the types inherited types matches one of them at least we'll get to that function code and that's supported by just inheritance priorities and then we can just return the value out of it and we return it from not to the parenthesis to avoid copying from the error value so in that case how the operator square index operator will look like so we take the t notice the t doesn't have a value because it doesn't really matter it's a unique type which is this fixed string produced by the udl then we have this requires requires to support the concepts uh sorry uh syntax not great we can put a name on that concept and then just avoid one requires but for the simplicity of the slides we just put it in and directly to to see that actually uh concentrate concept syntax the long synthesis is kind of confusing and you can see here that we get the name and the name is taken from the type which is provided and we passed this reference to it and that will go back and we will try to figure out whether we have an overload from the inheritance which will pass that get and if it does then you just return the value that's it as simple as that and there's no really magic besides the fact that how c plus plot works so in that case uh when we have the name tuple we can easily access it by the uh by the name using x underscore t or y underscore t if you get the z and we try to access the c name not found that will be constrained not satisfied from the get uh function so we won't get really nice constant error message but we will get at least that there is no viable overload because constraint not satisfied and notice here that's from the clan the arc has one to two and zero which is the z um name and the zero is the ending character would be nice if it was a string uh why did we have that from dc actually is showing the the name and the the character msbc i don't know what he's doing but he's doing something in the design as well so yeah achievement unlocked uh issues still there uh congrats you passed through the first phase so what else we have so which things will just work up the box so notice that we have this inheritance so because we have inheritance we can actually inherit from a different tuple and create empty one here and just propagate it to nt2 and all the fields will be propagated because of the inheritance how they hide and works so that'll become free i like it i'll take it if you want to have nested composite tuples in a sense like a tuple inside the tuple we can do it like is in the nested case and we put a name on etobo and that would be inheriting from an arc of nested nt1 and so when we can access it by you know nested and then the z and because there will be a tuple inside the table so that will just work out the dark because of the inheritance so we don't have to do anything that's that's quite handy also since we put the concept on it requires uh the concepts of that constrain we just work up the box because we have the constraints on them on the get function so x will pass and that will not we can also very easily implement the concepts for the extents which is this extensible kind of thing with the names so notice here that we have the t and after which is the type of the tuple and after that we propagate the fixed stream of names we do want to support so in our case that was x y and z and it in in that implementation we just put requires of all the um that all the args have to be accessible by the by the tuple and we do full expression over that all of them have none of them cannot fail in a sense so t of x t of y has to uh has to be allowed from the tuple meaning the tuple has to have those names and types involved and if that's satisfied for all of them we could so if you have x and y in our you know simple point of turbo then that's true x and z that's uh not true because we're missing y and this end on default expression will just not work what is not working structure bindings in the point allowed before structure bunny doesn't work out with the box with the custom types we have to do a bit of magic to do so because the error will be that cannot decompose class type name table also get by numbers doesn't work order the box because we don't have that overload provided and we need that overload in order to support structured binaries so how to make that happen unfortunately there's no really a nice way of doing that because there are no customization points besides opening the nine space std and provide a tuple size and that's also for the custom structs so if you have a custom track you have to provide a tuple size and get for those guys and and and we do here in our simple case we get the size of the name to block we have to get the size because if you inherit we would have to also take the size of the nested tuples into consideration but for the simple case let's say it's just the size of tss if you just propagate simple arc equals name and then we have to implement this uh template.get as pointed out before that's why we have std get not the number function with the end for the tuple element so we need those two things in order to support uh structure bindings size is simple we just go over all the tss get the ts size recursively uh in a sense from all of them otherwise we return one and we just zoom that up another here it is designed by instruction kind of pattern with the immediately involved lambda [Music] so if consent will require size we go to the size and that's important because if we don't have um visible expert that would just fail with hard error so we need consexper and requires it's a concept which verifies that the size is provided meaning that is a tuple which is you know nested tuple or whether that's an arc which is another tuple because doesn't have the size because it has name and volume and if it just has the name of the other then it's just one so then the get itself has to be change a bit and we'll do a bit of magic suppose plus 20 here ultimately invoked lambda expression with index sequence to get the number uh we'll introduce this id name which will get and we'll add an overload for the get and because here we'll have a name tuple and like we had ark we can have id and name and notice here that the name will just return for the given number it will just written a name and then we can access the name to put from the name i know that might be a bit confusing but yeah that's the simplest way to implement it with supposed plus 20 without much boilerplate so then we when we have that get zero and one will just work as well as structural violence so great and just a small remark about this immediately invoked function expression in which uh you can imagine another function which goes over the index sequence and we'll call the expression and if you put unknown on the along the expression we just put hello world will get assembly which will just be unloaded so that's a very handy way of doing that in class plus 20 in a one liner uh that can be done in simple 17 and previous standards just requires a bit of more hassle to implement so in the printing the tuple very simple we just have to provide the uh c out operator in a sense and here since we have a get we just do apply over the tuple there's nothing special here uh because um it just works out in the box like the download tuple and the rx will have name and value available to us so we just print them simple so if we get points and try to print it we'll get point x and y uh in case of the start point we will have to get the type name of thing you can imagine like type id of the when you try to adapt the track type id of the type you can do a trick with pretty function to get a a nice point out of it but it's not standard because pt function is not standard so regarding the adapting the start that will be more difficult to print across different standards but at least you can paint with the string when we provide the name so yeah it's even unlocked we're getting closer to what we want actually the last thing would be to get the packed name to pull because currently will return 8 written 12 instead of 8 for given types because they're not sorted in order of size of types and that'll be an exercise for the reader there's a tip here you can do any sort of decisive of arcs any submissions i'm more than welcome uh i have a solution uh in the full implementation which is provided at the end but if anyone feels like trying to achieving that it's a fun exercise to do and the full implementation can be found and physical problem so feel free to to go and experiment and do whatever you want with it basically so what about the showcase as i pointed out before uh we would like to do something more uh usable with the name tuples so that we'll see why you would like to use it so let's say we have a employee structure which is created as follows with the name tuple and we put name age and title and here we just put the types specific types of it and we'll have a vector of those named tuples so you can imagine there will be a like extract of strength of the name end of the age and string of the title and then that the type will produce the vector of name tuple of arcs as we described before so we have a vector of employees and it doesn't place back and notice here that we have started with the designated initializer kind of approach so if you try to provide wrong order order is fine but draw names that won't compile so we good here we won't make any mistakes we have strong types which some you know back us up so we can provide two uh employees into into our structure immediately modify it by taking the first one taking the age put a different number access them by name nothing special here we discovered that but what is really cool it's to json to json on the slide for the name tuple which would look mainly like that so we want an array of objects of employees with all the values provided so the whole implementation to json takes the o stream and takes a vector of tuples we print the the array because we know it's a vector in our simplified case we iterate the range for loop over over the the vector and print the name of the main thing which is the the tuple line in that case employee and after that we just do apply again as we did with uh with the sealed example before we fold express we apply full expression over dna our arguments and print the name at the value and that's it from json that's also available in the example however it would be not provided here and because there will be another exercise for the reader so that's a difficult more difficult one and the idea is that we have the compound time screen which we in that case can since we have the names and everything we can translate into the name table which is super powerful if it comes to the component computing and performance so just because we just have a few minutes left let's just do and convert the benchmark of compilation times because i think it's also important like that's one of the main questions why why would you use that if it's you know 10 times slower to compile something so the simple benchmark would be that to create a big toolbar with i think thousands of elements or hundreds of elements and deluxe and all of them and nine people kind of a similar vein tells with the names instead and what the result shows the result shows that um there's a two thing at least that the name tuple is quite stable if it comes to the compilation times because it doesn't depend on the standard library as std tuple does so std tuple is much slower to compile with gc ellipse on rc plus plus because the intrinsic for index sequence is not being used and there's a recursive uh sort of version there and ellipsis class is in the uh the interesting so it's much faster to compile so we see that we decline uh std depot and standard class plus it's slower actually but the fastest possible is a bit faster but the difference is not huge so i think that's positive because that's for one of the lines uh it's not like a second versus a minute it's it's maybe 10 slower to combine obviously that might be improved as well and we have more features for the debugging part of it because the previous one was the optimized version with all three this one is with the debugging boards basically very similar results showing that um that it is uh faster to use a 3d tuple to compile however the difference is not huge enough not to consider it at least so to sum up uh three minutes left i i would argue that python name tuples are really powerful and flexible they're definitely a feature which would be really nice to have in c plus plus however also adding a feature from scripting language to a system language imposes challenges because we don't want you know to use a scripted language approach towards it we have to adjust to you know our custom performance and other important things would you care about in c plus plus so c plus plus 20 definitely simplifies template meta programming however retain in my opinion a huge cost in complexity by lacking reflection capabilities all of that would be super simple and super handy if you had reflection available aesthetic reflection we would be able to use an instruct and just get the names and if you had meta classes or something like that we could even do the packing part of it as well and take one strap a different strike which is parked and it has the names so that would be great but that may be to come for the time being suppose plus 20 we can deal with the name to ball as an improvement over at the opinion so yeah with that i'll assign all the tuples in z 20 and i will go back to questions well there's many questions there's a comment that uh gcc client already packed to pulse i would argue uh with that we can discuss that uh yeah actually there's a follow-up comment that it doesn't uh oh my gosh [Music] yeah there's more comments about packaging like the packing is quite handy uh but yeah so by default the city to pull the is not packing the the implementation of std to call replacement which can do that however the sd depot doesn't even there are more comments um sorry about that yeah it's like i will answer most of them offline i think because they will be out of time and i'll just go and and at dig into some specific examples but yeah with that i think we can finish up on time and also all of the questions yeah thank you for the talk um and then we're gonna end the stream