hello over the next few episodes we're going to be working on a mini stealth game project so in this game you're just trying to get to the finish zone without being spotted by the guards this is going to work in the same way as the previous falling blocks project where every now and again i'll describe what we're going to be implementing next and then challenge you to pause the video and try and get it working on your own all right so in a new unity project i'm going to start off by creating a ground plane i'll just scale this up a bit and i'm going to create a material for it i just call this ground i'll make that a nice dark gray and just assign it all right i'm also going to create a capsule object which is going to act as our first guide so i'll rename this to guide and i'm also going to create a new c-sharp script also called guard and attach that to the guard object now we're going to want to be able to define a path for the guard to patrol so i'm going to create an empty game object called path and this is going to hold a bunch of empty children which will act as each of the waypoints in that path so i'm just going to top view quickly and then create empty child which i'll call waypoint 1 and then if i duplicate that i can drag it out keep duplicating and just make a simple little path um it's a bit difficult to design the path though when we can't actually see the waypoints but i don't want to give them an actual graphic so instead what we'll do is use something called gizmos and gizmos are just things like this little light icon here and also the camera icon just things that you can see while you're in the editor but which won't actually appear in the final build of the game so how we'll do this is we'll go into the guard script and in here create a public transform variable called the path holder so if i just save that that's going to just have the path object assigned to it and then in a special method called on draw gizmos we can loop through all of the children in the path holder so we do that with a for each loop for each transform call that waypoint in the path holder we can say gizmos dot draw and i'll just draw a little sphere at the waypoints position so waypoint.position with a radius of just say 0.3 now if we save that and go into unity you can see these little waypoint gizmos show up and as we add more waypoints and move these around you can see that visualized here in the scene view and if you want to be able to see them in the game you can also toggle gizmos on and now those are visible there but once again once you actually build the game these will no longer be visible now it would also be quite nice if we could join each of these spheres with a line so above the loop i'm going to create a vector3 called start position which i'll set equal to the position of the first waypoint in the path so we can say path holder dot get child and we want the child with an index of 0 and we'll just get the position of that child and then i'll write vector3 previous position is initially equal to the start position and inside the loop we can then simply say gizmos.drawline from the previous position to the current waypoint position and then the previous position gets set to the current waypoint position all right so now if we go into unity we can see these are each uh joined with lines and if we want this to sort of operate as a loop with the final waypoint connecting back to the first waypoint then we can at the end of the loop say gizmos.drawline from the previous position to the starting position all right so like that we should now have a closed loop all right so now that we've got this nice little visualization we want to get the guard actually moving along this path so let's go back into the script and i'm going to create a start method and in here i want an array of all of the positions of the waypoints in the path so i'll create a vector3 array called waypoints and set this equal to a new array of vector3s and the size of that should be the number of children that the path holder object has so we can get that with simplypath holder dot child count we'll then want to loop through each index of our waypoints array so 4 into i equals 0 i less than waypoints.length i plus plus we can now say waypoints with an index of i should be equal to the ith child of the path holder so path holder dot get child with an index of i and we want the position of that child all right so now that we have an array of all the points in the path it's time for the first challenge which is to get the guard patrolling the path there should be a variable to control his speed and also want to control how long he waits at each waypoint before moving on to the next one note that the guard moves in a loop going back to the first waypoint when he reaches the end okay so hopefully we're able to get it working i'll now quickly go through my own implementation so i'll start by creating a public float for the speed so that's something like five and a public float for the wait time at each waypoint maybe point three then i'm going to create a follow path co routine so iron numerator follow path taking in an array of vector threes called waypoints and i'll start by making sure that the guard is positioned at the first waypoint so just transform.position is equal to waypoints with an index of zero i then want an integer to keep track of the index of the waypoint that we're currently moving towards so int target waypoint index is equal to one since we're already at the first waypoint so we'll now be moving towards the second one and then a vector three for the actual position of the target waypoint so that's equal to waypoints with an index of target or a point index and then we can start our loop so we'll just loop forever so while true we're going to move the guard towards the target waypoint with transform.position is equal to vector3 dot move towards from our current position to the target waypoint and the maximum distance we can move this frame is equal to speed multiplied by time dot delta time all right now if we reach the target waypoint so if transform.position is equal to target waypoint then we're going to want to move on to the next waypoint so we can say target waypoint index is equal to target waypoint index plus 1 mod waypoints dot length so remember the modulus operator means that when this value is equal to this value it will go back to zero so we can now say that our target waypoint is equal to waypoints with an index of target waypoint index and now that we've reached the waypoint we'll want to pause for the wait time so yield return new wait for seconds passing in our wait time variable and then outside of this if statement we'll just want to yield for one frame between each iteration of the while loop so yield return null okay we just need to start the follow path co routine now so in the start method let's say start corroutine follow path and pass in our waypoints array let's save this and give it a try so if i press play we can see we're now moving between each waypoint and once we get to the last one we loop to the first one now one thing that's a bit irritating is that the guard has sort of sunk into the ground so going back into the script we want to make sure that the waypoints have the same height on the y-axis as the guard object so once we've assigned to waypoints i we can say waypoints i is equal to a new vector3 and on the x axis it can just stay the same so waypoints i dot x but on the y axis we'll set it equal to the guard's position on the y axis and then of course the z axis just stays the same as well so waypoints i dot zed all right so if we save this and try it again now we'll see that the guard stays thankfully above the ground okay let's now give our guard a spotlight so i'm going to create a new light object which is the spotlight and i'll parent that to the guard object and just reset the transform and just move it down on the ground here so we can't really see it at the moment but if we increase the range and the intensity should be able to see it streaming out and maybe make this a yellowish color something like that is nice all right so having done that we're actually already ready for the second challenge after reaching each waypoint and waiting for however long the guide should now rotate to face the next waypoint before moving off all right so let me once again quickly work through my own implementation so i'll start with a public float for the turn speed set this equal to 90 so that's 90 degrees per second and then i'll create a new coroutine called turn to face and this will take in a vector3 for the look target and i want to calculate the angle that the guard will need to have on the y-axis to be facing the look target so we know that if we have a direction we can use trigonometry to find the corresponding angle so i'm going to create a vector3 called direction to look target which is equal to look target minus our own position dot normalized then the target angle is going to be equal to 90 minus arctan 2 of direction to look target dot z comma direction to look target dot x and that's in radians we need to multiply it by this conversion factor of radians to degrees all right now to make the guard rotate towards this target angle of a time i'm going to need a loop and for now i'll just make this loop forever and in here i'll create a float angle which is equal to math f dot move towards angle going from the current rotation on the y-axis so transform.euler angles.y to the target angle with a max delta this frame of turn speed multiplied by time dot delta time all right and i'll set transform dot euler angles equal to vector three dot up multiplied by the angle and then want to yield for one frame between each iteration of the while loop so simply yield return null now i'd like this while loop to stop running once the guard is facing the look target so i'm going to be using a method in the math f struct called delta angle which tells us how many degrees apart two angles are so i'll say while math f dot delta angle between the current euler angle on the y-axis and the target angle while that delta angle is greater than zero keep rotating towards the target angle now it's a little bit dangerous actually to just use a value of zero here because due to small imprecisions the euler angles might never exactly reach the target angle so it's better to use just some small value here say 0.05 and that will be a lot safer okay now up in the follow path routine after we finished waiting at the waypoint we can start creating and turn to face the new target waypoint now i'd like to wait while the guard is rotating so we can just tack on a yield return command here now right up at the top of the coating i'd also like to make is that the guard initially faces the target waypoint so we can just say transform dot look at target waypoint okay so if i save this and i'll go and run the game in unity hopefully this will work correctly and it does seem to be working fine i'm just going to turn the wait time down to zero and just ratchet up the turn speed and move speed variables just to make sure that it doesn't break and it seems to be working very reliably so that's good okay now the third challenge is to create the player controller you should be able to move the player around using the arrow keys and the player should rotate to face the direction of movement the controller should also make use of a rigid body for collision detection all right i'll go over my implementation in the next episode until then cheers