there's a new bug sweeping the world of offensive Security in the Apple computer now specifically this bug is in the Apple M1 M2 and M3 chipset it is a bug in the Silicon design of the CPU which means it is unpatchable unless you literally go to the store and get a different CPU that you then replace your current CPU with before you get all crazy and freak out and think that someone's going to hack into your computer rest assured this is a local bug meaning that someone has to already have access to your computer to exploit this but this bug is a really really interesting deep dive into the world of side Channel cash-based memory attacks and the way that cash has been an attack surface for hackers for the last 10 years also if you're new here hi my name is Ol learning uh I'm a security researcher so during the day I look at code I find bugs not like this one but similar and I write reports and uh and talk about vulnerabilities so if you're interested in that if you want to learn how to code if you just want to hang out with me hit that sub button and we'll see in the next few videos now this bug is the output of the research of a bunch of different universities of a bunch of different researchers and all of the research has come together in a white paper a proof of concept and a vulnerability all referred to as go fetch now what is the bug so if you read the articles about the bug the bug is a vulnerability in the CPU that allows one process an unprivileged process just code running as any user to read the data out of another process and leak cryptographic key information so for example if you have a process process a who is an attacker it can read the RSA keys or the AAS keys out of process B the victim doing some sort of cryptographic authentication right it uses really really novel techniques that have been developing over the course of the last 10 years or so let's talk about what those are the bug uses what is known as a side Channel attack and if you don't know what a side Channel attack is consider we have a password checking algorithm password checking algorithm will iterate over every character in the password that you've provided and compare it against the known good password now let's say for example that if you give it the wrong password it still tells you no that's the wrong password but for every character when it's checking if the character is correct it waits 1 second but if it's incorrect it has some kind of processing it has to do so it takes 3 seconds to run well the program did tell you that your password was incorrect you were able to deduce by the amount of time your attack took to figure out what the correct password is based on the latency of the operation this is known as a side Channel attack where the operation itself is correct but the details of the operation or the implementation leak out information from other channels like time heat sound that allow you to gather other information now this applies to computers in a really interesting way computers use this thing called cache I'm sure you've heard of it cache is this piece of memory that sits in between the really really fast CPU and the Noto fast Ram now Ram is extremely fast but cache memory is even faster F so every time you go and you read a memory address you may think that you're actually going into virtual memory and then hitting a ram chip to get that data but a lot of the time you're actually hitting the intermediate cache memory now this applies to side Channel attacks because every process shares the same cache now again the features of the cache whether the cache hits meaning it has your data or it misses where it does not have your data is the correct feature of cache but the amount of time it takes for the memory to get access to via the hit or the Miss is something that reveals through a side Channel information about other processes that are using that cash line so if the cach hits and takes some time but misses and takes more time that reveals information about the access patterns of processes that are using the me the same memory as you and we saw this in the Spectre in meltdown bugs in 2016 what those bugs were were literally through caching and speculative execution where the processor is moving forward into the future and trying to figure out what branches your processes going to take and load that memory ahead of time a researcher found that you could read all of the memory arbitrarily on the CPU through speculative execution by timing the cash misses it is truly amazing I still to this day don't fully understand it but I'll link the paper to it down or I'll link the paper to it down here below go check that out but that exploit that vulnerability kind of broke ground for the future of cash side Channel research right they effectively proved oh the fact that you as a process share cash between other processes is bad right and there are there are features within the CPU that are trying to optimize execution like speculative execution for example that allow you to take advantage of the cash side Channel and so while all this sounds very you know Doom and Gloom we've found ways to get around this right new CPU architecture implements this idea of constant time programming the idea being if I run an operation let's say that I I I run a move operation where I move data out of memory constant time programming is a way of Designing the CPU architecture that no matter if the cache hits or misses that result takes the same amount of time every time so I don't get a side channel the timing is always the same the problem with this is that if every operation in the CPU every single one to include the optimizers running in the background and the micro code of the CPU if those all ran at constant time you would have an extremely slow CPU so most parts of the CPU are ran in constant time programming but certain parts bypass this and this is where the Apple bug comes in things get extremely hairy in what are called the data memory dependent prefetchers in the Apple silicon so the dmps is what they're called are used in the Apple silicon to effectively read all the memory that is in Cache all the memory that you're accessing and inside of the memory what it's doing is it's looking for things that look like memory addresses and the DMP the P being prefetch is looking into that memory and seeing are there pointers that we may need in the future and if those pointers exist it's going out and it's reaching into memory and pulling in other memory so that makes sense right we're going out or we're saying like oh eventually somewhere in this program they may access you know hex 8000 I'm going to go get hex 8000 for them load it into Cash just in case the problem is the vulnerability is that they didn't validate if a if a number if a thing is actually a pointer or not basically there's a function in the Apple silicon that says if it looks like a pointer we're going to go out and get it and that act that that access of loading in the thing that looks like a pointer does not adhere to constant time programming which is the findings of the go fetch paper so because of that you can put arbitrary memory addresses into a blob in apple silicon and the DMP the data memory prefetcher will go and try to prefetch it and put it into cache without adhering to constant time programming thus revealing a cache timing based side Channel attack truly amazing so the end result is a process that is able to listen in to another process and Via these timing attacks figure out what the nature what the memory in that process is and to leak out any of the cryptographic keys of any of the libraries that are that are being used so they used op SSL I think crystal and a bunch of other uh crypto libraries so really really interesting and here we're watching it happen on unfolds on the left you have the attacker process that is filling up the cache and watching memory get evicted and using that timing to reveal information about the CPU and on the right is just a server that is executing the RSA algorithm now they do say that on certain CPUs it takes more time than others like here you'll see this video is 2 minutes 59 seconds long um and again like I don't fully understand the nature of the attack right they're doing a lot of crazy math that has to do with how like RSA is implemented for example um but really really cool bug the fact that you're able to the fact that people on this planet exist that know this much about the iners of CPU architecture is really cool to me um yeah so that that's about it I just wanted to show you guys this I could talk about it and uh yeah it's pretty neat