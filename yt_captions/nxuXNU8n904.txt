welcome to your daily dose of Lee code today we're doing the classic problem twosome alright so let's read the question given an array of integers nums and an integer Target return the indices of the two numbers such that they add up to Target you may assume that each input would have exactly one solution and you may not use the same element twice you can return the answer in any order okay so what are the key takeaways from this problem so in simple terms we're just given a list of numbers and then a target number and all we have to do is just find two numbers that add up to the Target so the first takeaway is we only need to find one pair not a bunch of pairs and another key takeaway is there's always one solution the next key takeaway is we can't use the same element twice the last key takeaway is we want to return the indices not the numbers so knowing this let's start thinking about a solution well based on the problem statement alone we can actually think of the best conceivable runtime or the BCR so the best runtime we could do is O of N and this is because we have to look at each element in the list at least once since we're not going to know which two numbers add up to the Target without looking at every single one okay now we're ready to think of some solutions starting off with the brute 4 solution this one's pretty intuitive we can just iterate over the list twice where we use the first Loop to find the first number and then another loop to find the other number so all we're doing is just checking every single combination in the list so let's write that code real quick okay so first we write the first Loop then we write the second Loop and now we're going to check if num's I plus nums J equals the Target and if they equal each other then just return the indices now this solution gives us a Time complexity of O of N squared since you have to do a nested Loop but it does give us a space complexity of O of one since we're not using any other data structures but we can do better since we did find out that the best runtime that's possible is O of n so we can further optimize this Solution by using a hash table where the key is going to be the number in the list and the value is going to be the index that we found the number and the way we use this hash table is we're still going to Loop through the list but we're going to calculate the difference or the complement and all that is is the target number minus the current number that we're on and then then we can check if this complement or difference exists in our hash table and if this complement does exist then we found our pair and we can just return the indices but if we didn't find the complement then we're just going to add this number into our hash table so let's write the code for this first things first let's make our hash table remember the key is the number and the value is going to be the index that we find the number now let's Loop over the list of numbers and let's calculate the difference or complement by doing the target minus the current number that we're on and now we're going to check if the difference is in this hash table and if it does then we're just going to return the index from the hash table and then the current index that we're on and if we didn't find anything then we're just going to add this current number and the index to our hash table this solution has the time complexity of O of n which is what we wanted but now it also has a space complexity of all then because we had to make the hash table but that trade-off is worth it and that's basically it we went through this step by step and got both Solutions and we solved this problem if this is your first lead code problem and you didn't get the solution right away don't worry about it it just takes practice so don't give up I'll see you guys in the next video so see ya