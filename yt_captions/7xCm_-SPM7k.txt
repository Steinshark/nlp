so hello I'm Chris and welcome to and Parker lemon a case study in which we'll take a look into different approaches towards getting a nth element out of the variety pack so I hope it sounds exciting the talk is not about State and Parliament so if you are looking forward to that I will disappoint you but but I have some tricks here there will be a lot of magic so hopefully that will be even more exciting than and the fact element itself so what we'll be talking about firstly we'll introduce the motivation why we actually care about it uh what is about we'll go as far as [Music] STD get implantation so you know after this talk you will understand why std2 Polo is the way it is and how it works under the hood and how we can improve it we'll also compare it between different compilers and so the different approaches which we'll explore compare them between different compilers as well as different libraries so I had to be a bit depressed here and other languages are trying to get on stage and we'll sum up the the findings and all the you know study and see what was good was bad and I will go about it in the future so uh there'll be a lot of slides a lot of code some of the good practices which I found important will be marked as with the dark group background so and that's something to take out with the talk [Music] so that'll be good and everything is powered by the compile Explorer the links are always provided and everything can be I can be easily checked uh afterwards or during the attack so without without further let's let's begin so the motivation I have to get that out of my chest uh I wanted to point out that I'm working for the hypocracy trading so the performance is important uh for us but uh why we care about you know complimental programming in general yeah I believe that as a digression that on average I think rust implantation will be more performant than C plus plus and I think that's a really controversial statement but I think that's true and the reason being is the fact that rafts just have better defaults it's much harder to screw up I'm Automatic by default there's no IO streams by default and stuff like that so so it's I think it's easier on average to write Multiplex the rest code to be faster than C plus plus code however I think the main reason why we care about the uh C plus plus so much or use it uh especially in finance companies it's the fact that we have more ability to actually tweak the code to the levels that I think are unachievable at the moment by other compilers other implementers so in other words if you have the best code in Rust like you know tweaked really really into the uh to the ground and the best C plus password I would say the C plus plus code would would win at the moment because we have all this you know low level abilities as well as especially the better approach towards template meta programming where we can do much more things and the latter will be expressed here and you know just to find out why why would be faster because in my opinion the faster way to do the computation is just by not doing it at all and that's uh that's why I will be talking about ant element because it's the most common algorithm in the radical pipe which we have to implement to get um things started obviously there are traitor of C plus plus is uh you know slow to compile so you know the fastest code you can get may depend on the compilation times but that that's why the exploration here okay so I get that out sorry for the digestion but I think that's important as a motivation and the performance reflection and the other things are also important in my opinion as a use case because there are you know there are tons of use cases for the Flash and one of them and all of them by default if you want performance will require static reflection and static reflection would require some tnp and it will require Tuple and Tuple will have you know elements and will be able to get the elements and do all the reflection out of it so I have the ability to easily operate on football is important for the attraction design for the federalization if you want the Json out of it in all the use cases which are propagated by the reflection uh you know spread around and there are tons of them and it turns more which are really important as well so that's the motivation if you have any questions feel free to ask them during the talk I will try to answer if I would see them if not I'll be available afterwards so yeah feel free and to hold okay so the motivation and the simple motivation for the and proclamatory is that from the level level of a code perspective is the fact that when you have a tuple and you have a Tupac from one to three that will be a tuple of end event if you get an end and that would be ambiguous because we we don't know the first one second on the third one however if you get the end pipe 11th here by using a number and that will give us the the proper value and if you get the one which doesn't exist that won't compile it will give very really really bad error message but that's the current state of C plus plus so let's not focus on that anyway that will that will work if the numbers that doesn't work with the types that will also you know kind of reflect the reflection proposal as well yeah out of range that's more or less what we would like not even close what we will get so what are we now I think Andre uh some just consumerized that pretty well in that tweet recently about where we are now if he asked what's the simplest way to to get the end of element out of out of the pack that his solution as you see it's not an easy way and it's important to to get that right C plus plus doesn't have really good facilities right now and a lot of them are not company friendly and a lot of them are not user friendly but as we will explore in the future the potential improvements which will be made to the language which makes that easier okay so right now let's begin what we actually can do and there are a lot of things which we counted to and we'll see how we can work on it but some things are quite easy in C plus plus I don't know so getting the first element is actually easy it's because the value price agree so in order to do so we create a Lambda and we pass arcs to it and the first element is the one which we want to get and rest the auto dot with some we want to ignore so in that case when we have first by column and one two three we will get the first element because we will get this overload uh been set to the first and and two and through in the other Dot and we return the first so that's easy right that's just a Lambda immediately info Lambda here what we can ask them we can also take the last grab the last element easily unfortunately we cannot do that with the variety pack function as we did before because we cannot write Auto Dot and then the arc because uh project packs are greedy so it will take everything and the last element wouldn't just exist and that wouldn't compile either way because body pack has to be at the end but we can do something else if you take a look into the you know comma expression like that if you have one two three the outcome that operation would be actually free because it'll be the last element after the comeback so if you generalize that a bit more the last element we can easily get out of a fold expression when we have comma RX so that would be equivalent to the previous example one comma two comma three and we'll get the three that will give us also a warning that is unused value warning that we don't use the one and two we can work around that by just assigning arcs to RX on his own yeah don't try it at home but you can do it and that will silence the warning for us and we will get the value which you want so that's still you know in so we we print using shift lab operator so that syntax is not as bad I'd say uh yet for our standards we can still deal with that if you want to forget the first and last element sorry that's also possible yeah we just have the structure bindings 20 plus 17 we'll have the immediately eaten both Lambda we'll get the first element out of the the function and we'll propagate the the rest to the fold expression and in that case we'll return a tuple from the first element and the last element will be from the fold expression on TSO Dot so that will give us the one and three in that example so I hope that's that's still clear there's now that my magic involved yet um I will get into more details more magic later so that was about basically what can be done in C plus plus 2023 at the moment and it's kind of simple the future actually is sort of exciting and if it would be approved there's a proposal structure bindings I need to do the pack I think it's quite quite quite neat so that will allow us to use structure bindings to get the first element in the following form we have the structure bindings we do first enter the dot TSS you have to put a name here we cannot do that but I will get the first right so that would be one what is exciting is that it's symmetric so if you want to get last we just Dot and then the last so that will return the Fire for free so in that regards it's quite quite neat I'd say but what is even more cool about it is the fact that we can get the first and last at the same time so we have a first do that that will go up to the last but without the last and then we have the last so that will return the first and last as being one and three so that's super cool in my opinion because that opens a lot of abilities to um to separate so it is the structure panics to get a kind of end element we could we could easily do that with that approach too so that was about the proposal to get the first and the last there's not an easy way without a bit of TMP on top of that to get Ashley to NF so that's the discussion would you get into right now so the idea here just to clarify again we have a Reddit pack meaning we have something and we would like to get an element out of it so if you have one two three you want to take zero one or two in that case which will correspond to one two and three foreign we grab the n and angle brackets which will be the the number and one two three is the periodic back which is introduced here so the goal will be to be able to implement the Tuple get we will have around simple Tuple and we will implement the get uh and in that case the gate will be implemented using different approaches which will you know explore here with the different solutions and end type element will be applied with the with the Tuple here and and see how that can be put we'll see whether we will get better when the acidity to pull already there are better approaches when STD get and maybe why okay so they go as I open it out and for government returns element and the end position from a verdict pack nothing new here requirements so we have to be able to get the envelopement out of it and that's nothing special uh it has to be Thai agnostic so you know that's the main reason why we're actually doing that Tuple can have different types so if you have different types you're gonna be able to take a m pack and filament out of that pack as well so in that case when you have a it is a character we're gonna return the character and not an end always because it's not the common interface in that case and also we would like to have nice error message kind of concept not satisfied if we try to get out of range meaning if you have three elements and we try to get the third one [Music] because it's zero index that that should that should fly it will file at the moment in sdd Taco uh we probably have noticed if anyone tried that after 50 pages of error messages okay so objective we're gonna you know we will compare different solutions so we want to kind of be able to judge them flexibility will be judged by the fact whether it supports different types we have one solution which will not but it's kind of nice so I wanted to hint to it because it will lead into the final solution which we will see red ability is is important right because you know although the interface at the end is STD get or something like that or M5 element and you know we want to understand that code and we want it to be you know beautiful code is simple and and vice versa and we want to be able to understand because the code is much more often rather than written so in the in other words how much magic is involved and some of the solution I can immediately one will have a lot of magic TMP Magic performance is there any overhead you know not really a runtime overhead because all the solutions are you know at Comfort time we verified them with static assets however there is an overhead if it comes to calculation times and that's what we actually will Benchmark in the end some of them are much faster than the others and some of them are uh really but I would really encourage since this talk is not really interactive I can't ask the audience sorry about it uh to guess and and try to guess which Solutions will be faster than uh than the others and see how good your intuition is I got everything right first time uh just joking I was kind of surprised by this out so uh maybe you will be other so Solutions there are three types of solutions which we kind of we just split them into they're probably different as well uh but those are kind of common and and have a special um uh properties which are important so the first one is kind of using the function overload parameters so we have a bit of magic to get n minus one element before the nth element so somehow we get to that and when we discard everything afterwards and return the nth so that will be the first type of solutions which we'll try to find ideas for and that will give us the environment using this approach another approach which is also a pretty pretty is the fact that we create a kind of a magical and here the magic is is just uh nothing C plus plus weighted it's it's just something which we'll have to put in that's not value The Blood Plus Code uh so in that magic will create a start or something which will have IDs uh mapping to two types or values and then we'll try to use inheritance or something other tricks to get back to that type ID based on the number as an element so that we can attend the object and I thought that would be more clear we'll actually get to that and the first type of solutions because we'll take a look into different languages and different C plus plus languages kind of as well and the extensions which are capable of helping us with getting getting them background okay so what kind of solution to explore stdra just to see the syntax recursion just to see whether that's good or bad Arc expansion and concept expansion to to see how how we can do that I will use both mp11 to see how that compares especially for everyone I spent uh almost a day trying to get the free processor to work in order to show how that works I am it's possible solution language extension we will compare it will be type pack element fluid um implementation in Clan Circle the newcomer uh um a huge fan of circle and Sean so definitely something to show and also the general is generalized sorry packed declaration and usage proposal which kind of applies circle into C plus plus and and that's also exciting I don't have implementation for that because it's not ready yet but but we'll see how successful implantation Compares into other Solutions you have so that you can adjust how C plus plus can involve in the future okay so as I pointed out I always got both links provided so a little bit to verify them so the first idea and we always started with the same interface we have N5 element with arcs. and then in that case we verify that we had enough but in the array example which is limited because it only apply to the same types we would create an array and we'll just you know use index operate to get enter limit I think that's that's something which I really like about this solution before I wanted to hint to it because we'll get to something similar in the future is that the syntax is something which you actually like because you create an alarm and just index operator of N and that seems to be simple to me at least and and others and I think that's that's close to the ideal syntax but but you know it doesn't work with different types so we cannot really apply and compare that with other solution so that that's not great but the readability I think it's easy to follow in comparison to other Solutions and it's quite quite neat uh language features are out assuming it's really fast to compile because there's not much to do the index operator yeah okay so let's get into the proper Solutions like recursion in order to do that and that will be the code will be in C plus plus 20 will use Concepts and other things but uh actually I believe all of them all of the solutions please besides the one which is using Concepts and which we'll see in the future uh are capable to be implemented in C plus plus 11 I guess with the bradic packs uh so at bucklemon we have the case for the n equals zero we just return the arc because that's the arc which we which we actually want because if it wasn't the one which you want we recursively gone again with n minus one I hope that's like uh naive understandable solution which you know everyone starts with when they learn how to meta program uh in C plus uh but that's the device we have the the the overload on the bottom as a starting point we get the because we have M greater than zero assuming and then we just go down and down and down and we Decor simply call the same function and at some point we'll get to overload which is uh where the N equals zero and loaded and the arc so that's it that's where we start with the naive solution it satisfies our requirements meaning it works with different types it's flexible I'd say it's readable I think number contact or device do you want to call sorry about that uh it's readable uh it requires a bit of magic for the final case with them and go 0. [Music] so performance is it slow or not I would encourage everyone to to guess because it's a it's it is different than other Solutions in in regards of the completion times what is good or bad I don't know yet I would so I just wanted to compare to a different recursion solution quickly where we don't have a different overload but we have ifcon's experience inside so whether that be faster or not I will leave that to you to to figure out now I will figure out I will show you the results later but the idea here is the fact that we still have the same function and instead of having a different overload we just have one function with the different calls to to itself so whether that would be faster or not if contact spare and why and that would be interesting to see in my opinion because that kind of relates to whether should we write more overloads or should we write less overloads with ifcon's expert if if that's available and that's a good that since C plus plus 17. so what about this recursion a second part yes it works for different types yes it's readable a bit of magic again well a performance I think here is less overload standard cushion but whether if contact spray is more expensive better than overload you will say and the next Solutions will always use the following trick which is available with C plus 20 immediately invokes function expression in which we have a Lambda which we call immediately and expand on in that case is Regina number and when we use folder expression to expand on the on the call and since the expression doesn't depend in that case on on the ISS in order to expand it we just come out just come operator deployed in order to to be able to expand because expression on its own can be expanded foreign as I pointed out before this proposal and the structural Bunnings will make that actually much easier so we'll be able to do a Mac index sequence which is what we actually used before as well get the structure bindings and just call the expression with um with expansion so keep that in mind and that's a blue background something to remember I think it's very commonly used pattern it's a plus plus 20 with a terminal program so in our case what we have is unroll function in order for the performance reasons we don't want to do the you know charms and loops and that will expand into two calls to the STD puts without any jumping back so that's pretty cool uh I think which can be replied okay so moving to the solution we actually leveraging that approach we have the Lambda nothing special here just explain that and then we do this trick with the function expansion of the parameters so notice here we have this Deco type void turn NS what will that do is that we will expand on NS times using void Stars so what we will get here is voice search voice star boy star boy star NS time then we get the nth element which is the the one we want and then we ignore the rest and we use pointers because avoid you know it's something that we actually leverage here and we cannot reference to the point so we propagate the pointer to the arcs that will expand we will get the nth every time the uh you know the reference out of it and we'll get the alert so that's kind of neat trick which we can approach apply and get the NFL element out of the wireless plug it satisfied the requirements I'd say it's in the spirit of their magic but we have to understand a lot of trickery of C plus plus but you know let's put that aside the talk is about to figure out what's the fastest what is uh what the options are so so yeah we always hide it by the API that's why we have SDK because we don't have a language feature is it faster or not something to answer there's no recursion involved so yeah recursion I might be slow might be faster I don't similarly with C plus plus 20 we can apply uh someat similar concept uh with actual concept we have a type and we have an auto as a parameters for the concept which is called prefix in that case and it's always satisfied and we use it only for the expansion part so the reason why we have this concept is to avoid this avoid Star Trek between head here so here we have a decal type of void star NS dot but you can imagine if C plus plus 20 and third syntax we could actually implement it a bit differently by having a concept and then an auto which will expand on by the on the concept itself the same outcome however a cleaner solution without contacts so how does it look which starts with the same thing at the immediately invoked function expression and then here is the magic which is a bit less magical than the previous solution and the idea is here that we have the prefix of ISS and other Dot and that will expand is times on the using the third syntax of the concept so the first things the prefix the concept which will be satisfied always is times and that will be expanded until you know is will run out and then we'll get the arc and then everything else so if you pass the RX to that we'll get everything matched into the prefix is times but we'll get the arc which is the one which we actually want to get out and then we discard everything else so uh very similar to the previous solution just a bit cleaner P plus C plus plus 20 allows us to do concepts here so requirements satisfied nothing special a bit better than the previous solution a scale far far into dark magic territory I'd say it's still faster or slower hard to say doesn't use a recursion whether it's faster than the previous one I think that would be interesting to answer whether the trickery from previously uh C plus plus uh previous C plus plus versions is better than the concept there are a lot of talks about concept Improvement compilation times because we don't have to use Spina is not an error in that case it's not that similar but we have a comparison between something which is a concept and something is not a concept and maybe one of the other is actually faster Okay so what about Library solution we have mp11 I would ask who is actually using it but I see everyone ah I have a note from someone that I made them mistake on this slide using slide 35 was an error using an arc instead of arcs a question mark I don't think as it's an error here so just to go through I'm sorry here we have the RX we propagate the arrows here and we return an arc which is the nth element and that Arc is being expanded towards ISS of number like an is number of previous parameters than the arc and then the Third yes so I think there's no mistake here but if there are more concerns about it feel free to ask me afterwards and I will try to follow through uh with the explanation or maybe there is a mistake which I just simply dancing but this code might be checked on the gold boat so I would assume it was copied I probably uh okay I see so the question has been answered uh I the mistake hasn't been confirmed okay so mp11 everyone probably who is using post and tnp knows about it it's quite neat library from Peter Dima it's really fast to compile one of the fastest if we check on the meta bench of TMP staff so it's pretty cool whether it will be fast in our case we'll see how we approach it here everything is in both mp11 and namespace so we can take and approach is the same we take a n elements of the list so we have a list of arcs we take n of them so so so that we can actually expand into the TSS here so it's very similar approach what you had before with the board after the concept right now we actually say take n element before the arc expand over them that will be the TSS because now we know exactly what that will be and then get the arc and then ignore the rest so the idea is very similar that the main difference that we actually know the nth element types and we get the empty list of them and expand over them so whether that would be faster or slower I think it'll be interesting to see readability on its own of that solution I think it's a bit better because we actually were able to hide a bit of magic into the library unfortunately a lot of it's still exposed but we can argue with it as this type in the right direction uh definitely it's a bit better in my opinion as pointed out mp11 is well optimized for compilation times so maybe we could assume it will be good but how it compares to the other solution we'll see okay and now everyone who is watching that was waiting for that and that's why you were joining this guy this talk let's take a look both pre processor uh yes as I mounted out it's something which uh probably we want on iOS in production however it has very uh certain properties which are interesting to see so the approach and the idea is quite simple we have the generation of the code uh happening for the uh different elements so in that case we have if the I equals zero that means that that's our element we get the arc and we dispose everything else if the arc if the I equals one we ignored the first one and get the second one and return that one and ignore the rest and if I equals to we would have Auto author to ignore 2 and get the third one and in order so how to do that with bootstrip processor just for the record uh I wrote this code and it compiles the first time just a disclaimer now that's not true at all but I tried so that's where we start and that's let's take a look into that what's happening here so we have the macro and we will use post preprocessor post PP repeat but we will repeat uh n times that solution is coupled by the number of possibilities in the booster processor which I think it's 256 or 124 depending on the post version so it will be limited and what is really interesting about that solution that we will compile in all the overloads up front because we have to say the number up front how many we actually support and in that case let me repeat which is let's say 256. so if you actually ask for the first element or the 200 the compilation times will be very similar in that regard because we'll have to compile all of them up front either way so I was going to be interesting to see how uh how that compares because you know we will do work up front a lot of work up front if you want to get into details of that one maybe poke me afterwards but the idea here is that we both people repeat both PP Inc is to increment is to join and and we generate the code we just provided before and most people Dimitri repeat tabs so we always try to put other end times before we get the nth element and I'm amongst one times because we get after we get the nth element and then we ignore everything else with the uh our um okay we pass that through I'm sorry if that was unclear uh I wouldn't advise anyone to actually use that but maybe the library authors may may learn something out of it so readability it's uh you know SP processor text text replacement error messages will be terrible it won't be hinting even to the right place uh in the first place and uh yeah and it won't be won't be great and it's obviously hard to read because it's just pre-processor so everything is difficult because we don't really see the code which is actually generated so how that comparatively comes to Performance that would be something we'll see later as I open it up there are multiple overloads people say like pre-compined in that case so maybe it would be good for like three compiled headers or something but uh but that's the solution that you have okay so let's dig in into some other Solutions how we can get the uh the nth element so that we can compare them in that case we'll get a strike and then we had this concept before in that case we'll have a extract because we'll try to have a different approach in which we will do the immediately for Atlanta and then here we'll create an anonymous group extract sorry that's why we don't have a name we get the any of the time of the type at the and the element we inherit from them all of them so the strike will be heard from all the past kind of and it's kind of like a pair but we can we don't have Universal templates so we have to have any which takes the T and an author but you can leverage like imagine that's a pair of type and ID you create that object because we want the value and then we will just try to get the one who will leverage inheritance here to get the one which is associated with the m so the N is coming from uh from here from the call itself but the T it will be the dust accordingly to which n is associated the T because we inherited from all of them and only one can match in that case for the given number so the one which will be inherited from and much in the n and that he uh it will be the the list and and return the T value yeah so that's one way of doing that as well and the start is anonymous here yeah some people wonder to me that's a really weird syntax uh I kind of agree it's kind of good but uh but that's C plus plus okay it's a requirements uh satisfied it's even a more magical problem on the previous Solutions because it's like we cannot look at the overloads themselves and that easily there's no other question here there's no uh not much in the overloads and parameter expansion so maybe maybe actually that will be fast maybe maybe it will be slow okay quickly let's get through the language extensions something which Clank has and we can it's really uh great for the types themselves so if you have the verdict pack of tags and you want to take n grab n alphabet that will be very easy with that solution here really fast but that's like how I believe as a like mp11 outer labor and Lamborghini and then the approach incline but in that case the only difference is that we do not use the inheritance to get the nth element because we can actually get the envelopement out of this periodic pack and then static cast to uh to the proper type which we now uh the type of because we we've just found it out by the super Puck element type element which is great for the barrel pack so this guy will return us the proper any with that given type and give a number so we can static cast it and return the value so I hope that that's similar to the previous approach probably that that's clear enough is that flexible yes [Music] readability well it requires an extension it doesn't work with different compilers so it's a bit of uh knowledge burden but I would say like my assumption would be that it will be fast because it's a compiler extension right it's feature in the compiler okay let me go into the circle uh which is the C bus pass compiler implementing by Sean Braxton and it's really powerful and has a lot of extensions Sean is working on a lot of things right now we're actually related in in circle but in my opinion is the best TMP for our house for template meta programming white button and C plus plus and a lot of approaches are related to to the circle which might be in the C plus plus imagine so that's what it is in circle we get like I came to that a bit done with the array it was very close to ideas and that's my opinion I I think that's ideal syntax there is not much else we can you know shave out of the syntax here we just get after that okay like that's expressive uh that's what we want and it's a compiler feature so it will be fast if it's implemented right right and yeah I think it can be easier but it's not C plus plus it's Circle it's a language picture I would assume it'll be fast so moving to the park declaration that's also possible with the proposal p1858 is the same syntax it's the same code if you get that proposal yes please uh that would be the uh the thing which will be able to do and it's as good as Circle yeah okay so how we can implement the get uh you know this this to a hint why we have the get as a free function of the member function why we don't have dot get it's because we would have to put the template for use cases where we have a dependent context so in order to avoid when you have t dot T dot get and we will have to write T dot template get which would be probably even more magical than anything else the committee decided to get STD get as a free function okay so that's the Tuple and right now the simplest to pull in order to implement our use case will be just leveraging Lambda expression so we have a tuple which takes the TSS and TSS will be applied by a function like a functional programming for the Tuple that will give us really leverages a leverage for that and Spark element function so you know I will get actually ticket will look like that we have the Tuple and we get the expansion of RX and we get the nth back element of the arcs which we discussed uh many times so far quickly bonus because I want to get to the benchmarks with C plus plus 14 I guess we can get actually much better Tuple interface with uh zero one two we don't have context for parameters I may never have them so underscore see is something which creates the udl which creates an object like integral constant of zero one two three and then we can easily apply and underscore C for the given uh element and that will give call the index operator and we'll avoid all these dot template magic because it's the best so how to implement that that's the whole implementation uh notice here the outer end here on the on like in the middle of the screen here it's not a end it has to be integral constant type so that we can apply it here because we don't have contextual parameters and how to get the underscore C for the number uh or just parse like C plus plus 17 I think or 14 introduced the udl for the correct for the characters like generic and we can get the number of it supporting to see underscore c will create a 42 but it will be integral constant we can propagate with the parameter and get get it applied to the certificate in that case okay Circle that's the footballing circle uh hello uh C plus plus wake up uh no unique address TS has done that I get is just a you know index operated yes if you get the proposal that will be our Tuple plus all the uh 100 Constructors we will have to implement on top of that but uh the simple version that will be it just quickly total manipulation it's kind of uh showcase what can be done with C plus 20. and that we can manipulate to pull with uh ranges it's not very important it's more an advertisement than anything else at that point of presentation because I don't have enough time but the idea is that we can apply the STD Rangers to get Tuple manipulations and Titus manipulations with is in a sense so for example if you have renders we can get a tuple we can filter reverse drop and that might be applied using this library and then we can get the static asset notice yeah the static assert where we get the Tuple manipulation of values and we can do the same for types as well so that could be a MP list or anything like that and that could be applied for December okay always measure if it comes to benchmarks and the intuition is not very good enough and always measured in a production like environment because micromesh markings might be missing so reliability on its own and all solutions have some sort of dark magic I would say only Circle and p185 is worth looking at from the readability perspective performance we have different use cases we either have a lot of tuples with less than 20 elements or we have a big two balls with more than hundreds of thousand elements the second is so something which uh which is often applied in HST because we have a lot of types which we want to for parsing which we want to apply and we will have a lot of big tuples uh so we care about the completion times C plus plus limitations at the moment account in thousands so we cannot have tax for million elements uh which uh some may imagine some may not but the limitation at the moment is Thousands how we measure the performance we get the meta bench from lydian to get get it measured it's like Ruby based a thing which generates the code for us so we we can actually measure the compilation times memory consumption and stuff uh encouraged to use so the numbers this is for GCC 12 and Clan 15. so as we see here like for elements below 20. it's sort of similar recursiveness is not ideal uh what's interesting here is that the recursiveness one is slower than a recursive two which I was kind of hinting to the fact that overload resolution is slower than if contact Square uh so that's one finding uh other findings is the fact that the fastest solution are at expansion apparently here GCC doesn't support climbing expansion right the concept expansion but we can see that preprocessor is low in comparison to mp11 and I would smash how that compares to plan it's kind of similar recursive is slow we don't really care about that also preprocessor is low and then we get to better numbers for like 200 elements out 20 it's kind of hard to measure because there's a lot of noise and uh and only the obvious Solutions are out like like recursiveness but for the bigger pack we see that the concepts expansion is actually the fastest so the expansion of our concept is interesting uh what the circle interesting about is that it's very similar I have a customers is low but what I wanted to think to think towards like all other Solutions are somewhere and that's the circle here on the bottom it's just flat basically flat uh it's it does not have an element it's flat and that's what we should strive for in my opinion that's like my outcome of this talk so what are the highlights here for small numbers below 20 is a lot of noise so there's no clear winner to just clear losers like recursion a lot of nuts recusive Solutions don't escape well multiple of Roads flower when it comes expert that's proven as well that's something which is which is maybe worth taking into account clever Solutions guys scale quite well in that circumstances for the F5 elements so if you get a get fancy we're a good time Circle upload as a language feature approach is something which just destroys the competition it's flat no matter how many elements we have it's much faster on its own uh there's like basically the stuff doesn't make sense if you just have Circle and if you have Circle we may get it actually by p18 five eight so fingers crossed for another so how that compressed to Tuple a very similar result recursiveness is slow and the fastest is actually sgdouble so that's really interesting cc12 that unfortunately I can't say but for big elements estimated to pull it even faster in this season 12 so well done they have even better solution for clan on the other hand and and for GCC Elemental losing the case so when I updated the talk they got better so maybe I had some influence about that and here we also have STD Tuple as a top which is great meaning the different approaches are applied which which I even faster what about circle circle is also interesting because I don't know you see I don't know whether you see the number but it's basically zero for Circle and uh and Tuple is the is the closed with mp11 and direct expression generally close but there's no comparison since circles so so all right so again recursiveness is slow clever Solutions are okay is pretty good uh yeah it wasn't the case for clan before Clark 14 and for GCC as well for ndcc 11. so it has been a huge Improvement so if you can update there will be a good thing for the constellation times if you apply the Togo and Circle approach to pull as a language which would destroy the compensation however circle is using ellipse C plus plus so as it's on its own the Tuple is slower and it's not as fast as Circle Tuple implementation so that's why the number for Circle here is for Tuple itself is really much slower than for silico right because it lives it was Plus but potentially the Tuple will become standard then that would be much faster like the Tuple as a language feature what is also important which I wanted to hear lastly here is the fact that there's something wrong with our compilers because GC and Clank are much slower but Circle if you compare it to you know the best solution and the worst solution in a second notice here like GCC is lower than the client but they don't compare even to Circle and the same for yeah the Tuple and that's for best solution which was Circle in that case so maybe that's not fair comparison but the worst solution which is the recursiveness part of it it's still much slower in GCC and Clan and this is a compiled slower than Clan but like 10 like five times lower than Circle so we have a lot of things to do still in order to calculate sometimes and use the incline and because Circle just can't do the same thing not faster and how does it compare to different languages quickly here I convert d-line grass Zig Circle and Clan so below 20 elements it's kind of okay everything seems to be similar there's a bit more overhead to to start with d and sorry and Zig but pretty much the same although this is interesting uh above 100 elements is that that that's clang you know it doesn't scale very well if it comes to Tuple as did you get in comparison to any other language it said pretty well but it doesn't go so far and circle is here like you can't say it because it's on the bottom right it's on the black light since we have just one minute and credibility uh you know a clever solution should be hidden behind test and user find the interfaces I think that's kind of obvious because we don't want to you know see the dark magic in front of us on daily basis unless we work in hft uh are similar performance recursion is low I think that's nothing really new but definitely do not apply live Solutions if you care about compilation times circle pack many places are super fast and scale well and that's something which we want and I believe strongly that lack of language features to manipulate and store product pack is 13 C plus plus quite a bit and if we get the p1858 that'll be much easier and much faster and C plus plus moving back to the why the stock actually happened would benefit even more and would be able to outpace in a space of the computer of the of the max performance other languages where I think C plus plus should should go to because other areas are kind of taken by the new language so with that uh yeah let's pack some more language features and uh thank you very much