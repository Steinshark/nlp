Hot Spot performance engineering fails let's do this I right away I just have a take just off the rip and I I'm gonna see how much it aligns with the article okay one thing that I hate is this notion that your performance is often just like a single problem so what you do is you build all of your stuff and then at the end of building it you profile it and what happens when you profile it you find that every function just kind of uses some time and you don't know how to make it any faster so your only answers to burn the entire the entire mother to the ground and try again like that's just the worst and so often that's at least how I read this is that often you find yourself in this hot spot myth where all you have to do is build it and there will be obvious wins and that's that so let's see where this is okay here we go developers often believe that software performance follows a potato distribution eighty percent of the running time is spent in 20 of the code using this model you can write most your code without any care for performance and focus on narrow pieces of code that are performance sensitive right Engineers like Casey have rightly criticized this model you can read moratori's excellent uh piece on his blog boom uh it's definitely true that not all your code requires attention for example it is possible that 99 of the time your code process has correct data the code that handles errors can be quite slow and it would not uh and it would not impact most your users reasonable but hotspots predict uh predicts something more precise you should be able to just keep all your code identify the specific bottlenecks optimize those bottlenecks and get great performance all around relies on an empirical evidence to falsify this model many companies Embark in large rewrites of their code bases to optimize it absolutely Netflix did this and it took an incredibly long amount of times many companies embark on large rewrites of their code base to optimize it this is like completely true I forgot to turn off alerts uh but this is like so true here's the thing that happened I remember at Netflix we had this low performing thing and things were just breaking and features were getting worse and so what was our answer to it just simply rewrite everything and use react now was that a good thing was it better I mean I guess you could argue maybe we have better developer productivity I'm not really sure how well we measured things or what was the ins and outs but uh I mean I think most people like the new code base better than the old one so you know overall pretty good you know thumbs up to that you know what I mean but is it any better is life any better is it faster no it's not really faster is it easy to let yourself slowly fall into optimization problems absolutely we see this at Netflix all the time where it just slowly grinds down and gets less less like fast and you can see memory going up and since we're on televisions it like falls apart and so just doing like trying to walk backwards your changes and trying to find the memories really really hard so I do see this a lot where it's it's often very hard now some performance issues are very obvious this hot spot thing right I would say that a lot of you can make a reasonable amount of changes in your software with looking at hot spots right you can go okay I can find this I can find this and I can find this but by doing that there's like this there's this curve that exists where it's like you find one thing that makes it slower awesome you're faster you find the next thing that makes it slower awesome you're faster you find the next thing it's not a big win but you're still finding it and then all sudden it's like you can't really find a win anymore you've just written yourself into Oblivion and so I think these things you know these things are tough and that's why I really like this Casey take on stuff why bother with such expenses if you could just simply identify the bottlenecks and fix those exactly we have tools today called profilers that can tell you roughly where your uh software spends times and if you apply such a tool to your software you may indeed find massive bottlenecks it may sometimes work wonders for example there was a video game GTA online that was loading a Json file simply optimizing this one bottleneck solved a massive performance issue this was hilarious if it did not make the game more performant but it made the start much faster so bottlenecks do exist and we should hunt them down and optimize them that's not what the hotspot model predicts it predicts that that is all you need to do to get performance boom uh let's see hit a few bottlenecks and you're done dude this is a mindset that's present everywhere and I do mean this this is a mindset that's present everywhere at every company that you write the software you don't care about it and at the end it's obvious what has gone right and what has gone wrong wrong you know what I mean real talk see this all the time sadly it does not work let's run through a few reasons overall architecture trumps everything absolutely if you first build a bus you cannot then turn that into a sports car with a few changes if you don't challenge YouTube YouTube will figure out this okay there is something YouTube will figure out you can even make react fast okay it doesn't matter that it isn't fast you can make it fast and so don't don't challenge the Ingenuity of the internet you know what I mean uh a few years ago a company came to me and offered me a ton of money if I could make their database engine faster they had money but their software was much too slow at first I was excited by the project but I started reading their code and doing benchmarks and I realized that the entire architecture was wrong they insisted that they knew where the hot spots were and that they just needed an expert to optimize a few components they told me that their code was spending eighty percent of its time maybe in 100 lines that is what the profiler said and it is true formally speaking if you could have made these hundred lines of code twice as fast the code would have ran twice as fast but these lines of code were pulling data from memory and the software cannot beat physics there are Elementary operations that are not time compressible you cannot move data faster than what is allowed by your Hardware beautiful take the key point is that if your software does not have a good overall architecture it is not well organized for performance you can have no choice but to rewrite it from the ground up to re-architect it this is a hard one this is a hard one in the sense that this does happen to people right there is this like weird fallacy where people will try to optimize the wrong thing you know what I mean there's this thing that happens where you get like you get out your profiler and you find the places that are slow and you try to fix what is slow about them as opposed to trying to figure out a different way to do it and I've definitely been there uh we had this thing uh we have this thing called uh it was like this async something something or another and it was a part of one of our internals at Netflix and it was taking up literally like 40 of all the memory was going to this one like 15 line piece of code the problem was is this one 15 line piece of code was used everywhere so it was like impossible to undo what has been done without like a full new way of doing things and so to me that was like it was pretty like wow like this is one of those moments where it's obvious hotspot optimization just optimize this one spot but the the problem is is that you've just used it everywhere it's impossible it's tough anyways I don't know if they ever fix that problem sometimes you should repeat yourself to be honest yeah sometimes you should repeat yourself and if you're working with JavaScript and you find yourself repeating yourself a bunch and you're having a bunch of this like like a really simple thing to do if you're because most of this really I think Falls hardest on JavaScript because JavaScript is extremely hard to make fast you know what I mean I actually want to make a video called why JavaScript is hard to optimize I can show you some things that just will blow your mind about how hard it is and so if you if you take it like so if you do an operation say you have to like say websockets say you have a server that takes and breaks websockets constantly and there's a lot of stuff that's going on with websockets maybe you have a thousand active websockets at any one time but maybe over the course of a day you'll do like a million websocket connections and D connections or a 10 million right uh what happens well what you should do is that websockets you have these listeners you have all the stuff you could literally create a pool of listeners that simply never recreate or destroy functions and all that and all of your listeners are set on a class and what you just handed a websocket and then it passes its already pre-made functions pre-made everything into it as listening you just invert how you do it and you can see a massive win simply because you're not recreating and destroying these things over and over and over again right uh it's not a Singleton Singleton is not the right word you create a reusable listener and then you reuse your listener I know it's a crazy Concept in the JavaScript world but it can do amazing things it's just one of those things Casper yeah cash a persistent pool cash that's called pool no yeah I did the same thing with game development yeah it's it's a listener pool yeah that's all that my girlfriend says I'm a bad listener yeah that's amazing pooling is an amazing tool to keep in mind it really is an amazing thing to keep in mind but it's a it's like an absent thing in JavaScript you know what I mean it's very very different in the JavaScript world to do that uh interested in that video about uh javascripties I want full pool of cash I do too baby that'd be the best uh optimize the hot spots multiply going back to the example of GTA online it is easy to find that the program spends 10 seconds loading a 10 megabyte uh just on file however the next steps are going to be more difficult you'll find that finding the bottlenecks become difficult we are subject to the Heisenberg Principle measuring big effects is easy measuring small ones become impossible because the action of measuring interacts with the software execution but even if you can find the bottlenecks they become more numerous with each iteration absolutely eventually most of your code uh eventually much of your code needs to be considered exactly so this happens too so for someone who's never gone through this cycle of taking the biggest uh like slow down did I say Big D did I say Big D did I say Big D I see a bunch of people like Big D Freudian slip the man wants it okay slow down first off second off that's not I didn't say that okay not what I meant you know what I meant uh yeah you did no you did stupid uh anyways if you've never done this you will fix one problem and it literally creates like four small problems and so now you've taken your one big slow function and made a bunch of little ones that are also slow and it becomes increasingly difficult to figure out what is going wrong and people don't know that like this is real and so then you get to this point where everything just takes time and you don't know how to improve it so it does get really hard there's very few times it's like literally just simple you know stuff uh the effort needed to optimize code grows exponentially in other words to multiply the performance by n you need two to the n optimizations interesting I don't know about this this seems like a dubious equation to me but okay I'll I will be on your team for that uh the more you optimize the more your code gets uh you must consider it is relatively easy to double the performance of unoptimized uh piece of code but much harder to multiply it by 10. okay reasonable if you quickly hit walls that you can uh that can be unsurmountable yep the effort needed to double the performance again would be just two or it would just be too much in effect we have long tail effect though there are clearly easy wins much of the work lies in the tail yep all that explains why companies do full rewrites of their code uh for performance the effort needed to squeeze more performance from an existing code becomes too much and complete rewrites are cheaper yep uh it also means that you should be acutely concerned about performance when you design your software if you want to avoid rewrites news told us about premature optimizations as the root of all evil this is a misquote by the way it should be all kinds of evil but he meant that before you worry about replacing your switch case uh routine with a go-to's you should work on the algorithmic design and the code architecture in effect news was pre preemptively rejecting hotspot performance engineering and you should too I actually like this take you should never you should try to build things like I like the Casey take which is always just try to build things well right and so I I just have the I have a few simple things you should do uh and one of them I'm still kind of developing a video on this and I don't really know exactly how to kind of formulate this but I'll show it to you I know I've showed it to you before is it uh what is it uh is it JavaScript I hate JavaScript JavaScript memory is it this one uh yeah yeah yeah I think it's this one map filters at this one here we go simple test so I think I've showed this once before I'm still trying to formulate a YouTube video about it but look at this it's really really simple right it just creates an array of some size and puts a bunch of numbers a bunch of numbers in it does a for Loop Does this does it reduce it sums them all together it does a four each sums them all together just does and then it runs this function a bunch of time right so we have three different ones right simple for loop I reduce or a four each to sum something and that's that and then I just do this right here and now you're probably thinking okay what's the what's going on here so let me just select node 16 really quickly there we go we got node 16. and now let's go like this uh uh let's see uh what is it uh can I just TSC this oh come on don't be like that I think that should be good uh let's let's find this uh LS dist is it in there let's see where are you JavaScript memory all right so node uh dist JavaScript memory and let's go simple test you'll see that we'll do a couple of these and they get longer and longer and longer and longer curl me Daddy yeah I named my functions the way I name my functions you don't come in here and judge me okay don't judge me don't judge me and you can see like there's like all these things that make performance really really hard when you're talking about small amounts of data you know which one of these are slower well it looks like a for Loop you know you could take from this a for Loop is 10 times faster than a reducer of four each you know what I mean what is that true right is that really what's happening how much jit is happening here are we programming something that's not optimized for jit what the heck's happening here right uh you know it's it's very hard to tell if you're doing a small amount of operations it looks to be the same but as it grows maybe it looks a little different here why is this one less than this one that doesn't make any sense they should each be larger and larger and larger but it looks like it's like this one's the smaller this one smaller but this one's larger this one must have got hit by optimization so did this one but then this one didn't get hit by the Optimus you know like there's so many ways that's really hard about looking at performance when it comes to small little tiny teeny bits of JavaScript and people do this they look at something really small and then they extrapolate using it for their entire product right and so when we look at even more so medium just means I forget what it means like 100 elements in here you still see the same thing for Loops are like 10x faster you're like okay this must be a rule and then we get larger and you see it again for Loops are now like 10x faster again and you're like see look at this it's so much better look at that of a second versus six seconds right look at that so much better right it does all this crap but then you like this n18 and you change to a new version of node you know your infrastructure has been upgraded and then you try again right and so what happens this time do you think there's going to be a difference do you think there's going to be something new here maybe not is a 4-H Loop no for each of course they're not the same yes no well let's find out all right so let's go back up to here let's just look at the biggest one the biggest one the worst one possible again look at this you still see it it's like a 10x difference reduced being way slower than four each and this one being just way faster you're just like wow look at that it's like always a 10x win this is fantastic uh and now you do it again and 20. yes we're testing different versions of V8 because they all are different you know what I mean and so now we do this again and we see what's the difference here what makes them each different you know what I mean it's not NVM it's n and now when you look at this one all sudden you're like this well what that what what the hell just happened here why is this for Loop the same as this reduce with just 10x faster than 4H now what the hell is happening with JavaScript well again it's not always straight forward what's happening in JavaScript and what happens to you know in this version of node can be completely different in other versions of node you know what I mean it's just different they find ways to optimize things that are different and so the problem with V8 and trying to optimize against JavaScript in general is you can you think you have this idea that this one thing is faster than something else and then you do it and then it turns out well guess what they made an improvement it's identical but then this one is still way slower and then you're all confused over which one you should be using and this could completely change with every version of node because they're using different versions of V8 and so what is fast on one machine may be slower on another machine and so in general whenever I'm writing code you know this is a me personal kind of thing is that like I don't use for each or reduce I always just use for loops and this includes like four const a of you know some iterator and this is just something that I tend to use I might I you know I may want to look into this more I just tend to use the more simple Loops not because they're hard they're not because they're harder and I feel smarter but because in general I usually get the best performance out of them but then I've also learned recently that even using these can actually be worse if you sure Short Circuit the loop right you can actually find yourself in worse patterns I was I did this I actually programmed something wrong where I did a for Loop and for whatever reason the return statement was in the loop and not below the loop I must have actually moved it up or down I did something stupid right so I don't know if you know this but you can like you know you can move code I must have actually just like blipped the line up into the for Loop without even realizing it and guess what running a loop one time with a return statement was literally slower than running a for Loop 22 times and that just was faster and nobody knows what the hell happened right because that's the problem is that being clever with your code doesn't mean it's gonna be faster when you're running into an when you're running in a jit environment you just have no clue and so there's this whole video I want to make about this and this article just Rings true which is how do you write code the best well in a compiled language it's more obvious in a non-compiled language it becomes excessively unobvious like it's really actually hard to know what is good code and so in general my my general takeaways is don't create memory unless if you have to if you can just follow that rule you will in general write fairly good JavaScript right everything else just whatever do that and then the second follow-up of course is don't make CIS calls if you can avoid it right that's always an easy one but that's that's true in every single language don't do that right don't don't don't don't right so if you're gonna go stat a bunch of files don't do that right unless if you really absolutely have to but don't do that avoid electron if you can exactly because you create a lot of memory you know what I mean uh it's that simple uh in addition to overhead of uh oh gosh this is moving too fast what did you say ah this reminds me of your uh pad left take their latest version of the function has logarithmic time complexity looks kind of cool yeah dude it's just it's nuts Loop unrolling is a thing yeah if you have constant if you have constant sized loops and rest or your whatever compiler can understand that you have these these nice size loops and they can unroll them then yeah it totally works out but that doesn't mean you always get that uh does n dollar wait does what you use a custom JS engine from 1973 yes I'm going to say yes that's why it's simpler uh that's why simpler code is better V8 can optimize no I'm not going to say simpler code is better I'm not going to say simpler code is better I will say smallest amount of characters and memory usage is usually always better yeah it's kind of confusing it's kind of confusing you know what I mean it's just confusing I don't know why it's hard anyways the name is the prime imagine