Hello and welcome to mCoding. Today we're talking about extending
 Python's built-in number system. We'll walk through a class that I've written
that implements infinite precision complex numbers. More specifically, this implementation models
what are called the Gaussian Rationals. These are just complex numbers where both
the real and imaginary parts are rational. As it turns out, implementing your own number
type is in some ways easier and in some ways harder than 
you might expect. Python provides a lot of machinery 
to help you do it. But there are also quite 
a few gotchas. In particular, making sure this class works with 
other existing number types like integers is a bit tricky. So let's dive in. The first issue we run into is what 
to even call this class. Calling it a fraction is somewhat misleading. Any number can be written as a fraction. Pi, for instance, which is irrational, can
be written as pi divided by 1, which is a fraction. But Python already has a 
built-in fraction type which represents rational 
numbers, not fractions. So we'll steam ahead and call it 
a `ComplexFraction`. But be aware that naming is hard. The next thing to be aware of is that Python
already has a hierarchy of abstract base classes that represent different systems of numbers. Their number, complex, real, rational, and integral. With number being the base class
of all number types, even those that may represent things
 outside of the complex numbers like quaternions. Each of the others
just add on some operations like complex numbers need to be able
 to convert the built-in complex. And they need to have real 
and imaginary parts. And they also tell you that you need to implement
things like addition and subtraction. The one that makes the most sense for
 us is to inherit from complex. There is also rational but that's not 
a good fit for our class. Internally our complex fraction is just going
to store two fractions: the real and imaginary parts. We don't want to allow storing any
 other attributes onto our class. So, we forced the real and imaginary parts 
are the only two things we can assign to using slots. This will also make our complex
 fractions use less memory. Next note that we're using
 `__new__` here, not `__init__`. That's because like all other built-in number types, 
we want our complex fraction to be immutable. Whenever you define a class that's immutable, you 
have to use `__new__` instead of `__init__`. Because although it would be uncommon, `__init__`
is allowed to be called on the same object multiple times. If `__init__` was the place that the real
and imaginary parts were set, then that could potentially mutate an
 existing object which isn't allowed. Now, of course this is Python. So, there is no
such thing as true immutability. If someone really wanted to, they could reach
in and change this underscore attribute. But in Python, it's sort of 
an unspoken rule that if you have an attribute starting
 with an underscore, it's an implementation detail that
shouldn't be accessed by the outside world. To give the outside world access to our
 real and imaginary parts, we just use properties. These properties allow anyone to read the
real or imaginary part like an attribute. But if they try to assign to it, 
they'd get an error. Also notice this little symbol 
on the left of my editor. This tells you that I'm overriding
 something in a base class. In this case, the real and imaginary properties
are required by our complex base class. Next up we have factories and
 conversion functions. It's really up to you to decide what kind of 
convenience functions that you want to give your users. Currently our `__new__` function takes
 the real and imaginary parts. We pass each part into 
the built-in fraction class. This means we're automatically supporting
anything that the built-in fraction does. In particular, we can handle rationals,
 floats, strings, and decimals. However, this doesn't cover 
all of the cases. For instance, we might like to be able to construct a 
complex fraction from a built-in complex number. Or from a string that contains both 
the real and imaginary parts. So feel free to create whatever
 factories you think would be useful. And sometimes your users don't
 necessarily want to deal with your class. In this case, they might prefer to just have 
a tuple of the real and imaginary part. And it's also good practice to give them
 a way to convert to the built-in complex type. This is also something that's 
required for a base class. Of course, to find a nice __str__ and
 __repr__ arithmetic operations. Addition, subtraction, and so on. And here's where the first big 
gotcha comes in. Why did I define this `_add` method instead of just making this the
 implementation of the `__add__` method? If you're not familiar with these double
 underscore or dunder methods, there are Python's way of allowing you 
to define for your own classes what things like plus, times, 
divide mean. So if I have two complex fractions, then `x + y` will call 
this `__add__` with `x` and `y` as arguments. And if we put our implementation in 
the `__add__` and set our `__radd__` to `None`, then our example appears to work. `1 + 2i + 3 + 4i` gives `4 + 6i`. But if you add a complex fraction 
to say a built-in complex type, then you might get 
an unexpected answer. What happened here is this `1.2` got 
converted into this crazy ratio of integers. Now maybe that is what you 
expected to happen. But what a lot of people would 
expect to happen and what's in line with how some 
of the other built-in number types work, you might expect Python to recognize
 that the `y` here isn't a complex fraction. So, we should no longer try to 
be maintaining this infinite precision. and instead just convert our complex
 fraction to a normal complex. And do the addition there. This makes the result type a plain 
old complex number. And the result is much 
more readable. And there's a subtle other 
issue lurking here. Suppose we take `1 + 2i + 1`. Integers in Python are exact. So, we're happy 
to keep the answer as another complex fraction. But if instead of `x + y`, we do `y + x`. Now we get an error. When `x` was on the left-hand side, we
 were calling the complex fraction's `__add__` method. But when `y` is on the left-hand side,
 we're calling the `__add__` method of the built-in int. The built-in int does not know how to
 add itself to our complex fraction. Resulting in the error. And this is the purpose of 
our `__radd__`. `__radd__` is supposed to do the same thing as 
`__add__` but with the arguments in the reverse order. If the built-in int indicates that it doesn't
 know how to add itself to the other object, Python will then go to the other object and ask itself if it knows how to
 reverse add itself to the int. So `__add__` gets called when self 
is on the left-hand side. And `__radd__` gets called if it can't use
 others' add and self is on the right-hand side. The implementation though is exactly the same as the other add just with the argument swapped. In this case, addition is commutative.
 So, we didn't have to swap them. But in general, like, if you were implementing division,
 then swapping them is the right thing to do. Now we'd like to solve both of our
 problems at the same time. We have repeated code that's in need
 of a shared implementation. And we want to implement this behavior of 
falling back to floating-point arithmetic if we can't do exact operations. So we introduce our `_add` method. We can now implement the `__add__`
 and `__radd__` methods in terms of `_add`, just adding self other versus 
adding other self. Then we need to add the fallback 
logic into both methods. Now if we just had add an radd, we
 might just do that manually. But because we're going to 
need to do this logic for +, --, x, /,  and any other arithmetic
 operations that you would need, instead we're going to define a function
 which generates both of those functions for us. And that's what this operator 
fallbacks does. It takes in the operation that we want to do in the
 case that we can handle everything in infinite precision. And it also takes in the operation that we want
 to do if it has to fall back to floating-point arithmetic. In this case, we're just using `operator.add`, 
which is the built-in add operation. So how does this operator 
fallbacks work? Well, the good news is that the Python
 documentation actually gives us kind of a reference 
implementation of what to do. All I did was take the function in the docs.
 And change some of the types here and there. For the forward pass, we check to see if the 
other argument has a type that we specifically support. In our case, that's any other exact
 rational number or another complex fraction. Otherwise, we check to see if we
 should fall back to floating-point arithmetic. The way that Python lets you signal to
 let the other argument try its reverse method is by returning `NotImplemented` or if this function wasn't defined at all. The integers `__add__` would return `NotImplemented` to 
allow our complex fraction's `__radd__` to be called. Instead of `ab`, we use `ba` in 
the reverse version. This is so we can keep the logic mostly
 the same but still end up with swapped arguments. Once again, we check for things 
that we specifically support. Otherwise, we check if the other 
thing is a complex number and fallback to floating 
point in that case. Notice however that these cases are
 not exactly the same though. Here we're checking against specific
 types: float and complex. Whereas here we're checking with 
the abstract interface complex. In the forward pass, we don't want to
 check against an abstract interface here because that would be a little 
bit too eager. We wouldn't want to immediately fall
 back to floating-point arithmetic if `b` happened to implement 
the complex interface. For all we know, `b` is another kind of
 exact complex number type that knows about our complex 
number type. So we would want to give that type a
 chance to do its reverse operation. We only fall back in the forward pass if we're 
sure there's nothing more intelligent we can do. I really encourage just reading 
the documentation here. I don't think explaining it in a video is
 the right way to catch all the subtleties. But in any case, we define the forward and 
reverse versions of our operations and then return them. Now we understand why it's 
written this way. We factored out the functionality of all of the 
cases that we know how to add into this function. otherwise, fall back to the default operation after 
converting to a floating-point number. Repeat for subtraction, multiplication, 
and division. Unfortunately, we have to write exponentiation 
for ourselves, both forward and reverse. This is because unlike with addition, 
multiplication, subtraction, and division, a complex fraction to the power of a complex 
fraction is not necessarily another complex fraction. So we basically just fall back to floating-point 
arithmetic unless we have an integer exponent. Handle the case of 0 separately. If our exponent was negative,
 then do one over the absolute value. And if we got a positive integer, 
 then used _fast_pow. I just made a video on _fast_pow. So if
 you want to hear more about it, check it out. But suffice it to say that it worked 
with complex numbers. For the reverse version, we're raising some base 
to the power of ourselves which is a complex number. So we're pretty much always going to have to fall
 back to floating-point arithmetic in that case. We do make one special exception 
where if we happen to be purely real, the built-in fraction class that is our real 
part might have something more sensible to do. Although honestly, probably not. Positive and negative are pretty 
self-explanatory. For absolute value, we separate out the
 case where we're purely real or purely imaginary. In that case, we can give an 
exact answer. Otherwise, we do square root of a
 squared plus b squared. The a squared plus b squared part 
is this norm squared. This isn't required by the 
complex interface. But oftentimes you can use norm 
squared instead of using absolute value. If so, that's a big win because the norm squared is always 
going to be an exact infinite precision fraction. Whereas the absolute value typically
 is not because of the square root. Then we come down to conjugate. This is required by the interface and 
it's fairly straightforward. Just flip the sign of the 
imaginary part. Then we come to probably the most 
subtle and confusing part: the hash function. The first time I implemented this class,
 I didn't realize how subtle this was. I thought, "Okay, I need 
a hash function. Why don't I just take the hash of the
 pair of the real and imaginary parts?" Simple enough, right? Well, that's no good. The reason that's no good is that I want my 
complex fraction to work like all the other number types. In particular, complex fraction 
zero should be equal to zero. It should be equal to 0.0. 
It should be equal to the fraction zero; And it should be equal to the 
complex zero. Zeros of all the other types compare
 equal to the integer zero. And more generally, whenever two numbers 
of different types represent the same theoretical value, they still compare equal. Although, due to rounding errors, of course, it doesn't always work out the way 
that we might think based off of the notation. Okay, so this might complicate our
 equality function. But what does this have to do 
with the hash? In order for sets and dictionaries to work, 
equal values must have equal hashes. That means that if I want my complex
 fraction to compare equal to other numbers, it needs to have the same hash as 
those numbers if they represent the same value. Whether it's zero, float zero, complex
 zero or complex fraction zero, they all need to have the same hash: 
the hash of zero. Checking equality is very simple. If I see something else implementing
 the complex interface, then I just compare real and 
imaginary parts. But how do you come up with 
this hash function? Well, once again it's read 
the documentation to the rescue. I don't have to come up with 
my own hash function. The documentation essentially says: if you're implementing a complex
 number type, use this hash function. I didn't come up with it. I'm just 
using the one that I found in the docs. At first, I didn't even realize 
there was an issue. Then I thought it was a huge issue. 
And then the docs just gave me the answer. It was kind of a roller coaster ride to go on. 
But I'm glad to know that it's been sorted out. Moving on we finish up with the boolean conversion operator 
`__reduce__`, `__copy__` and `__deepcopy__`. We actually didn't need to implement this one. 
It's actually included in our base class. Remember zero is false; 
non-zero values are true. `__reduce__` is for pickling. For `__reduce__` we return two things. The first is a callable that we'll use to
 reconstruct the object when we unpickle. And the second is the state. So we essentially pickle the real 
and imaginary parts separately. And then reconstruct it by passing 
it to the class to create a new instance. `__copy__` and `__deepcopy__` are kind of 
interesting since they just return self. Remember our class is immutable. So how do we make a copy of
 something immutable? There's no need to actually make a
 copy because we're immutable. So, we just return ourselves. We do need to be careful though. If someone subclasses our class, 
they might not want it to be immutable anymore. So if the type isn't exactly 
complex fraction, Then we should just pass the real and
 imaginary parts and try to construct a new one. Same thing for `__deepcopy__`. Our real and imaginary parts are
 themselves both fractions which are immutable. So, there's nothing to deep copy 
and we just return self. And with all that we now have our 
own infinite precision complex fraction type! Of course, don't forget to write tests.
 Lots and lots of tests. Especially involving hashes and 
make sure dictionaries work properly. I also wanted to point out one thing
 that I didn't talk about and that's comparisons. Complex numbers don't have 
a natural order to them. So I didn't define any of 
the less than, less than or equal to, greater than, 
or greater than or equal to methods. Since they weren't defined, 
we'll just get type errors. But if you were modeling a subset of the real numbers, 
you probably would want to define them. If you like my content, then you're also
 going to love this video sponsor: brilliant.org. Brilliant is the leader in terms of curated 
interactive math, science, and computer science lessons. If you're anything like me, then you'd
 like to learn something new every single day. And Brilliant is the perfect 
place to do that since they have thousands of high-quality 
lessons with more coming every month. You can even find courses on Python,
 computer science, and machine learning to supplement what you learn 
on this channel. So if you'd like to get 
started for free, visit brilliant.org/mCoding. Or click the link in the description 
and sign up today. The first 200 of you will get 20% off 
Brilliant's annual premium subscription. As always, thank you to my 
patrons and donors. Don't forget to subscribe! 😊