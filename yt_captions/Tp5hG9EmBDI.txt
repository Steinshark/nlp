well here I sit on a rainy winter day to record this talk for you just in front of the conference um and this talk actually will be the last one the plans broke out to stream on the D track and so I I hope I have the luxury to be with you in the chat and say hello and um you know answer your questions during the talk uh maybe I'm even having time to hang out with you a little bit in the lounge um um but we'll see so if I'm not around it didn't say hello yet then I'm probably not there maybe I done later we'll see um and to my future of me I hope the conference went well but we'll see um for now um I will be you know giving this talk I've already given in summer to my user group though it's on YouTube if you want to see it later easily to find there and probably the conference version will also be on YouTube later so hello YouTube and let's get started with this talk about how to import CSV files and let me quickly go into the slides um so hello I'd like to talk about you know how I imported CSV files into a CBE program with a standard C++ uh and let's go so this is mostly about code I've written in June July and this is also when this talk was created during like a week when I did code review and was you know having my Reflections hold up in this of my code base and was you know kind of you know putting this into this uh presentation so let's go um so motivations were that I've been dealing with CSV files this year quite a lot and mostly theoretical and now I had a practical reason to write code for it I was like really excited to do it and also was wondering what would I find into the intersection between standard C++ which I prefer for such tasks and then um ultimately having to convert the data at some point into Q types like Q string um just before we start let me say one thing on CSV files don't use CSV files right um no one uses CSV files because they think that's it's a great format it's full of pitfalls and stuff and often when you have to deal with CSV file someone else has made that decision for you uh that this is input format it's kind of the case here um but just want to make it clear that this not me um saying that CSV files are great or that you should use them um I I do think that you should avoid them but on the other hand it's wor talking about handling them because they're quite common unfortunately in everyday user land so let's see how we will you know continue on this talk is we'll talk a bit about the why where then of course go into the CSV file import itself and then talk on a little bit about the Lessons Learned why I'm organizing this conference and for 10 years I had sing events as a ticket shop it was glorious to have it I miss this event surface a bit um so the the big news last year was that sing events closes and for this year I wouldn't need a new ticket service and with that I would have a different ticket shop this year and um in summer I needed to import the data from the ticket shop into my local program to start the voting on The Talks um and it was already clear that I'd be only using the ticket service I've been using this year um only this year okay I've made the decision to stick with them for this year not to have two different ticket services in one year but I also made the decision to make a different ticket service next year as to choose a different ticket service next year okay um don't want to go too much into the details of that because that's not topic of this talk this talk is about the uh CSV import and the stickage service actually has an API but I found out that it's basically not supported and it's actually really really hard to to find support at all even with with other things and so I was like h a CSV report which I can generate and which has all the attends um probably is best to be used in this case and so that's what I went with let's quickly talk about where the data from the CSV file goes right um this program actually is called event back end that's its name um and that's what it does it's a database front end and on the next slide it's all in text there it's basically the program which contains the database and the code to manage lot of things in the conference from getting the lists of badges importing exporting attendees um writing invoices changing invoices all kinds of stuff is in this program um it handles the voting or the voting result to be precise and and so on um it's not legacy but import it this because every year I have added some new function to do something and then uh not every year this function lives for the next year and sometimes like theing service is just you know not existing anymore though this code is not dead code and I'll keep it around to know what I did with theing service when I use an API again and I kind of want to use an API again because it's a lot easier to just trigger uh the call to the API from the browser program than to manually download the CSV and then to import it into the program even if it's like you know it's not a big step but it's annoying to have the to do the nextra step um this program is built with cute and I you know I'm a heavy cute user I know a lot about cute and um this talk made me find out a lot of things about cute which I didn't know so it's kind of a good takeaway for me that my cute knowledge is now better um mentioned I did that is a database frontend so it means like all the input goes into the database and then we do something in the program if you want to create an output we get this from the database and handle it then then C++ um and so this has the disadvantage that everything looks like an SQL query in a SQL Centric application and some Parts it's an advantage because it's very reliable and other parts it's just you know it makes the code right that's more like s Centric and not C++ Centric um and again for 10 years I've been using sing events but it's not a heavy influence on the program because already back then I was like I I don't want to rely on the ticket service 100% And I don't want to rewrite all my code if I need to change it which mostly has kept up um but it's visible in some parts and sing always has been only one of the sources for the import so I do have an internal ID Etc so that I do not rely on so much on the things I I save them and I I use them where I need to use them but I don't have actually the problem that I kind of you know need to everyone just use this service um I can import other sources and have my internal ID used with them and they just you know are Mark in a different way um and as time was of the essence my focus was in summer to add to the code base and in a good way that is stable and also kind of you know kind of creating a working and reliable process for this year so let's talk about the CSV file import quickly before we start talking um CSV files only in Tapo format okay kind of want to Define this as first line is headers and field names every line has has every field empty Fields maybe comma Comma just nothing or empty quotes I chose to index by number and not by field names because I viewed this as easier um and so in the code I have a lot of uh constant int variables like size T because it's an index um that are then you know named after what it is and you know we all know the iso standard for CSV files that's I think one one of the main problems when you when you handle CSV files is there's no standard okay um I am happy and often you you will have the situation that the CSV files you get are from um the system Source program writing the export and you import it so it's kind of reliable but there's not really like a standard and there's there's some CSV libraries but it's not like that they all do the same or that Jason is you know way more standardized than CSV and again it's non-tabular csvs i' I've worked with that as a developer it's not as much fun um but sometimes those are actually standardized and you you know what field is what but that's not the case for us really um and then basically you know right you read your CSV file and read by line if you can okay so in C++ 20 we have the advantage that we can use split and SD Rangers split and gives you a view on this this is kind of nice and gives you what you would want but there's just one problem what about quotes if your CSV files is only numbers or text without the den minator in it cool nice but the vanilla case the the standard CSV file which just out there which so many people have to deal with it split cannot handle okay no way um and of course you can you know do some postprocessing to correct that and that's probably something I will look at but at the moment um split view is just splitting the view it's it's doing what it's supposed to do but you'd have to write some post processing to correct that again then quotes also mean that new lines can be in the quote and that is a whole different problem menu parse it's not so nice um again the standard has an answer to that and that is SD quoted which actually can read a quote until the end and returns that but quoted itself returns a string and not a string View and when we work with views we would like to have a string view in our case and I think it's also kind of you know somehow see it's an i man so it's it's related to iOS streams it's not really what we want would be cool and maybe I read a paper about adding functionality and stuff to quote it that's not relying on iOS streams um but that's also a different story um thankfully I am able to read perine okay so that that's like one of the things you you should check for if that's what you can expect and the say stay true by the way um so SD getline it is getline has a big advantage that we we can reuse the same string and percept the same allocation again and again again and that basically it will only grow when one allocation is bigger than the things you've read before and so it will have just very few ocations in that way and that's good enough for my case um then I do reading by character um and this works it's easy code i' purposeful y written this code in a Lambda to keep it local and maybe to Port it to some normal function later but that probably will never happen I just would delete this code after this year and we're done um say refactoring Opportunity by it's working code and correctness is more important than performance um and it's a detail and I I was thinking like hey Bo more pool um you know because you you you search a comma and a string and that's a string search right but Bo is only good if your pattern has a certain size and we're searching after a pattern which is just one character and so B hor pool doesn't work on that set well or I haven't actually really um measured that but it's something I don't expect to work so I don't waste time on it um and then yeah I do have two uh modes one of the modes is a comma and the other Motors to to read a quote and that's kind of you know how it works and then it puts the string view in the vector and returns that as a line so this passes a line from the string to a string View and then we do the processing because the next string the next get line will overwrite this uh string and make this Vector invalid and maybe even like reallocate and this Vector would you know have string use which point into memory that's potentially now dangling and the whole structure wouldn't make sense anymore [Music] um and once I had this running the first thing I I did is like you know look at your headers look in the headers of the CSV files and know the index number for what you want so this is the first code I got running with this it's like you know this what do I want and here you see this some some examples of what I want um I want the order number I want the date first name last name and then you have the opportunity to look at your data and from looking at the data I thought well those numeric IDs they're quite big so handling them as an integer would not be as Advantage as it could be right in a lookup or something um and I didn't really have any documentation from the provider so I didn't what those numbers actually represent and what the guarantees on uniqueness on them are and um also the data looked in multiple ways ordered the IDS looked ordered because they were monotonically increasing over time and with quite big differences between so this is like a global number which which is increasing on that service I guess and the date also looked ordered I've written some simple code to check this because I I was like I assume it's ordered and then I was surprised to find out oh the ID fields are not ordered I was like ah I know it's ordered by date right um no it wasn't so that's like if you if you have a if if you don't really have uh documentation that guarantees you the ordering and you find a field in your data that looks ordered um check if it really is and even if it is because if I would have looked earlier this file would have been ordered Um this can be really really troublesome and and prone to making you write code that relies on this order and then the file you import the next week isn't ordered and suddenly you have a bug because of that and maybe you don't don't even notice because an attend that isn't imported into my program um along you know I have like 102 attendees imported and not 103 would I notice that maybe not the first time um so if you don't really have like guarantees on ordering don't rely on it and it can be very very hard to find information on that um and ordering the data could invalidate the order right if I would say oh I order the data and then I you know process this and rely on the ordering um this could very easily depending on your code on what how you write your code what you do invalidate um your data and again Le two bucks um and yeah so I of course I've been wondering why it's not sorted and it's an additional step and running something in the cloud costs money so why would you sort in your Cloud where you pay for an export which is handled right also it takes longer you need to sort the data and you want to have a responsive website um and the other thing is why this happens has probably to do with ordering um there is two two folks ordering tickets and the first person comes and opens the order and then they go talk to to their boss and their boss says hey hold that I need to talk to or we need to get some internal stuff cleared before we before we can continue this order and so this order is internally in a session and at least with my ticket service it seems that they then you know have those things which end up in your order already allocated this this number exess your order Etc and then they come and complete the order the next day and in between people buy buy tickets and then you have this um that this is different in the database than the order is um and obviously also the uh the date is the original date when they started the order not when they closed it um so at least as far as I'm aware of the data I have is not ordered and I was very happy that I you know took the additional effort to see if that's the case or not and there was no documentation so if you don't have documentation on it if you don't have really really uh strong hints that ordering is something you should rely on uh don't um but you know let's talk a bit more about C++ and allocations because we're importing something and allocations probably would occur and we don't want to have too many allocations so converting from a string view toq string will allocate an STD string is one by per character and in my case it's utf8 um the Q string is utf16 which is two bytes per character and the Q string instance itself will use reference counting so that gets on gets to be on top right which is minimal in comparison to the ocation of the string um and and those allocations are the biggest bottleneck and I was like thinking how can we have less allocations and still you know I have no choice I need to convert to Q string but in the import case maybe we can reuse the Q string and in this function I have here I don't do that I was thinking about hey could I do that so this is a Bott neck and here we see that I concatenate two Q strings uh the order number and the attendee ID kind of um to get a new unique string because I need to have something which is unique which identifies an attendee into in the import right and um first time I did that I got into the SQL trap and I wondered why the import is so slore um cuz you know constructing an sc query every time the locations database connection and all that yeah not fast don't do that um but then also you know I have those allocations which are just going into my apis and not doing anything which are not even like having their own variable um kind of hot allocations if you want to name it that way and I was wondering like you know um can I I have those conversions and those allocations be more efficient can I reuse allocation in the Q string in this case to save on allocations which brings you to the whole design question should this function con to Q string convert to Q string right um it's should it return the Q string um of course this is great for usability but we have those local allocations which if we are able to reuse the Q string because it's you know it's reference counted so maybe you can um it would save us a lot of allocations and make the whole code better in performance points of view um So to avoid this parameter usage very easily we would make an OD parameter which takes the Q string by reference um another thought was like maybe the Q string has from utf8 and maybe there's a version from utf8 um to just put in a pointer in a size and have this then internally be used with the allocation of that instance um and in a perfect world I could show you the code ah would be wonderful don't yeah this is such an easy opportunity um unfortunately from utf8 a static an a static function cannot access a member function or member type I mean a member variable and so it cannot you know plug this uh converted utf8 into um into an already existing Q string it always creates a new string a new Q string instance and so um even if it has this interface of you know Char string pointer and a size type um we we cannot avoid allocating when using this um then I've wondered about this on on Twitter and brought up some interesting conversations and some of the things you've you see now in the next slides um just from that and yeah I want to point out that there is no static conversion function taking a q string either right you could make a static conversion function still and have an out parameter taking it by reference um that doesn't exist so if we convert from utf8 which we do we always add okay to scute but Q test string views and someone point out hey why don't you use Q utf8 string view which yes it's nice uh but actually I I already have a string view in the standard and it's nice to know that also cute has that and that it's actually one for cute utf8 um that's that's nice and this means like you could write generic code taken you know an auto parameter of what could be a q string view Q string or u8 Q string view um so you would be more flexible in the code you write and will be able to make that more generic there even is like an any string view so you kind of can do that but it's also you know the right J this um one thing which lets you actually also decode into Q string is a q string decoda class which I want to mention in this context um this actually helps you a little bit it preserves internal state which I don't know how much that is um gives you more control than from 8 as this internal state is not like reallocated every every time and I'm not sure if that's actually ucation with uh the from utf8 um but also this class does not do any buffer usage as far as I know okay and no one has pointed out that so far that it's able to do that so the big thing which I I want to save on the locations is also here not an option um this is an example for the Q string coder basically is a function object and then you yeah can read chunk data and um convert it and that way you don't have to you know create a conversion type with your hot Loop every time um it's nice to know it's great when you need something like that in my case I was more looking for hey can I also reuse this bite array and reuse the string but that seems not to be uh supported and then um all those Q string view classes are nice but cute itself and my code using cute is full of Q string and those instances very very rarely have now Q string View Alternatives and maybe with c 7 we get this more prominent that we have less allocations but with a with reference counting cute is probably know fine on that way and as well Q string view doesn't need to allocate um when it's passed by value um but maybe we can get a q string which is able to use its internal location and conversions like this um so unfortunately I could not get around those locations which in in my case doesn't matter so much because it's not like running on a server costing money me money in the cloud just running locally and I can go drink a coffee um the big import is done and also like you know fine tuning this every other import will cause much less allocations and run a lot faster which was true um but there still was a trick or is a trick which which you know we can do here to avoid allocations and that was that I've um created a frat set of attendees which I have and i' you know I I do import this from the database and fill it with with this with the attendees I already have and then I do not convert the attende number to Q string I can keep that into an SD string which you know still not great but that's how this you know got rid of some allocations at least and now you have the allocations which convert to Q string only if an attendee needs to be actually imported which makes the program run a lot faster um I also needed to import other things like the order data um [Music] um so I needed to create for every order an order object and not for every attendee okay so I need to you know kind of see am I still in the same order need to add it to the order object new order or yeah then you know push the the last order object into a container and start a new one um and then later right this do the database the reason behind that is that the ticket service which you know I've already kind of you know hinted at I'm not happy with um they've got actually the invoices they wrote In The Name of my company okay this is a invoice which is officially like you know it's not like it's it's written by them but it's goes on on my company so I'm like reliable for it and they got the rep wrong and people were pointing this out and I called them and yeah here the but is wrong don't you see that and they explained to me no inv is correct and what is not wrong and if if like like they were like if you need to um change that and correct it then you need to correct it to yourself and so I you know had to create code in the next step to write those invoices um which is a different process and by the way um that I couldn't tell that in summer because it didn't happen but in mid September the ticket Service uh suddenly wrote the invoice is correct because uh seemingly too many people um told them that there was something wrong with their invoices and they finally figured out that it was right um but I had their own like text person tell me that those invoices were correct from their support um and they didn't tell anything about that this would would be corrected or something um Shan strange and yes just a few folks noticed this as all and it would have not been a big problem but it was a problem for me because I'm responsible for the invoicing of my company and I cannot have a third party service write invoices which are not correct um so creating the invoices and sending them was the next thing to do which I did really nice working uh service and this has worked brilliantly um but also triggered a lot of people um requesting changes to the invoices like changes to the in invest to the invoice address or adding a PO number and that's something I didn't have to handle prior uh sing events created their own invoices but not on my company's name so if you wanted to change something in that invoice you would contact the support of King which they did have one a good one and they would do that I've usually probably never noticed those cases and this year I kind of see that this is a normal thing to do um as a conference organizer so but this is a different process and when I wrote The Talk The Code wasn't there and also um it's not too interesting um Lessons Learned yeah um I I learned a lot about conversions and how they allocate with strings and u8 and how to get around this in the design space but then having a Library which has a type which hasn't yet discovered that this low hanging flute option exists and with copy on right you of course would need to create and allocate a new string if you would be holding two instances of that string right it's a bit more complicated to implement that but most Q strings only have one instance and in that case the reference count would just needed to be checked and if it's one and it's it's getting you know written to then you could probably do that um so um then there was this year's IDs are in the billions and putting that into an integer type is not really something sensible but this is of course useful if you use this and in a map it's a lot faster to compare and a processor an in to an comparing a bigger in string um and yeah long long in is a thing could have done that but I don't want to do calculations with it uh faster indexing as I said is the main benefit internally I use my own ID which is around 7K right now and will stay like probably for a long time under 1 million I mean I I wish I had 1 million attendees at my ++ but that's probably never going going to happen um even with online event now theoretically making that possible um with strings I just you know added them the order ID and the attendee ID and it was unique and that's that's fine for this year and next year have to think more about you know do I like the next year's ticket service and are we going to stay with that um and yeah converting from utf8 to Q string will always cause an allocation and that there's like no way to reuse a buffer and no way to um have less allocations it's kind of sad um but that's the way it is and when we work with Q string and cute we do it because like Q string is everywhere and it's a common type and cute and cute itself even if it has no support for string views um and its own API still has a lot of things which could be updated to to take a C string view um and I I I'm not so much into the cute implementation that if that would make sense and where the problems f for that and where they wanted to start with that and if that's in the road map but would be interesting um and on the other hand I like string View and if I need a string view I prefer the one from the standard if I can use it um so if I work on cute and I need a cute string view that's fine great good to have but there most things um the whole View and and ranges and Views is in in the standard kind of the future [Music] and that's basically the end um thanks for listening I you know will let you know in the chat if I'm you probably know if that I'm here in the chat or not um maybe I'm busy organizing the conference um and that I will end the talk thank you and I hope to be able to to you meet you in the in the lunch um if you have any questions please put them in the Q&A tab that I can answer them um because you can't guess it from from the future but um that's probably the best process to do otherwise I let you know in the chat if I'm launch thank you and see you in the meeting C first update which is next