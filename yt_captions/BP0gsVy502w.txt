uh and one one of my long-running hobbies is getting reflection into c plus plus so this is something that i in some capacity or other i've been working on for the past 15 years so that's that is what will be the topic of today's presentation so how a potential reflection api in c plus plus would look like or could look like we will see also some examples and i hope you enjoy and that you will not be looking as confused as this poor guy so in detail we will be talking we will have a short introduction what's reflection and what is the reversal reflection other motor objects and metadata how could a reflection api be designed as i mentioned we will see some examples and use cases [Music] so what's a meta object network is some sort of representation of some base level language entity like a namespace a type a function constructor or it can represent many different things that we deal with in matters there's a bit of an issue with your sound can you switch to a different microphone okay so as what i was saying a meta object is some meta level representation or some base level language entity like a namespace type function or something else that we regularly deal with in ic plus plus program but unlike on the base level on the meta level all the meta objects all the representations are verified what does it mean means that the meta object can be stored in variables they can be used as function arguments or function written values and this provides us with the ability to write more complex reflection algorithms or even libraries of such algorithms and most of the reflection operations are invoked at compile time so this happens when the program is compiling and like as a matter of saying we say that a meta object reflects that base level entity so the meta objects provide access to metadata reflecting various things in the base level entities in the program so for example types of variables that are data members in struct and so on and so on there are like literally hundreds of pieces of metadata that we can get from the compiler and can use in some way in various use cases so on the technical level what how would they let object be be represented it can be a compile time constant value and the type of that value doesn't need to be explicitly satisfied or we are not even saying that every meta object needs to have the same type so generally we can see plus plus 20 we can define a concept which could be called meta object what is the actual definition is not really important right now it could be some compiler magic or it could be some basic template meta programming what's important is that in the api the functions are typically written or declared in this fashion so you have some function and it is typically a template and the types of the arguments are constrained by the meta object concept so this is the preferred way how the api the api function functions should be defined but you can also use the requires clause if you want to do something more complicated so then reflection is a process generally a process through which we obtain metadata or meta object and on which we can obtain the metadata in there like indirectly through some reflection operations again from syntactic point of view this could be done through a dedicated operator or some special language expression in this presentation i'm going to use this mirror keyboard so this will be basically the place or the placeholder what for what the actual reflection operator will be this is taken from a library that i have written and i will go into bigger detail later so some very trivial example would be i i want to reflect the ins type so i used that expression whatever is inside this parenthesis is the reflected base level entity and this this returns a constant value that we can store in a variable and the very basic thing that we can do with it is that we can check if the type actually conforms to the meta object concept that we have declared before the opposite operation of reflection is colloquially called unreflection or splicing or there there were some other terms used as well i'm going to mostly use reflection or splicing this is basically going back from the meta object to the entity that is reflected by the object so basically getting back to a base level type using operation of the value getting the value of an enumerator and so on and so on another example would be for example invoking a function or a constructor through some [Music] operation on the meta object which is reflecting the base level entity in in more general terms splicing can also mean emitting a snippet of code which somehow references the meta object and basically splicing it back into the program as it as if it were written by by you as a normal program construct but we can we can do some additional magic if we reference meta objects we can splice them back within that snippet of code and so on but this is this is still in the future and there are some use cases for this but this is not something that's settled so generally what is a reflection api it is a set of functions which are operating on the meta objects and these functions can be classified or grouped into various categories depending on some criteria for example their use so we have you can have some classification function saying what we are reflecting uh extracting some primitive pieces of metadata having some operations on containers of meta objects having some some more complex algorithms which are still reusable having some helper functions like predicates comparators transformation functions and we can even provide some syntax sugar likes like place all the expressions and so on and again most of this is done in the constitutive or constant expert context so this happens during the compilation the whole evaluation happens then and you just get the result of the whole computation which is done at compile time then emitted into the program so what would be the the design considerations for a reflection api let me let me just stop there and clarify what would the presented api here is we we have the reflection ts in standard c plus plus which is a temporary experimental part of the standard which has a template meta programming api this is this is considered a sort of obsolete way how to do things so now we have some other proposals we have some sort of consensus on a constable api and this is the thing that i'm presenting here is an another alternative how how the reflection api could be designed so the goals here were to have a functional style api which has some cons clear syntax it should support as many use cases as possible should provide not just basic metadata extraction operations but also some algorithms which basically algorithm library which allows you to handle various use cases and patterns and it should support composition of those algorithms and the basic functions into custom bigger algorithm algorithms which can be used in place where they are needed another very important things from the usability point of view would be proper interaction with argument dependent lookup so no x like excessive name qualification should be required and it also should be similar to the stl and other libraries like boost so a very first example how could we write a reflection based hello world program we could declare an empty structure which is called hello then we create an instance of that structure which is called called world and then we reflect both of those things so here i'm getting a meta object that that represents this structure and here i'm getting another meta object that represents this variable and very trivial operation one one of the many that are available on such meta object is getting the name so basically these things prints so we have mentioned that the meta object operations are divided in several groups so the first quite big one is the set of classification functions which tell you what what the meta object reflects or represents so you have a lot of functions like reflex named reflect enum reflex record reflex member function reflects function called expression and so on and these return a boolean value telling you like what what is the base level entity that we are looking at and this is typically used to constrain the the arguments of the function or they can be used in if constant expert clause in the condition the other big group of function is the metadata retrieval function so this return the individual pieces of metadata which are useful for various purposes and some of these functions are applicable to animate objects for example getting the source location or comparing these two meta objects reflect the same base level entity and some of them work only on specific meta objects for example to get name operation is defined only on meta objects that reflect something that actually has a name in the base level program likewise the get type function only makes sense on meta objects which reflect something like a variable or a constant or a function all of which have have some associated type so these functions can return values of various types many many functions as i mentioned written boolean values and functions that that return integers like the get source line gets sourced column functions that written other constant values for example enumerator values or pointers and references and we have some functions which written strings like get me the source file name or give me the name of the base level entity another group of operations can give you back the the base level types that that emit object reflects and then there is another very big group of operations where you for one meta object you get another meta object so for example you have some declaration which is made in a namespace and you want to know what is the meta object requ reflecting the scope of the original declaration you can call this getscope function and yeah we will we will see other ones so some slightly more complicated example would be like we we have some sort of logging api we have some there is a representation of the log and in the process of the logging we want to write down what is what is the base level entity that is related to a log message and one way how to do this would be to reflect the related meta object or meta object pass it to this function and then we can use some of the operations that i have mentioned for example i can i can check if if that meta object reflects the global scope i say this otherwise if it reflects something that has a name on the base level i can call this get display name function the prototype for which is here and you can see that it returns a string view and the parameter is constrained only to meta objects that reflect something that has a name if if neither is true then i print something else and then i have some operations that are applicable to whatever the meta object reflects or the source file uh the line and the column so these are the the operations which give you the source location information uh as i mentioned we have several functions which can give you the name of the base level entity so this get name operation is the most basic and it will give you the the immediate thing they made the immediate name how the base base level entity was was declared so for example if you reflect uh stood string you will get something like basic string then you have another operation which is called display name and this if if the compiler uh knows some some quote unquote more user friendly or human readable name like an alias you can get something like string and then you have an operation like get full name which will give you the complete type type name including all the qualifiers template arguments and so on and um i've forgot to mention but most of this api is based on the operations like they were defined in the reflection tf there are some extensions but most of the api follows that original design so then you have operations which give you boolean values saying something about the specifiers and decorators decorators like cos the experno except then you have other miscellaneous functions which can tell you for example if if a record type uses the class key or the struct key or is it a union you can ask if a lambda capture is explicitly captured or in like in some other way uh and so on and so on like currently i think there is close to 100 of various metadata retrieval functions then another group of functions which is actually doing the unreflection or splicing are these ones so for example you have a meta object that reflects a constant like an enumerator you can get back the value of the constant if you have something that reflects the variable you can again get the value of the variable you can get a variable of a record number in some particular object you can get a reference to a variable you could get a reference to a data member in a particular instance you can get the pointer again to a variable or a data member and you can also invoke various callable base level objects like functions member functions operators constructors destructors so you you can you can specify what is the meta object that reflects the desired callable what are the arguments and then this will be invoked through a unified api so then then the last group i think is the one that i mentioned already where for one meta object you get another meta object so i already described what this get scope is doing you can get a type of a variable you can get a class from base class specifier you can get a sub expression from a bigger expression that is reflected and so on and again there are these are not all the operations which are in the api there's way more and these operations allow you to [Music] get back to the type which is reflected by by some sort of net object so if the meta object reflects a type you can get back the type identity with the template parameter which is then the base level type reflected by this meta object and if you're familiar with libraries like budhana for example and other template-based cons eval or context libraries this is quite a common pattern where you use this type identity as a representation in some type and you go from from basically a value based world to types and you can do some manipulation of those types in some functional style algorithms unlike tmp where you where you would use templates or template aliases okay so then the last type of meta object that i didn't mention in bigger detail are meta object sequences and these are basically containers of other meta objects and for for various reasons it is useful that the meta object sequences are met objects themselves and they are returned by by many operations in the api so you can get the base classes all the data members all the member functions enumerators or parameters of a function and so on and one one notable thing about the sequences is that when when you get the meta object sequence the elements of the sequence are not immediately materialized so if you if you for example reflect the big name space like namespace boost which can contain like thousands of declarations and you only want to check okay is this namespace empty you don't need to materialize all the meta objects you you want to do this only later and only if it is necessary so again these are some of the functions that return sequences i mentioned get-based classes you can get the captures of the lambda you can get the constructors of the class you can get the destructors you can get the enumerator values member types operators parameters and so on and the basic operations on the sequence the first one is identifying is is a variable of some type actually a meta object sequence so this returns true or false depending on if the argument is actually met object sequence then you can check if the sequence is empty what is the number of elements in the sequence you can get the individual elements uh if you have multiple sequences of meta objects you can concatenate them and there are some other operations you will see in a second so one of the most trivial operations on a net object sequence is for each which does basic iterations this is basically the same at least in functionality to stood for each so you have some meta object sequence so a container of other meta objects and you want to call a function on each one of the elements so for example i have an enumeration of weekdays i want to get all the enumerators i i reflect that iman i want to get all the enumerators which are in in that iman type and on every one of them i want to do this thing so i want to get the name of the enumerator and i want to print the value of the constant as an integer another thing that i mentioned before this is basically syntax sugar plays all the expressions so this is nothing new we have seen placeholder and we have placeholder expressions in various boot libraries we also have them in the standard library now so there are some constant objects which are called their names are spread like this so underscore one underscore two and so on then you have expressions where the expression takes one of the placeholders as one of the arguments and what what the placeholder expressions do is they don't actually immediately call some sort of reflection operation they they create a callable object like in lambda that can be called lighter and the reason why we have the placeholder expression is that lambdas are nice and they have really short and nice syntax but with the place all the expressions you can you can shorten the expressions even even more so basically this this could be viewed as laziness but i i think that in in many cases they also uh improve the readability so there is some some syntax in the lambdas that sometimes gets in the way of understanding what's happening and the place all their expressions help with that so really quick how they are implemented so there is some template which is called placeholder expert it has some function which is stored somewhere inside it has a call operator then you have these two placeholders and for every every actual reflection operation so this would be an actual operation like get named get type or whatever else you have in another overload which instead of a meta object takes the place of the expression and it basically returns a lambda that can be called later with an actual meta object so some very simple examples of predicates so i can create a lambda that check that that will later later be able to check if a meta object reflects something named if it has a type so you you can compose them into into more complicated things uh you can you can have some comparators so you can check does do this to mate object reflect the same base level entity what is the comparison of the name of the left and the right and so on and again all of these do not do any immediate reflection operations they just written lambdas that can be used later and so the the last big group of uh place of the expressions are various transforms and here you can see that you can you can do some pretty complicated things so for example this can be a placeholder for something that has a type you can get the scope of the type you can get the name of the scope and you can get the length of the name and this is if you try to do this as a lambda it will be like more typing okay so then why why would be all the things that we mentioned before or how how can they be used in some some bigger things and this is where algorithms come into play so they they implement some small specific pieces of functionality which is not not really trivial but it is reusable and it can be combined into various even bigger things and this is these algorithms are based on the primitive meta object operations that we have seen before and they can be combined into custom algorithms in place as they are needed they can interoperate with the placeholder expressions and most of the so again some example uh this transform algorithm what it does it takes a meta object sequence so a container of meta objects and some sort of function transformation function and it goes through the all the meta objects in the sequence and calls this function and returns another meta object sequence that contains the transformed object so some some examples there is there is no operation in the api which is called get parameter types but you can very easily create one if you need it in place so you get the parameters of something which will be specified later then for each of the parameter you get the type of that meta object and you tie it together with the transform algorithm similarly you want to get the base base class type so when you when you call this function base classes uh you don't get immediately the the types of the base classes you get a meta object that combines the type of inheritance of virtual or virtual or not virtual the xs private protected public and the actual type and if you want to extract just the type you need to call this get class function and this is this is how you can use this together with the transform algorithm then you have things like filter which takes a sequence and the predicate and it returns a new sequence which contains only the meta objects which satisfy this predicate or remove it which is the opposite so for example i i want to define an operation which will give me virtual function only virtual functions so again this is a placeholder expression so this can be specified later for whatever it is uh you get the all the member functions which are there but we filter only those for which is virtual returns true the same thing for non-static data members so you can you can get the data members of something and you remove all for which aesthetic is true and you get only the static ones same with countif this is pretty trivial so you can count something depending on for example if it is public or if it if like a data member has a specific type trade and so on then you have some search functions so find if and find if not return to you the first meta object in this sequence which satisfy or doesn't satisfy this predicate so you can for example get all the member functions of some class and you you want to find the first one for which the name is full or again get me the first data member which is non-static in some sort of clause then this find ranking operation is similar to what we have seen before but it is slightly more complicated and what what this is doing is that it has it's again take some meta object container it uh takes a query function and a comparate compare function or comparator and it takes every meta object in this container it calls this query function that will give you some some piece of the metadata like for example to get the get name function or something else is static is virtual and so on and it will compare the written values by this this other functions and it will give you that meta objects for for which the value according this compare to this comparator is the largest so an example of how this could be used is that i want to get the data members of some class and for each of the data members i want to get its type the reflection the meta object reflecting its type i want to get the size of that type and this this alteration will return to me dead meta object for for which this expression returns the largest value this gets top value uh does basically the same thing as the find ranking algorithm but instead of the meta object it will return to you the actual value that you are that you are checking with this query function so in in this previous case this the result of this would be a meta object in this case it would be the metadata taken from that meta object so again i want to check what what is the maximum number of parameters in all the member functions of some class so i get all the member functions uh i get the parameters of each one of those member functions and i check how many are there of them and i want to get the maximum value of that again we will see some some more concrete examples this might seem like like why would i want something like that but there are quite a few use cases where this is some thing that you need to solve in order to do the bigger things so you will see some examples so generally i think you get the idea we don't need to go through all the all the algorithms there is quite many more of such algorithms like fold joined he sorted sword and so on all of any of none of and the idea behind all of them is that using you you could you could do all of those things that i have shown you before by writing for loops for example or template for loops but having having named algorithms uh improve the readability of the code so if if i have like three nested uh template for loops of some sequences and meta objects and i'm doing some comparisons it might not be immediately clear what what the what what the piece of code is intended to do but if you if you do that composition of named algorithm algorithms the code becomes much more readable and usually it also requires way less typing and the third quite useful thing is that uh many of the algorithms can hide some compiler magic that you shouldn't probably use directly like end user code but you can you can hide them in in for example in the filter function or in the transform function and so on so as we have seen one of the very important things of those names are named algorithms is that they can be composed in place like from some smaller pieces into something which doesn't make sense maybe it doesn't make sense to have a specific api function because maybe only one person of one developer of 1000 will will need that but the composition of the small pieces allows you to to create such algorithms on the fly in the place where where they are useful without like defining a really big api trying to cover every every use case so some examples i have i have these two enumerations or whatever enumerations and i'm interested in interested in testing if if the enumerators are consecutive they enumerate the values so here in this digits this is zero this is one and so on so these are consecutive these are power of twos these are not consecutive integers how how could i test if this is valid so this this is something pretty specific and it might not make sense to to have such operation directly in the api but i can create that operation very easily so again this is done as a placeholder expression so whatever this will be i want to get the enumerators from that meta object and i want to test if the enumerators are sorted according to this predicate so if they pairwise uh if for all of them this is true so the the left the value of the left enumerator is the same as the value of the right and numerator minus one and then we can use it several times like for for the digits it will return true for the power of two single written false you can you can want to for example you want to print some sort of table and for that you need to know what is where in the table you are printing enumerator names and to do proper alignment and padding and whatnot you might want to need to to find out what is the enumerator with the longest name so you can use the find ranking algorithm you get the enumerator the individual enumerator values you get the name of the of each enumerator you get the size and you return that meta object for which this expression returns the largest value and then then you can call it in several different places and when when you when you find that enumerator with the longest name you can you can do some some other things on it so you can get the name of the enumerator you can print its length and you can print its constant value so again i have this weekday enumeration i have this month enumeration and i can use that algorithm that i just constructed to to print to find that information and to do something with it another example does does a class have overloaded functions so there is this group by operation and that group by operation what it does it takes some again some container of meta objects in this case it is member functions and for each of the of the elements i want to get the name and then i want to create subsequences such that the the meta objects where this get name is the same will be grouped together and this will this will return a sequence of other meta object sequences where they are grouped by by the by their name and a class has overloaded functions if there is such a subsequence where the size is bigger than one so there are at least two two functions in a group where the name is the same and i test if this is true by using this angle algorithm and like here it is seven lines if if you try to do that with for loops and whatnot it definitely would be more good or yeah very very possibly so again we have these two examples this one on the left side does have some overloaded function here there are no no overloaded functions you call call it on the left one and on the on the right one and here you get through and you get false another use case i have a structure and i want to check if there is some padding so we can we can approach this like testing if the size of that structure is bigger than the size of all its data members so what you can do you can use this transform algorithm or okay let's let's get even deeper so you have you have this type t you reflect it you get the data members of that type then you filter only those which are not static then for the ones which remains you can transform them by you don't want to have the data members you want to get the types of the data members and then from all those types you want to extract the base level types what what this extract types operation does it returns to you this type list and then just by like pretty trivial meta programming with a fold expression you you sum together the size of and you compare it with the size of the whole structure and if this is bigger than the result of this then the structure has so again we have some examples this one on most platforms shouldn't have any padding but here we have this char and then it is followed by double which requires some alignment on some specific alignment on many platforms so very very probably for this structure you this algorithm will tell you s1 doesn't have any padding but this one does has something another example we can check are the data members sorted by size again i get the data members and i compare if piecewise or pairwise the the data members as we go from top to bottom if for for each one of them this this operation returns true and again you can check and for some for some more concrete and more usable use cases because the previous ones might have seemed slightly esoteric so let's let's have a look on something which might be immediately more useful so i want to implement enum to string operation so the parameter is some sort of enumeration type and i want to return a string view that that is the name of that particular narration value so again i have this choose algorithm and this choose algorithm it takes all the meta objects in this sequence so in this case all the enumerators of this type e and it chooses the first one where this is true so the the enumerator that we are testing has the same value as the value that has been given as the argument to the function and uh it doesn't just return the meta object or it doesn't just return the value there is there is another operation which is the actual result so for all the enumerators here the first one where this is true for that one call this get name operation and return that and this first parameter is the fallback so if if for some reason it happens that this has value operation if it returned false for everything then this value would be would be used as a fallback so you would get a empty string the other operation is basically the same so if you look at them they look the same way so i don't think it is necessary to explain this only these two things are switched and the return value is an optional node and the parameter is stringy okay another one this is slightly more complicated but let's say that we have some some c plus representation of the program arguments that you get in the main function so this program arc is a single argument it has some some utility function like what is the next argument following this one then you have this program arcs and this is the whole set of of the arguments and then you can do the nice c plus plus iteration of that and what i want to do is i have this these three things these are these are some generic things and i want to implement a generic function that will work on whatever [Music] structure that will take these program arguments and it will try to parse parse the options into this into this object regardless of what is what is this type t actually and here we have some application specific things which which can differ between various applications and let's say that i want to write a very simple application sort of like hello world but it will it will print the message multiple times so we have the actual message we have how many times we want to print it and we want to have some delay between each of the printouts and i want to have this generic or use this generic parse function to to take these program arguments and to automatically parse them into the structure and i don't want to implement it specifically for every every such structure because they can they can change even between different versions of an application or can be completely different in different applications so how how would i do that so what i could do is that i could use this program arguments class that we have seen before i i can go through every argument i can use this range based for loop to iterate through the arguments and within within that there is another nested loop where what i'm doing is that i go through every data member in this type t in the type into which we are parsing and for each one of them i am going to call this function and in this function i get the name of the data member i somehow compare it to the to the argument that i am currently testing the details are not really important here and if if i say okay this is this is an argument that i'm interested this might be something that i can parse into the structure i can i want to take the next argument and i want to call this from string function that will pass the value of the argument this from string function read needs to know what is the actual type of the of the data member so again i take this metadata member i get its type and i get the reflected type so this is this is another example of the of the splicing of or of reflection of the reverse operation and you can have multiple different overloads some for integers some for floating points of for chrono types or for whatever types you want to support and uh you you use this the the the result of this operation which is again the type identity that we have seen before to choose which of the overloads of this from string operations you want to call and then you then you pass the string value that you get from the argument if that was successful then you you use another reflection operation so again you take the meta object reflecting the data member you get the reference within this object and you assign the path value otherwise it prints an error message and you are done another another use case you have something like virtual interfaces many of them and you want to track the changes in in the operations within the virtual interfaces so you want to you want to know if somebody for example adds a new operation or if they change parameter value number of parameters return value and so on and you want to produce some sort of hash which uniquely identifies what is the api of that of that template interface and again the question is how how could you automate this and again the answer is with reflection so you basically reflect that interface you get the member functions of that interface you take only those which are virtual because these are those that you are interested in and for all of them you you use this get hash operation which basically calculates and unique hash of some of the base level declaration that some some meta object reflect and uh what what this thing does is basically this this makes the hash of the function itself and this makes the hash of the return value of that function uh this takes care of all the parameters of the function and you you combine them together and then this fold operation what it does it it it is sort of similar to the transform operation but it is more more generic and it basically combines all the hashes so for all the member functions you filter out the virtual ones we you calculate the hash and then you combine the hashes into a single value which you then return and this is what represents the revision id of the interface so use case i have this interface which initially looks like this and it is it is inherit in it inherits from that template that we have just seen and it has these three operations and when you call the revision id then you can get for example this value and sometimes sometime later you you do some changes for example you change this parameter type you change this return type and then if you call this revision id operation you will get a different result and this is useful for example for example for checking between two different translation units if you are dealing with the same operations and if it if it didn't change or if it doesn't have different definitions in the different translation so you can you can for example do do such tricks okay another slightly bigger example is implementation of some parts of of rpc so in remote procedure goals you have basically you typically find classes like this so you have if some sort of interface that you want to call remotely you have some stub which is some local representation in in the process where you are calling that operation uh you have some something which is called a skeleton which is the counterpart on the remote side and then you have the actual you have the actual implementation of the interface and basically the sequence diagram for for asynchronous case you typically don't do this synchronously today but to simplify this the the um the sequence diagram would look like this so you have a user that's through the through the basic interface called the stub there would be some some stub implementation which will handle the serializing and so on it will pass the serialized request to some connection the connection will transmit it to another process then on receipt of the data this the the skeleton class would be notified then the skeleton class needs to unpack the request it it needs to find what is the actual function that is being called it needs to create some space for the deserialization of the parameters then call the actual implementation get the get the return value serialize the written value use the connection to transmit it back to the start and here it is deserialized and returned to the client and this is typically currently in c plus plus handled by code generators so you you have some interface definition language and you generate all the code for these tabs for these skeletons and so on or the dispatching searching for the function serialization deceleration is typically uh generated code and we can we can if we had reflection we could actually implement a lot of these boilerplate codes like true meta programming so let's say we have this in this interface like in calculator with some operations like add subtract and so on and the question is how could we how could we automate the implementation of the stub so what what could we do is that we inherit from the interface and we we implement all the all the virtual functions within the that interface and we basically everywhere we use this this same pattern so we have some some sort of helper class that has this function called make call and it takes uh something we will get to it later and it takes the parameters so for the add function you you call this make call function and you give this lr expression for subtract you do the same and you would do the same for all of these and the question is how to do do this rpg rpc stub implementation generically so that it works for whatever interface that we are using this on so this is just just a zelda code and it doesn't show all the details but what the make call operation could do is that it would take a meta object that reflects an expression so what what is happening here is that i make a call call function call expression and i reflect that expression and the reason i why i want to do this is that i i want to get the the sub expression the actual function call sub expression which is happening there from that i can extract what is being called so the callable that particular member function that is called i want to get for example the return type when when i'm deserializing this i want to get the written type and i want to splice it back so i can i can get this type identity and i can properly the serialized so i i'm not going to show the details here because that would be pretty long but again in this this serialize or in this serialized operation you could use use reflection and automate it for quite a big chunk of user defined types where this would be applicable so on the on the other side so in the skeleton on the side of the remote process where the dispatching needs to be done you have you have some sort of virtual interface like this with this dispatch method which takes some request package and some response packet and again how how the dispatch function or that skeleton could look like it would have some pointer to the actual implementation uh you you would need to extract the the method id that is being called by this particular invocation and then you you take take all the member functions from that interface and for each one of them you call this function so you get the method id that you have extracted from the request you compare it with some calculated method id for each one of the functions in that interface and if this matches then you you you can again use this transform function as we have seen before uh you can you can use it to create what this operation does is that it creates a tuple into which you can deserialize the the arguments for the call so this will basically create a tuple with the same parameters is are necessary for for making the call to the function that we've found and identified then we can do the dc realization into the parameters tuple this is another meta object operation which basically takes the reflection of the member function it takes the object on which we want to call that particular function and it also takes the the serialized parameters so this is basically as if you typed in the expression for calling that particular function you get the result you serialize it and you send it back so this is again quite a few reflection operations and this way basically you could make the skeleton generic and reusable for for many different uh versions of of this interface type okay so another this is sort of funny one so don't try this at home but one thing you you might want to do with with reflection maybe not exactly like this is that you want to define your own concepts depending on not just type traits but on some some metadata that you can get get back from reflection so what we are doing here is that we are defining this integer concept but we don't want to use the the basic type traits because they are boring and they include for example the the boolean type and we don't want the boolean type we want only those types for which the names conform these to this compile time uh regular expression so if it is just the name int or it is the the name int with all these decorators like sun signed unsigned long short and so on then then this type t conforms to this this concept and then we can use that concept in in a function and for example in this case i don't want to to add booleans so i i only want to to add types for which this regular expression matches so it will work with unsigned types it will be it will work with shorts it will work with regular integers it will work with unsigned long longs but you won't be able to add true and false which do not conform to this okay so the last thing that i mentioned before we conclude is that before we have seen the api where you have the individual functions like we have seen the the function definitions out there are defined but for some some use cases it is quite useful to have another api so in this api you don't have many different functions you have for example just this one function which is called the has trade and all the boolean traits of meta objects are actually represented as enumerations in a like in an enum class and then you don't call multiple different functions you call only this one function and you spell the trait that you're interested in you specify as the template parameter for this one for for the other operations like get name get type get the numerators you you have uh these three functions where you first can check is is that particular operation like get type applicable to this meta object this will return to you a boolean value if it is true then you can apply that function and it you you will get get some result or you have you can combine these two into this try apply function and if this particular operation like get name is applicable to the meta object which is the parameter of the function then that operation will be called and you will get that value in an optional if that operation isn't applicable you will get an app empty option and one of the use cases where you might want to do this is something like you want to print all the trades of some base level declaration and you don't want to spell them one by one you might miss some some might be edited and so on and you you want that program to be future proof and if somebody adds new operations to the them to this enumeration or to designation you want it to to keep working uh so what you what you might want to do is that you you actually reflect this this set of of enumerators which each of which represents a single net object rate so then then you get all the enumerators you get the longest value this is just for padding for the output so this max value is used to print as many spaces as necessary so that the other column is properly aligned but what what you are doing here is that you are taking all those operations that that are all or all those traits that are defined currently in the api and you just call that single generic generic function which is called the hast rate and you call it for each one of those operations which is in that api and so the the result for example for if you reflect the stood string type you will get a really long list of various trade values so that that basic declaration is named it is an alias because it is an alias for basic string it is a scope itself it is a scope member and so on and so on so this is this is another api which is more generic and more useful in certain use cases okay so i have tortured you quite long enough so from my side to having having played with reflection for years and years i would say that reflection can be really fun it is definitely very useful and it is possible to to create a reflection api where the code is readable it is easy to write and easy to understand and it also provides not just some trivial operations but it gives you also some toolkit of reason reusable algorithms that you can combine into something bigger as as you need it so there are a lot of use cases actually have another presentation going through 10 different use cases most of which are listed here in some bigger detail and yeah so where can you find the code that we have seen here so there is there is this mirror library the current incarnation is on github this is like the seventh reboot since 2006. it is implemented on top of the reflection technical specification implementation which i have done in plank so you need to build your own fork of claim but it is not really complicated you just you can use a script which is included in that repository and it basically contains all those things that we have seen before there are some use cases which are bigger which don't fit onto a single slide there are many use cases there uh there is integration with other objects like uh other projects like the compile time regular expressions the chai script scripting engine and so on so these are the links the presentation itself it's on github it's basically my name flash mirror maybe just to mention how how is reflection going to look like in c plus plus we as i mentioned we have the reflection ts which was sort of dead on arrival it was replaced by some different api there are still some discussions or contentions whether that api how how it will eventually look like so we have presented here we have seen here one possible option and what's what's next next for reflection uh i think definitely more splicing one very useful feature would be the ability not to just splice a single type or a single value or a single namespace but to supplies whole fragments of code which which are which are referencing subnet object another thing which is sort of planned is splicing identifiers so you would be able to create your own identifiers depending on somehow meta object and supporting more use cases so yeah thanks for your attention and let's let's look at any questions that you might have thanks for the great talk matash um that was really interesting um uh during the beginning of the talk daniela asked an interesting question but i think we're gonna switch over to hubido into the questions room that's probably for everyone and so um thank you for your talk and let's have the questions in hubilo okay see you there