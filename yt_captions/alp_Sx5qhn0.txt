the rust killer I actually haven't watched this this new language is better than rust it is Zig when I first heard about the zig programming language I was skeptical why do we need another language in the systems programming space agree we already have C C plus plus rust and carbon he forgot to go when he heard C plus plus by the way a kind of a miss you should always be spitting that crap clean out in theory but I gave it some thought and there actually is a place for this language in the systems programming ecosystem and I think you should love it too in this video by the way this is low level learning if you haven't seen low-level learning great YouTuber good friend really appreciate him uh he's given me a lot of advice well we've worked out uh quite a bit we've actually been trying to figure out a way to even do a little collab and I think this would be a lot of fun we're gonna talk about what Zig is where it fits in the systems programming architecture I can tell you where it fits in and my thoughts on the language let's get into it so here we're on the website for the zig language right ziglang.org and Zig is kind of does flip edits edit this does my editor edit this guy I'm not sure I actually don't even know does because that little transition that was very flippy I I'm actually convinced right now that this guy gets this video edited by my editor all right anyways kind of a cool language because it's built around three simple principles to keep it as simple as possible okay first the language is meant to have no hidden control [Applause] let's go let's go let's go dude there's nothing more than I hate in the universe than that I hate this I hate this I hate hidden control flow and what does it mean by hitting control flow that's gonna be try catch right try catch you don't know where the hell you're going when a function throws you don't no you don't know where it's going you don't know how where it's gonna get to all you know is that the moment that it throws your whole program's gonna the band you don't even know why I think I made a nice little flow somewhere around here did I oh come on I made this really nice diagram oh yeah there it is look at this here like you can imagine this is your stack right this is the stack and say this function throws if this function throws which function is going to catch it above you and even worse when it comes specifically to JavaScript there is nothing that identifies if a function throws and to me that is javascript's worst design feature I think I've spent I I bet you there's been more server 500s there's been more wasted Cycles there's been more wasted requests there's been more production problems purely because people do not know that a function does or does not throw you just don't even know so you get all these weird production problems like one out of a thousand and you have no clue why and it's because some function you just don't even know throws you know what I mean I just hate it I just hate it so I love that that's one thing I'll always love about this language is that all right let's go back into it let's get back into it I think go handles it better I do think go handles air is better than JavaScript because even though that ghost handling of Errors is clunky it's still error first error as values there's nothing better than errors as values you must maintain that as your Mantra because the moment that you don't have that your program just goes to it's every time troll flow meaning of course go hand GO error handling is ugly but the point is it's better than not knowing right if I had to choose it goes rust or like the of the results syntax go which is like for both handling and then guess guess when error handling did you catch it no I'm not a great catcher okay just I just suck at it the code only does what you say it does there are no secret features yeah I love it two there are no hidden memory allocations the code only allocates the memory that you ask it to nothing happens I know that sounds really nice but the reality is that if I'm not mistaken you also have to like you have to you have to give an allocator to the thing and then after you give an allocator you have to use the allocator to allocate on like the stack but for me I just want to say struct whatever and it just allocates right there on the stack if I've defined Heap based objects then it just heaps right like string in Rust it's like there's a or effect in Rust like I want that to be a real thing I don't want to have to think about it all the time so I'm not a huge fan of this though I can see why this would be probably really great in a you know in embedded the embedded world to really have like a strong uh wrapping around what can and how it can be allocated I could see why that'd be great yeah I tried to write my own memory Arena once it's extremely hard I wrote it in C for wasm before like without using uh bind gen or whatever it's called Uh and and scriptum it was really hard it's in the background I got it wrong three every time no preprocessor and no macros meaning the code that you write is the only code that gets put into your program no so this is a good this is a really good debate which is are macros bad I would say pre-processor style macro something that you see in C plus plus like Define those are effectively the devil can we all agree those are the actual devil walking around on the earth casting those with he with he Wills into the to the pits of hell but macros like rust style macros I love them every macro I've used from rust I am happy it's a macro loving it loving it right and that's because it's a different one it has a very strict syntax in which you can go to you can follow it's very tightly integrated with the LSP it makes sense you identify identifiers uh expansions all that kind of stuff uh think about rust without drawer I know rust without derived macros would be a terrible language I wouldn't use it and I'm not convinced that zig's version Zig does effectively have this what Zig has is something that I would almost argue is more powerful than rust macros but also I think harder to visualize meaning that it has code that executes during compile time and code that executes during runtime so compile time compiles into more code so it's like an expansion but it's written in Zig so it's a little different let's see what again sorry let's just keep on going this comes at a time where I think a lot of languages that are meant to be low level like C for example are kind of bloated with their run times like lib C you know the program does a lot of stuff before it actually gets to the code that you write which could force you to spend your time debugging the language and not your code itself which is kind of the whole Mantra of the language right keep in mind that everything I say in this video is at the time that Zig is in zero one zero zero so it's not even at a 1.0 yet so everything in this video is subject to CH 0 1 0 0 was the most confusing way to say uh zero ten zero one zero zero nice binary solo there low level learning what's what are you doing out there that's a 10 it's not a one zero change so what are the principles surrounding Zig and where does it fit in all the other languages I would say that Zig is one level above assembly and one level below c one level above assembly one level below C but I thought we didn't do jokes below the sea level such shitty reference to tick tock don't worry about it don't worry about it um all right uh let's just keep on going stop it shut up obviously because the program has human readable syntax that is not just you transposing memory in and out of register sorry but it's one level below C because you were actually given finer control of your code than C but without all the blow when you make a program in C there there you just say see and bloat I mean I know what he's trying to say but still see it I know that's what I heard that I was like see it's bloated what I think Chad's like what the hell does that mean what do I mean by C's bloated all right let's find out what he means by season bloated this is it that is just funny I know what he's trying to say in some sense Zig feels like a higher level language than C and it does it has a lot of higher level abstractions but it's also in some sense I understand what he means by its lower level right it by default links in the C standard Library it does a lot of stuff under the hood that you're not necessarily aware of here in Zig the program is a little simpler granted there is an imported standard library but it's just not as bulky as oh gosh so again a level I believe he means stud right as we learned yesterday it's called stud it's not called it's standard no one says standard okay we all call it stud right right above assembly one level below C I'll stood let's go to the developer ecosystem which is one of the things that I'm happiest with with Zig that makes it kind of fun uh for a new programmer if you install the zig compiler which I've already done we'll make a bit like a folder color I do have one thing to say right before it keeps on going he said fun for developer stuff when I tried to do an HTTP Library I think I was I mean this must have been three months ago when I played with Zig I had to download the source code and just put it into my project I hate that Pat without a dependency manager your language can get the out of here okay I don't want it like without it I I need dependencies because I don't want to I like there's it's the same reason why I don't use dwm Window Manager right I don't want to I don't want to be in charge of patching okay I don't want to be in charge of patching I want your code to be your code I don't want some dingleberry flopping around inside of this third-party code and doing a small little change for us and then the next thing you know it's like incomprehensible and incompatible to update ever again I just I I have a very hard time with that but we'll see old Zig video when you run the zig compiler you're giving this really nice menu that kind of reads like the cargo program in Rust you're able to do things like initialize rust by the way Library initialize a folder for an exe initialize a folder for a library and do a bunch of things as key checking running an entire integrated test Suite that runs inside the program as well which is a halter video that I'll make later on this also the zig compiler can translate do you hear his dog itching himself in the background listen closely listen closely you can hear the dog video that I'll make later on this also the zig compiler can translate C code into Zig code and also act in as a drop in archiver compiler in C plus compiler a bunch of cool stuff for sick so let's go ahead and make a project real quick and we'll do Zig init EXE so here it's created the repo for us just like cargo wood and we have our code here main.zig a lot of comments here but basically all this does is it prints out some code and the code says all your code base are belong to us so to build that pretty simple nothing crazy going on here we'll do Zig uh build and then run so that'll run the compiler it'll invoke the llvm back end to Output the object and then we get our executable which gets ran all your code base all belong to us another really really cool feature that I like about Zig is that if you saw here at the bottom of our uh our source code you can actually write in tests directly into your code so that instead of Zig build run we can do Zig build test and that actually invokes every test that we write into I think that's really good I know I know it's it's not very hip today to love unit testing I still am a big fan of unit testing where it makes sense uh this is I I love testing testing should be built in I think it's a huge language flop if testing is not like a a front and center thing like even if you hate unit testing you must admit testing should be a pre-thought not an afterthought like I just think that it's just crazy town the fact that there's it's just crazy to me that like testing is not even even kind of what go did with their testing I wish they would have they I wish they would have went harder into their test I hate that you have to have third-party stuff to get good testing it just bothers me it really bothers me testing should always be first class every time um I actually so so I don't really get unit I don't get unit test anxiety when I don't have unit tests what I like unit test for honestly is whenever I come to a piece of code in which I cannot Implement within 30 seconds inside my brain right like it's not like oh I know the answer to this thing for me that screams I use a unit test as a form of implementation meaning I Implement what I think I want then I go to a test and try to drive through completion the correctness of it all right so I I I don't like tdd because tdd is you write your test and then you write your code I like to write my code get it kind of how I want I believe I've done it correctly and then do some tests to make sure that it's correct right to make sure that I've done it I I rarely test my code but when I test it it's in places in which you can't immediately understand the code right there's definitely like a I don't do red green refactor I don't do any of that I I'm a very practical pragmatic individual which means that until it is hard uh what third party thing you need for going oh uh the testing like to get good to get good testing that t Library sucks it's a bunch of if else's and I don't like I don't I want assert I want just simple diff assert like go every time you do something and go it's three lines of code right it's if this thing is not nil then fail for this reason ending squirrely brace well this might be new assert equal must be new but I just want assert I just want effing assert I want to say assert that this is equal to that that is it right and it just drives me bonkers okay so that's my only thing nice content hey love from France we'll have a good one yeah that's just a me personal situation all right let's keep on going sorry about the little sorry about like this whole like breakdown getting all excited about testing I get really excited about testing okay uh you know what I mean I get really excited about this you can do Zig build test it'll do the same thing it'll compile all of our tests and it'll say yep we ran all these functions and none of them failed so all of your a lot of tests have passed was pretty cool another by the way I'm using uh I forget I forget what unit test framework I'm using for for C plus plus but it's such a nightmare like the how I have to write my code to be able to unit test it in C plus plus is such a just a doo-doo head I hate I don't like their their I don't like their how they do abstract classes slash interfaces in C plus plus I don't like any other patterns I don't like any of it just just it's emotionally painful okay I would just like to let you know that it's emotionally painful the really important part of thing that I like is again it's meant to be a systems programming language if you've ever coded in a language like C or assembly one of the big problems is transposing your code from you know x8664 on Linux and maybe you want to move that code to a you know mips processor running Windows I know it doesn't exist but you see my point what you can do here is you can do Zig build do you see this down here you may not be able to see this down here I3 by the way hey nice I3 dude I love the fact that he has default I3 he straight up has default I3 just like me let's go that's what we're talking about get that default okay default default default default right oh it's so good I'm I'm default gang all the way attack D Target and I can say equals x86 64. I go away windows and this will actually produce a Windows executor I like that I that's awesome on Windows but it's a really really important feature I mean building a modern language today without handling all the different platforms would be just nuts I mean the fact again C plus plus you have to learn two languages you have to learn C plus plus which takes if you don't know the 21 days to learn C plus plus it takes about 90 years and then you travel back in time and then kill your previous self and boom you've learned C plus plus in 21 days but then you have to learn cmake which is like a whole nother thing this is like this just needs to be a thing exact same thing on the Windows API so really really interesting another big piece that I really really enjoyed from using this language is the security Baseline of a language so if you are learning to code but you are writing a project in C you should not be doing that because C is known to be a very dangerous I don't know that that's a hard I don't know I I you know low-level learning for the most part I fully agree with him almost universally but I do think there is something good about writing at least one project and c I think it's a great learning experience because it just feels extremely raw right uh in the sense that you're just I mean you only have a few Primitives you're mapping memory or structs over memory it just feels really raw very easy to mess a bunch of stuff up I feel like you kind of have to go over that just so that you can you can experience it I think he's saying if you're trying to ship it to other people I think I mean I've had to shift some C code to some people I think it's great to do it at least once I had to ship a driver for this thing uh let's see is it plugged in a little Netflix test device right so sometimes I just need to test stuff we call it a little odroid just like like a simple little basic uh television processor so if I just want to test on device this is something that we just internally test on because that way we can I can like I can like log on to it and see what happens I can run debuggers on and all that kind of stuff but I have to drive I had to write a video driver for that thing and so it's like it's good writing something in C is good it's good for you it's good for your soul it's good for your soul everyone should do it I think everyone should write at least one program and see and experience it this language it's very easy for a new but I can agree with you that a c for a brand new person shipping to somebody would be very difficult but my very first job was embedded programming with C shipping it to the government it was extremely difficult but it taught me a lot and see you should not be doing that because C is known to be a very dangerous language it's very easy for a new programmer to make errors when you're writing C that leave your code vulnerable to attack I tried to do this on stream I tried to use Zig to make a program that was able to be hacked so what this piece of Zig code does is it creates a TCP server it binds on a port and then it listens for a message from the user what I really really like about Zig is that it does have Security in mind from the go all the functions are being used like is uh rust splices where the types have Associated length values to them meaning it's really really really hard to allow the programmer to make a vulnerable condition in this language everything lengthwise and memory management wise is done under the hood for what they're what he's saying is is that there's no like Sterling or uh what's it called uh uh buff copy whatever what is it called stir copy what's the thing called where there's like the stir end copy versus stir copy where you're copying in versus you're copying in with a length there's like all those different ones store copy for stir and copy or stir copy in uh you know what I mean like in C you have to you have to manage between use the length versus yeah store copy I forget what it's called it's been a while now but there's like use the N ones versus don't use the N ones and the non-n ones just like every time every I print F printf like I dude I always explode myself because of that stupid uh store men buff copy and classic storm and buff copy in right For You languages I spent literally two hours trying to make this language oh and don't forget slash hand slash n gives me every time who here has not been crushed by slash n who here has not caused some damn buffer problem because you forgot about Slash n or not slash and slash zero every single time slash zero every time my life is just one big slash zero segmentation fault it happens every single time in my entire lifetime I I don't I just I hate it I get it it gets me every damn time another important piece of this language is the documentation so any new language you're gonna have to learn how to code it and the ziglang.org does a really good job of documenting the language everything from the standard Library down to the types and basically every feature that the language has you have like your vectors you have your pointer Concepts here you have your volatiles your non-volatals uh everything that the test can I pause it for a quick second why why why did C plus plus and Zig and rust column vectors is there like some sort of documentation I'm missing on why it's called a vector because like every time I hear the term Vector I I assume it's because it's it's based off the mathematical idea of a of a one by n Matrix uh you know calling it a vector but every time I hear a vector I always think like VEC three or a vek4 right like are we talking about uh are we talking about a three-dimensional one are we talking about like a quaternion stored in a vector I think it's I know just for me I don't understand why it's called a vector because I always associate a vector with like a constant time yeah out of here Betty with all your C plus plus get them out Benny comes in here trying to talk about C plus plus and so we banned that ass [Music] so get this like I'm over here and I'm all like hey well something something about vectors and then Benny comes in here starts yapping his mouth about C plus plus Karen we got C plus plus started vector oh Karen I gotta go pick up a laptop I may or may not have thrown one out of a window that needs to be refurbished do you know any refurbishers of laptops [Music] get Benny back in let's keep on going get Betty Betty sweet allows you to do is oh there's a link link it link it to me afterwards link it to me documented here in the documentation so I found that very very enjoyable ignorant also they have the entire standard Library mapped out into documentation where it shows you the types that it has and also if those types are able to throw errors you have to handle in the specific rust uh error handling scheme so that's pretty cool too I think there is a fundamental question though that is still unanswered to this language and the question is why Zig why would you have a new language like this if things like rust already exist yeah I think we are moving into a world where if you're learning a new language you should be learning type safe languages that are not breakable you know to a certain extent like rust the problem is it is very hard to justify teaching rust to a new programmer I keep going back and forth on this one sorry I wanted to pause it before he says his thing I I really do go back and forth on this at first I really do think typescript is probably the best for a beginner it's easy to learn you can move really quickly you can get somebody seeing something you can see it happening it becomes quite simple and then you can go into like a harder better language like like understand the fundamentals of programming and then learn about something that's not programming right and or you know concepts of programming that way it's like a little easier you know it's an easier transition I keep saying this but I keep kind of going back to this idea that am I wrong about that I almost feel like I'm wrong about that and what I mean by that is that if you if you think about it there's Concepts and there's like these there's unknown knowns in world right like I forget I think was it Donald Rumsfeld who I forgot who said this right there's no knowns there's known unknowns and then there's unknown unknowns but there's actually a fourth category which is unknown knowns like things you know that you don't realize you know and the pro one of the reasons why rust is super hard is because you come into it with unknown knowns you have this like construct of how you view the world and you you will you will build and and and create software in this like unknown or yeah this Unknown Known way and it's just kind of like like for me it's a huge gut thing right uh I'm I'm very very fast at uh like building software and that's because I kind of have like this internal guide but I don't really know why I do it anymore I just know that I build it this way because it it feels right and I'm sure there's better ways to build software blah blah blah but when it comes to rust and learning a language for the first time how much do you start like developing that internal guide that just makes rust even harder to build do you know what I mean yeah instincts would be a good term for unknown knowns right you know you don't know why you know the thing but you feel like this is inherently right and so I'm very curious if that actually makes it harder to learn rust do you know what I mean like maybe it is a lot harder I don't know I actually don't know I I can't say that it's good bad or or not you know you know because rust in itself is already a very difficult language I highly suggest that if you're learning to program you don't learn rust as your first language for that reason it's a very complicated language that makes things safer but you have to know what things are unsafe before you can make things safer I could buy that argument it's much easier for the user to learn this code reads a lot more like python or C than it does like rust and makes the syntax a lot easier to hold on to so where does ZIG fit in in these systems programming namespace I think where it fits is if you already know the basics of programming but want to learn a type safe language that isn't as complicated as rust and get your hands dirty with doing some embedded systems projects that don't have to take the rust language into account Zig is the language for you all yeah I'm curious about Zig because obviously there's the whole null problem there's the whole uh there's still errors are still kind of raw errors I don't know if they have enums as in like some types you know what I mean I I don't know you know like I don't know if you get the same I I worry about it I'm not sure I I'm not I don't buy that ziggs a great type safe first language uh I think typescript's a better type safe my big problem with Zig just in general is this is that C has a huge momentum behind it and I think for Zig to to win it's going to take a series of really motivated contributors to actually make zig have all the things it needs to compete with say C in the embedded world or rust in the embedded worlds right like those things are very important and they're very very hard to do right like to get enough motivated people to do all that it's a lot of work and so I think that Zig I think will continuously fight against trying to catch up until they reach a mass of people that's fast enough um I think that I I think uh embedded is a great hurdle for Zig I think that Zig I think zig's best argument is that it's a good replacement for C and it feels mostly like C uh it's less hard than rust I I would agree with that it took me less time to get something up and running in Zig uh but I don't know I still have this hard part with his uh is that until Zig has a big enough momentum in the open source world and its tooling has proper package management and all the things that's really needed to make it really slick I think it's just gonna struggle I think it's going to struggle and the hard part is that there's so many super motivated restations that anytime Zig catches up rust has already caught up plus a year ahead and so I I think that's just gonna take it's gonna take a lot of effort you know what I mean I think if you're very competent at C switching to Zig is easier so maybe that's kind of the play is that you want more type safe stuff and so therefore Zig is just like a great transition natural transition from C and also Zig has a better compiler interaction story with C right I don't know if it has like a drop-in replacement or an easy interaction with with C but I I swear I read something where it's it's very easy to interrupt between the two and linking and all blah blah blah blah blah so very curious about it is this the ruscular I don't think it is I think rust is going to win because I think Russ's biggest strength isn't that it's a systems programming language I think Russ's biggest strength is that it can act like a general programming like a general purpose programming language do you know what I mean I think that's its biggest strength and that's going to be really hard to beat because you have system capability general purpose programming language and so I think that that's really amazing I tried carbon but they didn't have a compiler what am I supposed to do write it on a piece of paper and imagine how it feels oh no right like what am I uh what am I supposed to do with carbon oh yeah look at this garbage code it's incredible one day when this I can execute this it's gonna be amazing