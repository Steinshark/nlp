okay hey dependency injection by everybody's favorite tech YouTuber code Aesthetics dependency injection is a term I don't love because it sounds a lot more fancy than it is dependency injection is simply when you have a piece of code which uses another piece of code and instead of using that code directly it's passed in instead when you pass something in to be used we call it injection we'd inject the dependent code into the code that uses it while this part is quite simple it unlocks some very powerful side effects that we're going to cover I do really like a dependency injection until dependency injection becomes the ultimate solving hammer for all things right uh because I I at Netflix we have this thing where everything became Di and eventually like every single thing was a funk door with like six arguments that's just producing it just got out of control right and I forgot to turn off alerts it just got out of control and when it gets out of control it becomes unfun really quickly you know what I mean it becomes unfun real quick we have a business app where users can chat with their co-workers they can also send pictures and files to each other when a user sends something the file gets uploaded to our attachment service I work at Netflix the attachment service is responsible for storing retrieving and processing all attachments we're gonna build up this whole service using dependency injection and we'll see what it enables us to do [Music] when a user sends a message with an attachment the message text gets sent to our standard chat Service uh or they're going to use Theo's upload thing is this is this the video dependency inject a little upload thing into this chat service is that's what's happening right now we want people to receive their messages almost Real Time by the way I heard this guy okay I got I gotta get in contact with code Aesthetics but I heard word on the street is that he built this is all in Python and it updates every single like character on the screen one at a time and goes really really fast like that that's that's what I've heard that's it it's like a super terrible implementation it's not fast but it totally is amazing no shot yeah that's what I heard that's so this service is all about speed the attachment on the other hand gets uploaded to our attachment service there's an endpoint in our node service attachment slash upload that the app connects to and uploads a file the attachment gets stored on the disk temporarily process in a few ways we'll talk about and then upload it to its final destination let's go let's go the default storage location is an S3 a part of Amazon's S3 the world's largest graveyard you thought my GitHub was a large graveyard of things people will never use again S3 literally the largest web services it's a simple storage service that lets you put up files and pull them down we have some code here that takes the uploaded file and then uploads it to S3 I'll look at all of this um okay okay unfortunately simple and elegant doesn't always like to co-exist with business while S3 is nice and straightforward and most of our clients are okay with it we have a few firms that don't want us to permanently store their data this means we actually need our service to handle multiple storage locations then depending on which company a user is from we need to put their attachments in the right place most of these picky clients just give us an SFTP server to connect to but one really wanted us to use webdev what's webdav what's that AWS does not equal simple anything I mean it's true but I mean do you see what's happening right here this is you we're about to get we are about to get ourselves into a couple little cool patterns going on here so the first pattern obviously is the strategy pattern uh you want to be able to pass in a singular item in which has an interface in which has several underlying features you know what I mean and so or several underlying implementations so we're going to get a little strategy we're going to get a little di you know what I'm talking about it feels good it feels good our first thought might be to Simply extend our upload code with some if statements ah I'm gonna vomit the upload method pass in where to upload the file this is awkward classic strategy pattern going on here okay look at it would you look at that would you look at it that's classics for a few reasons first this one class has a ton of responsibility making the code pretty ugly the code for SFTP is intermingled with the code from AWS and web dev even though they're pretty different I don't think he meant to say that but I'm pretty sure it just came out as this this class has a lot of responsibility like making the code ugly reasons first this one class has a ton of responsibility making the code pretty ugly the right abstraction when you hear it that way uh it is true this one the responsibility of this code is or the responsibility of this class is simply to make it ugly that's it it's very important FTP is intermingled with the code from AWS and web dev even though they're pretty different there's a lot of paths the code can take and that makes the code harder to understand it's impossible to do anything with right we have this one upload function which needs a bunch of info for where we're going to upload the attachment yeah it's just what info it needs is very different depending on where it's going if it's AWS we need the AWS keys if it's SFTP we need the address and private key and webdav needs a URL in auth key so we're kind of forced to have a bunch of these optional variables that need to be filled out in certain cases I think the default thing that people kind of reach for right here when they see this situation is using like a little a little mapping and generics in typescript to kind of enforce that if you pass in this type it gets these parameters which can be a little interesting not an enum you wouldn't use an enum you'd use like a type mapping to solve this typically people avoid enums they use a const as const you know what I'm talking about see in typescript remember there's a variable there's a const which is a constant pointer to a variable and then there is a const uh as const which is a constant pointer to a constant you gotta remember there's like you gotta remember there's like a lot of things in in JavaScript that you don't think about you know this makes it pretty easy for the caller to make a mistake clear as mud it's actually really when you think about it in the in the terms of of uh what's called of C it actually makes cons to make a lot of more sense yeah I see right here I see a const a con Star as a const right it makes a lot more sense when you think of it in terms of C there's a pointer there's a constant pointer and then there's a constant pointer to a constant like you got to think of it that way it honestly makes life a lot easier and finally the part of the code that actually calls upload over here needs to have all of this destination specific context to perform the upload but I I just have to find out now I'm sorry that I'm totally derailing the video but now I I gotta find out I gotta find out can you have a pointer to a constant is that something you can do in in typescript land uh can we go like this let Foo equals a uh five as const oh yeah oh yeah oh yeah oh yeah yeah yeah you could have a pointer to a constant look at that see there is the four types of pointers see this whole time so that means you can say Foo is uh a six oh never mind it's not a pointer to a constant this is stupid you can't change the pointer okay whatever okay back to the back to the thing just but really at this phase it just wants to upload the part of the code that knows best which company a user is from and can deduce where the file should go is up here at the beginning of the request yes because right now we're forced to pass all of this information around yep let's see what happens if we use dependency injection instead let's create an interface that represents our attachment storage which contains a key upload method that does what the request Handler wants to do perfect I like an attachment like it then we create three different implementations of the storage interface the configuration for each is passed into their Constructor beautiful optional variables that sometimes need to be set exactly these values and you get an error if you forget one so now once the user is authenticated and we know which company they're from we create the storage that the request Handler should use yep instead of the configuration needing to be passed all the way to the request Handler only the storage is passed to or injected into the request Handler it's not aware of which storage is passed in or where the file is going it just knows that it can call upload that said this construction code is still a little too complex to put here so let's see if we can clean this up if we look at the input here it's really just this company configuration and the output is the storage we got ourselves a little bit of a little so we can just move a little bit of a some sort of Factory going on here hey oh beautiful love you great but saving to the final storage destination is the last step of the process we have all these other stages that the upload goes through [Music] yeah we run each upload through a virus scanner does he work at Slack or teams which one is it pattern as a strategy pattern uh let's see wait how to discover the different pattern as strategy pattern I mean it's obvious here I mean this is obvious why this was a strategy pattern right uh because you had a series of if statements with a bunch of different items within it right it became very clear that under this condition you want to do it this way under this condition you want to do it that way under this condition you want to do it this other way it's a strategy right it's like it's within the name itself you need to take a different strategy based on different things so you interface it out so they all have the same input and then you have a uh then the the actual concrete implementation does something it doesn't uh di doesn't help with reconnecting sockets yes it can it can the last step of the process we have all these other states it goes through they should never know anything about it that's a real thing a socket you could wrap the socket class so it should never run it or go through a virus scanner this checks the files for signatures of obvious viruses then if the file is an image we scale it down to a Max width of 2500 pixels this is what we display to the user when they click on an image because it uses less bandwidth and loads faster classic then the file goes through preview generation this is basically the thumbnail that pops up underneath an attachment in the chat so the user can see what the attachment is without fully downloading it nice then the last thing it must work it's black if restoring the files on Amazon's S3 we pre-encrypt the files before setting them up that way if there's a security breach at Amazon we can say they're encrypted when we have to set up one of those we were hacked by the way emails so let's see how we can make each of these requirements fit cleanly into our service for the virus scanner we currently use a scanner called threat protect if you were wouldn't you just uh went there to get like the salt and the decryption I'm a little confused about that one packed blanket has much better apis and our plan is to switch to it but sadly we haven't finalized the deal with Synergy we're only allowed to test with it in our development environment not in production no worries we can create a shared interface for our two scanners strategy pattern again and initialization we pick one again this is just strategy pattern all over again over and over again that one into the request Handler the nice part is the strategy pattern works with uh with function like functional programming as much as it works with um the old threat protect scanner is created our request Handler just scans the files but doesn't know which scanner is doing it for image scaling we use the sharp Library in order to inject that we simply wrap it up in an image scalar interface the interface also contains a method which tells us if an attachment supports scaling we injected into our upload request and only scale if the attachment supports it preview generation is the most complex given how many it's just a series of strategy patterns going on here we have an interface that represents the different preview generators let me guess and then Returns the preview image we have one implementation that handles document files like word docs slides Etc one for videos which extracts the thumbnail from the video and one for images but the image one can thankfully just reuse our image scaler we just inject the same image scaler you tell me that code is about patterns preview generator yeah so we have all these preview generators but honestly the reality is is that almost all programming comes down to like two patterns the Builder pattern and the strategy pattern that's it you use a little you you use a little bit of dependency injection awesome and you couple that with a little bit of building and a little bit of uh strategy pattern you pretty much just covered like 95 of all programming right that's pretty much it that's that's all there is it's a The Observer The Observer pattern all that that's like the other one that's kind of used in its own little area right polymorphism is a strategy we only need one at a time depending on which files you need to worry about these details is it implementation we'll inject a factory which takes on the burden of deciding which preview generator to create chaining pattern is not a pattern that's like that's the Builder pattern chaining uh is a builder pattern monad is I have monads are more like tools than they are anything else is manae is a strategy I think so the factory takes in the mime type of the upload and then Returns the right preview generator to use so now the upload can simply just ask the factory for the preview generator looks good and then use it and lastly we have encryption we only have one implement this isn't complicated someone said why would you ever do this to yourself this makes life a thousand times easier simple simple understanding of a basic pattern to interface things out and to use the strategy pattern like that's that's that's very simple right there's nothing about that and it just gets a lot easier you know what I mean this is not very very hard encryption key asked word you're telling me I asked you to have the most secure password ever and you chose ask word right it's just a it's just about solid to be honest I don't do any of those of those fun little little phrases everybody uses ah it's mostly it really this is most programming okay most programming is you prototype the out of something when you're done prototyping it you look at all the places in which you failed all the places in which were hard then you implement the actual thing and that's that okay that's really all programming is and sometimes that looks like strategy pattern and sometimes that's not solid and dry dry sucks dry is one of the worst pieces of advice of all time okay because the thing is this repeat yourself there are times when you should repeat yourself if you think repeating yourself is the end game of or if you think don't repeating yourself is the end game of programming you make code okay that's why that's what happens I used to do the same thing I did the same stuff and guess what dry sucks dries the root of all evil okay first off you didn't say the phrase correctly it's second off it's not the root of all evil okay it's not the root everybody knows greed is the root of all kinds of evil proper phrase uh but dry makes things dry is what creates every framework you hate I completely disagree you go for it dry Is Not Great Dry Works just go Martin Fowler and go when you've repeated yourself three times then refactor I think that's a pretty good rule of thumb right you repeat yourself twice not a big eye you know not a big deal try wet and get some is that whap what ass programming is that is that what that is I've never tried what ass programming but I I hear it's I hear it's great rotation of encryption but think about all these like little phrases dry solid whap all those all those things it doesn't matter write your function to do a thing write your function to make it easy to test even though you may never test it boom you've literally solved like 95 of all problems you'll ever run into okay this this like strategies people come up with all that it's just experience that's all it is just you won't think about I don't know anyone that's like oh assault okay okay assault a solid here we go single purpose no one does that use AES but the key is per user and comes from our lab is the only thing that we need so we inject our key service into the AES encryption and then the AES encryption into the storage Factory yep this is Enterprise programming whatever we get a request for a company that's configured to use AWS the storage Factory injects the AES encryption into the new instance of AES storage then the upload request gets this final constructed AWS storage and simply calls upload without knowing that there's this whole chain of connected functionality yep yep this is good and now we have our complete architecture you can see that our service there's that you know one thing coda Curtis does is he has he has nice code Aesthetics things ever but in the moment of like reveling in your own creation the music it rises and now we have our complete architecture [Music] it just circumcises that music clean off just give us give us and give us a second to Revel in it maybe you know just give us a moment that was like the crescendo let us have the gasm don't don't just take it from us this is configurable from this one spot which makes it super easy to change once our deal with Synergy security goes through it's just these two lines to change our service want to add preview support for a new file type it just slots in like this no access to the key server when running the attachment service on your local development box no worries we can just use a fixed key when running locally injection basically just lets us pick and choose from our compatible puzzle pieces and then slot them in when we need them yep you'll notice that he I mean he is missing the fact that it's it's the strategy pattern that allows for the picking and choosing its dependency injection that enables the passing it in right there's there's a there is like a very important difference right there but time in which the currencies are injected varies a bit a few dependencies are resolved and injected right at startup this is often the most common scenario in dependency injection but some dependencies are chosen and injected when a request comes in in either case their process is mostly the same we have some code that accomplishes something it lists the dependencies it needs and so we fulfill those needs you might want to review generator factoring interfaces and injecting things when we only have one implementation this man has done a lot of implementation of encryption well there's one big thing we haven't talked about if you look at our architecture here most of our components talk to each other through these interfaces which are injected in this means that each of these connection points we can control what is being used we've been using this to choose which implementation to use in our production service but we can also make them use no implementation we can use injection to inject fake or mock implementations instead yep which basically means we can slice and dice up our architecture to isolate sections of code during testing let's say we want to write a test for our AWS storage class we can use a fake S3 which we run locally that pretends to be the cloud service yep then our task can call upload and we can verify that a file got uploaded to S3 but because of the encryption we can't actually check the content of the file this is why a lot of times I always say there's kind of two parts of code you need to write there's the logical part of the code and then there's like the i o async part of your code if you can long as you can separate out those two facets it makes it really easy to test without a whole bunch of mocking I'm not a huge fan of mocking I'm not a huge fan of all those things uh there are a few times where it's necessary I'm not 100 convinced it's a great thing but you can do it this way and verify that by the way another great reason why a squeal light is amazing uh squeal light allows for you to uh just like point to a file right so you can you can create a database that is in the perfect condition CP that file to a new location and then just run like run the thing as a full-fledged end-to-end test and it just does the right thing and then you can assert the database at the end there's something that's really cool file file file databasing of squeal light is one of the coolest like features of all time not to worry let's inject a mock encryption that basically just disables encryption when the AWS storage class asks us to encrypt a file we'll just hand back a file that isn't actually encrypted now our test is able to verify fully that uploading and only uploading works because we've isolated it away from our dependencies I generally have a hard time with these type of tests you know what I mean because you're not really testing anything you know what I mean like you're testing you're not real encryption is not really encrypting you're testing that you're not real S3 storage is not really S3 storing right you know what I mean like I always have whatever it gets into this level of Di and testing it's just like what exactly are you testing because then you are testing that you're calling all these things your coverage goes up which adds business value I I feel like end-to-end tests that actually do the right thing because the problem is is that you know this type of testing is great and all but you know what you see right away right here what do you see right here there's no try catches there's nothing that's actually preventing issues and what do you see right here none of this will ever cause an error right there's like this whole problem of error testing and what actual errors will return from actual Services versus these dumb things that you write to In-Place Services I always have a hard time this does not feel like testing code to me honestly this does not feel like code I would test there's nothing here this is just like one giant grab everything and that's that right it doesn't there's there's nothing here that that seems worthy of being tested in my personal opinion what if we wanted to test encryption well we could mock out the key store to return a key that we control all the way I don't think there's anything worth unit testing or if we wanted to integration test both our AWS code and encryption code together we could do that by injecting our fake key store into the real encryption and then inject the real encryption into the AWS storage a key thing here is that this is easy to do a natural side effect of having nice code is that it's easy to test without needing to hack around the code structure if you find yourself how can I test a private method or I need to set some internal variable in order to test that's a signal that you maybe need to pull some stuff out that you need to isolate some part I see the word mock down there I don't want to see any of that get that get that but I like this good job with this video I truly think you only learn stuff by trying stuff so for those subscribed to my patreon I'm going to start including some light experiments with videos for this one you can download the attachments I'm going to reconfigure the service by changing the dependency injection and then you get to win some aesthetic points if you enter the results on the site points go up go up highly recommend that you go back here and you go and find this man with patreon you go and you go patronize him give him some petrification okay do it great video I loved it the testing part you know I always I always am on the fence with that kind of testing I always I see it so often but the rest of it beautiful perfect exactly the way exactly the thing I wanted to see you know what I mean great video love that you guys should all take this to heart because there's some really good programming techniques in there but I will make one kind of thing that I feel like is really important there's one caveat I want to add to all of this that's extremely important which is don't do those things right away all right notice what he did in this video he fixed code that was too complex he did not create code that was all perfect and perfectly dependency injected out and everything no no no no no no start with the bad stuff okay see ya oh camel my camel bye camel my camel start with the bad stuff understand your program and what you're creating and then start pulling things out you gotta absolutely do that right it is one of the most important things ever people often abstract entirely too fast it I just see it all the dang time I start bad refactor the worst there you go the proper way to go about this um someone said can you can you give us an example what dry is not good I'd have to go look at it but when you repeat yourself three times consider refactoring okay three times then consider refactoring you know what I mean uh then your manager says all right next thing yeah it could be um anyways just some thoughts of mine new lighting I see I know I'm still working on the lighting I'm a little green okay I'm a little green I'm sorry for my greenness the name is am I dead to Jen am I I can't boom look at that crispy finger look at that crispy finger again