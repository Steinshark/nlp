welcome to the first episode in my series on asynchronous web applications in Python I'm calling it asgi fundamentals we will cover fast API Starlet and a few other very important libraries however fast API does way too much magic to really understand from a top down approach even if you go to definition and try to read the source code there's a lot of implicit understanding that they don't spell out we've got fancy decorators that somehow map paths to endpoints we just turn a python object and it somehow gets converted into an HTTP response we've got pattern matching inside of paths that somehow turns into arguments to the function and not to mention using pantic for custom models and schema routers sub applications exceptions background tasks and even the little things like authentication but thankfully you don't need more and more specific tutorials to tell you how to do every little thing in fast API what you need is a tutorial that teaches you the fundamentals that's my goal for what this series is meant to be all right let's start as low as we can go with the fundamental building blocks and go up from there to start you're going to need to know how to raise your own goats Wait no that's a different tutorial the first thing you need to understand is the asgi specification that's asgi asgi not ASI once you finish this video you're going to go to this website here I'll put a link down below and you're going to read the entire ASI specification and then and you're going to read it again and then you're going to bookmark it because you're going to be coming back to it again and again and again it's not that long it's like a 10 to 15 minute read and it defines the standard the asgi standard for how a server is going to call into an asynchronous python application under the hood all the asynchronous python Frameworks are building off of this standard so you really need to read it so what is the purpose of this standard in the first place here's an artist depiction of some data that might be sent to to a web application convert it to bytes and ship it this is pretty much exactly what a message to a server might look like but if I'm building a python web app this is not really the level of data that I want to be working with I don't want just this one big long thing as a string or bytes object could I write a parser for this yeah probably would I make a mistake yeah probably and don't you dare even think of trying to do it with regular Expressions especially since HTTP has a lot of corner cases and you might end up trying to parse a request that looks something more like this than the easier example instead of making application authors worry about all the corner cases of HTTP and parsing let's define an interface let's define a standard for the kind of results that we want to see in Python when we get a message like this and how to communicate those results to and from the outside world well great great news that part's already done it's called ASI so what do ASI tell me about what an application looks like the asy speec puts most of the heavy lifting onto the developers of the protocol server something like UV corn which is in charge of handling all the web requests connections raw HTTP data stuff like that but for the application author they make it incredibly simple an ASI application is a single asynchronous callable that's it it always has the same three parameters a scope dictionary that defines the scope of a connection an asynchronous receive function for receiving events from a client and an asynchronous send function for sending events to a client we've raised the level of abstraction away from raw bytes and instead our Primitives are now these event messages that are dictionaries real python dictionaries all event messages have a specific type and different types of messages have different other fields the application callable is called once per connection the scope tells you the details of the connection and within a single connection you can receive and send multiple different messages a connection could be a single HTTP request response cycle where I first receive all of the client data I come up with my response and then I send it to them if they're uploading a big file I might receive many events before I send anything back or if I'm streaming data to them I might receive just a few events and then send many events or a connection could be a lot longer lived like a websocket connection all right let's start building up our very first ASI application we Define our async def callable it takes scope receive and send I've taken the liberty of type hinting these already you can pause here and take a look at the definitions if you want although they're pretty straightforward so a scope is just a dictionary a message is just a dictionary the receive is something that you await to get a message and the send is something that you give a message to and then await in order to send it the most popular server for Asi applications is uvicorn so we're going to be using that that's going to be the thing that takes raw HTTP stuff and then converts it into this scope receive and send for us all this app does is count how many connections it's received and print out the scope we use a global to keep track of how many connections we've seen and then we just print whenever we start and end the current connection which since we're not receiving or sending any messages is going to be really fast let's go ahead and bring up our terminal in order to run it you can see as soon as I start the application I immediately get one connection now this is not a real connection this has a special type called lifespan this is like a fake connection that the application uses in order to do start up and shut down things we can see a real Connection by sending a curl request though of course we get an error because we didn't have actually Implement anything but the main thing that I want to note is the scope here so this is what the scope of an actual HTTP request looks like we have some version info about you know which version of ASI it's using we're using HTTP 1.1 server and client host in Port the scheme is like HTTP or https then we have the HTTP method like get post put or delete this root path is for when you have an application that isn't mounted at the root of the URL don't worry about this one for now and then we have the path and raw path I don't know why they felt the need to give us both of them I think the raw one is actually optional it splits off the query string which came from here then of course we have all of our headers for the HTTP request and finally we have this state dictionary so this actually is just a copy of this state dictionary during startup you'll get this lifespan startup connection you can put state in there and then that state will just get copied a shallow copy given to each request in order to make our app functional we need to just look at the type of these connections that are coming in and then handle different ones based off of their types so here's what I'll do I'll just paste this in check the type of the scope and if I see a lifespan type then I'll basically pass everything down to a separate Handler that handles just that type of connection or if I see an HTTP event then I'll send it to a separate HTTP Handler I give give both of these the same scope receive and send that the main application received because both of these are basically acting like their own little sub applications that are just receiving messages tailored for them let's head on up and write the lifespan one remember this scope that has a type of lifespan is supposed to represent a connection that spans the entire life of the program with that in mind I'm basically waiting for two events a start up and a shutdown this time when we run the server we again see the lifespan connection but we also see the first message which is the startup message the application won't accept any other requests until startup finishes so if I try to curl it again I'll actually get a failed to connect and it's actually a little bit worse than that you'll notice that if I try to kill it with contrl C it actually won't even shut down this only seems to happen if you don't complete the startup process correctly normally you can control C to kill it uh but for now we'll just have to kill minus 9 okay and there we go to complete the startup process successfully we basically just have to listen for the startup event and send a startup complete when we receive it similarly to prevent Badness when shutting down we listen for the shutdown event and then send a shutdown complete now this is using receive and send but this is not receiving and sending to an actual client this is just talking to the protocol server starting the server again this time we'll get some info messages because we actually completed the startup and if we contrl C to quit and go back up then you'll see that we actually handled the shutdown event right when we did the control c as well okay so how do we handle an HTTP connection well let's start off by just seeing what kind of messages we receive back to the server and do a curl request and then so far we just get one message that is an HTTP request that has an empty body but if you look closely curl has not actually completed here it's hanging sort of waiting for the response from the server and the server is hanging waiting for curl to finish so I'm just going to go ahead and kill this and we're going to see something a little bit weird when I did a control C on curl that close the connection once the connection is closed if you ever try to await receive a message you'll always get this HTTP disconnect message this isn't something the client has to actively send to you if the connection is closed one way or another then every time you await receive it you'll always get the same disconnect message okay so lesson learned if we ever receive one of these HTTP disconnect messages then we should break out now we run our server and run the curl again and this time when we kill it it just immediately ends but the real problem here was that we kept waiting for a message even though the client said there was no more body if we see that they don't have any more body to send then we break out of the while loop our response is basically made up of two messages the first is a start message where we put the status code and the headers let's just print that out and then await and send that message then let's immediately follow it up with the body of the response regardless of whatever they sent us we'll just hit them with a k then go ahead and send that so this now represents the entire life cycle of an HTTP connection request so we get the request coming in we receive the entire message uh potentially multiple messages if they disconnect then we stop once they say there's no more message then we go ahead and start sending our response where we just respond with a 200 and hit them with a K all right let's see it in action start it up again curl and there it is okay in the logs here we see after we Reed their last message we start sending the response and we get an info message from uvicorn saying it recognized that we sent a 200 okay for that request let's try sending a post request next this one I think is pretty representative of a typical username and password that we see in the wild once again we responded with a K but before we did that we can at least verify that we see body of the message contained that username and password um and we see in the headers that it was form URL encoded content type and that it was a post request I'm not trying to fool anyone it's not pretty but I hope you can see that at the very least you can piece together the most basic version of something that might resemble a real production application I can say oh okay I received an HTTP message for a specific path if it was Slash Echo then use this Handler if it was SL status then use this other Handler if it was a post request use this endpoint if it was a get request use that endpoint I have the information here to at least respond to requests in the way that a normal application would that you're familiar with that would look something like this I just check the scope and see if the path is to slash Echo with a post request then I'll call an echo endpoint and pass in the same scope receive send if I see a request for/ status that's a get request then I call some other endpoint you could even do something like try to match the path against a regular expression and then use the captures of the regular expression the groups in the regular expression and pass those as extra arguments to the endpoint huh it's starting to feel a lot like what the big Frameworks are doing doesn't it well it's no surprise this is basically exactly what a fast API router is it's just a smaller ASI application that's being called by a bigger one and if you were to look into all these end points you you would notice a lot of commonality like how they receive all their request data and how they send all their response data Whenever I send a response I always send a response start status maybe a content type here and then I send the body well let's take a look at the Starlet response object so if you're not familiar with Starlet a fast API application basically inherits from one of these Starlet applications let's take a look at the response type in Starlet so this is Starlet code the plain text response inherits from response and sets a media type so what is response let's scroll down render and it headers headers set cookie delete cookie where is it ah we have a Dunder call and what do you know it's an async death function it takes a scope a receive and a send and what does it do it sends two messages a response start with the status code and headers and then a body with a body all of the response objects in Starlet and therefore in fast API as well are not much more than just little rappers around sending these two messages and then maybe doing a background task afterwards we've barely started to put the pieces together by no means is this a complete picture but I hope this is enough to show you my vision my vision for the series is to help you understand from the ground up these building blocks that way when there's some feature that Bast API doesn't have or that it does have and it just doesn't quite work the way that you want it to you're not stuck you won't be limited to copy pasting simple examples you've seen online if you understand the fundamentals you can build something great on your own if you especially like my content the best way to support the channel is to become a patron on patreon so thank you to all my patrons and donors for supporting the channel my company also does code reviews Contracting training and Consulting check us out at M coding.