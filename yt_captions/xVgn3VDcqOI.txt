uh good afternoon everybody and welcome to my talk C++ common knowledge uh my name is David zesi and um yeah and that's about it so you're going to hear about common knowledge items uh that I think might be important might be not I think they're important uh why this talk uh you know I have a hobby and this hobby is quite uncommon now nowadays I'm reading books and I especially like reading very old programming books like for example this one uh something that tells you about how the C++ came to being or this one a bit more advanced uh about the C++ object model or or actually this one there is a book with the exact title somebody already had this idea before uh those Book used to be quite common right so in the past years you would go to a Blog to to read about what's happening in the world but there used to be times where you could read those books and that's how you would get your knowledge about everything uh the last book here is actually targeted at roughly intermediate audience but I wouldn't say so there are very Advanced items there there are very beginners items there uh it's a mix of everything but it's something about you know something you should all know about but sometimes we are not aware of it and and especially if you're coming from different programming languages or if you're not touching some part of the language sometimes you might not be aware of it uh of some of those uh I kind of decided to make a talk like this but it's a bit different one so I'm not going to talk about the same stuff that are in the book and especially I'm going to modernize it a bit so there are different items totally different there around 100 there no time here right to cover 100 items much less and I have a very short program to show you what's going on uh this program is really full of bugs uh it's like the most buggy one I I think I've written ever uh it fits on less than A4 uh and on two slides this is one of the classes there it's a very prominent class it's a based class for other classes just has two data members and a very curiously looking uh conversion operator uh there is another one there uh because obviously the first one converts to the named object so you must have a named object somewhere well that's the name object uh something to admire right just the name inside and a uh equality comparator so operator for comparing itself with another named object and just because you know I I know how to program I added for a good measure also a free function comparison operator that compares to object that piggy backs on the first one so it's a canonical implementation right you just call another comparision operator nothing wrong here you most likely have seen Wars I mean people write desktop applications in JavaScript right so this is not that bad uh it's all this work is not done for nothing uh there is something that uses named collection base that's a named hip it in from it and it's a hip data structure so something that makes it easy to pick up the biggest or the smallest number this actually keeps track of the smallest and the biggest value so it allocates or actually it has some data members for it data Max data mean arrays dynamically allocated a proper Destructor a proper Constructor that constructs everything and of course it follows the rule of five so it also has a copy assignment copy Constructor move assignment move Constructor everything that you want and then I'm using those two classes or actually three classes in together together uh mostly I'm going to use the named Hep uh and that's not much of a usage I assume there is a function that needs a collection uh passing by a unique pointer very modern right so uh you can hint polymorphism coming up because I'm passing by a pointer and I'm using the Base Class name in The Pointer and there there is a hip being created uh a copy of a hip being created uh also all unique pointers very nicely uh and then I want to pass actually my copy to the function and because I'm a careful programmer and don't trust myself I will first compare if those two are equal uh if it's okay I call the function needs a collection uh surprisingly this code compiles uh it compiles it builds at least if you're compiling with C++ 20 or maybe 23 even I think I you need it for one feature uh and it builds without any errors there are not that many warnings also triggered and you might miss them uh not very important warnings Clank and GCC show you two warnings msvc shows one uh and that's all uh the program unfortunately uh I think crashes or runs forever or something like this uh despite not you know being compiled and despite being very short uh if you apply your common knowledge and common sense to what you've done or what I've done there are more than 10 violations very big violations of things you shouldn't be doing at all whatsoever and you know if you're a bit familiar with C++ and about what C++ is about you should have picked up all of them or not all of them is maybe too much but at least five of them there are more than 10 and in particular what I've been doing is not initializing data members uh cause triggering undefined Behavior multiple times uh allowing implicit conversions which is not that great right confusing assignment with initialization violating one definition rule uh a little not that much totally neglecting aay II and exception safety uh leaking memory I was leaking memory believe me or not I was doing it uh I was totally ignoring cons roles uh triggering infinite recursion on the way uh that's there on the slide uh slicing objects and making name Lop look up cry totally cry um so let's try to fix those and uh fixing is fixing is quite easy uh I'm just going to walk through uh in total 12 different items that are not intended to be read now that there are why they are mingled uh which will help us fix the program and we're going to go from the simp simp rules to the most uh I wouldn't say difficult because we are still Somewhere In The Beginner's intermediate level of C++ but things that will help us figure out what's going wrong what's wrong and hopefully uh will help you figuring out these kind of Errors if not in your code then sometimes maybe if checking beginner's code uh which you are reviewing when you hire new colleagues for example uh the first one uh a very common one uninitialized means indeterminate right uh we all know it in C++ you have to initialize everything because the compiler is not so nice uh I was actually triggering undefined Behavior not like this but I was triggering it in a similar way you see the named collection base is doing something totally awful it has two data members that's great but it also has a Constructor it's a user provided Constructor it doesn't do anything right it doesn't initialize anything uh and that's already like code smell because it means that the name will be properly initialized the compiler will call the default Constructor for the standard string but unfortunately the size will stay uninitialized its value is indeterminate uh reading it is undefined Behavior formally uh you know if you get rid of this ugly Constructor everything will be fine now our Cloud becomes an aggregate uh uh and because we have braces when we initialize the NCB everything is good no problems whatsoever uh if you skip the braces again undefined Behavior that's something that might be surprising but that's how Aggregates are initialized uh the lesson keep the braces around somewhere and the best way of of course or the best place to put the braces is directly in the class with the so-called inclass member initializers right if you do it if you even put some initial initialization there you're good to go there is no undefined Behavior triggered whatsoever whatever you do so it's a better way of doing things uh let's do it item number two declaration order is initialization order a very very very common error especially if you are beginning with C++ I've done it also I committed the same crime on the slides uh and I I think the crime is now pretty obvious when you look at it right so what I intended to do is of course to have three data members data mean data Max and the capacity that's my declaration order and I was hoping for that different initialization order like in my Constructor I first initialize capacity and then I'm using the capacity to allocate to arrays uh unfortunately that's not what happens right declaration order is initialization order especially when it comes to classes or only when it comes to classes actually when it comes to everything right so in whatever ordered I declared the members in my class in the same order they will be initialized it doesn't matter what you write the compiler is smarter than you uh which pretty much means that at the stage when I'm initializing data mean and data Max uh those two are actually the capacity has an indeterminate value I'm reading something value that doesn't exist I know nothing B will most likely happen right because very likely there is a zero there if you are lucky but it could be that you're alloca allocating a couple of gigabytes and that might not go that well uh your hard this dis most likely won't get formatted contrary to what people tell you about undefined Behavior right so don't worry about it uh nevertheless it's bad uh a simple fix put your data members in the right order H and then everything is fine uh which brings us almost to the next item right this is fixed uh we are done uh or not to the next item to the application of the first item when we initialize data members why even initialize them in the Constructor when the initializer is fixed to 16 in this case just put it there in the initializer list uh directly in the list of the members and you are done this will be fine whatever you do uh now unless of course you mix the order uh the next one assignment is not initialization uh two things that are very often mixed right uh and people especially coming from different languages tend to put assignment when where the initialization should happen uh we have even special Syntax for initialization nowadays the Carly braces right right uh sometimes it looks very ugly uh but in the constructors it doesn't uh what you've seen on the slide on the first slide or on the second SL was the first second slide let's say was something like this and it's still there uh what I'm doing here is of course my named hip is inheriting from the named collection base so obviously is must initialize the data members of the named collection base right so it has to initial initialize the names and the size and for the Simplicity I'm just initializing the name here uh I'm doing it in the body of the Constructor uh but that's not really the place to do it right that's that's actually the body should be totally empty like most of the ca cases maybe some logging statement something like this uh those of you who've been programming a lot know that all the initialization happens in a different place particularly here so even even if you don't mention anything there even if you don't initialize your members or your base classes in the member initializer list the compiler will do it for you it will just sneaky call the default Constructor for a class or in our case it will initialize the aggregate the named collection base uh by calling it yeah there is no default Constructor for an aggregate but let's say default Constructor right uh that's a bit wasteful we are first initializing and then overwriting those values again in the body of the Constructor so first for example The Constructor of the standard string will trigger in the default Constructor and then we are you know overwriting this value why do it at all uh if the compiler can do it we can also do it just put it there where it belongs to using the aggregate initialization syntax uh this has the benefit that the size will be initialized to zero also uh without explicitly mention in it and we are kind of good to go so assignment is not initialization uh item number four implicit conversions are almost almost always evil you shouldn't do them I've done it twice on the slides on the slides with the program uh the first one was quite obvious and it didn't trigger any nasty Behavior actually so I have a con Constructor the named Hep which takes a standard string is the so-called converting Constructor right it converts from one type to another uh and it does it I mean there is no harm you might think and I agree you can write you know Silly code like this uh there is no harm in it it's just to confuse your beginning colleagues maybe it will compile just fine uh doesn't make any sense but you can do it uh where the harm really comes into to play is situations like this imagine you have like a function crunch the numbers intensively uh something you are likely to see in many code bases and it takes a named hip of double by constant reference well now you can call this function with something like this one little two little or know one medium and one big number it will compile just fine right it doesn't make any sense whatsoever uh might be just a practical joke uh it's a good joke I would say even uh won't do anything because this hip is empty that you are passing uh to the function but nevertheless it shouldn't happen disable it just don't allow something that stupid sometimes converting Constructors makes sense but here absolutely not why would you convert from a string into the hip make this Constructor explicit and you're done the conversion becomes impossible at least implicit conversion uh there is another case of this of the same thing uh and that's this one uh look at it I'm comparing two hips or actually I comparing two pointers to the named collection base and that's quite weird because if you remember then know the named Hep cannot be compared there was no comparison for it uh the named collection base actually also cannot be compared but it has this operator inside that converts it implicitly to the named object and the named object can be compared right we had the operator uh equality comparison implemented so named objects can be con compared and just because of this this whole chain of events we now can compare to named collection based or or for that matter even the named hips doesn't make much sense right I I mean most likely two hips are not equal when their names are the same that's that's not really the case disable it disable it by marking something like this explicit I'm saying it should be explicit but you will be seeing it again uh without the explicit when we are talking about a different item item number five everything needs to be defined just once it's about uh the one definition rule something that scares people and it should because it's it's very very difficult lingo in my opinion uh but the concept is very simple uh my code I mean looks good now right I already applied at least two different refactoring to it to to fix many problems but it's still not really as it should be uh specifically I have a magic number there at least in this version of code and this magic number uh shouldn't be there I should name this constant I I should name this number somehow so it's easy to track so so it's easy to reason about it so let's put it outside uh and that's actually what also I had in the beginning slides it was put outside now the problem with this is that such a piece of code usually leaves in a header right and you already can smell the disaster coming when you include this file multiple times uh this is something like a named hip looks like something that's going to be used a lot around our code base so imagine this scenario a very simple scenario uh we have the named Hep with the definition of a variable there uh in the global scope and we have two different source file the number cruncher where the function crunch numbers intensity comes from and the stat Sprinter both of them include the header both of them are compiled uh produce object files uh and then the Linker comes in and the Linker says no uh the Linker will tell you that you have a multiple definition of the same object uh esecially it will complain about the K Cup being defined twice at least uh it's usually a very ugly error it starts with LD and that's how you recognize it if you are on Linux uh so and then you have to start looking where it is uh there a rule in C++ that says that everything needs to be defined once and only once uh it in any of that or not among all the translations units that are put together by the Linker so if you have multiple translation units and in this case we do have you know source files are usually known as translation units and the same name def is defined twice in different translation units you are cooked the rule only applies to variables and functions nothing much more and things that are not in line so you can mark it in line like for example or your members of a class are automatically marked in line and you don't have this problem this is not in line Solutions very easy uh either make it like a con expert something or a static something and the problem is solved like it's not a variable anymore uh or make it in line uh nowadays we have this pleasure of applying inline to VAR to to the variables uh it has a very curious effect the Linker now will accept multiple definitions of the same symbol but you have to promise that they're the same the Linker doesn't check it uh you can make very nice practical jokes with it so uh but you shouldn't uh and if we are actually talking about it uh why just not put it uh you know inside the class it's by default now in line whether it's Conex per static or not and the problem is solved anyway uh item number six only fully constructed objects benefit from a aii so resource acquisition is initialization the very ugly you know name um not ugly but something that's very hard to explain right to people uh for something very simple Can you spot the problem here uh I mean I'm pretty sure you can some of you can spot the problem here uh and the problem is uh I'm actually having two resources and I'm allocating those resources let's simplify this class a little so those are my resources right remove everything that's not needed and now we have just two Dynamic arrays and let's have the happy scenario we are calling the construct RoR uh it in the process of calling the Constructor the data Min is allocated on the hip everything goes fine and now the data Marx is yeah it's not allocated we get the St alloc error something very unlikely to happen but generally speaking you know errors do happen in the construction uh not Stog maybe but something else on the other hand you might be on an embedded system resource limited system and Stog will happen uh now the big question is what happens now we just allocated a resource right we just allocated a piece of memory on the hip we have to free it but we have an exception in the Constructor uh so the million dollar question is does this delete ever get called right and the answer is no this delete won't ever be called uh because there is a rule and that's actually what ra is about that the destructor is is guaranteed to be called for every fully constructed object this is R AI distilled to to to the basics now what is a fully constructed object right because that's another question a fully constructed object is an object for which at least one Constructor fully finished this is not the case in our I mean in our scenario uh you might try to be smart I also tried to be smart many times before I knew better and do things like very exotic things like like this one like function try block the things exist you can rob the whole function in a TR catch block uh also the Constructor and hope this will work right uh no it won't uh it won't because first of all it's illegal to refer to any data members in the catch block of the Constructor you just cannot do it it's undefined Behavior like plain blank uh and secondly uh even if you could I mean yeah what's the value of data Max now assuming that data marks through I mean it's indeterminate right you don't know it might be null if you're lucky it might be something else so you might call delete on a pointer that's not really pointing to something for data Max so it's dangerous even to do it you don't want to do it and anyway you will get the exception because the exception will be rethrown by the Run time uh what's the solution to the problem uh well the solution is actually quite easy uh if you look at it uh and apply the rules that the destructor is called for every fully constructed object you might come up with something like this let's make a default Constructor that does absolutely nothing uh it will actually use the default initializers that initialize data Min and data Marx to n pointers and let's delegate the job to it in our real Constructor and this will magically work actually this works because you know the default Constructor will not throw it does nothing and once it's called the object is fully constructed you benefit from the destructor and the destructor will do its job because only the objects that allocated something uh will be non null uh but it's ugly uh and you shouldn't do it because for example it breaks rule that I said be that I mentioned before that in initialization is not assignment I am now doing exactly this right so you shouldn't be doing it uh and if you look very closely at it uh you might realize after some time that actually if you get rid of one of those data members uh like this uh you don't need any special handling anymore right uh because if data mean allocates everything is good now the destructure is called and you are good to go if it doesn't allocate well who cares the destructor doesn't have to be called also we don't care uh this might lead you to another item that what R AI really means is one class one resource especially one class one Dynamic resource this is what AI stands for and with this one uh you might come up with something like this right but now we are in this ugly situation that we lost a data piece so of course we abstract away directly and create a type like dynamic memory that keeps around just an array and the size of this array uh which pretty much is a kind of a vector right but okay uh and then put it in our class instead of what we had before uh quickly realizing we don't need any Destructor whatsoever because everything is taken care of automatically by the by the runtime now uh and if we are at least with C++ 11 we quickly should realize that this is what unique pointer is for right ored Vector for and not your manual uh memory management uh which brings us to a totally different item item number eight uh member functions have an extra disc parameter or an extra dis uh argument passed to them uh it's a very found item that really goes into the object model of C++ and how things happen in C++ that helps you understanding how more advanced feature works like deducing this that has been kind of there in the language now right and you can use it uh we're coming back to the base to the name object because this is where really a lot of bad things are happening right this named object overrides or sorry overloads the inequality comparison so the operator not equals to with another named object and you might think that when the compiler say sees such a function what it does uh it kind of looks at it like this but this is not true what the compiler truly sees is more something like what we see on the slide so there is a function operator not equal to that takes two parameters instead of one and the first one is the implicitly injected or implicitly uh yeah injected is a good word here pointer to the current instance named this and that's pretty much all it's there it's always there if you don't believe me go to the assembly look at what the assembly is generated it's always there unless it's optimized away of course because sometimes it is optimized away but it is there this pointer exists uh why does it matter why is it important well it's important because I am making very grave mistakes uh partially because I don't understand how this relationship Works uh I have a member function and as I mentioned before there is also a free function which piggybacks on the member function it's a canonical implementation yeah that's how you should do it actually you have you should have one function one should call the other uh NE negating that the other that that's how it's done and then imagine of course after inlining it because you know that things like this should be inlined that I'm creating two named object and comparing them against each other if Alice is equal to Bob great our chain call looks like this first we compare those two then obviously because it's equal equals uh then we call the free member uh sorry free function operator uh which in turn because it's internally calls not equal to uh will go here right uh I mean that's what we are hoping for unfortunately that's not really what happens right uh depending on which compiler you are on which language version you are you are either not compiling this code at all or you are getting an infinite region here and I think the first solution is much better actually uh it's much better to have a compilation error than just get getting stuck somewhere without any clear reason why the infinite recursion well look at this what I'm doing there is comparing uh in the implementation of the equals equals operator I am comparing to think so we already know that what the compiler truly does is something like this it calls the member function or it tries to call the member function it seeks to call the member function uh that's implemented inside the named object uh and it rewrites it to match the parameters into something uh like operator not equal to address of a comma B so it's trying to match the parameters right remember that there is the first implicit argument to this operator is the pointer uh then it comes up with the types for those and what it comes up with is that the address of a is a pointer to the const named object and B is just reference to the const named object right and it's con in both cases because we qualify both A and B with const so there are con objects there is no other way and unfortunately this doesn't match our operator our operator uh is not const the first implicit pointer is not const so the compiler will say no uh I'm not going to call your member function and since I am on C++ 20 I'm going to apply a very cool rewriting rules that I am able to apply nowadays what are the rewriting rules uh basically since C++ 20 uh whenever a compiler says uh equals equals or not equals to and it cannot find a matching function it is allowed to rewrite the expression into the opposite expression and and negate it so basically it cannot find not equals to here so it is allowed to rewrite the expression into something like this great we have a full match right now we know what's been called uh and that's why the infinite recursion we are calling ourselves infinitely in the loop and actually that's one of the warnings that GCC and and Clank trigger uh the other one was the mismatch in The Ordering of the Constructor and the Declaration of the arguments of the members but this one is something that Clank and GC will warn you about and you might scratch your head then very often because you don't see the recursion but it's there be careful about it uh how to fix it well you just have to understand the second role of of playing with this that con member functions have cones this parameter right uh this is what we have right this is what the compiler now sees when it looks at the not equals to operator this is what we want to have uh very easy things to achieve just put the con keyword after the member function and you're done this function does qualify that sorry this Con does qualify the this pointer it's it's really confusing with this all the time I know uh but nevertheless this is what truly gets qualified the this pointer that's implicitly passed uh to the member function and now everything is okay our chain call is as it should be so we are calling from the bottom one uh to the inline operator equals equals and this one in turns will call the last one the inequality comparison and everything goes as expected uh is there something we can fix about this code I mean now that we know about the rewriting rules and we are anyway compiling for C++ 20 I think there is plenty of opportunities to fix this code uh like if you know that the compiler anyway synthesizes the other one why would you write two of them like one is enough the compiler will make the other one anyway uh so let's do it and with that one let's introduce another a bit more advanced item and especially I think if you are in writing sometimes codes that's used by somebody else that should be known to you uh otherwise you might be surprised about it or might not know about it uh freed hidden friends are here to help you so as I already said it doesn't make much sense to write both comparison operators it's or equality comparator operators it's just enough to have one of them because the compiler will make or create the other one uh so far so good right and for the sake of the argument let's say that this code works because it should work now and it compiles uh but this still works because for some reasons and sometimes you have those reasons we couldn't make the conversion from the named collection base to the named object explicit so you still get implicit conver version and you still can compare to objects of the named collection base and we know it shouldn't right it's it's a bad thing what are your options there uh there is an option and the option actually is in the title of the slide it's a hidden friend it's a not so well-known idiom but it's a very good idiom it's for hiding functions from the lookup so if you don't want a certain function to be automattic to be found by the lookup when the compiler tries to find a match for your call uh specifically if you only want it to be found where your at least one of the arguments totally matches the argument uh or the parameter in your function uh just move those function wait inside the object uh that it's you know no concerns uh in this case our bull operator can be moved into the named object and it won't work obviously because now it has three arguments and it should have only two it has three because there is an implicit this uh so you make it a friend function and declare it or Define it directly inside the class uh a function a friend function that's defined in place is called a hidden friend it has very special Magic Properties it won't be found or used for that matter if at least one of the arguments that you try to call this function with doesn't explicitly match the one that you list there so if it's I cannot point oh I can point no I cannot point I can point uh if it's not the named object right in our case it's not the named collection base is not a named object so it won't be found anymore this comparison Operator by the lookup it's impossible it's hidden uh this function is now only found uh okay doesn't matter let's not talk about it uh so this won't work H and that's great right as it should be it shouldn't compile and if we are already talking about it uh then and about hidden friends and about how to declare functions how to declare or Define operators comparison operators and so on and we are in the modern language uh why not just go a step further uh and do something like this right just default it uh declare it as a friend uh and it's going to do everything you want it's still a hidden friend uh but now you have all the other comparisons synthesized for you out of the box so you don't have to do anything else uh so that was a hidden friend idom uh a very powerful things from for hiding your uh functions from the lookup uh the next one um polymorphic classes need virtual destructors that's where I leaked memory uh you didn't most likely see it but I did leak memory a lot in the first slides uh I have something like this or actually I didn't have something like this uh it will come but let's look at those couple of examples uh what do they have in common I'm creating like a pointer uh a unique pointer the to the named collection base and initializing with a named hip or I'm doing something different like I'm doing creating again an object on the hip of the type named hip and assigning it to the base pointer Base Class pointer and deleting then or doing something like this it's a bit more hidden now I'm creating again an object on the Hep named hip on the hip that that's unintentional and then I'm calling a function with it the function that takes a pointer to the named collection base all of this have something in common right you expect somewhere at the end of the lifetime when the named hip is not needed anymore that there will be a delete call on the pointer and and it will be of course the unique pointer will do it for you and for the middle example uh we just did it explicitly so we expect something like this to happen and what we want it to do is of course to call the D structure of the named hip and then the operate uh operator delete to free the memory deallocate the memory uh but that's not really what happens right that's not what happens because we made a huge mistake and I was actually quite surprised that uh neither compiler warned about it because they sometimes do warn about it uh this time it didn't this is our named Hep right it doesn't have a Destructor because it doesn't need it great uh this is our named collection base it doesn't have a Destructor because it doesn't need it h except it does it does because we intended to use it in polymorphic code a code where the child class will be referred through the Base Class pointer and what's even worse destroyed through it uh so what truly happens because we don't have a virtual Destructor here defined is then when the delete PTR is called uh the destructor of the named collection base is invoked and not of of the named hip uh this is not what we want right because it means that we are totally leaking memory uh shouldn't happen is there a fix of course there is a fix and it's a very easy fix uh just put the virtual Destructor there default it and you're done it becomes a class that can be used PO polymorphically and whatever we do with it now uh it's going to be good it's going to work as it should so so this was kind of a of an example when things can go wrong with dealing with inheritance right a basic example uh which you're not likely to do unless your code base is very big and unless you know your compiler doesn't warn you about it like it didn't me the next one is in a similar spirit so we are going to talk about object slicing or about copying child classes or derived classes uh when referring to them through the Base Class not a pointer but just through the base class and this is something that you know it's in my opinion it's sometimes very easy to see like for example on this slide uh in this four lines of code I'm slicing an object uh and in particular I'm slicing the named hip and by slicing I'm mean that I created a hip a named hip that owns two different arrays and then I make a copy of it but I'm only making a copy of a piece of the hip so I'm only making a copy uh of the hip that belongs also to the named collection base I totally neglect the hepp part let's say uh it's not really visible here right because it's kind of hidden in this you know make unique named collection base everywhere do reference uh but what really happens inside is that the Constructor of the named collection base will be called and the reference to the hip will be passed to it which is totally legal right and the name collection base will be created uh without the hip part uh it's more obvious when you do something like that so when you just have a function that takes like in this case a named collection ba based by copy uh you can already see that there is a copy being made it's clear uh the consequences are always the same right so the consequences are always the same uh basically we are doing what's called object slicing which means that we are not copying the whole object but only a part of it uh in this case we are copying the name and the size and that's all that might come as a surprise later on uh when you will try for example to do some casting of this Hep of this copy of the hip that you made uh nasty crashes no compiler Wars about it really uh and that's said uh an easy fix of course uh like for that one I mean okay it's not an easy fix it's an ugly fix but the fix exists uh just pick up the right class when making a copy when using unique pointers uh much easier fix when you're are passing to functions uh instead of passing by copy just pass by reference like maybe a con reference uh and you will be good no harm will be Ever Done Right No Object slicing and uh with that one we actually reached the end of the list of all the 12 knowledge items uh those are there uh all mistakes were truly made on the first two three slides uh I managed to do all of them uh luckily uh try it for yourself if you want uh see if you don't believe me uh are there any questions so thank you very [Applause] much I don't know I have one I'm just going to ask a question from from the um the online audience so this is a a question from Peter F neisen in Issue Number 10 when do we have to explicitly Define equal equals uh if we ask for the um rocket operator or sorry spaceship operator I didn't understand the question now you can repeat it of course but that that's me it's not it's not okay let me ask it it it slowly in is Issue Number 10 yeah when do we have to explicitly Define the equal equals operator if we ask for the uh spaceship operator I presume we have the spaceship operator and he wants to know is there any case when you can also Define the equal equals I wouldn't say so why would you do it then I mean I mean if you have the spacep operator it covers all the bases so if it was the question of course so now you don't need to do it anymore I don't think so unless you want to confuse some people right I I mean you you might do it I think you might do it because uh it's it's you might hide for example the spaceship uh using the hidden front and explicitly uh Define the equals equals outside so it's visible to the name look up right so so you can distinguish between the operators but yeah is it a good design then I don't know I I doubt it yeah so um my question is also about the equal equals operators stuff I can't remember which slide it was at the kind of start of the uh Speech but you said that the compiler could convert like decide to convert from uh not or in in equals operator to the uh quality operator uh instead do you know what I'm talking about right now yes of course um that's kind of scary to me and I wanted to know uh do you know of any more of these like implicit conversions or whatever you're supposed to call them that's the rule that's been introduced just I don't remember in C++ 20 or 23 it always happens a compiler is allowed to rewrite one comparison into another when one is lacking that that's all do you know of any other operators or other other special functions that behave this way no no luckily not I don't think it's scary I mean maybe like the um less than operator could be converted to like larger than or equals to remember that you can always explicitly disable other things right if you don't want the conversion to happen just no you cannot disable it delete yeah you could delete it yeah just delete the other one but that doesn't doesn't doesn't help you here that's kind of scary to me but thank you so you cannot delete it no I was hoping the same but no you cannot because then you delete yourself I mean you have to delete that one to disable this this is what it's Rewritten to right so it's Rewritten into the same operator so how do you delete this particular use case I I could imagine that there is a way to do it but I don't I don't want to do it okay I have a question about item number five um are you aware of any uh best practices regarding the adding the inline to uh your con expression variables because adding the inline will make it more consistent because everybody sees the same address of your uh Global constant but on the other hand these types of constants I don't want anyone to access the address anyway so uh I often find myself struggling should I add the inline shouldn't I because it always suggest suggests not what I want to do because um I don't want you to access the address but if you do I would want it to be consistent I understand your question I think but inline has a very specific uh reason I mean reason for existence now in C++ light inline means literally allow multiple def definitions or red definitions uh as you say there will be only one object created at the end uh but that's part of the Linker job right but if you declare it inline but if I don't declare the con expression variable inline it will have internal linkage and um it will be fine in terms of the one definition rule but everyone will see a different address and yes that's weird and but I don't want them to access the interest anyway so so to r on that then just do it make it in line okay if you don't want them okay or it and uh another comment um if you explicitly Define the spacit operator and don't default it you have to explicitly default the equals operator to make it uh available that was maybe the first question thank you and that's really funny because I didn't have to do it and it compiled it compiled because you ex you defaulted the the spaceship operator but if you have to implement it in terms of understand maybe delegate to okay I have a I have a further comment from perer online and I think he might be agreeing with our previous uh um now I understand the question to to clarify he says you do not get the equal equals operator for free in some situations even if you ask for the spaceship operator so that's um okay and I have another question from somebody online uh Roman asks uh you were talking about memory allocation issues are there any techniques to handle bad Alex I think crash the program I mean if you're out of memory that's the end of life of your program anyway right uh unless you can switch to a different allocator or something like this uh I mean that's that's what I've been taught always so it's a disastrous situation right when you're out of memory so your options are very limited at this at that moment unless you are on some heterogenous system and you don't care you have multiple memories or different allocators maybe or you don't know or you maybe had a very bad allocator that just one had kiloby and yeah okay I seem to remember writing code decades ago which would at startup would allocate would would Reserve 2K or something like that and then if it got a bad Alec it would the allocate the normal allocator would switch to using that 2K for the last get me out of here cleanly uh so we we sometimes tell uh beginners to try it nowadays to especially on Linux to just allocate as much as possible it's an endless story you can allocate allocate and allocate you know and it's never stops it's a virtual memory so um are there any more questions uh if not thank you very much for attending the talk and for the questions and see you around