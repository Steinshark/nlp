I changed my mind about Zig originally when I started the coding it about a year ago I wasn't sure if it actually had a meaningful place in the developer ecosystem and as I've been using it and being asked more and more questions about it I think I've come to a better conclusion in this video we're going to talk about what ziglang is where it lives in the developer ecosystem and my thoughts on the syntax and the features of the language now if you're new here hi I'm lval learning I make videos about software security programming and cyber security in general so if you like that stuff or just want to hang out with me hit that sub button I really appreciate it now a lot of new programmers ask me uh what language should I learn should I learn C or C unsafe or should I learn rust or is rust too hard or should I learn Zig and I think for a long time I had a good answer about C and rust but I didn't really know how to answer when it came to Zig Zig had this weird aura about it where I wasn't sure what problem it solved but I think I'm going to be able to answer that for you today if you consider the ecosystem of systems programming you have the C language and you have Russ now those are the two main ones that stick out in my head when it comes to systems level languages and we're not going to talk about C++ by the way now there is go go is another compiled language that is very very good and getting more and more speed but go is a garbage collected language and some systems some platforms and some projects require that you don't use garbage collection for one reason or another garbage collection is inherently non-deterministic so a lot of the times people will just choose to not use a garbage collected language now you're left with the basic two you have have C and rust now each of them have their pros and their cons their shortcomings and their power right C on the one hand is the OG language it's been around since like 1972 or whatever and it's it's one of the best languages that exists in terms of the power that it gives the programmer I mean the entire world to include every embedded device that exists your router your fridge or microwave is probably written in C and that is because C is an incredibly powerful language the programmer is able to do literally whatever they want as long as it's within the scope of like what the OS the kernel allows it's able to be done in C now that is what I'm considering on like the far left of the spectrum right you have like powerful but do whatever you want to give it like chaotic evil language right on the other hand you have rust now rust is designed with so many of the failures of C in mind C for example is not a memory safe language you can exit outside of the bounds of an array you can do arbitrary use after freeze and it's on the developer to catch them at compile time or the program to enforce that you can't do those things at runtime but you can very easily write code that just allows you to do whatever you want and have it go out into the ether and become a security vulnerability that eventually gets hacked by hackers but if you consider the new programmer who's trying to get into the space who wants to learn a language that is for systems programming but doesn't want to do Russ cuz Russ is too hard but doesn't want to do c because C is unsafe where do they go this is where I think Zig fits in very very well now what you're looking at here is a project I've been working on on Twitch I've been basically trying to reproduce the xxd binary if you don't know what xxd is it's a basic hex dumper right you can specify the size of the columns and the size of the groups and what you do is you pump in arbitrary data into there and it hex dumps it right pretty straightforward I use this project as a way to learn new languages cuz the project itself is very simple but it forces you to learn a few things about the language you have to do like basic Loops memory views into binary data how to open files you have to use the parts of the API that may be like non-standard and then also like it's just a cool tool to have I think it's I think it's pretty neat so anyway what I'm doing in this project is reproducing xxd and this is the current status of it and I'm calling it zcd so pretty neat in doing this project I learned a few things about the language that I want to talk about that I really really enjoy the first is the main feature that kind of separates Zig from C so if you have written C recently right C Used to Be basically it was literally an abstraction for a assembly instead of writing assembly you would write C and the C would just turn into assembly that' be it there' be like no extra things added there was no allocators that were created you had to write all that stuff yourself as C got older as C matured we now have like the GBC library that does a lot of stuff for us use print F you use scan F and all of that stuff that when you use it gets buffered in the Heap so zigg is trying to prevent these things that they call ghost allocations where when you run code in Zig all the allocations will be ones that you ask it to do it will not do any allocations for you and because of that they've given you very explicit access to these things called allocators so you can write your own memory allocators that allocate memory in the way that you would like it to be allocated you could write your own kind of Heap you could write a basic stack allocator you can basically do whatever you want which is really really cool another thing is this defer macro right when you're doing allocations every application when you do an Alec must be met with a corresponding free right if you don't do that you have a memory leak and you're your program is buggy uh this defer keyword allows us to do the associated free for that piece of memory and it makes them close together in code so when I'm doing a code audit I can look at it and I can be like okay cool I have my Alec here where do I free this variable I literally like on the next line I do it the defer keyword allows this piece of code to be ran when the function scope is about to go out so when i r when I run defer this actually effectively puts this line of code at the bottom of the code but it puts it up here so I can mentally associate that this is tied to this which I like a lot the next big thing that I was a really big fan of is the errors as values feature of Zig now if you've written any rust you have the result type the okay type and the error type right where the result is a en that allows you to basically return either an okay which is good value or an error which is bad value and then handle the output via pattern matching Zig is a very verbose language where you are required to not only use all the variables that you uh you you name but also you're required to handle all the errors that you get right so effectively this open file function has this return type what this return type actually means is pretty interesting and I I love the notation of this on the right of this exclamation point you have the return type when it's a good value so the correct return type is this if there is a return error to be returned this is the error type right and so what we're able to do is we're able to run the open file function and effectively think of it like we go left or we go right in the case that we go left the open file good value the standard FS file is put into F easy that's awesome if you go to the right we're able to check to see okay we've caught that we're in a file open error error and that type has different subtypes and we're able to print them out via basic pattern matching I think it's really cool I think it's a way for you to be forced to handle every error case of your program which in languages like C for example like a lot of the times you don't even have to check the return value you can just say like open and then if it's good it's good but if not it can crash like it doesn't like no one cares uh so I like this a lot and this last part I think is really interesting you know zigg is not explicitly a memory safe language like you can do the traditional thing where in one function you create an object and then you return a reference to that object and then when the stack goes out of scope you have a reference to a dangling pointer right like that that kind of thing is allowed in Zig but what I do like about Zig is that it gives you things that smell or like taste like memory safety uh that prevent a lot of very simple bugs like for example I have the the dump hex function which is doing the basic you know print out the data as as hex and what I'm doing is right now I create a chunk and the chunk is always the same size right right now the chunk size is two and I have a little bit of an edge case where basically I'm able to index outside of a chunk where the value is undefined if the size of the file is odd right so if I have a file that is 51 bytes on that last iteration I've only read in one bite of data and I can iterate into the second bite so basically I have a very basic out of bounds uh array access now in a language like C this would just be okay we'd just be all right with this happening there'd be really no I mean there's a way to check it we could we can make sure that we do the math and and do the calculations to determine if we're outside of the array bounds but in Zig when I run this code there is a runtime Panic it can see despite not being explicitly memory safe that I am indexing one the value one so I have line of one into a slice that is length one right and so instead of giving me some weird seg faults where it's doing an array access that the OS can see it's going to throw an error at this level and you know this is a much I think safer way to crash right than you know potentially going outside of the array bounds like like C would let you do now what I'm not saying is that you shouldn't learn C what I'm not saying is that you shouldn't learn rust you should learn C you should learn rust and you should learn Zig like I think everyone should learn all the things I think learning is the way that you become a better not only developer but a better person in general now that being said if you have limited time I think obviously you should be picking one and that choice you make just depends on what you want to do if you want to be a systems level programmer You know despite the movement towards rust things are still written in C and if you want to get a little bit of a taste of what I think the future of coding looks like and what safer software looks like try Zig and try rust I do have courses at low lev. Academy go check that out Link in the description below if you want to follow along with me on my journey and figuring out my thoughts my additional thoughts on Zig go follow me on Twitch I stream there like once a week if you like this video do me a favor hit like hit subscribe and then go check out this video we'll see you next time guys I appreciate it bye-bye