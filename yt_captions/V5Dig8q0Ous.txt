and with that tonight these are our hosts of the tables this is the content we have in this Fair industry um modern C plus plus for absolute beginners Conan by Dre frock undo and the open source tools from kdib because now we're actually gonna go and get started with the demos which is sexual content for tonight right and here we go with demo from undo I think they're demoing um the life recorder and let me bring on Greg hello Greg from undo hello hey yeah it's going all right going all right hello everyone and let me bring online your yeah so here's your screen and we're all waiting for your demo thank you very much all right I just want to do like a couple of slides before we get into the demo just want to set the context that's okay um so I think a lot of people know this quote from konaghan debugging is twice as hard as writing the code in the first place so if you write it cleverly as possible you are no definition not smart enough to debug it well let's look about let's look at how we uh well kind of why why that is and think about how we actually how do we debug and actually I think as developers we spend actually most of our time debugging right I'm including the inner loop debugging think about how many lines of code do you think you can write and have it work first time right maybe you're a better programmer than I am but for me it's like 20 probably not even 10 maybe how many lines of code can I change and have it work first time I think that number averages to less than one right um we spend a lot of time um debugging and sometimes we use like Dynamic Checkers like valgrind or sanitizers um maybe we have them as part of RCI maybe we pull them out like well I don't know maybe like this is the sort of thing you maybe do a lot of times I think a lot of people a few times a year maybe use a debugger maybe maybe you know again a few times a year a few times a month Maybe um some sort of fancy Dynamic logging yeah some people a lot of people don't have that or we just printf and that's what we do most of the time every time and I think there are a couple of reasons for this one is I think I'm going to be a bit controversial but just laziness um so we all know this XKCD cartoon why is it compiling it's compiling because I added the printer right so I can feel like I'm working but not work but the other reason is that it gives me it's actually better than most debuggers are telling me what happened right I'm trying to think when I'm debugging how did that happen I don't mean like how did that happen or how did that happen I mean I had expectations of what my code was going to do in reality diverge from those expectations and when I'm debugging I'm trying to think backwards to like figure out where did reality diverge from expectations of course usually it does something a little bit more like that um so this is where time travel comes in so um and this is well undo live recorder comes in so we want if we can make the debugger just allow us to see exactly what happened rather than what most debuggers do which is let you see what is happening much more powerful so let me show you what that looks like I've actually got loaded up here this is uh this is our internal um GitHub Insight undo and this is a pull request that I made uh that's failing some tests right um so made the pull request kicked off some Jenkins tests all very kind of normal here's Jenkins okay some of the tests have failed uh if I go into here I can just like take a look at one of these at random I've got some log information and okay some kind of abort oh yeah okay look at assertion failure here right it's got a normal experience right we look through the logs and if we're lucky sometimes in the logs we have enough information to root cause the issue and you just like oh yeah I know what it is let me fix that and go again but often probably most times we don't have enough information in the logs with like that assertion failed like it should never fail right that's why it's an assert what's going on so what would I do normally I'd maybe add some more logging run it again maybe see if I can reproduce it locally I don't need to do any of that because I've got this link to something we call the observatory if I open this up this is a whole bunch of recordings that got taken of my test as it ran this test actually ran I think yesterday but these are recordings of the program's execution various processes and things ran but I'm going to just pick this one it makes for the best demo so what this is going to do now I just clicked on that play button this is going to provision a Docker image it's gonna um check out the source code from the right version and uh and it's gonna load up uh let's go now here we go and it's going to load up a a view through vs code here onto my application kind of at the point that it crashed which is going to be like a little bit like looking through a call file but this is a recording and I get full history every line of code that executed and also full data so I can actually go back to any line of code that executed and I can see all of the data so let's just let this all get Provisions that's checking out the right version from git it's setting everything up it gives me some tips because I'm kind of a bit lazy it's just it'll get it's usually it's a little bit quicker than this but here we go all right so I've got a few things that are a bit different here I've got this timeline this is all inside the browser right so this is this is the test that I was just looking at remember we were looking at it in Jenkins and Jenkins log and we saw this assertion it failed um and I can sort of hover here and I can see this assertion fails because square root cache is zero and it should have been 15. um I can kind of hover around elsewhere and I can see that okay well that's so passing in a number to Cash calculate number is 255 and what it gets back is zero and what it should have got back was a square root right zero is not the square is not the square root of two five five so kind of okay so if I was looking at a core file I could get this information it's a bit more convenient because I've got the right code Hannah Jenkins and stuff but doesn't give me enough information to record this right I need to know why did cash calculate um return what it did well let's have a look out on the left here I'm just going to remove these windows around a little bit so I've got a bunch of threads and they've each got a cool stack actually this is like um if I look in here I can click this show more stack frames this is inside Lipsy right so actually I'm not here at this assertion I'm inside Lipsy from where the assert failed so what I'm going to do is I'm going to hit this uh uh sorry this button here reverse step out and that's going to pop up uh one uh stack frame and again and again and uh once more and so here we are inside our code um now again I could have done this with a core file but now this is where stuff like life starts to get really interesting okay I'm going to just wind the clock back and see what the program did and why and see why did cash calculate return that bogus number so uh go back one line okay that's pretty funky now I'm going to step into Cash calculate because I want to know why it returned what it did okay cash calculates returning look look it's got a cash hit here it's returning zero okay we knew that okay there's some threading stuff going on I mean thread 11 here uh maybe it's a race condition and I've got some locking happenings maybe I can go back before this lock was released and let's see if everything looks same here so just go back a few lines okay stood in thread 11 it will stay inside the threads this is before the thread was released now let's have a look here so it's returning from the cache it's returning the ice entry in the cache I is 90 and go over here in my watches and like look at G cash 90 and if I open that up yeah okay sure enough the cache contains bad data right so this is like bad day at the office right I've got my cash contains bad data I don't know I don't even know how that came to be how did that happen I don't know whether that was another thread so pointer error is it a logic error all I know is something like stomped on my data structure and gave me bad data so uh what I'm going to do here this is a super cool feature this is really kind of one of the killer features I'm going to click this uh let me just hover that so you can see it click this last changed button and it's going to give me an expression so I want to know when did g cash 90 whoops 90 last change so I can enter and what this has done now is wound me back in time to the like the most recent time that that element of the cache got updated so I'm Midway through the update actually it's executed the first line here and not the second so it's Midway through the update so if I go back one line now okay so now the data structure contains good data the square root of 40 uh really is six like with integers watch the data as I step forwards now it's like live action replay of the corruption happening right step step so that's it that's two five five and zero being written in there let's see like what's going on well we're writing number adjacent and it's square root and number adjacent to negative one so the square root is garbage why am I trying to take the square root of negative one well uh I could uh I'm getting pretty close now I could do this by code inspection but as this is a demo let's let's do it just a slightly different way I'm going to use the last command we've got the command line here so y there's number adjacent where is number of graysons uh minus one okay it's being set here number adjacent well it hasn't been initialized yet it's been initialized to number which is zero minus one so here's the bug called the function with a number of zero it returned the right thing it returns zero but there's a side effect you left one entry in the cache in a bad state right so it was calculating square roots either side and the basis is some kind of locality of reference and I didn't notice until sometime later in the execution different thread came along actually in this case looks like it was the same thread usually it's a different one anyway different a thread and unless you know the same or different thread came along and tripped over that bad data and then and then the program assert failed now this is a trivial program right it's like less than 100 lines of code um it's just to show a demo we want to show a very quick demo in like 10 minutes but uh so fight just want to say that this scales right so our customers are people writing really you know code at scale millions and millions of lines of Highly optimized C plus plus and um and they use this you know all the time every day even even in those environments so that's it that's the quick demo um I will be uh hanging around um in the lounge afterwards to take any questions thank you very much thank you that was an awesome uh demo of the life recorder for Nando and yeah crackers is an expert and many things so um we will be having um a table for undo and the launch later but now let's continue with um this is our next guest in our next topic now there's a new book actually a new version of this book The Modern C plus for episode beginners book has a new version uh Second Edition and we are going to talk with the author now about this let me bring on uh Slobodan hello Slobodan so you're sharing your book so I can share that so um tell us about the new version yeah sure so this is the second version of the of my first book which was uh which is a modern C plus for absolute beginners but I like to refer to my book by its second title which is a a friendly introduction to C plus plus the the book introduces the language itself the standard library and more than C plus standards in the second edition I've covered the some of the features in C plus 23 also the second edition features more diagrams and one of the feedbacks I often received is that people would like to see it uh Full Source Code projects so I've included six new Full Source Code projects in addition to the exercises so I'm very much looking forward to having a discussion with people on Hublot platform and uh yeah thanks for having me and looking forward to presenting about my book okay what what can you show us about you you have the book here can you show us a chapter an example uh sure sure basically the book is divided the book is divided into let's look at the table of contents the book is divided into uh basically three parts the first part deals with the language itself the basic facilities in the language followed by the abstraction mechanisms such as classes and templates then we move on to the standard Library where we cover some of the most used algorithms and containers Etc also finally we are addressing the notable features introduced in C plus 11 1417 and 23 and finally at the End of This Book there are four basically six source code projects fully written out and we do a basic commentary etc etc so after each of these uh theoretical introduction there is a there is an exercises part with solved source code exercises which have also included after every every chapter so I'm very much looking forward to any uh questions you might have about this book and looking forward to it once again okay thank you you're welcome so if you're curious about his book um he'll be later on the launch and yeah I've heard very good things about your first version and it's very popular I can kind of you know see at which books people look and your first version has been in the top five there at median C plus plus so definitely there has been some interests in in that book and now we have a version which also covers um the newer standards maybe we talked we should talk about that a quick uh a little bit um 23. well well basically in in the second edition I wanted to feel I wanted to focus more on uh I've Revisited some of the chapters I didn't as you said earlier there isn't so much material in C plus 23 to be addressed but basically what I put my focus on were addressing and readdressing a couple of topics which were introduced in the first edition and I also introduced many more diagnosed people wanted to see more diagrams visual representations of certain Concepts so I did that I've also updated a couple of exercises and mainly what people wanted to see were fully written out uh source code products written from zero and then we building complexity and the commentary is also there etc etc so we're building complexity step by step we start by zero and then we are expanding so I'm very much looking forward to any questions in the cubital platform after this presentation Okay so if that's everything you have to say about your book then we'll look forward to coming to your table and meet the author and the book so let's see who is next thanks lobodan um we have Conan as our guest now but I need to find my table my window again here we are so um here's Chris from Conan and Chris I think you have a demo about Conan yes I do I have a few slides and a quick demo so I'm going to share my screen for everybody that's what I'm after um yeah so according to zero has been released in February I think and it's been renovated and it's great to have it um so let's see what Chris has to say about Conan to zero and Conan in general let's go so uh just a quick introduction to Conan 2.0 for the tool Fair here today my name is Christopher McArthur I'm the Conan developer Advocate if you're on any of our social medias you'll definitely find me we're in a bunch of different places like the CPP Alliance slang the hashtag include Discord and you can follow us and keep up to date with all the different releases that are going on so one of the first questions I always get is what is Conan so it's a CNC plus plus package manager and the role of this is really easy uh it's just to Simply install dependencies we've all had that frustration of I'd like to try out a new project uh but the building three or four different projects putting and installing them all in the right place configuring the system it's quite a hassle at times and being able to just quickly develop and prototype things is one of the most convenient features of a package manager so the distinction between Conan and a lot of the other package managers is it focuses on building and distributing the binaries so when you're talking about things like API compatibility binary compatibility between different versions being able to model that track that and make decisions around it is where Conan's strengths really lie so we have jfrog's con Center uh I've been contributing to that for several years now there's over 1500 open source projects and it's built in over 100 configurations so you can see this in the demo very soon but I'll show you that you can quickly just install the dependencies need so Conan is open source it's MIT licensed it's a distributed model so there's one client to many servers it's scalable and flexible so you can have different combinations of remotes and servers working combination it supports all the major build systems so cmake Meson auto tools any platform Windows Linux iOS Android your heart's content embedded devices as well and it's more than just C make list.taxed so being a python package manager really gives you some flexibility so you can do more things uh and more completely so uh let's say we just have a simple consumer example right so I want to make an app and it's going to be version 1.0 because I'm real fancy uh you can just make a clone file.text uh you don't really need to get into the python and it's a very easy syntax requires speed log 1.11.0 we're going to be using some generators this is a Conan's language for the Integrations for build systems so you can see here we're going to use cmake tool chain and C makeups and our layout for this project is going to be cmake because it's a cmake project so we can just get clone our app we can CD into the repository and do a Kona install and that's like the easiest way to get going but the secret here is the dependency graph so what you didn't see in the previous slide was this dependency on fmt so the format Library so my app is going to have a direct requirement to speed log but that speed log is going to have a recipe and it's going to have a requirement to fmt and that transitive dependency is carried through the Conan model graph and being able to make these distinctions and understand these things we get to do fun things like having requirement traits so we know whether or not the header libraries are exposed whether you need the symbols to link against uh whether it's a dll that needs to be copied at runtime you can make more informed decisions when you're building and deploying your app and you can do some fun optimizations in that so I mentioned a recipe so our app here is going to have one uh we're going to use Conan to build and distribute it because that's the next step we figured out how to install our dependencies but we need a recipe for how do we build and package this so we're going to make an app and it's going to have a binary and it's going to have a clone file and there's going to be a source method a build method and a package method and this works just the same where you clone your repository and instead of doing cone and install we're going to do cone and create so fun little demo I have here a terminal we're already in our app directory so if I just do uh LS minus La you can see minus the bad text coloring there are a few directories going on so we have a source folder here as well as a test package and we can see here our clonefile.py so if I tap to that Conan file you can see here we have a handful of things um I cheated and just used one of our Nifty little um commands in common so if you do Conan new you can actually just generate yourself an example recipe which is what I did right here um and you can see here we have our layout which should match what you saw previously in the cone file.text most of these things translate over we have our requirements generate build and package so these are the different methods that Conan can invoke and this is how you teach it to build and package your software you can see here for our binary configuration uh our settings our operating system compiler and build type architecture and this is just how you describe things there's some fun fill-ins you can do your metadata and here we're going to be making an application so easily laid out so if I go back to my cheat sheet and I steal my command I can run this here so I'm going to compile this with C plus 14. and you can see Conan will go through and work and it'll build our app so our graph here you'll notice it's going with our app and it was exported so it was in our cache and you can see our dependencies here we have a speed log and fmt so our version range here so I need version of Speed Lock anything greater than 1.10 and it resolved that and it found the latest and it turns out it was a 111. uh compatibility so depending on your C plus plus standard you can get different binaries the default compatibility in Conan 2.0 is very easy it accepts any CPP SD which is generally what you would expect most of the time that most of them should be compatible it is a plug-in so you can change and customize it however you like um here you can see our requirements these are the different binary packages that it resolved to and found and it generated our files for us and this created our package so the introduction section to the new Conan 2.0 docs is going to be your best friend it's a narrative story so similarly how we solve from Slow band for his book where there's like real code examples all of that is here present with Conan as well it makes it very easy to get Hands-On and try it um so why would you pick Conan over the other ones and I touched about this a little bit earlier but uh its focus on being able to package and distribute software is one of the key aspects of it and it also gives you that flexibility so you can build a framework for doing devops devops isn't really something we talk a lot about in the C plus plus ecosystem but um spoiler alert you've been probably doing it this whole time with building and saving packages somewhere those binaries if you build and debug and release or different compilers and platforms you've already been doing devops so Conan just gives you more tools to manage that and do it better uh and you can do things like model modeling the platform configurations and language between libraries which is very convenient what's new in content 2.0 uh quite literally everything so there's been five years without a breaking change uh and that commitment to stability uh is still true with calling 2.0 so about 60 of the code base is new and about 20 is back ports but the example I just showed you is completely compatible with Conan 1.x as well so you can do the latest in Conan one.x and then plan your migration over to 2.0 and this uh was done intentionally and the design was really thoughtful behind this so this is a slide just to show all the different changes um on the left hand side you can see a list of different breaking changes these are more structural changes to how the client works and on the right hand side you can see a whole long list of new features and this will give you a good overview of like what to expect I mentioned the plugins in Diego CPP contact he used the expression death by a thousand bytes and that is absolutely truth so one of the changes in column 2.0 is you have the power to help yourself there's a profile Checker command wrapper and package signing to name a few and this will really make it easier for people to try things out uh so new graph model new plugins extensions deployers binary compatibility things I didn't mention multi-revision cache there's new package ID modes there's lock files got a huge revamp which is super good configurations environments got an overhauled package immutability and so much more there's a page on the docs what's new and you can learn all about it there some more resources if you curious uh there's an Accu talk by Diego uh a year ago now we did an introduction to 2.0 blog as well uh the tutorial which I mentioned if you have questions uh the official place to get help is the Conan issues on our GitHub repo uh if you want community help I highly recommend our CPU Alliance lock channel it's one of the most active in the C plus plus ecosystem and it'll definitely give you a good overview and people are definitely helpful so if you want updates Twitter uh I run the Twitter I do make typos you can make fun of me I appreciate it thank you very much uh pip install Conan that's it easy peasies thank you Chris that was a nice short demo and um more about Conan on the table in so I need to go once again and um thanks Conan and next we have kdab presenting on their open source and cuter tools so let's bring on helium and we are written I need to add yes that looks better so welcome everyone I'm Milian from kdub we have uh quite a few open source tools um I'm mostly interested in uh two of them keep track and hotspot is what I've been doing those uh profilers for Linux one keep track is a memory profiler so heat memory profiler and another one is hotspot which is what I'm going to talk about later is a UI for the Linux perf subsystem and we also have tools like crazy which is a llvm based study code analyzer for especially for cute so it helps you for example to Port your code from Q5 to q6 and finds uh little paper cuts that slow down your application and whatnot and yet another pretty popular tool of ours that is also open source like the others is gamma ray um a cute visual debugger and introspection tool all of these tools are pretty interesting I would say and I could easily fill 10 minutes each but today we'll talk just about hotspot and um the thing here is um this is mostly interesting for uh Linux people but I guess or hope that there are quite a few of those in the audience and um historically and if you look at how you do profiling on Linux then sooner or later you will stumble over the Linux path subsystem so the perf record and perf report commands and those are pretty damn hard to use on the command line just to give you a quick example I hope you can roughly read what I have here [Music] um if I go to some application that I want to profile then I used to be uh I used to have to do something like perf record and then I have to remember that I actually want to do dwarf unwinding and then maybe I want to enable um the Z standard compression and then I want to run my application and um then it did something and if I report it then all I get is this fancy or not so fancy um standard console UI that is in my opinion uh not good enough so um I set out a few years ago to write hotspot which is essentially the same thing that I just showed you on the command line using the ready-made perf tools but in a UI package built around Q5 and KD Frameworks and the notable features really are is that it's much much easier to use and it tries to give you some context sensitive information which is what I'm going to show you next and a few other things that I will not show today like actually being able to very easily access the profiling data that you recorded on an embedded Target so let's say an ARM device Raspberry Pi you name it and then you copy the perf data file over to your development machine maybe different architecture there and then you just connect to this root and the debug symbols there and analyze everything and that just works so um let's talk about some some Demon time so as I showed you before I actually recorded some data and instead of just saying perf report like I did before I can just use hotspot as a drop-in replacement for puff report it will look for the perf.data file in the same directory and then it will actually look at what is needed to analyze the data and now it's done uh you get a little overview page um hopefully looks like that you might have seen a little progress about earlier and that actually was me downloading debug information through debug info d uh which is pretty epic nowadays and then um the first thing that you really should look at uh is either the overview or what id do is the flame graph so if you haven't seen a flame graph yet please please educate yourself on this great Innovation by Brandon Gregg it is essentially A visual representation of this tabular data that you probably know from any profiling tool and it literally just divides the full width in fractions so if you can read a thing here in this Tower City landscape then it means it has a fractional large contribution to the overall cost perfect sampling profiler so that translates very nicely so 66.8 which you can see in the bottom corner is in this raw motherboard file pretty uh clear and now I can easily say I actually uh want to colorize it by some demo by the binary or whether it's in kernel space or user space so we can see here a few Red Towers that are kerners-based but the rest is all user space here and um I can see what is uh system and what is user space and um these are just different ways to slice and dice the data eventually um you will essentially go from top to bottom look for a white thing that you have under your control and in this case it's this draw motherboard one and as you can see at the bottom in this timeline view all the threads that we recorded and the CPUs and when you hover something you actually get to see when a sample was recorded that contained this frame on the stack as well and okay now let's assume I found something here right draw motherboard how do I figure out where in the code that is um you can right click view color Kali and then it's yet again a different way to look at the same data and here on the right hand side you would have a list of all the lines of code that actually got recorded you can sort by inclusive cycling cost and then you would see okay bundleboardline.cp dot CPP line 40 is apparently costly and I can double click it and open it in an editor of my choice and I would see here is something that is apparently slow a different way to look at the same data is if you go to right click and then disassembly and this is essentially kind of like gold bold but integrated and for profiling data so we also disassemble the data just like God bold does and then try to do this um what's it called basic building block colorization and then you will see the same line here that I just opened in the editor with the high inclusive cost and I can also look in the Raw disassembly code and find the equivalent costs there as needed if you need this kind of low level data it's all there now which is pretty cool and there are some more improvements coming along in this area so I would say for the 90 use case this is all of what I'm doing um in my daily job as a software developer when I need to do profiling of C plus plus code hotspot is Trivial to work it's super fast and I just do this a lot now one thing though that um I mean many tools can do something like that pretty easily right but one thing that is uh pretty nice is um I can also record data so I don't even have to remember these Arcane um command line uh tools and I can enable um more advanced path features for example the off CPU profiling which is pretty nifty so um let's start recording and I get here a example application and now if I try to resize this window it's really really slow right and well yeah I deliberately wrote very slow code here let's close the application and um if you are interested in what a command was run you could even just copy and paste this out and put it in a shell script or whatever there's no magic going on here really now we can view the results and again some debug info D that should be pretty quick because most is already cached at least I hope so uh Famous Last Words yeah okay so now and this is done and the summary in this case is actually pretty interesting because uh we see that for some reason this application starts 210 threads which is pretty stupid on a um laptop like mine which only has eight cores um similarly on average just 0.4 cores are running so not a lot is happening and down here in the timeline you can also see that really uh being the case right um let's jump over to the flame graph and make that more um clear so first of all we have this list of CPUs and um there is stuff going on but not a lot and then down here I see apparently some threads get created and then they get killed and then more threads are created and then they're killed and more and more and more and so forth this is very very bad code um similarly let's try to figure out where the code is actually sleeping so let's see as I said in the summary page it says on average uh most of the threads are just sitting around idly not doing anything and because I did this off CPU profile profiling I can now select the different cost source for the flame graph so by default it shows me the on CPU cycling cost sampling based but now I can switch to off CPU tracing costs through the scheduler Trace points and then the flame graph looks totally different and this is actually a sleep time cost now and when you look at this um a large screen is useful um but let's have a look at what happens when I hover the timeline I actually see the towers at the top I'm getting highlighted as well and for example here this thread is the so-called dbos thread it's um I can actually ignore that let's say exclude This Thread I'm not interested in that similar here is a um event thread which is really just this little part of the flame graph here in the middle so again let's say I'm not interested in that I'm going to exclude that thread as well and then what else do we have we have the main thread sometimes not doing anything because I simply um didn't interact with the window that you uh saw so if I zoom in here I can also say let's exclude this whole stack whenever this Frame is in encountered and bit by bit I can clean up my um flame graph that way until I eventually find the needle in the haystack which is in this case this left big chunk where a function that I have under my control apparently tries to lock a mutex and again I can just go to view caller colleague and sort by the off CPU time and find so here again it's on the right hand side and when I saw it by the of CPU time I go to manualbroad.cpp line 124 and indeed I double click and I instantly see the lock that is being um held here which is obviously pretty uh badly placed so let's quickly optimize this I just reduced the size of the critical section and then I will recompile give me a second and then I'll just quickly rerun that to show you the advantage here so um I just re-record and I resize I close I view the results I wait for the cache to be filled and now things look much better than before um there's actually some threads being used in parallel on average not much because I'm actually still um not interacting with the main window all the time but when something is happening so for example in this area here let's filter in on that then you can see all threads are more or less busy doing something and um the flame graph looks nice I can again look into um what is now on CPU what is off CPU just like before and then further look into my application try to come up with additional ways to speed it up so yeah if you have any more questions around hotspot Heap track gamma ray crazy any of the other tools come by visit us at the virtual table and thanks for listening thank you for the demo all right thanks sumilian from Caleb um and this is now the end of this kickoff um join us now in the lounge