Hello and welcome. I'm James Murphy. In this episode, we're talking about the core guideline that says that you shouldn't use std::endl and some common pushback about this guideline that I hear concerning multi-threaded code. The core guideline says that most of the time you should just prefer to use a newline literal inside of your strings instead of using the standard endline. The reason for doing this is twofold. Sometimes it avoids an extra write operation. Here we needed a second call to the write operator in order to write the new line. But here, we were able to just include it in our string since we were already using a string literal. But even in a case like this, where you can't save the extra write operation, it's still preferred to use a new line over standard endline. The reason for this is buried in the standard. So, don't feel bad if you didn't know where to look. But the effect of writing a standard endline is to first write the new line character and then call flush on the stream. Not all the time, but sometimes, flushing can be very expensive, like if you're writing to a file, especially. And in that case, doing unnecessary flushes will severely impact your performance. If you're not already familiar, a lot of output streams are buffered. What that means is, when you write text into this file object, it doesn't necessarily mean that that immediately writes the text to the underlying resource, in this case, the file. Instead, it may just keep track of all the stuff that you've written in an in-memory buffer and then sometime later write all the stuff to the file all at once. The process of writing the in-memory buffer data of the file object into the actual file on disk is the process of flushing If we were to use endline because of the flush that end line implies, This means that we're going to be flushing and synchronizing with the file system three times in this code. Whereas, in this code, we don't necessarily have to flush it all until the file object is destroyed. So, in its destructor, it would call flush and flush all the data all at once. The actual amount of speed-up you get from doing this is going to depend a lot on the relative cost of doing a flush. So, for something like writing to a file, you'll typically see a bigger speed up. But for something like writing to standard out, you wouldn't see as much of a speed up. It's not required by C++, but a lot of implementations will flush the buffer for standard out every time it sees a new line anyway. In that case, if you use endline, you're basically just doing a redundant flush of zero characters immediately afterwards. Any decent implementation won't actually flush if there are zero characters. So, your penalty will just be the penalty of an extra if-check. However, whenever I suggest this guideline, inevitably someone asks: Hey, doesn't endline protect you in a multi-threaded situation? I'm not quite sure where this myth originates from but it's sure widespread. And the answer is: No, it does not protect you at all. Let's take a look at a simple multi-threaded example to investigate. Here, I have a worker that takes in a start, a stop and a stream to output to. It just loops from the start until the stop and output some info about which thread and what number it's on. Then down here, I just start up two threads that call the worker function. The first worker is going to print from ten thousand to twenty thousand and the second worker is going to print from twenty thousand to thirty thousand. For this example, the stream I'm using is just a file stream going to this out.txt Okay, I went ahead and built it and let's run it. It appeared to run fine with no errors but let's check the output. When we look at the output, we see all kinds of messed up lines here. Some lines like this one printed out just fine. Other lines have sort of part of one line and part of another line mixed together. And other lines are just fragments of what they should be. So, clearly this is not the output I was expecting. So, what output was I realistically hoping for? Well, I'm doing these two different chunks of work in two separate threads. So, I can't really expect them to be ordered in any particular way with respect to each other.   However, the bare minimum that I could hope for is that, I at least get complete lines.   Let's take that as our goal. Suppose we don't care the order the lines come in, only that we get complete lines. So, how do we accomplish that? Well, as per the common myth, let's see what happens if we try standard endline. Does this protect us in some way? Recompile Rerun But the output is exactly the same, garbage. I hope this helps dispell the rumor that standard endline somehow is better than newline because it fixes data races. It clearly does not do that. The underlying issue here was not whether or not the data has been flushed to the file yet. The real issue is that we have two threads trying to write to the same place at the same time. If changing a newline to an endline fixes this problem for you, then you got lucky. Most likely this did not fix your issue and it just made it less likely to occur. So, you now have the same bug that will only manifest in a very rare case. Maybe it only happens every 100th time you run the program. And honestly, to me a bug like that is much worse than a bug that fails everytime. At least, if it fails every time, I know something is wrong and can try to fix it. If endline doesn't actually fix this, then what's the real fix? Let's take a look at the solutions for C++ 20, C++ 17 and C++ 11. If you have the luxury of using C++ 20, it's really simple. Start by including the syncstream header. Make a standard osyncstream that wraps the output stream that you actually want to write to. Then everywhere that you were going to write to the output stream, write to the osyncstream. osyncstream guarantees that it's safe to write to an output stream from multiple threads as long as all of those threads write to it through an osyncstream object. Under the hood, it uses some kind of lock or mutex in order to accomplish this. It will acquire the lock or mutex on construction and release it when it's destructed. And while we're at it, since we're using C++ 20, we might as well use jthread instead of thread. jthread is the same as a thread except it automatically joins in its destructor so you don't have to remember to call join. And here's the output. In that case, as you can see, we get only complete lines in the output. Of course, these threads are computing. So, the order of these lines is not deterministic. If I were to run this again, I would get something completely different. So, the order is still not guaranteed. But at least, we don't have any mangled lines. Okay, what about C++ 17? osyncstream and jthread were added in C++ 20, so we need to use something else. osyncstream took care of the mutex for us. Prior to C++ 20, we need to do it ourselves. So, include mutex and make a global write_mutex. You might be tempted to just lock and unlock the mutex yourself and that would probably work. But that's not the best solution. The issue with this is that if an exception is thrown even if you handle it somewhere else, you might not release the lock in time. In C++ 17, use scoped_lock. It locks the mutex on construction and releases it on destruction. If you're using C++ 11 on the other hand, then use standard lock_guard. It does the same thing as scoped_lock. scoped_lock is basically just an all-around better version of lock_guard. Of course, we can't remove lock_guard from the language because people depend on it. But notice that for lock guard, I have to specify this is a standard mutex, whereas for a scoped_block it was inferred. And scoped_lock can handle multiple locks, whereas lock guard can only handle one.   So, that's the real way that you fix these mangled lines in C++ 11 through 20.   Finally, let's take a step back and think about the design that we have going on here.  I didn't really mention it before. but anytime that you really have two threads competing for the same resource like this, you might want to rethink your design. Although the mutex is protecting us from undefined behavior and mangled lines, it's not protecting us from bad performance. We still have two threads that are constantly fighting over acquiring this mutex. This is going to be horrible for performance. Instead, we may want to implement our own buffering where we say, write a thousand lines into a local string stream and then only try to grab the lock and write to the file every thousand lines. This is going to be much better for performance because each thread acquires the mutex a thousand times less than it did before, meaning there's way less contention. And another design decision that you might want to think about is that it may not be the best practice to have each thread just trying to write to whatever file stream or standard out or whatever. In larger applications, it would be a common design to have a single thread in charge of all of the printing or writing to file that needs to be done. And other threads just submit data to the printing thread through some kind of thread safe queue. Hey, thanks for watching and since you made it all the way to the end you get to hear about the giveaway that I'm doing. This is a paid editor for C and C++ that I'm using called CLion. If you'd like a chance to get a license for free, then be sure to make a comment including #clion below. Thanks to jetBrains for providing the licenses. And as always, thank you to my patrons and donors for supporting me. If you enjoy my content, then please consider becoming a patron. Thanks and see you next time.