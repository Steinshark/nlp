one Trend we've seen a lot in programming in recent years is the attempt to replace C and I think that's both wise and terrifying it's wise because C's about 50 years old and being old doesn't make it bad but it has given us five decades to think about what works and what doesn't work in programming language design we've got 50 years worth of techniques we really ought to be putting into practice and putting them into practice is the terrifying part because C is everywhere you may not write C but I guarantee you're writing something that runs on something that runs C and was written in C it's in the compilation stack for everything we install so if languages like go and rust want to become the new SE they've really got their work cut out for them all of which makes this week's topic kind of breathtaking we're looking at Zig it's a language that's not only trying to take on C and C++ and rust and go for that systems programming Crown it's also trying to replace the infrastructure that c itself gets built on things like llvm so it can hopefully become the best way to build systems level software across all different architectures Zig ends up being a project with a huge scope and if you're a fan of programming languages there is a lot to chew on this week we cover crossplatform compilation to memory management techniques to new thoughts in compile time metaprogramming as well as when you've got these huge long-term Ambitions how do you structure an open source project for long-term funding there is a lot of ground to cover so this is a bit of a longer episode than usual and we best get started I'm your host Chris Jenkins this is developer voices and today's voice is Loris [Music] Crow [Music] I'm joined today by Loris Crow how you doing out there Loris hello hi ch um pretty good thank you good good it's good to have you here I always love it when we do a language Deep dive because I'm a particular fan of the world's programming languages and you're going to tell us all about zigg which is a language I don't think I'd heard of until we had uh yuran Dirk grief on the show from tiger beetle who said they've written a new database in Zig and I thought we have to do something about Zig I have to learn about that so let's start here I always think new programming languages come into being as a reaction to what's missing in the in the marketplace if you like like there's a burning reason why Zig needed to exist do you think that's true what zig's raise on Ed uh right right so I I guess a a way of answering this question like factually uh is maybe to look at how it was created originally so the original Creator Creator uh Andrew Kelly uh wanted to make a digital audio workstation uh software for music for making electronic music and that kind of exactly yeah yeah and uh he tried a bunch of different languages and he was unhappy with all the solutions with all the um trade-offs that each offered so uh I think he started with higher level languages and then quickly found out that to do real-time audio processing uh you can't use a language with like uh automated memory management and like languages that don't give you precise control over the hardware yeah because audio is one of those places where we're talking hard real time exactly yeah you have to be there on time yeah and uh but on the other end of the spectrum um at the time the like the main languages that did give you uh full control over the machine were like CN C++ and um each had its own like if you will baggage of issues which some of it is also up to like Personal Taste um but for example C is very low level but it does doesn't have good metaprogramming facilities C macros are very well known for being not particularly good yeah yeah yeah they're not much better than string mungin right yeah exactly you you mess around with with strings and you have a lot of like unwanted side effects yeah often times so it's uh it's a food gun that that's how we usually think of it yeah yeah um on the other hand you have C++ which I don't know if he actually did attempt to use but in general C++ exists in a space uh where the language is very powerful it's very complex and um it's a type of language where you are heavy with abstractions often times and uh that kind of detracts from what you're trying to accomplish or or rather I'm some people can definitely make it work for them and that is their preferred way of programming so that's good but for some other people uh C++ doesn't really um you know it doesn't uh feel good in your hand as a tool for some people yeah I can see how people we're not going to start a language War but you can certainly see how people would feel that way about C++ abolutely and and to me you know this is not really a thing of language War at all like I can fully appreciate how somebody who likes that way of doing things can make it work for them uh and but on the other hand like for me personally that doesn't that way of doing things doesn't really click so ultimately I can totally see how somebody would be productive with C++ and I wouldn't so I need a different tool right and I think that Andrew also shares uh generally speaking this perspective so uh he wanted to make a language that was uh lowlevel so that gave you full control over the machine that would be suitable for an audio workstation and that on the other hand it wouldn't be overly complicated and there's like a a sentence that you can you can find in uh like zigs uh on on the website where we say uh it's one of the first things that you can see on the front page it says uh focus on debugging your application rather than debugging your programming language knowledge right yeah yeah okay so that's kind of I I know people anytime you write something that's sort of competing with C in the lowlevel world someone says why not go and why not rust but you yeah you begin to demarcate those as I'll let you answer it why is it not go or rust uh so the reason why it's not rust I would say is that like the answer is very in a very general way it's kind of the same answer as why not C++ I think the rust is another language that likes its own complexity and it gains a ton of power from that for sure but uh but the complexity is there uh and um and also um when it comes to like giving you full control over the machine rust it's not entirely of that opinion like rust uh for good reasons for for for safety reasons rust wants to um relegate certain things inside unsafe rust which is a part of rust that you are not supposed to use lightly so that means that you will find out there libraries uh that uh when choosing between maximum performance in safety they will choose safety probably over performance often times because you do get audited if you have unsafe or not so in in general R is going for something slightly different than what Zig is going for okay uh so both in terms of like trade-offs between performance and safety but also in terms of uh abstraction and I would argue also like readability in terms of like the complexity because writing abstracted code makes it harder to understand and to read for for a consumer uh when it comes to to go um I think that go and Zig both share an appreciation for Simplicity although go is not just simple it's also very minimalistic um so I I would say that there are like some parallels between Zig and go but we don't have the exact same take on everything and I can get more into detail if you want later um but but ultimately go is not as lowlevel as rust and Zig are um I would I am not sure if would be the best choice for an Audi workstation for example or for an operative system because go has a runtime has a garbage collector also interoperability with C is a bit complicated Ino because well first of all everything any language that has a run time that makes interoperability with see a little bit more complicated because you need to uh give information to the runtime of your language to the garbage collector about about what's going on with memory and so that sometimes makes things a little bit awkward but with those specifically um I do think that the for the go team interoperability with C was never a priority or something that they really liked so go can call C functions for example uh but you cannot do the inverse easily so you cannot make a go function that can be easily called from C and I think basically this is like a uh a philosophy of the go team like they basically said no we want to do something different we don't want to do something we don't want people to rely too much on like we want to be able to consume C libraries but we don't want to do uh the inverse if you're in goand you just go I think that's kind of their their philosophy there yeah yeah it's like we want to be able to reuse existing CA but we're not intending to live in the same ecosystem quite yeah exactly I would say that and you can see that also in a bunch of choice that they made also with how compilation Works in go um like in terns of the compiler but I think it's a reasonable it's a choice it makes sense uh very different from from what Zig is going for yeah there's there's a I don't think we need language Wars because there's a huge design space to be explored and there's plenty of there's plenty of land for everyone right yeah but okay so that demarks what you want to be what's what's zig's answer to this set of design constraints um I think that I think the most interesting part about the answer to like let's say systens programming like lower level programming in general is to rebuild it from scratch uh all these other languages that I well not all these other languages but like it is common uh to consider kind of like see the bottom layer of obstruction of what you're building so for example there are programming languages that compiled to C code uh I think Nim is an example of this and uh rust itself rust doesn't compile to C but for example rust depends on the C standard library of the platform that you're targeting so if you're writing a Linux program like a rust program that you want to deploy on Linux rust will use the Lipsy of your Linux distribution um okay with Zig the idea instead is to really really build everything from the bottom up and this is a big scope this is not like for the faint of heart it's it's a lot of work but it does yield some very good um uh results like some some very good things that you can do once you are willing to do that work so I would say that the most important interesting thing about Zig is that it it really is a language that allows you to build for every Target from any Target meaning that um if you want to Target like not just normal computers but also very tiny embedded devices you can do so easily and that's also cross compilation because you're T like you're compiling on a Linux machine probably which is going to be maybe x86 64 and you're targeting a very tiny arm V8 embedded device so you're you're comp there but this is also from computer to computer so with Zig it's very it's considered fundamental the ability to build your program for Mac OS Windows Linux from any of those other oses so from Linux to Windows from Windows to Mac Etc that's surprisingly rare but a very nice feature and it doesn't end here because we can do this for Zig applications and to be fair I think that go can do it for go Ras can do it for rust but they cannot do it for C while we can do it also for C and C++ so the idea is that if Zig if you have a project that has Zig code in it and also a c dependency not only you can cross compile the zig part but you can also cross compile the C part really yes and that is I think the huge thing and it's so big that actually you can use Zig as your cc++ compiler when you are trying to cross compile a rust a mixed project between rust and C or a go and C1 so for example go people have been using the zig compiler to enable to complete the close the circle to to enable complete cross compilation of uh SEO programs SEO is basically what what you call a project that has both go and C in it C go is like a component of of their of the go compiler that's how compile in link uh to to C code so uh so go people having using go projects they are using Zig to cross compile and same with rust even AWS is using um Zig to cross compile rust lambdas for their Lambda engines because rust depends on the lipy of the Target and their their machines running Lambda functions are running a specific version of the of Linux with an older libc and you need to be able to Target the correct version of the libc to make sure that everything uh runs smoothly right and that's not something that normally compilers can do uh and Ras itself which doesn't concern itself with C compilation at all certainly cannot do so they have there's a package called cargo Zig build that allows you to use Zig to basically link against the correct lipy version that works on Lambda how on Earth is that working are you telling me that Zig also has a c compiler built in or yeah it does it it's straight up does okay so and Andrew started out trying to build an audio workstation and ended up building a language that also includes a sea compiler yeah pretty much it's legendary yeah and man and this is like uh and I would say we're like halfway through the Journey because we want to get even more hardcore than this so I mean if you want we can change subject otherwise I can no I'm fascinated keep going yeah okay so uh do you remember when uh Apple released the uh M1 architecture right so they went from Intel to arm uh and that was big news because well turned out it's also pretty good uh CPU like pretty good architecture new Max I I would say are pretty nice from uh like a they're powerful they overheat bit less it's they're nice so uh when Apple released the M1 uh Zig was the first compiler that was able to cross- compile for M1 from another Target from another machine so Apple obviously when they Rel well well not only when they released but also while they were developing the M1 obviously they had tooling to compile for the M1 but they never released over when when everything came out they had not released any tooling for compiling 4 M1 from another machine oh so you had to buy the new Mac in order to build for the new Mac exactly because what you would get was uh when you have mechos you get a clang like you get a fork of L lvm um which is uh yeah it's I I would say it's kind of pretty much all VM except with like private patches that apple makes specific to their system and when the M1 came out they had patches specific to the new architecture so you could compile uh obviously from M1 to M1 but lovm itself the open source project did not support M1 yet fully and so you could not get lovm like on Windows or Linux and then use that to compile for M we were the first ones and that was because um not only Zig is a s compil and to be fair the Z compiler stuff right now I would say at its core is not super impressive the the idea is that Zig uses lvm and lvm is like this library that allows you to uh it's like a unified framework uh for optimizing for generating optimized machine code so the idea is that you uh your compiler reads the program that is trying to compile builds a data structure in memory does semantic analysis all the usual stuff that are language has to do but then the final step is to give some of that information to lovm which will then take care of selecting which exact instructions uh to use for the for the CPU that you're targeting right so it's I suppose want to say it's almost a little bit like web assembly it's like a very lowlevel language that's actually going to generate the final machine code yeah that's probably a bit of a stretch but I think that's fair that's what that's the that's called the LM IR intermediate representation yeah that's what you create which is a bit code of some kind and bite code sorry of some kind kind kind of like a uh web assembly I I think that's a fair parallel okay um yeah so we give that to LM and uh since we already bundling all of lvm it doesn't take much to also add clang which is the C compiler that runs on lvm so that what's allow us to to build C there's more than Zig does but at its core is not super complicated uh but but um a compiler is just one step necessary to create an exe a final executable there's also a Linkin page at the end so um the main problem with uh the new M1 Max was that linking uh needed to be different than it was in the p and the reason why we were the first ones to be able to cross compile 4 And1 uh was because we had our own in-house Linker uh there's a core team member in the Z project uh his name is Jacob cona and he used to work in Microsoft and we kind of poached him um to work well he I guess he poached himself he wanted to work on on on linkers uh I think at Microsoft he was not working on anything even remotely as exciting and so he decided to jump ship and join the Z project full-time so he we have our own link here and most of the work is done by him um and so that my point here is that by having our own Linker we were able to reach to to have a feature even faster than lovm could and lovm is considered in general like a very good project and it is and it is yeah um but by not the point is that we did not consider lvm the Baseline we were willing to get past lvm and do some of that work ourselves and now going forward and this ties back to my point that we are only halfway through our journey now going forward we plan to make lvm a completely optional component so that means that we have our own implementation of some of what lvm does so we have what we call them be hands so we have our own implementation of what reads the internal representation of the compiler uh the internal data structures and decides which instructions to Output uh that's a lot of work because you have to build one of those things for each architecture that you want to support so you want to support x86 64 that's one implementation arm 32bit another arm 64bit uh x86 like 32-bit x86 that's another one uh um there's more architectures out there so for each one you have to write a specific one and then you have to write uh another bit uh based on the OS that you're targeting so like xd6 64 Windows is a little bit different than exit 664 Mac not in terms of like the instructions of the program but like the packaging like how an executable is structured all the like surrounding metadata the framing in a sense right yeah and we're doing it now uh the work that we're doing in that regard right now is not to replace lovm in terms of optimizations so the the bulk of what LM does and what it's considered state of the art for is optimizations we are not doing that yet what we're doing right now is uh basically do the work so that we can have debug builds which are not optimized uh happen without needing LM at all ah that's our starting point but the plan is going forward to basically have a competing optimizing backend so you will still be able to use lvm if you want um how it's going to happen in practice doesn't matter much I think it's going to happen that you basically will need to get lvm through the package manager so you you will use the Z package manager to get LM instead of getting it bundled in the compiler itself but then you will be able to get an lvm optimized is final executable regardless but we're going to work on our competing version and you will decide which one you like more and over time if we do a good job it might even be that our competing mean becomes compelling enough that people will use that one over ovm C it you're not kidding about going all the way down to the lowest level right yeah jeez yeah okay that that's what's your timeline for that oh that's got to be a multi-year project right 100% uh yeah for sure uh honestly I don't know what the timeline is going to be the reality is that the the timeline of these things can vary dramatically depending on the amount of talent that you attract uh one thing that the people usually uh say when when we first tell them yeah we want to get rid of LM uh they start by saying oh you're insane you're never going to be able to do it there's a bunch of geniuses that work on lvm um Fair fine let's assume that that's right I mean I'm sure that the people work on lvm as smart um but it's not like they are bound by a blood contract to work on lvm and if we and working on lvm it's a humongous C++ project takes forever to compile and it's in some ways like it's messy what if we were to be able to present to people working in that field uh another ecosystem where they can research the same exact kind of of optimizations that they are researching and implementing on lvm but the compiler instead of taking four hours to build it takes 20 seconds I imagine that would be very seductive and I think you're deliberately trying to seduce people Z side is fair and I mean we already have people in the court team who have Push access to lvm so it's not like we are like uh well I I don't know anybody who is part of like the the leadership of LM so I wouldn't say we are like insiders um but we we already know people who do this so there's a yeah sounds like there's potential for both knowledge sharing maybe some more kinds of sharing out there absolutely and absolutely and if lvm also ends up benefiting from this it's great for everybody sounds like one of those whoever wins we all win situations absolutely okay this is getting very low level maybe we should try and pull it back into user space love the ambition though absolutely but I I do want to get a sense um of what it's like to write Zig what am I going to find as a programmer what am I going to like need to learn right so um the the hardest part about Zig is not Zig at all Zig as a language is very very simple the most complicated part of Zig right now is comp time which is the ability to run code at compile time instead of run time and if you're not used to thinking about uh the two different like uh lifetimes of your program the two different phases of its life then you might get a little bit confused about what it is that you can can do at comp time or what it is that you cannot do at comp time but overall the core principle is in my opinion kind of straightforward where things get complicated is once you get into systems programming more in general so if you like a JavaScript or a python developer and you never had in your life to think about stock versus H or maybe people told you but like if you're a python programmer this is something that also happened to me like in University um if you do Python and people tell you about stack versus Heap that's like philosophy to you because that's right you don't have control fascinating but you'll never use this knowledge exactly like you don't have control over it and and yeah but when you're get into lowlevel systems program suddenly this becomes a real concern right exactly and so people so the hardest part is for example understanding the difference between um an array of which of whose length you know you know statically like this is going to be a six element array and it's always going to be six or maybe uh you know you need up to six slots maybe at some point in time you you use fewer than those so you have like a counter that tells you how many slots you're using but six is the limit so and if you know this statically at compile time then this can be put on the stock and there are some things that you can do with with this memory thanks to the knowledge of the fact that it's bounded to six elements and this you know exactly how much memory it's going to need for the whole lifetime of the program exactly and that is critical information for the compiler itself like the language uh lower level languages are like designed around these very critical concepts of like what you know statically and what you do not know statically so if for example instead you have a program where you ask the user to tell you how many items they want to enter and they are allowed to enter 10,000 if they want or um more realistically imagine parsing a Json file like a Json file can be arbitrarily deeply nested or big in general so in that at that point uh you need to concern yourself with hip allocation uh which again is something that in Python in JavaScript you don't do directly because the runtime manages that for you yeah uh so that's one example another example is all things that your platform like apis that your OS uh operative system gives to you which people sometimes are used to think about as in terms of capabilities that the language gives to them even though the language can only act as an intermediary so for example sometimes people uh ask um how do I get the size of the terminal window in Zig and the answer is well the question the real question is how does your OS allow you to get an information right and then and that's going to happen through a CIS call of some kind and then the the I guess the secondary question is where well has somebody written the boiler plate to access that CIS call and where is it in the zig Stander Library so the question of how you do like this kind of stuff in in Zig or in in each specific language it's not completely wrong it does make sense but um understanding what is the actual API below you can be a little bit annoying especially when the language uh wants to show you precisely what what that is and it's not trying to give you a sugared interface that is overly simplified um because sometimes you do also get that in other languages which might make sense like a higher level programming language it makes sense that it doesn't give you necessarily lowlevel access to like to everything um so I would say these are like the biggest challenges people need to learn systems programming they need to have this mindset where they have to think okay how like when for another example people sometimes ask how do I print colored text in the terminal how do you do that in Zig and the answer is Zig doesn't concern itself with this like these are Escape codes it depends on which terminal imator you're using and a bunch of other related concerns that really are pretty much trans arent to Zig uh but people don't have this mindset so I would say that is the hardest part about learning Zig and connected to this there aren't a lot of good Learning Materials in my opinion ah so this sounds like um the usual kind of youngish language problem where maybe there isn't a library for everything yet and there AR there isn't documentation for everything yet yeah for sure but also I mean it's not like Zig has invented systems programming so it would be nice right if there was some good piece of like a good book that taught you the core principles uh without too much fast and and in fact there are plenty of books that try to teach you these things it's just that in my experience most of those that I've seen they tend to conflate C specific stuff with the OS so for example you have this book that it's trying to teach you systems programming and it starts by telling you about how the C compilation model works and how that intertwines with like how libraries are uh certain files are like laid out in your system and this is all real and concrete and it was especially real and concrete and concrete like 40 years ago but those Concepts uh like in other things like macros and where things are usually the is on library but those those are things that are specific to C so if you're not doing C A lot of these things are not as Timeless as the book thinks they are while instead stuck versus Hep that one is much more Timeless so personally I think that we're missing learning materials that can discern between really Timeless systems programming Concepts like Stu versus hip uh versus cisms that are not they relevant anymore yeah yeah that's a sort of uh long life cycle but not not mathematically pure you almost say yeah yeah okay but so I would like to talk about how the C interrupt works and maybe this is the way to do it so if I'm if I'm actually looking to get the size of a terminal window am I going to go looking for a sis up call and find I actually have to do it through an osc library and how's that going to play out when I actually start coding so uh well I guess it depends on the US let's assume that Theos is Linux okay for Simplicity so if Theos is Linux uh you're in luck because in Linux uh the CIS calls are considered a public API of the OS so you are not forced to use the C library of your OS you can invoke the is calls directly and in the case of this since we like doing things from scratch uh you will find in the zig standard library that we do implement the CIS call which I think it's iocl um the CIS call that you can use to get that information from the OS so in the case of Zig uh so yeah in the case of of Linux that's how you find that out um but in other platforms yes you would have to use Cel although we do have also bindings to the Cel so in practice you wouldn't have to do everything yourself from from scratch um when it comes to like these very common things but let's imagine that instead you want to use like a C library okay let's imagine that you want to use I don't know SQ light uh by the way SQ light is a perfect example of a very popular Library used for example by go there's a lot of go projects that that bundle site but site is a c project project so uh that that's one major use case of people using Zig to do cross compilation when they also want to bundle SQ light anyway uh you want to use site so uh at its Baseline here's what you want to do uh you want to the way this stuff works in C is that you have C files that contain implementations of things and have header files which are like files with a h extension and those files contain definitions so they contain they do not contain full implementation they only contain like the signature of of a of a function for example the original kind of API docs right exactly the original API docs like they're there um what's it called is it called open API I think uh the thing they used to be called swager it's basically like it's a system to document like restful apis right that's kind of the idea except systems programming um yeah so the way this works is that then uh site comes with bunch of C files and one header file that you are supposed to include in your project to to get access to to the public API with Zig you can do that directly so in Zig you can import a c header file and it will work right away like you import that and you immediately get access to all the definitions in there oh interesting okay so there's no kind of bridging file that you have to write well the bridging file in a sense gets autogenerated that's the idea right okay so you don't see this and actually if you do want you can do that manually like you can take the header file translate it to C definitions and in case there's like the need to tweak something manually you can do that if you want uh but the happy path like the the most common way you will want to do this is just straight up import the header file and have Zig do that bridging internally okay um then at that point you can just straight up call all the esuite functions that are defined in there so you can you can just like go read the esuite documentation and they will tell you call I'm making this up I don't remember how to use sqlite but there's going to be maybe SQ this is a test of the SQ light header API syntax don't worry okay so there's going to be maybe some kind of sqlite init function so you just call it and it works um there's also a couple other things that Zig does that help you with interoperability with C so for example C uses null-terminated strings a lot uh so basically there's a you when you want to give to a function a string you give it a pointer to the beginning of the string and the pointer doesn't carry information about the length the length will be discovered by the function that you're calling by iterating through the sting through the string until it encounters a zero character once it like a zero BTE once it finds a Zer B it knows that the string is over uh modern languages don't like to do that anymore modern languages very much prefer something else I'll tell you my age I can remember when we didn't like to do it at the time so in Zig for example normally a string it's not just a pointer to the beginning of some data with a null at the end but in Zig it we use slices which other languages sometimes call Fat pointers so the the tiny what you call the pointer is a pointer but also a length so yeah you you have both information and to be fair sometimes in see you also have apis that want a length not they don't want to disc discover a null bite at some point but they want you to pass in a length but those have have always to be two separate arguments two separate values that you need to uh move around in parallel anyway um so how does z uh help with the inter interoperability well uh string literals in Zig are not terminated so in basically when you write I don't know hello world and you want to use that string literal in Zig that's going to be a pointer plus a length I don't know how long hello word is 10 characters nine characters whatever depends whether you include the traditional exclamation mark at the end okay so so you do have this information but there's also going to be a null bite past the end of the string so you can take a c uh a zig string literal and pass it to C transparently no need to do anything else and it's always going to work and More in general Zig does have a bunch of functions in the standard library that allow you to um deal with null-terminated strings which are not the preferred type of string in Zig like you don't treat strings as null terminated normally but uh n terminated strings are a reality because not only because of C interoperability like in terms of SQ light but also because of C interoperability with the OS like OS apis the lib C that's C but also the CIS often time inherit some cism some like some ways of of communicating data that are like mirroring what C does yeah unsurprisingly right unsurprising often the OS is WR in C so exactly because us is written in C because that's that's maybe how people used to do things at the time and so these things are still there yeah yeah and okay so to conclude yeah uh you have string lons you have a lot of other like operators in Z that you can also use with C functions um very easily kind of transparently um but just to name one I think it's really cool you can use the fur so the fur is almost the same concept as ghost theer there's like some minor differences um but the idea is that basically if you want to free a resource while when exiting the function instead of making sure that you call free or like file close for example like the whatever results release function you need to call instead of making sure that you copy paste that call at every exit point of your function what you can do is on one line you open a file and on the line below you defer close it oh okay yeah so you have basically clean up that you can put immediately after the creation of the resource and whenever you leave that scope no matter how you leave it whenever you leave that scope that function will be called yeah because it's always deeply dissatisfying that you have to you have to remember to stick the close call or the free up call at the end and it just it just scream this is going to get forgett one forgotten one day right yeah absolutely so the fair saves you from having to be too careful about like branching paths in your function and if you look at it from a and maybe it's not as handy as you know what C++ can do with Ry with with distractors they run automatically you don't even have to ride the fur but C++ distractors only work with C++ the fur in Zig also can be called on C functions it's completely transparent so there's this funny end result we we where basically Zig in a sense is better at using C libraries than C because the same cleanup routine in C would require you maybe to even use goto like it's not uncommon for people to use uh goto and have like a a label like a section of the function with all the cleanup functions but it it gets really messy like uh I don't think I am able to fully convey how messy cleanup can get in C because it doesn't have the fur I can believe yeah absolutely that's interesting that's interesting still being in sea but building on it with new syntax I have to ask before we leave this particular thread what about pointers do pointer does pointer arithmetic come into Zig uh pointer arithmetic can come into Zig by the way that's a great point I was forgetting that's another great um Improvement overse that also helps beautifully with interoperability so you can do pointer arithmetic in in Zig if you want to uh because because that's what the machine allows you to do and maybe occasionally some OS API will require you to do so but in general you do not do pointer arithmatic in Zig and specifically in Zig you cannot do so in the type system you are not allowed to do arithmetic on pointers what you have to do is take your pointer convert it to an integer which is not like an operation that that does anything at run time it's just like um a type system thing like you have to be explicit about taking a pointer in interpreting it as a number apply the math to the number and then convert it back to a pointer so you can do it if you want or if you need probably if you need you shouldn't want but the language is not going to make it easy or like very comfortable to you there's a little bit of friction introduced there and on on the flip side it helps identify very quickly where these kind of shenanigans are happening right so it's it's mainly there for the sake of C interrupt rather than writing Zig dayto day exactly and I mean we say see interrupt but I don't know there might be other things out there like I'm thinking of firmware like you programming a tiny embedded device and you need something like this because of the very low level stuff that you're doing which is not really necessarily specific to Z to see anymore but it's like low super low level bit fidling maybe at that point you need something like this um but otherwise you normally don't and still related to pointers there's another crucial thing pointers in C are very underspecified in the sense that you see a Char star so you know it's a point pointer and when you de reference it you get a character but then the question is can that pointer be null or not you don't know maybe documentation tells you but you're not sure normally the second question is okay am I I'm getting a character at the end of this poter assuming it's not null now is there going to be just one character on the other side or is this like a string is this like expected to have another character afterwards and another one afterwards until I encounter a null is there going to be a null or I might supposed to know how many items to get because of another variable this is not encoded in a type system at all in Zig all of these are different type of pointers so if a pointer can be null it's an optional pointer so we do the thing that all modern languages are doing where you have like the concept of optional and then you need to the optional um and we use that to represent n pointers but then we have types for so you have normal Zig slices which are a pointer and a length but then you have a style pointer that can be that's going to be a pointer either to one item one specific item so you're explicitly saying that's going to be one character one chart at the end not many or there's Syntax for saying No this is like a pointer to a unknown number of characters so there's specific syntax it's going to tell you yes this is a pointer to many items but the pointer itself doesn't tell you how many and then there's a pointer to an unknown number of character with a n Terminator at the end and this is in the type system so for example if you by mistake think that that you know you're trying to uh create a string off of another string and so like you may maybe take a tiny slice from the middle of the string and you try to pass it to another application and you forget that that that that um that API is expecting an alter intern at the end which is not going to be there because you you just split off like a tiny like two characters from the middle of a string right so there's not going to be an Al Terminator on the other side the zig type system will tell you it will give you a compile error because it will tell you I'm expecting an alterated string but the the the operation that you like the slicing operation that you did on the other string does not yield an unterminated string so you will get a compile error right away instead of having your program read random garbage and maybe sometimes crash yeah yeah that's that's one of the question I have to ask you then CU I can see right now this appealing to people that need to use C don't want to use C got into rust didn't make friends with the borrow Checker yeah and now have could find Zig being the ideal place if I want more Ty type safety around SE particularly around strings yeah what about memory management because that's the other big sticking point right yeah agreed uh so in general so if we want to talk about if you want to talk about ergonomics what I just what I described earlier like the the first statement that really helps a lot with memory management uh because you allocate a resource defer free it and you're good to go you need to there explicit like aloc maloc free call in zigg land exactly and uh to to be even more concrete about this um Z does not have a global allocator so in C you have maloc and maloc is like the allocator and maybe different projects use a different implementation of mlock there's like a few competing implementations but in in Zig libraries there's this uh idea that in C libraries there's this idea that you have maloc coming from the echosystem that allows you to allocate memory in Zig allocators are always passed around explicitly so if a function wants to allocate it needs to accept an locator as input interesting yeah so this makes it more easy dramatically more easy to audit what it is that's allocating memory or not if a function doesn't accept an allocator or a data structure that bundles the allocator in it like it's also like for example we have array list which would be like equivalent of a C++ Vector so like it's a growable array right when you make an array list you give to it an allocator and then when you when you pass around the array list the array list will be able to allocate because it bundles a reference to the allocator inside of it um that's for convenience but in general you can very quickly audit if a function can allocate or Not by does that help you audit if a function is forgetting to deallocate D by itself no what it helps is that the uh doing that is that the what we call the general purpose allocator the main allocator implementation that you find inside of Zig in standard library that allocator in theb mode has Leak Detection so you cannot check statically if all allocator allocations are freid or rather you can't unless you're willing to become rust rust can uh with all the limits they also have limits on on the type of like memory management strategies that that the Bor Checker can understand but they can we can't but we can instrument the default allocator with with uh checks for leaks uh in the bug builds so when you run your tests basically uh the allocator will fail the test if at the end of it you have like still memory allocated okay and that's default built-in part of the test site you don't have to specifically instrument exactly you don't have to do anything oh that's nice that's nice actually yeah there's another um angle to this also which is that um it is correct for programs to want to leak memory occasionally in this sense uh I'll use the Z compiler itself as an example so the Z compiler um when built in the back mode will make sure to free everything when built in release mode it will not free once it's about to leave it will not free memory when once it's about to leave uh to to close because the OS will clean up that memory anyway and there's no point in freeing every single item that you've allocated if your program is about to exit like making sure to free tiny things makes perfect sense when your program is going to use a ton of memory or it's going to be super long lived like otherwise it's going to consume more and more memory over time until it eats all the available memory and everything explodes yeah um but for like let's say one shot programs kind of like a compiler is like you run the utility it runs to the end and then it closes um cleaning stuff up at the end is just wasted time so um have you ever used like Visual Studio no for so long I can't believe yeah um thankfully I haven't had to use it in a while now now but a few years ago like seven years ago or something I had to use it consistently and it drive me nuts that when you close it not only it takes forever to load that that is already not okay but when you close it it takes forever to close why why is it taking forever to close because as it's closing it's trying to free and run the destructors of every single component and subcomponent and Subs sub component I have a vague memory of doing this with eclipse and just getting into the habit of force quitting cuz who cares exactly exactly and and eclipse is another uh in Java I think it's another language that has destructors and and so kind of makes people want to use them a lot but then there's moments where you actually really in terms of like functionality that you're offering to the user you don't want to do it like you just want to close it right away yeah uh so long story short I I made this point because in reality it is a legitimate Behavior to have the program in specific circumstances link memory if you think about it because like for real like the user experience would be genuinely significantly improved in both eclipse and visual studio if the thing just exited right away of course you you do want to have a toggle like a flag that makes sure you free all the memory cleanly so that you can guarantee that you do not have unwanted leaks like you you visual studio for example is a long running program an eclipse yeah so they should not be leaking memory in the normal operations so it's not so you still want to be able to uh test for that there are like two men there at least two memory management strategies one is be very careful about what you're using because it's a limited resource yeah but for the long run you know what whatever memory you're using at the end you can just drop on the floor right exactly yeah yeah that makes perfect sense that there's one other big thing that you've talked about a little bit but um I'm tempted to run over our usual time slot because I'm fascinated by this go for it I I'm not in a rash for sure good okay so comp time you talked a bit about that and as an old list programmer this is a concept that makes sense to me but I think it's never really gone mainstream yeah why don't we talk a bit about the separation between runtime programs and compile time programs sure um so let me tell you about how Zig does this more specifically um so comp time in Zig is interesting because um Zig as a language doesn't have runtime type information so for example in JavaScript python also in go you can ask questions to the program running at run runtime about its types uh C programs on the other hand don't have a runtime and they don't have runtime type information usually it's not always the case but usually runtime type information tends to go hand inand with an actual runtime of the language so for example in Python you can create new types at runtime you can do introspection and so having a runtime that can um yield those Dynamic properties to you um usually benefits from having runtime type information uh C doesn't have those facilities because like a struct in C at the end of the day boils down to offsets in memory uh oh the struct is I don't know uh 16 bytes long and eight bytes in uh and like the first uh it contains two Fields the first field is at offset zero and the other one is at offset eight and that that's the end of it so everything else has disappeared um but it is useful to be able to inspect types and reason about types at least statically so that's what Zig does ZIG does not give you runtime type information but it does give you come time type information so you are not allowed you're not able to create new types at run time but you are able to create new types at compile time by reasoning on other types and the way you reason on other types and then by the way this is also what generic does in other languages it's just that this is usually done with um in other imperative languages this is usually done with a funky declarative syntax and a bunch of diamond brackets where you use Diamond brackets to denote like uh the generic type and then to put constraints on it using like some kind of declarative syntax like I want type T to be uh I don't know um uh to conform to interface a or interface B Etc okay so you're using you're saying you're using comp time to do things like I want a list of A's but now I need to pin it down to be a list of eight8 bit integers yeah yeah okay because you can because the idea is that you are creating a new type by in by referring to another existing types another existing type and the way you do this in Zig is not via this custom syntax but by using Zig normal Zig syntax so literally a list for example let's say you want to make a generic list and you want then to be able to make a list of integers a list of characters whatever the way you you implement this in Zig is that you create a function called list that accepts a type as input which has to be marked as a com time parameter so like the signature would literally read FN list open parenthesis com time T column type so it's a comp time parameter named T of of type type you have to pass in a type and so that could be like integer or whatever and then this function returns another type and in the function body you create a fun you create a struct defin you return a struct definition that places that defines the payload field like a Str probably that has the payload field of type T what you passed in which is kind of like generics work do but it's normal procedural Zig code that gets executed comp time so for example you could create like an uh let's say you're making a simple array but the length of that array you want to be uh the result of other reasoning you could create a Fibonacci function run it at comp time and and say that your array is long the 10th Fibonacci number which I don't know how much it is but it's not going to be 10 it's going to be a bigger number right so you can call normal run normal Z code it's going to be in interpreted by the compiler while compiling and usually you do have some of that in other languages it's just not fully general purpose they give you restricted language to specify properties and have they have their own special rules uh in Z it's just you run the Z code and and the compiler has like a concept of a execution quot so that like for example if you made a mistake and you try to make um you make an array is the 1,000 Fibonacci number but your Fibonacci implementation is very bad the compiler after a while was going to tell you um I executed like 10,000 loops and I and since we couldn't come to a conclusion I gave up and if you really think this is this is this is not like an infinite Loop then you can uh pull up that number like the number of executions before giving up and and we're going to try again but so that way basically we the the compiler is how it deals like with infinite loops and undecidable stuff yeah so you're protecting against people making accidentally making compile time infinitely long exactly yeah yeah yeah and Alan cheering has opinions on why you can't automate that yeah exactly so and you know what in our case I think it's fine in practice to solve the inability Problem by just giving up because ultimately like you're trying to compile a program and you're not willing to sit there forever or arit along to have it compiled so yeah okay so this raises two natural questions and the first has got to be what's that like as a as a programmer because most of us are used to using like diamond brackets for generics do you prefer the zig way does it feel natural once you get used to it I think it feels insanely natural like you mentioned earlier lisp to me I by the way I also love lisp I've never used lisp professionally but like in University definitely one of my favorite subjects and um and I also loved writing macros in lisp and it feels like writing macros in lisp or actually I would I would say it's even better than writing macros in lisp yeah the spicy opinion well so what I think happens with lisp is that people say micros and lisp are nice because lisp is an iconic language so the Lang itself is the data structure that represents it it's the list the yeah it's the well the the symbolic expression that represents it uh which is fair but I do think that the the actual truth is that by having the program be a data structure you are naturally uh the language is steering you naturally towards treating the program as a data structure instead of it being a textual transformation and in fact you can write macros in list that don't generalize really well that like make assumptions about um a specific like argument being an being or not being a list or being or not being quoted for example uh in Zig you are literally comp time is more limited than what you can do with list macros just to be to be clear and that's also kind of by Design it's kind of like of a 8020 thing like it gives you 80% of the power but it saves you from the 20% of really curs stuff that people will want to do all the time or or rather with 20% of the complexity which does save you from cursed stuff yeah um in Zig what you do is like the when you look at the type you literally call a function like you call at type info and you pass in a struct so let's say that you made a struct named person and person has age and name and then you call type info on person and what you get back is a data structure that contains like it's another struct that contains all the info about that type like among other things it will contain like an array that contains the two Fields with information about how the field is called what's the type etc etc and so your meta programming is always going to look at the program as data and never as syntax and I think that's the key that makes come time weirdly weirdly natural okay yeah yeah it does remind me I mean the frustration with list macros was always that they were untyped and you could really cause things to explode in an even more spectacular way than normal list absolutely but the nice thing was that there was absolutely no difference between writing programs that worked compile time and run time because it was the same tools same language same everything exactly and it's the same for uh for Zig um because you do use the same syntax you like I have an example on um a blog post that I wrote trying to introduce people to the concept of comp time and my favorite example in there is uh this idea that uh which is actually taken from real life experience uh I was writing a RIS client for Zig and in is you have commands like the query language of red makes you write commands that are case insensitive so if you write it upper case or lower case it doesn't matter so at some point in my client I wanted to recognize some of those commands so I wanted to check for equality between two strings and um my idea was well to slightly very slightly improve the performance of the comparison function if I know that the constant string like the string literal that I hard code in my program that I used to check the user provided string against if I know that that one is always going to be uppercase I can simplify the comparison code ever so slightly I can just remove one branch from the comparison um but now I have I want to enforce that when you call my equal function you always pass in the first argument uh the argument that you pass in uh like the first argument that you're passing is always going to be uppercase right so you want some compile time code check those strings correctly WR exactly now imagine trying to do that with diamond brackets stuff I have no idea if you can actually even pull it off here's what you do in Zig in Zig in the function body you open a comp time block well first of all you have to mark the first argument as always being available at comp time so people will be forced to give you it doesn't have to be string literal directly it can be like a variable name but ultimately the value contained in that variable needs to be resolvable at comp time it doesn't need to depend on weird stuff like the the network yeah um so you open a comp time block and in there you have a for Loop that Loops over the string and checks that each character is in the correct range that's it that's all you do nothing weird you just use the language to check the stram character by character and if you find a character that is not in your expected range so in my case it was between uppercase a and uppercase z um what you do is that you emit a compile error and like you can emit a compile error that says well you are supposed to give me a uppercase string and you didn't give me an uppercase string because this character is lowercase like you can even be precise and print the string and point out at Point at the specific character if you want like you can craft the message whichever way you want and that becomes the compile error and so now users of your API not only the constraint is enforced so if they give you a bad string they will get a compile error but the compile error is also going to be uh designed by you so people will get a nice compile from the compiler that will tell them uh you're supposed to pass an applic string but you didn't nice yeah so you can start doing bespoke compiler extensions and you don't have to learn a new language to do it nope that's pretty sweet okay okay that gives me a good sense of the of the footprint of the language so there's one of the big topic I think we should talk about um which is I thought it was really interesting the way that the zig project is funded right because every every language particularly in every open source project has a problem with getting enough work done because you've got to give up your day job if you really want a language to take off yeah and your approach zig's approach to funding is fairly novel tell me about that so Zig is a fber 1c3 nonprofit Foundation uh us nonprofit Foundation like 5 1c3 is a thing in the uh US legal system and it's been kind of set up like a charity yeah it's exactly what we normally would consider a charity so it's tax exempt and you cannot pay dividends so all the money that goes into the organization has to be used to pursue your mission so basically you have to use that money to run the company you can take it out and buy a yacht with it or whatever a mention um Zig is not the only language that has this uh legal structure python I think it's also another 51 C3 but not all languages are that some other languages are a different type of it's still considered nonprofit but it's a different type of organization and which does have to pay taxes uh this is a what is usually it's 501 C6 like it might seem that there's not much of a difference between three and six especially because it's placed where we normally in like sman versioning we would have like the patch number so you you think oh C6 C3 whatever it's like uh they fix the bug in there no that's there's a huge difference well no always consistent with version numbers but my God lawyers they can really change the rules between versions um so Zig specifically leaves mainly off of donations so most of our income comes from people uh donating money to the foundation so that we can move forward with with the development of Zig um some money also comes from other things so it's it's it's only it's mainly donations from individuals uh we do have also a good number of donations from companies but I think in terms of like if you were to uh do a pie chart and and plot them both they would I think roughly be balanced so we we do try actively to keep a balance between our sources of income uh because we don't want to get in a situation where like one entity or like a very small number of individuals end up having control basically over the foundation maybe not directly like right not legally but if they control the money flow then ultimately they do control the destiny of the organization Sly yes yeah and we do want to be able to say no to people um we do have support contracts um or rather we have one uh with Uber because Uber is using Zig to uh cross compile they are cross compiling I think uh as of today all their uh backend services that require cross compilation um because of arm servers mainly so like they wanted a while ago to be able to have arm servers and not just Intel well XD 664 and so they use Zig and and now they did the work to actually make sure that all their CN C++ stuff course compiles correctly and yeah so they have a support contract with us but then again it's not a huge chunk of our income uh and that is mainly to when it comes from from income so um related to this also we kind of want to be independent and we're very serious about this like we used to joke that uh like like the because you know people sometimes say oh if you want to if you want this your language to succeed like you cannot make a successful language unless you are supported by a big tech company and we kind of beg to differ but also um our standard offer is how much money whatever big te company wants to to give us in exchange for 0% of the foundation and zero seats in the board of directors but they do get Zig in the end so they do get something in the end yeah yeah there is some Qui proo but no power no power no control at all zero absolute zero and uh because we really want to make sure that we like the zig is a bdfl run project so also compared to other languages we basically ultimately have Andrew who is the creator who acts as like the the ultimate uh decision maker it's not only him there's a core team there's people there's a process which is also very public like you can read proposals to change the language on the GitHub and discussion happens in public and actually anybody can chime in but for example it's not a democratic process like if a feature proposal has a huge number of upates that counts zero towards the decision of whether to include that feature of or not in Zig right yeah that usually that has some downsides but usually has great upsides for design consistency absolutely and it's absolutely in my opinion fundamental if you want to have your language stay small if you don't want it to eventually devolve into a kitchen sink yeah that's true and there was a talk by the creator of the elm programming language recently that I think dove into dove into this General concept I think in a very nice way basically I'm paraphrasing and I'm going to oversimplify uh the the talk is titled the economics of programming languages I think it's from strange Loop and um well it was given at strange loop I highly recommend it but the the bit that I'm interested about was uh said something along the lines of um languages that are like 50501 C6 is like more corporate languages that end up having like a bunch of organizations come together into a like kind of Consortium or like a Trad Association um they basically look at the language as a Marketplace they look at the Shared infrastructure and all the Commerce all the Commerce all all the all the the business that this thing can support so which is reasonable right you look at a language like I don't know C or Java and those languages do enable a certain type of Commerce so from their perspective they want the Commerce to be as much as possible they want to give the best Market to their organization members and so if an organization member wants something because it helps them do their business you have a strong incentive of say to say yes and whoever doesn't need that feature they cannot use it they can disable it uh they don't have to use it right so there's no point in saying no to people if your goal is to enable the have the biggest possible Market um but as Technologies we know that well there's some downsides from that right once your language becomes a kitchen syn then it's like it's not good over time so there's huge value in keeping your thing small and consistent and I think that's what you get by choosing 501c3 over 50166 or rather not going down the path of making your organization like a trades Association yeah yeah it's interesting the thought that that one decision how you're structured as a company or as a as a financial organization will influence how you're designed as a language yeah has huge influence um people programmers don't want to think about this stuff they like to think oh I just want to focus on the code uh which is it's a sentiment that I can understand frankly I would like to only focus on the code uh but the hard lesson that I learned is that the to have the best technology you have to get right the business side like the business side comes first every time you make a mistake there the technology will suffer it will in the long run it really matters in the short term it doesn't the long run it has a huge effect yeah yeah that's true okay well I'm very glad we diverted into comp time but to we should probably wrap up and let the listeners go to runtime how's that for a segue so yeah if you um if someone wants to get started with Zig I know you have LSP support you have a vs code plugin you've got all the quality of life things for new beginner but where should they start learning um my recommendation would be go to the official website Zig lang. org and there there's a learn section the learn section has like a guide on how to download Zig install it and it also links you to some learning resources personally among those the two actually the three main ones that I would suggest is as a starting point the language reference uh the documentation that tells you about the language not the S library that one teaches you specifically about like syntax of the language and it's one page it's one long page like it's not an A4 or USL page but it's like just one page is not huge and you don't have to read it all precisely you can scroll through it um but that one gives you Baseline understanding of Zig right uh then from there I would suggest if you don't have like experience with lower level programming and you want like a very smooth learning learning curve uh zigg Lings is the best starting point in my opinion so zigg Lings is like a community project where basically you clone the repo and you get a collection of very tiny programs that don't compile or that don't behave correctly oh okay yeah and the comments tell you how to fix them so you go one by one and you the comment will oh this program is supposed to print h word but it doesn't fix it and that's going to be super simple right you're going to right just fix the the string Leal but then going forward the exercises will become very smoothly but they will will become harder and they will require you to understand more of the syntax you know I I think that's how I learned closure they had a similar thing called I think the closure cones it's like a series of failing Pro small failing programs that you have to fix and you gradually learn the whole language it's a lovely way to learn a new language yeah zigging is very very very popular I would say it's probably the most popular uh piece of educational content in the zig ecosystem and the name zigg Lings is also inspired by rustlings because rust also has it uh okay the same yeah thing and they call it rustling right nice I will link to both of those in the show notes but for now Loris thank you very much for joining us it's a fascinating um a fascinating language with more almost more scope than C which I can't it has pretty much all the scope of C it tries to fix all the things that c for some reason never wanted to fix like think about it why is Zig able to cross compile C and A C compiler is not going to be able to give you that out of the box like we didn't get into this but like you get a z you get a z compiler and you write hello world in C and you can compile it from Linux to Windows try to do the same with clang it's not going to work I'm not even going to try yeah but it's insane uh so yeah the scope is all of C all of the things that c should have done that he didn't do plus a little bit extra nice that's enough to keep us busy for a while yeah Loris thank you very much for joining us thank you thank you Loris since we recorded that conversation I have been playing around with the zigging tutorial he mentioned and yeah I can confirm it's a nice way to learn I'm also planning to find time to pull out my old are doino microcontrollers because I've dabbled with kind of embedded Hardware in the past I've never really been happy writing C I've Loved using rust but it's been a fight to get things to compile onto the embedded Hardware so hopefully Zig is going to finally make me happy when I'm tinkering with soldering irons and wires and LEDs and stuff in the meantime I leave you with links to the everything we've discussed they're all in the show notes there is a wealth of information out there about zig how to learn it what it does extra features we didn't get chance to cover and I'll leave you with a fun Easter egg if you install Zig and type Zig Zen it will tell you why it exists I'll let you go and discover that before you go please do take the time to give us a like or a share or a rate or a review it is the easiest way to let us know which topics you find most interesting so we can do more episodes on those kinds of topics and if you haven't already click subscribe or follow catch future episodes and until the next episode I've been your host Chris Jenkins this has been developer voices with Loris Crow thanks for [Music] listening