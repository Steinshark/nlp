rust is not a good c replacement all right Drew why don't you tell us I have a saying that summarizes my opinion of rust compared to go go is the result of C programmers designing a new programming language and rust is the result of C plus programmers designing a new programming language okay I agree with that uh this isn't just a metaphor go was designed by Plan 9 alumni an operating system written in C and the source of inspiration for many goals of features and rust was designed by Folks at Mozilla whose Flagship product is one of the largest C plus code bases in the world okay yeah uh the values of good C plus programmers are are incompatible with the values of good C programmers interesting rust is a a decent C plus plus replacement if you have the same goals as C plus plus but if you don't the design has a very similar drawbacks both rust and C plus are what I like to call kitchen sink programming languages with the obvious implications these languages solve problems by adding more language features a language like C self by writing more C code I really like that take kitchen and sync are both keywords also no but really but real talk this is actually a really interesting take because that's one of I think that's one of goes big reason why people get upset at go is that it doesn't like add more features why not why aren't you doing this why haven't you added this why haven't you done this why haven't you done this but instead they do very little and in some sense it keeps the language very simple and so to solve a problem you just write more go is that bad I don't know I don't know if that's bad or good I can't because I you know the hard part about if anyone who's ever been in a part of like a really large really complex C plus code base knows for a fact that language features don't make it easier they don't make things great it's it can be excessively difficult reasoning through these things right and but that's really hard for you to understand right it could be really hard if you've never been in that world go a simple yet performing yeah uh curious just a cure it's just a curious take that I think I can agree with I think I did some uh back of the napkin estimates at the rate in which these languages become more complex based on the rate uh at which they add features per year my Approach wasn't very scientific but I'm sure the point comes across C .73 new features per year measured by the number of bullet points in the C plus a C11 article on Wikipedia which summarizes the change from c99 adjusted to account for the fact that c18 introduces no new features is it I mean C11 pretty much just gave the new threads right it dropped P threads for some new naming conventions am I right for that and some like basic new ways to kind of do things go two new features per year measured by the number of new features listed in the Wikipedia summary of The Go versions okay C plus plus 11.3 new features per year measured by the number of bullet points in the C plus plus 17 article which summarizes the changes from C plus plus 14 which will be implemented in in 2032. uh rust 15 or rust 15 new features per year measured by the number of headers in the release notes of the major rust version over the past year minus things like linters interesting about a language that does not change drastically but there is also something very nice about getting features that make your life easier so I'm not sure if like I don't know if these are good or bad measurements it's really hard to kind of I mean I guess the real measurement you're looking for is how many changes make material impact to how you write code I think that would be a better measurement assembly zero new features um I don't know just something you know think about this this speaks volumes to this ability the stability of these languages but more importantly it speaks to their complexity over time it rapidly becomes difficult for one to keep an up-to-date mental map of rust and how to solve problems idiomatically this is true I would agree with this as more and more features are added it does become more difficult you do have to continuously be pursuing and pushing in to become good at rust I agree with that a rust program written last year already looks outdated whereas a c program written 10 years ago also has pretty good odds of being just fine system programmers don't want shiny things we just want things that work that really cool feature other Pro other language has not interested it'll be more trouble than it's worth okay I mean I think that's a good point I think that's a good argument for why for why like you know languages with large change aren't as great like the same thing with JavaScript like JavaScript in the last few years it is very like it is it is disgusting looking at JavaScript that's 10 years old like it's gross it's insane you know what I mean like you look at it you're like what the hell's happening in here it's crazy and then you look at JavaScript even just a few years ago and it looks like wow they should have used this or they should have used that and it's because there's just so much change so quick also just looking at JavaScript can also be kind of gross too all right anyways with uh the philosophy wish wash uh out of the way in a tone set let me go over some more specific problems when considering rust as a c replacement C is the most portable programming language rust actually has a pretty admirable selection of supported targets for a new language thanks mostly to llvm but it pales in comparison to C which runs almost everything a new CPU architecture and operating system can barely be considered to exist until it has a c compiler and once it does it unlocks access to a vast repository of software written in C many other programming languages such as Ruby and python are implemented in C and you get those for free too see as a spec no spec means uh means there's nothing keeping Rusty honest any Behavior it exhibits could change tomorrow some weird thing it does could be a feature or a bug there's no way to know until your code breaks that can't slow down to pin let's see they can't slow down to pin down exactly what defines Russ is also indicative of an immature language I mean I could I mean see see feels complete maybe that's why there's a spec I mean uh rust is still in the process I mean they don't even have like impul everywhere you know what I mean uh yeah by the way this article has no affiliation with the rust Foundation C has many implementations she has many competing compilers they all work together stressing out the spec uh finishing or fishing out the Loosely defined corners and pinning down exactly what C is code that compiles in one and not another is indicative of a bug in one of them true statement a statement in which you cannot argue which gives a nice extra layer of testing to each by having many implementations we foresee to be well defined and this is good for the language and it's long-term stability rust C could stand to have some competition as well maybe it would get faster ah maybe see as consistent and stable ABI the system V the system of V ABI is supported on a wide variety of systems that have been mostly agreed upon by now rust on the other hand has no stable internal ABI you have to compile and Link everything all in one go on the same version of rust compiler they're the only code which can interact with the rest of the ecosystem is UN idiomatic rust written at some kind of checkpoint between rust and the outside world the outside world exists it speaks system five or system V what is it do you say system V or system five and uh us a systems programmers spend a lot of time talking to it system five okay I actually think a v we got a v in there as well I actually I I agree I agree with this point I think this is a good point especially about this part because I know that is a bane of a lot of people in writing rust is trying to um is the interaction points with the outside world oh system U I like that uh cargo is mandatory on a similar line of thought rust compiler flags are not stable attempts to integrate it with other build systems have been met with hostility from the rust and cargo teams the outside world exists and US system programmers spend a lot of our time integrating things rust refuses to play along okay maybe a little salt there uh concur uh concurrency is generally a Bad Thing serial programmers have X problems and parallel programmers have x to the Y problems where Y is the amount of parallelism you introduced introduced parallelism and C is a pain in the ass for sure and this is one reason I find go much more suitable to those cases however nearly all programs needn't needn't needn't uh be parallel strange contraction a program which uses pull effectively is going to be simpler reasonably performant and have orders of magnitude fewer bugs Fearless concurrency allows you to fearlessly employ bad software design nine times out of ten it's pretty good I do agree with this uh with this whole Fearless concurrency thing I've written some pretty poor performing code that I just could write faster and rust all right and go granted skill issue there granted that's a skill issue but nonetheless it's just easier to write it faster because you just don't have to think as hard right you're just like and go oh that's fast first try cool dog uh but I do agree that when rust when you write it in Rust I feel like I have more confidence in it but it takes a bit of time you know what I mean it takes a bit of time safety yes rust is more safe I don't really care okay I care about that one in light of all those problems I'll take my seg faults and buffer overflows I especially refuse to rewrite it in Rust because no matter what rewriting an entire program from scratch is always going to introduce more bugs than maintaining the C program ever would I don't care about what language you rewrite it in okay so this is an interesting this this one is kind of interesting uh I think I disagree at this point I do think that when safety is a concern using a language which has enforced safety uh like built-in language features I think is a better choice can we agree to that base memory safety uh disregarder yeah I think that this makes more sense right this makes more sense than that in that world and safety safety is just easier to get right in in Rust just hands down so if safety is a requirement I think it makes more sense that's why I'm not necessarily opposed to Russ being in more of the operating system level because it's just going to be less likely to introduce dumb bugs there'll still be bugs right can you code CPP safe sort of I mean there's always uh there's always what's it called um there's always like unique pointers and shared pointers right safety is always requirement yeah maybe why do you often highlight from the first I don't know I like going like this it just feels good did you see the F-35 pilot needing to eject because the computer issues like a wooden uh maybe it would happen to rust I can't say it would or would not happen in Rust that's the hard part about this mix nuts which is you can't say it would or would not happen in Rust because rust enforces things and it actually enforces less things like uh integer are rolling over right classic one it will hard error in debug mode and not hard error in release mode so that's like a real thing right that's like a real thing that can cause a whole set of issues in which you know what do you do that Greg hates rust be back later work yeah you know I'm not saying it's it's perfect I'm just saying it's it's just different the language does not matter the developer does no that's not true either that's not true languages have various levels of of safety built into them right that's because if the language doesn't matter let's all just use C your answer would be like well actually yeah actually is correct well actually it is actually the correct answer to that all right anyways C is far from a perfect language it has many flaws however its replacement will be simpler not more complex consider go which has a lot a lot of success in supplanting C for many problems it does this by specializing on certain classes of programs and addressing them with the simplest solution possible it hasn't completely replaced C but it it has made a substantial dent in the problem space more than I can really say for rust which made similar strides for C plus but definitely not C I think Zig is pretty interesting in this case I think Zig has a lot a long way to go on tooling and I think once Zig has really good tools I think Zig will become a great Contender until then I think Zig is really hard to get behind just because you know the LSP is just not great right and I know there's a lot of difficulties with it but it really is important to have good Tools in this day and age because people just you know it's just like memorizing phone numbers at one point I was super good at memorizing phone numbers and then the cell phone came around and now I don't have to memorize cell phone numbers and now I'm really bad at memorizing cell phone numbers and I don't really want to go back to the time where I memorize cell phone numbers LSPs are kind of similar to that like I could totally program without an LSP but I would rather program with one hands down every single day of the way a week right the kitchen sink approach doesn't work Russ will eventually uh fail to the Jack of all trades master of none problem that c plus has why is language designer start small and stay small why system programmers extend the philosophy to design designing entire systems and rust is probably not going to be invited dang little does he little little does the future know on this one Russ doesn't get it does get a bit more invited uh later on doesn't know in lightest article um let's see I understand that many people particularly those uh already enamored with Russ won't agree with much of this article but now you know why we are still writing C and hopefully you'll stop bloody bothering us about it status update I guess Ro I guess uh rustic is okay it is it I mean it's a good article in the sense that it shows you how different people think right who is bothering that man rust people uh by 2019 it was pretty obvious that it was adopted by the industry definitely not definitely most certainly not it was not obvious even now it's not fully obvious what is going to be the outcome of rust I do not know I don't know what is the outcome of rust I think it has a great potential I think there's some big hurdles that has to come over uh and some of those hurdles are definitely the foundation itself the people in leadership uh I would love to see different engineers in place I sounds like they're really great Engineers that are just terrible at people problems that's what it seems like to me um I'm curious if rust is fully sustainable always like could you could you do that I don't know I think so I think you could but I'm curious what larger projects look like right what do larger fast changing projects look like is that the right commitment maybe maybe not uh yeah Amazon Amazon and Microsoft most certainly are committed to uh are committed to Russ but that doesn't mean it's widely accepted right industry accepted means that you have Industries using it right just I mean just because somebody uses something like Objective C had an entire ecosystem in which everybody had to write in at some point to make like iOS stuff that's an industry standard now was it a good one no it was shitty but nonetheless it still was one and so that's kind of what you have to kind of think about just because there is Niche projects whether or not they're large it's still a niche project it's still just Amazon doing just Amazon things right it is it is I've written that Microsoft is committed to safety of rust not rust itself yes this is also true Objective C was kind of cool it was also kind of horrible Mojo is real uh I actually like Objective C what large go projects are hell yeah I'd like to see this because I know a lot of people that say large we I mean I'm working in a large go project and Netflix and people it seems pretty I mean it seems pretty easy seems pretty straightforward right uh I'm interested in carbon carbon's interesting objective CDs nuts damn Netflix by the way all right hey the name is the not the sea agent