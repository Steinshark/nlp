uh our talk is going to be on uh move semantics uh stood move and when should you move and when you should not so uh this talk is aimed mainly for beginners um but yet I do find that many people struggle with move semantics so even though it started many years ago I mean in C plus plus 11 that we some call Modern C plus plus it is with us for more than a decade and and I think that this is a good time to make sure that we get all the details so it is going to be a very interactive session uh I would like to get your answers on some of the questions and I will take questions during the Talk itself so feel free to put questions in the chat or in the Q a but mainly to answer our questions when they come on move semantics of course so let's present myself shortly I'm a lecturer at the academic College of Tel Aviv University a member of the Israeli ISO C plus plus National body Co organizer of the core CPP uh conference and Meetup group and develop developer Advocate at incredibuild two slides on incredibuild we do build acceleration so if you are suffering from slow CI pipeline especially in C plus plus but also in your testing or other parts of your CI then talk with me um my email appears at the last slide so if you want to get the email you would have to stay with me till the end um incredible a very good product for being more efficient in your CI pipeline uh in the past year or so we invest much in automotive uh tools in the environment for automotive so um accelerating the build pipeline for um all developers work in automotive environment which is embedded Linux distributions for embedded uh so again if you are there please feel free to speak with me the motivation so the motivation is to have more efficient code and I guess that we all know but if not this is the slide to start with that in some cases in C plus before we had move semantics we paid for redundant copies so suppose that we have some kind of a factory that can return good dealers and support that let's suppose that uh we have a function called create frightening Godzilla and this function can create uh of course Godzillas but it creates it locally so there is a Godzilla created on the stack and the function returns it now when the function returns to Godzilla we actually get a copy of the Godzilla uh from the function and then we copy it into G1 and you can see that there are some redundant copies here so some of the copies would be alighted will be waived by the compiler but it might be still that we may get a copy by creating G1 from a temporary that was returned from the function and we may used the return value and like still its assets or maybe a better word or a nicer would move its assets so instead of taking the object that the function returns and copying maybe we can do something a bit more efficient we have the same issue on the third line uh when we call assignment and we get back a local a local variable that was returned from the function then we call the assignment which actually in in many cases do deep copy so allocate resources copy the resources from the right side but the right side is an object that is going to die and instead of taking uh copying its assets maybe we can just take them like move them so this is the uh motivation for move semantics the third option the third um example here is calling pushback so uh when you use standard Library containers you send something to The Container anything that you send is going to be copied so this is how pushback works this is how insert works this is how the standard Library containers work so when we send the Godzilla here even though it is a temporary we may have a copy created on uh the call to pushback and again we want to avoid this copy so even if there is a need to create another object on the other side instead of copying the content of this sweetie we may be able just to take its values its content and avoid the deletion of this temporary so this is the idea behind move um and then after we Implement move we want to to ask did we actually call the move functions so we would not hear uh today implement the move Constructor and the move assignment I assume that you saw it somewhere if not you should um take it after the after this session but let's take an example suppose that I have a Constructor for class A and the Constructor is taking a string in this example by value and then I do take this thing that you got and copy it into a data member or another example I have a b class and in B is Constructor I'm getting an R value of a string and then again I'm taking this string that we got as an argument and passing it to the data member name and the question to you here and again this is an interactive session so now it is your time is what would be called I mean a b what they call the copy Constructor of string the move Constructor of string um is it the same case in both what is your answer you can post your answer in the chat okay maybe one more maybe someone doesn't think that it is C well we got all answers to see and and this is indeed the answer and the the reason is is that once you have a name and the name is not just because this is the name but uh the variable is identified by a name then it is considered to be an L value even if you got it as an R value or even if it is a local argument so even though we may move from it because we are the last that are going to use this variable okay uh we still we still copy in both cases so since we do copy in both cases um it is not the best way to do so what we want to do is to use stood move in order to cast it to our value so we actually say Okay um compiler you just treat it as an L value because it has a name but I actually want to use it as an R value in order to move so let's call stood move and this is the use case for stood move this is the classical use case I mean I know that I can move but compiler you think otherwise because you see that I have a name and it might be that I would use it later on so I can tell the compiler that okay I want to treat this enough it as an R value which then would call the move Constructor of string uh what is being called in the next one so I have a Constructor for a I'm getting a constraint by ref then I do stood move which I should not I mean don't move it I mean the the user just sent you something that he may use later on on the caller side but you we we still did move which is not a good thing to do here but then the question is what would happen maybe you would move or maybe you would copy or the code will not compile or maybe it is compiler dependent what do you say please cast your answer please cast your votes on the chat a few more votes please if you're not sure take a guess okay thank you for the answers and the answer is copy and the reason that we would have copy here which is like a pure lack in a way it's not a pure luck these are the rules but I mean you did something wrong if you would move here if you would call the move constructive then you are in a travel and the reason that you would not call them call the move Constructor is because name was const we got name as a const so we actually cast to our value but move preserves CV const volatile so it preserves the constness of the variable so we actually get there is a const r value and since we have a const our value cornstar value cannot be moved because in order to move you need to take the assets and put null PTR in pointers like make sure that the other one would not delete your assets after you took them so if you just want to remember the rules uh there is a very nice table that I took from stack overflow that shows who can go where so in our case in the previous slide we have a constant value because the casting to our value with STD move preserves Consciousness so we could have been in the fourth row which is a constant value case but usually this is not implemented I mean you couldn't actually move from a const so there isn't any real reason to implement the fourth and indeed string did not Implement any Constructor that gets something like that the move Constructor signature resembles row number three so once you have a constal value for some reason then it is a fallback you you fall back to the copy Constructor so this was the case there it doesn't mean that it is okay to move something that you are going to use in a moment or the user is going to use don't do that in some cases it may fail okay um so um you may want to make sure that if you move it is not only resource that might still be used later on so this is not a good thing but in some way if you say oh but I I saw that it works correctly I mean it didn't call move okay there is a reason because it was const okay so we got that um is it valid to stood move an L value reference what do you say can we move L value reference and the answer are answers are it will not compile or maybe it compiles with the warning or maybe it will compile but it's undefined Behavior or yes it can be legit in some cases what do you say again please cast your votes I see a lot of B's and C's a lot of B's and C's and a few D's so let's go for the answer and the answer is d yeah you can move from L value reference and in some cases you do like for example swap if you want to swap to variables you get them as L values and you steal from them you move from them y because once you know that lhv would not use its value I'm going to override its value so if you are going to override its value anyhow then you know I I can move from it because you would not use your value I'm going to override you I'm using you but I'm using you in order to override the old value so it is perfectly okay to move from an L value reference and the compiler is fine with that it is just a casting to our value the compiler says if you want it to be our value that's fine and then you actually move so this is equal to the move Constructor and this is a call to the move assignment and we do that when we actually call swap by the way when you just move to C plus plus 11 from C plus plus O3 for example you instantly gain performance just but by this move because if you call swap so yours call to swap Remains the Same call to swap but you then call to the C plus plus 11 version of swap that does this magic of using move and if inside you just swapped two vectors then instead of swapping vectors by copying them you swap the vectors by moving them which is much more efficient and you get that by just you know moving from O3 to C plus 11 or later without changing anything in your code just by using stood Swap and stood Vector in their C plus plus 11 version Let's uh have um another one be cautious with passing by value so there is some recommendation saying that since C plus plus 11 it is okay to pass by value because you can then take what you passed and move it now in some cases it is okay but in most cases you can do it a bit more efficiently so um the Alternatives would be either to implement two functions one for the L value case and the other for the out value case or to have one using folding reference and in fact our didn't talk about that that the link to the talk is in the previous slide showing or discussing the um advantages of having two functions or a single function with a folding reference using stood forward and studentfold would say okay if the folding reference here is an actual r value then pass it with stood move then do move this 240 is a conditional move but if I actually got here an L value because this double ref here is not an R value it's a folding reference it might be an L value it might be an R value so it serves both in a way and stood forward is a conditional move it would move if I actually was an R value so these two would behave a bit better um and and this is what would happen if I only get it by value if you send idle value you pay for the copy because I insert okay you you maybe needed a copy uh but suppose that uh the item exists in the in the set oh if the item existed in the set I I do not need to copy because you know I just see that the key exists so I can just you know avoid the copy so the L value that gets in and the key exists in the set I can just avoid the copy if I get it as an L value and not by value so by value do the copy anyhow and in all other cases I uh just avoid that but if I get a const reference and you actually send an R value then I pay for the copy of the R value because the function cannot take the R value as an L value so you actually pay for a copy when you pass it on when you pass it on to uh the in call to insert okay when you call insert here so yeah I got the value but then I have to copy it inside So eventually if I just want to move the R value and to not do anything here both options would be the best you can see it in the code here um what's wrong with this one we are going to the next example I have a plus operator and my plus operator uh gets two use links and I want to concatenate them so let's assume that they have some kind of continuation code here and at the end I just move back the local variable that I created and the question is what is wrong with this one and the answers are nothing the code is fine or you are returning a dangling reference or maybe there is a performance issue or the code doesn't compile so what do you say about this function again assume that there is some kind of a concatenation logic there and what would happen there is it okay or maybe something is not so good I will give you a few more seconds I know it is fast you have to think fast here so in three two one I will reveal my answer and the answer is that you have a dangling reference and the reason for the dangling reference is because you are returning a reference this is a returning a reference for something that is local I mean I do not copy I do not move I just say let's return the reference uh it's um it's you know a local reference so I your tent is an R value but you cannot return a reference to a local so if you try to do things here a bit more efficient you are not doing that anyone wants to see the actual dangling reference we have a link to the code here so do you want to see the dangling reference happening or um you okay let's let's take a look at the at the dangling reference I see the answers of the yes which are on the previous question of whether do you you see me let's take a look at the dangling reference so um this is the example okay you see it here thank you for the reactions um you should see my compiler Explorer I guess let me see if this is the case um maybe for that I have to stop here the presentation okay yeah you see the compiler Explorer now and I have here uh string that I just created in order to create the plus operator okay so um in order not to have to implement the entire logic of Sling I just inherit from stute string and inside I implement the plus by calling the plus of my parent okay so I'm calling the plus of my parent here you can see that line 16 the plus operator and at line 17 the call to my parent and when I stood through and returned by our value actually the program crashes the program crashes I get the warning here in GCC that I'm trying to return a local variable as a reference but I do crash by the way you may crash or you may not crashing is not something that is uh guaranteed but you are doing something wrong it is undefined Behavior to return a local by reference so this is the crashing example don't do that you would crash getting back to the slides so um what's wrong here we try to amend the previous example we try to have it as okay uh so let's return by value I mean I understand I cannot return a reference to a local variable even not an R value reference to a local variable you should not do that by the way in the previous slide you should not do that and there is a link to stock overflow asking is there any case where you would return a link uh sorry uh uh r value reference and somebody there is answering the question in stock overflow most great answers for our value and move semantics questions in stack overflow are answered by domain itself our enant so if you go there there is an answer by iodine and The Man Behind the great idea of our value in roof semantics which is great even if you grow now and ask you questions about that and it is new it is not to duplicate you would get an answer most probably for from our dinant on the subject so you can later on browse this link I would of course put the slides in the proper link so again we amended the example and now we return by value what is wrong here and the answers are nothing the code is fine or we still return a dangling reference or there is a performance issues old code doesn't compile what do you say so the answer is a performance issue and their performance issue is a customization that avoids rvo or in our case nrvo return value optimization or named return value optimization the compiler in many cases is able to see that we return a local variable and do this is a rule of implicit move on um so again let me separate it into two even if we do not do stood move there is an implicit move on a return of a local by value so the stood move is redundant even without that you are moving no need for stood move on a local variable that is returned by value it would happen anyhow but there might have been something which is even even better the compiler is able in some cases to see that you return a local variable that is not being used anymore and to say you know what I would create the local variable exactly where the return value should be created on the stack or exactly where somebody is taking it even better in in which case it would create the variable on the place where it is going to be used in such a way that it does not have to be moved so we actually um have a better performance by even not moving just by it is called the return value optimization or named return value optimization if the variable has a name so alveo or nrvo are better let's take a look at the code so a very similar example to the one that we saw before but here I have uh by value we can type and I do stood move inside and I see that I I'm calling the move Constructor on the return I'm calling the move Constructor I'm calling the move Constructor yeah because it's a move but if I would remove the move okay bear with me for a moment I'm removing the move okay there is no Constructor I mean I mean you just got a low volt back without constructing uh I mean there isn't a call to the empty construct sorry to the Constructor that creates the sling but um then there isn't any Constructor on the way out okay so you can see that once I remove the call to stood move on the local variable that is being returned by value I'm becoming a bit more efficient I mean move is quite cheap but there is something cheaper than cheap which is if you pay nothing nothing is usually better than just cheap so um we would prefer having this over calling to the move so uh the answer is yeah there is a performance issue uh the proper way is not to move and to return by value so the reason implicit movement return of a local variable by value it should say here if it is returned by value uh and this would happen here unless the compilers say you know what I even not need any move I can just do rvo or nrvo uh let's take the next one what is wrong here I have a stack in the push function I get a t and I forward forward T inside the vector so the stack is implemented using a vector and since I use uh the vector I see a question there on the previous slide I would take it in the at the end maybe if we would have time uh the stack holds a vector and I push back uh the Ford of T because it seems maybe I got it as a folding reference and the answers are um the t w ref input is not a following reference thus it will be a compilation error or maybe twf is not affording reference thus we support only push of R values or push may add to the vector of a dangling reference maybe or D push May inefficiently copy when it can move an item into the vector what is the actual problem that we have in this code in the meantime I can answer Stefan's question on the previous case if you do a stood move on a local variable returned by value then the compiler might maybe think oh there is a better way to do that but then it falls into the rules of uh I think the compiler is not allowed to avoid the um casting or the call to the Constructor so the rules of when the compiler is allowed to do rvo or nrvo may not allow the rvo or nrdo in the case that you called stood move because it's not the same type that you are returning so there is a need like to go to the Constructor in order to construct to create the return value and then you go to the move Constructor so it's it's not optimization I guess but more of that oblying obeying to the rules of of the standard so let's go back to this example um and I see that uh some are amending their answers you can still do that that's fine and the actual answer is B uh the Double ref ear is not folding reference even though it looks like that because it's a template but I already know T when I call Push I mean t is not the direct template parameter of me is a template parameter of the stack so uh once T is already known then okay it's like oh it's int or it's a string I know what T is and then this is our value and if this is our value it means that we actually do not allow calling push with L value because L value cannot go into a function that expects an R value it is afraid of being you know moved from he yelled some rumor that if he goes there somebody can steal him so um our value would get in but L values would not so the proper way is to just have them both or or if you do not want to have them both you can Implement one with a real folding reference saying okay I'm a template function expecting some you and now this is a folding reference I may have some requirement on the you that it would be convertible to T otherwise I may get compilation or inside maybe I prefer it to be checked outside um there would not be any other match so if this fails um I would just not have any other Pro possible function but still I may want to write that and then this pushback can use fold this is the second option of achieving the same let's go to the next one what is wrong here I have a stuck the same stack with a vector same thing now I mean the pop function and in the pop function I want to pop something and then again it get it back to the user and I get it back from the back function now with the back function just Returns the value it doesn't um erase it from the vector so I call back then I call Pop back in order to erase it from the vector and then I return e and don't answer oh the stood move here is redundant and is pessimizing because um you would not be able to do rvo no I'm not returning a local variable that is written by value this is a reference so if I would just return it as e there isn't any implicit move on a return of a local reference it's a reference so if you do want to move here in this example you should call move but still there is an issue and the answers are populated reference oh Pop moves from a dangling reference code would be okay without the call to stood move or Pope is an undefined Behavior moving out from a vector is impossible oh the reference e is being invalidated once we call Pop back now the differences are quite subtle I mean all answers almost say the same thing but it is not exactly the same thing there is a problem here what is the exact problem is the problem with uh the return value of Pope or maybe B is a better answer try to pick the best answer I see there are a lot of these okay so the answer is indeed D and the the reason for D is when we call Pop back the element that we got by reference is invalidated by now because uh pop back called it's distract or the destructor was called here then you cannot return it not with move and neither without move you just cannot return es is because e here even if you try to copy from it yeah which one I would return a copy or a move uh but a copy a move of of something that was invalidated in the previous statement is not something good don't do that so no no it's not the way to go now comes the question can we move back a value from a popped value from a vector what do you say can we do that is it possible to I mean we can copy out of the vector if I would just uh use instead of the reference here instead of the reference maybe it would be better but then if I remove the reference here then immediately here I'm copying like this call to back copies into e then maybe I move out but maybe is there a better way I can remove the ref ear but then still I'm copying I'm copying on the first line back without the ref would copy into e is there a better way yeah I see a proposal by Kira thank you I would do that so we could say let's take the back and move it into e okay now I use move then pop back you can distract it and then when you return e here don't do stood move here comes again the rule saying do not call stood move on a local variable returned by value because it would be pessimization I mean it has implicit move anyhow but you still want the compiler to consider an rvo return value optimization or named return value optimization a side note implementing move for getting no except if you do Implement your own move don't forget the no accept keyword on the Move Constructor um there was a question is vac back already in our value so when we call back back do we get here and our value and the answer is no we get back um an L value because the value is still alive in in it is more efficient today to take it as an L value this is how it is implemented uh by Vector because Vector can return it as an L value because back is not popped back I mean back is can I get the last one which is still in the vector yeah you can get it I will give you the back as an L value you can even change it and then you change the value inside the vector so it's it's um in a way yeah it's like uh dereferencing the uh last one the I'll begin thank you Kia again uh so let's go to the side note the side note said implementing move for getting for uh no accept is costly so uh if I have a move contractor and I forget to do the no except then if my object is sitting in a vector and the vector is being resized um I need more capacity I I need a bigger size and the bigger size requires more capacity because they don't have enough capacity then I need to reallocate and then when you reallocate I mean the vector reallocates for you then if the elements are trivially copy Bill if they are truly copyable then they're just copied with mem cpy mem copy but if they are not really copyable then there would be a loop and the loop would either move them or copy them but the move the the loop cannot move them if the move Constructor is not saying that it will not throw an exception because the the vector is a bit frayed if I would move elements to the new allocation and one of the elements would throw an exception during this move then I'm with part of the elements in the new allocation and part of the elements still in the order location now I can propagate the exception to the user but the user would lose is all the location is old Vector you would say okay no I never mind I would not push back I would not increase and then I say no no it's a bigger problem I just ruined your vector and then the user would be upset so instead of moving because I cannot move back I mean then an exception can be thrown again instead of moving I would copy this would this is what Vector would do because when you copy an exception can be thrown also but then I still have all the old elements in the older location which is good I mean okay you can use it you can throw propagate the exception to the user but he still she still has the original vector so if there isn't any no except the com the vector is obliged it needs to copy if you are not sure you can actually try it try it with no except or without run it you would see uh in a loop uh I mean not in the loop the loop is in the vector you do a vector you create a vector you push back at a certain point the capacity is exhausted and if you would see a lot of calls to the Copic Constructor unless you had no except if you are not sure then there is a link down below here you can go to the link later on and check that that's true it would behave like that so don't forget the no except in case you actually Implement your um move Constructor and this is also a good point to say Implement uh the move Constructor then consider defaulting or implementing the others I mean remember rule of zero or if I'm not in the rule of zero then think about the rule of five last one last one last chance to gain some points if you count your points on the questions uh are you ready what's wrong here there aren't this is an open question it's not a multiple choice there aren't any uh uh answers you have to think you may type in what you think okay uh there is a problem here something is not so good what is the problem so I see there a few answers that say the same thing in some kind of a different language but uh it is it is the same thing you cannot move from a resource twice once it was moved from you cannot move it again so here for some reason we think that calling the less than operator with uh Temporaries might be more efficient I don't know maybe but then if you they call it with a stood move and it actually moves inside for some reason then it invalidates B and A and then when you actually want to return them then they might be invalidated I mean if you think that there is any reason to move to to do the casting to our value then it means that it might be that the other side the the less than operators that you are calling would take advantage of that so moving twice or moving multiple times the same resource is not a good thing I mean you can move and then override the value but you cannot move and then use the variable as is the value the variable is invalidated by now let's take a look let's take a look so in order to show the actual problem I have here the exact same code which says okay this is bad and I want to show you the result here my strength with world my strength with the low and the maximum is you can see it here on the right side an empty string how come the maximum is an empty string who stole my string what is happening here okay let's go up to see what happens in the less than operator I mean you called a less than operator something may happen there so for some reason somebody decided to implement the less than operator taking to our values these are 12 values and and and the implementer decided because it took to our values for some reason I mean it is the implemental choice to move the arguments into some Temporaries and then to do the comparison on the Temporaries nothing is wrong here I mean except for it is not so efficient but you know it's the implementer decision maybe there is some logic in that maybe it needs to do something with the Temporaries Etc so that is something that could have been done once you send me uh enough value yeah it could have been stolen it could have been moved from and and then when you go back A and B by now are moved from which means the the string is empty or it might be that this thing is not valid to to deal with at all I mean something that was moved from it doesn't necessarily mean that you can print it here string allows us to print because it just puts an empty sling into the moved from you shouldn't print it it could have just crash so the better way would be not to do that suppose that instead we do that just check and return so in in this case we copy we copy because we return A or B and here we do not have the implicit move on return because we got it as a reference there is an implicit move also on arguments but if there are arguments that we got by value but here we got something as a reference so since we got it as a reference we actually do want to move it out when we return so a better way might be to do this too forward on the entire expression which means okay do this and then when you return something fold it out which means okay if I got them as actual uh if if the expression here is something that t would accommodate as the T that I got is in our values and take the expression or what I return and do a casting to a value and here we see that we do call move let's go back to the slides um I think that I have till the quarter the 15 minutes so it might be that I would have some time for questions because this was the last one but we have still a summary so to summarize um there was a question in which cases could it be more efficient to compel two forwarded values I guess never I mean I don't see any logic in oh maybe the comparison would like to copy me or no the comparison you would usually take you as a construct so why should I bother falling I mean I would keep the forwarding for the return value in this case let's go to the summary don't stood move anything without thinking don't move local variables or in turn I mean local variables which are not references and you return them by value don't move something that is still in use don't move something twice or multiple times or in a loop on the other hand don't wave should move when needed you should still move any r value that has a name and you know you won't be using it anymore and thus can move from it so if it needs a move do the stood move and you can stood mobile values if the moved value would not be used like the example that we had in swap I mean don't be too shy of moving L values if you see that you are overriding the value oh so I can before overriding the value I need your value I shouldn't copy I can move the value from because I'm not using the value I just override it in a moment or I I know that the the one that sees the variable outside would see the new value that I'm just putting in like in swap and that brings me to the last slide you have my emails down below if you want to contact me on incredibuild build build acceleration you have my incredible email anything else on the presentation or anything you have also my Gmail and I'm open for questions as long as we still have time and you have questions foreign thank you so much for that uh very interesting talk uh I haven't seen any questions in the Q a yet but I will ask one of my own I'm not sure if I I have to go out briefly but what's the difference between stood move and stood forward okay so uh uh I I do see a question in the chat okay I would go to the question there in a moment um the question on stood movement stood forward so um when I get something that might be an L value or might be an R value and I want to move from it only if it was an R value you remember if I do a stood move on an L value it would cast it to another value so you should be very careful if you do not want to move an L value well we saw that in some cases you do want to move an L value then you just call stood move but suppose that I get something that can be an L value or can be an R value the case is template argument so I got a template argument a templated argument uh on a direct template parameter of my function with a double ref which means okay it's a folding reference it's not necessarily in our value and again we didn't discuss how come these folding reference came into the language it is a following reference it means that it may be an L value or an R value by the way it may even be a constable value reference or even a constant value reference so it can be all four in a templated argument t double ref in which case if I want to move only if it is an actual r value then I would use tilt forward that is in fact a conditional move a conditional move that checks is the T that you got is an R value uh in which case uh it was deduced as an R value I mean there is some magic inside the T would just be the type the double riff catches their value okay so I want it to be casted to our value but if I got it as an L value reference then the T would be deduced to the TL value reference and then stood forward would say no no we are not moving it there is no casting to our value you should b l value as we got you so stood forward should be used in templates not regularly and stood move may also be used in templates in case you want to move in any case I mean we had a swap swap use templates but it was a template on L value reference and we knew that we want to move in any case bottom line stood forward conditional move stood move I actually asked to do casting to our value no matter what okay we have we have two other questions in the live chat and I'll ask the first one and maybe decide wait maybe we won't have enough time to do the the second one but we can meet in the lounge afterwards um but the first one was from Stefan Walter and he asks in which cases would be more efficient to compare the forwarded values I guess that's in in your um your comparison uh function that you wrote yeah so I I do see both questions in the chat so for the first question I think that I relate uh I referenced that during the Talk itself so I saw that and I said okay most probably there isn't any uh viable idea for forwarding into the call to the comparison so it was just you know a toy example you would not do that it was for saying don't do that and I don't see any reason most probably comparison is a non-modifying function it would just get you as a contrast so I would say just pass it as is and the other side would most probably get three test scores as for the other question regarding what is your take on passing stood function is arguments value contract or R value ref so um I would take a step back and say okay maybe the signature of a function that expects a stood function should better be templated taking the function as a template argument in which case if I actually send a 0.02 function or a Lambda or a function object it would not need to convert itself into a stood function it can just be passed as is and this is more efficient than creating the stood function now then if I need to forward the callable that I got I mean I got this function as a t double ref as a folding reference to the function which might be a Lambda might be a pointer to a function Etc if I just use it I will just use it but if I need to fold it I would use to forward in order to forward it the same way that I got it so getting a function usually I would like to get it as a folding reference by the way it is better than getting it as a const l value reference because if I get it as a constable value reference it might be that the function tries to modify its state and then I do not allow that and if I get it as a now value I actually allow all possible functions a const function and unconscious function Etc we can play with this question I think if I can share the screen in the lounge I guess I can you can yes we'll do I think we we will call us a day there uh because we've been going for an hour and so let's meet in the track D lounge and thank you very much for your great talk thank you all and we will play in the lounge with the question of how would you pass a collarbel and we will see that passing it as an uh folding reference and folding it is the better choice let's do that there thank you all bye