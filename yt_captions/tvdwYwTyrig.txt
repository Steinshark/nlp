welcome mark thanks andreas and welcome from me too my name is mark motz i work for the cube company and um my talk today is about core routines as an api principle so just um before we start i will use as i announced in the abstract of the talk i will use q types for exposition and explaining things um so before we start i would like to just get a show of hands um via the poll feature here um that you should now see um how many of you have experience with qt so that i don't know um that i know how to um gauge this in and how much of the api to explain okay it's still moving i have no idea when it will finish let's just end it um so about half of you have voted so about the third uh use it every day about half her only superficiously and superficially it should have good that you got that um another 20 have heard of it and uh 2 have never heard of it so ok um show results okay so let's start uh we'll first start with an introduction um why this talk um then we will recap the non-owning interface idiom which i presented four years ago um on meeting c plus 17 and then we'll talk about the non-owning interface idiom version 2 which will use covertines and then later we'll tie it all together and discuss core teams as an api principle so why this talk this talk is not a core routine talk at least not one that tells you how to write covertines i want to tell you why you want to write coroutines instead if you want to know how to write cover routines there is a lot of talks and papers and articles and blogs about this and from personal experience i can recommend goronishanovs nishanovs sorry talks on youtube um where he goes into various details um about coverities he's one of the driving forces behind the standardization of the routine proposals so he's the go-to guy for this so why this talk if not to tell you how to use core jeans um i just deeply dislike owning containers in the api and as someone coming from raw c-plus plus you might think about um yeah why does he say this where do we use owning containers in the stl um answer is we don't but qt does cute api is full of this api that takes and returns only in containers for example there's a control that's called label can show a bit of text on the screen and that has a set text method takes a q string q string is like standard string except it's ugf16 um but it's owning it's an owning container right if you assign something some data to a q string it allocates memory so what if my back end library gives me a standard u16 string it's already utf-16 encoded so i should be able to just pass it in nope i need to call a function so uh what if i'm working for bloomberg and i get a pmr you use 16 string instead yeah there is from standard u16 string but it does not work with custom allocators so i need to use another function from utf-16 and passing the data into size and that's ugly especially because here i'm running into this mismatch between the queued containers which use a signed integer type four sizes and the sdl which is unsigned integer type so there's also something called crew gradient which represents a gradient that you can paint on screen linear radial and so on and of course as a gradient it has stops that define where at which position which color should be reached and as such there is a stops function that just returns your vector of gradient stops and q vector is like standard vector more or less um so also an owning container what if i just need the first two steps there stops i still get all of them then there's q region q region is a is an abstraction of a bit mask a bit more efficient in that it's a collection of rectangles and this is used for example if you expose a window you get paint events that tell you where in the window you're supposed to paint uh update and that is represented by a q region so a common case in q region is that it's just a single rectangle and not an ellipse also which is then built up of hundreds of rectangles so typically when you deal with regions you iterate over the rectangles and then deal with them so there's a q vector of correct function a returning function called rects but what if q region wants to optimize that common case where the region is just a single rectangle and just save the single rectangle so what if curious wants to use small buffer optimization internally and hint it does the answer is it can't really because the interface ties it the implementation to vector right so this is cute and you can say okay cute 90s design why what why do i care but we also find the same pattern in the standard library and one thing that i vividly remember from mbo discussions is this um so error category um has a message method uh that gives an int that's the error code and it returns what that error code means right and it's returned in a standard string now error codes are you can think of an alternative mechanism to exceptions so it's it's understandable that people who don't want to use exceptions like embedded folk would like to use error codes instead but they can't use error category because in a freestanding implementation there is no standard string because standard string allocates memory so owning container means this otherwise perfectly okay class could uh not be included in freestanding implementations so how to solve this all so we have seen two problems the first one is that owning qt contain owning containers in apis hinder interoperability if i have my q region rex it returns a q vector if then i have some function which takes a standard vector instead i can't call one without with the other because two vector does not implicitly convert to standard vector and even if it did it would need to make a deep copy of the data so two libraries that should interpret interoperate can't because they don't agree on the vocabulary types in this case what the vector is or supposed to be solution use views for function arguments like in line 7 here we changed from using a standard vector to a standard span and then i can call that function with anything that standard span can represent including a q vector line 10 there does not exactly work like that because the committee broke standard span if you pass it an r value um it will refuse to be implicitly converted you first need to store the r value container in an in a temporary in a variable to make it an l value and then you can pass it i will i will have something to say about that pattern in a second but this works otherwise so the second problem is that owning containers and apis restrict the implementation we have said that qregion wants to use a small buffer optimization where it just stores the single rectangle internally instead of having a vector of any kind of rectangles which is an additional external state it wants to avoid so if i now just pass rex the result of rect to my function fill rect that works but internally qregion needs to jump through quite some hoops to turn the one rectangle into a vector of rectangle so it needs to allocate memory just to satisfy that api constraint or that api contract so because back in the 90s and auth when people cared about cycles and memory allocations that came to light people wrote this code in line 10 to 15 instead so they found out that if you if direct if the region contains just a single rectangle that rectangle is of course the same as the bounding rectangle of the whole region so they check does the region contain only one rectangle if so get me the bounding rectangle construct this band from that one rectangle call fill rex otherwise it's okay to call rects because that will not allocate memory because it's not already in a vector so this api is not easy to use and it's easy to abuse at least if you take efficiency into account and people actually need to work around this and they need to know what the implementation actually does because maybe small buffer optimization would extend to two rectangles then this code would need to be changed and uh would not have the ability to use that bounding record trick so non-owning interface idiom also solves this problem if you use it if you use a view for return for returning function from a function and the span does not care whether it's constructed over a single rectangle or over a q vector or standard vector or c array so in any case i can return a span representing either the single rectangle or the vector of rectangles from the same function and i can do so in a no except fashion because i know that whatever i do i don't need to allocate memory and now the simple api in line 8 works and is most efficient and this is what i want to achieve in apis that the easy case is also the most efficient case so of course non-owning interface idiom has some limitations it introduces lifetime issues if you look at line 10 i get q region from a function so i have a temporary region and i call rects on it and i immediately feed the result into fill rects and that's okay everything is okay the temporary is kept alive until the end of the full expression which in this case involves the full call of to fill racks but if i split the line into two and store the rectangles first into a local variable then by the time i have done so the temporary object that is returned from the retracts function has been deleted by the compiler and rex the span references deleted data some people think like authors of standard span that you should just delete our value overload but this restricts users and the simple case in 11 in line 11 which was okay before and still is okay it just fails to compile and you force users to first store the q region into a local variable and then call rects instead of the more comfortable way in 11 and 9 11. a line 12 is an error and it should be so that's okay but we have done too much we have restricted perfectly okay code and it's not like this is a completely new issue if you call a function that returns you a standard string and you call data on that standard string you have exactly the same issue you have get a car start pointer to the to the memory allocated by the start start string and if the temporary is uh still around and you access it everything is okay but if the temporary has been deleted you're referencing deleted memory so nothing new so next try how to fix the lifetime issue well write a checker it's not as simple as copying the declaration and deleting the r-value overload but it more closely matches what the api should allow and what it should not allow so forget about having to do everything in the api realize that there are these days tools clang or in the the acute case uh specialization of it clasie which are uh there to um encode these domain specific uh patterns or anti-patterns warn about empty patterns and a very general way to do this is herb sutter's w lifetime work which has been implemented i believe in clang and in visual studio i believe not in gcc yet which tracks lifetime of reference data and so on and should be able to to catch all these kinds of errors so um the second issue is that views of course only work on over contiguous containers so here i picked an abstract item model it's an interface that you can implement to show your data in tree views and uh and table views like excel like things in qt and one of the virtual methods that you can overload is a mapping between item roles that tells the which type of item you want for a given cell and role names those are important in scripting languages in qml and returns it as an owning container in this case it has an unordered map q hash but that's non-contiguous so i can't just replace with a view views also only work if there's actual backing storage to return a view over so if i take your string split which takes a string view and chops up the string into into parts along separators and returns me a vector of of those parts the vector of parts is contiguous but it's calculated result so there's no backing storage to that i could return a view over so the solution to both of these will be to use core routines so this finishes the first part of the talk if there are any questions so far please i see so is acute or qt marketing says qt and developers say cute okay i won't wait for others just um we'll take the rest of the questions at the end and just post them there in the q a tab so um how do you use how how should we use co-routines for this owning interface idiom version 2. so another problem first problem three if you use owning containers in apis that means that you do any calculations eagerly if i split the string i want to split string and i call q string split that will split the whole string and only after the whole split string is split i can get access to the first five parts or so that i want so if i have a loop over string split and i use parts use parts use parts until i find some token that signals that i've now done i will have split the whole in this case for example 100 megabyte file um even if the token appears on the third line that's kind of wasteful so um here too coroutines can help if i replace the return value of the split function with standard generator which is something like for gold people a channel that um becomes a lazy sequence so as i iterate over the generator um so you can observe that the code has not changed between the upper and the lower part um only the return value has changed but because it's a standard generator i'm have a lazy sequence and um i'm backed by a coroutine and therefore as i iterate over the split result i'm producing i'm finding new parts now i'm not iterating over the whole container the whole string producing parts and storing them away in an owning container i returned them i yield them out of the core routine one by one and therefore if i um if i prematurely terminate that loop i will not have produced more than i actually needed and consumed and the nice thing is that adjusting the implementation from an owning container to a co-routine is absolutely trivial so here's the implementation don't get bogged down in the details just pick out lines six and nine where we push back to into the result some parts that we have found yeah and now happen look what happens if i turn it into co routine it actually gets simpler because i don't need to deal with the result container manually i just co-yield whenever i find something um you can implement this without core routines i tried i did and i succeeded it's 450 lines of code for that function and the heart of that is is this again do not get bogged down in the details just look at line three nine and fourteen this chops up the function into three parts and it's three states basically this is a state machine that implements um the tokenization and it's exactly what the compiler does for you if you do use core routines so but here i need to do it manually that's 11 code and it's not fun to write of course this uh g string tokenizer does a bit more than the co-routine string split that we have seen so far um it for example has no allocations at all whereas the core routine will allocate the the frame the coordinate frame on the on the heap and it also implements r value pen pinging pinning that means there are no dangling references because when i have been given an r value q string for example or standard string i move that into my tokenizer into my promise into my return type and thereby keep it alive for the duration of the loop um so if you can't use coroutines yet no problem just write 500 lines of code or implement it for each x so coroutines um a yielding coroutine is basically calling a callback it's a bit more complicated than that quarantines are more flexible but you can emulate the behavior for generators at least so we can implement the whole thing with callbacks so we give it a callback on line three start function and then instead of co-yielding in line seven and line ten i just call the callback with my string view and i can use it as in line 15. um does this throw yes because of standard function do we know how to make it not throw yes of course but it will look a bit more complicated but this is a fallback solution i would not recommend this for anything except for really high performance critical code and then of course not with standard function but this is basically what every scl algorithm does yeah not with a standard function but with a template argument but that's how to customize a scl algorithm so back to the limitations of coroutines um they have their own set of dangling pointer problems um for example consider a split function coroutine that is now working on standard string instead of q string so i get external string in a character separator just to keep it simple and return a generator of string views and now i have in line 11 that simple code where i pass a string literal and i of course i expect that i use first the hello and then the world um but that's not so because um since the split function takes a standard string the hello world string literal is first converted into a temporary style string that is being passed to the coroutine and the core routine immediately suspends because it's a generator it immediately suspends before it does any work and because it's a reference parameter the reference is copied but not the data so by the time we go out of the split function and enter the loop that temporary will be destroyed and we will be looping over deleted data of course we all wish that range-based for loops were defined like this instead of the way they are defined maybe we will get there at some point but um until then that's what we have to live for and range based for loop is just one problem we have we can trivially rewrite the code in line 11 to 13 here and we have the same problem even if the for loop was wrapped in a lambda to extend the lifetime of its uh of the right hand side argument so this really is something that screams for solution in c plus itself and not at the api level so something like w lifetime or whatever else is brewing in the standardization committee at the moment so my recommendation would be to ignore the issue until we know how to solve it in a general case and not try to delete our value overloads and stuff like that um in every api that we write and of course don't forget uh start this yeah if i have a function that returns a string and i call split on the return value of the function i have exactly the same problem just under this pointer so why is this the case why do we have this problem the problem is that generators spend always on initial suspend because they don't want to find the first token until they are asked to by a call to begin on the generator so because they initially suspend that means i cannot write no code in the function body that is executed before the initial suspension and that means i cannot write any code in the function body to start store away the function arguments make copies of them or something like that so the recommendation usually is to pass by value because then the arguments live on the frame of the coroutine and it's all automatic but we wanted to avoid having owning containers in the api and here i'm presenting it as a solution so that's not going to fly so one way to solve the issue is to pass the arguments by value and then get the automatic lifetime extension if that is not possible for example for star this prior to c plus plus 23 we need a custom promise type and that custom promise type needs to have a constructor that matches the function's argument list and if there if the compiler finds such a constructor in the promise type it will invoke it with the function arguments so there we have a point where we can grab control over the function arguments and store them away but this of course ties the promise type to a specific co-routine because every core routine will have different requirements and this proliferation of promise types means that there is more work and implementing implementing them in documenting them and for the user and learning them even though of course they all share the same a interface they're just arranged the gold standard so far that i have found for me is to wrap the co routine which acts only on views in ordinary function in an ordinary function overload set which does all the conversion so if it's getting an r value owner it will store that into the return value or into the generator or into the promise type and thereby pin it uh pin its lifetime to the lifetime of the generator if you want to know how to do this manually you can look at the implementation of the string tokenizer there's also this block article on the website of my former employer where i explain a bit how to do this but not in detail and of course doing so implies that different functions from this overload set which appear or are designed to appear to the user as a single function have different return values and therefore callers of the function must receive the return value in an auto variable or at least if it's all the same template uh with a simpler plus 17 class template argument deduction so leaving out the template arguments next issue is that of re-entrance if i have a normal function that just puts stuff into a vector returns the vector that function cannot be recursed into at least not from the same thread multi-threading is a cool different beast and we're not talking about that here so when the core routine is suspended however other code is running that's the whole point we put the core routine to the side so that we can run other code in the meantime and that code could potentially call into the suspended core routine that's not a problem as such because every core team invocation gets their own frame so at least uh different coroutine invocations don't clobber each other's frame state local variables but you do however call an unbounded set of code while your core routine is suspended but again this is nothing new it's just like invoking callbacks if you invoke a callback you also must assume that the called code recurses into your or re-enter re-enters your function and you need to put recursion guards and whatever you know um how to deal with this issue they are in in order to avoid reentrancy problems it's also to a lesser extent the same as calling a virtual function because you do not control the re-implementation of virtual functions so they too can recurse into the interior function and the same is true for single slot connections which is just a fancy way of callbacks fusing callbacks so treat suspension points as you would in vocations of callbacks or virtual functions and you should be on the safe side don't forget however about the initial suspend which is hidden in the code so there's no no co yield no code wait for this it's just as you enter the function it's immediately suspended if you're using a generator uh important also to keep resources in right objects across suspension points because if your if your core team handle is destroyed because for example we stopped tokenizing because we found what we need and we just exit the for loop then the coroutine is being destroyed and as the coating is being destroyed the stack frame is unwound as if by the thought of an exception except that i can't catch the exception and if you have newed something and then suspend and then later assign it to some owner then you have leaked memory so next issue is coroutine frame allocation i said that the compiler will allocate the coroutine frame on the heap that frame is used for function arguments the promise object local variables and selected temporaries that are held alive across suspension points and compilers are sometimes able to elight the memory allocation at least clang is for example see nicholas talk from cyprus con 2016 where he has his magic disappearing coroutines but that likely requires all the code in between the creation and the destruction of the coroutine handle to be visible to the compiler that means no atomics because compilers forget all they know about memory when they encounter an atomic operation no out-of-line function calls um and so on that's very hard to do especially qt where most of the stuff uh multiples and an api boundary so the coroutine frame allocation can of course in c plus plus we can get control of everything can be overwritten by a custom allocation function just like any other function uh class um i need to do this on the promise object for the compiler to find it and then i can for example use a pool allocator to at least reduce the overhead of of the of the frame allocation careful here the coroutines can be resumed and destroyed on a different threat than they were created that's not likely for generators though bottom line coroutines can't really be no except because they always have some allocation inside one thing that i did not look at so it's untested but that's worth a try is whether caller supplied storage can help here you probably don't know css because i invented it not too long ago it works by providing a default argument at the end of the function um that supplies some storage could be a standard vector could be a q string in this case it's just a flat array of car of course 42 characters and um we intend to place the frame into the storage we cannot allocate on the stack or as an automatic variable storage inside the function but we can force by doing it this way we can force the caller of the function to allocate memory in its stack frame and storage such allocated will at least survive until the end of the full expression which may be enough and if it's not enough i need to pass something manually that i that i created manually on the stack this is incredibly powerful um and we are using it in cute already on q any string view um to store some some stuff that we could not otherwise store where we just don't have any storage and um i also intend to use this for for number formatting and stuff like that it's just a very powerful idiom the problem here is that i have not yet found out for myself whether this actually works um i can use that storage which comes in as a function argument to to place the promise and with it the whole frame in it independent of that of course i need to know how much storage i need to supply that's another issue but this is worth something looking into so finally core routines do not provide random access they can't go back only forward so generator types are input iterators or input ranges um but what if you need more what if you need random or bi-directional access or well with what whether what if you need better than linear complexity provide an additional api just not having a better than linear lookup if your underlying data is is able to provide this just means that in elements of programming stephanos book speak you do not have you have a base of operations but it's not an efficient base of operation and you should have an efficient base of operations so that you can do all the things that you want to do with your class in the most efficient way possible so coming back to this example from the abstract item model that interface that i can implement to plug my data into into two views and so on um i can return from role names i can return a lazy sequence that works regardless of how the data is actually stored even if it's generated on the fly that works and for the cases where i have an item role that's just an enum and i won't look to look up the role name for that i just provide an extra function and that extra function is constant complexity whereas of course iterating over the role names would be linear complexity so summary core routines as an api principle what have we learned core teams can help avoiding to use owning containers in api that's where i started and since core teams are ordinary functions they can be virtual functions and they can be dll exported in other words they are usable in apis because they are normal functions the magic is in the return type these return type of course need to be exposed in the api and that's where the problem comes we have conflicting requirements here on the one hand we want as few promised types and therefore return types from core routines as possible because that makes it easier to learn to implement and to document like we have standard future let's all use only standard future uh no and but that requires type erasure and type erasure means memory allocation i think i will look at klaus uh talk um in meeting c plus plus here to see whether he has any better ideas that of type erasure that don't require memory allocation we'll see on the other hand fine tuning behavior like the allocation the argument pinning and so they that requires protein promise types and that means having different return values return types and of course inline functions which is also something that you should be very careful about if you are working in something like ute which has strong binary compatibility requirements inline functions are sometimes necessary to get the performance because the abstractions are so trivial that you cannot afford going behind an api boundary with them but it must be a conscious decision to do so to inline that stuff what else have we learned proteins can help with implementing lazy sequences of course that is one of the result that for for coordinates in the first place generator pattern and that of course leads to less work wasted when i only need a subset of the results it's very easy to implement compared to traditional techniques that require state machines like your string tokenizer and once you start looking laser sequences are everywhere like written literally everywhere what else have we learned coral genes of course come with their own set of issues this is c plus plus and um there is golden apple um there's always some dark hole where uh where an insect is coming out so we have seen issues one and four that was lifetime dangling references nothing new again just different disguise of the same underlying problem lifetime issues dangling references issues threes two and seven were dealing with the fact that either your data is stored and contiguously so then you return a view and have random access or not then you use a co-routine but however you only have an input range then no longer random access we have seen the issue of reentrancy of frame allocation and with that i thank you and i'm open for question please visit our booth on the show yeah thank you mark for the excellent talk i learned a lot and we have two questions [Music] kind of simple questions the one was that that was uploaded is on slide 13 and 14. if you want to go back what happens if you're split to your split if somebody captures the result into the lambda it uses lambda as a slot chances lead to memory corruption and will the compiler find this or will just work so lambda capture is nothing different from just storing it into some variable and we have seen um somewhere here how this can go wrong right and i've also talked about what are things to do to avoid this meaning if you get an r value you need to store it internally the problem with slots is in general is that you need to be careful um what you store in there especially by reference if you store something in the lumber everything is okay by value but if you take references you need to make sure that they are kept alive for the duration of the connection the cute connection um so for those who don't know qt so well um this is a question about signal slot connections in qt where signals are basically a notify of an observer pattern and slot is um the observer that can be connected to the signal and receives the data and since q5 you can connect lambdas s slots you don't need functions anymore you can connect a lambda and those lambdas of course can have state and that state can be by reference or captured by reference or by value by value everything is okay by reference you need to make sure that what you refer to in the lambda lives at least as long as the connection and those things are completely orthogonal to each other so you just need to follow both rules both sets of rules okay thank you um the question is what do you think about a function signature uh fill reacts with auto input range rectangles i guess it's uh that that works of course if you can make it a template um that works um the idea here is to go behind an ap ip api boundary so to have something that's dll exported out of line and if you do if you do that with templates um you can only do this for a certain number of instantiations that you know ahead of time and then you instantiate them in the cpp file in the library and all other instantiations will not find the definition um so this is a closed set of options that you have there even though it's a template as long as you want to keep the implementation behind the api api boundary and my concern here is not so much about inline code like stl algorithms or arranged range algorithms in c plus 20 because the compiler can see everything what's important for qt and for other such libraries which are traditionally shipped with most of the code out of line is that you can efficiently cross the api boundary or the api boundary so yeah that is of course simple just plug in an input range plug it into a for loop and do whatever you want but it's a template so it gets instantiated for every new range that you passed okay thank you then the next question uh by peter isn't the generator easily done even in 98 using iterator with virtual next method doing all the work yeah it's basically that function that i showed you from q string tokenizer it's the next function what makes this more complicated is that it's actually doing the pinning of r value references and so on and this cannot be done in c plus plus 98 because a function um in q that's called q tokenize or member function tokenize returns different return types depending on what you return what you give as arguments so if you give it a standard string l value it will not store the standard string because it's an l value so it assumes that it will stay around for as long as the stroke string tokenizer stays around if you give it a start string r value it will store it internally and that makes the q string tokenizer that is being returned from the tokenized method a different thing it now has a standard string member into which the um into which the argument has been moved and the same is true for q string if you get an r value it's being moved in and if you get an l value you just stored a store to view um over the data and then do the same thing not only for the haystack but also for the needle and you can maybe grasp where all the complexity comes from okay then there's a question from jens relayed by dennis asking if your caller site storage optimization isn't just a manual in rvo so return time no optimization and rvo is just so it's named return value optimization that is if i create a temporary insight to fun local variable inside my function and the compiler can prove that this object is the one that's being returned from all return statements then instead of copy constructing that local into the return value of the function it will construct the temporary into the place of the return value in the first place thereby saving the copy construction or move construction css instead is concerned about obtaining storage from the caller you can of course always put that storage into the return value and thereby get the same effect if an rvo kicks in but css works also if the return value you cannot change the return value for example if you want to format a number an integer number you know how many digits it maximally can have so you can allocate storage for that and then you can allocate that storage either in the return value um and you have something like a queue formatted number which internally contains as many characters as unnecessary to format any integer number and that implicitly for example converts to true string queue string view and so on but that is not a q string view it's something that implicitly converts to it if you want to have a function that actually returns a q string view then that does not work because the q string view is a type that you do not control and you cannot just add storage took your string view to to enable your use case so in this case you can pass a stood array of car16t and sufficient size like i did let me get back to slide there there we go yep um you allocate um you take this extra argument and you just store the result in the storage and then you return a view over that storage that's the trick with uh caller supplied storage and um the the idea here is that you can use css even if you can't use the return value for example in a constructor a constructor does not have a return value so you cannot just put something else into it but with this additional argument you can supply um storage for um for example converting whatever a car 32 t into a pair of car 16 then a q string view can store um that is highly dangerous i know i know i know but i use it in qt only on cue any string view which is designed as a pure interface type it's only designed to be a type 4 function argument and in that case it's safe because i can pass car 32 ts to a function that takes a q any string view that internally decomposes the thing into two car 16 t's and stores pointer to those variables and those two variables they come from caller supplied storage well that's a good question i really had to argue in my head to find out why css is not just innova okay thanks again mark for the excellent talk on answering all the questions and it was mentioned that the qt company has a booth so join this under this room and then there's also extended q a if you have any more questions you want to discuss in more details then join the lounge the chair group for track a and i hope to see you over there and we can discuss the uh css and we are all in more detail if you want so thanks again mark and see you you're welcome just skipping through the chat