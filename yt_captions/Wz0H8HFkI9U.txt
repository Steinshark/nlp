why I think C++ is still a desirable coding platform compared to rust okay okay I mean this is a bold take because I mean you don't even get a build tool with C++ just so you know not communist for starters don't you're trying to bait me again we're not getting baited not getting baited when a question is made comparing compiled languages like C++ and rust the typical generic answer comes both are compiled languages with no/ runtime that allows that lets you write whatever the machine can do so performance will depend on your writing and not your CH uh chosen language interesting okay I think I see where this take is going I think I see where this take is going this very interesting while this is largely true there is lots of important details uh left that are important to be highlighted not without controversy of course here I will try to dive into some of those insights okay so this actually seems like it's going to be a really good article cuz I've been wanting to see someone voice a good defense of Y C++ still good my general take is that it's very easy to still do well I mean easy is definitely a skill issue when I when I say this it's still very easy to do shared mutable memory in C++ comparatively fair fair take I think okay I think but you also get uh I'm just going to continue reading but you also get the with with with C++ if you choose to use unique pointers or shared pointers you you have a run time slowdown that effectively rust solves at compile time it's just easier to work with right it's just much much easier to work with so that's kind of like in my head how I kind of think about the C++ versus uh unique pointers are free man are they free are they fully free shared pointers are not free right they have an atomic uh counter in them correct I didn't think okay we're going to conflicting answers I I didn't think unique pointers are free I know shared pointers definitely cost something shared okay okay people are generally saying I mean I could see why unique pointers should be free because ultimately at the end of the day long as you are semantically correcting compile you should be able to just get rid of the unique pointer I mean I think that's pretty fair so hopefully uh unique is just a Destructor thing and is deleted a move copy Constructors okay so it's still non it's still something just not as much it's it's low low overhead all right uh P you know it's cheaper than non move copy Constructors and all that no none none's always more free than something even if the overhead is super small it's still cheaper than nothing okay uh it sounds like we're getting kind of I I would have to look it up I don't know the exact outcome of a unique pointer so I just know they exist they're great they make life really really easy they give you a lot of those safety features that you've always wanted they're fairly easy to use and bada bing bada boom your codes significantly safer in C++ and more managed and easier to work with a team with unique pointers shared pointers also are pretty neat but I know that they come at a cost that's like that's my working mental model I don't know exactly what a unique pointer does in comparison to a shared pointer other than that shared pointer has the atomic counter and unique pointer doesn't have it but what does it do and how does it me does it manage it does the compiler completely just take out all all constructs of a unique pointer and just turns it into the thing just hides it completely I have no idea below I took a picture from an article on Research gate about sorry in principle both rust and C++ are compiled languages that use 95% of the llvm compiler infrastructure rust and C++ are translated into IR intermediate representation where most arguably all optimizations are made uh below I took a picture from an article on Research gate about Loop optimizations notice that in the first clang box no optimization is being done only pre-processing macros Etc and uh desugaring uh EG lambdas all optimizations are done in the second box where no where C++ no longer exists as a language all right there's all this good stuff here's all the Canon canonicalization passes Loop optimizations passes poly Loop Vector vectorized late mid-end passes classic late mid-end passes you know what I mean classic it's the classic late mid end it's beautiful it's a beautiful thing okay uh the translation layer exists between I actually have no idea what llvm actually does so this all just sounds magical I've never really studied into optimizations I know they're quite magical they're quite fantastic and it's one of the few times in life where uh computational Theory and the real world meet and you actually can do some pretty cool stuff I've always wanted it's one of those like I've always wanted to learn X for me that was in that realm right it's always in the always wanted to learn the this translation layer exists between C++ and its respective as abstract syntax Tre as long as as a logic container are not conducive to feed optimization algorithms most optimization logic needs to be portable information rich and quasi assembly representation where all the side effects are resolved that is why C++ and all other languages get converted to IR intermediate representation before optimizations are performed okay perfect the same logic applies to languages like Julia Scala and rust rust adds three extra IR layers h l t hir and M oo the trilogy uh most trilogies suck in successive lowering steps still these extra layers are related to type checking and safety mechanisms EG the well-known rust borrow Checker okay cool cool uh the parenthesis here uh Russ claims that there are Russ specific optimizations done at the Mir level that will in the future impact performance significantly I have found a list of such Transformations but I could not assess nor prove that the performance impact is real or just rhetorical my post on Reddit asking for comments on the subject has also not produced any conclusive proof either way so even the experts on uh are on the fence on this one I feel it was more wishful thinking on the part of the documentation writer at the time very interesting one thing that I will say that I really do like about rust and what it can do is you do these iterators are zero cost abstractions when you look at like the compil stuff when it comes to an iterator it's pretty neat to be able to see that your filter map whatever can all just just run in line like to me that is a really nice experience in my book uh I I I really enjoy that because you typically like if you're from a JavaScript language you forget that the closures created the functions created a new array is created whereas you just get less stuff created and at zero cost for those type of things which I think is super cool iterations are a huge rust W exactly I really do love that about rust and I feel that that is like a super under championed feature of why rust is really cool and it's easyish to write well performing code but this is where the similarities end I need to recall that this publication is about low latency trading a and as our tradeoffs when deciding if something is worth it will always lean towards the item that leads to Performance increase es okay so this is super cool low latency trading uh requires you to be making decisions as soon as possible so nanc matter here uh which I think is pretty exciting I love this idea uh if we were a company that produces web servers or web browsers then the conclusions below would probably be different uh be a different nature okay very exciting performance is not only instruction by instruction execution timestamping before one gets uh to the actual instructions an entire pipeline of human and machine interactions come into play some of these factors will be discussed below beginning with the safety toll assuming for a second that both C++ and rust are compiled within the llvm framework is any of the two language languages able to produce IR that leads to faster execution in all situations okay good question here I like I like where this is going I actually really enjoy like this this line of article um Russ tends to be more strict than C++ it's it's ra uh and that means more real- time checks although integer underflows and overflows are only checked in debug mode memory accesses in arrays are uh constantly checked for bounds unless you're in unsafe mode oh I did not know that no that makes perfect sense that makes perfect sense of course it has to right is that true during production too okay okay okay okay which defeats the purpose those checks alone take significant toll they slow down the process compared to uh the retrospective naturally unchecked C++ code yeah but you can get unsafe okay so so the argument is that yes if you if you want speed to that level where including the bounce check on an array is a significant toll right significant toll therefore unsafe would be the the answer to this question okay but is that an Apples to Apples comparison well yes if you're going to list the safety of Russ compared to C++ as a pro then it's just as fair to list the performance hit of such safety in regards to execution speed agreed great great take right there you can't list it as a positive on one side without listing the negative on the other side I think that that's a great that's a fair a fair ass take you can't talk about safety safety safety oh you can't say that that's unfair because that's not apples apples I could use I could use I pick you just made my brain WTF with that ass take okay I said fair fair ass okay fair Dash ass the ass was not dashed on the take okay okay buddy get me all right undefined Behavior C++ relies extensively on undefined Behavior I mean the statement isn't the greatest to say out loud in your head or to write down on paper okay I don't think that that's like a great thing you want to really do as an optimization enabler oh really uh UB can make a a brutal difference in many cases really okay okay I got to hear this rust on the other hand does not and cannot leave knots untied because it focuses on security okay how show me uh for for example this simple C++ snippet shows how c++'s UB can make a huge difference in the routine knop which uh uh we return the results of the division of a number multiplied by two by two it seems obvious that this should result in the original number and the assembly code just moving the input argument in the EDI register uh into the output register eax uh Co cooperates that okay so it's able to optimize look at that Beauty look at that nice Beauty right there it optimized it okay cool when was this article written that's a great question because yeah uh It Was Written uh yesterday yesterday all right all right I want to see this however when you consider the edge cases things are not so clear what happens if you multiply two uh up by 30 by two and then divide by two uh what do you get uh point zero uh oh Nega yeah oh yeah that's right 31 you get the whole negative thing these are signant oh yeah they're signant divide by two it is uh this big old negative then that that's a big difference yes it is a big difference so why C++ ignored that possible Edge case because signed overflow in C++ is undefined behavior and as far as the compiler concerned ered it will never happen oh I think I see I think I I I think I totally understand what's going on here what is the what that okay so this is actually a super interesting case right here with the edge case reasoned Away by the language the compiler is free to implement that optimization if you compile a similar function in Rust you'll see that rust will be unable to optimize that expression away because both signed and unsigned overflows in Rust are well defined in the language as tw's compliment this result in assembly below where the first line Le uh the result of the multiplication by two is computed uh in fact it computes the Value Plus value instead of uh value times two smart okay at least it's I mean that's smart right there that's a smart one right there and then the result is H let's see haved by shifting right SAR okay okay we can see what happened happens here it moves this into edx uh Eda eax okay and this one does a few operations here a little Le a little sorl and then a little r q okay okay again pundits will state that you could have called one of the arithmetic wrapping functions which forc the compiler to do this optimization well you can do many things but but here we are measuring the effect of the compiler over two similar code blocks okay fair I think the statement and what he's saying I I think to resay what he's trying to say is that you have to do more things to get the same outcome in Rust is that a fair statement all right cash locality just write better code I mean you have to do a whole extra thing to make sure that these optimizations are happening but do you really need to take optimizations before measuring so the reason why these things happen is again he's saying exactly why he's doing this which is realtime trading uh where like if you're trying to do Forex Arbitrage you got to be able to respond within like you know 500 NCS might means you don't get the Arbitrage so how fast you need to respond is really really really important so when you have extra instructions it's not good and these people do do fpgas uh This Is How They also lose $400 million in a few minutes right so it's bugs are really expensive in this department we have that whole article 400 and some million dollars lost in like 40 minutes because of a single because of power Peg the greatest named function of all time power Peg gets power pegged it was so beautiful cach locality C++ has full unfettered access to memory by Design C its ancestor uh it's antecessor is that what I don't know this term I don't know what an antecessor is well that's not helpful I'm getting what you calling me boy I'm confused at What's Happening Here did I just get dunked on somehow I don't even know what's going on here what the hell's happening all right it's it seems like ancestor supposed to be the word but we're using some other term here Brazil mentioned did we just get a Brazil can we get a conf confirmation confirmation Brazil mentioned died died by Homo erectus my homo erectus lasted longer than 4 hours I am now dead uh was created with the use case of it being a low-level language just a tad bit above assembly huh what that's this is probably the video that gets me canceled like out of all videos to get cancelled this might be the one okay this might be the one that actually makes it happen uh C++ inherit uh that which makes it arguably the easiest language to code memory intensive algorithms and data structures like hashmaps B trees vors and lists C's pointers have a simple and intuitive meaning this is so good this is like my I've have never copy and pasta copy and paste put it over here everyone's logical jump they have to make oh I put Q's wait what how did I put a q there uh there we go said one guy ever this is that has never been the case I that is probably the one of the most frequent questions I've ever had is how to how do pointers work I know it's simple like once you know how pointers work you're like Ah that's stupid of course that makes perfect sense but until you know them they feel hard almost forgot to reime it up well thank you Ryan Winchester flashbacks to my university is this an onion article this is shockingly not an onion article it's actually a really good this is a well this is a well ass done article for you pick allowing even Junior developers to grasp and even write statements that would be extremely hard to understand in assembly okay that's actually a really fair take that's a great take right there is that it's not it's not that pointers are easy it's that their counterpart in assembly is really hard and so the simple abstraction that c makes on top of assembly makes it really makes it great to work with okay I understand that while rust does not does allow the same it makes it very difficult to get away with it this is true we've read articles we've seen examples uh unsafe rust is hard again this is by Design rust creators do not want you to be bit twiddling but focus on business logic first so they made uh so they made is such that accessing memory directly is painful and timec consuming yes we've seen this unsafe rust not not simple uh this means that good developers who know how to take advantage of cash locality will have a good time implementing such algorithms and data structures with C++ and will likely will very likely struggle with rust for the same task I still am not sure if I can make a doubly linked list in Rust okay I'm just saying I could make a doubly linked list in JavaScript in like a minute and a half C++ C++ probably like 10 minutes just because I have to remember I had to go look up and then in Rust it's like I I don't think I could I don't think I could today it might take a little while for me to do that you know what I mean it it might take a little bit uh you just DQ and the rust list you suck yeah skill issues no it's C I did do that uh it's a skill issue it is totally a skill issue you have to use weak pointers and see uh in C++ still do you yeah thank you for the this one yes I've seen I I've read the book too many damn lists anyways we'll look at that at some point all right rust mandates the use of its own compiler rust see oh hold on okay uh let's see compiler Choice rust is an offspring of the llvm project and so is Julia cotlin and Scala without llvm rust would not have existed rust mandates the use of its own compiler rust C which is a top driver for the of the llvm stack pretty much as clang is for C++ C++ on the other hand has dozens of good quality compilers available in many platforms okay bold bold take Borland anybody can I get a Borland can we get a Borland um I'm not sure like I I guess for me this doesn't make a lot of sense but that's probably due to the environment that I work on so maybe this isn't like a huge W for me but maybe it's like a huge W for something else right there are platforms that I don't work on maybe that is a lot easier right so I I don't want to say hey it's terrible but maybe there's something to that that makes more sense I don't know uh G CC for example is the most ubiquitous C++ compiler today it exists by default think app install build Essentials in every Linux distribution GCC has a much better optimizations in specific cases like function calls we analyzed in this previous article oh super cool on Windows it's hard to beat microsofts tooling and better tooling does influence uh in the way you get performance optimizations done fair fair take not surprising that uh game development is almost exclusively a Windows operation right Fair Fair no one's going to argue that one resource available resources available although the scenario is changing rapidly the pool of Engineers with C++ background is much larger than the pool of rust developers also still fair to say for now uh let's put it this way I think what I think would be better to be said in this state is the pool of expert C++ developers is much larger than the pool of expert rust developers like I would consult I would consider myself an average average rust developer right I can do things I can get things done uh I can do some lifetimes I can work out some decently performan stuff but I wouldn't like I'm a tinker I would put myself in the Tinker the Tinker you know category but as far as like expert goes I would most certainly say I am not even close to that and then you got to consider like the entirety of the game industry right like the entirety of the game industry are pretty damn good at C C++ right they are they they are pretty damn good and so I have never met a game developer that I'm not pretty decently impressed by except for TJ calling himself a game developer while writing a engine in O camel yeah right not not real you know what I mean not real yeah right uh anyways so if I want to bet uh safe in the development of a new system I have to go with C++ I think I think one thing that you're one thing that this article is super discounting is what I call the hype factor and if I were to post a job today saying C++ position available at some prestigious company the response would be pretty good I'd probably get a lot of I'd probably get a decent amount of applications but if I flip that and said the same thing except rust I bet you my application rate would double if not quadruple so I do think that there is an eagerness for people to use rust that is not present in the C++ world right why leave your current job likely doing some C++ or whatever to go do C++ elsewhere whereas most people aren't working in Rust again proven by the fact that there's only 20 professionals currently working in Rust and they are totally willing to jump over to do Rust right they're excited about it they're excited ready they're they're lubed up you know what I mean yeah if you're building Chrome with C++ why why leave exactly you have to have a real reason to leave uh the dubious benefits of safety oo when rust is brought up in a meeting the first pro uh proactor uh is language safety but safety against what in many years of coding C++ very rarely I experiened to stack Overflow or segmentation fault it is literally not an issue in every code basee I have worked with okay we are talking about safety against hackers the large majority of C++ applications are non-public facing so much that the data center machines run with mitigations turned off since there is absolutely no possibility of contact with those machines with Bad actors so hacker safety is not a concern that I in particular would care unless I'm coding a web server okay this is actually I I could say this there's there's definitely some potential um I could understand this argument I think I'm understanding this argument right here right I I still am kind of doubting the whole thing but still anecdotal evidence but you know data is just the plurality of anecdotal right for the most part that is that is a huge portion of data that you read um is this true like I don't know I have no idea but I I I can I can appreciate the perspective sample size one likely not data uh are we T let's see or are we talking about protection against crashes well don't get me started on this one first crashes can happen in any languages with the same frequency I often point to this article about Princeton's unmanned vehicle team competing in 2007 DARPA challenge as an example of how even a heavily protected garbage collected language such as C Can Crash and Burn leaving your process un unusable it's pretty funny it's pretty funny when you're crashing and burn and doing that um I do think that C++ is really hard to I think it's harder to get right so just saying the dubious benefits of safety maybe there is some truth to that in the sense that once you get good enough at C++ the likelihood of you introducing a bug goes down I can buy that but the guarantee that there's no bug is nonpresent right you just have no idea right valren is great Valen gives you gives you a lot of information 70% of all security bugs at Ms are memory safety ones again but this is an operating system in which everyone can access and try to take advantage of that is a much different situation than a server in which is running some process in which no online process is attached to right I get that these are these are different problems trying to solve different things right sanitizers are cool too yeah yeah yes Clos Loop versus open loop systems exactly I do think that there's a whole there's a lot to be said for that what percentage of bugs are security bugs that's another great question 70% of security bugs are due to memory type issues what percent of bugs are due to security right it's too hard I I mean try cating a b tree well first off cating a b Tree in general is a little bit tricky so adding a adding a extra layer of rust is always makes it harder you know what I mean it is in the standard lib you can just do B Tre this is true all right let's see exceptions can throw a Java process back to the main and helpless on how to proceed the process will puke an undecipherable excuse of and bail out uh oh but C++ segmentation fals is much worse say the haters however SE fults can be caught with a wrapped uh signal trap and handled cleanly like any Java C exception okay it still I mean it still leaves the same problem which is that you don't know the state of your program and at the point in which they I mean it's the same reason why I don't like throw right I don't like throw as a construct in general so I think that that's a plus one in Rust always which is that exceptions are not handled by throwing they're handled by returning this is also a go a go thing as well right uh erors as values just typically lead to easier reasoning about your program CU at every step you have to handle what could happen if there was an exception there so your ability to return whatever state you were in to a reasonable state is just it's just simply easier Mak sense yeah yeah seg fults meaning your data is corrupt and the best uh choice is to cancel the process pretty fair I'd say that's fair uh zig Zig again very nice I like that uh conclusion given that the performance benefits are either in uh inconclusive non-existent or more likely negative the safety benefits are not really that pressing for most applications is that really worth moving a uh to a completely new language with its Infamous long and hard learning curve as rust that's good to think about I mean I think that one problem I think we inevitably have is uh per ception issues right we have anchoring bias um which means that you've heard your whole life that C++ sucks and so when you read an article like this it's hard to take in what this person is trying to say because you just you you're trying to fit it into this view that C++ sucks rust is awesome right and so I like rust I would rather use uh I'd rather use rust than C++ hands down all the reasons he said are just not reasons for me and so I wouldn't arve to the same conclusion I'm not concerned over uh whatever this this this case is right here right like I'm not measuring performance on an instruction base so it's not really something for me I like cargo I like the fact that I can stall what I need via cargo I don't like the fact that every single project requires hundreds of little dependencies kind of giving me this node node modules feel right um I can understand this which is there is a there there's several learning curves when it comes to rust but there's also a general learning curve when it comes to C++ right and the curve is not as fast but does it end in the same absolute position I am not sure I don't know like I honestly don't know if it ends in the same the same position uh if I had been writing C++ fulltime for 30 years I'd probably just keep using that yeah that's a very Fair take right this is kind of what you have to do tooling makes a big difference also the community is more welcoming in C++ probably got him yeah for new devs what should you start learning uh probably probably rust is my general take I think C++ will give you a better understanding of memory to begin with and actually gives you a better love for what rust does but then I think it's harder to understand memory and layout and things when starting with rust right you can learn see you can learn see in that you get the same experience it's just something to think about you know I do not know the general answer but for me for now it is not worth it yet I like rust a lot it is much more modern language than C++ no modern C++ is not modern it's just lipsticks on a cute pig that's a very nice compliment to C++ you just gave there and I truly would like to move to it eventually however it did not cross that threshold where I would tell a client to definitely jump on a boat okay I mean I I actually don't disagree with his conclusion I think his conclusion is actually really good like when I take the perspective of what he's attempting to accomplish with the language he is choosing it just seems like a better decision you know what I mean it just seems like a better decision I I I get I get why he's doing what he's doing uh will it forever be like that I don't know I know I like this I like this talk I like this thinking I think this was really really great I I think a lot of people don't think probably as deeply as this this Henrik individual is on this happy about it I mean PhD okay we got a PhD over here I you know I don't got a PhD nuts uh at all so just something to think about just a reminder oh nice let's go Netflix let's go Netflix Oh Netflix no come on let's go come on keep going north keep going north keep going north the name I still prefer rusten I prefer rusten