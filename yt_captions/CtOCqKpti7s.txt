well today is Hardcore coding Theory relatively speaking it's still 64 Shades of Gray for those of you looking for the sequel and remember the sequel is always better than the original thing is this 50 Shades Darker yes it's Shades Darker send pictures back from marinina n a read Muller code was used and Irving Reed is a very famous coding theorist and this worked incredibly well they were ever so pleased about the results they got from this the nice thing about it from the theory point of view is that if you want to go all mathematical and say it's a a multivariable polom blah you know you can do that because it is but I can disguise that for you with readed MÃ¼ller and I can say look everyone trust me it's just an exercise in recursion that we're all familiar with and you've got to be prepared to do concatenation of bits strings which I think in North America and Canada is called bit fiddling but here in the UK we call it bit twiddling but twiddling fiddling we don't mind which recursion and bit twiddling is all we need to understand how those pictures were sent but because it's a recursive procedure it takes us almost on a sort of Magical Mystery Tour of everything we've ever done about codes because as you build up to something usable in terms of lots of era correction you meet lots of other almost familiar friends on the way the nkd notation is what we're going to use this comes from a previous video where we qualitatively took a look at pictures from Mars and how they were sent but of course we're now getting down to hardcore details involving recursion and bit twiddling but just for revision the total number of bits in what you're sending including payload bits message bits and parity check bits that's n within that how many bits are devoted to the messages itself K what's your distance the bigger that number is the more errors you can correct so the correctable errors is your distance here minus one / by two and take the floor of the thing that we are headed for at the end of our recursion is 32 bits total six bits of message 16 is the distance this magic code when we've got there will actually correct up up to seven wrong bits in 32 and I mean some of you say why couldn't you do this earlier and the answer is it's a tradeoff the trade-off is we've only got six payload bits whereas with things like Hamming codes it would have been more like 26 you pay your money you make your choice okay well how do we do this recursion then how does it develop every recursion has to have a sort of bottom point where it finishes you know factorial zero is one that sort of thing well here we're going to develop the known in some textbooks as the H subn codes and the reason for that is that they are actually derived from things called hadamard matrices there's lots of ways of getting at these read Muller codes but the fact that there is a hadamard matrix method of getting at it is good news for us because what it means is you can do it recursively and as computer scientists we're all totally and completely happy with recursion I know we are the zero one of these codes the very simplest is just so simple it's laughable it's just the single bit one but every good recursion has got to have an algorithm from how you get from this one to the previous one to the next one and so on the rule for constructing shall we call it hn at every stage you take 2 to the^ nus one Zer and 2 to the^ n minus one ones so in other words you get a bunch of zeros and a bunch of ones joined together by concatenation Plus at every stage of the recursion you do twofold repetitions of previous pattern from the previous version of the recursion it's one of these things let's actually start doing it and I'll keep cross referring here and you'll get the hang h z is one that's god-given you can't contest that that's the bottom okay then so what about H1 well what this is saying is that for H1 our n value is one so we're going to have to put in a pattern here that is 2 ^ nus one Zer well if n is one that's 2^ 1 - 1 2^ 0 but anything to power zero is one so you start off with one zero and one one okay but the rule says and as well as that your working set this is called your basis set of things you're building up your working set must also include a two-fold repetition of the things you had previously well the only thing I had previously was a one so what's the two-fold repetition of all one one one it's all to do with concatenation when not at the moment doing any arithmetic or exclus or anything we're just joining bit patterns together so here we are then it's one one now rule here which is a quite General thing in developing these codes is you can always introduce a zero Vector as it's called if I keep calling these things vectors don't worry it's a very in phrase you can band it around in the pub but all it really means is bit strings you can always introduce a zero Vector of order n what that means is absolutely for free and from nowhere I can add to this 0 0 okay and if I was working with bit strings as I will eventually that are four bits long I can just bring in four zeros it's bound to be there the zero Vector at whatever length is always part of your set of code words that's fine so you can look at this now and say do you know you've almost got a valid code there you in two bits look you've got 01 one one and you say that absolutely for free I can have Z 0 do you know if you just added one zero in there you'd have a complete set of four bit possibilities wouldn't you yes and here is a lovely way to introduce you to what I blather on about from time to time it's called a linear code it means that if you add these things together with exclusive or they'll deliver something else in the same family well look there's only one thing with missing in this family of four bit possibilities so if I do 01 and I'll indicate my exclusive all binary addition without carry with that plus what happens if you add 0 one to one one well one and zero is one because they differ one and one is zero because they're the same H that has delivered me my final possibility of one Zer so what we're saying is at every level of this recursion you take what's called your basis vectors that come from this recursive algorithm lots of zeros lots of ones uh plus double UPS of what you had last time you do all of those but then you add together what you've got in all possible combinations and you know that they form a closed family you'll get to a stage where they won't deliver anything different they just rattle around within themselves now look at this fabulous code Sean it's so familiar to us isn't it but it's not very exciting because in N KD terms what are we saying that this is it's got a two bit code but the payload is two bits long there is no space for any error correction and if there's no space for any error correction whatsoever then there must be distance one apart they all differ by one bit as you go from zero through to four I have to confess to being completely lost at this moment I understood what you said but I don't see how it has a bearing on where we're it will in next time around believe me this will have such a bearing as you can't imagine what I'm saying is in the trivial case this doesn't give us an error correcting code at all so it's useless but we recur one more time I might need your help here H2 oh crumbs you need 2 to the N minus one zeros and 2 to the N minus 1es that's always the new thing introduced every time yeah is two to^ one which is two so you need two zeros and two ones Plus two-fold repetitions now uh I did derive that but that wasn't part of the basis there two-fold repetitions of what you had last time 0 0 one 01 and one one one one don't worry about the zeros you can always add those in at this stage if we want to add in a four zeros zero Vector we can do so at whatever stage we want is that so that's just like a you can have the code of nothing yes yes it's a like you know when when you're doing arithmetic systems you find zeros very useful but it really is like saying 5 plus 0 is five right but of course with exclusive or it's handy to have it because if you accidentally exclusive or something with itself because they're identical it'll yield a bunch of zeros for you so it's handy to have that there in as a kind of check that it didn't just arise from out of space it could have Arisen from adding two things together that are absolutely identical these are what's called BAS vectors for the vector space and they're four bits long but from these you can generate all of the forbit possibilities you're after by simply adding either taking them as they come or adding them together with exclusive all and I'll show this now on this Sho which I'll carefully introduce over here I've introduced a 4bit zero Vector which sometimes is called bold zero that is the zero Vector of whatever length you need remember the X1 we got two not and two ones fine X2 Note One Note One X3 one one one one those are the three we started with now add them together in all possible combinations until you don't get anything new and I mean exclusive or of course X1 + X2 0 1 1 0 X1 + X3 1 1 0 0 how about X2 + X3 one Z One Z and finally the final possible combination there all three of them and of course you know it doesn't matter what order you do these exclusive ORS in X1 plus X2 plus X3 is the same as X3 plus X1 plus X2 you do all that one you get, one now when you look here look 1 2 3 4 5 6 7 8 you've generated eight possibilities out of all the 16 possibilities in four bits what I'm saying to you is you take any two of those now and add them together again you won't get anything new if I take 1 0 1 0 1 1 0 0 do an exclusive r on those I will get 0 1 1 0 there it is look just above try it with any of those and you won't get anything new the other thing I'd point out to you here is what is the minimum distance of this code well look the not one1 how distant is that from four zeros two two yeah the only exception is if you take the zero Vector with the vector that's all ones you will get a much bigger distance you get four but you're not worried about the maximum one you're worried about the minimum one so this thing then is not exactly awardwinning but it's a step on the way we've now got something let me use my crib sheet and write down for you H2 is a 432 code and you look at that and you say well that's a bit better than last time where we wasn't any error correction but we all know from previous videos If things only got a distance of two you can't correct an eror you can only detect it and when you look back at these set of possible code words you say ah we've seen that it's actually carrying a three bit payload with one parity check bit at the end of it and overall it's always even par yeah but we're on our way we can now fast forward and say what about H3 what we're going to develop from here is basically a set of 16 8bit possibilities and if you sort of say well this is H3 what is its nkd rating it's an 844 code we're coming on we're getting a b ver correction at last now in this recursive Builder partway four minus one Sean three 3 over three one don't need to round down it can correct one error it's getting up to Hamming code standards this this is we're up to 844 at this H3 code but probably the most equivalent Hamming code I could pluck out for you is 743 perfect illustration of tradeoff look that will only correct one error but it's got a payload of four bits that's got a payload of four bits and this is pretty comperable how far do you have to go with this before you get up well we've done H3 you have to get to H5 and we will draw a veil over H4 completely I will leave you to read the handout and work out the basis vectors do it all for yourself or if you can't be bothered to you can use my or program which has got an option in to generate them let me just say H4 has a nkd rating of 1658 and that's very nice look at that 8 - 1 7 72 3 and A2 round it down it could correct three is in a 16 bit payload this is looking good but those clever engineers at JPL and elsewhere said oh if we went one stage further we could do even better H5 this is our Target 32 6 16 notice what's happening is that at every stage of these hadamar readal the codes the size the length of them it's exponential it's doubling it's gone 2 4 8 16 32 next one will be 64 so they are expanding at a heck of a rate and as some sardonic person has once said in the comments on this that's true with extending these codes it only gives the cosmic rays more chance to damage them and that's quite true so this is a fabulous compromise as you can see now um I'm I hope you've all by now seen the previous video with the pictures from Mars if not you can always go and consult it but this was just about perfect you get a six bit payload pack inside 32 and with a lot of hard work at the jet propulsion laboratory you can deterministically decode every one of these vectors to get its shade of gray out of it so long as it's not being hit by more than seven errors you might have a big decoding effort to do this quickly enough um because it can very easily Mount up uh but that solved the problem for you mission accomplished really I think there it's uh it solves all our error correcting desires for this particular level of technology that happened in the Mariner 9 it was always counted a great success of course things have moved on from there a lot since that date we've used secure shell to bridge across to something I'm more familiar with open Susie Linux and I think I can't remember in the previous