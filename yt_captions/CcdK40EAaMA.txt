thanks um yeah my name is mark motz i work for the club company now and i want to talk about q string q and string view something that i did for my former employer but it's in cute that's a variant string view and i want to tell you why even if you don't use qt you should care so in this talk i will briefly present some history that's basically when you download the slides afterwards that you have the links to the to the blogs and uh and youtube videos then we'll talk about what's there now and uh what i intend to do in the future so all this started with the introduction of q string view in 2017 and q510 which is basically the q string version of standard string view and there was a series of blogs and talks about that and in meeting c 17 i also did a lightning talk called the most important api design principle question mark that introduced a non-owning interface idiom version one back then and at this meeting c plus i did a talk called coroutines as an api principle and that introduced noi version two and all these feed into the notion that you should not use owning containers in the api you should use views if you can otherwise co-routines are are an option so with that let's see what we have in queued at the moment so q string view and assorted classes in q6 um we have merged q string tokenizer um that's basically a c plus 7 11 implementation of a co-routine to split strings with quite some interesting features q legend one string has magically survived even though it was scheduled to be removed but we still have it because latin one is still um important encoding you can't do everything in hf8 because utf-8 has variable length encoding so you can't get the length of a string um in in characters in uh code points whatever that is um easily and in latin one string has this property and uh us ascii as a subset of that is too important to just let it go we have a utf-8 string view too no and we have q any string view and this is what i want to talk uh to you about so what is q any string view any string view is a variant string view type think start variant of the aforementioned three views q string view queue letter one string view uh it should be called but for legacy reasons it isn't and uh cue utf-8 string view so whatever you pass to it it will figure out automatically what the encoding is that's easy for cons car eight t stars that's utf-8 obviously q letter one string is letter one and cod scar stars for uh for legacy reasons for that's just acute policy that utf-8 is the default encoding so everything that's in car stars byte arrays etc is encoded as utf-8 or interpreted to be in utf-8 and car 16-t cons car star cue car star and so on they are utf-16 unlike your string view you can also construct a q any string view from a single character um that was deemed to magic for by the time that q string view was added because of course as soon as you um pass a cue character to a string view and you just store the string view and don't immediately pass it to a function it becomes invalid because internally of course you take the address of the argument and store it in the string view and that you can only do when you immediately pass it on to a function and not when you store it in a local variable so extending that further any string view can now even take car 32 t and decomposes that into two character sequence for utf-60 because car 32 utf 632 is not supported by qt that is also policies policy decision and you can even construct it for mercury string builder to expression template we have this expression templates that if you concatenate strings and you set the correct command line options compiler flex um then you get an expression template out of that and you only get a final string constructed once you assign it to an actual string um that should work but i just got a buck report this week that it doesn't so i need to look what what's wrong there so here's how to use qrani string view for example in a function called set object name which traditionally has taken a q string by construct like so many things in qt and if you look at the line three four and five in the upper block there the first two are locating and the third one is a statically constructed instance of a q string so it doesn't allocate but it returns from a nested lambda inside that macro q string literal a temporary q string whose destructor are then run and all the funny atomic operations that q string copies perform so if we just change this in the api it took you any string view disregarding how that looks in implementation for the moment we can now pass the same things and what was allocating before no longer allocates because clearly stringer is just a view and it's accepting anything it's accepting utf-8 in the first case letter one in the second and even q strings um that is now a pessimization because you still have the temporary q string if you would just write uh u uh car 30 car 16 t literal um you would not get the temporary q string inserted and less code being executed at call time in the caller so unlike your string view cue any string was not designed to be overloaded with q string it is designed to replace q string and any other overloads for any other string like types um yeah so at the moment you string any string has very little api you basically uh it accepts everything so it's uh it's there for its constructors and then when you want to go in um you need to use visitation like with a standard variant um here's an example of how this looks um and the goal here was to replace all that overload sets that we have enqueued with the q string view cue card q legend one string utf-8 string cons caster and so on and just replace that overload set with the single function that takes qna string view and then only in the implementation farm out into level latin one utf-8 and utf-16 implementations the way this looks here is that basically you get any string view in and then you call visit on it passing a lambda and then you can do the processing in there and this auto name variable will either be a q letter one string or a q string view or a qtfs 16 a q utf-8 string um and then you can just do the thing here we just call tostring which returns a q string from all of these views and since that is so common that's already an api on q any string view so if all we do is building a q string why take a q any string in the first place there are several reasons first we have now one place in the library behind the api boundary where the q string is being constructed as opposed to at the call side with the temporary q string object which liters every call site with a q string construction and a memory allocation which does the same thing as a sequence of executable assembler instructions but of course it it's duplicated for each caller whereas if you take if you do this in the library you only have a single place where this is being done second we have now gained that implementation no longer is forced to store the thing as a q string but it can for example store it in a u16 string style g16 string to get the sso installed small swing optimization or in some small small vector in qt that's called qvar length array so um or maybe you're even preprocessing the string anyway and you would anyway cause a detach from that uh from the q string that you were being passed um like for example in q settings we have this key that you can look up and there's an actual preprocessing step and so we didn't actually lose anything because we anyway create a q string and clean up the key before passing it to the backend so um if all we do yeah or maybe you're just parsing and not storing at all and if cute is so far away from your day work then just look at the basic f fstream seaters constructors lately and you will understand that the standard library has the same problem so that's the present what about the future i will skip that because i'm short in time i just wanted to show this here as the end slide for yentz because we were talking in the in the q a about this this is how to format numbers uh using the new standard two cars um function that we got in c plus plus 17 but with have without having to set up a buffer first manually we're using the css idiom the compiler and the scholar supplied storage idiom um to get a buffer into which we then format the data and then we return it as a letter in one string and uh since we return returned the latin one string with automatically compatible with all the cute infrastructure and with that i thank you okay thank you mark