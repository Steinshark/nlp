today we're talking about how to tell if an optional parameter has been passed in this first case is the lucky case because we don't have to in this case x is either passed in or it gets the value 42 but it's not always possible to put the value of your default argument in the function definition up here for instance in this case the default argument that we want is the length of an array we can't know that length when we define the function so we have to compute it dynamically another reason not to put a default value up here is if the default value is mutable like a dictionary default values are defined at the time that the function is defined not when the function is called so if you had a default mutable argument like a dictionary then that dictionary would be shared amongst all calls to the function doing this is a very common source of bugs so you might be tempted to do the following set the default value to none and then use a boolean expression to tell whether or not none was passed in this isn't always wrong but i do think it's a bad habit what if zero or the empty dictionary were valid parameters this code would throw out those parameters and replace them with the defaults what i recommend doing is the following again keep none as your default argument and then set x to be either itself if it's not none or otherwise compute the default this explicit check to see whether x is none allows us to pass in zero if we need to you can also do it this way explicitly checking if the parameter is none and setting the default if it is i prefer always using this explicit check against none because it's one less thing that i have to think about i don't need to worry about whether 0 or an empty object might be a valid parameter however there is one exceedingly rare case where this still isn't enough what if i actually want to distinguish between the cases when a user passes in none versus when they don't pass in anything if you are writing a function this way i really encourage you to take a look at your function and think about it do you really need to distinguish those cases is there any way you can avoid it most of the time i think you can avoid it but especially for code that writes other code or highly generic code sometimes it just can't be avoided for those cases we'll use something called a sentinel a sentinel is an object whose sole purpose is to check whether or not something is or isn't the sentinel value in many cases it's okay to use the python built-in none as a sentinel value that's what we did in the previous example but if we want to distinguish none then we have to make our own sentinel once again we just set the sentinel to be the default value and then check explicitly using the is operator whether or not the past and argument is the sentinel now we can easily distinguish whether we have the sentinel value or none here we have two example uses of the sentinel pattern in the python standard library on the left we see its use in the data classes library and on the right we see its use in the funk tools library however the sentinel pattern will get you into trouble if you want to type check your code you can see here that mypi is giving me an error correctly telling me that missing isn't the right type the way that the standard library gets around this is by using the overload decorator from the typing library get rid of the type annotations in your actual implementation of the function then just before the implementation of the function you need to write a separate overload for every possible combination of types that could be passed into the function at runtime this implementation is the only one that actually gets called and so it must handle all the possible type combinations that could be passed in the overload decorator's purpose is more to help static type checkers like my pie you can see now that the program passes my pi's type check that's all i have this time thanks for watching don't forget to like comment and subscribe