Today we're going to talk about how we can make a computer CPU run more than one processor time we said look at the other side of this just before Christmas with us how we can have Many CPUs one Rotten program what we want to look at today is how we can have one CPU Appear to run many programs at the same time. We interrupt this program to bring you How do we get our operating systems to allow more than one program Or as the operating system parlance is process run on the CPU at one time now Obviously we can't but we can use a technique called multi programming or as it's commonly referred to in the sort of non computer science world multitasking to simulate that effectively what we're doing is switching between One process and another very very quickly And the reason we can do this is because if we think about how program runs Some other time it is running one instruction than the next and then the next and the next and sequence after each other But a lot of the time the programs often particularly interactive programs ones, we use aren't actually doing anything They're maybe waiting for a network packet They may be waiting for a key to be press or the mouse to click on a button They may have just asked the operating system to load a file from disk They may have just asked your own system to print out hello world and so we can use that file actually These programs are waiting for the operating system to do something and the operating system is actually waiting in many cases for the hardware I mean if we waiting for a network packet We're waiting for the hardware to send it to us or whenever there's another machine to send it to us So actually the CPUs not doing anything useful and what we can do is attempt to say ok This program is not doing anything useful at this point. Let's let something else that can run run at that point So to start a process the operating system needs to load from the sources in the code and the data for the program into the computer's memory Once this is done. We can start the process and the operating system Does that effectively by just setting a few bits of stay within the operate system to the right values and then we can just jump? To that address in memory where we loaded that program at this point The CPU is only executing the process me and the operating system is frozen now the C people keep executing the process forever unless it's tell to do otherwise now either by an external interrupts interrupting the CPU or I mean the process making a request to the US so if I trust the OS to print out hello world, I'd call the OS a Which point control is passed back to the OS which can then handle that request? Afterwards the OS done the requests can pass back control to the process And things continue the program can run and run occasionally making calls to the OS At which point control is passed back to the operating system and then back to the process to do more calculation before? Passing control back to the OS when the process wants something else to happen However, the operating system doesn't need to hand control back to the same process There's nothing actually stopping us loading a different programs coding data again from storage into memory as well And then we can start that program instead by returning to its code start address Welcome to computer files first unboxing video. I've got here the Raspberry Pi for computer and We're going to open this and have a look at how this works and to do that. We're going to need to could open Nobody's actually got the knife modulating an operating system. Could you load the knife DLL for me and Then the ice is back in control and it can then pass control not back to the new process, but back to the original process Which continues as if nothing had happened? It's oblivious to the fact that this this other process running from my point of view I asked their eyes to do something it did it and handed back control to me and Completely unaware there's any other process running on the system So we're going to have the operating system switch between the different processes and to do that We need to be able to do three things The first is we actually need to physically switch from one processor running to another now at some level. This is straightforward We just jump from one memory address to another but we have to keep track of a few things And so that's called context switching and we'll look at that in detail in another video the other thing we need to do is decide which process is going to run next and that's called process scheduling and again, We'll do another video on that. Just deciding we've had this process running Which one's ready which one we gonna actually run at this time? And the other thing is we need a model a way of deciding Which processes are available to run and that's what we're going to look at today. So we're gonna have this idea There are many programs running many processes running and we're going to switch between them So let's look at how we might model that so we're going to start off Building up what we call the life cycle of the process. So we're going to start off by creating the process and Then it'll transition from that to what we call the running state And if you think about surprises is created it then starts running on the CPU So the organism cursor is then start running on the CPU and then eventually it is Terminated so we can start to see how this work. So let's find a process Jadey, baby So the process gets created by the operating system as we saw in the demo It then starts running on the CPU and it's doing things It's calculating things and this is a very boring process and it just immediately kills itself and doesn't I think at some point This process is going to want to interact with the rest of the world It's going to call the operating system to do something and when it does that We model that by having another state in our system Call this blocked and our process can transfer from the running state To the block state and at that point we know that process is still doing things. It hasn't finished It can't run at the moment because it's waiting for Something to happen so we can print it out some data to come over the network whatever it is so what we do is it stays there and then eventually We can take it back to the running State And so we can then have our process go back to the running state. It's printed out Hello world it now waits for a key to be press so it's blocked again And then it goes back to the running state until eventually it gets terminated But of course we can then start Another process and we can start to see now how we can model having more than one process what's going on in the operating system? Because we've got that process running there and then we can create another one now. Obviously you can't run at the moment because This process is running but eventually this process will ask for some what you've written at which point it's blocked and the operating system can shed you'll That process to be running. So this is waiting for say a key to be pressed on the keyboard But this one can then run start calculating PI to 500 decimal places or whatever it is. It's doing Now we'll get to a point where either this process will decide. It's a 1 used to print something else at which point it Can then become blocked as well or? This process will get the key that's been waiting for from the keyboard in which case it's ready to start running again So actually we don't translate directly from block to running We actually have a state called runnable and we use that to keep track of Processes that can run but can't run at the current time So this one's running this one can run but it's not ready and let's create another one as well So eventually this one starts saying something out to disk so it's gotta wait for that to finish and now we can either showed you this one to be running or That one could be showed you to be running and that way that's let's put that one on there have the green process running this One gets the data saved to disk. And so that one is now also runnable and then this one Less way because the network packet It's an HTTP server say And we can show you one of these back on here now as should be obvious You can only ever have one process or running at a time or attempting one per CPU but you can have as many as you like in the runnable state and you can have as many In the block state and you can follow the transitions Between the different things to model the process and this works fine because eventually the process is can then finish it complete Can you go straight to terminate from so runnable or anything? Do you have to go back to well, so the program the opposite? Yeah, there's a good question. If you're here, could you go straight to terminate? Yes I know this process could be too measured directly by the operating system something outside It says I want to kill this process in which case he gets to make it and cleared up but for you to stop itself It has to be running on the CPU to execute the code to say it's finished So we can have many in this state many in this state. But any one running on there But then you could have another CPU come in Yeah None of my processes is missing Just wait Yeah, I'll need another process of Gym but okay. So this works. Let's have a running process. We move things around But say this process here something goes wrong. You've written a bit of code and it gets stuck in an infinite loop well We've now got a problem the operating system the way we've designed it can only switch when one of these processes hands control To it, cause the operators and that's what they've built It's what we call a cooperative multitasking system because we require the processes to cooperate they have to hand control back to the pros to the operating system at some point and operating systems like the original Mac house of ready systems like Windows 3.1 they work in this Sort of fashion. They could run many programs at the same time But they required them to pass control back to the operating system regularly Which a GUI program will do so the way they work but if they ever do some long calculations a very tracings I mean you could often get the system freeze if it was badly written software You'd have to call the operating system occasionally to pan control back But there is another way we can do it. We can have build what's called a pre-emptive Multitasking operating them and what happens here? Is that the operating system says ok? I know I can switch control when you move between States when you press control to me because I can then bring that one in But what I'll do is I'll say I'm going to regularly Look at what's running and change the process and to do that. We have another let me just redraw this diagram before we do that So at this point if this process is running for a long time Then the operating system can't change it because it's codes are not running We were reliant on this actually making a call to the operating system Now the way we get around that is a modern operating system like UNIX like Windows NT and so on what they do is they say actually as well as switching processes when they Call the operating system We will let the operating system switch the process automatically and the way we do that is two things first We provide a mechanism for the operating system to regain control regularly from the proces Regardless of them doing it and the way we do that is we have an external interrupt which fires say every 200 Second every thousandth of a second whatever you want it to be the difference from computer to computer So every to hundreds of a seconds this external timer interrupts the CPU and that passes control to the operating system and now the operate systems back in control and It can switch processes. It can say well, okay. This process has now had enough time on the CPU We shall take that off and put a different one on and the way it does that is if we extend this model To allow us to move process not just from blocked into being ready to run a ball, but from running into the runnable state So that we can bring another process in and what happened? Is that every time we switch processes We move one from running in to run a ball or back into running or occasionally That one will then call the operating system. Who can we move one in? Like that, so we get some switching as the regular interrupts are happening between the two and so on It's like having the two Steve's talking about different things And we can keep them running until they finish and we get to murder them What's happening? We've talked about the keydown event the key up mouse-click events. We probably wouldn't get one Where the mouse is moving if you think about as the mouse is being moved You've got lots and lots of events most of which you're not interested in You're probably only interested when a button is pressed or so on the only times pass that's different. Is it cause of you?