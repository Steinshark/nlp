i've spoken to people who have been much more involved with the 360 series than i have i'm i'm a complete charlatan i've written a few fortran programs that ran on top of system 360. but people who i've been in contact with now say we admired it a lot for its achievements but it was not not a user-friendly or programmer friendly environment i've not found anybody who is prepared to stand up and say yeah it was the bee's news it was wonderful they all said yeah it was a bit of a mishmash some really good things in it some things that were awful to cope with didn't they think about writing it in a higher level language wouldn't that have got better productivity because of course this is all in assembler so what would the story be then about trying to use a higher level language and at this era i mean i do have a little bit of hands-on knowledge not so much on the 360 series but on the ico 1906 where the rcl provided software didn't let me do this but algol 68 compiler written for the rcl1906a did enable me to do it is to yeah just be able to use the higher level language for things like if statements or case statements things involving layouts and and also of course to have the higher level language be capable of working out for square arrays or rectangular arrays which scientists and engineers love but as we all know they're not held in a square format directly or a rectangular form you have to work out in a linear apparently linear level of memory where exactly is byte number a555 that's holding this character i'm interested in and you have to do multiplication sums you have to know how many bytes there are in each of these objects in your array you have to know whether the underlying architecture is storing the array by rows or storing it by columns now interestingly at bell labs before dennis and ken invented c can you guess what ken thompson's chosen the high level language was i will say at the outset that his first stab at anything was to write an interpreter for it in the b language very cut down bcbl i i'm guessing just because of what you've just said fortran yes the number of times that ken in those very early days says oh yes and once we've done that we must do a fortran compiler fortran can be amazingly spartan and minimalist in its approach but if you're struggling to find a language that will just about do as a system programming language and nothing else is available i know from experience i've done mixed fortran assembler programming so long as the people writing the link editor get the assembler modules talking to the fortran modules okay it can be remarkably effect effective what does a compiler do with the assembler when you've got a mixed language the comp as far as the compiler knows you write a procedure call a subroutine call out for a subroutine called fred with parameters a b and c little does the fortran compiler know that the thing that will merge this into a uniform thing is that fred is written in assembler and the rules on the assembler manual say we can help you if you will only pass your actual parameters in registers five six and seven shall we say you follow that then we the link editor for assembler level modules and that's the thing in the end the fortran compiles down to being assembler level modules this all got linked in a uniform and harmonious way because there are agreed conventions for how you pass information between the two the thing that really gets you in vanilla early fortran was it helped enormously with the logic the if and the case statements you could do them as it were although fortran didn't have case at the time but doing array calculations and getting that right what it couldn't do then in most fortrans was actual detailed bit twiddling you know masking with bit patterns that typically had to be saved for assembler and addressed at the end of a known interface as to how you passed your eight bits across to be twiddled with or whatever so we've now mentioned the fact that if you wanted a slightly higher level approach then fortran could come to your rescue if you wanted something better than that wouldn't these more modern languages um pl1 if you're an ibm disciple algol 68 if you were a weirdo committee person that just loved high-level language wouldn't they be even more helpful and the answer to that is it depended on the implementation if i had to pull out one more anecdote of high-level language constructs that eventually became house trained and became visible in dennis and ken's early sea it was structures now in arrays you don't really name well you give the array an overall name but the rest of your calculations as to where the elements are is all done by multiplying because they're all rectangular or square you can work it out but what you really need is something agglomerations where they're not all the same size objects structures in other words you need to be able to name the fields or components in your structure and have them be at different boundaries depending on whether it's a set of reels or a set of characters or a set of integers you need to be able to name things and i'm told by psychologists that this is a very deep psychological need in the human brain you've got to be able to give things names and significantly kenneth was more or less saying it was fourth time lucky by the time we got structures properly working you knew that if you did underscore fred it knew how many bytes displacement the beginning of fred was from the start of the beginning of the whole structure and you didn't have to think oh is it 10 bites ahead the tables you were building up as you compiled it told you that by counting and dead reckoning the field called jim had to be exactly 12 bytes downstream of the start so if you say thing underscore jim you've got it right but if you actually moved on by what you thought was the right number of bytes you'd get off by one problems no it wasn't 10 bytes down it was 11 bytes down but if you name if you extend a labeling system to be the principle of naming things you start getting things right and he said that was the key in early c if you give them names and you label them and let the compiler make its own memo of how far down these fields are within each of these structures as you declare and instantiate them it will get it right for you so it's getting higher level effect well yes it's just so simple but what ken is covertly saying is even genius programmers like me make mistakes and the way to stop making mistakes is to have a labeling scheme and just trust it so it's another part of something we might want to get on to in another video is to what degree is it advantageous in programming to hide things and in a way giving these names is hiding the ultimate hardware truth from you procedure interfaces is another way of forcibly hiding things you know i'm not going to have you replicate and squirt out all my raw assembler i'm going to get you to jump into one of my procedures and i will tell you which registers in the cpu to use for passing over extra information and you will trust that procedure and as we get even further on into agglomerations of procedures and arrays and structs that develop into an even bigger class thing in object-oriented languages even more so does it apply that being able to name things and from the concatenation of the names being able to work out where the heck that object is in real memory is absolutely vital so we'd have to go over here across the distributed shared memory link to get the value and then we could bring the value back so rather than taking 100 nanoseconds it would take in the order of three hundred and half for most people if they've never created a branch before that just shows you the main branch that you're currently on and it will have a star next to except the one it's showing you