hi i'm james murphy. have you ever come across 
an error when trying to import a module? in   this case it's telling me that i can't import my 
function a from a partially initialized module a.   scrolling over it tells me that the most likely 
cause is a circular import. in this video we'll   go over how these circular imports commonly 
arise and what are the main ways to fix them.   here's the simplest and most common way 
that this kind of import cycle can happen   at runtime main tried to import something 
from a, so it starts initializing a. it   starts running the code from a, but the first 
line in a is to import something from module b,   so it stops initializing a because b has to be 
initialized first, and then it hops over to b   and starts running that code instead. but then the 
first line in b is that it needs something from   a. so it stops running b and goes over to a and 
it would like to just start initializing a. but   it realizes that a is already in the process of 
initialization. so that's where the error occurs/   we can actually see this chain of events 
unfold in the traceback. here we see in main   it tries to import function a from module a, which 
triggered the import of function b from module b,   which then triggered the import of function a 
again from module a, which is then where the   final error occurred. the way that things are 
written right now we have an import time cycle   between the modules a and b, but if you 
actually look at the names that we imported,   we don't actually use them at import time. we use 
them when this function a or when this function   b2 are called. since we're not actually calling 
these functions at import time, there's no true   cyclic dependency, which means we can get rid of 
this import cycle. there are three common ways   to resolve this issue. the first one is to take 
your import and put it inside of the function. in   python, imports can happen at any time, including 
when a function is called, so if this is the only   place that you need this function b1, then it 
could be okay to just do the import right here.   this could actually be even more efficient 
because if you never call the function a,   then it may be that you never even have to 
import b at all. but let's say that you have   a bunch of different functions in a, and a 
lot of different ones use this function b1.   in that case, the better solution would 
be to just import the module b directly   and then in the functions where you use it, 
use the longer name module b dot function b1.   go ahead and do this conversion for all modules 
involved in the cycle. let's see how this resolves   the import cycle at runtime. first our main 
function tries to import something from a, causing   a to start running. in a, we get to the import 
module b, which triggers b to start running.   in b, when we get to the import module a, because 
the a module has already started initializing,   this module object technically exists. since 
it exists, it doesn't start running this again,   it just says okay that exists so the b module 
will just continue on, finish its import,   and then after that import is done 
the a module will finish importing.   the third and final common way to get rid of this 
import cycle is to just merge the two modules   together. no imports, no import cycles. however 
if you had two or maybe even more modules in the   first place, you probably had them for a reason, 
so i'm not just going to recommend that you take   all of your modules and merge them into one, 
that would be kind of silly. so for that reason,   you should probably prefer using one of the first 
two methods. let's take a look at another example.   the next most common kind of import cycle that 
you'll run into is due to using type hints.   this example is not like the previous one 
because type annotations are defined on a   function definition or class definition when the 
function is defined or when the class is defined,   not when it's run. but if you think about it, the 
most common use case of type hinting is not even   at runtime, it's for static type analyzers like 
mypy. if all we care about is static analysis,   then we don't even need to do the import at 
runtime. the typing module provides this variable,   type checking, which is just false at runtime. 
so if you put all the imports that you just need   for the purpose of type checking in one of these 
if type checking checks, then none of those will   actually happen at runtime, completely avoiding 
the import loop. but now if you import this   function you're going to get a name error because 
this name b hasn't been imported. to fix this, go   ahead and add this from future import annotations. 
what this actually does is it changes the way that   annotations work. instead of evaluating b as a 
name, all annotations are converted to strings.   so now you don't get an error at runtime here 
because even though the name b isn't imported,   the string b certainly exists. you should 
be aware though that whenever you do one   of these from future imports it's not 
necessarily guaranteed behavior forever.   right now this causes your annotations to be 
handled as strings, but there's actually a   competing proposal to make them just be evaluated 
lazily so they're just not evaluated at all   unless you try to look at them. unless you're 
actually inspecting your type hints at runtime,   this probably won't make any difference for 
your code base, but you should still be aware.   an alternative solution is to again just use 
import modules instead of from module imports.   you will still need the from future import 
annotations, and the downside to this approach is   that your type hints look kind of, you know, not 
as nice. now let's take a look at a very tricky   cycle that some larger projects will run into. 
this is what i call the sub package init cycle.   the actual structure of the package is 
important for this example so let's go over it.   first i have a main script, it's outside of the 
package and just tries to import some class from   some module in the package and do whatever, very 
similar to the previous case. now this package,   my package, contains two sub packages: sub package 
a and sub package b. sub package a contains   two modules, module a and c, and sub package 
b contains the module b. for whatever reason   let's assume that module a needs something 
out of module b. here's module b, which we   also assume depends on module c. but looking at 
module c, module c doesn't depend on anything,   so there's no actual cycle here. a depends on b, 
and b depends on c. c doesn't depend on anything.   nevertheless when we try to run it we do get an 
import cycle, so what happened? the problem here   is not with any of the modules a, b, or c. the 
actual issue is in these sub package init files,   our subpackage init files here are re-exporting 
some names, in this case classes, from some of   the modules inside of them. doing this is pretty 
common in python projects because it allows you to   have shorter import syntax. here i can just have 
a client say from my package dot sub package a   import a instead of the longer from my package 
sub package a module a import a. the problem with   doing this is that every module in a sub package 
depends on the init of the sub package, so if the   init of the sub package depends on all of the 
modules in the sub package then you've kind of   made a fake dependency of every module in the sub 
package on every other module in the sub package.   that means even though c has no imports at all 
c now automatically also depends on a because it   depends on the init. let's see this by starting 
in main and following the traceback. main tries   to import something from module b, so to import 
something from module b we first have to run the   sub package init. all sub package b does is import 
from module b so we start importing module b.   module b wants to import something from 
module c, so first we have to initialize   sub package a that contains module c. but sub 
package a imports from module a, and module a   imports from module b, so now we have a cycle 
because we haven't finished initializing. the   way to get rid of this cycle is to just make all 
of your init files blank. if you still want to   give your users a short way to import names rather 
than importing directly from the modules you can   define what i call an interface package. this is 
a package that has no extra modules just its init.   inside the init you put all the things that you 
wanted to import from your other sub package.   now your users can import from the interface 
instead of reaching directly into the modules,   and there's still no import cycles. depending 
on your use case you might give the interface   a separate name, but a lot of packages just make 
the true package that has all the modules in it   underscore whatever and then make the interface 
name just the whatever. so what was interface a   just became sub package a and what was sub 
package a became underscore sub package a.   finally let's take a look at the worst example. 
we're back to just a flat directory structure,   we just have two modules but in this case both of 
the modules depend on each other, a depends on b,   b depends on a, and they actually use those 
dependencies at import time. this is the worst   and most difficult case, primarily because 
this often involves an architectural error.   if you're actually using something from b 
in a, then that thing needs to be defined,   so b needs to be initialized before a. but 
if you're also using something from a in b,   then a needs to be initialized before b. well 
which one is it? does b need to come before a,   or does a need to come before b? in my 
experience, if your modules are that   intertwined that they need each other both at 
import time, that kind of suggests to me that   they should probably be the same module, 
merging them together is your best bet.   however, the most common case that i see 
this come up is when someone tries to mix   library code with script code. most commonly these 
import time dependencies are not really necessary   and you should just pull them out into a script 
and leave the remaining library code alone.   if you can't strip out these import time 
dependencies then i'm sorry, there's not   much i can do to help you. your application 
needs some serious redesigning, it's going   to be a mess no matter how you do it, and there's 
no general advice i can give you. just good luck.   as always, thank you for watching. thank you to 
my patrons and donors for supporting me. don't   forget to subscribe, comment, and slap that like 
button an odd number of times, see you next time