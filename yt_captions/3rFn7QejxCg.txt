all right guys welcome back to tech in turn uh today i'm joined with javin ambridge for i think the third time total um and javed and i created this extension from lead party which i have been hyping up for a few weeks on tech uh and today we are actually gonna try it out together so we're gonna basically be competing we're gonna open elite code and we're gonna like see who can solve the problem a friendly competition all about self-improvement let's uh make that clear yes exactly so um should be fun uh i think today our like our rankings are completely based off how fast we complete the problem but in the future it's going to be like dynamically determined off of your memory usage your runtime and how long it takes you to write it as well as if you view other people's code that'll be extremely detrimental to your score and you will definitely not win so that feature will soon be rolling out uh to the market across the world nice we've uh yeah we've got a lot of really cool features coming up so uh let's just jump in and i'll kind of show people how to use it as we go so we've found a problem here it's called number of good pairs oh that's a good point i thought i was but i am not share so um basically all you have to do is find a leak code problem that you want to work on and you actually don't even need to find a leak code problem if you're not on lead code then this this this chromium will bring you to a random problem but right now we're on a problem if we want to learn how to use it we just click the information button tells us exactly how to use it that's going to look a little prettier in the future but it is what it is for now so i'm just going to go ahead and start a party it's just me in there i'm going to grab that link and pretty good name domestic cockroach right now it just gives you a generated name but we're going to have it so that you can pick your own name in the future uh you gotta send me the problem yep i'm sending it to you now so there's the link and you can see right now like since we haven't started the game that's deactivated i can't start writing code behind javin's back okay he's readied up so i'm gonna ready up two everybody's readied up now the host who is me can start the game um i haven't even read the problem but i assume it's i assume i'll be able to tackle it all right put that down there all right you ready yep let's do this start okay number of good pairs given an array of integers nums a pair i j is good if i equals to j and i is less than j return the number of good pairs four good pairs zero to three four three four two five okay so there's a really obvious like brute force solution here where you just go through each place and then you run through the rest of the array to see if that um you know if it makes a good pair which of course would be like a really easy solution but it wouldn't get you the win in this feature that's coming up soon because another person could easily write a better runtime function and beat you so i'm going for an approach that is going to be on time there's an end time oh geez i can't even think of an own end time solution [Music] how would i do this okay wait a second why is in this first example why is there only four good pairs can there be five because like one is smaller than two is smaller than three two is smaller than three one is smaller than three one is smaller than three the numbers need to be equivalent and the indexes need to be smaller oh a pair is called good if the numbers are equivalent and the end oh okay okay okay that makes a lot more sense i was i was just thinking about all pairs that were like smaller than each other see i don't read problems correctly this is my number one problem in coding interviews i actually don't even just read the problem i feel like you're right there and i have to think about this a little bit more oh shoot you actually have to return them i think i can still do that i don't think you return them i think you just returned the count oh you do okay thank goodness just python three or two does that have a problem oh you beat me shoot i don't think i was that performing like i thought originally it was going to be o n but i got to o n log n time what you sorted it you sorted the array i want to look at your solution i'm going to look at your solution all right what did you do okay so you made a new map i did that too for each of the things exists equals count so you get you get the index okay if it does not exist you add it in there and put a new set in there so i want a list of the indexes that are matching that value that's exactly what i did okay what did i do wrong i must have done it wrong here so key value pair and the entries you sorted yeah because if you don't sort it then there's an opportunity that a higher index is uh closer to the start of the array and then you won't match it to a lower index when you're supposed to yeah because if what i figured is if you're adding them into the list as you go and you add them in the correct order then they should be further along in the list like they should be ahead of it so i don't know why this didn't work oh i i understand what's happening right here so you're doing the length minus one right and for that first uh that first array zero three four that's giving you two but inside that that's actually three right because zero to three and zero to four and three to four all right right right okay so what is the correct way to find the number of pairs then is it it's probably some exponent exponent because each entry is less than the entries ahead of it it's almost like um i feel like there's a math equation for it it's definitely a math equation i can't think of what it is yeah but i think you can do it the brute force way it's pretty trivial so if there was like four entries one two three four it would be three plus two plus one plus zero so essentially it would be the length what is that some okay length plus length minus one over two let me try that but it's also one below it okay this is gonna be stupid but we'll see if it works i'm just kind of curious now oh this is uh this is good i mean the point of this uh extension isn't fully about just competing and getting right answer like these kind of situations are exactly what is going to help you improve and become better at these kind of interviews so uh just because i got one uh jason's gonna get the next one and i'm gonna be in the same boat and we'll both learn from each other and in the end it will be much better and if this goes through well and uh his will be for sure a lot more performant than mine okay let's submit that and see if it works there we go now you would have won for sure based on performance that is imp performance as well as memory uh yeah improvement unfortunately i'm gonna win just because of writing time but you would win in the future potentially if you had maybe been a bit quicker uh see how the math adds up well also i think you you told me what was wrong with my code there it's i sometimes get a way ahead of myself where i'm like i just want to be done with the problem and so i'm like okay now i've got the pairs i'm done but i didn't even think about it like oh okay each pair it's more than just n pairs it's actually the summation so for anyone who's curious this here the reason i did this is because each pair is like if you take the first entry it is like every entry above it and then the next entry entries every entry above it and so on so forth and so what you end up having if you have four in the list you have three plus two plus one plus zero the summation formula if you have like one plus two plus three plus four plus five all the way up to n you just do n times n minus one over two and that gives you the summation so in a nice closed form so one more elegant solution than mine for sure well uh that was actually like a lot of fun like i really enjoyed that it was it was good well we do another one okay so we found a new problem to do um so again like right now we only have a feature where you create a room for each problem in the future it's going to be like you can keep the room going with new problems but right now you just have to create a new room every time you get a new problem and so we're going to do this one split a string and split a string and balance strings i'm going to go ahead and send that to javin so a few things to note while you're doing this and this will come in the new feature is you're going to try you want to try your best to be under 30 minutes when you're doing interviews going above 30 minutes is usually pretty detrimental to uh interview so we are in turn going to negatively impact your score if you go up above 30 minutes so really 10 to 20 min or 10 00 to 10 minutes is very optimal 10 to 20 minutes is average uh 20 to 30 and onwards is a bit slow so try if you're maybe getting to that 20 minute or 30 minute interval cut yourself short and look at someone else's problem it'll help you in the long run for interviews as well as just being more uh higher velocity while writing music yeah and of course it does have some like depends a little bit on the problem itself but what you'll find is that you'll get like you'll either get a 30 minute long interview in which case you're gonna have to solve the problem in under in 20 minutes like you have 20 minutes because the rest of the time is talking and uh if you get an hour long then you might get two 20 minute problems actually you might not get a 30 or 40 minute problem you might get two 20 minute problems so definitely a really good thing to point out there javin yeah and final note is uh i've been impacted by this uh previously but uh if you're doing a technical interview the main concept of it is the technical part don't go crazy talking about yourself that's usually done in other parts uh leave yourself the time to actually do the problem definitely definitely okay so i'm gonna read the problem before i ready up this time so balanced strings are those who have who have equal quantity of l and r characters given a bound string s split it to the maximum amount of balanced strings return the maximum amount of splitted balance strings example one rl l r l or l so there's four there you've got the first one uh in the very first two characters and then you've got r r l l and then you've got rl and then you've got r one more time all right now i'm going to ready up get this thing out of my way again you know what actually i need to take a swig of water this is like intense i'm really glad we made this extension man because i'm actually enjoying it a lot it definitely makes the experience a lot more enjoyable no doubt okay three two one start i'm trying to wonder in python how do i check if the nra is empty because i'm worried it would just equate the two i just would say not okay nevermind i worry it would it would try to equate the objects on like the address level let's see what happens here oh i didn't return it okay i got a accepted run time oh shoot so i'm doing a stack approach essentially uh i am going to be counting the characters and then once they are equivalent i will iterate a total count and reset the original character counts that is basically what i'm doing um i got tripped up by example two just so you know so you might want to take a look at that maybe you're much smarter than me i don't know about that oh my god you submitted already i think there is more performance here i'm just gonna say are you making sure to reset your accounts yep uh no there i submitted mine well how are yours always so much more performant than mine i'm really mad that we don't have this feature out right now where uh it would be working um both of them to be quite honest is there a difference in language performance is that significant there could be there actually really could be like you can try taking my solution and running it uh like rewriting it in java script and see what happens i wonder yeah i wonder so if yes i at r write count plus plus l less left count plus plus if they equal the same thing total count plus plus and then reset them okay that probably makes a lot more sense wait actually kind of surprised that works it's kind of like a greedy approach ramp i'm just because i know if i can find something the first time i find it is going to be the minimal which leads to the highest quantity that makes a lot of sense i what i did my approach was so it was wrong like the first time i did it it was wrong because i thought that it had to start with an r and then end with an l but it could be lr um and so here's what i did i basically decided this leading chair bleeding char sorry set it if it's like the beginning um if the if the first charge the leading char then add it to the stack if not pop it from the stack if the stack is empty then count plus one and reset the leading chart yeah i think yours would be more memory performant than mine um you think so i actually think mine would be less memory performant because i'm storing all of like the list yeah actually you're one of two numbers i'm just storing a single integer yeah you know what there's definitely like some foul play with languages here because yours is uh like your memory usage is so much higher than mine that's something that maybe we should account for uh in our next iteration of our extension if anyone has any uh insight or recommendations you're more than open to getting them you can reach us at contact leadsparty.com that's a good point uh we definitely should take that into into consideration maybe for like the beta beta version of this feature uh we just like default to writing time if you have different if you have different languages but we'll talk about that after this episode is over well anyway i got beat twice but i had a lot of fun and i actually felt like i learned i actually learned something here today i don't know if you got beat twice i beat you in writing time but you 100 there's not even a question about it in the first one it was way more performant way more memory performance so i feel like i just uh i beat you in the writing time that's basically the only category that i beat you and i think the second problem i think we're pretty equivalent yeah you know what i think is like really comes out to me is like what i do wrong in interviews is i always don't read the problem or read the test cases because um i could have i think i could have beat you here if i had realized that um r is not always the leading character like if i had just known that then i would have done this in the beginning but i didn't and so therefore i had to run it and feel oh okay now i'm wrong and then go back to the drawing board and then by the time i had done that you'd won well i heard you say oh darn like you submitted it and it didn't work and i was like oh i'm uh i'm still writing so if that submission had worked uh based on what you said uh then you would have 100 one in every single category well i i had so much fun uh thank you javin for for first off helping build that this like really cool platform uh and second off for beating me live on camera today embarrass me um thanks for having me it takes uh i like to say this uh it takes two to tango i did not i did not build this extension by myself we have an asana board that we have a lot of the tasks and we have been actively working together for the last month and i i still i think i may have just won based on an edge case not necessarily that i actually won but i'll take it and uh today i feel like we did two ranked easy problems on leap code so the next time we do this we're gonna have to up our game a little bit um but for today we haven't done this in over a year yeah no i i don't think either of us have much experience recently so okay well uh that's it for the show today like javin said you guys can reach out to us at that contact email or you can find just go to leadparty.com and you can learn more you can find out how to contact us and possibly get involved in helping build some of these features so that would be really cool again you can you can find me on linkedin uh jason goodison javin you can find on linkedin too if you want to uh reach out to javen and talk with him he's a software engineer at uber and i'm at microsoft so great thanks so much for joining us today guys we'll see you next week