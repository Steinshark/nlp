the story of Doom Source Doom 3 source code and how beautiful it is yes beautiful allow me to explain I've never once okay I have okay I'm guilty I'm guilty of it I've called I've seen code that I went this is beautiful code it's infrequent but it's it certainly happens okay it does happen after releasing my video uh game diad I took a little break and I read some books and watched some movies and I put off let's say I'd put off for too long I was working on the European version of diad but that time what is the European version of diad is that where they drink like tea they complain about they like sue people for privacy stuff what what what is it I don't know what is the European version they just work less hard got them got them first try American view coming in hot but that time was mostly waiting for feedback from Sony quality assurance uh so I had a lot of free time after loafing around for a month or so I started to seriously consider what I was do going to do next I wanted to extract the reusable game engine parts of diad for a new project uh you can actually teabag people oo is that European is the teabagging a European approach to saying good game let's see when I originally started working on diad there was a very clean pretty functional game engine I created from an accumulation of years of working on other projects by the end of diad I had a hideous mess sounds like every beautiful piece of code I've ever started with honestly in the final six weeks of diet development I added over 13,000 lines of code main menu cc ballooned to 24,500 lines of code love it I love it menus are so effing hard menus are just the worst they're just forms it's forms all over again it's just forms all over again the once beautiful source code was a mess riddled with if defs gratuitous function pointers ugly inline Sim DNA ASM code I learned a new term code entropy yes it's real I searched the internet for other projects that I could learn uh use to learn how to organize hundreds of thousands of lines of code and after looking through several large game engines I was pretty discouraged the diad source code wasn't actually that bad compared to everything else out there yeah inline simd in your menu is wild like what kind of what the hell is happening in your menu that you need simd going on like I thought menu systems were pretty simple like you're painting some squares with some with some textures on it waiting for input to change what's being focused okay maybe I was maybe I'm being ignorant here but in my head that is like what's happening you know what I mean unsatisfied I continued looking and found a very nice analysis of ID software's Doom 3 source code I spent a few days going through Doom 3 source code and reading fa fabian's excellent uh article I retweeted all right check out the article and look hey sea mcgarth I'm actually going to go to Shan mcgarth over here we're going to hit a little follow on this because you know I just love I just boom followed okay do the same thing uh it was the truth I've never really cared about source code before I don't really consider myself a programmer programs a video game arguably the hardest median to actually create in makes a successful video game I'm not really a progr programmer I'm good at it but for me it's just a means to an end going through Doom 3 source code really made me appreciate good programmers to put things into perspective diad was 193,000 lines of code all C++ again not a programmer people not a programmer uh Doom 3 has 61,000 Quake 3 has 229 and Quake 2 has 136 that puts diad somewhere between Quake 2 and Quake 3 these are large projects when I was asked to write this article I used to use it as an excuse to read more source code for uh from other games and to read about programming standards after days of research I was confused by my own tweet that started this whole thing what would look Nic looking or beautiful or for that matter actually mean when referring to source code I asked some programmer friends what they thought that meant their answers were obvious but still worth stating I actually honestly don't know what goodlook source code is honestly I have no idea I think good-look source code changes and it's also like a measure of your understanding as well of the code right like if you understand understand the problem and then you understand how someone framed it and you're like oh that's good but you could look at a piece of code and you could see like man I don't understand the problem and I don't really understand what's going on here this is bad code like that might just be purely a perspective you know what I mean uh code should be locally coherent and single functioned one function should do exactly one thing I actually don't necessarily agree with this it should be clear about what's uh what it's doing uh local code should explain or at least uh hint at overall syst system design interesting uh code should be self-documenting comments should be avoided whenever possible love it absolutely love this last part honestly comments for the most part are really dumb unless if it's like a very special circumstance comment duplicate work when both writing and reading code if you need to comment something to make it understandable it should probably be written different I or Rewritten I don't agree with that last take uh some things are just complicated right some things take you debugging for 10 hours to know this one special case and so that one special case should be like hey to save you 10 hours you should should know in this particular situation this thing happens and that's that right there's an uh itte 4 coding standard doc that I think is worth reading I follow most of the standards and I try to explain why they are good and why spec specifically they make Doom 3 code so beautiful all right all right un unified parsing and lexical analysis one of the smartest things I've seen from Doom is the generic use of lexical analyzer and parser all resource files are asky files with a unified syntax including scripts animation files config files Etc everything is the same this allows one this allows all files to be read and processed by a single chunk of code the parser is particularly robust supporting major subsets of C++ by sticking to a unified parser and Lex or all other components of the engine needn't worry about serializing data as there's already code for that this makes all other aspects of the code cleaner okay I mean I think that's just universally good advice if you're going to have some sort of scripting thing make the scripting thing good right this is Lua in a nutshell right if you're going to use Lu in your project it's probably better than you making up your own your own DSL right uh like when you use vimel vimel is a little crazy it's kind of wild it just is whereas you use Lua and you're like not bad it's not bad right uh const and rigid parameters Doom's code is fairly rigid although not rigid enough in my opinion with respect to const const serves several purposes which I believe too many programmers ignore my rule is everything should be always const unless it can't be I wish all variables in C+ Le we con by default oh my goodness rust in the making dude he's getting rustifer you can see it Doom almost always sticks uh to a no inout parameter policy meaning all parameters to a function are either input or output never both this makes it so much easier to understand what's happening with a variable when you pass it to a function for example by the way this statement right here is like JavaScript people don't understand right this is like you know the American mind can't comprehend this is the JavaScript mind cannot comprehend this statement which is that there's input and output variables passed to a function right like that's a real thing you do and you see a lot in C it's great it's beautiful right it's beautiful it is amazing and when you learn how to use it it's really useful right it's like a whole another way to solve things um this function definition makes me happy just a few const and I know many things the ID plane that gets past an argument will not be modified by this function I can safely use the plane after this function executes without checking for modifications of ID plane yep I assume this is called ID right right this is this is ID the software studio so ID plane that's what I just assume uh I know the Epsilon won't be changed within the function although it could easily be copied to another value and scaled for instance but that would uh be counterproductive front back front on plane edges and back on Place edges then now we're starting now we're getting into game programming are out out variables these will be written too the final con after the parameter list is my favorite it indicates ID surface split won't modify the surface itself this is one of my favorite C++ features missing from other languages it allows me to do something like void F cons surface s uh okay yes uh again rust just saying he's ready okay this guy's ready desires it wants it can't wait to have it rust uh if split wasn't defined as split const this code would not compile now I know that whatever is called uh F won't modify the surface even if F passes the surface to another function or call some surface method con tells me a lot about the function it also hints at a larger system design simply by reading this function declaration I know surfaces can be split by a plane dynamically instead of modifying the surface it returns new surfaces front and back optionally front on plane edges and back on Plain edges oh he called it back on place edges up here see I I was a little bit confused but okay we see it now we see it now um okay yeah I mean this is good I mean this is obvious programming goodness is when you know a lot about a function the more you can know from the signature the better it is right that's why typescript is popular uh because you have the ability to read only if you need to you have the ability to Define types I mean that's why Dynamic typed languages are generally not considered that great is because I mean generally there are people that love typed untyped or secretly typed languages uh I call them secretly typed because they're still very much typed they're just hidden behind some opeg surface right dhh um so I get that the const rule has uh and no input output parameter is probably the single most important thing in my eyes that separate good code from beautiful code okay I can buy this uh it makes the whole system uh easier to understand and easier to edit and refactor yeah agreed minimal comments this is a stylistic issue but one beautiful thing that Doom usually does is uh not over comment I've seen way too much code that looks like this uh that looks like I find this extremely irritating I can't I can tell what this method does by its name if its function can't be inferred from its name its name should be changed if it does not if it does too much to describe in its name make it do less if it really can't be refactored and renamed to describe its single purpose then it's okay to comment I think programmers are taught in school that comments are good yes we are I was required to I was required to comment every line in every lab until I got out of school and during my time working on my own startup is where I learned I ain't going to comment okay future me's problem is remembering what I did and that's that I'm going to have to remember what I did and if I don't remember I hope I wrote it well enough which allowed me to come up with a good way to do what I call like the 75% rule program code 75% good enough first try and you can go very very far very fast now it's not the 100% solution it's not one that's going to be be infinitely scalable but it's pretty good it can get you far enough into the project to the point where refactoring makes sense you know what I mean comment every line of so dumb it absolutely is but it's school and they require that uh comments aren't bad unless they're totally let's see unless they're totally necessary and they're rarely necessary Doom does a reasonable job at keeping comments to a minimum using ID surface split example uh let's look at how it's commented split the surface into front and back surface the surface itself stays unchanged front and back plays are optionally stored indices in the uh to the edges that lay on the split plane return side question mark the first line is completely unnecessary agreed uh yes because it's part of the con definition it's already in the definition we learned all that information from the function definition the second and third lines are valuable we could infer the second Line's properties but the comment removes potential ambiguity okay that's good I actually I actually really like this I really like this observation don't restate what types can state for you and I think this is a good lesson for all the um all the TS Andes out there all you TS Andes in the functions you don't mutate variables maybe it's more and more valuable to start passing in readon you know what I mean maybe we should start maybe we should start making it normal to do uh read only regularly I don't but maybe that's a good idea is just start readon to like signify to other people the usage of this function could be good or object freeze. life no see I don't like that I don't like object freeze um because that's actual programmatic differences whereas you're stating what a function will do this function will not edit this object coming in like to me that's a really great it's a it's it's an API design Choice object. freeze is pre- API you pass that in and if you're and if you attempt to mutate the object I don't know if object. freeze throws does object. freeze throw I don't even know honestly I have no idea uh cons a equals a Fu five uh uh object. freeze a I forget if it returns something does it return something uh B okay uh b. bar equals 5 see it B right it doesn't even tell you so it's silently it silently airs right and so by silently airing that's like the worst of all problems uh I I wouldn't want this right I I I don't want that I want code that I know what happens so by specifying on the API side whether or not it's going to change that's good right strict mode throws okay strict mode throws okay strict mode throws that's good but again that means every time you look up or mutate an object like I I don't really want to have to go through all this you know what I mean yuck Design's better than than that right design it well don't you don't need to enforce it if it's designed well anyways the first line is completely unnecessary we learned all that information from the function definition the second and third lines are valuable we can infer the second Line's properties but the comment removes potential ambiguity I already I actually completely read that already Doom's code is for the most part judicial uh judicial it should be judicious judicial is a very different word here it's not judicial it's judicious uh with its comments which it makes it much easier to read I know this may be a style issue for some people but I definitely think there's a clear right way to do it for example what would happen if someone changed the function and removed the const at the end then surface could be changed from within the function and now the comment is out of sync with the code great example great example extraneous comments hurt the readability and accuracy of code thus making the code uglier spacing Doom does not waste a vertical space I like this uh for the most part here's an example um from uh T stencil Arc chop winding I don't know this one uh I can read the entire algorithm on a fourth of my screen leaving the other three fours to understand where the block of code fits relative to its surrounding code I have seen uh too much code like this this is going to be another point that falls under style I programmed for for more than 10 years with the ladder style forcing myself to convert to a tighter way while working on a project about 6 years ago I'm glad I switched the ladder takes 18 lines compared to the 11 lines uh in the first that's nearly double the number of lines of code for the exact same functionality it means that the next chunk of code doesn't fit on the screen for me what what's the next chunk okay I see this argument this argument I really fall into like and I'm not sure I really don't know on this one because here's the deal is like I do like vertical spacing I like to separate out ideas what I mean by that is like I like a variable initialization section it just feels good for me to have like hey I'm going to make three variables and I'm going to have this is the like the thing and then I'm going to have like an action uh you know what I mean so here let's go over to let's go over to Harpoon like I like this right I'm stating I'm stating some I'm stating some things with this right I'm stating here's me reassigning for defaults here's me creating new ones here's me leaving or doing whatever right I like doing things in chunks right I don't know why for me I like that I could tighten this all up I'm just not sure if it's really uh that great right like is that any better is that more readable probably just more of like a get used to it you know what I mean yeah we're missing the code blocks for sure some people like this I program with a lot of people that prefer this I kind of like I kind of like the spacing you know what I mean I've always been kind of a space Andy now I could go this way versus the other way I you know I don't know which way I'm kind of like initializing and using it in one spot I never know the way to do things right for me vertical spacing I find more comfortable I don't know that code makes no sense without the previous Loop chunk uh if I didn't resp uh respect vertical space their code would be too uh be much harder to read harder to write harder to maintain and less beautiful okay so we're going to say we disagree with this one generally here I'm going to take a little poll while I'll keep reading and we'll come back to that cuz I'm actually curious how people really feel about this another thing that it does that I believe believe is right and not a style issue is always use these things even when optional this okay I agree with this this is right this is right this is 100% right I think it's a crime to skip the brace brackets I've seen so much code like this I I wonder why we don't get to see the code we're missing the code so just deal with it uh the ugly code like you you know what he's putting in here it's an if statement or it's a for Loop you know how they have you ever seen a for Loop and then an if statement a for Loop in the if statement oh you think it's dark readers oh how much do you want to bet right on that one I don't think it's dark readers here I'm going to refresh there you go hard refresh and all always right I don't think it's I don't think it's yeah we're just not seeing it we're just not I don't think it's dark Raiders I think something else is going on here and I don't understand what it is but you get the idea it's like a it's like a for Loop or an if statement with no with no Squires on them you know that's ugly code it's the worse than putting braces on their own lines I couldn't find a single example in IDs code where they skipped the braces admitting the optional braces makes parsing this wild block okay they're using a while block see that's crazy uh more timec consuming than it needs to be have you ever added a comment and you didn't realize someone didn't put in the scorely braces like I don't even read the squirly braces like they're they're they're like gone in my brain and I will put in a log line and then ruin the if statement because of it I absolutely hate that my goodness all right absolutely love that okay I love that one minimal templates it did a huge no no in the C++ World they rewrote all required uh STL functions I personally have LoveHate relationship with STL in diad I used uh it in debug builds to manage Dynamic resources in release I baked all the resources so they could be loaded as quickly as possible and don't use any STL functionality the STL is nice because it provides fast generic data structures it's bad because it can often be ugly and error prone for example let's look at Vector T class let's say I wanted to iterate over each element uh dang it I this is where I really wish the code would actually load uh that doesn't simplify with C++ 11 so this must be doing that whole like iterator thing grab the iterator plus plus on the iterator const auto a colon you know the thing I I don't know personally I don't like to you the use of Auto called it called the auto called the auto I think let's see it makes the code easier to write but harder to read I might come around to the usage of Auto in the coming years but for now I think it's bad I actually agree with this Auto is just not the same it doesn't feel the same it just never feels the same oh you're right maybe it is ad blocking here uh how do I turn this thing off I've never actually turned it off for a particular site there we go I refreshed the page and now taking literally forever well I mean this might be part of the problem okay see so this is part of the thing that like maybe we don't want that I still didn't get those code blocks though I'm still not getting the code blocks and I'm just getting way more ads okay I'm getting all the ads none of the code blocks okay gee that's going to be typed correctly by every programmer every every time again I we don't even know what they're saying but I think I can I think I believe what he's trying to say yeah I got to get that I got to get that I got to get that block back up baby baby let's get that block back up all right all right that's going to be typed correctly by every programmer every time it uh it removes all ambiguity they rolled their own generic containers string classes Etc they wrote them much less generic than the STL classes presumably to make them easier to understand they're minimally templated and use it specific memory allocators STL code is so littered with template nonsense that is impossible to read fair fair take have you ever tried to walk through some of the stuff it's very difficult to understand C++ code can quickly get unruly and ugly without diligence on the part of the programmers to see how bad things can get check out the STL source code Microsoft's and gcc's man just just calling out GCC dude STL is crazy okay STL is is difficult Prime why is everyone call me Prime oh the way back machine has the code thank you everybody thank you I wonder why the code got deleted because I actually really wanted to see this yeah see again oh interesting choice of spacing look at the spacing it's actually on the Almond Style versus whatever style I forgot what it is but I actually so I actually prefer this code versus this code yeah that's fine I prefer my braces I prefer my squirly braces on the on the right side you're welcome by the way yeah WordPress must have got pronouned right um yeah I mean this is obviously crazy if you program like like that you should be shot in the ankle of course okay like like like a wing clip so it hurts you have to go get some stitches but like you're not dead or anything okay I'm not saying you should be murdered okay in game also so you can just use like a tarov healing pack and you're back in the game okay now you're going to drink a little bit of condensed milk you're dead Okay everybody knows that you're dead uh oh you got some condensed milk you're dead I love that by the way the fact that you drink condensed milk and you die it's just so good um anyways all right minimal templates blah blah blah blah all right yeah look this Auto it a vector begin it does not equal vector Type n i++ like I've always hated that I think this is a disaster luckily they made it nicer and this also like any of like I love I I literally have right there effective C++ Third Edition I have a tour of C++ as well I have you know like I understand where they were going and there's a lot of Beauty with the ideas of making things iterators and how you get them and how you delete from them and all that it's absolutely wonderful but at the exact same time it is a huge pain in the ass okay C++ uh you know it really is you know what I mean like I the way back machine totally sucks what is this why do I got to have the code why do I have to keepy okay and dang it I'm I think I'm using Firefox still which makes it virtually impossible for me to edit because I don't know how to use their their thing okay I don't even know how to use their thing okay what is this what is this section can I just delete you and create is there a delete is there not a delete tell me there's not okay there is a delete okay that didn't work didn't work didn't work okay um what are you are you floating or something let me guess you're you're floating you're floating aren't you so we're gonna go like this style equals uh float left space enter damn it's not floating I thought it was floating I thought we had a float right there I thought we had a float um I thought we had something there okay I thought we had something there but we don't um I'm not really sure skill issues I it's skill issues uh import um uh bang import nope import did not work um here I'll go like this we'll just keep it easy uh margin uh margin left is negative 100 pixels damn it that didn't work either I dude I thought I had it is it Styles not style is that my problem is it Styles no I don't know what it is okay whatever we're going back to um I'm going to go right to here and I'm going to bring over Chad okay because this is the only way I can do this okay I can't I can't read stuff that's way to the to this side okay it's weird CSS am I right am I right am I right I'm not trying anymore okay see C++ code can get quit uh unruly and ugly without diligence on the part of the programmers to see how bad things can get check out the STL source code Microsoft's gcc's blah blah we already read all this all right uh take a look at Andre's alexandr scu's Loki library or the Boost libraries these are written by some of the best C++ programmers in the world and great care was taken to make them as beautiful as possible they're still ugly and basically unreadable ID solves this problem by simply not making things overly generic they have a hashtable and a hash index class hashtable forces the type to be const charar the hash index is an INT toint pair this is considered poor C++ practice they should have been uh should had a single hashtable class and written partial specialization for key type conar star and fully specialized int int what it it does it is completely correct and makes their code much more beautiful it's also specific implementation specific stuff can be really beautiful you know it can be really easy to understand I do agree with that it' be considered by many to be good practice to create specific computation class as a parameter to the hash table like so okay beautiful compute hash uh this could be specialized for a particular type okay beautiful wonderful then you could pass the compute hash for type as the hash computer for the hash table classic the hash computer for the hash table is going to be the compute hash for type this is similar how I did it it seems smart but boy is it ugly what if there are more optional template parameters maybe memory allocator maybe a debug Tracer you'd have a definition like this absolutely this is real this is real I've seen this stuff I've seen it it's not awesome I not happy when I see that stuff did I just see a study time follow or study time raid hey thank you study time for that beautiful raid thank you appreciate that what a wonderful day so good uh What does this even mean I don't even know there's too many parameters at this point I can't even find the method name without some aggressive syntax highlighting it's in conceivable that there' be more definition code than body code this is clearly not easy to read thus not beautiful I actually fully agree with this statement if your function definition requires more code than the code of the body something something has gone off the rails you you are clean coding you're clean coding hard you know what I mean you've got to the point where um or you've probably you've probably left the path of of good programming at this point uh study time says uh study s says you're a good human being how do you defend yourself uh this reminds me of the quote in Gladiator where where Maximus says to proximo proximo you're in danger of becoming a good man don't worry I will disappoint you I am a piece of it's okay don't worry I I I am completely I I have complete understanding of who I am not good okay this is not something you want to write home about uh all right anyways uh I've seen other engines manage to uh this mess by offloading the template argument specification to a myriad of type defs I've seen this too it's crazy it's even worse yes cuz the the the definition jumping is insane it might make local code easier to understand but it creates another layer of Disconnect between local code and overarching system logic making the code not a hint towards system design which is not beautiful I love the use of beautiful here proximo oh dude isn't it so good uh you can't be prime home I don't even sure what that means uh for example let's say there was code okay yeah and this I actually agree I feel like I mean I guess in some sense I do like T type defs they can be really nice and go I know that you can use a type Def and then attach methods to it so if you have it even though it's like an INT you can attach nice little methods to it like there is some really good stuff but I also understand that like when you overly typed def things out in this case it's just really difficult to understand right it is just really difficult to understand uh it's possible that the string hash tables memory allocator string allocator won't contribute to the global memory which would cause you uh which would cause you confusion you'd have to back Trace through the code to find out where string hash table is actually a type def of a mess of templates parse through the template code and find out that it's a different allocator and find that allocator and blah blah blah it's ugly agreed Doom does it uh does the complete wrong thing according to C uh common C++ logic it writes things as non-generic as possible using generics only when it makes sense let's go John carac I love this I love this take this is so good what does Doom hash table do when it needs to generate a hash of something it calls ID stir get hash because the only type of key it accepts is a con uh Char star what would happen if it needs a different key my guess is that they template the key and just force it to call key. has and have the compiler enforce all the key types have the in get has method awesome this is so good remnants of C I don't know how much of the IDS original programming team is with the company anymore but John carac at least comes from a C background all ID games before Quake 3 were written in C I find many C++ programmers without a strong C background over C++ eyes their code the previous template example was just one case three other examples that I can find are the use of get set methods uh string streams string streams are crazy crazy string streams excessive operator overloading okay who doesn't like a good old fashioned operator overloading right who doesn't love a good oldfashioned operator overloading it is very it is very judicial in all these cases uh this is a waste of lines of code and reading time it takes longer to write it and read it comparatively Class Type public VAR what if you're often increasing VAR by some number n versus get set VAR yeah I mean this is just Java bleeding into it right this is just Java bleeding into the situation you know what I mean everyone's kind of seen this being too dogmatic on any language is bad I blame this on schools not on The Language Fair this is fair uh this is definitely the Java side of things trying to be like you need Getters and Setters they're the best don't worry it'll be inline blah blah blah blah it's just like yeah but it's super annoying you know what I mean if see if you have no friends no operator overloading for you just use a struck dude no one forbids it yeah hi Mom uh the first example is much easier to read and write it doesn't uh it it doesn't use string streams and string streams probably contain the most extreme bastardization of operator overloads I've ever seen the double this direction I do agree I do I've loed this for so long I've loathed it I don't like it that's ugly it does it does have strong advantages you can Define the equivalent of java two string method per class without touching the classes V tables but the syntax is offensive and i' choose not to use it choosing to use print F instead of string streams can make their code easier to read and thus I think it's correct decision the only down downside of print f is when you get like slightly incorrect type passing into print F and you can cause some weird teas right uh print F I actually don't mind this oh look at that beautiful HDMX horse look at that look at that beautiful one I teach all my junior devs uh on how to write uh guard Clauses they make the code so much readable yeah I do like a good early return is nice let's see Syntax for some classes operators would be this would be ridiculous too look at that dude so disgusting why would you do that side note John carac has stated that static analysis tools revealed that their common bug was incorrect parameter matching uh in print F it's like I predicted the future there I wonder if they changed the string streams in Rage because of this GCC and cang both find print F parameter matching errors with W wall so you don't need expressive static analysis tools to find these errors another thing that makes Doom code beautiful is the minimal use of operator overloads operator overloading is a very nice feature of C++ it allows you to do things like this yes you can do it in Rust too I'm not sure I actually think C++ might have it slightly nicer rust is a little weird you implement these traits and there's like a lot of cases to it like doing the ad one you know you really got to do all these different cases because of how you know the borrow Checker works and who owns who and do you produce a new version or not it's like there's a lot to that you know what I mean there is a lot to that um without overloading these operations uh would be more timec consuming to write and pars Doom steps here I've seen code that doesn't I've seen code that will operate uh overload operate the percent to mean dot product vers or uh operate Vector star vector to do uh piece-wise Vector multiplication it doesn't make sense or it doesn't make sense to make the star operator for cross product because that only exists in 3D what if you wanted to do 2D V times 2D V what should it do what about a 40 or higher it's minimal operator overloading that leaves no ambiguity to the read of the code Fair one of the biggest things I've learned from Doom code was uh was a simple style change I used to use classes that look like this oh oh baby look at that code oh look at that code and what they're doing is this what according to what okay like I think John karmac is one of the greatest programmers of all time and I have absolute commanding respect for carac but whatever this style of code is it honestly makes me want a vame this is crazy this is crazy looking what am I supposed to do with this I love the fact that the two different Constructors here they don't H you know you don't Define return Types on Constructors so it's just like empty space like there's so much stuff this crazy man let John Cook I don't know I don't think I should let John Cook on this one oh gosh I don't like that I I don't dislike that just because I write hascal dude your phrase your statement makes me think you write hascal you know how many knots are in that phrase crazy okay crazy that bro hitting tabs so many tabs dude crazy they rarely put the inline functions uh inside the class definition the only time I've seen it to where the code is written on the same line as the function declaration it seems this practice is not the norm and is probably frowned upon this method of organizing class definitions makes it extremely easy to parse I don't know I don't like anything where I have to like be really precise on looking back and forth right I don't want to have like because imagine a wall of definitions it's hard it's hard since you'd have to retype a bunch of information to find the class yeah inline string yeah yeah yeah yeah yeah yeah I'm against all extra typing there's literally extra typing right here um I need to get stuff done as fast as possible but this is one situation where I think a little extra okay he owned me he saw me coming and owned me okay owned me on this one very very much so um let's see a little extra typing when defining the class more than pays for itself each time the class definition needs to be parsed by a programmer there are several other s stylistic examples provided in Doom 3 coding standards and that contribute to the beauty of Doom source code method names I think Doom's method names uh rules are lacking I personally enforced the rule that all method names should begin with a verb unless they can't get so I actually let's see for example is much better so I actually I prefer the other way at this point I think this is I actually prefer just the thing as opposed to the get part I don't like the whole enforcing of a verb anymore I used to be that way but it makes more sense to be able to just be like length then get length I don't I just don't think you need that I don't think you're getting anything extra out of this yes it's beautiful I disagree with this point I like all the other points but I disagree with that point I was really excited to write this article because it gave me an extra excuse to think about what beautiful Cod is I still don't think I know and maybe it's entirely subjective I would probably I'd say the only time I've truly been struck by like beautiful code is no matter how ugly it is it's when someone solves a problem so different than me it feels like I've unlocked a new way to solve a problem in my brain has anyone ever had that it's like where you see something done so different than how you would approach it that you're just like oh wow right like it just it it's so cool it's such a great experience it's magical and it doesn't happen very often but when you do see it it's prasing like that's the first time prasing has ever been found and recorded and it's true and it feels good and I've been chasing the high ever since I love reading code just in case I find another one of these right you never know when you're going to have your next prasm but when you do so good why not a lot of stylistic choices are definit definitely my personal preferences and I'm sure other programmers will have different opinions I think the choice of what style to use is up to whoever has to read and write the code but I certainly think it's something worth thinking about absolutely uh here let's go down to the John carac one because I actually do want to see this John carac one here let's go back to the previous one because I had it all I had it out and I really did want to see this one all right John carac a few comments in some ways I still think Quake 3 code is cleaner as a fin evolution of my C style rather than my first iteration of my C++ style but it may be more of a factor of the smaller Total Line count or the fact that I haven't really looked at it in a decade I do think good C++ is better than good C from a readability standpoint all other things being equal I sort of meandered into C++ with Doom 3 I was originally experienced C programmer with oop background from next objective c ooh sorry uh so I just started writing C++ without any proper study of usage and idiom in retrospect I very much wish I had read Effective C++ sitting right there on my counter let's go and some other material a couple of the other programmers had prior C++ experience but they most mostly followed the stylistic choices I set I mistrusted templates for many years and I still use them with restraint but I eventually decided I liked strong typing more than I disliked weird code in headers the debate on stdl is still going on here at ID and gets a little spirited back when Doom 3 started using STL was almost certainly not a good call but reasonable arguments can be made for today even in games okay base take by John I am a full const Nazi nowadays that's not a phrase Bingo C 2023 not a phrase that was going to come out of my mouth but it just did and I ched any programmer that doesn't const every variable and parameter that can be a major Evolution that is still going on for me is towards a more functional programming style which involves unlearning a lot of old habits and breaking away from o directions this is great honestly this is great I think that it's you know what I completely agree with Mr carac on this statement you really should strive to make everything constant as you can it just reduces the amount of potential change but it's not really about mutation that I'm worried about it's about sending a signal to other people that what you have designed these points change you can tell somebody where change occurs and that's one thing I really do like about rust is that it's const as basic definition mute as what you have to opt into and I truly do think that that is the best uh or one of the best features of rust is mute as an extra word you have to add on const should have always been the default he actually had a post in 2014 he actually became more and more of a functional programmer yeah I know I saw that one that uh that good performance sucks when you forget it yeah yeah I mean there's there's all these other reasons why you should use const but I think for the biggest one is that you you get to understand it you know what I mean you get to look at it and see it and I think that that right there is more beneficial than anything else all right hey sometimes you have a non-con parameter in an interface and one in implementation it can be constant that style the check style complains that it's not const I hate that yeah uh that's crazy I don't know how to I don't know how to deal with that one but that is kind of rough the name is the Beautiful koden