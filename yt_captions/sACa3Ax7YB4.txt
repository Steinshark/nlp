okay let's move um i thought i understood move semantics when i last christmas started to write a little bit about it and i learned that i did not and um so this is a talk where i try to tell you a little bit about this whole thing and this is not a talk with slides um this is a talk about implementing a simple class a simple class um to store email addresses actually a single email address and of course this class should have good performance and therefore move semantics is something we are interested in so let me um start with a class i have a class here this is my email class um let's go through it step by step class email okay oops okay class email so what's an email an email has a string value and a state in the state could be none an email value is set or um the email address was even validated so we know it's a proper email address whatever that means so let's try to initialize the email address having a default constructor um we have the initial value of none and here this string is empty so that's the initial state and then we have um the ability to take a string initialize a value with the string and check the state the check state function is a helper function that will evaluate this email address and find out whether it's empty or so whether it's none or whether it's set or whether it's even valid um so for the moment we don't want to look any more again against that here we just find an ampersand so if it's if it's an if it contains an ampersand it's valid and of course a lot of other things are missing there and then we have again again returning the email address so get value returning this by value we will talk about that and finally we have an output operator the output operator um just will print none or the email address in angel brackets or if it is a valid email address the audience asking if you could uh make the form of your text and your code bigger that they can better follow along okay so let's do that that or even a bit more yes just make it really big okay thank you oh my green is not my screen is not big enough okay let's see so good so class email a value in the state constructors you can check the state geta and we have an output that's all looks like a pretty forward class let's use it so let's use it in some test code um yeah i will change the font here also so let's use it here um let's create a vector of emails with some initial emails my email addresses and an empty string and an invalid email address so having no ampersand anything else yes let's um push some additional email addresses there um we have here from the command line from xcv we get a default value of 10 000 10 000 100 000. and um 100 000 emails addresses we push in there and but we can try out different things print out the email addresses with a helper function that simply iterates over them and prints the first form the last four of them so we don't print the whole collection and then that's up let me sort the email addresses here um go from begin to end um and our sorting compari tricario is yeah we compare we saw it according to the value of an email address so that's straightforward code i think no surprises should be here i hope at least um let's um compile it and run it so i will also change the size here okay so let's compile and run it to compile it i have a couple of compilers available let's start with the sequel transforming compiler and um so you see it's gcc 5 5 with -02 and a couple of warnings are enabled and let's run it bro here you see on the initialization takes 220 milliseconds and the um sorting takes about four and five seconds on this platform that's not a proof just to have some numbers and you see that here we have the elements the first ones i initialized here are these four and then we have the others other 100 000 email addresses and then we have here them sorted so um empty email addresses first and then there comes the others and you see that when i print it out every email address that is valid has a okay after the email address good that's it can we improve the speed in this simple class yes we talk about roof semantics and we can improve one thing here so the first thing we can improve is this constructor this constructor takes a const string reference and then uses this to initialize the string member well that's a problem because you might have already a string value you no longer need and you might want to move it to this member but this doesn't work because you take the argument by const reference so what could we do instead well so let me comment out the old thing we did and let's switch to a new thing let's take the string by value and um move this value into the member so the constructor takes the argument by value which if you learn c might be something you learned as a surprise no don't pass a string by value but this time this is something different because we anyway have to create a new string a new string as part of a new email address and but when we take the argument as a non-constrained value we can benefit from move semantics so let's take whatever we got maybe it's just created here on the fly maybe it's a copy or maybe it's a move and then move this here to the string value remember that if you take a con string reference you could not move it to here because for console objects it's move is not working so let's recompile and let's run again you see this is a significant improvement so initialization now takes less than half yeah don't don't take these numbers too serious it's um it's um the only thing that it's this shows is there's a remarkable improvement the improvement depends on the amount of optimization you use the platform you use the way the standard library is implemented so whatever you use here um there might be some chance for improvement and you see it might be significant are the other ways to do that of course you could overload for different cases for um taking a non-cons um r value reference on and a const l value reference and so you can overload for different cases but here we have a simple way to do it um just this works and has a good performance in all cases if and only if a move is cheap because um we have a string here and their move is cheap if this value member would be an area of 1 million doubles this might be counterproductive so be careful with this improvement this is not always an improvement but in many cases it might be okay that's the first thing we can benefit from roof semantics so what else can we improve here um look at the the sort function um the third function takes around between four and five seconds so um can we improve that and yes you might see that we use or might remember that as a sorting criterion that's here we call getvalue so each time we have to compare two values to email addresses we call getvalue for these two email addresses and that's called a lot when the sorting algorithm is called and each time this count get value member function returns a new string because it returns a value by value so that's the old old old flame rule or discussion we have in many projects should get a return by value or should it return by reference and there would be significant improvement if we return by reference let me again uncommand this and instead return the value by reference so let's recompile and see how the numbers are and run that's huge that's sorting got faster by a factor of 10 about 10. and it's clear i mean we save a lot of time so we create a new string intentionally by the way my strings i use um uh have significant length you see here some of them so that the short string optimization is not used but even with a small small string optimization there might be some significant improvements depends again from platform to platform but of course if we save to copy a string especially if the string needs memory that goes faster significantly faster so we should return by const reference well wait a minute let me go to this program and add a new line and in this line i want to iterate over the characters of a temporary email address that's my favorite example when i discuss with people um show together return by course reference so for each character c in past a new temporary email address um this is a function i use next email so next email will give me the next um email address and then in this email address i would like to have the value and iterate over these characters so let's print out um c maybe a space and at the end let's print new line let's run so it compiled and let's run it um yep looks good works let's compile it um with another compiler maybe we use a visual studio so we don't see breath fast so um let's use that and run it again and you see here something interesting you see here nothing so it seems the iteration over the characters of the value of a new email address is not printed and the reason is first of all the problem we have in the range-based forward which i hope hope really hope will be fixed very soon i am just proposing a paper for that and the problem is that there's some hidden mechanism behind the scenes when using a range-based for loop and these mechanisms extend some but not all lifetimes so it's not like a function call it's more like um that this value um has a lifetime and that lifetime gets expanded throughout this life this loop but while the loop internally runs in the range-based for loop the lifetime of the returns value here is not extended so we iterate over a destroyed email address and what you see here is a result um whether it works or not depends on the platform depends on i don't know the your memory use etc so you might get a caught up you might get undefined you have undefined behavior and part of undefined behavior is that it might simply work as it did here and that's my favorite example um that um returning a reference is might be a problem because this means you refer to a member of an object and you have to make sure that the object is still alive when you then use the return value which is a problem in the range-based for loop but you can't easily create this situation in other cases so now we have a trade-off should we um be safe and slow or should we be fast well there's a new option introduced with move semantics and this option looks as follows we can do both we can what we are we can overload functions you know that you know that probably that you say oh that's overload functions for a const and a non-const version these are just a way to say well let's like overloading for different um parameters that are qualified differently now let's qualify the object we call this member function for differently but i don't overload for non-constant cons i overload for temporary objects and other objects so the one thing i say is there is a special implementation for temporary objects well in fact this is and for our value references so our value references bind to temporary objects or pr values and they bind to objects marked with move so for these objects i have here an implementation and as this is for temporary objects especially um so they might die as here and before but as i told you this is not the only example let's change this and say well let's return it by value and for everything else and kant's reference we have um here an implementation for all others this binds to all but this has higher priority for temporary so this is prepare preferred for temporaries so now we have a fast getter and we have a safe way to deal with to ask for the value of an object that's about to die and yeah let's compile and run and this was by the way introduced with c plus plus 11 also with move semantics and you can and should use it if you return expensive things expensive members from your object so email test now also works in visual c plus plus um good um because we fixed our back it was very okay that visual zebra does work the way it did um actually it was good we saw a problem and um it also works now with gcc we have some pretty good performance you see here um the sort function we have a fast sort function because together here we call it for objects that have a name so we use this scatter only if we have a temporary object like here we use this scatter okay so that was the second thing let's add another thing that's in our program at um remove from our um all values that have dot com in it so timar just mentioned remove f and he just learned that um as a caveat with remove and that's carry out um i want it i want to use also in this talk and interestingly so let's go over our collection and remove um all the elements where we have here we have where we find dot com so we return if um.fine um sorry em dot get value dot sign dot com is not equal std string and class well our so our remove criterion is um if we find a value with dot com we remove it which is almost all elements in this and there's some program and then let's print it out okay oh no error that happens rarely when i do a demo coding um emailcast so here you see something interesting and it's funny really funny that teamwork just uses remove if in the talk before um because um he told you already that remove if works a way that um it re it changes the order of the element it can't remove um an element in a container because it only deals with iterators or pointers to the container so it can only modify values of the elements but not remove elements from the container and so actually what does remove if do it moves all elements um to the front that have not dot com well actually these are only these three elements these are moved to the front and everything else um and and everything else is either untouched or we move the old values there away and as you see before we remove the elements these are the three last elements or these are the four last elements and now we have them here because this value and this value was moved to the front and now you get an interesting and interesting effect because you see that now in the container we have an email object that has no value but is classified as being valid okay so what happened we move this value to somewhere else to here so we use move semantics and the way the move semantic is is implemented that it moves the members so we have a value and the state member so we move the value yeah the value from here moves to here so we'll use the value here oh excuse me talk about this this value is moved here and look at the last element the value from here is also moved to uh here so we lose the value here um the output of a move for strings is a valid string you don't know the value it might not be empty it could have any other value but it's very typical and in all implementations the fact that the value is moved in a way that the moved from object the object that had the value and where the value was moved away is empty so we see that here but we and we also move the state well state is a just an enum there's nothing with move semantics to optimize so we copy the state and that's the effect um we copy away the state we move away the value and at the end we have this value now you can discuss about this a lot because you might say wait a minute um that's okay i mean the last element in my connection is no longer valid it's not a valid email address and that's okay because you have moved it away but um to some extent we usually expect that if objects have invariants so if objects have certain states uh consistent states that we don't create objects that have an inconsistent state you might argue oh it's your problem if you use the last element but um at least in the standard library we guarantee that moved from objects are always in a valid state so in a consistent state and that's for a good reason because if they are not in a valid state um operations might no longer work up even to the destructor so the question is if there's a problem or not and please also know that you didn't call move the move was called inside an algorithm and there might be functions that do it that way and yes we should not use the removed elements anymore by the way when you compile that with a windows compiler um it gives you a message that you should not you that you should use the return value of remove if this is in german but it tells you um because then that's a new end that's a new logical end and with that help you might better see that there's a problem the question is um how safe how good how sane do we would we want to have this email class to be so should we create should we allow that move semantics creates inconsistent states um it's your issue whether you you think it's an invalid state or not or um should we fix that if this uh at least if this class is used in a lot of places it's probably better to fix that and um so let's look how fixed would look like again i don't say you have to fix that but um you might create interesting situations if you have a class that looks like it does guarantee gives you a gives you an invariant a guarantee about all the objects that exist which state they have and this is suddenly broken so let's implement it let's fix this and how can we fix that well there are a couple of options you could try out so the first options may be that you say oh let's um disable move semantic okay and maybe the naive approaches um we disable um the move constructor and we disable the assignment move assignment operator um maybe i'll switch back to the tcc compiler because then i have color output so you see um it seems to run in a little program problem so what is the problem if you declare move operators as deleted you have there's a rule that you have also deleted the copy operations so no move no copy is it possible anymore so we have also to enable um to explicitly then enable the copy operations so const email and const email ampersand here and let's um set this to default build a problem why that because here's an interesting other rule um if you mark something as deleted you say any try to call this is an error so if overload resolution finds this um it and and says ah delete it says oh it's not allowed to call this that's different from not being declared not being there not being there means um if overload resolution doesn't find it it might take a fall back and in fact if move semantic is requested and it's not supported the copy operations are used but here you say no no forget forget with the fallback mechanism um only allow copying not allow moving which makes no sense at all by the way so um it's the correct way to disable move semantics is to default other special member functions for example the copy operations and now we have it and it compiles and of course we don't benefit from move semantics anymore and um we will have um um it will take longer yeah it's about double double the the speed here and um yeah so and by the way this is um interestingly this is a violation of the rule of five you might have learned that either you declare one of the five special member functions or none excuse me but either all or not um this doesn't this is not right when you want to disable move semantics because there is no way to declare move as please don't find it um so delete would be wrong default would be wrong you could implement it but that would really be crazy so in this case um the rule of five means if you declare or implement one of these five special member functions think about the others but not necessarily declare it also a consequence of move semantics so um well we have a little bit worse of performance so the other option would be to implement these two functions and that might in this case definitely be the better option so let's implement it and let me write this here so the values of a new email address is initialized with um the values of an of an email address but we want to move them so sd move and we also do the same with the state but state has no move semantics um so we take e dot state um and uh all that so far that's what the the usual um move constructor would do and but we do something else we we give um moved from objects a guaranteed value and for that case we say he got values um you know values dot clear that's let's make sure this is an empty string where we got from and let's especially set the state um to um state nah that's correct that is a statement okay oh and and more or less the same we have to do in the in the assignment operator so here we need assignments so e dot values equals removed values from we are sorry the new values are the move values from here and oh god it's a video how bad i type so and the state is um [Music] let's and we should here say this oh yeah value uh [Music] oh that's interesting first of all here we need this and oh what did i do here this is i have to implement these the move operations yeah i'm sure you you saw that already so and there speed parameters it's getting better ah i guess still get an error because of course now i implemented the move operations and once we declare them and that's the case when we implement them we have disabled copying so we have move only types now but we still want to support copying so let's um also enable copy now it works finally good yeah and speed is better again we don't have a inconsistent state there you see the move from object here which was this one is now a valid email address good um look at the number of initialization can we improve that a little bit yes because um if you implement move operations um you should tell whether your implementation throws an exception or not or could throw an exception or not the reason is that the vector um uses when it uses pushback um uses move semantics if it if it has a guarantee that there will be no exception because pushback has a rollback um guarantee and if we move values away we can't roll back so um if you move a couple of values and then you got an exception you have a problem with this guarantee that you gave this guarantee in c plus plus 98. so um the this was a problem we found very late in the standardization um of c bus bus 11 and at the end we introduced a new keyword called no except and with this keyword we can say okay um by the way i guarantee that this will not throw and um there are some some some discussions and some ways you have to do that and you can say even conditionally i give this guarantee if my members give this guarantee etc but in principle this changes the performance again so look at the numbers now and now we have here 200 milliseconds and before we had 250 that's that's not 10 times faster but it's significant and the reason is that now um when the vector grows and grows and grows we allocation now uses these move operations instead of using copy operations good and the good news is um if you just declared with equals default your move operator um the compiler will fill out no except for you so this is only a problem if in case you have to implement a move operator which should still be very rare but you have seen here one example um especially if two members and the state of two members depends on each other okay um we are almost done um with a significantly improved class email um um if you think about the starting class we had and how simple it is just the two members here um but there's one more thing and then there's one more thing and that's it um look at look at here the print statements these print statements i have used here is that i use some helper function that takes begin and end and as you can see here in the output um it will find out whether this what we put in there is a non-console or cons vector so we call print um and we could call it for a cost vector so const um ncd vector of email back and let's call here also i call beginner and vec.begin back dot and it's empty but um i just want to show you that the print function here um makes a difference and um because yeah you see um here we also see that we pass a const vector but here we see um we pass a non-const vector but here at the end now we can't pass a const factor so why am i telling you that because i want to do some improvement i want to make some improvement i want to say um let's provide a helper print this helper print takes a collection well we can take a collection of any type template type name b and we take this collection um yeah as a const reference and what we internally do is pretty simple let's call print with a collection.begin and print with collection dot at so um so i can i think you'll see the point so let's take an arbitrary collection and call another print that takes two iterators begin and end so does it work oh um we should test it so after this two prints i should also call this new print so let's do it right behind let's print the collection and let's print the vector you might see already the problem and the reason why i teach you that i'll tell you that and as you see now um here these are the last two containers a non-const vector and a constructor and now we have only a cons vector so um that is clear because um when we pass a container to this print um we are make whatever we get const because it's a const reference okay so let's take a non-cast reference well this declaration would make everything cost well let's let's not do that and of course i should comment this out so and it works good so let's print it oh yeah great um non-cons const so that's that's a good thing of um template type deduction um here we get t gets it gets a type of what we pass if it's a cons vector t is a const vector type if it's a non-conservator it's a non-cons vector type so great everything is fine well is it oh let me let me do something different let me call print with um a temporary vector so fc vector of email initialize with nothing okay so and here you see problem invalid invalid initialization of a non-const reference from an r value of type so-and-so and the problem is this is a temporary object this is not an l value an object with a name this is a temporary object and non-cons references can't bind to um temporary objects so to pr values that's a value category so this doesn't work for pr values temporary objects so what is the solution well we have something used new since plus um 11 with nuke semantics we have something that is sometimes called universal reference sometimes called our value and forwarding reference so you need also a forwarding reference um i still think um universal reference that was the initial name introduced by scott myers is a better term because it can universally refer to everything well not to everything not to i don't know funkings or so and but it can universally refer to all um expressions l values and r values so if i do it that way and you see it compiles and it keeps the information whether the containers were const or non-cons and and that's a good thing um and the reason i wanted to point that last is i'm not very happy that this is called the forwarding references because as you see we don't use it for forwarding well to some extent you can say before about some information but which by the way every reference does but calling std forward here would really make no sense um you could only call it once saying i no longer need this so you could do something like this and say an scd forward of t of call and for this object we use begin but saying for two objects i no longer need the value looks a little bit weird because forward means i no longer need the value semantically like movement said and if you pause it with two arguments does not really make sense to do that and it's not necessary as you saw um maybe oops maybe i'll leave it in and uncommand it oh and um so here i wanted to motivate a little bit um that we also need universal forwarding reference somewhere else and if you don't use templates of course now with the new c plus plus versions you can use auto here instead so um you could use uh since c plus 20 auto double emphasis and percent here since cbs40 and that should work and that's my final version and um let's compile it with the cheaper 20 compiler and you see um it works again the same way that's it that's not all about move semantics that's all i wanted to to to to tell you about that in a just some live demo so let's see um what we had we had um for expensive members um initialization might better take by value and move for getters there you are might overload for r value references and constant value references to once return by value once returned by reference moved from objects are nothing special uh functions algorithms use them just as other objects so we have seen that in remove if and you might at least think about not breaking in variants so guaranteeing that even a move from object is an invalid but unspecified state uh in my new book i discuss a lot about this in detail in many cases it's okay as it works because rarely people use a moved from object but just to be safe you might think about that um to disable move semantics don't delete a move um special function and in fact deleting a move special member function is never useful as far as i know um and by the way this breaks the naive use understanding of the rule of five and um use no except when implemented special movement functions and there are universal forwarding references which might not forward well that's why i still name them universal references it's a little bit pity that the standard committee introduced a second term although we had one in the c plus plus community but that's a different issue that's it we are right on time you will find this code um probably a little bit better because i did it with more time before the talk at my website userdisc.com download meeting cpp and you find the first version and the last version with some comments and of course i should point out that um i have written i learned all this by writing this book a book about move semantics it's done now and it has 260 pages and you saw some significance parts of it if you want to have more um yeah [Music] so there's two questions i'm going to paste in the yeah yes um asks in get value ampersand ampersand shouldn't you use constant ampersand ampersand the problem is the same for constant temporaries isn't it so you mean here here i suppose so well no don't don't use a reference to something you return here because that's the implementation for temporary object that's about to die and you're running exactly the same problem it doesn't matter whether you return a reference with a single ampersand so an elevator reference on our value reference the problem would be the same by the way i see something i missed something when we return here by value we can here return with std move because the temporary object no longer needs the value i forgot that and that will even improve the performance of the program we had and another question yes the other question is freedom client asking would the speed up be similar if the constructor was spelled out in the cpp file and not in line this was like very at the beginning of the talk here i'm doing when we switch from here to there but we have the same speed up on yeah but it depends so much on a lot of things um if it's not in line that's an issue and i saw if you move and you don't optimize with with -02 using cpp using gcc etc it might the performance might get worse and we have different performance on different platforms so this is a signal i would i would say because conceptually we have to do two memory allocations if we just have this constructor this is better and if you know that memory allocations might happen and for everything else please measure um again it's a little bit tricky in c plus plus to come up with general rules it all depends there's one last question from zasha and it is about i noted that there is a move if no except however there is no sda forward if no except do you know some reasoning behind this no i don't know that um the move if no except was proposed by people who implement the move semantics in for example things like in vector where they say if this was passed with move semantics then we use a move otherwise we do a copy and maybe they didn't use it for forward and even moving forward are not enough for all all situations um i just wanted to implement for example perfect returning and deferred perfect return you defer to later and then neither move nor for what could work you needed to have to have to implement yourself what a forward does so um i think it's just a workaround that came from implementers of library usually you it might help but if not implement yourself a significant a similar helper function okay i think we have time for one more question so there's a question about what about rvo iron man returning as the the move value that you presented answering the first question okay so i read that again what about rvo i mean returning std move value that you presented on okay so you returned their std move for value and what about rvo in that case wouldn't rvo be better well this is not rbo um this is not a local object that's created inside this function it's also not named rvo this is nothing like that because we have no local object this is a this is a local up this is an object which is a member of the object we call this function for that's outside the local scope of this function so the rules of avio and nrvo do not apply here at all okay thank you for your talk thank you very much guys and