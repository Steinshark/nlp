okay so today we're going to talk about something with not a very exciting name but basically the way I would I would uh make your viewers interested is it's a way of programming the kernel without programming the kernel I've heard some people say what JavaScript is to the web uh ebpf is to the operating system so there's a big important distinction in most modern computers between user space down here and it's where we spend most of our prayer time programming and running applications and the kernel which is dealt with by the operating system and the kernel is doing things like taking care of the lower level details of files and um making sure that display drivers and everything run properly one issue comes if you want to ask questions about say file access or TCP transfers or things like that so you want to ask questions that are you're interrogating the operating system to understand you're monitoring your system and if you want to ask the question about say TCP connections or say file IO and you're writing your monitoring program you have this great new idea for how you're going to stop a distributed denial of service or something like this but you're writing it in user space so you need to ask these questions via an a p i application program interface and that limits what you can do and it puts a bit of a drag on how quickly you can do it so if you really want to know you want to monitor file access real quickly you want to monitor TCP connections input output things using memory or whatever ideally you want something running up here in the kernel so ideally you want your program up here I should emphasize the kernel isn't magically faster but for doing accesses on whether a file is uh being accessed for looking at things like file read rights TCP in outs the kernel is much quicker you don't have to go through this API and make calls upwards into the kernel you're already there there's a lot of problems with that though if you want that program to reside in the kernel kernel programming is pretty tricky and then you say to somebody hey oh I've written this great new monitoring tool oh great so what do I do to run your application well step one rebuild the kernel of your computer so you've already got a big kind of barrier to entry or let's imagine you're working on Linux which everybody should be uh then you'll say uh dead Airlines 12 hours could you put my program in your kernel I have been very good Richard Clegg and hope that he's going to include it and that maybe takes a few years so is there some way we can get little hooks into the kernel um and it turns out there's a little virtual machine in a way I think it's really badly misnamed now e b p f extended Berkeley packet filter which is a really weird name because its Origins are really strange around about the 90s early 90s some researchers in Berkeley about what they call a packet filter they were networking people and they were looking at Network traces and I want some simple way to say give me all TCP connections to Port 80 or give me all UDP packets please so they wrote kind of a a regex regular expression match for Packers right and I've been aware of this for years but then a few years ago I started noticing lots of my networking friends in conferences they were presenting all this stuff on Berkeley packet filter I was like what's going on here packet filter can't do that sometime around about 2014 people came up with an idea though this packet filter can run in the kernel maybe you can do clever things in the kernel and then they started to extend it and extend it and give it more and more abilities um and now it's gone so far away from being this thing that filters packets and tells you which packets which match expression so now in um Linux and sort of working in Windows and I believe a Mac versus on the way we've got this little virtual machine sitting in the kernel and do you use a space can write some code and if it matches what the virtual machine wants you can be running little code hooks up in the kernel now what's the use of that it means you can do incredibly quick monitoring or outputting any kind of drag on the CPU this thing has even been taken a little bit further so there is something called xdf so we have if we have our network interface card so their packets are coming in here to be passed up to the kernel there's even something called X d f which will allow these bits of these BPF programs draw on the interface card so you're not even taking the burden on the main parts of your computer now the burden of computation might be going on the network interface card so we've got a way of writing programs in user space having parts of the logic the parts of logic that need to be fast run on the Kernel or even on the neck and it's it's just there's an explosion of monitoring tools so for example one that loads of you probably use your Android battery monitoring tool if you've got a modern version of Android it's probably running ebpf somewhere in the mix to look at powered events and Battery events and stop stop starts with bits of software and you know sometimes if you've got an Android phone you'll get that thing saying application Facebook is using lots of battery do you want to stop it that is probably using ebpf somewhere in the mix on a modern Android phone I've only just been learning this so I'm going to show you the world's worst demo of this because um I'm I'm not a skilled programmer on ebpf but what I wanted to do was create a kind of minimum application for viewers to see the kind of things that this can do but absolutely don't copy what I've done because it's really bad what I've done is a little python demo here um and I will say this this is uh this is very kind of bodged together and the first thing you'll notice is that this doesn't look like python because at the top of the screen here you can see it defining BPF Berkeley packet filter text and then we've got a C program hiding as a matter of text in our Python program so we've got a program here called Don't Touch dot py it's looking like a c program at the top here we can see a little structure that's going to store a name and the length of it because we're doing old school C now so we need to say when we've got a string we need to say not only the characters but the length so that's because it's running on the Kernel it's quite a low level yeah yeah so these these BPF programs need to be really low level it's a virtual machine that's pretty much assembler as I understand it the EPF hash is a structure and this line is giving it a name access it's telling us it's going to map this info about names to an integer this is not the way I should have done it I have copied this code for a man called Brendan Greg who's literally written a book on BPF don't worry too much about this bit of the code this is just grabbing the name of a fail being accessed so some file is being accessed and here I'm storing the name of that file and then I am storing the name itself so I'm showing the length of the name and then the name pushing into my hash the number one why am I pushing in the number one because I shouldn't be using a hash at all to do this I'm just adapting somebody else's code so I'm creating a hash map where I should really do something else but I'm creating a hash map between the name of a file that has been accessed and the number one so every time a file is accessed this is going to happen he is the python so here now we're back in Python land a little bit more comfortable and this special line says uh compile me up that text that I was looking at that BPF program compile it up and these flags are just going to stop it spitting a lot of warnings to the screen and here's a crucial bit we're going to attach a kernel level probe to the event VFS read a read in the file system so every time a file is read in the file system we're going to call our little BPS program and our little BPS program is going to read and put a name and the number one into this little hash map so now whenever a file is read it goes to flash mapping is associated with the number one and yes that is a terribly inefficient way to do it now we're in proper python mode and we're entering a loop sleeping for a second looking for a keyboard interfa interrupting casual Board of the program and grabbing that table access and that table is a table of the name of every file that has been accessed we're going to look through that table and see if we can find a file called hands off dot text so that's what we're looking for if we find that file called hands off.txt we're going to play an alert and if we've alerted too many times we're going to exit and that's all we're going to do and then here while that's all happened we're going to clear our list of access to files so let's see what happens when we run this program so I'm going to run don't touch needs to be run as a root in this case okay so now the program's running everyone's second it's looking down the um list of files accessed and it's checking whether any of them are called hands off.txt now when I access the file hands off.txt you say oh it's spotted that I've done that and it's saying do not look at the file try again and it's given me another warning I asked you not to look at the file and we can keep on messing about with that and it will keep on doing that now okay that's a really really silly silly example but the original plan I've adapted that from was looking at the most accessed files on the system so instead of just saying is it hands-off dot text it was um sorting them all in Python sort them all out printing them in the table and showing you a useful monitoring system with the most accessed files on the system now here's the thing if you're going to run code in the kernel you have to be pretty sure that it's not going to disrupt your machine running stuff in a kernel is inherently a little dangerous so let's try something else let's try something a bit dumb let's calculate some Fibonacci numbers so everybody loves Fibonacci numbers so my kernel program now is going to calculate some Fibonacci numbers so I've got a new file it's almost exactly the same but I'm going to add in something new into our structure we're going to add in a 64-bit Fibonacci number call uh that I'm calling fib and I'm doing an iterative calculation of Fibonacci now you'll be saying oh hold on Richard why are you doing that iteratively it's the classic recursive program I'll come to that in a minute but iteratively we're going to go around and we're going to add together these Fibonacci numbers first or second the usual way we do it and return the results so Fibonacci and and I've got n is 40 which is about what I can do without an overflow so let me run that and we're doing exactly the same thing for no reason whatsoever we're looking at the file system we're waiting for the don't touch this file and when I press it instead of just giving me a warning it's calculated the 40th Fibonacci number which I can look across and see that I've got the correct one if I've made it much higher it would have overflowed why am I doing this stupid thing because it is a really Daft thing to do one one thing is you're putting this thing into the kernel what if it stopped running what if it it didn't come back now you've got a kind of a rogue process in your kernel uh that's not great so let's see what happens if I remove the increment from that Loop so I've removed the I plus plus let's imagine I've just messed up in my programming as happens so often so now this is not going to terminate I've written a an unterminating Loop and now I try and run this and what is it done we can see when it's tried to compile the C code the ebpf compiler has said um infinite Loop detected so it's spotted that I'm trying to do something sneaky I'm trying to get this to run forever or or I've messed up or whatever I've done something that's going to not fit within the safety parameters of my kernel and it stopped my code compiling and that's also the reason I'm doing a sort of clunky looking iterative Fibonacci because the usual recursive Fibonacci another thing that will make this this computer says no is trying to do recursion within um within the virtual machine here so that's actually really short demo it's just absolutely a sort of first level taster um but this um this is used by lots of things now uh when you look at the companies using ebpf it's all of the big players it's Google and Facebook or meta as we're supposed to call them now and the guy whose code I I was using Brendan Gregg is with Netflix so people and um the people doing the big networking stuff are all using this and US researchers are also getting really excited about this I'll give a particular example slightly local uh Cambridge York and bologna have done some work and they're using this to detect when iot devices are producing a different traffic profile than you expect and that might be a sign of a distributed denial of service device so yeah this technology one thing I would say if you're going to play with it it's one of those Technologies where it's at that stage when you read a manual page you read a Blog and you think that sounds great I'll implement it and then you find that that was from 2021 and your operating system is from 2022 so it doesn't quite work anymore so I would encourage people to have a play with it but I would also encourage you to have a little bit of patience so I've written this for example in a system called BCC and then about an hour or two after I had written it I found somebody saying BCC is obsolete it's so 2022 so that's why I call it a rapidly moving Target if you want to get interested in this because you're in the kernel yeah is there a potential here to kind of look right fry your kind of internal not fry but no lock up the machine you're thinking you're thinking of the Halton cash you know you know it could easily be it so if if you start running non terminating Loops in your kernel then potential potential not great things will happen which is why it's carefully protecting foolishness it's trying to trap it yes I was a bit mystified with this when I start so somebody who's looking at my code it might go Richard what are you doing you've declared FIB of the function but you haven't declared n so if I go u64 am mysteriously now it lets it compile which it really shouldn't maybe the devs could tell me why that is certainly that's beyond my level of knowledge of this system um so you can see a work in progress but really really important and lots of production systems are running it how much room it's got left so now the sender knows if I don't want to overwhelm that computer I'm only going to send he got slightly dimmer when we got to this road and then slightly brighter again when we got to this row and we might find that but basically if you've got a