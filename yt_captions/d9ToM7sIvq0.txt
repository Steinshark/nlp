hi and welcome to my talk about how to arrange apply your code my name is tina oil please i work for the rosen technology and research center so what qualifies me to give this talk in my company we use the neo neo-c-pest standards right away which means we're among the first people who bring the new features into production code but that also means that there is not a lot of material available to look up how these features are used in the beginning blog posts and talks are very technical and focus on how the features were implemented into the standard library examples examples tend to be simple my goal is to provide more complex examples some of them are modified examples from our co-face before i start i want to recommend some talks or youtube videos to you that you can watch if you want to learn more about ranges there will be a link to all of these talks in the slides first if you want to learn anything about or everything about rangers basically any talk by eric niebler is where you want to go to he is the author of the range with the library and in his talks he explains in depth how ranges work and how you can use them then we have a talk from justin bringer on the overview of the standard ranges and this is your place to start if you want to know what got into the standard library and also another talk from jesse brindle c plus plus 20 ranges in practice this is a great talk it's also practice oriented with great examples and very good background information as well um this talk series from christopher dibella is also really really really good it teaches you how to build your own range adapters um which is what we also know as views since the standard library lacks some features currently you will likely end up using also using a third party for ranges if you want to use them or you going to write your own range adapters so this talk is really helpful if you want to learn how to do that and also if you want to write your own range adapters i recommend cybran's youtube channel and they have live coding sessions um which are uploaded to youtube and they show you how to implement um views like stride or transform maybe chunk by enumerate and so on so i highly recommend you learn how to do this from psy as well and if you cannot use cps 20 yet or the standard library lacks some features for you you can have a look at this upcoming libraries the first library to use is the range 33 library which is the most extensive library for ranger support and it's also the basis of the range of support in the standard library if you want to know more about this library you can watch the talks by eric niebler because he's the author of this library next we have nanorange and i guess this might be the second largest range library there is it provides concept range-based algorithm function objects projections and more you can also go to sci brands github which is starting llama and get the range adapter they implemented in those youtube videos and live streams and the next library is ranges next and it provides only a handful range adapters it provides range ranges to enumerate and product which is the cartesian product and last but not least we have boost ranges and boost ranges support range-based algorithms and they also have a few range-based adapters like strided for example and these use the pipe syntax as well an advantage of boost range is that it is c 89 compatible so now that we've covered some recommendations and libraries let's dive into the talk first what do i mean when i talk about rangefinding your code a lot of people think about the pipe operator when we talk about ranges but there's actually more there's also the range face algorithms but of course in this talk we will focus a lot on the pipe syntax as well ranges our algorithms are loops we have the tendency to think in loops first because that's what we learned first and we're doing them the longest so they are the most natural to us a change in that already happened on the introduction of algorithms it even got and still get backlash from people saying that they are harder to read and they don't trust the algorithm when they don't see how it is actually implemented the same predators holds against strangers the syntax is the most unfamiliar especially compared to loops it's way more a functional programming approach where you describe what the code is supposed to do then not how it is doing it i'm convinced that once you learn once you get used to the syntax reading and writing the code will get easier and easier the key is also to learn your algorithms so that you know what is actually available to you rangify also means using range-based algorithms you might think there is not a huge change we can just omit the begin and end but it gives us the the option to better the sprite the intent rather than the implementation details and it also limits the noise and also we can now use views in these algorithms so let's say we have a vector of doubles and we want to change the elements of the vector and store the result in a new vector i think in c plus plus there may be a hundred ways of doing that like you can solve this by using a loop you can use an index to loop you can use an iterator-based loop or range-based loop or you can use a standard libraries transform or you can use in c plus 20 the range-based transform as you can see you can now omit the beginning end and just pass in the vector as the first argument but now with ranges you could also use copy and if you use copy you can use a transform view on the input vector and modify it with the modify function this is also a possibility but in this case i would write something like this i would um again use a transform view with the modify function and then use the ranges2 function to create a vector from the result of the transform this has the advantage that i can make the output vector const please note that the we use transform is part of the standard library but ranges too is not so for the last line i use the range v3 library and also if you see the compiler explorer symbol like here that means i have provided a compiler explorer link with all the code so you can look at um so you can look at it later and play around with it if you want to so these little examples always seem a little bit over-engineered and that is why i came up with a little bit more complex examples i try to show as many different cases as possible i will start with some small examples that fit on one slide the first example is finding a maximum number and this is actually a simplified version of a problem or of a piece of code that we have in our code base i need to use simplified versions of the of the code examples that i'm grabbing from our code base because i'm not allowed to share any code from that code base so um i hope you will forgive me for that um so for this function we have a vector as input and it's a vector of strings and these strings are actually numbers and those number signs and to find the maximum number we have a local variable initialized with the minimum of ins and then we iterate over the numbers vector we call string to inch on the number and find the maximum number and then we return the max value and there's no need to use a for loop here you could have used a transform or something like that so it's just how it was in the current code so to range apply this i always look at the loop and try to analyze what the loop is doing so in this case i see that the loop is only looping over the numbers and we don't need an index and what we're doing in the loop body is we are transforming basically the numbers from string to end so that's what we can do in our ranges approach so we can use the ranges function max which returns the maximum number of the passed in range and we call it on numbers and we want to transform the numbers by calling string to inch on every element of numbers and we do this by using the transform view so for all of these examples i prepared some highlights which are showing which parts of the code of the above example corresponds to the part of the course of the ranges example so in this case the loop over numbers corresponds to calling rangeless max on numbers and again the max function also corresponds to the ranges max and string to end is done here in the loop body upper and in the ranges version it is done in the transform view lambda the next example is a sliding mean and in this case the mean or the window for the mean was five elements and it was hard coded to five so i kept it like this first we define our output vector which is the size of the input vector or the input range minus 4. that is because the sliding mean has some is a the sliding mean makes the output vector a little bit smaller and then we have a for loop iterating from two to ranges size minus two or the input range size minus two and um off screen i have a mean function which sums up all the elements of the path in range and divided by five and i will pass an array um to this mean function that is made up of all the five elements from my from my sliding window and i store the output into the output vector and then i return the output vector please note that i'm not doing any boundary checks here so normally in production code i would check the precises that the sizes are okay and that i can do the actual calculation but in this case i'm not doing this um just to keep the example simple and the noise down so when we want to transform this into the rangers version we again need to analyze the loop and here it uh and here it's not enough to just look at the loop because if you would look at the loop you would might you might think that you need to drop the first two elements and the last two elements of the input range and we have views for that we have the drop view which drops the first elements and we have drop last which drops the last elements and how many um you just um you just give to the view um please note that we have drop in the standard library but drop last we don't have in the standard library so if you want to use drop last um you would need a library like range weekly but in this case we actually don't want to drop the elements because you can see in the in the loop body that we are calculating all the elements from the uh from the in from the index so um with ranges we can use a sliding view which does all the work um that we see above but without but without actually copying the values it creates a view over the input range with five elements and it slides this view over once every time we we dealt with the with the current view and then i call transform on the sliding window of five elements and then passing in the mean function and i'm outputting um everything into a vector by calling the ranges 2 vector function so the ranges 2 creates a vector with these transformed elements and again i highlighted here the corresponding elements so for the um so the loop and the the array with the five elements is corresponding to the sliding view of five elements um the mean function will be called in the transform and ranges to vector will create an output vector which corresponds to manually creating the output vector and then returning it the next example is subtract mean so at rosen we use or we work with matrices and 1d to 3d and we're using multiarray for those matrices um in in this example we have a matrix and mean values which are mean values for every column of the matrix and i want to subtract the mean from every from every column of the matrix and i do that by looping over all rows of the matrix and then essentially looping over the column of the matrix and also the column name vector and then subtracting the column mean from the row value and for the and i can also ratify this so for the range version i need to figure out how i want to handle the matrix so if i look at the loop i see that i essentially want to loop over every element of the matrix and in this case i can actually iterate over the matrix flat so there's no need to iterate over the rows first and then the columns to do that i created a span from the multi-array um the span will create a basically a view of the matrix but flat so all the elements of that so this is one v and i call the ranges transform function on this because now um i cannot use the um the transform view because the transform view only accepts one input and it will only transform the range um on the left side of the of the pipe operator but the ranges transform accepts two input ranges so this is why i'm using range's transform here so the first element is the span that i created for my matrix and so if i wouldn't use multi-array if i would use another container i could probably use the join view the join view makes a 2d matrix 1d and a 3d matrix 2d and so on but since this is multi array and it has some implementation details that prevents that i cannot use the join function or the join view so i'm creating a span which does basically the same thing also a span doesn't um copy the values it just creates like a view to those values so it's perfectly fine to use the scan here and the second input range for the transform function is the column meme and i cannot use the column mean as is because it is it is only the amount of elements of one column of the matrix but i want to iterate over every element of the matrix so i'm um i'm fixing that by using the cycle view and the cycle view um what the cycle view does is it um it takes the the vector and if you're at the end of the vector um it will start at the beginning again so it will cycle around the vector every time then i need to say where i want to store my output now i want to store it in the matrix and then the last element for the ranges transform is a lambda and this lambda has two inputs from both of those ranges the first input is the matrix element and the second input is the mean and then i return the matrix element minus mu and the corresponding code lines here are for the nested loop over the matrix i use ranges transform and a spam from the on the matrix to get like a flat view and then i need the um column mean the correct column mean and i'm going to use a cycle view for that so that the column mean vector is repeated over and over again until we reach the end of the matrix and the calculation of the matrix element minus mean is done in the lambda for the transform yeah so this is how i would do this using ranges so the last of the small examples is the a range function and you may already know this function from python because it's essentially the same thing it creates a range with the size of len and the start where you start that you pass into the function and it counts up the step value and in this case again i want to have a vector i initialize the vector with len and start then i put iterate over then i iterate from 0 to len and in this case i actually need the index so i'm going to add um i times step to the output vector which creates the um the range that i actually want and then i return the output so to ratify this um i again have to look at the at the loop and see what the loop does and in this case i actually need the index from the loop um i can do this by using enumerate and enumerate gives you the index to a corresponding range so the corresponding range at this point i i don't really have corresponding range would be the output vector i could make the output vector the same way as i did in the above version here but i'm not going to do this i'm using repeat n for this repeat n is also reveal and it repeats the value that you're passing in length times so the start value will be repeated blend times which is which will create the same thing as the initialization of the output vector but it will do it on the fly because ranges are lazy so um the repeat n will repeat the start value and enumerate will give you the index to that value and then we call transform on the result of enumerate and transform gets passed in a function called next value that gets passed in the step and we want to output everything into a vector so now let's look at the next value function it is a function that returns a lambda and the input of this lambda is the index and the value which is the result of the enumerate function and if you're using views what you're getting here is a triple so you can deconstruct a tuple into the index and value and then calculate what you want to make relate so here i want to add index times step to the start value so the corresponding code lines here are the for loop and the enumerate function and the initialization of the output vector can be done by vp10 and then i'm using transform and the lambda bar to calculate the next value which corresponds to the to the loop body and then to output the result it is the same as creating the salt and then return it so these were the more simple examples but i also prepared a more complex example and this will actually be the last part of the talk so um first i'm going to explain um what the complex example is then we will implement this in a c 17 way um how i would implement it in c 17 and then we move over to ranger fighters so what i want to implement is the so-called hunt method also known as jefferson method or greatest visa method and this is a method that you can use for allocating seeds in parliaments or proportional representation systems and i'm going to show on this example how it works so in this example i have three parties and party one one one hundred and ten votes party two one eighty five volts and party three of one um 35 volts and i have seven seats to allocate so this method will so in this method we will need to count up from one to the number of seats that we have and then divide the votes by these um numbers that we just created so well we begin with one so we divide 110 by one which was 110 then we divided by two then we get 55 and so on we do this for all these tv shows for party one and we do the same for party two and four particle now the next step is to sort these um the results of the division so the biggest number is the 110 then we have 85 and we have 55 and so on and we only have to do this until we have filled up all of our seats and the last part of the algorithm is to count how many seats the path you want so party one won three seats party two one also three seats and party three one one seat so this is the entire algorithm and as i said i first want to implement this in cpr 17. um so first i'm going to create a method for this and i'm deciding on the input and for this i want to have a map as input and the map faults a string and an int the string represents the party and the end the number of votes and then i also need the total number of seats this is all the input that i need for my function so the first step is to calculate those quotients here so what we need to do is first decide on the output that we want to have from this calculation and here i decided that i want to have a vector a vector of pairs and this pair holds a string which holds the party and a double which holds the result of the division there's no need to use a pair i could also use a map or a struct so um there's no need to use a pair but um i just use it here and then i have a for loop starting at one counting up to a total number of seats plus one this is um this is this uh these are the 60 visors so um and and next i'm going to iterate over um every every element of the map and i'm directly going to deconstruct the map so that i have the party and the number of votes deconstructed and to calculate the proportional votes i will [Music] get the number of votes per party and divided by by i which is the seed divisor and i'm going to store everything in the vector of pairs normally i would i would reserve a size for the proportion of votes but i just didn't do it here to save some space next we need to sort this or we need to sort the result to sort the result i'm going to use standard sort on the proportional volts vector and because the vector holds a pair i need to tell the sort function which elements i want to be sorted which i want to be sorted the vector on and here i want to sort the vector on the second element which is the quotient which is the result of the division and then i'm going to resize everything to the number of seats because that is really all what you need next i'm going to count how many seats which part you want and i'm going to do that by using the first i'm going to decide on a output for the function for the overall function and i decided to use a map as well with a string for the party and inch for the number of seats and now i need again to iterate over the input map but this time i really only need the party and not the number of votes anymore but i still deconstruct everything to get those two variables separately and then i use the countif function on the proportional votes vector to count how many times the the party is in the proportional votes vector and this is stored in a pair the party is thought in a pair and it's the first value of the pair and once i have this i'm going to insert the party and the count into the output map and then i return the output map so this is the entire method which if i change the font size a little bit it actually fits on the slide if i would implement this into our production code i would make this into three functions because this is clearly three different blocks so the first block is to calculate the proportional volts the second block is sort and cut and the last block is to count the seats per party and now that we're moving on with range and finding this code i will focus on these three blocks individually i'm also using range v3 to range apply this because i'm using a lot of features that are not in the standard so again with this the hardest part is to know which algorithms you um you can use and then in the end how to use them but i guess that's probably true for all new skills um here again we're going to look at the uh at the for loops so the first for loop creates this these divisors where we have to divide the number of volts by and we can do this by making an integer sequence by calling news ins which will create this sequence for us starting by one and ending by um total number of seats plus one because the end value here is also exclusive like it is on the for loop above next we have a look at the nested for loop so what this nested for loop is actually doing is it is combining all the elements of those seed visors with all the elements of the map and we can actually combine two all elements of one range with all elements of another range by calling cartesian product and cartesian product will do exactly that so this is how it looks like this is the first element of the result of calling cartesian product it holds the first element of the map and the first element of the ctv source and then we and then the next element is the second element of the map and still the first element of the ctv source and then the third element of the map and the first element of the ctb source and if we are going on then we will repeat the elements of the map but now we get the next ctv source and so on and so on so so um as you can see this will create a huge range or a huge view actually of all elements of one range combined with all elements of the other range and this is a new range or a new range view and we can now transform this new range that we've got and calculate what we want to take a link with it and in this case here i created a lambda to calculate the to calculate those quotients and the lambda takes the volts and the dv source as input this is the result of the cartesian product function and i like to deconstruct my tuples so um what i get back from the rangers library in those cases is a tuple and i like to deconstruct it and now i get party and vote which is the pair from the map and i get the divisor and now i'm going to return a new struct that i created in the zippers 17 version i've used a pair but for the c plus plus 20 version i decided that i wanted to use a struct and i'm going to show you why in the next block of code but for now it is doing just the same as the pair is doing so the first element of the struct holds the party name and the second element holds the quotient and i want to store everything in a vector so like i did on with the other examples i want to show you which elements of the one example corresponds to the elements of the other example of the other version so the first loop corresponds to creating an inch view the nested loop corresponds to the cartesian product of both ranges the transform view corresponds to what we do in the nested blue body and i also created a lampa for this because i also think it's it's more readable if the functions that you're calling have good names and so this lambda tells you what it is doing so if you just read that transform line you i i guess you can figure out what the function is doing without looking at the internals of the function so that's the goal actually with the example above um you have no way of knowing um what this is doing you have to analyze the code you have to read the code line and figure out what it is doing so that's why i like to make numbers for um for the transforms because i then can give it a good name and it should be readable by just the name and the output i'm going to create in the superspace 20 version with ranges to a vector and for the c 17 version i created a vector separately um outside of the link um so again as you can see in the zipper 17 version it describes more how it is done and in the zippers 20 version it describes what it is what is done to the code or in the code this may be harder to read in the beginning but i think you can get used to it actually so next is the next part of the function which is sort and cut so now we want to sort the proportional volts in descending order by the by the quotient value in c plus plus 20 i can now use the ranger sort algorithm and i can omit the proportion i can omit the beginning end on the proportional volts and i actually think this may not look like a big change but i think it limits the noise i actually think it looks better and for now i have the same lamp there and i will cut the vector down to number of seats um but next i need to change um the um the the body because i'm not using a pair anymore i'm using a struct and the struct actually has names or the structured actually have nones so in in this case i change second to proportion but i can have this um in a simpler way and i really like this feature in c plus plus 20. you can now use a so-called projection and what it does is that you can now use the standard greater function because in this case we want to sort in descending order and then you can give a third argument to the function which is called a projection and it is actually a member to the um a pointer to the member of the struct and of this tract member that you want the sword to be applied to or the the greater function to be applied to and i really really like this syntax because i think it reads so nicely you know exactly what it is doing you want to sort proportional votes in descending order and you want to sort it by proportion so i really really like this so this would be the c plus 20 way now if you're using the standard library but you can also use range v3 for this and range v3 has a nice little syntax for this as well and this is the height equals operator and what the pi equals operator does it um applies the um the function to the the vector on the left side of the um pi d equals operator and in this case sort isn't a view anymore so everything we saw from range range v3 until now was a view but a sword is in the view a sword is an action and an action will be performed legally but means right away while views will be performed lazily and this sort function you can give the same [Music] the same arguments uh you can give it the standard greater function and then a projection to your uh to the member of the struct that you want to apply the grater to um i have no preference actually in um in using um like the c plus plus 20 way the standard library way or the range v3 way i like both versions here and for now i'm going to omit the resizing of the vector and i'm going to show you a little bit later why i did that so next we're going to the last part of um of the function and i guess this might be the hardest to understand when done with ranges so when we look at the loop here at the at the first loop we will we are again looping over the input map and we deconstruct it into the party and the number of votes but we don't need the number of votes anymore we only need the party and in c plus 20 you can use the view the keys view to only get the keys from the map there's also a corresponding values view if you want to have the values from the map but this is essentially what the first loop is doing it gets all the um the party names and now um i need to i need this counter and i'm going to do that by calling transform on the keys and i have written a function here that meets the proportional votes and the total number of seats as input i'm going to show you in a second what this function here is doing and i defined the output to be a map and ranges 2 is really great you don't have to make a vector like i did here in all the examples um you can also make a map and this is what i'm doing here so i think um what is maybe a little bit harder to understand is that in this case you are performing everything on the input map and only on the keys of the input map and this is actually enough to do all the calculations so let's look at the count seats per party function again i try to choose a good name here so that if you only look at this part of the code you kind of know what the code is doing without looking into the function into the details so count seats per party is returning a lambda and needs as input the proportional votes vector and the total number of seats and what it does it calculates the number of seats this is an extra function and it will return a pair of the party and the party we get from the keys view and the calculator numbers and now we need to look at the calculate number of seeds function and this meets the proportion of votes as input total number of seats and the party name and like in the c plus plus 17 version i use countif but in this case i'm going to use the rangers version of counter the range based version and the input argument or the input range for countif is the proportional volts and i'm only going to take total number of seats elements so take view only gives you the number of elements that you pass in here as a number that's why i didn't cut the proportional volts vector i could have done this um it it actually um makes no difference i think so in this case resizing was no problem at all but i also really wanted to use the take view so that's why i did it this way and countif again needs a lambda and this lambda here has the argument of the proportional votes which is the um which is substract and in this case i'm not going to deconstruct the struct i could do it but i only need the party and i'm comparing the party to the party that i get from the input keys so this is a little bit nested this is maybe a little bit harder to understand but it is doing exactly what the function name is telling you so now when we look at the entire function without the external numbers and functions this is the entire algorithm and i actually think that you can read this really nicely so um we first create the ctv source which is an ins view a view of ins um of of some of the numbers one two number of seats plus one and then i'm going to calculate the proportional volts by creating a cartesian product from um of votes per party which is my input map and the ctv source so now i have like this combined range of every value from this one range and value of the other range and then i'm going to transform this new view by calling a function that is called divide votes by ctv source and i don't need to look into this function to know what the function is doing and in the end i want a vector so when i read this i would understand what these three lines of code is doing and the next line would be to sort the proportional votes um by using the range to free sort and i want to sort in descending order that's what i'm reading from from greater and i want to sort by proportion and lastly for the output i want all the keys of the input map and i'm going to transform them by counting the seeds per party probably on the proportional votes vector because this is what we calculated before and i need the number of seats as input maybe it would uh also be very clear if i would resize the proportion of votes here and don't use them then and don't use the number of seats then as input for the transform um [Music] that actually may be a little bit clearer i don't know and then in the end i'm going to create a map from the output the only thing i'm not seeing here is um the order of the elements of the map but i'm guessing that it would look the same as the input map so the party first and then the amount of seats second so this is how i would do this in the cpus fast 20 way so to sum everything up there are a lot of great talks about ranges out there and there are also many libraries that you can use if you want to use ranges but cannot use the standard library yet or the standard library does not have enough features for your use case um not every range-based code needs to use the pipe syntax you can also use the range-based algorithms which i think are a very very nice addition to the standard library the key to range apply the code is to know the available algorithms and there's no way around it you're going to have to learn your algorithms you're going to have to learn what is available to you but i'm really convinced that um once you get used to this um and once you know your algorithms it actually gets simpler and for the method of finding the right um ranges um to use in your in your code i think it's best to analyze the loops and try to figure out what the loop is doing and what is done in the loop body and then find an algorithm that describes what this loop is doing and a surprising number of times you will find a matching algorithm or range for that in my company we are using a combination of standard ranges and self-written range adapters since the standard library lacks a lot of features and we have a hard time incorporating some other libraries for us so we implement what we need when we need it but also the standard library provides a great framework to write your own views and also we are free to use um ranges in new code and also in existing code when we refactor it which i actually think is really nice so i'm always learning the new features by the way because i'm not just allowed to use them i'm encouraged i'm encouraged to use them thank you very much for your attention please let me know if you have any questions