hello everybody um this will be an interesting talk um i promised my favorite code examples um about c plus 20. um c business 20 is pretty new um every every week we have a new compiler version out of the major compilers um every week i learned something although i have seen all the features right now i hope and so this talk is constantly changing and um so this is a this is a version of november 10th 21 and let's see whether you like what i like so um the talk will roughly talk about only about how to print elements of a rank and but there are so many interesting things to discuss um i think that's enough so let's see where we are we have here um a data structure a coordinate with a three values x y and z value um let's use it well let's initialize an array with some coordinates um since c plus plus 17 we don't have to specify the element type and number if we initialize with the same type and let's sort them and let's print them out okay and how do we print um well let's print it the old way not the c plus plus 20 here's nothing from c plus 20 yet so um let's use the template let's print the elements of the past array iterate over the array and print out the value good so the first thing we can improve with c by plus 20 as you might have heard yet is instead of writing that this is a template for type t you can just write auto by the way it's still a template uh and it still follows the rules of templates for example you have to put it in a header file and then we can switch the sort algorithm so before c plus plus 20 we pass begin and end as usual when we pass ranges so now we can just pass the range as a whole and using a sub-name space called ranges okay so but for sorting we need a way to compare the values in this data structure and what we usually have to implement is the less than operator for that or we need to sorting criterion for um to pass to sort as an argument well we have something new here you might have also heard about this that's the spaceship operator and the spatial operator um is responsible for the comparison operations well at least for four of them but if you uh declared with equals default um even for all six of them so by that you enable comparing coordinates um with um all the six comparison operators checking for equality and relations and ordering and it uses by the way the members x y and that in that order so we sort according to x as a first criterion then to y and then to z and this will also support cons expert and no accept and type conversions so that's all you have to do and then of course we need some output support because we print all the elements and the elements are called innate so we need an output operator oh an output operator you still have to implement the usual way which in this time as um using a hidden front so a friend function inside a class or data structure and so we want to print it out that way so how do we do that um okay we could print out um x y and z coordinates and it stream them out to the output stream and then stream out the slash in between but we have something new and something new we can use here and that's format sdd format um as a library for output formatting so that we can specify field width alignments etc and let's use it just that way that's pretty simple print out the three values as passed here as additional parameters with a slash inside and here we could do a lot of alignment tricks which i didn't use here yet okay so um in a minute i have to organize my screens a little bit and that's how so what else can we do well this print function does support rangeless um and but in the declaration according to the declaration it can take everything so we can restrict that by saying okay um let's use only ranges here ranges where we can read values from and for that we have concepts standard concepts so that are constraints about template parameters remember auto is here just a template parameter a generic parameter and this is a so-called type constraint so we constrained the parameter here that you can only pass input ranges so if you're passing in um a good compiler might say oh that does not fulfill the requirement that the argument should be an input range good okay oh um let's skip the first coordinate by the way um that's another thing we have with c plus 20. so um let's skip the first element oh that's easy take the array and drop the first element well what we create here is not a new container let's just skip the first element by iterating over the elements so we um have here a mechanism of lazy evaluation we create a view a view refers to the original array that says well if you want to iterate over my elements skip the first one and so the moment print starts in this range base for loop to say okay let's iterate over the elements the first begin goes to drop drop goes to the array and says give me the first element and then rob says oh no i give you the second element because i want to drop the first one and then so uh from this point of view this view gives you as a first element the second element in the array and that that means we print uh not the first element which would be 0 0 2 here of this array okay so these are all uh cool things you might have seen already um coming from c plus 20 um range support you can use ranges as a whole you can um type rangeless interviews uh so to filter their mouths etc you can put constraints etc you can use auto instead of template parameters so things like that and and to print out your format to define the comparison operators you have the spaceship operator so but let's look into a little bit more interesting examples so first of all as usual in c plus plus not everything works as smooth as it looks like so if i take this program you just saw remember let's print all the points drop the first one well after they have been sorted and let's use this print here oh let's let's use a filter instead so instead of dropping the elements yet let's use a filter but a filter um is um a predicate well and in contrast to drop it well it looks to each and every element and says oh i pass this through if you ask me for the next element i give it to you or i reject it so this filter is a little bit trivial it says yeah i i accept all the elements i always return true but here that would be your condition what elements should be filtered out or what elements should be filtered through but there's a problem now this code no longer compiles there's a compile time error what the hell is going on here well there's a problem and the problem is the following we have here a print statement that takes a const reference to whatever we pass and there's a problem with some views because some views have a state and that means while you iterate over the elements they modify their internal data and filter is one of them so if to iterate over a filter the view can't be caused but we made a const here so therefore this code will not compile anymore that has interesting and dramatic consequences i think for c plus as a whole so here you see um some filters work like drop work but others don't work some not always work when there are cons for example for drop dust drop it worked because we were iterating over an array but if we would iterate over a list it would not work to pass it as a cons by const reference here so in general not all views support iterating of the elements when they are const some always some sometimes and for that we have to change this code we have to say okay uh let's not make the parameter const well we could pass it by value if it's a view it's cheap a cheapest view is cheap to pass so this is a view we pass finally a view to this array but we might also want to use this print for ordinary containers ranges which are expensive to copy and as a consequence we should not pass by value at least not in this case so um there's a solution for that we have a type that says um let me pass something by reference without becoming cons and a reference that can refer to everything and because a non-cons reference cannot refer to temporary objects that's a universal or forwarding reference um it's usually it was introduced for perfect forwarding but more and more it turns out that we need the other flavor of this reference which is to universally refer to something uh by keeping all its um attributes so not being cons is one important point here so therefore i i tend more to come back with the old term we had universal reference because forwarding reference uh sounds like we are using forwarding here which we don't use here we don't use std forward here it's just a universal reference and there are two ways to do that you have to use a template parameter with two ampersand or two ampersand with alto in this syntax so yeah and we can still qualify it has to be an input range so with this declaration everything works fine again and you can of course apply more interesting filters here good so good things and bad things happen when you apply and use um c plus plus 20 and the features of c plus plus 20. let's improve the whole stuff a little bit look at this oh look at this here this is a range so what is a range a range is something um we can say that as well historically defined by begin and end and begin and then usually are iterators well raw arrays are supported um by using um pointers as iterators which provide the same api and therefore can be used as iterators but there was one interesting restriction we had before c bus plus in almost all places in c plus plus which is um begin at the end of such an iterator had to have the same type so a begin and an end iterator had to have the same time but there are nice applications if this is not the case if the end has a different type than the beginning here's one look at this i want to iterate over these points and my end is just a specific value not an iterator at all it's something i can use a little bit like an iterator but yeah let me let me define a range that goes from begin to this value this should be the end and [Music] let's define it as a template parameter and of course this is a type this is a declaration this is the end value of and the value is initialized with this um value that's a template parameter that's a fixed end value we are using here so this means let's iterate for all points until we come to this end how can we um implement such an n value people have done that before c sub 20 and you can for example do something like this here's a data structure and value that's my type it's templified by the value the value that defines the end and then um what else do we need um to deal with that well let me first say that there's a terminology a new term introduced with c plus 20 which is the end iterator in general is called now a sentinel so we always iterate with iterators um until the sentinel which is a synonym for end iterator but may have a different type and that could be used like such a sentinel so um how do we define and implement this sentinel type well that's all that's all you need you need nothing else um what we define here is let's compare my value with an iterator that's here the argument is just some iterator and yes we have the end value if we compare with an iterator we have the end value if where the iterator points to has the same value as the initial value passed to here now remember how this range base folder works so first of all there's a remarkable thing that is the range-based for loop already supports beginner and having different types that was introduced by sequels 17 by the way and so but internally please note that the internally the loop here initializes an iterator and says i'm iterating until i am at the end so why i'm not at the end so some code here internally is why my internal iterator is not at the end now what is the end the end is this the end is this object this object has an equal operator and here we see another feature of the new um spaceship operator and all the technology around it um we have new support to rewrite comparisons so we have defined how to compare an end value as first operand with something else as second operand this is comparing not not equal and the order of the elements is different but there's a new rule that now um this can be used because if the compiler cannot compile this it will come use this instead and try this instead so it tries is there instead of a nautical operator is an equal operator defined yes we have it and and is it even defined for the opposite order of the operands yes and then we negate the result and that works so therefore this is enough to make this work and what we do here is we create simply an object a range a ring starting with the begin and ending with this element yes obvious questions will be what happens if i don't have such an element yes we will iterate forever so that's uh you should only do that if you know that this element is inside um but there are other ways to do that we could for example here pass as a runtime argument um the array and also here compare the iterator with the end of this array and with this value so whichever comes first um that's that's not a big thing to implement then in addition okay here's another remarkable thing i don't know if you see that we use here auto we use a template parameter the template parameter is a value this is a non-type template parameter so what is the type of this well it's a literal type it's a data structure and that's new now we have a lot more support for um non-type template parameters now in c plus plus 20. in fact that if you have a template generically templified for a specific value the value can now also be a floating point value and a literal type like here which includes that you might be able to have support for string literals and um that does yes lambdas could also be template parameters now because um yeah they are they can be literal types they can be data scratches and that works i have some examples in my book about that i have not yet a very useful example to use a lambda as a template parameter but um i'm pretty sure we will find a lot okay so how many features are on this slide okay uh concepts standard concepts nttp parameters um rewriting of the equality operator um the spaceship operator scd format um ranges take um ranges as a whole so passing ranges as a whole instead of begin and end um helper types and views like sub range um drop you have seen filter you have seen these are all views of temporary created views here here the viewers let's um define the range from to this array up to this value that's my first example oh oh we have something else the chrono library was extended oh we should try this with craw well something like this okay uh let's take again my print function i accept an input range um arbitrary input grade not making it const so i can read elements from that of any type let's pass something different let's pass an array of dates could um the chrono library extension for c plus 20 now supports um calendar types a lot of calendar types very type safe with interesting behavior you might have seen the keynote by howard i don't know three years ago or so um here you see some ways to define such a date so this is a today the 10th of november 2021 um there are other ways to define the date this all could be variables not only constants and please note that we here create use an operator already so we create here an object of type day then we use this operator to combine it with a month the result is an object of type month date and then we combine it with a year with this operator and the result is a object of type uh year month day and that's also here it's just that the order is different to support the three major formats we have so we can start with a year then the next is always the month or we can start with a month and we have predefined um values for the common month we have slow like november 1st 2021. and um so i see uh you can ask questions at q a i from time to time i look there um but uh i might most of things answer at the end but so unless it's just a direct question for the understanding so let's take the dates let's sort them and print them out okay now we know these are dates okay well let's iterate over the dates which are days all this oh let's print them out that's new that would not compile in c plus 17 we have now an default output operator for every duration and time point and other chronotypes so by default you can always see something you don't have to add units whatsoever so it's it's like this this is a day we print out uh the usual format we have an id which is with the slashes um for all the other dates by the way we use slashes but here this is very common in it as a default value yes you can change that with the format commando come on oh i don't like mondays that's a song you might know that so if the weekday um of this day is a monday let's print that out oh that's a monday that start um let's schedule meetings okay um take this as a local date type um plus so we have a day here and then we have now um to um add 12 hours to that so now we have a date combined with an hour and that's some type that works some time type that works fine okay let's um apply to the current time zone that's a time point associated with the time zone and then let's iterate over some other time zones like europe berlin and america la and print out um the meeting dates so like here um printout well here you see format again the format library the format library um supports extensions for user specified types we have [Music] done that for the chrono library so you see here this the format that is supported here says oh let's take here um the next value the next parameter and here are some formatters meaning here and this in this in this scenario um the the day in this format and the time and the time zone at the abbreviated time zone here which might look a little bit different depending on your local machine maybe gmt minus eight may make maybe um your really your time zone and a depends a little bit on the platform yeah okay good so we have um support uh and all the support you have seen now of course also for um [Music] the new chronotypes um yeah works fine and then i thought about this example and then oh wait a minute let's look at the example i had and can i use this at compile time how much can i use at compile time so look at this this is a compile-time defined array some values and for some reason i have to merge some other values as you see the other values are also known at compile time so think about this as a framework uh there's user code there's framework code they have their values the framework either has other values whatsoever and so all are known at compile time but in very very different locations of the source code okay so how would we implement a function that merges um these two values 42 and four and that's a very added number of arguments we could take here pass here to this array and then come up with a resulting range that we can use in master print and do all the funny stuff we have seen before well okay um much the value um let's see later what the return type is a traditional way would be to take a template uh so template parameter for the for the the collection be causing and then an arbitrary number of values we um use various templates here so these are multiple types and multiple values of these multiple types and to support move semantics we use two ampersands so we have used universal or forwarding references um so just in case well here we have end we don't need move support but you never know so let's initialize a vector with this with these elements a vector um declared with the value type of these aligns and then initialized with begin and end so you might say this is some of these things are not necessarily necessary but be careful if you use class template argument deduction here and you don't specify the type um here you would have two elements which are two iterators um so you have to specify the type or the other option would be in this case to use um parenthesis instead of curly braces one of the nasty areas in c plus plus where we have different behavior uh whether we use for initialization parenthesis or braces but that's a different story so let's initialize a vector with all these elements and the elements are use the value type of the the past container type elements the value type of the container here are as you probably have learned the hard way is because all your compilers tell you is um let's use type name here because this is a member type member of this parameter so now let's merge all these values i don't know how how good you are with cpr 17 that's a that's a fold expression so this is a commando as a comma separated list of statements called pushback for all the past values so that way we call pushback for all the past values using move semantics so we forward the unminds into the collection well let's sort them okay and let's return the collection so what we have done um whatever you gave me in um internally i create a vector initially with these elements and then i um added 42 and four sorted all the elements and print out the elements and yes that works if you iterate all the elements you see this result that is yeah that is code that works okay a few things about this so first of all this is um so far called not using anything of c plus plus 20 again so how can we improve it and so let's go through it step by step so first of all this this type name is no longer necessary let's skip it um that's um in a lot of places where it's obvious that the type name is a type that the type member is that the member is a type and you can skip it there are some special rules where this is not possible um yeah so it's a little bit funny because finally in visual c plus they really require the type name and now it's no longer necessary um but okay so that's possible good um then um we can hear the sort uh let's apply the usual things we have seen in the code before okay look here saw let's use a sword for just sort all the elements in the vector the range of salt and let's here instead of taking template parameters with the name let's use auto here so cons auto reference for the range and to have perfect forwarding and move semantics universal or forwarding references for the past arguments the values you want to copy or move into the collection without to to ampersand and then dot dot to signal we have multiple elements of that once again this code is equivalent to this it is still a template it follows the same rules um the difference is that um we have no specific name for the types anymore that means um instead of using the type we have to use deco type of rg or here decal type of valves um whenever we need the type of these elements are on the template parameter of these elements we don't have a name for that um so we use decal type here that's interesting because that means um that in this case i would probably prefer not to use alto here i would probably still use that one because i need these two names t and rx um so that would be my code okay so the only improvement we have now is a use rangeless song so let's change the declaration here look at this we have an std array initialized but now let's switch to a raw array and the code suddenly no longer compiles so this code is not as generic as it could be um yeah so can we improve that yes because in cbs 20 we have a lot of support to program ranges not only to call algorithms for rangers and have something we have a lot of support to implement code generic code for ranges and so what do we have to modify so that this compiles well we have to declare it like that a week well there as usual in c plus there are many ways to do something but this is one way to do it so this is um let's pass ranges begin and range is n look at that here we call a member function of course the null array has no member function beginner there here we use ranges begin arranges end of this range and that's what we call a customization point object that's um an object by the way that's that's no longer a function and this supports all ranges and views and it has no adl issues why do i have to say that because there's also an std begin and see the end but they have problems in some situations so um we fixed um we fixed these problems with these new helper utilities in the rangeless library so please prefer them over std begin and svn there are even more things fixed for example we have const issues uh with c begin and c n uh constants is partially broken well or not no longer propagated for views um so that c beginner and c end is broken in c plus plus 20 and we will fix that with c plus 23 unfortunately only uh yesterday there was a vote to put it in the fix and but this fix will only apply to scp ranges c begin and suv ranges cn not to std begin and scdn so please prefer these in range of specific helper functions to deal with generic code dealing with ranges and here you see another helper that is uh in ranges give me the value type of the range that is programmed in a way that you also can use raw arrays there which don't have a member value type okay um by the way this is not perfect you should improve this because this requires um because we initialize a vector this requires that begin and end have the same type there's a problem with the traditional con compilers and containers that they require begin and end to have the same type and if you initialize them with a range and to do that um and and you've seen one example where we had different types uh remember the sentinel and value we used this would not compile here but there's a way to come with that you could create a user helper view it's called common you can pass through this view to iterators and they harmonize the iterators give them a common type and then this code will compile i don't have an example for that because otherwise i would have need one or more to start the talk um yeah but um you will find um examples in the book how to do that so that way uh we would even support in this match value algorithm iterator and sentinel ranges so and now i have said wait a minute everything is known at compile time so can we somehow compute everything at compile time okay const express is the way to say that though oh let me compile this at compile time let me try to compile the z compiler surprisingly this code works although we need a vector um because a vector now has a couple of com cons expert support almost all functions have that and but but here we [Music] return the vector we create a vector and we return it and here it is used at runtime so here are the news um you can use now vectors at compile time but you can't use a compile-time vector at runtime okay so we have support in fact um for memory allocation which vectors use and by the way we also have compile time strings now but you cannot propagate these strings and vectors to run time so if i try this code works because finally here at runtime we um make this call and um we create a vector if i would say here a cons expert in front here this would not compile well we have we also have a new keyboard the new keyboard says um it's not optional whether we do it at compile time or at runtime let's only allow to do it at compile time that's called const eval and const eval um says um this is a compiled time only function and yes this function is fine it works it compiles this is a valid compile time only function let's initialize a vector let's push back some elements let's solve them let's return the background that's okay the only problem is 10. now we are required to compile this at compile time and then we want to use the result as runtime and that's not supported so what could we do well first of all as a proof that this in principle works look at this if we would just compute the resulting size of the vector and then take the return value here and this is not just the vector we return just its size that would compile and work fine so but um of course i was thinking i want to have i want to merge all these values at compile time creating no runtime um computing at all well we can't propagate a vector but we can propagate an array so we couldn't and compile time take the vector initialize an array now the question is what is the size of the array um well it's a the size of uh the range the given range plus the number of additional parameters so that's that's the resulting array please notice we use here s size that's sign size that gives you the size as a signed value to get rid of these strange warnings that we compare signed values with unsight size values um it's also new so let's copy now all the elements from the vector into this array and return this array and that is go that works that compiles this code compiles the only compiler you can try it out now is visual cpus plus but it works this is working code and um yeah this is the output so we have it's guaranteed that this call is done at compile time initializing this value it could be constant expo here also and yeah we have initialized an array with the values of the original arrays um merge with 42 and 4 and sorted good a few hints here first of all you might say can i initialize the array here with the size of the vector well that's not supported ah i'm sorry before i come to that um again now um as we use now compile time computing only let's get rid of all the move semantics and and for perfect forwarding because we only have values and it's all computed at compile time so um we can simplify code like this now because at compile time it doesn't matter this has no impact on the runtime of the program so and now we come to the problem can i use the size of the vector to initialize its array no you can't that's interesting we have a different a difference between compile time values and compile time runtime values so this is a compile time value size of the number of the additional elements and vectors and areas need a compile-time value here and so what you have to pass here is something known at compile time unfortunately the size of the vector is not known at compile time although this code is only used at compile time we don't have support for that yet we could but um we were very very we were very late with this feature and we were a little bit careful so this will not work this will also not work so you could say okay um let's here let's initialize a value here um because here now you the compiler will say but this is not a compile time value although it's computed at compile time you see the point so that's a little bit of an unfortunate restriction to this code so i thought a little bit can we do it can we do it somehow can we somehow return um and use the resulting size of the vector and return it to the caller here at compile time well yes here's a trick and maybe there are better tricks this is just where i was right now 10 minutes before i started the talk and so let's um compute here uh with cons expert the the size we want to have so that's it which is um the size of the given range and the additional values that's a maximum size so let's initialize an array with the maximum size we could have which is the number of elements in this area plus the number of additional values we passed to this then in this case now uh let me reuse let me remove duplicates here so just that we see that we cannot we not necessarily return a vector that has just this sum as a resulting size because here this 4 this 4 here is twice then and we only want to have them once so it would mean that depending on the values we merge uh we have a different size which we return so unique copy data this is the unique copy version of ranges passing the range and the begin of where we copy the values while we removing consecutive duplicates and now let's return two things two things the array and the size and the size is um here um the unique copy gives us uh indirectly the position of the end and we have to deduce the position of begin and so that that way we have the size so this returns array and its size as a pair so what we get here is not just a collection it's an array and a size because the array might be too big because we have removed duplicates at the end so what can we do well use a view we have so many views so here's one view one view is um give me the begin of some range and a number counted does it for us and by the way count is implemented in a way that it creates a different type if the elements are in continuous memory than if they are not so um so that means counted gives you the best performing run time thing you can use here so counted takes um the begin of the array so that's in the pair the first element and here the second element is the size yeah i should probably use here uh in the next version um structured bindings to have better names for my elements in the pair but i hope you see the point and voila this is the result this is we have a compile time collection this collection is passed to a compile time function initializing a vector and dealing with that not knowing what is the resulting size because we assault and we remove duplicates but what we can return we cannot return a connection with that size because the resulting size is a run time value known at compile time and for the size we would need a compile time value and we can't propagate a vector to runtime but we can use this error trick with a size so we have the area and say but only the first n elements are valid or should be used in this area and that is the way you can use it right now so we now have here um the array by the way has 10 elements one two three four five six seven eight nine about the or nine no yeah nine i think and the first we have twice but um because we initialized this range this view um we can use that and now we can here use our print function that deals with the elements and yeah i could put together everything and say oh and these elements are chrono types because chrono types are compile time types if the values are known at compile time and that would also work but that's something i give you as an exercise ah by the way if you do that and try it out don't forget these two empty curly braces well if this is code that compiles with visual c plus uh the latest version by the way it does not compile with the c plus plus 20 flat you have to use a c blaster's latest flag um and if you don't do that you return from compile time to runtime some value is not initialized properly in this area and that is at least an error with with a c bus bus not sure about whether this is an error according to the standard or not but it's a good error in any case so please don't forget to pass um empty curly braces here so that this all the elements in this area are guaranteed initialized because we pass them to the runtime that's it so as i told you just printing some elements maybe we compute them at compile time and you have seen a lot of different features here in this talk i think not all we have a lot more but we have seen that so that's it hope you enjoy and let me now go through um [Music] let me go through the questions you have okay so the first question is um yeah so should i continue yes i give you assistance if you need thanks for the talk okay so where does it where does it get the current zone from in chrono okay let me go to the chrono slide well um current zone um is um supported by the operating system so you need support for this library you need obviously you need um support by the operating system so uh to detect what is the current zone also the operating system has to have um the ana time zone database to know which time zones are supported you can't use here any combination that's pre-fine combinations so you can't use europe munich i think that that's not a valid option um so these are the the official names in the so-called iana time zone database which are supported and we have an api for that so we either require that um the operating system has a current version including offsets of time zones etc but we even have um support that these time zone databases could be updated in case i don't know some country decides that that's daylight saving time or summer time as we say somewhere in europe it's changed a little bit uh um things like that happen usually they happen with the operating system update but we have in c plus full support uh so we could even run c bus bus programs 30 years including updates for time zones that's that's there okay so slide 20 or 21. does decotype rg not give a constraint type which won't have a value type member 2021 you might be right and i didn't try it out wait a minute um range is a reference i have to check that yeah you might be right um thanks so in that case the code would become even more complicated um so that we had to say um remove cvr from this rg parameter on slide 19 you speak of compile time vector i thought compile time dynamic memory allocation is only permitted if it's dedicated without leaving the time context but you never call in a compile-time context i think that was uh answered later or i think yeah um i think i answered that i think so in which case would you prefer to call the printing logic directly into an operator less than instead of using formatter which is the customization point for stood format okay let's hear when we had uh introduced here um the output operator for this type yes there's another alternative we could say um we define and formatter for our own type that's pretty straightforward pretty easy to do um the simple things you can do you have just need a helper function create a string um out of this data and then pass it as a so-called formatter to format and then you have support and we could just call format for a coordinate c um when should you do that why not i don't know if you need it often as usual if you need it often then if you have an obvious implementation so those who design this data structure might come up with a standard formatter to do that um yes i would see we i i support for more and more types we will see that in future um depending on the success of format um but i use it already a lot and i really i really um wait eagerly that um gcc does support format and fought it unfortunately it doesn't do it yet and um because it's so much easier to print data around with uh field width etc so yeah i have no clearance on that um if it's worth it if it's worth it it depends converting answers always it depends yeah could you please publish the code yes i will do um i will tweet it and i will publish two examples or three of this code yes please look at my twitter account i will yes of course this is nice to do so i you will you will try you will see the example with the runtime computing you will see um at least the final example with um with card and maybe we had two other interesting versions please um look at my twitter account i think nico you can take the last two questions that are new and then we you we can move to the lounge we we have a room for you is called track c so is the q a truck c in the lounge and but we have two two last questions here appearing in the q a what's a real example where the complexity of writing something like the compile time list method is worth the reduced runtime i have no idea we are discussing that so the reason we have compile time computing for vectors is we are preparing reflection we are we are preparing reflection which will come with c plus sooner or later um and reflecting means that at compile time we create containers um which lists for example the members of a data structure and the names and the members of the parameters etc and we decided that we want to use vectors there instead of creating our own internal compiler specific helper type and so that that's why we have this technology um as well i think this the example i gave you is as close as as it could be i mean uh think about some more complicated computation my usual example of compile-time computing is hash values hash compute hash values at compile time and so there are some things you can do at compile time but um yeah some maybe sometimes people think too much about it yeah but um yeah let's see we will find out also here and [Music] the last one nico is because basically you are sorting the questions from the recent ones you can you can answer it you can answer but we get then we we move to the lounge yeah is it possible for future versions to allow compiler makers to be transferred to runtime yeah we are discussing that the problem is um the problem is simple um a compile-time vector type might not be a runtime vector type because the runtime vector type is part of the library now if you exchange the library you have a different type for vectors and strings than the type you had at compile time that's our major problem there and um i i have no idea where where the clarification and discussion is about this issue that's it thank you very much i don't know yeah good now to the launch and the the name of the the table is q a truck c so other people can can follow up with you and uh okay so thanks a lot thanks nico thanks everyone enjoy the rest of the conference and see you these days cheers thank you bye