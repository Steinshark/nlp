i thought we'd have a little look at a neat little algorithm that actually is super super popular and that's iterative closest point so the icp algorithm is used all the time to align point clouds either in two dimensions three dimensions or maybe even more right depending on what you're doing so for example if you're using a robot and you're examining a scene and you've got lidar you're going to be finding lots and lots of data points saying this is a surface over here and it's this far away and the question is if you're driving along and you're capturing this lidar repeatedly you've got to try and put all these point clouds together into a bigger one that represents your whole the whole space that you're in and the question is how do we actually align lots of sets of points like this so i've done a slightly smaller scale version here right you've got to imagine this is millions and millions of points repeatedly at i don't know multiple times a second from some expensive laser scanner now i have don't have an expensive laser scanner nor is this 3d but if the exact same principles apply iterative closest point is also used for things like image stitching and can be used for lots of different things so you know it's very very common essentially this is the problem right so what we've done we've i mean i've drawn some points on here right these are in two dimensions and i'm just going to copy these points over here to pretend that what i've done is captured a second sample of these points at some later time but between those two times maybe i've moved or the camera's moved or the object has moved and so maybe my points are sitting over here or something like this right now i'm using this kind of baking paper as my best effort of obtaining some sort of tracing paper is this your um audition for number five yeah yeah i mean we'll see how it goes right it's it's partially partially seafood that was what i went with um i considered making my own tracing paper but it looked really messy this is our sort of reference cloud so this is some amount of points that we scanned ahead of time let's say in the previous lidar scan or earlier when we did a laser scan of an object right it's quite common for example in films you know you might build a masking or an object you want to to animate in three dimensions using like clay using an artist or something like this and then maybe you laser scan this to get a nice mesh it's the idea so anyway you've got some points and we've now captured some other points over sitting over here right now these look like the same points but and to me it's pretty obvious you just go like this right but humans are quite good good at this problem um we're good at pattern recognition the question is if you're a computer how do you do this how do you work out what the correct rotation and the correct translation is so that you can intersect these points as close as possible some points might be missing there might be too many points things like this and the other issue you've got is you have to do it really really quickly right because if you do a brute force search of all the possible rotations and all the possible translations you will eventually stumble upon this but it could take you hundreds of thousands of years so that that isn't going to help you when you're trying to reconstruct your lidar scan you know in real time as you drive through a scene or something like this so what we're going to do well let's what's the problem we're trying to solve for each of these points we want to find the point that sits on this cloud which we don't know and then we want to minimize the distance from that point so for example if we had a pair between this point and this point then quite simply we want to minimize the euclidean distance between these two so pythagoras essentially so he's going to do that right and for one point that's not so difficult right even for two points you can kind of just sort of you can just sort of do that the problem is that in this situation we don't have this correspondence we don't know that this point goes with this point and this point goes with this point right i only know them because i just drew them out and there's not very many points right for millions of points i'm going to struggle too so the question is what do we do iterative closest point the word iterative means you know we iterate this number of times the idea is that we first try and find the best possible combination of matches or correspondences between these points and then given those correspondences we try and optimize the translation and rotation and that will be okay and then we will repeat that process and we'll try it again that's the idea so let's have a go i just literally drew these at random so i have no idea if this is a good example or not but we'll try it let's imagine this is where my points are now of course if i move this around this is all going to go wrong so the closest point to this one is is this and the closest point to this is probably also this and maybe this in fact quite a lot of them connect to this point which is not ideal let's just for the sake of being a little bit more interesting say that these two connect over here right so something like that what we do now is that we ignore all these points because these points essentially what we're saying in this situation is that they're not anything to do with this mesh maybe this has got a million points and we've only taken a small extra scan we're just adding in some more points so what we can now do is calculate the center of mass of these two points which is here and the center of mass of these points which is here and we can put them in the same place right and then we can rotate this so that the distances of each of these points to the originals is minimized so these ones remember go to this one so we can try and sort of rotate it so that it's sort of there right something like this and that's our first iteration now it's clear to me having done this that my drawing lines on doesn't make any sense because now i can't move the lines we're going to have to pretend the lines are gone wipe them off will it wipe off that paper no it's a sharpie no no no it's fine it's fine um yeah we we people can see what i'm doing right so let's and then what we're going to do is we're going to iterate this process so we're going to do the correspondence problem again so actually this one now goes to here this one goes to here let's say there there there and there and then what we do is we repeat this process so we can say okay so given the center of mass of these points that we've matched to and our new points we can kind of move it over here and then maybe we adjust the rotation a little bit as well and then we reassign some points and we move it over here and we adjust the rotation and we reassign and we repeat this process for some number of iterations but slowly moves these points towards one another right that's the idea so it's actually a super straightforward algorithm and eventually what hopefully happens is you kind of get the right correspondences and once you've got the right correspondences your translation and your rotation should solve it to put these exactly where they're supposed to be there's a few caveats here right i've gone from here all the way over to here that is not guaranteed with iterative closest point because if your correspondences are completely bogus then your movement is going to be super bogus and you're just not going to find anything good you know maybe we end up settling on what we call a local minimum where visa getting corresponded with these points here and you just never get anything better than this and it just sits there and finishes the other for example if this was upside down and they're back to front it might kind of do this and it's kind of pretty close but it's not going to be able to completely flip it around necessarily and solve that problem right so there's a lot more to iterative closest point if you read the literature on it because there's lots of other strategies you could use so for example imagine that this is only a very small point cloud because again we've captured some extra scan and it represents some small part of some object and this is a huge point cloud that we've been reconstructing over many iterations what we might want to do is ignore most of these points that are too far away you know so if we start over here and there's a bunch of stuff here maybe we want to ignore it because it's too far away from where we're aiming for and try and pull it in the right direction there are other ways you can calculate correspondences but basically all of these approaches are aiming to shorten the number of steps it took to solve this problem i mean if i go back i could actually use my lines how clever um right so this was where i wasn't originally right um and it was what it was about one two it's about one you know two three it was about four or five iterations bearing in mind that there's nothing accurate about what i just did but about four or five iterations got us from over here to here which is pretty nice that's going to be much much quicker than trying to do some kind of massive brute force search of all pairs of points from here to here which is going to be you know n squared it's going to be huge um and this is not a normal a number of points returned by a lidar scanner 100 you know thousands multiple times a second you know at 60 hertz or something like this right we're talking a lot of points so most of the research on this is about trying to first of all find iterative closest point approaches that solve even when your initial estimate is rubbish right and also converge very quickly so in this case i came up with an initial estimate of here you know if i just got given this over here i can't this is this is less likely to work so i needed to find something that was sufficiently close so you need kind of almost like a head start because if that was up here near all those points we've ignored then you've got no chance yeah that's right and and actually what happens in practice you might imagine is you you manually start this process so you say i mean not for automatic lidar but suppose you're stitching meshes for 3d reconstruction you might say well i've got these i think it's about there and that that will converge extremely quickly you know and one way you can do this is where we have actual corresponding points so we could say this is point a and this is also point a and this is point b and this is point b and just for a few points you can immediately get some kind of initial transformation which can then be you know adjusted right assuming maybe i clicked on slightly the wrong point or something like that how do you work out what the best kind of translation and rotation is well without correspondences between these points that's very very difficult which is i guess the whole point of the algorithm once you know that let's say this point goes with this one and this one goes with this one and so on then actually it's it's pretty simple matrix matrix maths so first of all you can just calculate the difference between the centers and translate them like that that's that's fairly straightforward and then you can do what we call singular value decomposition which is basically a way of working out in one step what the optimal rotation would be but will minimize these distances so this isn't this is you know a known mathematical process it takes a little bit of time the more the more points you have so if you have millions of points against millions of points you wouldn't do that you would sub-sample some of the points and do smaller amounts of overlap in fact we can demo this now and i can show you this process all right so we'll get the laptop out and we'll have a look now i've downloaded something called the stanford bunny are you familiar with this the stamford bunny no you've probably never heard it's probably the most famous 3d model you know you might not have heard of but it's it's it's a it's a bunny rabbit a ceramic bunny rabbit that was scanned i think in the 90s or early 2000s i can't remember i should know exactly when it scan very very commonly used in computer vision to um fantastic to test reconstruction stitching you know up shading anything graphical you can use a stanford bunny as a kind of baseline mesh model there's a number of these from this repository the bunny's perhaps the most common all right so i've installed mesh lab now you have to forgive me because it's been some years since i've used mesh lab it's coming back to me slowly but i mean there's buttons in different places i think since last time so i've downloaded the bunny and i've cleaned it up a bit because this actually this bunny was actually computed by a laser scanner and the thing that laser scanners produce just like in our last video is a depth map it's a very accurate depth map but you can't see behind things so what you've got is a lot of halves and bits of bunny that just don't fit over each other at all so for example if i load all these in you can see that what we've got is just an absolute mess of of bunny all facing in different directions and it's not quite clear what we do so the first thing to do perhaps is hide some of these meshes so we can see a little bit better i'm going to zoom in i've got this mouse which should if i press this button magically connect to this laptop much easier to use with a mouse so i'll hide some of these and let's just look at two of these meshes okay so we've got two messages which we've got two meshes which is a hard word to say lots of times quickly and they kind of align you can see there's this beside a bunny rabbit head here side of bunny rabbit head and what we're going to do is we're going to stitch these using iterative closest points so i'm going to press the align button i'm making you know to be fair not that much effort right someone actually already stitched the bunny which is the model everyone actually uses i'm only looking at these two you can see them in different colors and what the first thing i'm going to do is do that key point localization just to say it's roughly here right and it won't be brilliant but it'll be okay so i'm going to go in i'm going to i'm going to i'm going to pick this first bunny as our reference that's the one that's going to be static and then the other one is going to move towards it at least that's the hope so i'm going to glue that mesh here and a little star means that it's fixed now the next one i'm going to select this one and i'm going to say point-based gluing and now i've got a new window up which shows both meshes and i can kind of click on so i can double click on this eye here and that eye here and maybe the top of the ear and the top of that ear and that's roughly the same place i mean i don't need to be super accurate it's not quite clear how i do the front of his face i'm going to sort of click there that's about right and then maybe a bit of tail i mean i'm literally making this up as i go along you need about four points and then you can quite easily calculate the rotation and translation matrix that will get you a little bit of a way towards this uh so let's go right that is not actually that bad you can see but it's not if i zoom in you can see it's not really aligned right there's a few bits missing and the ears are a little bit off actually i'm quite pleased with that this is a bit off anyway what we can now do is we can use iterative closest point to very quickly just go and just just just tidy that last bit up which is of course what you want to do if you were putting this into any kind of um serious graphics or anything like this so all i need to do is press process now this automatically runs until some minimum error is reached i'm going to change it to maximum iterations of one just so we can see it happening rather than just going ta-da so it's like step through it sort of thing that's right so i'm going to click process and it's just going to run one iteration where it corresponds points to the nearest points moves them a little bit and then stops right and what we'll do is click that and it did something right you might have to zoom in zoom in to see what it did you can see there's a little gap here i'm going to click process a few times and it's sort of moving in the right direction and you can see it doesn't go back quickly because it's correspondence problem there's a lot of points here it's a bit noisy but it's actually working pretty well and i'd say that they're pretty well aligned now um at least good enough for this demonstration let's have a look at another one of these models so if i if this has now been fixed if i unhide this one this is the other side of the bunny i'm not sure i've got enough corresponding points between these two so i might try what about that one yeah that's got some some some bunny head on it it's all very scientific and exact what i'm doing here so again we'll just go back to uh click on this do some point blaze gluing so um i don't know i mean something up something about i'm i'm not sure these are aligned because um there may not be enough points in common but i think probably so yeah okay actually well there we go so there's about four points oh it's not disastrous is it actually that's pretty good um it's not quite aligned you can see there's a bit of a gap uh there so what's the button to me oh there we go so there's there's quite a big gap actually is this close enough we will see i'm gonna click process a bit oh actually it worked pretty well oh nice quite pleased with that we don't need to use the stanford bunny anymore we can use mike's special reconstructive stand for bunny which will be superior right you can see this actually there's some artifacts here from the laser scanning which would need to be removed because what you want to do is of each of the views of your bunny you want to select only divide best bits of the mesh where it was looking straight on and then discard all the edgy bits that are not so good and then overall you get a really really you know solid model all right so that's that's pretty much it to close this point you could actually i mean in national you can do all these at the same time and just optimize the whole thing you know but it's it's a very effective algorithm and it's very very quick right if i hadn't have had to click process every time because i did that myself this would have happened in a fraction of a second i know there's something like 50 or 60 000 points on each of these bits of bunny right so that's not a trivial you know comparison to make unless you're doing some smart stuff about it so it's a really cool algorithm is mesh lab one of these amazing really expensive tools no it's totally free i think it's open source and definitely have a play around so you can download the stand for bunny we'll put a link in the description and download mesh lab or cloud compare is another really good one there's various others and just click the align button and start playing around with bits of bunny and it's good good fun for everyone