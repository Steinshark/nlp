so my uh talk is about uh no raw loops with no os um and i think a few introductions are in order my name is uh paul bendixen i am a bachelor of electronics engineering and i have a master's in technical ict and i am currently a software pilot at tri fork and i've been a member of sg14 almost since the beginning as a newly uh new out of college uh electronics engineer i of course knew that the only way to code any decent microcontroller was using pure c and when i got out into industry and saw how electronic engineers use c for the coding i knew that i had to do something to make it more readable and to make it more maintainable and sg14 seemed like the right place at the right time for that so what do we mean with maintainable and readable c plus plus well mostly modern c plus plus and for me one of the big things that is modern c plus plus i got started by sean parent in his c plus seasoning talk if you haven't already seen this talk i would highly recommend that you go watch it it's on youtube it's a couple of years old right now by now but it is a fantastic talk and it uh really gives us a lot um also today so this is uh one of the um defining moments of that talk where he exclamates that this is obviously a rotate uh and the code that went before this was well at least to me at the point it was not obvious that it was a rotate um but the whole point of the uh the talk is to don't use raw loops use the algorithms that are available because that makes it a lot easier for people to know what it is that your program is doing what is even more impressing in the talk is this little thing where he takes literally five slides of the lock and compresses it down to two calls to stable partition this code uses concepts which of course sean didn't have back in 2013 uh when he presented but that we do have now um that we are in 2020. and and this kind of kick-started a lot of different people going the same route uh taking a into consideration how do we make more readable code by using the stl one of the people who did this is jonathan bacara and his talks about doing and knowing the 105 standard algorithms goes a long way to do that he also has this very nice map that shows you where on where in the world of stl algorithms uh the different algorithms live and how they are grouped together you can go get a version that you can actually take take a look at at the fluency ppp which i would recommend that you do but it's one more step in the process of making sure that modern cps plus uses the modern uh stl algorithms and the modern sdl for that matter and after that uh and along with the jonathan a lot of people had come and i'm going to end this with one particular person not because he's last i hope but because he sums it up very well in his algorithm intuition talks a couple of those floating around on the internet as well um where we get to taking from one of his slides a sorted squares now taking this and using ranges and working with the scl algorithms makes this code very readable uh perhaps more readable than what would be done in the in a more let's say uh ee oriented uh approach to writing code so let's all just use the sdl and there will be no problems well not necessarily because we in the embedded field are of course special snowflakes just like everyone else and we can't use all the nice things for example a lot of uh embedded projects don't allow usage of the heap and the reason for this is of course amongst others fragmentation of the memory that we have finite memory to deal with we can't just assume that the system that we are on will have enough memory uh and of course the non-determinism non-determinism of allocating memory if we are in a real time or just a very constrained environment this can really hinder our program's correctness if suddenly we need to go off and allocate some more memory another thing that's often taken out is the exceptions and there are a few reasons for this but mainly it comes back to the heap and non-determinism and fragmentation and let's not repeat ourselves and finally a third thing that is luckily getting less and less um common that to have as a problem is floating point but there are still some problems regarding floating points for example if you're on a small enough machine you might not have the fbu which leads to large library implementations and if you don't have an fba it's probably because a floating point unit so dedicated hardware if you don't have an fpu it's probably because you don't have enough uh flash and memory as it is and then large library implementations aren't going to help you there's also the thing that we might be doing our own os in some of these and in that case touching the floating point registers um might hinder user space if we are writing the kernel space in working correctly and make some very interesting bugs but there is a way out so if we go to the standard then i don't know how many of you know what freestanding is but the freestand but in the standard there are is a paragraph called linked to here in the bottom called compliance that declares that there are two types of implementations for the standard a hosted and a freestanding implementation and for the hosted implementation everything that is in the standard must be in the hosted implementation for the freestanding implementation the parts here in table 24 it jumps around as the standard gets upgraded other things that are in here and as you can see we have uh stuff that we really like and love like dynamic memory management and exception handling um but we also have some quite nice uh things in here for use in the embedded domains such as the concepts and the type traits and the bit um and of course the standard la is the c standard library now this doesn't get us very far in using the stl because if we can only use these parts well there's some bit manipulations but it doesn't really give us all the nice algorithms that uh sean and the others are talking about so there is a proposal actually the by now quite a few uh the po8 29 by ben craig uh was proposed uh in order to add everything to the freestanding implementation that can be used without an os call and without space overhead uh ben's primary goal for this is for working in the windows kernel as far as i recall but this is exactly what we would like to have in the embedded space as well now he goes on to motivate this um i would recommend that you go watch his talk from embo in uh 2018 uh i was there and that's where i got uh inspired but the motivation of the entire system is of the entire proposal is that system programmers don't have a guide as to what c plus libraries will work for them so it should be such that a freestanding implementation would provide clarity and help for programmers currently uh the proposal initially wasn't too well received a report of go back and fix some things was given and it's currently being chopped into smaller more easy to pass proposals uh currently there are these two proposals regarding the library and there are more to come along with the other proposal then craig and ben sax also has another proposal that would make exceptions rtti default heap thread local storage floating point and other stuff that we don't usually need in the kernel and or embedded spaces to make that optional um and of course if you follow the standardization process you'll know that everything has turned into molasses right now it seems to be uh that we are going to wait quite a bit for that so what is actually the entire thing that can be implemented in a os less system without a memory overhead well there are these this set of libraries that has been pulled out the complete libraries are the libraries that are just going in wholesale so the internet you have span and all of these entities can just go directly in concepts used to be on that list but now they're on the actual uh freestanding list so that at least did get through the partial libraries are a little more involved so for example you'll see a library in there like a string normally we wouldn't connect string with embedded systems and it turns out that there is almost nothing left of string but there are some string related header constants that are needed uh some structs that makes it so that string must be there but we pull almost everything out to go into a bit of detail in one or two of them um we get for example most are functional except for polymorphic function wrappers so it's that function and friends because uh stood function will in some cases allocate uh on the heap and we don't want to use the heap uh boyer moore searcher ha and boyamore horsepool searcher has a lot of a lot to do with the string um library and so let's not go there but perhaps for the for the ideas of sean parent and others most of the algorithm and numeric headers are included the execution policy so that is the parallel uh algorithms will not be included and the following amino things will be omitted uh because of the use of temporary buffers and that includes stable sort stable partition and in place merge so out of the 105 plus um libraries in algorithm and numeric we now get almost all of them except these three of course stable partition is in there but that is something we'll revisit in a bit so i got very excited when i first saw ben craig's talk and i went up to him after the talk and i asked him so where is the implementation and he said well there really isn't one i've mostly been doing around with a compiler flags in msvc and i couldn't really use that and the thing is i kind of needed it for my own pet projects uh using primarily the avr processor families family the avr processor is an 8-bit microphone microcontroller it has a huge family variation there are a lot of these they've been going on for forever uh they are at the heart of every arduino of or at least they used to be the heart of every arduino they are still in a lot of arduinos so there's a lot of cheap cheap cheap hardware that's very easy to get a hold on and very easy to start working on it uses a gcc compiler and there is no c plus standard library whatsoever in any of the regular distributions that you will get of the gcc compiler you have to compile it yourself so getting a standard library using the freestanding proposal seemed like an a great idea so i decided to start hacking the gcc and this is uh the rules that i came up with um the c library part is left alone apart from undefined there are some undefineds in there already and the avr gcc [Music] the avrc library is in another library all to itself so by restricting myself from doing going there i only have to fiddle with one library the only change that will be made in the code is commenting out or if duffing out which is how gcc already used to discus distinguish between a hosted and a freestanding environment this is uh built on the idea that the stl is built by people a lot more knowledgeable than me and tested and reviewed by a lot more people than i can ever get to so by just modifying um what gets in and not modifying what is actually written there i can make uh pretty sure that i don't have to make whole new test suites and make sure that everything works and finally i want the implementation to be as faithful as possible so for example everything that uses ano which is a global variable we don't usually feel too bad about using global variables in the embedded space but it's the parts using anno is are left out of the proposal so even though it would be easy enough for me to just slip it in and the standard says that these are at least the headers that must be defined for anything to be classified as freestanding i wanted to be as faithful as possible also so that we can actually see whether or not we are getting uh the full um the full experience or if anything else is needed so what does this give us well we can actually now use modern c plus stud array type save arrays and taking advantage of all of the uh regular things that we have uh we hear about at uh conferences so doing a nice normal compilation of this program it works so slide now compiles gala does not but it does give an error that stable partition cannot be found and this is exactly what we needed in the places where there is a an uh a hole and a mission because of uh requirements that we perhaps did not know i mean who have you have ever thought about stable partition being something that might allocate um this gives the programmer the tools needed to be able to take the to take the library and use it and be stopped whenever they uh get into anything that is not uh okay for the criteria that has been set up so uh i would like to thank um uh miss kay for uh the idea uh she did a talk at ambo a couple of years ago where she had a slide containing all of the steps needed to use at that time it was clang with the avr and that turned out to be immensely useful so i decided to make my own case lie uh k-slide so first we build the bin utils and then we build gcc and then we build the libsy and that will allow us to build the freestanding library so that's how you get it there the code is online and you just go and download it and then you go through these steps it's not that hard um well of course this is uh 2020 so nobody wants to compile anything anymore let's containerize this uh and i would like to send my thanks my warmest thanks to across the auckland uh from the cpp lang slack who took my um my docker files and uh decided to maintain them using an ubuntu version of docker so that whenever you pull these these docker files you will have a complete avr with lips stdc plus according to the freestanding library and we are uh currently at 10.1 uh and i hope to upgrade and keep it up to date as long as i can talking about discontinuing the avr support in gcc but let's let's wait for it to actually happen so you can just pull your docker container and use that of course this is if we really think about it the entire uh freestanding library is actually just a header only library so it's just a library why not use conan and uh you need to set up my uh personal bin tray uh to be able to pull the conan conan 10.0 i'm sorry it hasn't been updated to the latest version uh but that will allow you to do a conan install and use this in your own projects what this gives us because it is a header only library this also allows you to run the libraries originally intended only for avr on your arm so i actually have as part of my conan build instructions a conan test that makes sure that it runs it will include each and every of the files um that are defined in the freestanding library also con compiled using gcc so yes this will also allow you to use the freestanding library for arm so go use that if you're not interested in using the avr if you want to know more there is the gitlab link and that contains the gcc fork it contains the ducker files and it contains the conan recipes and it also contains a woefully incomplete version of a homepage describing more about what the freestanding library is and how to use it so with that i would encourage you as you saw there is no stable partition in the freestanding library i would encourage you to do as sean instructed and create your own algorithms using the standard algorithms that are already there so i'd love to see your take on how to do a stable partition using the freestanding library thank you