hi hi everyone um i'm victor and for the better part of the next hour we're going to talk about the quest for a better crash so um just a reminder we're all here in remo and due to the nature of the delivery medium and the streaming delays that are involved um i would prefer that you will hold your questions to the end of the presentation you can write them uh write them in in remo in the q a tab and upload them during the talk but i'll i'll take them at the end at the very end okay so a bit about of me uh you might have heard about um some of you about um advanced installer might be using it um or maybe client power tools i'm gonna be talking today in the context of the work that we've done uh over the past uh 15 years uh within the advances to our team and i'm going to showcase some of the tooling and learnings that we did experimenting with various strategies in the quest for a better crash or a better stack race so this will be vignette in three parts remembering the crash uh how to roll your own and maybe for next year's uh a few words about the future in terms of stuff coming in the c plus plus 23 standard uh just as a disclaimer this will be 99 talk about uh windows and technologies on windows uh just the the third part of the talk uh we'll touch upon um the proposal that was accepted into c plus plus 23 about building um standard portable stack facilities in the library in the stl so until we get there it's gonna be a windows right uh so remember the crash i think we've all been there and we've seen crashes such as this one albeit this is a pretty old screenshot and some of you might even remember dr watson i would really love to to see a hands up if i were in physically in in a room with you who remembers dr watson and fiddling with the postmortem debugging him there it was fun i have good memories there um and maybe the modern uh the modern descendant of dr watson wer when those are reporting that's basically the same concept wrapped into a more modern or neat package with tighter integrations into developer portal and developers services but basically the same idea but where do all these crashes go actually um and um is this even available for third-party windows apps because i've seen those crashes and those logs being collected mainly from windows applications that failed on me along the years since windows 2000 up to current windows 10 and questions that i've had over 10 years ago now um about this was way before any store or windows dev center being available um can i leverage the same functionality within my app how can we register to receive such crash dots that windows collects what does it cost how does the crash data look like who owns it microsoft stores it what's the the whole the whole picture behind it those were you might consider it naive questions that we had very long time ago but basically all i wanted was this i wanted a stack race for any crash or problem that our users encountered in production and because it's not always easy to actually debug remote problems sometimes for privacy or security issues you don't have access to do a remote connection to debug remotely on the victor's machines sometimes your log files are not enough you have to build you have to construct custom builds for application to do various scenarios or to add more verbose logging to see what figuring things out sometimes the steps to reproduce the issue are incomplete sometimes the context really matters uh or the the application state before the crash so you basically want to see all the context that uh your client was in when using your application and being able to replay those scenarios or pinpoint the exact problem that they encountered so basically you want the same experience that you have on your own developing machine when you encounter a crash during testing or doing debugging your application you want the same experience but for an action that took place remotely and the answers to all those questions i had over 10 years ago turned out to be complicated um custom registration for each app version microsoft symbol servers instances um if you want to deploy those on premise it really complicates things you have to figure out how to work with symbol servers and everything it's doable but in my opinion it's a devops nightmare and i'm not very keen on actually doing devops kind of tasks i want to just program and like any good programmer i decided to build my own you might say we're setting ourselves up for a long run and possibly uh failures but um we were young and naive some goals we set out for this uh it had to be quick to develop because we need it as soon as possible we want it to be easy to integrate in our ci cd system no special service or simple server setup required we want zero footprint on plant site so we don't want to ship symbols uh on client and plant machines as it turns out the applications uh the application that we work on is fairly big and for example for uh debug build the the symbols are over one gigabyte uh and for release builds there are close to six seven hundred megabytes so it's fairly big you don't want that footprint on the client computer zero performance impact on release binaries of course on the happy path and easy to use as a standalone tool on a non-developer setup box because you want to be able to process these crash reports uh by engineers that are not part of the uh actual development teams so we want solutions engineer support engineers to be able to triage properly uh these crash reports and being able to figure out uh more easily um the the the the respective components and uh project owners that need to be notified in the triage process and you you want to be able to prioritize based on frequency when you detect that a certain kind of crash or certain kind of instance of a particular crash a particular location and in code is problematic and you have a lot of frequency in a particular kind of report um so the workflow would look something like this you have your ci cd infrastructure either jenkins or gitlab we used to use jenkins now we use gitlab runners but it doesn't matter and you want in your um build scripts you want to have a step to build artifacts you want to store you want to archive these build artifacts some of them are important we'll talk about what and you want to store them um forever or at least for a long time for each build that you that you produce and these artifacts for example uh for each commit that actually yields a build pipeline in this case let's say we have this commit with the git hash c08 and we want to archive symbols for this commit this would be the dcm file there that i'm pointing at and you have the standalone tool that is able to process this kind of symbols and user crash reports so basically for each build that you pull through the build pipeline you get your normal build artifacts your build packages and what have you we have several different outputs but one of them must be an associated uh archive with all the symbols that you that you care about for later simplification and basically the this dcm file is a zip bundle containing uh all the pdb's that were built in that particular instance and this is important because uh you cannot build these afterwards these pdb files contain precise information that is entangled with the binary they that was produced at the moment that the compiler yielded uh your your output your final binary so uh you cannot later on uh recreate those pdbs um if you go back to the same with the very same commit you actually need to keep them uh in sync entangled your binary and your pdbs so that's why you need to actually archive them a little bit on that um later on when it but if we have time we'll go more deep into pdb object format and pe and co formats and we'll see how this is relevant but for the time being the gist is that you need to uh have some kind of instruction infrastructure to store these pdp files and uh be aware that actually zipping them or compressing them in some way is actually very convenient because it turns out they they actually deflate very well so you can have a very large pdb basically deflate to less than half its size sometimes uh also the pdb is the answer to everything uh live universe and whatever and uh you want these pdbs to to be full featured a few years ago microsoft um india in efforts to optimize and streamline the the debug build cycle they actually made uh the an option to have a fast link a fast link phase that produces a streamlined pdb basically it's unlike an incremental pdb file that is produced and it's meant mainly for debug cycles but you need to make sure that you build with full uh debug capability basically the legacy legacy basically the the traditional pdb full format uh this is the one you want to archive of course you don't want to mess with the incremental bits there are tools that can actually reconstitute a full pdb based on incremental images but it's way too messy it's not worth the effort uh so you don't want to see basically a dry stack trace a crash report this is what you would get from the client side um when a crash occurred without having any symbols uh remotely so you're gonna see this you you wanna make some sense out of a stack chase that you receive from customer support so you want to be able to figure out to see file line number symbols you wanna you wanna see the exact experience that you have in visual studio let's say so you wanna you wanna have the exact experience that you have when you're putting a breakpoint and breaking it and seeing the variables context and the call stack everything even multiple threads ideally okay and the workflow is very simple when you have a crash on client side you have basically a component within the app that actually uh constructs this information uh without any symbols and constructs a crash report that is sent over the support service and is collected is symbolicated and triaged uh using uh this tool that we've built and uh at the other end the dev team actually gets a stack trace that looks decent so a very crude tool that looks like this you select the build the target build for that crash you you get it from the build artifacts that you have the associated dcm bundle that contains your pdbs and you select the crash report and you basically get the full stack trace with all the symbols and information context information that you need and you get on to fixing the bugs um sounds very simple and it really should be that simple if it's more complicated than this then it's not worth bothering so let's see how we go about doing this uh oh and you get something like this so we have a bunch of information right there we have the fact that this crash is an access violation we have the address we have the fact that it's an uh right through a new null pointer so we have quite a bit of information right there and we have the the call stack and we have the exact pinpoint of the the location um the source file and number there and it's all tied to a particular build so it's connected to the base to the source control system through the the git hashes and if we drill down we see the the first clues that we have there like i i already mentioned we have the connection to the build system we know exactly location something to note there the module-based address we'll talk about this later when we talk about aslr but for now just note that it's important that this be recorded on the client side when the crash actually happens so we actually do have code uh in into our application that constructs and collects all this information in the crash report uh when this happens so it's not like a background component or anything it's not like a one complex runtime so it doesn't have any cost at all you when you're on a happy path but when a crash does occur you do pay uh this cost of constructing this context information on the client side and the symbolication process happens on the dev side so how it works first of all we have to address the elephant in the room i know there are several people that would like to see uh structured exception handling be gone and uh i'll grant you that um this elephant in the room it's not pleasant so i've been dealing with this for 15 years now and yeah for if you really want to be pedantic and use just standard exceptions you can for toy projects but in real world windows applications sometimes when you have to deal with the operating system infrastructures and some low-level components and some apis that need this kind of programming model you have to deal with structured exception handling so um yeah it's um i think of it like a bit like a cone it's not pretty uh but it gets the job done so in real real life true to the metal um close to the operating system applications structured exception handling is a thing so we have to somehow address it so yes we do use the async exceptions on all our modules uh you can read more about this it's a vast topic i plan i plan to do some someday a talk about this um if you want to read more about this uh if you're not aware of the intricacies of structured exception handling on all the history it's a very ancient model still in place there are several links there and by the way throughout the throughout this presentation i'll have plenty of links and references in the slides when we get the slides later on uh feel free to read up on at your own pace so you do need to if you want the full experience you want to enable structured exception handling in the project settings so there are also called async exceptions if somewhere you see async don't don't be for example in the ms build file or project settings if you see that it's the same thing so you want eha or async exception the same thing you want full debug information so full pdbs not incremental pdb's and you want a program database information so uh this is not uh truly compatible with uh debugging continuous scenarios but those are for just for debug configurations anyway so uh for release builds uh you want a plain program database that's a slash zi switch um and first thing uh you want to handle c structured exceptions that those are the legacy old-fashioned let's say win32 exceptions you want to handle those as c plus typed exceptions and there are functions in the ce runtime that microsoft provides to handle this translation you have to be do a little bit of the work yourself and i'm going to show you exactly what what this entails but you do have help from the crt again links you can read more if you like so there's an api to set an unhandled exception filter uh again this is again very useful um you might think you're got all the exceptions but they might there might be places where an exception escapes unhandled so you wanna if you want proper logging or proper context information and you wanna actually catch and fix these kind of crashes and i'm not talking about recovering from this fatal type of of crashes the process should go down uh i'm all for that but you want some uh way of actually capturing what happened capturing some context the application links along and crashes so you want to capture some context and log it or send it to the support channels and investigate it to fix the bug so this is where unhanded exceptions uh we found it very helpful to catch this and there's a like a big net to catch this there's an unhandled exception filter that basically sits uh basically below main and catches everything that escapes from from you any kind of maybe unstructured perception or um something that might escape so and this happens if the process is not being debugged so when you're in the debugger you're gonna catch them anyway in visual studio so we basically intercept all of these and um a handler for this might look like like this one you get when you're being called by the c runtime you get an exception pointers structure and you can trace you have all the information there we are going to drill deep into these operating system structures to see how to use them and you can reach into them um and extract all the context information that you need to actually build us for full factories from one hand on the exception you see there already we're able to extract the exception code and address we'll see the later on what those might be and with some helper functions like this one stack work or trace from context you can actually build a whole stack trace just from that contextual information that this runtime gives you so um unhandled exceptions helpful thing we actually over here has found a lot of things just caught in this net wide net but nevertheless also if we're talking about the sync async exceptions and structured exceptions um those do happen um and you might have an access violation that would be in the most common case but more mundane cases like uh overflows integer overflows floating point overflows you're divided by zeros of anything or unaligned reads right stuff like that things like that happen you wish they weren't happening but they do happen in real life so uh again very useful the the c runtime provides you a way to actually translate these um structured exceptions into gives you an opportunity to inspect them and translate them into c plus class typed exceptions so that you can consume them and treat them like all the exceptions or the regular exceptions that you might have in your application but by the way if you haven't figured it by now i love exceptions uh okay so first phase uh you get an uh an sc code or structured resolution code and you have to decode it there are several i i think like 20 or 30 types of uh structured reception codes and you have to um basically handle all of them is just boilerplate code i'm not showing here just a little glimpse by the way this is slide where i had to really oversimplify the code that i'm showing here because of space constraints but the gist carries on so you basically have to decode to see what kind of uh structure the exception uh you're dealing with and um for a particular kind of uh exception the the access violation kind this is one of interest for everybody basically um you really care about the nature like you saw in in the in the course act uh that i showed early on we had like uh access violation through a write through a null pointer so all this information is here so you basically we get to decode this from the structures in the exception pointers um we get the exception information and there is the operation type and those magic numbers um zero one and eight there uh basically tell you that it's a either a read or write or a data execution prevention kind of access causing the access violation and uh whether you have or not a virtual address in there tells you that it's through a null pointer or a dangling pointer or basically a bad pointer most people protect against null you know the billion dollar mistake but um you cannot protect for bad pointers unless you sprinkle all your app with sharepoint which is not a solution by the way so um dangling pointers do happen as life i guess but you want to catch them so this is a way to actually pinpoint that a particular axis violation was through a dangling pointer and you basically encode this in enumeration or something like that and store this in the crash report later on same function i'm presenting it piece piecewise so it's easier to digest so after we decode the exception type again we encounter our old friend trace from context from stack walker we give it a context record from the exception pointers that the crt provides us and we also extract from the same context record we extract the exception origin which is the file name and line number we'll see later on how this has happened the gist of it being that the c runtime gives us this callback that and we can hook into this mechanism and it gives us through the exception pointer structure it gives us a way to mine all the information on the client side and construct a c plus plus typed exception uh here uh it's called seh exception um you can you can use whatever exception type you want standard exception whatever you want and throw it after uh the the serrant and gives you an opportunity to handle it throw it like a regular c plus plus exception and catch it and handle it however you like log it ignore it whatever i wouldn't try to recover it but so this is this would be the gist of the the uh sch translator uh trans translating from a structured exception into a c plus plus typed exception that's it what about an exception in flight so you want to get the stack trace for the raised exception on the current thread so you're on a catch block let's say or somewhere and there's an exception in flight and you want to a snapshot of the tracks stack trace in that particular location maybe to log it i know there's a way you can do that here i have a very simple function get stacks trace for current exception and again we see our world friend uh stack our transfer trace from context which we'll get uh get to later on uh that and we give it the get current exception context so we have to figure out how somehow from an in-flight exception uh to figure out on the on a particular thread mind you to get to figure out the the execution context that very same thing that we got from the crt uh for example when a structured exception hand happened or when an unhandled exception happened so the vase same thing the the execution context that is the very rich information that we need it includes everything even computer register information but you want to capture that somehow foreign exception and this is where this um get current exception context helper function comes in and let's see how it looks so it gives us this p context this structure that we've seen before um and it contains process or specific register data register uh register values um and various flags that you can mine for uh particular uh interesting bits again if you want to read more about this structure and how it's used there's a link there but we've seen this one so we know how to deal with it so we've seen it in the translator function uh that the callback that we used for the crt hookbook and again this exception record in that case was wrapped in this exception pointer structure that we've seen that the crt fills in for us so we have this p context right there alongside the exception record the exception record we already mined when we figured out the information about is this access violation what kind of access variation is what's the virtual address easy to read is the right blah blah blah so so uh what's this context how do we get this for an invite exception um first let's see the exception record because we already used some of the fields in there but let's see what's in there really so you do have the exception code the flags uh we already see that this is a link linked list of exception records um this is mainly how it's treated for x86 uh architecture in windows for 64-bit uh architecture the model is a little bit different uh there's a lookup mechanism um as opposed to a linked list reversal so it's more efficient in the in the unhappy uh unhappy path it's a little bit more efficient on 64-bit um other than that the structure looks mostly the same if you contrast this the explicit uh 32-bit and 64-bit structures that the the windows sdk defines for us you see that that that pointer of different size is there and depicts express exception record and it either points the table over a linked list it's not important how do we get this p context so if you're a newish visual studio that is 2015 or later so i'm guessing everyone this is the magic incantation to get that don't ask me how i found out i [Music] really don't remember maybe googling or i don't know mining the dark corners of the internet i don't remember this happened i think years ago really years ago so i don't remember all the information it's a little bit fuzzy it really doesn't matter just take it as a magic incantation and test it and see that it works and disclosure it uses private undocumented apis so um but uh microsoft has a pretty good track record of actually being very stable uh within with the the private apis and they basically never change so we've been using this uh technique and i have a slide with for all the visual studio versions so we've been using this technique for uh over 10 years now and we never had to change code when something changed in windows or in sdk so it's pretty stable but it's uncharted territory there so you won't find msdn links for msdn information so sometimes the structures i remember one of the structures that i'm going to show you i basically found it on some google group somewhere somebody pasted that they figured that i i think i was i found some structure in the in the chromium source base for the 64-bit yeah i remember for the 64-bit case i found the structure in the chromium code base that's basically somewhat some someone reverse engineered and figured out the the structure layout and what's in there so magic so take it as uh as it is it works test it okay so you have some helper functions from the crt current exception context and um uh you here you have to differentiate in either if you do static link or dynamic link for for this module so if you and in this time i'm i'm um referring to how you link against the crt so if you uh static link the crt into your application then uh you're on the else branch here if you're dynamically linking to the crt then uh then you're on the on the first branch and the if uh if branch so you have two helper functions from the crt again private apis that do all the all the magic for you and you retrieve from this uh again a non-documented structure internal structure this vcrt ptd and it contains the current context so this is how you get that that most wanted p context um if you uh just to mention maybe some of you are stuck in an older version we've been using this code when we were on visual studio 2013 uh for some time now we uh we had like uh used both tool chain versions 2013 and 2015 for period because we had we had to target older operating systems and life so this is the code we used on 2013 um basically a similar incantation a different crt structure that contains the p context and different crt functions again private apis that get you there just take it as it is some headers of interest eh.h exception handling signal.h to access these functions and some function prototypes and private includes that you shouldn't theoretically touch but those are there and the i think this is the structure yeah if i remember correctly i think this is the structure that i i i have to patch for when we started building for 64-bit application uh the 64-bit version of our application so i think this is the structure that if i remember correctly from years ago um that i i found in the chromium source code of something it's uh i found the magic fields there it's a little blurry but it's not meant to be understood okay so uh but so we've seen how to get a context for an in-flight exception but what what if we want to get the stack trace from the context of a caller that is to get a stack trace on demand not no exception is inside nothing crashed um you want basically you just want some rich logging for example maybe you have an assertion that you want to print the track stack trace of an assertion uh when when it happens or maybe you want to log a particular place um a particular location that is called to see which are all the the the paths that you reach to reach that function and when something i know some invariant is broken i don't know it turns out to be very useful uh even without the context of exception how do you get a p context from the caller function so no exception and here there's an api in kernel 32 it's called rtl capture context very easy you dynamically load it if you're on newer windows versions you don't have to bother with the dynamic load you have you basically can copy directly i think there's a signature in the sdk for it don't remember but you can always dynamically load it and you do capture context and you get the context and then our friend trades from context and does the heavy lifting and builds the stack trace with all the similar information um so now that we know how to get this p context how do we walk the stack so starting from this very simple structure how do we traverse the stack and build each stack frame and see what's in there so let's see this old friend that we've used all these slides in all these slides so just from context by the way uh the api that we're using here the stack work api and most of the apis that deal with uh debugging tools or image help library all these apis are single single credits so if you're doing any kind of multi-threaded stuff um you need to be aware that you protect this uh this type of function and this type of processing uh and needs to be in some kind of critical section to be to be protected so just uh as a warning and you have to copy the context structure because uh the stack work api actually uh stumps over it so you have to make a copy of this structure you cannot reuse the same pointer that you have so you have to save it and you get your context you get the current process current thread this is this is easy again we have a little helper here we have a class that acts as a symbol explorer and this would be the one that maps the information to the debug information this happens uh on on our side when we actually try to symbolicate and rehydrate those dry crash reports so on the client side this symbol this symbol explorer does nothing because it has no symbols it basically constructs just a dry crash report without any simple information but with the right addresses and the the p context is valid it has all the all the good information there so after that initial setup uh you get you get to your for loop there and you have a stack frame structure and um i'm omitting here there's a platform dependent an architecture dependent uh init phase this unit stack from context you have to set up the stack frame in a particular way um i think i omitted the slide that does that maybe i'll include it when i publish the slides later on you have to fill in some fields with some magic numbers and it just works this bit is actually documented so so it's a public api it's not something like undocumented territory there so you have your frame for loop and the stack walk api that actually starts from the current context there that you received somehow from an invite exception from a caller or whatever and you have that context information and this stackbook api basically traverses each each call each frame and we have uh our friend the sim uh symbolicate um explorer there that composes each stack frame for a given offset so for a given program counter that pc is a program counter so for a particular program counter you have the offset which is the the function address and you can record this information in your crash dump if you have symbols it will put symbols information there if you don't have symbols like on the client side it will it will omit those and you can use the same uh infrastructure to rehydrate and symbolicate applications on on the dev machine now on a support client side um and at the end very important you have to write the module load address and this is needed because of slr and this uh if someone is is not aware about this each time as a security measure um in in the old days um the modules were loaded at the same address in the in apparent process and even the process that is spawned was always basically spawned deterministically at the same um address in in virtual memory so this actually changed a few years ago i think with vista if i remember correctly with windows vista so basically you have a subsystem in windows that basically randomizes the the base address where the process is loaded or the module is loaded in your process so to prevent uh patching or trampolines or something so it's a security measure and you have to record we have to record this process precious information because it's a random thing we have to record this module-based address on the client side so later on when we figure out all the function addresses of our module and we also we always have to figure out a displacement uh and figure use this load address base address as a baseline for uh address arithmetic when we calculate the real address to figure out the symbol names in the pdb so very important to capture this information in on the client side this component stack frame from the symbol explorer it's very simple you have this the address again two helper functions simple name from address and symbol source from address that gives the name and file names file line very simple trivial and a simple name from address uses this api from the debug help library you see there debug help dll uh you have the the api sim from address and you basically use this to get if you have symbols loaded and we'll see uh how to set up symbol paths and everything and we need the the system for to reach these symbols um you basically get the mangled function name so that pretty name that you actually want in the thing that you see in your debugger when you're debugging uh on your machine so you get all that uh information just with this very single api this this this is basically the whole code i i cut very little from this function and to get the file name and file file number uh line number again there's an api um scene get line from address um and you have a displacement and you give it the program counter and gives you the information the right information from the symbol source again mostly boilerplates it's not not anything fancy here this is the part where you compute the randomized base address loaded um this is the code that needs to run on the client side so you have to get the module handle and the module handle basically represents the load edges that the module has been loaded at and you have to record this somewhere in the crash report the init phase again a little dance some boilerplate that you can find on the msdn this part is documented pretty well you have the sim initialize phase uh and the the important bit here being the function that sets the symbol search path because you can give it a location this is uh the the the argument here being the location where we have stored those pdbs remember that the the build artifacts that we store that we archive for each build and we store them we have a way the tool has a way to get there reach there get the dcm archive uh unzip it and point this symbol class pointed at the the symbol path there to find the appropriate pdb and the the symbol uh search path basically if it's given a path uh it uses it for using this um api scene set search path which is a documented api pretty straightforward it has some remarks and rules and corner cases but uh if you point it at a simple path it basically prioritizes that thing and it has some fallbacks um search locations where it searches for uh simple information if you don't provide it a pathway if it doesn't find an appropriate pdp in that path and as a fallback you can always assume that you have a pdp next to the executable there that's the the in df branch here okay so all this dance was nice um pretty might sound pretty complicated but it's actually not that much cold um but there's a good alternative uh if i didn't uh sell you on this path and you're not convinced that this might actually help you and or maybe you consider it to be too much work um it works but might be a turn off i can see that there's a good alternative that you should be aware of um if you're on a fairly recent version of visual studio 2019 i do recommend i strongly recommend that you you be on the latest um there's a newer thing uh actually the the mini dump file format is fairly old but the recent visual studio versions actually um put this on steroids and it's it it makes it really is a game changer it makes makes everything better so the windows snapshot process can capture program virtual memory and heap and lots of photo metadata from an application that crashes and you can uh wrap this in a in this minidam file minidon file and visual studio can parse this and the latest visual studio versions have a pretty nice user interface so you user experience around using the snapshot files uh so you can parse them and open them if your studio and points at the right location gives you the cool stack the context information all the variables and everything and i i think if more people people embrace this kind of format and it's this this one is basically in the box it's a it's a tool standard uh it comes with the latest visual studio if more people embrace this uh kind of format i think it will make for a better experience debugging applications and reporting bugs in general and if you combine this with the live share i think it's a it it's amazing so this is like a mini dump summary uh this is how it looks like and you open it in visual studio and you basically have a debug experience like you had set a breakpoint there yourself and you can even start a collaborative session right there from from that um break that breakpoint in the in the snapshot file in you need a live share session when you can do a pair um investigation with somebody else on a different computer if you don't know about live share just search it later on and see how lifeshare works is amazing and it works visual studio to visual studio visual studio vs code um it's amazing it's a great tool to collaborate and investigate this kind of bugs that don't happen necessarily on your machine so there's a there's a potential there to be something that might pick your interest so in the end we have to think about um post-pandemic crashes and what we'll do to to handle stack traces in eight years to come so there is actually a fairly old by now proposal um 881 first draft is from 2018 actually and it's based on boost stack chase if any of you are familiar with boost stack trace it it went through several revisions now it's revision 7 it's a very good paper i enjoyed tracking the the the progress through the standardization process unfortunately it didn't make it to c plus plus 20. i really hoped it would but it didn't um so it it definitely will make it into 23. so again i chose some names for the thing we built the the the library proposal uh investigates several names i don't know if you you're going to be happy with the the the one that uh is gonna win it doesn't really matter uh it what matters is that you'll have you're gonna have a portable uh way to construct such stuck traces and capture this kind of information uh from your application and it will work everywhere and it will be much more pleasant to use than the bits i've shown you up until now so uh this will be the first uh major library feature that will be in this in c 23 so it's basically voted in it's it's basically there just some polish and key features desired all functions are lazy so you don't want to query structures entry information without explicit requests same thing i told you earlier stuff that you do on a client stuff that they have to do when you have to process these things um dynamic styles for stack traces so you must not assume that the structure is is limited by a given depth there so you have to be able to enable disable this machinery through a linker switch so compiler vendors tool vendors will have to give you a way to opt into this mechanism and of course you shouldn't pay for this kind of facilities so it shouldn't prevent the compiler doing any optimizations in the presence of these these functions that are around your code so and should be because they're they're meant to be very lightweight they should be usable in contract violation handlers in co routines in any handler functions uh in threads in parallel algorithms so they should be able to to be usable everywhere um um you have a stack tree's description that's returned at the mango function signature we've seen this already you have helper functions like tostring to get the debug symbols information and other resources and show them android signatures it should have support for inline functions uh and display entries for functions that have been inlined in the final binary i think this that is just merely guidance in the in the spec um and should avoid doing any heavy operations in the constructors and the the the factory function the the static function current so it should be fairly uh quick to invoke this is uh the important bits the salient bits from the the class it has a lot of functions and operators and needed boilerplate but this would be the salient bits description source files line a way to get the native handle something to the native implementation from the vendor and it models the regular and it's comparable a back trace has basically a way to store stack trace entries it's not required to be a vector but a way to store several frames and the frames are of type stack trace entry and you have a way to traverse them and it has again configurable allocator that it passes to the frame um you can get this is how you get the stack trace you get the current stack trace um you can skip over some frames um and you this is how you would initiate and get uh to get ahold of the structures on the current thread of effects effect of execution sorry um you have the helper functions to string you have the iostream operators to log easily all the border plate that you need to construct to make something like this usable like get the kind of structures do a range four and print the description source file name file line or even simpler to use to string from the stack entry which has this overload or just print out the frame directly to knive string or even simpler to print out the whole back trace without individually printing the frames so it magically works so this this is the the it couldn't get any simpler than this so uh when we get this i'm hoping uh it will become available pretty soon uh even before 23 so i'm hoping that library implementers will provide these as soon as possible i'm hoping that everyone will jump on board and start using this kind of facility maybe migrate your own home implementation like we have uh we're definitely going to try to to see if we can switch to this implementation when it becomes the factor standard with that i'm ready for quick q a i'm gonna switch to rimo now