thank you and now we're ready now we are ready awesome let's see what happens um first of all thank you again said I'm allowed to put the little sign on the left top it's very important for me I have friends in Kiev I've also friends and Russia um there was one conference where I had a problem with the code of conduct team because of that so maybe our value system is sometimes interesting in this world today let's talk about C plus plus and and those who know me know that I I care for more than 25 years now I don't invent I usually document and teach and as if you write books you are an early adapter of something new and that means you think about things how to teach them this is good design this is bad design I'm involved into the senate committee for years now also with support of things cell I'm part of that problem now of that solution and um but we have 200 people now standardizing C plus plus awesome people great experts with a lot of heart and a lot of care I have to say that because you might get in this talk the impression that I don't like them so it's already a case of code of conduct okay and then but no that's not true I think we are a great group you learn how to work together and to make something together but I also see an issue and the issue is if 200 experts work together on the rush and they do so many stuff as we do sometimes things have a problem so in this keynote we will see a couple of things and good things and maybe bad things and first of all I have to change the title I don't want to talk about the devil in the detail I don't I want to talk about the shaman and you will see later on why when C plus 20 came out we uh could do a lot of things we couldn't do before partially I learned them the hard way when I when I wrote the book which just two weeks ago was done so let's look first of all what is possible now in my example is let's init the range with some random numbers so let's hear we have a vector of eight elements the zero initialization makes eight elements all zero and then let's call a function and the function should add some random values to this um to these elements okay so let's iterate over the values and call the function random and add the result to V to the element and what is random well random is in fact part of the C plus plus random Library where you could Define the distribution of values from 1 to 99 um using a random engine initialized or seated with a random device and that's it that's it that's C plus plus 11 stuff nothing new so something like that is the output good and C plus 17 we introduce a class template argument deduction if you look in the middle in the Declaration of random you can see that um we no longer need the type in there okay and now let's look at some things can we improve things here and the first thing we can improve is something if you do start to do that you immediately are lost and say I cannot roll back and what I'm talking about look at the top of this function and look at this change let's declare the template parameter not as a template parameter Auto let's use Auto here and and it's really fun I I gave a I gave a training on Tuesday and and we talked about generic lambdas and I told them and he asked them oh what what is this all this stuff with templates and they are so complicated and and as I told them have you used lambdas with Auto yeah okay you use templates oh really and and this is the way that we can write templates now it's still a template you can explicitly specify the type that auto represents but it's just nicer okay so let's um use this function in some other context let's use a queue well if you have ever done that pass a queue to function that expects a range to iterate over you might come up with the surprise which is um you get some crazy error message the craziness of the error message depends on what you do and how deep your code goes because cues don't have begin and end it's not the range so you get some error message and the error message points you right in the middle of randomat are functions that are called there so C plus 20 gave us its feature to say well you know we can constrain this template we can say this template is only appropriate if we uh if you give me something that is a range that where we can forward over and um yeah modify the elements Etc so forward range then we can write that as a type constraint directly in front of Auto most of you will know that maybe not everybody and as a result you get a nice error message even without looking into the function um body and the compiler will tell you well the constraint is not satisfied we have a problem here compilers still work on that they're getting better and better um give them still a little bit time to get with really good error messages here so now we can say okay let's try out to do something strange which is let's initialize or add a random value to a vector of strings oh the first guy is shocked by that who knows that this does not compile oh a couple of people who will raise their hand one two three four are in the standard committee and they are wrong because yes a random value that is an end can be used as a character and can be added to a string hey people what are you standardizing this works and depending on the value of the random number generator you might get after tic-tac-toe a visible or non-visible character having nice effects that's not good can we fix that yes you just saw we can constrain templates with C plus 20. so let's do that here so how do we do that um let's put another constraint now not just qualifying the parameter now constraining explicitly let's require that the value type of the elements so the element type of what we pass as a range so we take decal type of the welts and then the value type we need a type name there and then um let's require that this is an integral value and that's what you write there and suddenly you get an error message well you also get an error message for the first call why look at what we call on top of the slide we call decode type of what we have as a parameter so valves Deco type of valves colon colon value type what is wealth but also is a reference so that's not valid code so this requirement is not fulfilled a funny side effect if you have another in another random ad that could be used instead that might be taken now because require says if this is not valid well we don't use that okay so that's not the way you have to do it you have to do it that way we have a new type trade that says oh um please be when you take the type of wealth remove Constance volatile as a referenceness well in this case Concepts and volatilesness is not there but anyway this is a new type trade I wanted to show you and um so this is the whole expression pretty easy pretty straightforward and you get a nice error message saying the constrained integral is not satisfied when you call random ad for the words for the vector of strings can we do it better yeah we can do it better so one thing is that the whole problem that we will have to call decal type of vaults and then remove CV ref is that we don't have the type as it is without constant referenceness but but we have it to some extent that's what Auto represents so in this case Auto is not the best idea let's go back to use templates parameter but yes we still sometimes need them so let's introduce a template parameter and there's a type of the range use it introduce it and use it in the Declaration and then then say okay let's require that this is a forward range and that the value type of it is an integral value better uh can we improve that oh yes look at the top look at the type name so the way we could constrain Auto we could also can also constrain a template parameter now so instead of writing type name we can say Okay um rgt must be a forward range so we have it on top we have the for the type R GT which we use a couple of times forward range as a requirement we have another requirement saying the value type has to be an integral type and yeah now that starts to look okay I would say um we have a special kind of ranges support it for years and C plus plus which are raw arrays so does it work for raw Aries oh no um yeah because raw areas have no member value type so but here we also have something and that also comes with C plus plus with the rangeless library that says well instead of using value type user General utility we provide to say well let's use the value type of a range well there are two ranges there so in the rangeless library there's for range the value type and then you pass the range you have and by the way this can deal with if you pass some reference also so I could also pass here Deco type of something of that okay and now suddenly in this code we support raw arrays awesome can we improve the whole code can we can can I show you something more about C plus 20. yes let's use threads so let's uh put the whole initialization into a function into a local function so we use a Lambda for that and then start five threads calling this function so let's um create a vector of threads and five times pushback a thread that is calling this Lambda well oh my goodness well now even those in the Senate libraries saw some trouble kidding I'm kidding they're great um Concord writes that's not a good idea what do we have here but we have another problem with a cutter because there's a problem with threats if you have threats and you don't join them before the distractor is called you get a caught up so at the end you have to write a loop that iterates over the threads and calls join for them oh and you have to deal with exception handling because you might not come to your loop at the end and um oh what happens then if we have an exception how can we signal that all the threats should no longer run these things were not solved we knew that they were not solved and um it's it's a little bit funny I I've made a couple of proposals for C plus plus but they were all fixes nothing new and um so I drove this and it's called J thread Jace does not stand for your zutis play the stand for joining threat and um and also not for Java I should say and with that we have a nice feature analysis in C plus 20 says look let's iterate over all the threads well and join them no you don't have to do that anymore because the destructor does it for you um so even if you have that exception we wait for the threats which might not be good because we wait forever well in this case not but how can we say oh if there's an exception stop well part of this feature part of J thread is stop tokens and you can say Okay um give me an optional additional parameter you see there was none well even if you have some just put a first new argument there stop token and if you have that stop talking you have something where you can establish a core Cooperative way to deal with problems that signal stop threat no longer wait the problem is you cannot kill threats it's not a process we have to know the process scheduler cleaning up things Etc if you kill a threat you either cannot do that or if you can't do that you run into really a strange state of your program so you need cooperation and this is done by J thread J thread will at the end implicitly call not only join it but before culturally will say hey stop and but the threat has to um cooperate and say from time to time I'm looking is there a stop requested and if so I don't continue There are other ways to do that you cannot you can add a callback that is called in that moment you can even establish a stop token and pass it to a condition variable so if the threat is asleep that the sleep is interrupted to stop the threat so things like that came and I'm very happy that we have that it's not I only drove that I I didn't program that a lot of people programmed that I saw all the problems we fixed with that um if you do it on your own um it's a nightmare to do it right because concurrency in general is all right it's a nightmare a lot of things can happen okay so we have this code ah and then we have concurrent access um concurrent access to the values in the vector by five threads that's not a good idea so how can we protect that well we need something like mutexes or Timex or something like that well we have something new and C plus plus 20 which is a temporary atomic we call that Atomic reference and if you do that um it's enough to fix the code as follows as you see it here to say well let's let's create an atomic reference V here so V is already there but we make it temporarily Atomic and of course all at each and every thread that might um deal with that at the same time has to do with that but then this code is safe and and you see you don't have to share the atomic reference with the other threads each thread can make it an atomic reference itself and buy some mechanism that that use Global tables um that we have make this V Atomic inside this Loop but not for the whole program so temporarily Atomic only in this context and done we're done it works [Applause] well that's a plus for those who provide Pro full provided all the all the stuff used here we have Concepts we have constraints we have Auto you can qualify well you don't see it anymore Atomic references J threads um oh ah there was one more thing views here's my function again I skipped the body now but it's still a function that adds a random value to all the paths all the elements of the past rank okay if we have a vector of 8 and this will work fine and initialize all the values you can print that out great what we can do with views is we can create a view on a range which is not a new Range we can say oh let's take a subset let's take a transform mention of the values in the container let's take the elements reserve a reverse and things like that so you can do this you can say oh let's let's initialize another Vector of 8 in but let's only add random values to all the elements but only take the first five of them by using this pipe symbol and if you print that out you get that as an output well as a possible output it's a random values and that way you can you can create pipes like that and combine even with with simple building blocks you can combine and create multiple more complicated stuff like this you can say okay let's um let's um get a value how many elements should we skip so let's skip two of them so let's um initialize in another yet another Vector let's initialize the each element the five elements after the first two elements which we Skip and then um there's a c result how cool is that and I just switched to list here ah Vector Now list possible how cool is that those who come from Unix know about the power of using little building blocks to create really interesting complexity very fast and easy so time to program should be a fun session and I have to prove what I teach you that everything runs so we have to program so this is a code you just see I hope yeah it looks like that a lot of header fights who are missing okay um let's compile where do I have it maybe here yeah that looks good oh it was you didn't see what you saw there it's clear but so should I make it a little bit larger in the back for the week yeah yeah okay why don't you say anything so better or still larger oh I want to sponsor my Talks by some eye doctors I think okay that good so okay we keep it okay make proc zero oh oh man that's that's a standard GCC compiler I should use a 20 mode okay good compile at least it compiles so does it also work well I have commanded out print and um so we have to implement print but that I thought is something we can do together so um yeah obviously we have to write a print function um obviously the print function returns nothing and um oh we have this new cool Auto feature so Auto and um oh do we modify the um values cons Auto reference why is that green okay good collection um so that's my collection and oh I should look here that's easy um so let's um so painful to type in front of 500 people um for each element for each const Auto reference well okay we know it's and let's let's make it more generic um each element in this collection [Music] um let's print out the element um what what oh what is all you want to you want me to use a new format Library it's not supported everywhere yet I hope it's coming soon well it unfortunately is it now in GCC I don't it is oh I should about if you wait a moment I will rebuild my local system GCC okay I'll we continue so okay we use that good so that is code compile what do you think why not what doesn't exist line 46 oh yeah you you know last minute changes in a talk are really a problem um and what say it and it's okay or not okay we will see yeah I mean that's why we have a compiler good looks good program oh awesome that's it da who has learned anything used so far no nobody good so I could have skipped the whole thing yeah I see I got the message um let's let's use oh let's let's make some fun let's um print out here how many elements we have no so we have the values um so we have val dot size oh no we don't use What DOT size we choose the nice utilities from the ranges Library so stood ranges size for vowels B lamps okay that's a code compile no they say but they are wrong it combines all good so let's modify the code a little bit and add yet another view and for example say this time I wanna I wanna have a V4 which says um let's take list three again and then let's use the filter and fit [Music] and what what do we want to filter let's um let's have a predicate greater zero if it's greater than zero that's simply to type let's say um for each cons out to reference value return whether the value is greater than zero [Music] um oh it looks like okay so let's um init that V4 and see what's happening so does it compile no why why not hold it yeah this has no size yeah and you get an easy error message you know you know what I did in my trainings and it's really helpful I whenever I teach I turn on the flag um where is it F Max hours equals one so that you only see one error message of 200 lines and not anything else so the problem is we have no size we have no size and why do we have no size we have to look at that so here's a problem assume I have a vector and I call drop so drop for a vector is cheap you if you define a view like that you say okay let's call begin and begin as is constant you can easily compute where the first element is with this view because you just can compute let's go to the first element in the vector and then jump ahead three elements that's um not possible if it's a list if it's a list you cannot jump ahead three elements so you have to um iterate three times and things like that happen if you use a filter if you use a filter you cannot and you say um let's go to the first element you have to look at each and every element whether it fits or not to decide which is the first element so which one is the begin of The View so that means um for a vector and then filter uh then um a view on a vector with drop begin is a very fast operation for a list and a drop it's a it's a slow operation it's a it's it depends on the on the number of elements you drop um empty is it empty is fast for a vector a drop on a vector because it's just a computation it's a it's a size of the vector um bigger than the number of elements I drop um you can compute size fast you can use the index jump to a specific element fast everything is fast so that's fine but if you use drop on a list then Things become expensive sometimes so um empty is easy size is easy because you can also always ask what is the account size and then see whether we skip how many depending on how many elements we skip whether we are this what is the result but to jump to an nth element we um yeah we have to iterate and so we don't provide that and the same is for filter we don't well everything is slow with a filter well even even beginner slow because um yeah you have to iterate over all elements until you find the first element that while the predicate you pass is true um empty is therefore also slow size is slow Linux operator slow so you know that from C plus plus we don't provide slow functions well but wait a minute um if we don't provide begin we have a problem with a view it's slow but that's the nature of the game so the result is that size and the index operator is not available if you use a filter but empty is for example available and begin is also available so but then the designers of the library thought um but can we improve the situation and then and then they came up the following they said okay you know when I have a vector and I call drop it's it's cheap it's always cheap so that nothing to do that but if we have a list and and we call begin once we have begin that might be a linear computation depending on the number of elements you drop and the same is if we use a filter depending on the predicate um yeah let's see so their cash began cool idea once we have computed begin let's cache it so next time we use Begin Again we have it it doesn't take us anymore at the same time so we have some views at Cash filter cash is always drop sometimes depending on whether under the hood there's a random access rainshaw the list rank okay as a result you have this Behavior so you can see that um if I call vectrop or List drop the first begin is constant and then the second beginning is constant but for a list drop the fourth line the first begin is linear and then the next is constant and the same is true for empty the first empty is linear and the next is constant unless we have called begin already because Big Empty needs just begin and um and size we don't provide which is a little bit funny because from a complexity point of view size is as slow as empty but okay um why do we do that but that's a good reason for that because um we have a requirement in the standard we say to require that something is a range you have it is required that begin and end is cheap and it is stated in the standard they say this is little quoting um if you have a type T it models the range only so a concept range only if begin and end have amortized constant time so the trick is amortized here well because it's not constant obviously it cannot be constant but it's amortized constant we have that already we know that from vectors where we say well you know pushing an element at the end adding and inserting an element at the end is amortized constant time because sometimes you have to reserve new memory but um that pays off because over time you you added more memory for 50 new elements and the next 49 elements are cheap to insert that's a little bit interesting that we but that we say we have the same situation here because obviously the first call of begin is linear so it would only pay off if we if we have a filter that has 100 elements we would only get amortized constant complexity if we then iterate 100 times over this collection well not 100 but if if this is correlated to the number of elements so the more elements we have the more iterations we have well I discussed that and then and and I got an answer that said um well you know yeah that's that's sloppy language um we have you can see it that way that yeah obviously we need some time to visit all the elements but we reduce the amount of time that we could spend if we iterate once again so for the second operation it becomes cheap we just have let me say it that way not the best wording to specify that okay fair enough let's look at the couch so let's um let's measure that let's measure how fast this is and let's see what the result is once again I have a program here it is just saying well I have a size here the size comes may come from the command line I initialize a vector with size elements all be negative and then I call drop for half of the elements and then I measure how long it takes to call begin just begin it's important by the way if you do that you have to use the result of begin otherwise compilers are so smart it's they see that it's not used and throw it away so let's do that that's fast um that's still fast yeah we have a vector we have a vector and we call drop four Vector calling drop it starts to jump um to the corresponding element so that's cheap so let's um let's modify this and say oh let's let's add it later on and say um let's let's initialize a list see the list of int let's uh well Vector has done the job already so let's initialize a list with um the um how is it called Vector begin and the vector end so all the elements from the vector and then do the same again so this copy and paste to see only appropriate way to program I know I oh do we have a problem with the initializer well what is the problem here okay no the curly braces are not the problem yeah the good thing with C plus plus compiler messages is once you understand the error you understand the error message so so look at that that some things are suspicious here so passing so begin begin is a problem here and then call it here okay let's see is that something on the right no oh oh these cards qualify us do you know what happens when you read discards qualifiers you have a conscious problem well all you have a volatile problem pretty rare so okay we have a const problem so what is the const problem I'm sure some some people know here from what you just saw what is the const problem here oh beginners caching the value or and that means we modify The View oh so the problem is um we can no longer pass the range with uh const ant okay let's remove it and it works awesome okay I have a lot of generic code I wrote for 20 years now so remove all the const if you want to use your code for views that's what you see here or you cannot use it well unfortunately if you now pass a temporary object um that will no longer compile because um and non-const L value reference the one with the one ampersand cannot bind to an R value to a temporary object so to do that you have to do something we are all familiar with because we are only experts here but I tell you four million programmers in C plus plus I'm not familiar with which is this Beast okay we just mate Universal or forwarding references a basic feature for ordinary programmers wow um you are happy if you don't have to teach C plus plus I do that will be fun so of course I have some questions so let's look at the slides again a little bit what we have so first of all what can happen SAS a programmer has this simple code just a print function and you can print a container you can um then pipe containers whether it's a list or vector into a take View and that works perfect take just the first three elements you take a drop View and it works perfect for the vector but not for the list now you sit there think about a programmer just not so experienced just solving some physical problems physics problems suppose it's the right word don't know but people who are not experts and know all the tricky features of C plus and they come to this point of view well you know a little bit more than one year ago I was in that situation because I didn't see that coming so the next thing I tried is um what is if I don't call Print if I do it directly and it works okay good you know the answer already the problem is the const here so how can we fix that well a couple of interesting issues we have so first of all that's an interesting suggestion I got I ask a lot um but the the point is you have to call begin and create something where this is called already and this should be a view so here's a trick you can say oh let's let's create this View and then pass begin and then of this View to a sub range that's also a view and that's up range now is um allows has a cons to begin and that works good so next thing we just talked about is use some D2 ampersands um as I said it's called Universal of forwarding reference it was called Universal ref reference until the standard committee decided for whatever reason we call this forwarding reverence although it's not a forwarding reference until you call forward for it and it's not only useful forwarding as we see it was for perfect name Universal reference because it can universally refer to both L values and R values without making them cost things like that happen if if the languages not too complicated we make the terminology too complicate it okay when I get older I have to become wise I thought but I'm I'm more angry okay and because it's not necessary okay so we do that um oh yeah okay let's let's do this let's let's send my function um use one thread to uh print out the elements and another thread to accumulate the elements oh oh that's okay if you pass a container that's undefined Behavior if you call drop and it's a list if you call drop and it's a vector it's okay because we are calling here in two threats at the same time begin and that's a concurrent iteration we have a statement in the standard that says um even the non-cons begin does not count as a right it's safe to use it concurrently in contain us but not for views so you have undefined Behavior here in this code so in this case please use const here consultware f so you see the rules beca are becoming pretty easy now huh well okay do we have other options yes we can use values call by value but then passing a container is expensive we can constrain that and say no no um pass by value but we require that it is a view then passing a container as an error well that's maybe better maybe worse and expensive but then the caller can say oh let let me convert the container to a view we have a view for that that's called all take all the elements of this container as a view okay or we overload for containers and views um so here's um for views and then um let's let me add a print for containers containers we want to pass by reference oh that's an interesting problem if you overload in C plus plus for reference and values you should not do that um because then sometimes there is no preference of one over the other and so you definitely at least have to say and this is not for views so that definitely only one of them is valid um normally it's okay to say one of them is constrained and the other is not constrained and then we if both fit the mark on screen is used but that does not apply here so with that you can um depending on what you pass you call the first or the second print and it works fine good in any case okay we have solved the problem we cannot use const views well sometimes now there's a reason we have cons in this language it protects us that converts runtime errors to compile time errors so how can we bring back Constance now once we have removed it when we pass the parameter so that's interesting so the first thing I tried is I call CBA instead of begin well we have standardized that with C plus plus 11 just for that purpose we want to make sure when we iterate all the elements of a collection that the elements are caused good oh not available for views okay views require with use you need that and they don't provide that well we have one view that provides C begin that string View where the elements are always caused sometimes we are funny people only standardize and and you should have been the discussions I had I was I was running from one uh-huh okay interesting to the next okay but you can use we have something better we have Global functions you can use stood C begin or stood range with CB game that's a compile time error now here because we you see what I do on top I call C begin and then I do an assignment so that should not compile oh it compiles for views okay C begin is either not available to to deal with that problem okay there was some success so some success was yes it's partially fixed so in C plus was 23 we will have C begin member and we will have the stood rangeless C begin working but not stood C begin excuse me am I close to code of conduct violation it's okay good I sometimes I don't understand things so I mean we have this code we have design C begin for that reason see begin is broken for views and we don't fix it and I propose it definitely it was projected my proposal so here's the learning you have first of all don't use stood C begin anymore with C plus 20. that's a good advice because you know every program is lazy so that's the first thing they try out they don't try out the stood ranges C begin but you should do that we didn't deprecate the CBN which but which we definitely should do then at least Okay so you think that's all it can't get worse never underestimate expert that standardized because they understand that all they say what's the problem we know that okay if you read this function you might declare the top a little bit different as a template parameter if you read this function would you assume that you cannot modify the element that's a trick question of course a trap question as an expert you know it can happen but you have to do a lot of dirty stuff well let me modify this function a little bit and say um let's iterate over elements in a collection that are passed so let's declare the element as cons autoreference and then print out the first and the second member let me use a zip View this CPU comes with C plus 23. zip View like I said put puts together the first element of two elements of two Collections and the second element and so on the and so on it makes it a pair so this is the effect good immediately you have application for that function wait with the picture the next slide is the important one um I want to do something special when the first element is two so let me write that then I want to put a star in front cool I know you don't make mistakes but I still make pit Stakes when I program I might write one assignment here you see it coming huh you think this should not compile it compiles that's the effect so I want to find out that the designers of use have killed const completely it's not that this const is sometimes ignored by views it's also that that cons is sometimes ignored by views for good reasons there are use cases for that but how do I teach C plus plus now yeah and and when I complain they say but but that was always possible yes of course it was possible but you know it was possible when you used objects where the members are references that's not normal that's not typical that's a very special case and a very special things and and everything everything in your head should say alarm if you see references as members which are used here but you don't see them you just run into this trap as an ordinary programmer and I think that's not okay it's not okay to ship this just because it's possible already to ships as a major simple to use feature for ordinary programmers are we done no can't if you use it is not propagated well usually you would say if I declare a collection const the elements are cons that applies to containers that applies to arrays but that's not true for views all the code above but says let me copy again up front or the index operator and use an assignment here so modify the element is valid if you pass Vector drop 3. well not always now let's get really funny um only if the view you have operates on an L value on a range with a name if it operates on an R value then const is propagated why is somebody doing that foreign to fix that your code has to do the following you as a caller have to say please I know you wanted cons but this cons has no effect because I pass you a view so let me first convert this Vector to a cons and then call take or drop or whatsoever and pass it uh and by the way in C plus 23 we get and stood views as cons which you can use even after you have created The View and with that you also get an error here so it's a good thing if you get an error here that brings me to the question um what is the exact type of The View well um part of the example you just saw was this you have a function that returns a vector and you can initialize an object with that okay and now you say um let's pipe this object to drop so what you get is a combination of two views once it's a ref view that's just the wrapper that refers to the container so that we can use the container as a view and then the real work so because we want to app if we want to drop the first two element is done by the drop view which requires that it gets a view so we do this in Direction otherwise all the all the views like Drop would be more complicated so what you get here is a drop view of a review of a vector of end and it looks always very nice if you skip the namespaces but it's at if you um use a temporary object um you get something different which is um then what you what do you what you pipe into drop is an R value so it's about to die and if you follow the original standard that was invalid code but that was fixed in C plus 20 and in C plus 20 they inserted an awning view which simply moves the temporary object into a view so you see the view owns the elements and the values and and and and the vector and then a drop view is on top of that and and that has the effect that on the left unfortunately ref you propagates not cons but the owning view propagates costs and you want to read about that and then the C plus standard that's a problem there's nothing about owning views in the C plus 20 standard because it was not there when it was done it was added later as fixed um so where where can I find C plus plus 20 as it is now with all the fixes no way you can find a document where all where you have in addition all the C plus plus 23 features so we have no document that says this is C plus plus 20 with all the fixes and that's an important fix it changes a lot okay let me um summarize a little bit Where We Are so before C plus plus views I would write a print function this way template parameter can't see reference cons Auto reference the elements everything is constant C plus plus 20. and C plus was 23 now and you should do it the following way take the argument as a universal reference the Declaration of element you can do it that way one way or the other and then you should on the right hand side of the column use acid is used as cons of the collection so fix all your code above to the code below and it becomes usable for views you have a task now switching to C plus 20. you see it and please don't use stood as cons because the Sunnah committee preferred to confuse you even more because we haven't asked const that is similar but not the same it also makes something cons but it makes the object cons not the elements so if we use the const here it will compile but have no effect because as you know if you make a view cons it has no effect we need so it views as cons because that makes the elements cause cool but nasty the last time we had something cool but nasty was the two ampersands sometimes being r value references sometimes being Universal references and we ran into trouble and trouble and trouble and trouble and we will do have the same here I promise there are other ways to deal with that code now so this is a way you can do that so we can have we will have in C plus 23 and you concept that says um is it a is this range const but that doesn't mean that really means it has to be const so this is not true for a range that is not const so it does not mean it's can it used as a cons or so so if it's cons let's do our work else and that's a compile time decision let's call me again call myself after I made myself cast on the reflector when this was proposed by Thomas somebody said oh that's a really cool solution of this problem I have another idea of a cool solution of all these problems trust me I really have it oh I'll be done with the problems I have still time yet okay more problems to come so we didn't talk about modifications so look at this code we have a vector and we call print and then I check out which one of the elements is even and I create a view with that I say my collection pipe into a filter that is even so call even is arranged that only has the even elements of this vector and then I can use it for example simple in a range-based for Loop and say um each even element increment two and do it again everything works fine until you knew that this would come now ah shop right we need a short break now there's an audio delay so we wait so there's a problem with this code and the good cup so I can drink something and you think about which problem is coming here so everybody's going now oh God no no that should be fixed in a minute so you give me an okay or what I think the okay has to come from the audio people we will continue the Keynote oh thank you oh they come back that's good officials okay is it we can continue we can continue so he has a solution to the problem I mean he has a solution which tells you what problem we have here let me increment the value so not at 2 let me add one only the even elements which then became odd elements so let me do it once let me do it twice oh so the second Loop says let's iterate over the even elements of this collection and it converts five to a six why we cash yeah we cash begin we don't double check what we cash I don't I don't know if if you see the depth and severity of this problem which came up with with others when we talked about that this is officially undefined Behavior already the first one so now think about major use cases of a filter why do you have a filter you have a filter because you want to find elements that have a predicate to change them so that they no longer fulfill the predicate that's a very very very common use case so unfortunately the use case is broken and it's a runtime error so we have a statement in the standard for the filter view saying a modification with a filter view iterator results in undefined Behavior if the resulting value does not satisfy the filter bracket so we care about real world problems so Patrice came immediately with that example um that means I cannot iterate over a list of monsters and resurrect those who are dead no that's undefined Behavior just because we cash okay you can burn the monster the Dead provided they are still that then you never know in this monster world but how do you fix that ad hoc so don't specify them early and use them multiple times use them at talk so why do we cash begin then if we only use them once a hawk may I ask this question ah you see my problem is it do you want to have more sure here it is vector and a list let's drop the first two elements let's insert the new element and that's use of you to print out the elements so this prints out the elements of the vector on the list skip skipping the first two elements as expected I would say instead a few other elements and print that out oh oh okay so in the vector um we skip now the first two elements in the list we skip the first one two three four five elements six elements because we cash began now here comes the fun part you can heal this code by creating a copy of The View [Laughter] by the way means a copy of a view has may have a different state this this is called we can put it in X compile Explorer this isn't working example this is what we standardize now it gets even worse um May I inspect here after the first statement what the elements are and call Print here oh yeah but the behavior of my code changes look at that and now an early print changes the behavior of this program so just to make it clear we have introduced caching we learn that as a consequence we should use views at talk so we no longer need caching and the consequences that a read statement is no longer a read statement that whether or not I have a read statement changes the following behavior and see what well see what we have to have for values oh no let me change this a little bit more and say oh let's use a filter here and say um that we filled out only the elements that are greater than than equal um so sorry um so you see this has only elements greater than zero but here you have a zero because that was the element we cached no that was not the element we cached why do why do we get that hmm okay wait a minute okay so um so we have we call Print here follow the vector the vector um the the caches here begin and then we add a new element then we have that but here it's right so why don't we get here the three because we learned that filters cache well they have a very smart and said oh in this particular situation we do the following trick then a vector catches begin it doesn't cache begin it caches the offset some people break together in the room okay um yes that's a feature that's not a bug that's a feature so enjoy predicting what happens if you use a view and you have modification while the view exists and if we call Reserve yeah we get undefined Behavior because we might have catched something or use something that is no longer valid depending on the circumstances which range type of range we have which filter we have and so on and so on oh my goodness again you fix this don't do that don't do that never create a view and use it not ad hoc but then the question is why the hell do we cash so we have a couple of idioms we learned and we deal with containers and with arrays you can iterate if the range is caused a read does not change Behavior const makes the elements immutable C begin makes the elements immutable concurrent iterations are safe as long as they don't modify of course a copy of range has the same state all of these idioms are broken with views and sometimes only sometimes sometimes they are always broken do you think this is a good design I have some doubts I honestly have some doubts and let me come back to the initial example it turned out that this is broken because we did pass the view to multiple threads they concurrently call begin and that is undefined Behavior my I tried a lot to discuss that a lot a lot a lot a lot I learned that over time and each time I thought Okay I accept that the next problem came so the problem with with um that const for an element no longer works was sent me with a sub with a subject what the we just discussed it last week in Hawaii and everybody in the room thought that no we don't see a problem good design this will come in C plus 23. okay I have a consequence here I have a severe consequence here so we want to point out that the design of the standard views breaks several fundamental idioms that are well known and I really need to teach to beginners I know still experts can do a lot of things different but at the beginning I have to know something it's to benefit from caching we have all the problems we saw and then we don't propagate cons and we that all creates incredible confusion unnecessary undefined Behavior we compromise cons in a lot of places really bad and ugly workarounds and a lot of frustration because when I talk to that I've taught that already a couple of times and and people are in the middle of oh it's so cool it's such a nice thing it's rainless views great but should I use that or not sorry is that okay code of conduct so the important part is for ordinary programmers I think C plus plus standard views are completely broken as a library for ordinary programmers so you can use it you can make great things of that but you have to know a lot and I didn't tell you all the problems you can read them in the next book yes Nico what should we do I why did you why I got messages why didn't you say that two years ago well my time is limited I had to document C plus plus 17. and um 200 people standardize and at some time you you trust them that they know things like that and what is okay for programmers and what is what should be expert knowledge and what should be a library for ordinary programmers I was expecting too much in this time and yes don't get me wrong these are great experts they are really good people they really do incredible stuff but the outcome is a nightmare because a couple of decisions were made wrong simply wrong ah makeup do it better no we had to do that we had we run into this problem that problem and that was what we needed for a solution you know the problem is I think if you if you work if a couple of people work for five years on views all these problems become normal and say yeah we know that that's we don't need that and and that's why it is so important that we include I would have loved to have that t-shirt include beginners in the standout committee this is I don't know if if you agree with me but I hope you at least see the problem I have with that Library could we do better yes with the work they have done the Rangers folks have done great work and they also came up now with solutions for dealing with cons Etc with the work they have done we could have made it a lot better but somebody has to do the work I did I started to work on a system of views for C plus plus that just work started that's the important Point here the idea is that we have usability safety predictability performance iterating overview is always stateless you can always iterate when the viewers can't you can iterate concurrently read iterations have no impact on later code we respect the aliens of containers and errors we honor Constance we propagate consonants always not only for owning views a copy of a view is always has always the same state as a source more consistency in a couple of places so look at that this is how you can use Bell views the name has a nice feature because you can say instead of writing SCD here you write Bell there and with bellevue's you don't have the problems you saw so you can switch from one to the other and the design is that you can combine both standard views with values that's also the idea it's only the views it's not a new Range Library only the views this problem is solved you can resurrect a dead monster now this one is no undefined Behavior anymore dealing with multiple strats to read iterate over views every view is fine and cons is propagated if you make a view cons the elements are const always you can still copy The View and then the conscious is removed and of course this is also fixed so bellevue's will not have this strange Behavior that if you early Define a view and you have some modifications that suddenly the U does not work anymore so you can use these views more than just ad hoc and it's really fun that standard views have the power of lazy yellow evaluation so late use is natively supported and then due to caching it's it's probably yeah you can write great code with that you can say well let's define a view and then put a passage around and sooner or later and if it's 10 hours later you can use the viewer and it still works when I said this is a use case to those who standardize the random side because no that's not a common resource case you shouldn't do that okay but it's possible it would be better to do that and the price is not necessarily less a bad worse performance because as you know if we iterate only once all the caching is is it's a waste of time so if you want to do that there's a feature called eager begin so you just put in explicitly an element in the pipe saying and at this time please call it begin immediately so that we cache it by the way that's not anything invented by me I think um an explicit caching filter of you was already there and ranges V3 I don't know why it's not in the standard anymore this is an experiment but the experiment is so far that we have a lot of support there already you can find it at GitHub so it's github's bellevius it's it's not even better it's a this is a request for help I think it's time that we fix views and make them great because the concept is great I need your help for code for tests for reviews because sooner or later I have to document C plus 23. but we can already see how simple and safe the views ah all the code you have seen with bellevue's Works already and I don't promise to solve all the problems of C plus plus and the world now a lot of problems are suddenly gone the code uses um C plus plus 20 ranges so thanks for all the work with ranges so this is not a criticism on the ranges and Views in general it's just that we have made fundamental wrong decisions at a certain point of the path and then for some reason those who made this decision couldn't escape um and with the what they came up with the cons fixes I use that a lot I in that code so we can have a short look into that so so this is account state excuse me it's not very very very great already um you have seen the motivation a very very thorough motivation of this Library here's a shorter one and with a couple of key examples so how to use it and then a couple of key examples that explain where we fix existing broken code and then the design decisions the principles we have and the status the statuses on that I have the basic views of C plus 20. so Refuge owning view all and all T which is the underlying um mechanism to switch between or a ref view on owning view then drop View and drop take View and take filter View and filter transform View and transform drop by View and drop by and because I also make things want to make things more consistent we have a view where we don't have an adapter for and that is sub range so I also provide a sub view for that so that you can more consistently use all the views so ideally if you teach the whole system of views you never see the real types but it was not possible because we had an account standard we have no consistent support of this principle yeah a lot of things are open tests are already there but of course not complete um only only one or two people have looked at their harness as one of them thanks harness is he here and um it's um I don't want to write that I didn't want to fix threat with J thread I didn't run to fix broken atomics but it's time to fix this it's time to fix standard views I welcome and a lot of help please I think we can have something great look at that contact me help me to make this complete I think it's worth it if not tell me if you think it's worth it I would get like to get a big round of applause that's it thank you [Applause] any questions oh guy oh my goodness right okay first happy birthday Nico is 60 on Friday oh my goodness on Saturday so yeah thank you secondly great keynote actually that was really good and I thank you for the clear explanation of problems that we have with views um and we were in Hawaii so I'm on the standard Committee just to be clear we were in Hawaii last week and we were looking at lots of things like this um I think that actually the problem is that const propagation so 20 years ago um I eroticated I didn't write a game a bunch of Australia game called Rome Total War and const to propagation was the biggest problem that we had by Farber country mile and surely isn't all of this that you're describing just a different expression of const propagation failure and that as we learn that const does not propagate through objects in the same way this is what's happening here not the thing to learn is that cons is limited in its application we can discuss about the world and and that means the programming language where we have different idioms and one would be not to propagate consonants that has a lot of consequences a lot I think we agree on that so I think the answer on that is the easy answer on that is consistency I want to have it consistent and it's possible and I want to and and just to be clear I don't say pointers should propagate Constance I'm talk I'm talking about Collections and and we should make it very clear that a collection type A Range has a different semantics than a pointer we have problems with that because raw arrays can be used as pointers we know that and then but but here I think it's important that we that we have it consistent and especially as we have existing generic code and existing understanding of what a const means for a collection and I think based on that we should go on with this consistency and not surprise people we can't surprise them but not with the same API then I would suggest that we come up with something different so your suggestion then is that const should propagate not through indirect types but it should propagate three collections well first of all I don't say cons should always propagate that let me be very clear on that I all I say and all we Implement in Bellevue is um f um a viewer's cons the elements are cons whatever that means if there's an shared pointer the underlying object is still not const it's just that we have it one level down and I want to have it everywhere the same in containers in owning views and in referring views and that's not the case now spans that is interesting that you ask for spans I I was thinking about that and so far I I did not decide to implement span I think span is something different so I can live with span having different rules um it yeah so I have no clearance on that okay yeah so and and there's a reason span is so far not in the in the in the bellevue's list thank you very much thank you bye uh thanks for the talk um so I have a very practical question uh since you mentioned the net so standard ranges uh Concepts will work with references will work with elderly reference it's like vector reference is a forward range uh but and forward iterator standard for iterator and if I have instar ref that will be a forward the trade but standard regular is not applicable to ins in reference for example so my question is when you write Concepts do you think you should remove references from them and so like make Concepts work with references or not what's your opinion I have no opinion on that I'm very very thankful for those who came up with this with the concepts we have in the standard um that was big design behind and based on the experience of implemented ranges and they have they have made have had to make all these trade-offs and so far I didn't see a severe problem but something that was surprising so I'm not able to answer that that question so I would have to think about that thank you thank you yeah hi thanks for the talk um I've one practical question you said there are some solutions to some of those problems is there somewhere a list of what type of ranges to use and what we can use what we should not use and do you have some yes some hints on that well first of all views branches use are the issues sorry yes yes then um you can use them all you have to know the price so and and it's not easy to understand the price so um let me show you something where is it so this is pure advertisement thanks for the question I paid him 100 bucks to ask that question um I have a section in this books it's called view types in detail and the idea is that for each and every View you see if he on top a list of the major aspect such review has so can it be created with a factory or with which factories and what did they do what is the element type is it a reference or is it a value what is the category that the resulting category is it the science range uh is it a common range that means is it is it um are the types of begin and end the same does it cache um is it constant terrible does it propagate constant that that that that alone is something you need and once you need that and you know that of course you can deal with that the problem of course that if you say well I have a vector then I take a filter then I take another view and another view in another view and and you have a chain of 10 views and you really have a problem to find out the resulting attributes because each and every filter in front might have an impact on the behavior of the filter behind so still even if we have Bell views we have issues but um yeah use them all as you like you can also you know how to use a filter now and the question is as always do I remember next week and the reason is the answer is everybody who programs with use has to buy this book you got my account [Laughter] thanks a lot yeah no but of course we need documentation and the problem is that's one problem in the standardization those who standardize have an idea how to use things but they don't come up with documentation that for some reason now my part is Scott Myers went out of the business and um and others write good books do here oh my goodness so they sit here and um but um it's not part of standardization to document how to use that and to be honest sometimes we don't know how to use it we love it the hard way like here hey uh thank you for the talk uh so it's a pretty green picture of the Stoneham the views right no doubt we can build a better library right like Bellevue I don't know but how much of the standard views we can actually fix in the standard without having something like ranges 2 or Bell views or something I want something in the standard that addresses all of your concerns especially with beginners without well breaking its before we even use it so one thing guy didn't tell you that last week in Hawaii they fixed the range base for Loop which was broken for 30 years [Applause] I was driving that that's why the Applause comes and it took me to fight for that so of course I know well well I I said something about Wranglers again and again and I know I know the reaction and currently those who decide will say are you crazy they might hate me I don't know they might at least nobody is happy if I come and say well you work for three years is broken for some people great but we have a problem and then we have the problem that once we have something at the standard we really need good support to fix things so I could imagine that it's pretty easy for example to remove caching but is there a will to do that I will not even try to find that out I will definitely not no no way so that's a problem we could do a lot and the question is of course then what is broken when we fix the range base follow we can at least theoretically see some broken code and then broken by not compiling runtime error or performance gets worse and the same question is here so if somebody uses a view and then we remove caching and it uses the view one thousand times then there's a problem we would even have a rock around but we have to fix the code so it came down at the end the fix of the range based for Loop came at the end down do we want to do all the million of basic programmers a favor to fix the range base for Loop risking that some expats have to fix tricky code if that would be a general guideline in standardization I could see fixes here in the existing code base but you know it it would have to start that all those who have done the work listen to me one or two hours to this talk and just listen to me and not immediately say no begin as fast we have no threat problem that's what the authors tell me as an answer are you sure that we have a severe problem with caching that's what I get back in this in this teeth that's another way to fix that send back reports over back reports so you should have done that as a range base follow because one problem was they said oh we never get back reports with that and and I I know a couple of people who run into that back they say yeah well usually so C plus is so complex I could not imagine that I am the not the problem let's say something about where we are with C plus plus so I don't think there's a way to do that I think this will be maybe it's a it's a it's a library that's used we will have standard views and that's it that's it so thank you so Nico oh hey a few questions from the online audience so hi everybody um given the growing number of problems and consistency in the standard Library do you think it is time for the standards committee to consider breaking revision I think it's time to switch to a new programming language wait we talk about something that takes for years and centuries I think we have learned enough we have made enough mistakes we have adopted a lot and there's a reason I think that we see new new things evolve nobody knows what will happen in 10 or 5 or 15 years or so but I think it's time to come up with something better that doesn't mean that we will not have C plus plus in 20 years we still have Fortran so no don't worry I I always have a problem that in the committee some people think C plus plus is my baby and you should not criticize it so sometimes my talks are rejected at conferences with the argument too much criticism of C plus plus yeah honestly I'm not sure I can have this talk at a conference like cpp.com and um I think it's time we have four million programmers yeah support that but also say hey we did the best we could we have problems we have more and more problems because we have mistakes we have a problem with backward compatibility and and and and there comes a point with where the problems really become big and we have to talk about backward compatibility and a lot is going on those who have been in Hawaii know that because more and more people say C plus plus is no longer a safe language and in in our world we need a safe language and um this is also not so safe I think foreign yeah we need something better sure so isn't a view basically arranged over specialized iterators what's the difference of sdl views to boost iterator range and the corresponding transforming filtering adapters does the Boost solution exhibit similar problems I can't say anything about that I don't know why is the cache begin not implemented with a mutable member as far as I know that was discussed actually I don't know the answer okay I think there are a couple of good answers for that so you run into other problems um please also note that we would only solve the const problem we would not solve the problem we have because we cash and then later on if you use the view you should not use the same begin you have to start from scratch again so on the we would have a partial solution of the problems we have okay that's it oh that was easy hello hello thank you for the great talk um I've I while listening to our talk uh and uh about all all problems that you discussed most of the things I've seen uh from from my perspective it appears that uh our Pro are related to problem with backward compatibility for example if you use uh ranges I mean views in a way they are meant to be used with pipes and filters and so on uh and then combine that with the old-fashioned of range base for Loop then you've got the problems with caching and everything that you explained but I wonder what if instead of writing our four based uh printing uh function or or some other processing instead of that I write a Lambda and use it as a filter so it's so-called filtering Lambda would I then have the same problems with the caching and uh dangling and everything you explained in your uh talk today I'm not one of these smart guys that can understand your question without seeing code and feeling it so we can talk about that offline and but what I learned if I learned one thing in my career with C plus it's um a cool idea is nothing until you implement it and and you see all the problems and you really come up to some pain points and Corner cases so it was also that we thought um for example it could be give up borrowed ranges if you know about that is with bad views and we pointed if we we found no we couldn't so yeah the devil is in the detail that is always the case so yeah there are a lot of simple answers probably but then the work starts yeah but I just meant if we just stick to one idiom for example if whenever you use using views if you just stick to idioms of using lambdas that are best to filter yeah we could do that in other ways we could do that but then we should make sure that existing code cannot be used for views so views have a have a different landscape or different context where they are which on the other hand means that we have some problems because um of course it has a creates a great benefit to use existing generic code also with views so it's an interesting trade-off I'm not sure which one is better I mean what I really want to would like to avoid is something like in Java that we have 10 libraries for each problem um so yeah there's no easy answer thank you that's a consultant's answer we quote lots of people this isn't a question more of a comment um tomorrow evening we've got an AMA with imbal Levy um most people might not realize that she's the chair of the ranges study group for the committee so oh I didn't know that there may be some interesting questions to be asked then I will not be there but because I I really don't want to discuss that until I know that the rangelets committee is ready for this discussion and that means because we really had not the best communication when we talked about that um one problem was that it took me so long to come up with this talk so to say I understand in in the whole deepness how things are combined and probably I overlooked something and I was later on say oh maybe I was wrong but um yeah that's good we should work on everything okay thanks Nicole again for persisting was pointing out all these difficulties in the standard and never getting tired of it I get tired I can't tell you the question I don't expect you to have an answer to Is how in the future we can prevent these yeah fuck-ups and um it seems like there may be steel or and looking forward to a new feature in a z-plus bus standard everybody was excited to get views and ranges in the C plus plus 20. yeah so nobody wanted to say no let's stop that so I I propose to remove Concepts and not I can't contracts and it was accepted yeah sometimes it's worked but yeah I think contracts is not a picture like like 90 of the C plus developers were looking forward to but views and ranges was something that was so much promoted because it took years yeah to get it along and then in the end it fails and okay and it's not usable as it seems so it's it's really interesting and I thought a lot about that and discussed that with others um at first standardization should standardize existing practice and we violate that rule we we design core routines on the Fly we design modules on the Fly we design views well it's three years old and and that's the fun part views and ranges were three years or four years old and I don't know when Eric started with that and then um but but there's nothing nothing better than we need support by the compilers and then experience what goes on there but to get support by the compilers the compilers have to know that what they do is is work there they don't regret so it has to be standardized so the best model I have in mind is to say when we come up with something like this then for one or two releases we stop the guarantee for backward compatibility so we say views are in but don't complain until C plus was 26 if you have to modify your code if you use it that is the best model I can see because we have better standards file system was an example and we got some problems in the standard because people don't look at that including me I have enough to do to look at at what is standardized so I have no benefit and maybe you know when we started 25 years ago with standardization well not we others but I I was there when the first standard in 1998 was published and voted we came together we had no mobile phones no internet no laptops so everybody who came there had printed out everything on paper the whole standard and then we discussed today our speed is incredible better but I think we are too fast I honestly think we are too fast except of course the things I want to have in that's too slow about that yeah okay that's it do you want to say something again oh thank you very much thank you Nico that was a great keynote and it's 12 now so the lunch will be ready outside so if you are hungry go and have something to eat and something to drink and we will be back with a normal program at I think starting around one o'clock and