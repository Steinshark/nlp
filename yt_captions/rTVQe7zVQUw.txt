thank you jens thanks for inviting me um happy to be here i was catching a few of the sessions earlier today that were very good um so for those of you who do not know me um i'm a sequel plus programmer since the mid 1990s i've worked on a lot of different kinds of systems um i am the author of boost date time i got involved in boost in the early 2000s um and uh was one of the original authors on the chrono proposals for c plus plus 11 and been in and out working on the standardization committee right now i spend my time on the library working group which means that i read every single paper that comes to the library and so part of what i do is i try to take notes and prepare so that when the standard is actually getting uh to be finished i can make presentations to the community and we can see what's going to happen uh in sequels plus uh in future versions of sequels plus so that's what this presentation is um for those of you who don't you know live and breathe by what the standard committee is doing on a daily basis um you'll know that sequels plus despite the pandemic is going to ship on time and that's just a fundamental part of how the sequels plus committee structures itself uh since equals plus 11. uh we call the train model so basically whatever is there on the train ready to go uh when it's time to ship the next version of the standard will go into the standard now that doesn't mean that there's no thought or preparation put into [Music] you know what we want to have in a particular release there is a plan you can read the link there so that's another thing you'll see throughout this presentation i have links to the various papers if you want to dig in but there's a plan and there's a focus and my focus today is on the library but one interesting feature of the sequels plus 23 plan is it didn't really have um a big plan for language features uh which is uh not surprising given that c plus plus 20 was a very large set of language features including concepts and um so uh anyway 23 was sort of destined to be more smaller in the first place but as you'll see the pandemic is definitely having an effect as well on the library side the big features that people were uh prioritizing are networking modules support uh concurrency support and bug fixes so bug fixes uh may surprise you but um oops uh let's see if i can you know use the slides properly so the thing is of course with plans is it plans our plans and then there's the reality uh of what happened and of course kovid is the big reality that has really changed things um the seaplus plus committee has basically always depended on face-to-face meetings that's been it's real uh the way that the committee has always worked and so because of the pandemic the last meeting was in prague in february of 2020 which was basically where c plus plus 20 was finally shipped and so um the feature freeze for c plus 23 is only a few months away it's in february of 2022 and the committee will not be meeting till at least uh june of 2022 so the bottom line is that the features for c plus plus 23 have been almost completely developed uh uh doing virtual work um and i think there's no question that that makes it very difficult in certain sorts of features that need a lot of back and forth uh understanding and uh under you know working through corner cases and so forth those things are just much easier to do uh face to face um you know than than they are on a zoom meeting um in addition to that there's the time zone effect we have worldwide participation um and getting time zones you know that everybody can work in and so forth is difficult at times so what's basically happened is many of the subgroups like the library evolution group the library group we're meeting on a weekly sort of basis typically for an hour and a half and we're trying to work through uh and do features so long story short uh c plus plus 23 is going to be a smaller release i don't think there's any question it would be hard not to be a smaller release than c plus plus 20 because it was so large and there's going to be a fair number of bug fixes i'm going to talk about some of those today and i think that's probably actually really a good thing we needed to change some of the things that we did in c plus plus 20. so those priorities again um yeah um so two big library features um you know that were shipped in c plus 20 were format and ranges and some pretty um big changes have been made and many of those changes have been back ported um actually into c plus 20. we'll talk about that at least at a very high level i'm not going to go through all the details of it the good news is if you hadn't started trying to use the experimental versions of things you won't ever notice you'll just get a better product the changes wouldn't have been made um uh if we didn't think that at the end it was going to be a superior product and it was better to break things before we had 5 million users actually you know depending on these particular facilities support for modules we are getting some support for that and we'll see that i'm going to talk about that today concurrency support with co-routines things like standard generator some of the center receiver stuff um those are things that um you know there's still some work going on we'll see what happens with them i think uh for today's today's presentation i'm gonna be focused more on things that are more of a certainty to arrive actually in c plus plus 23. those things are still in a lot of work so ranges in format in addition to the bug fixes are getting a lot of additional things and then there's just another whole category here which was sort of uh mopping up a whole series of features that didn't make it into c plus 20 because we ran out of time um and a lot of those things are are coming in sql plus 23. okay so here's the outline of the talk um and i know yen's has given me a little bit more time than i had at cppcon but for a variety of reasons i'm probably not going to go too much longer than i went at cppcon um and i will give you links here to uh you know let you guys go explore all these facilities many of these things have open source and so forth that you can go look at and the other thing i'll mention at this point is i'm going to keep this talk updated so you'll be able to go back and as things change as things get pulled out or things get altered in some way i will keep the slides up to date so you can actually use it as a reference going forward in the future so there's a long list of things here um just even the categories themselves uh would make a big talk and so kind of the way i'm going to structure this is i'm going to pick and choose a few things i do have slides for some of the things i'm not talking about i'm not for everything i'll show you things i'm just not talking about at all but i do have slides for a bunch of these things like i say you can go investigate those things if you want i'm not sure yen's how if we can do the audience participation easily but we'll see when we get down a little further in the presentation so some things i'm definitely not gonna cover today um and it's not because these things aren't important it's just um you know there's a limit to how much you can do in a talk uh and in addition to that some of these things are still in flight so you see all the things at the top here are still under consideration uh by the committee and so it's unclear whether those things some things are closer than other things and like with freestanding and flat map and flat set uh i've give you i haven't given you the references here but there's several papers uh for those things at the bottom here move only function that's actually done it's actually in the working draft but i'm just not going to talk about it today so as well as in bocar the extended floating point i'll mention that just briefly because floating point numbers are important in a lot of domains that's highly recognized by the committee we understand that there's a large group of people you know machine learning embedded in other spaces that want to be able to use different kinds of floating point types and so this paper here 1467 [Music] would open up the standard to allowing that capability there's an additional set of papers the c committee the c standard committee is looking at a series of now sort of small floating point types and other floating point types beyond what c currently offers and we expect those will land in c23 uh which should come out about the same time as uh the the next generation sequel plus standard so i'm not quite sure what's going to happen with those i think those might take 26 before those are officially recognized but since part of the c standard they would uh likely get in your c compilers sooner than later okay um so let me see um so jens i guess i cannot see the chat here um [Music] so okay i don't know if if anyone can send me questions or not but if you have questions do what you can to send those and i'll see if i get to see them okay so let's talk about string processing um why do i put string processing first well i think the the reason for me really is that uh every non-trivial program i've ever written of course involves some kind of string processing whether it's secondary or primary to the function of the programs and so it's important for a very large number of programmers and so some of these things are very simple i'm going to talk through the first two uh i'll just briefly mention that resize and overwrite um is a performance optimization for cases where you're going to reuse a strong string and you need to be able to resize it and rewrite data in the buffer it gives you direct access to the buffer the string view constructor is a very simple thing that allows you to construct a string view from a range so i won't talk anymore about those in any detail so let's talk about the very first thing which is just being able to figure out if another string is in a string uh it's the simplest possible thing you can imagine and um it's unfortunately been lacking uh you know you've written the find commands and used iterators and so forth you'll know that this is a very nice uh thing we also if as a reminder we got starts with and ends with in c plus plus 20. so this contains is really the bookend to those uh to those features um to sort of allow you to to do some very basic uh string things uh in a nice way and of course this is uh in string view as well and you'll see this is already implemented in all the major uh compilers so that's an easy one this one is a little bit more uh it takes a little bit more explanation i guess um so this particular code if i have a function do it like this and i have some complex set of logic uh in here and i end up in some place returning or constructing a string with a null putter currently in sql plus 20 you will get a runtime exception or runtime error which is an unfortunate fact because in this case it's absolutely clear that the compiler can deduce the fact that uh you're constructing the string with a null pointer so what what's happened in c plus plus 23 indeed is we've uh made that constructor fail and so you will now receive a compile time error instead of a runtime error if you attempt to construct a string with a null pointer so again these are small things it's a that's one less razor blade uh you know as part of c plus plus uh something you know that you might run into okay see how i'm doing okay um so let's talk about modules um modules of course is a c plus plus 20 feature uh which was great but with c plus plus 20 modules we didn't really get anything in the way of support for the standard library module module being modular itself um so and of course uh sql plus 20 modules change the compilation model in a fundamental fashion from the way we've been doing it from the very beginning um if you think a little bit about what pound include and that model actually entails what it means essentially is a cut and paste of every single include file into your translation unit as you compile it so the inefficiencies of this are well understood and well known you in many complex projects get literally hundreds of files that need to be accessed in a translation unit which basically means reprocessing those files over and over and over again and so that's one of the fundamental you know the fundamental thing that modules is there to address in addition it has extra features for being able to support access control in a finer grained way than we could in the past uh for example excluding all macros so that you know with pound includes you get macros whether you want them or not with sound with import you will not uh get macros typically um so uh modules are supported by a non-binary or a binary um a binary form uh translation of the header that's not fully standardized as it were but basically each compiler is going to have their own they're all talking to each other now they're talking about having a shared one we'll see what happens with that um but header modules were uh sort of a special case uh which allowed you to create a header from a header unit like iostream uh to create a module so that was one way and this is one way actually you can you do standard library modules today on some of the platforms as you can use header modules in which case you just you know turn an include into an import and you know then you'll be using modules the thing about the headers is is that really the right model uh and that's really the question uh that needed to be asked for standard library model modules and there's been a number of different proposals and discussions over the years trying to figure out what the right level of things is and in particular you know how do we want to name things how do we want to divide things up at one extreme you can imagine that you know we would have one module for every single type which sounds like a nightmare to me because then i'd have to say pound import for every single thing that i i wanted out of the standard library um sorry i keep saying pound import there is no pound on import as you'll see in a minute so uh we could have one for each type at the other extreme we could have import std which would get you the entire standard library uh no questions asked and in between there's things you know where we could have things like standard algorithm standard container but the question is yeah how do we make the right size for programmers what's the right uh divisions there so going along with that consideration of the granularity are things like you know what is it that we want in terms of uh teachability for example well import std is super easy to understand it's also super easy to move code to that because you know you only need one import in every single file and you can get rid of your standard library includes so that's really a nice feature of that the thing about it is that c and c plus plus have been together for a long time and non-trivial sequels plus programs also have macros in them like assert in particular is one that's commonly used um it's also the case that there's a number of c functions that are in the global name space that come from sql plus headers so what do we want to do about that global namespace and ideally modules would not modify that global namespace they would in fact just you know stick to std and sub name spaces of the standard is one of the considerations so it might surprise you learn that in fact the answer that the committee has decided on for sql plus 23 uh at least there will still be some consideration of other options but for c plus 23 you're going to get two modules essentially import std and import std.compat and that second one is really there for things like f open and some of the other global namespace things from c if you want macros you're going to have to pound include them the good news is modules are completely compatible with inclusion as well so you can still pound include and so i think the goal basically is this is a straightforward way that we can move things forward and get modules being used in practice it's also simple for programmers it's also super simple to teach and understand and to be honest with you i really like the idea of not having to remember uh what thing is in algorithm versus ranges versus whatever that old model actually doesn't really add any value to my life it just makes me have to remember where certain things are so of course the question you're asking yourself is you know what does this do to compilation times if we import the entire standard library as one single module every single function every single type what does it do well so uh bjornis drew strip and microsoft and some others got together and in fact uh did uh some testing of of this and essentially uh you can you can afford it um so import std uh is in this particular experiment 10 times faster than a pound include of iostream so that's good news in that the standard library in full can be made available there's some other numbers on these slides i won't dwell on them if you want to see more about the methodology and what they did to do these measurements you can look at p 24-12 but their summary at the end of you know looking at this and doing some analysis of this is they're expecting you know that a realistic real world kind of example would be somewhere in the range of 5 to 25 times faster for in for modules as opposed to pound include so uh let's hope they're right um because that would be fantastic and it would be a fantastic uh thing for sequels plus programmers uh uh but it would mean less coffee breaks so uh that might be a little bit of an issue okay so um this one as i mentioned this is a high on the priority list uh the final wording approval and design approval is pending and so basically uh these two papers here talk about uh these things uh and i expect fully that uh we will see this ship in sql plus 23. okay so next um let me talk a little bit about input and output um and so of course in c plus 20 we got std format which is a printf style way to format outbound text into a standard string and one of the additions to this there's some additions and changes to that i'll talk about but then also why not be able to just go directly to the console or directly to a file so that's what std print will bring us and then in addition to that if you've worked at all with the format capability you know that you have to do template specialization not everything that's a part of the standard library has a template specialization for format so that leaves users having to do that for themselves or work around it in some other way and then formatting for ranges this could have gone in the ranges section but i'm putting it in here because it goes with the rest of the i o this is something that's really interesting and really valuable and then the last one here is actually even though we're making a major initiative at least on the output side here to change the way we do output we still have streams and we're going to still have streams for a very long time and spanstream is actually in addition to that and i probably will skip over that um the slides are there you know the author of the paper is at the conference i saw peter summerland earlier on one of the sessions so you can chat with him and ask him about it as well but it's valuable in certain particular cases okay so i think i said all of that so let's look at a you know format from c plus 20 example this is a very simple example i have two values a string and an integer on the right hand side here they get passed into the format the problem with this is that my format specifier here for the second parameter is a string and not an integer or decimal value like it needs to be and as a result in c plus plus 20 what as it was shipped what would have happened is i would have gotten an invalid format specifier at run time as a runtime error and that's problematic in particular given in the modern world we live in things like this even in c this kind of specifier mismatch can be detected and warned on at least by the compiler if not giving you an error and so we would really like this since this is a static string um you know it's a you know constant static string at compile time we would really like this to not compile and give you a warning and indeed that's what it's going to do this is one of those fixes that was a back port to c plus plus 20 so c plus 20 is going to work this way if you are using the fmt library the fnt library has already implemented this and this is actually output from that library in terms of what it looked like before and what it looked like after and so there's actually a couple of links here you can go and play with that yourself with the different versions and see how how things have changed i'm omitting a whole series of other related issues with the format api that came up when implementers really went to go implement it there were some other issues that meant that that was going to expand the size of the compiled code in a way that vendors thought was unacceptable so there are other changes that went in uh and that's why it's a complete breaking change all of those fixes are back ported to c plus plus 20 so when you get official c plus plus 20 support from a compiler they will have done all of these changes and you will see them so the whole idea of it being a runtime error will not exist you can still by the way do run time formatted strings you just have to use a different api for for doing that so if you're familiar with the format you know that you could provide a runtime string which would over override a number of those things i'll also uh give a shout out to charles barto's talk from this year's cppcon 2021. if you want to know all the inside gory details of what happened in format um you can go see his talk because he talks about uh exactly what happened uh he's part of the microsoft implementation team uh and he talks about uh what they went through and some of the issues uh that that happened as part of format okay so let's talk about print uh as i was mentioning print is exactly the same as format except for now we're not going to just restrict you to uh formatting to a string so that first bit of code that's highlighted is c plus plus 20. um but in sql 23 there'll be a new header called print and that will allow you to do the same thing directly to the console without any anything in the way it will also allow you to do the same thing into a file or into a file stream so you have the ability or actually any any kind of io stream are sorry output stream so um the new spam stream would be able to support this as well um so this will allow you to uh do that directly now there's another thing i'm not going to talk a lot about here um but one of the new elements of this is there are some overloads that are part of the whole print and formatting regime here that give better support for unicode for those who work with unicode you know that it's a troublesome area for c plus plus in in many respects um so um that is also part of this improvement you can go look at the papers and see more information about that um this is actually really cool we are using this in the stuff that we're working on that my team is working on currently and i find it to be really nice so we're at a point with the print functionality where you do not need to use streams really for doing output so you know with maybe the exception maybe you're going to use them for files or something like that but largely you don't you don't need to use the iostream formatting facilities you can use these facilities instead so again this stuff is available in the fmt library there will by the way be a print line version so you don't have to put the backslash n in if you want to get a line feed the one caveat i'll mention about this is this is not implemented currently in fmt so if you go looking for uh print println uh even though it's part of the standard proposal it's not actually in the library itself so again with the godbolt links you can you can go play with these things after the session on your own and see what they can do so i think i mentioned almost all of this this is in some final design review it has not cleared lewg completely yet but it has a sched time that's scheduled for it to be completed it's had several rounds of reviews so it's in very good shape and i expect it it will get through to c plus 23. so uh of course it also if you're familiar with format you're interested in the performance this is one of the reasons this initiative uh is strongly supported uh and if you look carefully at these numbers uh what you'll see here uh this is uh you know the standard for print the i o stream is approximately three times slower what's interesting is it's it's pretty close so it may just be within the noise of the performance measurement but it's as fast as c's printf um it's actually faster in the measurement and you could actually see where maybe c plus has an advantage here because it can do some things at compile time that maybe c cannot uh with the var signature on printf um but in any case uh it's very fast which i is a perennial complaint with i o streams and so i think this gets you to a place where you know you could do all of your output anyway uh in this in this fashion so a couple links there for you to go later on as i mentioned at the top of this section specializations for other standard library types that don't have format specializations today some of them will get fixed some will not get fixed they're going to be continuing the big ones that won't be fixed are complex and file system path shared pointer unique pointer so those are going to slip into the next uh some other things that are like thread id and some of the reg x and error code are should be fixed okay so let me briefly talk about range formatting it would be wonderful right to be able to take a collection uh or another kind of range of some sort uh and and just be able to directly uh put that into the terminal i mean this has been one of those things where you know programmers have had to write their way around this uh sequels plus programmers have had to write their way around this for decades so right now if you look at the fmt library it has facilities for formatting ranges there is a proposal that will bring uh that to the standard um this is one i'm not 100 sure is gonna make it given the time uh there's some complexities to it uh when you consider recursive uh collections or you know multi layer collections and so forth but in large part it basically looks like what you see on the screen here here's a vector of values and in this case basically i have a format specification uh which says give me two wide with a hex value and then join them together with a colon and basically i'm this is c equals 20 format so i'm just basically generating that hex string um and then i'm putting it out to the console uh with the print um as a string so that just prints out what you see here um here's another one uh where i just take a collection of strings and uh uh you know i i get some output um that makes complete and utter sense for uh for that string now of course you can combine this with other range adapters and so forth so you know take two take five filter uh all kinds of other things that you can do uh that are very clever on some of the ranges slides i'll show you a couple of examples of that so you can go to the godbolt link you can go take a look at this paper and see what it proposes it does a lot more than what i showed here including handling complicated things like tuple and pear and some other things so a lot of uh really interesting work there that would make our life a lot lot easier for uh doing i o going forward all right as i mentioned i'm going to pretty much skip span stream i will show you this one slide [Music] but basically span stream allows control over the buffer that goes into the stream this was a feature that came from the original i o stream in the 80s look up peter he'll love to tell you about it i'm sure there's ice stream and no stream versions of it and uh it allows you to get spans in and out um uh as uh for example your primary uh utilization you can also make your buffer be other things um you know uh within uh within the span stream itself okay so that brings us to ranges now this talk um uh you know the entire talk could be about ranges there's enough material here um that we could talk about this all day which is another reason why i'm going to uh jump over and do some highlights there's multiple dimensions of new things here that change things so the first thing is fixes to c equals plus 20. we'll talk about that in a minute um so and as you know ranges are divided into algorithms and then range adapters and views so there's some of both of those um also added in and then one of the fundamental things that was missing is the ranges to capability so take a range and make it into a container now a range is a container uh in the first place but the idea is that you can take a filtered or you know some kind of processed range and you know have an output container which you would then put the result into this next one pipe support so if you've used range adapters with the pipe syntax you know that's a very convenient syntax it's very nice elegant code unfortunately with c plus 20 the way the standard is written while you could create your own user view you could not create one that has pipe support that interoperates with the standard library so that's something that we definitely want to rectify because there's no way the standard library will have all of the view support that you could ever imagine and of course we want users to be able to write their own you know so and we want them to be able to interoperate with things so i kind of think this is almost just a slight overlook from the c plus plus 20 uh ranges and you can consider it a bug fix but it it opens up an important thing uh and also means again we don't have to put every single conceivable view into c plus plus standard itself um and you know it opens up the boost and other libraries to provide those things in a way that you know operates well um next one [Music] interoperation with non-range algorithms uh we'll see about this one whether it's going to happen or not i'll briefly talk about it but basically this is the ability for non-range algorithms to play with ranges better and then this all didn't you know just happen um again there was a subplan here that barry rebson and tim song and some others uh connor hockstra put together uh you know to try and move ranges forward so uh they split the work up into tier one tier two tier three kind of work um and try to um you know lay out a plan for what was the most important set of facilities to bring uh in c plus 23. and a shout out to tina's presentation from this morning uh how to rangify your code uh if you did not see that presentation and you're just getting started with ranges i highly recommend it it was very good um and uh so definitely take a look at that okay so let's do the one minute review uh of ranges because i'm going to show you a bunch of code on the next slide and slides and you know just a little tiny bit of theory but basically write a range is just something that can be iterated over it has a beginning and the return iterators the classic collections and so forth we've had forever range algorithms of course then are algorithms that instead of taking iterators they will take a range of course all the ranges algorithms also take iterators but um predominantly we want to call the uh range versions of them when we can because it's simpler and it's better um and then views are just another form of range and they have this sort of lazy property it's not given that all of them are that way but for the most part they don't calculate things when they get constructed and they can be chained together with the adapters that's the last piece of it but they're cheap to copy some of the properties on views got changed as part of work for c plus plus 23 and they got back changed in c plus 20. so we used to think about views as never having ownership but that really isn't true because there are some exceptions to that rule for the most part it's true but there are important exceptions where we now actually have uh an owned view in the standard because when something uh you know when a view has to own something say a shared pointer to something underlying there are cases that we want to be still able to use views but so we have to relax some of the constraints that were originally there for c plus 20. okay so the simplest ranges code in the world is here's an array of values and i used to call it this way with begin and end uh and two iterators and now i just call it you know with ranges sort uh and that's it so you know that's for me again the 90 use case for developers is instead of calling a traditional algorithm that requires you to pass in the beginning end find a ranges variation of it if it exists and make a call to that it will do what you want and it will be cleaner and simpler okay so we got a whole host of new algorithms and some of these you might recognize some of them you may not start or sorry uh shift left and shift right were actually new regular algorithms in c plus plus 20. unfortunately the range versions of those algorithms did not make it into c plus plus 20. i'm not going to talk more in detail about those algorithms but again there are slides you can take a look at them full left and pulled right i'll talk in more detail about um i'll briefly cover starts with and ends with you can pretty much guess what those are going to be about um iota as an algorithm and not as a view so in c plus 20 we have iota view but now in sql 23 we're also going to have iota as an algorithm um that was missing from the range of id algorithms and then find last is kind of on the bubble i hope but find last is basically a way to quickly look backward through a range um if you've ever tried to write code with reverse iterator and so forth uh it's actually surprisingly difficult to get this code correct and so this is a nice utility and this would be both in ranges form and in non-ranges form as well all right so fold um uh fold is a generalization of the accumulate algorithm and if you have worked with the range's algorithm since equals plus 20 you know that accumulate was not one of the algorithms um and that was in part because none of the numeric type algorithms actually uh came about in sql squares 20. so um fold is uh the first of a few algorithms that i expect to see and this one will should be in c plus plus 20. so it's a generalization of accumulate just like other c plus plus 20 range algorithms it has projections so if you've worked with projections that's a way to filter the range as you as the algorithm processes it um and uh it takes um two forms the there well there's the directional part of it which is either go from left to right or go from right to left so in other words forward to back or back to forward and then there's the question of how do we specify the initial value with accumulate you have to always specify an initial value fold on the other hand allows you to either specify an initial value for the actual calculation or it allows you to use the first element of the range instead as that initial value so that's what this first underscore first and underscore last uh variance of it is those underscore first and last mean underscore first use the first value of the range as the initial value or when you're folding from the right you'd use the last value of the range as the initial value so here's a simple example the signature simplified of course you know looks something like this we get a range we get uh an initial value and there's the projection which is defaulted to do nothing so a very simple example is you know add the sequence of uh things in this vector together so it's just like you would expect from cumulate uh and you'll get a numeric uh result here okay so i think that's going to be kind of it on algorithms oh yeah i said i'd mention starts with an ends with so starts with an ends with does exactly what you think it's a predicate it's going to evaluate a range uh in this case i'm actually using uh an iota view which is interesting and it's going to evaluate that you know this first range 0 to 10 starts with the second range 0 to 5 and yes then you'll do something and so forth and ends with the same kind of concept and so you can do this very straightforwardly all right so views and adapters and here's where we can see a lot of major additions to the library so we have adjacent which was missing in adjacent transform which actually goes along with zip and zip transform so that's the ability to uh look at you know multiple elements in a sequence as you process through cartesian product which uh you know we'll i think we're going to skip over that one but you can look at the slides but that one's going to uh give you basically a an unrolled for loop or a series of for loops depending on how many uh different ranges you're putting together uh chunk and chunk by allow you to group parts of a range together and slide allows you to see a part of a range for a time and move that that view along a particular range and then join with um you might be thinking well we already have join uh which we did get in c plus plus 20. but join with allows you to take an additional delimiter and uh join a range together with uh that delimiter so uh i'm not gonna go over that one uh in more detail you can you can look at it elsewhere so let's let's just go back again and look at some sql plus 20 code here um so this is again ranges 101 code i have a standard vector event um i have a predicate here which just tells me whether or not a particular integer is an even value and then i'm using those properties i was mentioning previously about copy to cheap to copy and the laziness of a particular you know particular view to basically create you know a view here on the stack so uh this thing evens is the actual view uh it is made up of uh looking at the vector and then filtering it on even values but no calculation is really done at this time of construction that's really just the construction of the references and so forth to the underlying things to actually do something with the view i have to actually iterate over it uh intentionally so i have a range for a loop here where i just go through and print everything um i can do the exact same thing uh different ways this is a filter view version so instead of using the adapter here i'm just using the filter view uh and in this case i'm passing the vector and i'm passing the predicate to the constructor these things are exactly equivalent in terms of the underlying facility of how it works they're essentially synonyms for each other i think these days most people are preferring this adapter style where you you construct this now you by the way i could have constructed that right in line in this for loop as well in this particular case i just uh did it as a demonstration that you can you know capture it on the stack and then use it later okay so that's all just c plus plus 20. and so you know as i mentioned uh mistakes were made in c plus plus 20. um and so actually we had breakage in a bunch of different places um uh nikolai joshudus uh brought to the our attention uh inconsistencies in the way i stream view worked that was broken that should be fixed join view had some other similar issues some other issues split view was far less than optimal the way it worked so that actually got renamed to lazy split view and a superior version in particular for string processing is now called split view so this stuff was all backboarded it is all being backported to c plus 20. so if you haven't started using c plus 20 you can ignore it uh it'll just work the right way from the beginning um and you won't have known that it was uh not in an optimal form uh prior to fairly recently so okay so here's an example of that other case i mentioned at the top um non-range algorithms in ranges um so uh this is uh i've got you know my standard vector event here um and i'm using an adapter to do a transform and so i'm transforming each one of these elements by squaring them you know basically calculating the square here but what if i wanted to actually you know sum that all up well and i wanted it to be parallel well the range algorithms are not parallelized at the moment so you have to use the standard algorithms so it turns out in some implementations this probably does not work currently which is unfortunate right because there should really be no reason why this particular range is is special but it has to do with the requirements on the iterators for these algorithms we will see if this gets in i do not know um i honestly do not know this has not been implemented anywhere and that is usually a big problem um and so we'll have to see whether or not people can get this implemented in time tested make sure it doesn't break anything else because that's important i think it's a really nice uh feature in the sense that it you know you'd expect to be able to do this honestly i was surprised when it you know didn't work um i didn't come up with this but i was surprised when somebody showed that it didn't work um and so uh it would it would be better if it works because it really should okay so the pipe support for views let's let's just talk a little tiny bit about some of the theory here so um if you if you think about um you know what ranges do and if you think about my slide two slides ago i kind of showed you this thing of adapters and views they're very similar to each other and in fact they the adapter generates a view um and it does that in part by uh allowing you to have this pipe syntax and this pipe syntax essentially gets turned into a view constructor um you know with uh that looks like this so if if this is a this is called a range constructor closure object um and that's really the the meat of what's going on in this proposal and so to be able to do this you need to have a way to access the range adapter closure object and this facility will name that properly and will allow you to do that so then you can make all of this logic work exactly the same if you want to see the gory details of this jason rice i did a presentation in cppcon 2021 there's a link to the paper uh i think the cppcon stuff uh obviously isn't fully published yet so there's no links at this point but anyway if you really want to know all the gory details on what that's all about you can go there all right and i'm going to skip cartesian product [Music] i'll just show a couple quick slides on [Music] things like chunk so here uh you know i just want to divide this range up into groups of two well except for i have an uneven number so chunk is the case where uh it will give you as many as it's got and so this is chunking it up and by the way this is this is printing a range um so you see here that same pipe syntax of the vector into the view adapter and um you know so you can just write this code directly you don't need to put it on the stack you don't need to you know construct it intentionally so this is another one of those things where it very much minimizes the amount of code and again this code working is dependent on that range printing capability being finished slide is a similar kind of situation and uh it just slides over over the view chunk by gives you a predicate so you don't chunk by fixed size you chunk by evaluating to see whether or not a condition has been met let's talk just briefly about zip and zip transform that's a really important capability if you want to put multiple collections together especially if you're dealing with things like tuple and pair there's actually a huge number of changes to uh tuple and pair to actually support this properly and again what you're seeing here now is you know this ranges print facility uh in with a zip so basically we have several vectors this one's you know numeric this one is characters this one again is numeric so if i put one and two together under the hood i'm essentially creating a tuple of these things which is then being printed out as part of this print statement so you can see that this code is extremely powerful this is code that we just simply cannot write in c plus plus 20. um and um you know the economy of it for what it does and the fact that it's all very quick um is is just uh a very good thing so there's some more here on the slides um there's some different ways you can do transformation of course that's you know what the transform uh piece of things is okay and i'm going to skip up to ranges 2 um which as mentioned is just a way to now take that range like a view for example and actually make it into a concrete collection sort of the various simplest form of this kind of thing would be i've got some kind of a vector then i do some kind of range based transformation and the last step here is this ranges to call with a vector notice i didn't have to tell it that it needed to be a vector event it figured all that out on its own so it's pretty smart about that and then again i can just print it out and so forth and you can go see this code work on godbolt it uses ranges v3 because ranges v3 has ranges to in a form that's similar to what's in the standard what is going to come in the standard is more capable of what more capable than what's actually in ranges v3 currently this is another example i won't go through it but it's it's a similar kind of thing with the strings and manipulating it so there's a bunch of ranges resources here i apologize for this table in advance there's a bunch of missing things here it's part of the reason why i'm going to keep it up to date there's more papers for me to put here that i haven't haven't gotten here yet okay so i'm doing okay on time but i probably gonna wrap up in the next uh 15 minutes or so here i don't know if i can do any questions i'm still not seeing a way to do that in the interface but maybe we'll figure that out oh there's a private chat here [Music] let's see okay jen says he'll post questions here when we get there great so um concepts for all the things i'm not going to dwell on this um and i mean everybody probably knows that many things are being uh you know made more as much constexpr as possible just to enable more compile-time programming so uh variant and optional are two big things that got a lot of additional uh const experts added to them so um i i honestly have forgotten now if every last function is or there are still a few missing ones unique pointer is one that might surprise you since that's about memory management but the constraints on constexpr and memory allocation have changed in c plus plus 20 actually so that enables this to be possible c math is another interesting area if you ever wanted to do any compile time calculations for mathematical things you're using c math library not everything is there because certain kinds of things and it was a big sticking point what to do about errors in compile time context um but essentially it's going to follow ieee rules and if it would give you an error at compile time then it's not allowed so um you can go read the paper i believe i have links to that one if i don't have links to that one i should get them shortly but you can also go find it um anyway those are some useful ones in two charts and from chars for integer overloads not for floating point only for integer and again the floating point at compile time is a bit of a sticking point to understand exactly how it works but we did get over that i think at least for some of the core cmap things okay [Music] the containers i'm skipping and now we are have utilities and i don't know um what the best thing is uh we got a question about hive or colony um and the answer uh with hive colony is that is going to get deferred to c plus plus 26. does ranges to allow you to provide an allocator that should be used for the container to be constructed by that is a very good question i believe it does yes it does it does i i do remember seeing that in the paper so yes okay do we have any more questions and i guess i'll also take you know shout out for any particular items that people want to see with respect to this monadic optional was actually covered by phil in his talk earlier this morning so um you could actually go see uh that talk and see a little bit about nomadic optional um and that's actually pretty simple it's just three functions uh expected um i'll probably i'll go ahead and go through that uh because i think that's of some pretty big interest and maybe i'll go through stack trace real quick too so let's do those two um uh any so question is any changes to the standard where exceptions are thrown in the past uh and where now terminate is called uh not that i'm aware of um there is a proposal that i'm not talking about um but we'll probably make it in that's [Music] basically allows you to call a function called unreachable and that is to indicate to the compiler that this is a branch of the program that should never be reached but that's not quite what the question is here so i'm not aware of this the only ones i'm aware of are the two that i showed which instead of an exception at runtime now turn into a compile time error which is infinitely preferable all right so skip over monadic so let's talk a little bit about expected field it also mention this in his talk earlier this morning so expected is in some ways a fancy kind of variant that allows you to have expressed a return value and an error return and so like optional as well it's very similar to optional in that it has very much the same interface and in terms of being able to ask if it has a value or there was an error and but the error type is customizable so you can make it a string you can make it whatever type you would like including void and or sorry the void case is is one case here where expected does something that different than uh than optional so if your return from your function would have normally been void but you still want to process errors you can use expected and void with an error return type and it will all just work which is something you can't really do with optional so here's an example i have some boost date time code here uh boost date time uh uses exceptions uh in its interface so if you attempt to construct a time uh with a bad value it's going to throw an exception and so instead of that if let's say i wanted to you know go from an iso string to an actual time value instead of exceptions i wanted to make that an error return i could do something like this so in this case i'm just try catching uh and uh i'm making uh unexpected uh so this is the case where it's unexpected and you see here the type that i'm using for my error is just std string so i'm just catching the exception i'm converting it into an error return and this time expected return then will either have a p time value or it will have an error string in it so here's some code that uses it and exercises the good and the bad cases and as you can see no longer my exception handling here i'm evaluating a boolean to tell you know that this value is is no longer good and i'm not really very happy with this particular error that comes out that is the error that comes out uh unfortunately so this one um is in the final uh phase of the committee um and uh it's it's been it's been uh a long slog it's it's a big it's actually a very big facility to specify surprisingly for something that seems uh simple on its surface but it's in the last phases and i expect that it's going to be done uh pretty shortly okay uh and then also for error handling stack trace um if you've used boost stack trace uh you would be so much oh well maybe i'll go back for something uh because we got a question uh why would you return expected instead of air uh i'm not sure i understand that question so uh yeah i'm not sure i understand the question um uh but in this case basically uh it again it allows you to have a type where instead of getting the exception you can do that from your point of view how early or late should the trainer show newer features like ranges and format comparing to previous alternatives to achieve the same behavior in common use cases well to be honest with you i think um i would not this is kind of like the old question you know should we teach c first and my answer is no we shouldn't we should teach the more modern versions of things first in part because they have superior properties so you know those kind of uh facilities uh are better they're safer uh and uh they're less error-prone than the former ones especially when you get into views if you watch my cppcon talk from 2018 you know i talked about how you know you know ranges with views versus you know range algorithms versus views and i think even others have made this point as well and some other presentations i've seen that the number of cases of error cases like off by one air cases for example that you can get with a view well you can't get it off by one air case with a view because um you know when you use a range for a loop to iterate over it there's no off by ones whereas with a traditional for loop uh and a traditional set of algorithms you would get that so i think modern c plus plus first and legacy c plus plus later okay okay so i think the clarification of the other one is why would you use uh avoid of expected uh versus uh an air type um so uh i think the the uh maybe i i said something almost wrong there um you always need an error type here so there's you can't have a void error type here but you can have a void for the return value of your function so if you imagine that your function just does something and it doesn't have a you know any kind of reasonable return that's when you would make this first parameter a void so hopefully that clarifies that question um and lublio converted the brackets so i don't know about that i skipped over a slide with span as a function argument in it is that about fixing stdspan vector etc and [Music] not compiling because of restrictions on range constructor of span have those restrictions been lifted i i don't think anything has changed with span my span particular span slide was uh related to uh uh spanstream uh stuff so uh the answer is no i don't believe this problem has been fixed um it's possible i'm wrong about that and something happened that i missed because there's a lot of stuff um so um that's it's interesting i'll i can go check on it but i don't think so okay see if we got any more questions all right i think we're good on questions so we'll do stack trace quickly um and then we'll probably close it up um i have about 20 more minutes before i have to go so stacktrace uh if you've used boost strat stack trace you'll be familiar with this capability this has been one of those again things that especially in debugging contexts has been really a challenge to do portably um and you know so um you can imagine uh doing this even in production code though with certain exceptional conditions uh where you might want to get detailed information about what's going on so this is one of those items that was unfinished business from sql plus 20 it was proposed this has already been added into the working paper as i say it's based on boost stack trace there's a ton of details that are complicated here there's going to be dependencies on compiler modes uh if you if you've compiled your code and stripped your code of all symbols and so forth you're not going to get symbols uh out of a stack trace you're gonna get you know some uh information that probably isn't too valuable to you um uh so you know you're there's no universal portability with respect to what exactly comes out of the interface what is portable is the interface is portable so that in a portable way you can include the header stack trace you can snap a stack trace in a particular place in your program uh and then you can you know output it to i o streams um or you can output it to a string or an i o stream uh and process it somehow later so you can log it do all those kinds of things so you know and again the details of what's in the stack trace are going to be a little different you know this is an example using boost stack trace um that was put together and so the synopsis of what this thing looks like um you know stack trace is basically a collection of stacktrace entries with a description a source file and a source line associated with it um and you know you've got an operator for io streams here as well all right so i'm skipping interfacing with c and um calling the add exit function um so uh form and function r1 um i think you know obviously this is c plus plus and c plus plus libraries have been getting more advanced more capable uh and still being fast and still being able to do things very close to the metal um and so we've opened up whole new dimensions of design capabilities with the features in c plus plus 20 especially 23 not so much but i think we're getting a lot of nice new facilities that augment our stl2 so that's our new ranges library um this is the link that i'm going to keep up to date i'm sorry it's cppcom but um i only want to keep one of these up to date so that's the one to go to um and i don't know if i can since i can't access the chat directly maybe i can put them in the chat and the ends can put them put them in so these other two links if you have not been to you know cpp reference for compiler support if you want to track closely what's going on right um this is now really the go-to place um to track what's going on with with features the only one disadvantage of what happens in cpp reference here is that um the only things that get listed here for sql 23 or any other feature are things that have actually been voted in to the full committee so i showed you a whole bunch of things today that haven't been voted in by the full committee yet but i'm expecting that they will be assuming that all goes well so here's actually the list of c plus plus 23 compiler features so there are a few language features and you can go take a look at those and then you can see here the actual set of library features that have made it all the way through the process and if you look at this list carefully you'll see there's probably a few things uh that i again did not even talk about leaving out but when c plus plus 23 is complete in february when you come back to this site in february you should be able to see the complete content of sequels 23. so that's why i link to this because it's the go-to place for finding that and of course if you want to know what ad exit is and you don't know of course go there and with that i think i'll say thank you uh and i certainly am open to taking questions for another 10 minutes or so here okay uh hello jeff thank you for your talk um let's see if there are any questions to be taken from the chat um let's give them a minute to catch up with the stream and there i am so one question i would have is like how complete is the library for super class 23 is there like still a window folder to go in or is this like complete yeah it's uh the completeness is that um uh the library evolution has looked at its backlog and has uh set up a series of meetings between now and january which is basically the point at which they have to stop work uh on design features and pass all of it to lwg for final wording and so there is no room in that schedule for anything more so if it is not in a paper already then it will not be in c plus plus 23. it is also the case um that like you know hive as an example it was something that has been you know was something that's been in the process and been worked on and lewg has looked at it um but the judgment call was that it probably wasn't going to make it given that it's you know in a medium to low priority so they just took it off the table for sequels 23 for the moment just because of the lack of time to actually process it fully and be sure and confident that it's a good facility in all respects okay so question does stacktrace make specific requirements on reporting stacks containing inline functions and i think that's another one of those examples where your mileage is going to vary um i don't expect the i i don't expect it to be the case that just because you put a stack trace in an inline function um uh you know that it's going to be a problem you you should be able to do that um whether or not you'll be able to see the sim symbols for it um you know we'll have to see uh what the compiler vendors actually do if you look very carefully at that thing i flashed on the screen nobody's actually implemented it yet none of the vendors have implemented it yet and actually if you look at if i go back to this just for one second you know um as i mentioned you'll see with a lot of these other things like the string contains some of these other smaller features many of the compilers have already implemented these c plus 23 library features so you can get them if you've got the most advanced version of the compiler and you use you know 2a usually is the flag or depending uh i think it's latest on microsoft's compiler so um uh any known abi breaks in sequels 23 stl well the known abi breaks in c plus 23 stl would be in ranges which is stl 2.0 as it were um and so it's not just an abi break it's an api break in other words it's not just that the binary is broken but the actual what you're going to get from the function called you know split view is not the same as it was when we shipped 23. so so yes those are the only breaks though um format is the other thing um there's none in the standard you know uh i i dare to call them legacy algorithms the old school algorithms that are just an std there are no breaks there there are really no updates there either except for if find last gets in find last will have a regular algorithm as well all right so i will try and consume that tab so i still have it um [Music] yes so i think that brings us to the end of your talk okay thank you so much for coming that was awesome thank you for inviting me and i hope we can do this in berlin next year so seven minute talk summer talk yes of course and yeah so