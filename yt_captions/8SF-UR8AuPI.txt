and real life with tonight's armor with Sean parents I want to welcome the folks in hobilo and this also streaming to LinkedIn so people will you know slowly triggered in from LinkedIn to Who video or just view this on LinkedIn I do want to sell it I prefer the questions to be asked on mobidos I will you know prioritize them but if you have any questions on LinkedIn naturally some people would ask them in the chat and I will also try to cover those um and with that let's get started um Sean parent tonight here to answer your questions and I guess some of you are wondering who Sean parent is what does he what is he doing in the recent life of C plus plus so Sean please introduce yourself okay uh so I'm Sean parent I'm a senior principal scientist at Adobe I've worked there almost 30 years now I did take a short break in the middle to work at Google on Chrome OS and prior to coming to Adobe I worked at Apple in the system software team working on the transition from 68k machines to powerpc machines ages ago um uh my current role at Adobe is running Adobe software technology lab so I've got a small team there are four of us all together uh our Charter is to take a long long range view of uh trying to improve the code that Engineers write so we're not so concerned with with process as we are with uh what Engineers type when they actually sit down with the keyboard and so some of the things we're looking at are the challenges of writing correct concurrent code um uh challenges around the complexity of C plus plus and the lack of safety in C plus plus um and and challenges around how we educate our Workforce and kind of bring everybody up to up to speed so so that's who I am see do we have any questions coming in um yes this will be now the time to ask a question um so if you have questions in her below I prefer strongly the Q a tab so if you ask a question there that's where I will choose from if I see a question in the chat I also will be happy to take that there and of course people on LinkedIn uh ask questions see there's already some uh people saying hello from LinkedIn yep actually there's currently let's start with an easy question um what is your impression about the new C plus standard uh well I don't know if we're talking about 20 or 23 uh right now we're internally just moved to 17 after a very long effort and things like the parallel algorithms are still missing from from Apple's release of clang so we're not even fully on t plus 17 yet I think there's a lot of potential in C plus plus 20. I'm looking forward to to cleaning up some code with Concepts um modules have a huge amount of potential we haven't had much time to play with them yet and uh co-routines I think have significant benefits in structuring concurrency so looking forward to those also uh oh certainly we've been writing some some experiments and playing with some of these features uh uh uh C plus plus 23 I've been Loosely tracking it uh uh uh you know generally I think the the the feature set is good you know my ongoing issue with C plus plus has just been the the ever increasing size and complexity of the language it's it's it's become very difficult uh for both new and Senior developers alike to kind of wrap their head around it and when you have you know a large company that's growing which is you know adobe's a fairly large company and we've grown largely through acquisition and so we have engineering teams all over the world and and we don't have a homogeneous environment like you would see at Google where we have a single set of coding guidelines and and you know from Project to project code looks looks very similar instead we have a lot of different teams that have developed their own ways of doing things and then they're trying to share code with each other and and it's it's uh amazing how different C plus code can can look coming from two separate projects yeah so there's a question from her Below on the status of your book status of my book uh that's actually a pretty high priority for the team right now um so I've got uh uh Dave Abrahams has joined me and with the software technology lab uh if you've been around C plus plus a long time you probably remember the name he was very involved with getting boost going uh many years ago now and then left the C plus Community for a while to work on Swift so he worked on the Swift standard library and is one of the designers of Swift and then worked on uh Swift UI at Apple and I've managed to snag them and pull him over um and I've got David senkel who comes from Bloomberg who might have seen some of his talks at some of the conferences and then a younger individual Nick Demarco who I worked with at Adobe a few years ago and he left the company for a little while to try the startup thing and I managed to convince him to come back to join the software technology lab and so right now we are all working on uh course uh better code course which the idea is to uh uh use that as a way to develop the book further so we've gathered up all of my piles of notes and presentations and sorted through those we just did a dry run of the first three chapters with a small internal group of people and uh I've uh it was very informative kind of it has us going back and and reworking some stuff uh but but we're moving I'm I'm adding co-authors and uh uh a a busy writing and and busy making progress on it finally it's been a very very long time where it's kind of sat on the Shelf um uh so so yeah no schedule yet but it is it is it is uh actually moving so that's good okay let me see the next question what worked best on achieving Superfast developers writing better code so far can you share some examples or reasonings what has worked best uh uh uh you know certainly the kind of no raw Loops thing has resonated and I think had the the broadest impact um uh the the there's an orc to the to the to the book and my talks and and the class that we're developing um around relationships and and this is the idea that it's it's it's the the things that happened uh uh between the objects that don't happen in the code that tend to be problematic in in the system and so how do you go about identifying what the essential relationships are and and uh uh codifying those and coming up with a system to reason about those uh within your code so I think as we start to get that message across that's had a significant impact on how people think about their code and and and and approach development so and let me choose a question from Nathan what is the future of why does it remain an experiment to try new things or would it become a production ready language uh that's a good question um Dave Abraham's right now is in Kona he just gave a talk uh yesterday evening to the C plus plus standards committee uh presenting some of the ideas in val for people who don't know a Val is a language that was created by Dave Abrahams and uh Dimitri butcher's last name recordon and and it's uh uh in in its flavor it's very similar to Swift but it's uh uh uh even more safe by default uh so in that sense it Bears some resemblance to rust but it pulls off rust level safety uh included around concurrency without the need for all the annotations and so we think it has potential to be a more approachable language um uh right now the work has been mostly done uh by Dave and Dimitri we've got another external contributor illusion and then my team is is starting to look at how how we can contribute uh we had a meeting with herb Sutter not too long ago trying to inject some of the ideas from Val into uh his cpp2 effort we've also had conversations uh with uh folks working on carbon uh around trying to get uh uh some of these ideas injected into carbon and I think I think we're having having an impact there uh we're also stealing one of her Sutter's ideas and right now we're working on a a transpiler um so that you can compile Val code into C plus code and through that we're going to try to work on on C plus plus interop um uh so the uh you know it started as kind of a purely academic exercise it's been moving very rapidly in the last several weeks rapidly enough that we're trying to get a few more arrows behind it and just see where it evolves uh uh uh I'm I'm not committing to becoming you know a a commercially viable system uh uh on its own at this point uh they're still still a long ways to go before we get there uh uh but it's you know the more we play with it and the more we look at it I think there's the ideas there are interesting enough uh that we're like I said we're investing a little more and and trying to see see where it plays out so and how much are you personally involved in why uh uh you know well I managed Dave Abraham so it's kind of kind of his baby um uh to date I've been involved mostly as a as an advisory and helping out with some of the papers and and and things on it but yeah I'm hoping to to get a little dirty especially as we're working on on C plus plus interop and so roll up my sleeves and and write some code okay um asked in your CPP North 2022 keynote you mentioned the difference between programming languages that are efficient by definition versus efficient by optimization can you elaborate on this a lot of C plus plus speed come from O2 O3 compiler optimizations yeah so so the the basic idea is is at a high level uh uh uh do you have guarantees about things that will or will not happen and for example um uh return value optimization in C plus plus uh has something that's been allowed for for uh uh many years you know going back to to uh C plus plus O3 um but it's not till C plus plus 17 that that it's it's mandated and so you can couldn't rely on it before then and when you're developing code um uh uh that's performance critical it's important that that even your debug builds reach a certain level of performance and that you can get consistent performance uh in a wide variety of environments so right now you know the I work closely with the Photoshop team and the Photoshop team builds all of their code for uh you know IOS and Android and wasm and Linux and mac and windows and so it's a fairly broad Suite of of uh compilers and platforms that come into play and so so you need sets of of guarantees um so for example uh many of the functional languages you know present this uh uh illusion that everything is a copy and then you rely on the copies not happening under under the hood and getting optimized away but what that means is is inefficient code or the optimizer can't see through what you're doing and efficient code looks identical and as a developer you don't have control over that um uh so uh one of our goals around Val is to uh uh uh uh even take things a little further than C plus plus which is to make sure that even uh copies where they happen are explicit and so the model and vowel is is implicit moves are allowed but implicit copies are not and so even if you want to copy an INT it's an explicit statement to to copy and int and and uh uh you know personally I find that that that much much better uh with concurrency this gets you know much harder if you look at a language uh like Haskell uh concurrency is really just a compiler flag and uh in a purely functional system you can just turn it on and the optimizer will try to find places where it can run code concurrently and you'll pick up you know a small performance win in a typical Haskell code base and if you're very careful about how you construct your code and you know what the optimizer is going to do you can get significant wins uh uh by by turning on concurrency and so you know a challenge in a programming model is how do you enable concurrency in such a way uh that a developer can can reason through it and and get uh kind of you know guarantees around the scalability of their performance and make that explicit in the code so so that's what I I mean by by those things um uh so yes it doesn't you know completely remove the need for having you know O2 and O3 and letting the the compiler go off and and do further optimizations but you do want to establish a Baseline uh things that I'd love to see in C plus it's uh uh you know I'd love to see some changes to the destructor ordering rule so that objects can destruct after last use instead of having to wait until they they're at the end of scope and if you did that that would enable uh uh uh things like tail recursion optimizations and um uh you know I think that we could do that in such a way that you could have explicit guarantees around where you got tail recursion optimizations and things like that and if you look um you know the game Community complains quite frequently that debug builds uh you know where where the debugger uh or where the compiler is turning off inlining become unusable with modern code because you get super deep nests of of function calls uh with a lot of the template heavy code like boost or kind of code that's using functional paradigms and the only way that that works efficiently is if you have your Optimizer come in and inline all of that code and remove all of those function calls um but that makes things more difficult to debug so you know how do we get to a world where you can have your debug builds uh run at a higher level performance and not generate you know 100 unnecessary layers on your stack that is true speaking of the stack speaking of color teens do you think as is the features production ready I think the feature is production ready um it's production ready I mean it's it's it's a well-designed well it's it's a thought through and and and and and in some sense a well-designed system for co-routines I mean certainly in C plus plus 20 the biggest thing missing is the library support to make it actually usable there's uh you know understanding how co-routines work and constructing them is is a is a challenge um uh my biggest complaint there is exactly what we were just talking about which is that uh the model for co-routines implies a heap allocation and in that sense I think it's it's an outlier for the C plus language um uh you know uh uh you know invoking a function usually doesn't imply that there's a heap allocation on that function invocation and and you know for example lambdas don't don't do Heap allocations compared to say Objective C blocks which do um uh uh there's there's a rationale and a reason for why that Heap allocation is there and sometimes your compiler can optimize it away but I think it's very telling that things like uh uh Eric niebler centers receivers code uh really doesn't use co-routines internally because Eric doesn't want the Heap allocations and can't rely there's no guarantees about when the compiler can optimize those away and they'll almost always appear in in debug builds and uh uh so in that sense I think the the feature is a little the design of the feature for co-routines is a little unfortunate I think um uh uh you know it's it's kind of a weird thing in the declaring a co-routine isn't actually declaring a function which is what it looks like it's more again to declaring an object or a struct and and then the the invocation of it um I think should be purely on the stack unless you explicitly keep allocated as opposed to it magically getting Heap allocated and you're getting a co-routine handle for the for the for the allocated object um so yeah I I think it could have been better yeah complicated system it is missing I think at 23 will bring further improvements and then there is it's a new model people have to get used to it yep and it's not like something which was Prior like not in the standard but in available of a lot of libraries um there's a question on books um Sean I believe you have advocated developers to look at the work of stepanov and my self-study I've been reviewing functional programming and category Theory this is analogous and we're looking at or should we stick with elements of programming uh both um uh you know I think uh uh category theory is interesting I think it's very easy to get lost in category Theory and you know at the end of the day category theory is looking at at how how things compose uh but is devoid of semantics and and elements of programming is is very strong on on on on on looking at things by starting with defining what they actually do um uh uh so you know I think there's there's things to be learned from from category Theory certainly there's a lot to be learned from functional programming I think uh you know most developers would would do well to to spend a little time doing functional programming if they didn't didn't do it in school um uh uh uh it uh makes you cognizant that there is you know for for any problem there's a different approach that doesn't require mutation and and you get you know immediate guarantees around around safety and there's concurrency benefits and things of that nature at the same time doing something like sort becomes inefficient and and much more complex you know so so studying kind of both approaches you know the EOP approach and the the functional programming approach I think will give you some insights into you know what's the better approach for a given for a given operation and you know anything can be written in a you know in an in-situ form kind of where you do modifications in place uh or a functional form where you return a result and then functional forms can be either lazy or eager um uh and there are our trade-offs with each of those approaches and those trade-offs are different for for any given problem that you're trying to solve so so I think as a developer getting to the point where you're familiar with what those trade-offs are and any of anything you're trying to solve you can approach it in all three different ways and um uh evaluate the trade-offs is is a good thing that is true um from the court safety and correctness perspective what is your opinion on error codes versus exceptions uh I gave a talk on that um uh called uh exceptions the other way around which is which is available on online so my you know my opinion is that uh uh you know error codes that need to be explicitly handled uh even if it's you know through a monotic monadic composition you know where you have a language that's called like a DOT question mark or something that can that can you know chain or not chain uh depending on whether or not you you've got an error um uh error codes are unnecessarily problematic and they just pollute your code base with noise and so I am not a fan of error codes the C plus plus exception handling has some issues of its own um uh uh you know it has some costs that that come in because it drags in in uh rtti which is not an opt-in system um uh the fact that uh operator new can throw even though on on most os's it really can't because the OS is going to over commit um but the compiler still has to generate the exception tables in part because operator new is a replaceable operation which means it could be replaced to Dynamic link time when your application is loaded so the compiler can't really determine whether or not operator new will throw or not um uh it just means that the the t plus exception handling is is heavier weight than than it could or should be um uh but you know go watch my talk I really think that that you know going to an an error code environment or uh uh you know uh uh uh you know any of the uh uh uh uh proposed kind of you know expected uh result types that do monetic composition I think are are are largely going backwards and and are brought about by people's just uh uh uh own squeamishness around exception handling so you're not you're not a fan of expected I am not a fan of expected no not at all okay so there's a couple of questions about like basically boiling down what do you think about carbon what do I think about carbon um uh you know it's it's it's interesting it's got potential uh we're monitoring it so David senkel on my team is uh is attending the the carbon meetings and we've had a a a few uh larger meetings with the with the carbon team um uh uh I think carbon is is right now a little too hand wavy for for my comfort level it's it's largely trying to tackle the governance issue with C plus plus um uh uh and from a language standpoint it's uh basically going with the C plus plus Ox model of of generics which I think is a is a good move but but it's largely ignoring um uh safety at this point it's uh I think kind of uh getting rid of references in favor of pointers even if you have the notion of non-null pointers adds complexity it's it's not a simplification that they that they think it is um uh uh you know and so so we're watching it I'm you know I would say right now I'm I'm not a fan of the of the design as it is or the direction it's going in um but you know maybe just a simplification of the C plus plus syntax and assuming they can pull off interop which is a big question at this point they haven't demonstrated that yet uh uh you know maybe that's enough so so it's got a lot of arrows behind it so it's it's hard to rule out yeah I think from other languages which came into light this year they are more like an idea and other languages already like you know Sean uh mentioned health status approach of you know having the idea to actually compile to C plus plus and not try to to build up on one of the compilers might be the better way for for some people um let me see what questions we have um oh yeah so like when we talk about herb um what's your view on herbs such as cpp2 uh I I think it's a good piece of work um uh uh that's you know we're having conversations with them uh uh in fact that was one of the reasons why Dave Abrams is out in Kona right now was to was to spend some time with with herb Sutter and Gabby uh discussing cbp2 um uh uh I think buried in cpp2 is a a simpler approach that's actually more capable um uh uh uh looking at it uh we think they're just uh hair away from getting thread safety you know out of their safety model and their current safety model uh rules out some constructs like sharing immutable data which actually are safe so kind of I think the design goes a little overboard on some edges and not far enough in others um uh but it's uh uh it's a relatively you know solid design at this at this point so so I'm I'm encouraged by it um so yeah yeah I liked it when I saw the keynote but I also like that uh he keeps working on it that's like what's one of my biggest worries that I hope like you know friends every year a science project at his keynote and where does it go from there yes not always the best track record um but I have a question on embedded which C plus plus features should be avoided while programming for microcontrollers uh you know uh the last time I did embedded work was programming a Z8 processor which had 2K of ROM and 128 bytes of RAM um so so I'm really not the the uh uh uh the the best person to to to ask that question um uh uh you know I don't know use the features you can afford to use I guess is the answer um any any cpfs feature which you advise against in your own uh coding guidelines um no our own coding guidelines we try not well so the you know things that I think are very problematic are things like Dynamic linking um uh which is not a C plus plus feature and that's part of the problem uh uh and it's especially bad if you're doing Dynamic linking and you're trying to do simple hiding with it which puts you immediately in in undefined Behavior territory uh and yet a lot of a lot of teams uh and a lot of products do exactly that um so that's an an ongoing pain Point um uh uh you know basically it's an ongoing effort to try to raise awareness of what the rules are for a library versus an application and you know if you're if you're writing an application you could replace operator new delete for example but if you're writing a library uh you really can't without stepping on on the main application toes um uh uh so you know our guidelines are around things of that nature and not around specific language features that you you should or shouldn't use on on the language feature front we try to educate people as to as to you know what things uh uh uh uh do and where are the sharp edges as opposed to making mandates about you know don't do X you mentioned safety aspects of codes what is the Approach at Adobe to test safety relevant generic C plus plus code a reasonable amount of templates no excessive meta programming yeah um you know our approach I think is like most of the rest of the industry uh which is you know these days which is trying to rely on static analyzers to the extent that we can and sanitizers to get us get us beyond that um uh you know from from uh an educational standpoint we try to teach people about how to uh work in an environment where almost everything is a whole part relationship and uh uh you know uh getting rid of shared pointers to mutable data and uh uh getting rid of of of of of sharing data through uh threads except through explicit communication channels uh things of that nature um uh which are all you know built around ideas of safety uh but yes uh uh you know I think like the rest of the industry in C plus plus it's a it's a difficult net to crack uh personally what I've been doing is is almost all the code I've been writing lately um I actually write it first in Daphne which is uh a um uh uh a language that can output in multiple languages including C and um typescript and and and and some other languages uh but Daphne includes a proofing system so you can write uh pre and post conditions and loop invariants and you can use existential and Universal qualifiers and the system will will prove your code is correct to the specification and uh so so it doesn't have a good C plus plus back end but even my sequence Plus Code these days I tend to be writing it in Daphne first and proving it correct and then just transcribing it into C plus plus so taking a little bit more of a formal methods approach but um uh I know of at least you know one other person that adobe who does a similar thing but uh but certainly I don't think we're going to get uh you know an entire company to start proving their code um there's maybe a connected uh question about ADA what do you think why it's not getting as popular as C plus plus in other languages uh you know I I it's a good question I don't know and honestly I haven't spent time looking at Ada in in uh in in many years um uh and it did come up recently in a in another conversation around you know Ada has checks some of the boxes that people are looking at for C plus successor languages but honestly you know it's on my it's on my list of things to to research a little more I think the last time I tried to take uh a cursory look I was surprised at how few of the platforms that we care about it's available for in any in any uh uh a significant form so that was a little a little problematic at the time but um yeah I I don't have a firm opinion of ADA um there is a question about Reflections what do you think about adding reflection to C plus plus should it be a must a nice to have Sean Baxter in the circle compiler and David sanker have done a lot of progress on this but I don't see the committee much willing to change the language for work on this area yeah um uh you know I'm a Sean Baxter fan uh I like what he's he's been doing with circle and certainly he's been doing a lot of interesting experimentation uh with the circle compiler um uh I I think it's unfortunate that the standard committee isn't listening to him more um because he's certainly gained an experience and and his approach is evolving uh I would really like to to see us have a much better compile time reflection in the language and um uh you know I think if if we have a good compile time reflection it lets us build opt-in a runtime reflection where that's useful uh so I think that that's high value I think the current state of affairs of trying to figure out what you can uh declare a const expert and win constex for things actually execute at compile time um uh is is a difficult programming model and the the circle model of basically lets you run anything at compile time uh you know I think is is is is is is is an interesting and and valid approach um you know I I disagree with the with the naysayers who thought that you know having your compiler uh running on your server being able to execute anything is a security violation because if you're like Adobe what do we do we compile a bunch of code to generate unit tests and then we execute all those unit tests on the server um so if it's a security hole it's it's already been blown wide open and not to mention the fact that the the current template mechanism is trained complete so you know it you could you can do anything that way too um uh so so yeah um uh I'm a fan I would like to see more reflection I think I think just some of the basic things that we still you know deal with the number of places in code where you have to you know map strings to enumes back and forth and uh uh uh just just common things like that I think are are are ridiculous uh but certainly I would like to be able to do things like you know iterate all the members of a struct and uh uh you know merge you know right right compile time code they could merge two structs and generate a new struct and do things of that nature so yeah so it was like a very very similar question which we could you know continue now it's like do you think that we will be able to match with Java and c-sharp or is it maybe a different language model which allows them to do more um uh I well I hope we don't try to match Java and C sharp both of those are are built uh uh uh uh with the model that you have a class object which is a runtime object and the closest C plus gets to that is having the V table and and um the rtti information which is all all all immutable data um and a little a little heavy weighted as it is you know I would like to see us move more towards getting opt-in rtti or at least now an ability to opt out of rtti uh within a class definition and uh there are many techniques for building your own V table so I think having direct inheritance and uh having the compiler generate V tables for you is a is an unnecessary feature of C plus plus um uh uh that said there are uses where you do want you know the equivalent of a class object and I think if you have enough compile time reflection uh you can you can build that easily I mean you can certainly do it without compile time reflection it just ends up being a lot of boilerplate code or a bunch of macros or horrible copy and paste things um I used to uh uh when Matt Austin uh uh was kind of lead on C plus plus at Apple years and years ago uh I used to argue with him that um he was he was working on both C plus as well as as Objective C at Apple and Objective C is another language that has class objects and and and runtime reflection and my challenge to him was how could you turn uh uh uh Objective C into a c plus library that was actually usable and and that would kind of be my my challenge for the folks working on reflection in C plus plus is can you make the job in c-sharp capabilities uh be edible from a library and uh you know in a usable form and and I think if we can we can get there and we will have accomplished a lot so and I'm sorry there is of course a question about Avi is ABI stability holding back the evolution of C plus plus uh well I there's there's two ways to say that I think if you broke ABI compatibility it would it would stall C plus plus uh for for over a decade right certainly Adobe would have a very difficult time moving to a a compiler or a tool chain that broke API compatibility um uh even small breaks and ABI compatibility historically have cost us several years uh uh just because they're such a large ecosystem of of libraries and dlls and things that are outside of our Direct Control and things that have to be coordinated because we have to build across different versions and different environments of things so so of kind of a full API break uh would be very painful and I think would stall install the language at least all adoption of the language um uh that said I really think the standards committee should start to come to terms uh with the fact that you know a lot of development happens in in dlls and a lot of those dlls are built with symbol hiding to reduce their size and that immediately puts you into undefined behavior and and the ABI communication between them is may be specified by platform vendors but certainly not specified at the language level is just kind of an unspoken rule that language providers can't break it and I think C plus plus needs to figure out how they have an explicit ABI resiliency model something along the lines of what Swift did uh where you have have a set of constructs where you put in the stake in the ground and you say these are for communicating across dll boundaries and you actually Define what it means to build C plus plus code inside of a dll um uh uh uh uh and and you create a a resilient layer which may come at a at a small runtime penalty to use that layer to speak across it so I don't think the the question is as simple as as you know break it yes no it's uh yes we want to break ABI stability so that we can evolve the language but to do so we need to put into place a resiliency layer so that people have some guarantees that they can migrate to and that's probably a many year poll because you want the resiliency layer in place first and give people time to migrate uh uh uh to that and then you can go and start breaking apis and and you you have an answer so so that's my answer on apis yeah I this wasn't I think 2021 when price keynoted C plus plus now um he mentioned the paper P two one two three um which tries kind of to solve this accordion not by introducing interfaces and constructs to uh say um break the API here for that standard but leave the API alone for the standards and I I guess we also you know would like to have this ability for libraries to say this is Library version X and we're breaking standard I'll be breaking the API and otherwise we're not breaking the API um I kind of like that idea but I think it's also like an idea which needs to be more refined and I'm not aware that Vegas paper has no it's still reviewed and under review probably in Kona now [Music] um but I wonder if you have heard about that paper I have heard about it um uh I haven't I haven't uh uh spent time going through it I was encouraged that somebody was looking at the problem um uh uh yeah and uh you know Apple years ago had a a tech note that they put out which was the unfortunate title was something like C plus plus tips and tricks or something but buried in there was was basically their statement on on minimal ABI compatibility uh between dlls and and what that meant and and it was it was very restrictive uh at the time and and uh but I think that you can actually start with a relatively uh uh uh restrictive environment right right you just need to let people know what's what's guaranteed to work across the boundaries and um you know and you need rules about you know what does it mean to have a single application that depends on say two different versions of boost uh uh you know that are coming in from dlls right right how does that work um I had that problem once yeah yeah we have that that problem in Spades so you create a CPP file and only the CPP file is basically acting as a firewall yeah and only that is like then connecting to the library which is uh using or like connecting to apis connecting to the library which is using the old boost version and you're not sure how to build as a new version yeah and things like you know Apple's runtime uh their their Mako environment has has a notion of two level name spaces uh which means that you know a dll that includes a dependency that dependency is an automatically visible to other dlls and things of that nature but all of that is outside of the language and all of that is is basically you know a implementation defined behavior and as far as the language is concerned it's undefined Behavior you know too it's an odr violation technically um uh uh and so yeah I think that that the fact that everybody does it and nobody's working on trying to standardize a way to do it is very problematic and what we run into all the time is people create a system that uh works on Windows but then fails everywhere else and and it's because of things like you know Windows does rtti look up by name and every other platform does rtt I look up by symbols and so if you're hiding symbols then on Windows uh names still are exposed through our TTI so things like a dynamic cast might work on on on Windows but fail on Mac or vice versa depending on how you have things set up and so these are all all problematic things and you know the number of times where I hear you know developers complain we don't understand uh we're throwing an exception and we're catching the exception of the right type but it just blows past and doesn't get caught and it's like yeah that's because you're throwing from one dll through across the dll boundary and and a simpler name wasn't exposed and so an rtti lookup failed and so your catch failed and you you ran off the end of your exception chain termination yep um what do you think about having garbage collection on C plus plus I think garbage collection is generally a horrible thing and you know a horrible idea all right it's uh you know garbage collection is for people who don't know what their pointers are doing um uh uh and so so I'm very much a fan of of of precise lifetimes um in fact I would like like more precise lice times than C plus plus offers I would like objects to fall out of scope after last use as opposed to at the end of the scope block um uh Objective C and even Objective C plus plus works that way which can throw you for a bit of a loop if you're if you're you're used to the C plus rules um uh uh so yeah I mean it you know in general I'm against you know trying to share data I try to make as few Heap allocations as possible which means I'm trying to generate this as as little garbage as possible um uh uh garbage collectors tend to cause you know indeterminate delays they're blowing your caches uh they're limiting your memory basically for for you know every every bite of ram I can give to photoshop Photoshop will run a little bit faster um uh you know and do less paging so so it's uh not a fan I've never been a fan of garbage collected systems um we actually have someone asking you look at that question so as the C plus plus begin now what areas should you focus on to improve your own career what area should you focus on wow I improve your own career you know I I may not be the right person to ask I tend to think uh uh it's it's not language specific basically focus on on understanding programming um uh so we mentioned before uh you know EOP or studying functional programming or going back to some of the classics right right reading uh uh uh uh dijkstra or Bob tarjan's books or or even try to work your way through canoes um I think we'll have much more more benefit uh kind of an approachable form of that is you can find all of the train award lectures online um uh read them you know end to end it they're not that long they're a few pages each there's some some real gems in there uh uh uh so so you know spend your time learning about the the profession and then programming being in C plus plus or or any other language will come fairly naturally I spent you know most of my time in C plus plus uh but I was working on Photoshop web and so I spent time in typescript and I've spent time and and Swift and I've spent time in uh uh you know certainly a lot of time in Objective C and Objective C plus plus and uh you know like I said right now I'm writing most of my code in Daphne first um uh the language really doesn't matter all that much it's it's figuring out the ideas and and then how those ideas map into a particular language and that usually doesn't take too long to figure out so so that would be my my recommendation um I think an interesting question has been asked about energy consumption do you think we would have compiled optimization for that end I I hope so um uh uh in the single threaded environment energy consumption Maps fairly well to Performance not always but fairly well um uh uh it's as we start to get more language support for concurrency coming into play I think where things get interesting because uh my canonical example is is is just you know implementing find right if you do uh find on a single threaded core uh you're going to search roughly you know half of the items before you find what you're looking for assuming there's one instance of the thing within the sequence that you're searching uh if you do parallel find you'll split that into half and you'll you know on two cores uh uh you won't find it in one half but you will search the entire half and you'll find it somewhere probably in the middle of the other half and so it's going to be roughly 13 quarters of the data and as you add more cores you very quickly are approaching searching all the data and so you know a parallel find is doing roughly twice as much work as just a a sequential find and and throw in the overhead of scheduling all those tasks and everything it's it's it's uh probably consuming a bit over twice as much uh uh energy to do it um uh so that's you know I I think that's that's going to be be challenging and certainly if you look at uh a large server-side systems you know Google scale type systems uh uh you find that that it's the energy costs that start driving uh uh uh you know end up being the majority of your total total running costs right your energy costs at that scale start to to to dwarf your engineering costs for development and dwarf uh your Hardware costs and all of that and that's you know especially to these days as as Energy prices have been skyrocketing uh this is why you start to see you know large data centers building their own solar farms and and trying to manage their own costs that way um so yeah I mean I would certainly like to see it I would like to see like you know Dash OE which was compile my code efficient to be energy efficient I think on the other end of the scale we see the same problem like I mean you have talked about you know running code on iOS and um making you know putting part of of your Adobe products to new platforms which are more mobile and more prone to energy consumption than a normal PC yeah yeah and that's a problem and you know it's uh uh uh you know Macs and windows now uh you know have a way to kind of drill in and see what um what the energy consumption is of various apps and frequently it drives me nuts when you know an adobe product is is listed on the top of that list on my machine and so yeah yeah unfortunately I don't think that that's as easy a fix as just a compiler flag you know usually it tends to be uh something that's spending too much time staying alive being in a network or or that nature that's the other thing that a computer can never expect what the runtime does so yeah um what is your current development environment operating system editors Ides and like offline tools anything you would recommend or won't recommend ah I don't have anything too fancy uh for work I do most of my work on a Mac my personal machine is a Windows box so I tend to split my time between those two um because I still do a lot on on iOS and Mac development uh xcode is the IDE I spend most of my time in maybe it's probably close to 50 50 at this point between that and vs code um uh uh inside of vs code I I use things like uh Daphne which I already mentioned which is pretty cool because if you write a piece of code in Daphne um uh basically the fact that you can compile it means the code's correct so it's kind of a fun fun environment to to develop in I use uh uh Jupiter notebook with the Zeus extension um which lets you run C plus plus code inside of a Jupiter notebook inside the cells it's uh it's kind of a semi-interpreted version of C plus that can be great for developing a A courseware or just for developing ideas because you can basically be you know writing your notes and have executable Snippets of code in there um uh even when I'm working on uh on a big product I tend to write almost all of my code outside of that product either in just uh you know main.cpp file um uh uh you know or inside of a notebook or inside of Daphne and then transfer it into a notebook or into into a main.cpp file um uh and then I left the code and drop it into the product so so I'm almost never you know writing in a significant body of code directly in the product right right the most most time I'll spend doing that will be pulling code out right it's the put in a replacement and so now I've got a gotta grind through several hundred files and and and you know updated API or pull out a bunch of code so you would not have been uh you know profiting from the so-called Twitter ruler that only the people just wrote a lot of code stay no uh I think I generally would have been negative so I would have been escorted out I'm pretty sure um uh uh yeah yeah um I'm also I'm I'm odd in that I I learned to program taking a lecture and I was relatively young I was in I don't know sixth grade seventh grade something in there and uh uh about two years before I ever got to touch a computer and so I I I I was obsessed with with writing code in notebooks and executing them in my head and that habit has stuck with me so uh I don't bother to compile things until I've convinced myself that the code is correct and I I will tend to Will you must have a lot of handwritten code then uh I used to have a lot of handwritten code I mean now it's like you know handwritten I do type it uh I do I do sit down and type it I no longer you know write it with a pencil and a notebook um uh but like I said I do use things like jupyter notebook and and I will will you know write all the pieces and things like that and uh um uh you know all work for several weeks on on a piece of code before I even attempt to compile it and I'm the only person I know who who works that way it's not a way I would recommend it's just the way I think um uh you know I kind of don't see the point of writing something through the compiler until I think it's right so so uh yeah I'm not very fancy with my tools um which parallel Computing Frameworks are preferred by Adobe why how did opencl fail how often as I lead the better choice compared to when no login Frameworks like metal cooler Etc yeah um uh so the well a lot of our parallel code is written in a language called halide uh which is uh uh a language specifically for doing uh uh image processing and it can Target um uh basically code running in a thread pool on a CPU that's simply optimized or it can execute on GPU or kind of any mix in between and so a lot of our lower level code is written in halide and halide's been a collaborative a collaborative effort to develop between Adobe Google and MIT um uh and so so it's kind of a a parallel environment embedded inside of um uh C plus plus and then uh uh uh uh Intel TBB uh gets uh for fairly high amount of use inside of adobe is probably the you know number two most used system going next to halide a lot of people don't know it but TBB is open sourced and uh which means like when we were doing Photoshop for the browser we did our own port of TBB to wasm and now since then Intel's been been has released class of support and so even though it's you know Intel TBB it does have arm support and so you can run it on iOS and you can run it on Android and even run it inside of wasm uh so so it's a a fairly nice concurrency environment um I've been uh tracking Eric niebler's uh kind of structured concurrency Center receiver stuff uh that's not getting any play that I'm aware of currently inside of adobe um uh I think it will I think it's an interesting Library um uh uh solves a lot of the problems I've got some things that I wish it solved that it doesn't but but in in general I think it's an improvement over a lot of the things out there uh which includes my own libraries which are the the St lab currency libraries uh those uh I I gave a talk on currency and I wrote the library uh basically well I was at C plus now because I thought I would take the code I wrote for the talk and check it into a GitHub repository was basically how that Library started and uh it's it's since evolved quite a bit and I've had uh some external contributors uh including Felix petraconi who's who's contributed a huge amount to the library and uh one of the key features of that is it provides uh portable abstraction uh For Thread pools that will back end into the platform thread pool system if you have one so uh under Windows it will use Windows thread pools and on Mac it will use Apple's lib dispatch and on Linux it can use the dispatch if you have live dispatch and it's got It's configurable to use uh the the cute uh thread pool so if you're running inside of a cute you can use their thread pool and if you don't have any of the above options it's got a high performance portable thread pool that it will spin up and uh uh uh so so for that reason it gets a fair amount of play at Adobe because it can it can basically Run Anywhere and uh it's also got an interesting uh Future model it's it has Futures with continuations and continuations behave like regular types so you can Fork computation by just copying a future and attaching continuations to it going in different directions and it's got an interesting cancellation model where uh it applies uh raii principles to computation and so if you let a future go if you let a future destruct the assumption is then you don't care about the result of any computation leading to that future and if that was the you know any computation for which for which the the the only dependent is that future uh will get canceled and so you can view it as you know within your code you end up with a a graph it can be an arbitrary dag of these of computations uh leading to Futures with continuations with more computations attached to them and as you you let things go the right things cancel so uh so that's been getting a fair amount of play inside of adobe both are our AI team has been using that and there's an effort to uh rewrite the Photoshop VM system that's been using that so well we are now a bit past the hour do you have more time for more questions or shall we close yeah yeah if there's more questions I can answer one or two more okay uh let me look into um there's two questions about gpus uh one is about um PMR allocators use Virtual functions and if you write software for low-level GPU Hardware then you cannot use these as allocators if you would like to use allocators wasn't a must couldn't they make it optional to have virtual functions in PMR allocators uh I you know I've never been an allocator fan because allocators invert the whole part relationship so I'm much more a fan of doing kind of explicit data structures into which you you you uh uh uh uh construct objects so so if you need to do those things um you know I think every every use of an allocator is kind of hiding uh an interesting data structure um uh and I don't think allocators get much much play in Adobe uh uh could the V table in in pmrs have been optional okay maybe I mean if you know me I'm not a fan of inheritance anyways uh uh it could have it could have gone with a type Erasure approach um uh uh you know I also think you have uh GPU systems uh like Cuda which are are increasing looking to just run any arbitrary C plus plus so the problem will probably resolve itself over time as we get more uh more fluid computation models uh uh uh executed on gpus which is you know a huge mess right now right I mean you've got you've got Vulcan and Cuda and dx12 and metal and uh uh uh that's one reason why why we have a significant investment in halite it's just supporting all of these GPU environments as a pain so so that's my answer to that one [Music] yeah there's a similar question about how efficient and portable GPU programming could be added to the standard like you know how do you support GPU programming in ISO C plus plus yeah um uh uh you know like I said the the you know Cuda guys are probably furthest along so you know Bryce adelstein would probably be a better person to to ask this question of um uh uh and their approach is just trying to get you know all of C plus plus executing reasonably well on on a GPU uh the biggest problem that you have on gpus is uh gpus don't like sharing at all and in within C plus plus it's very hard to tell what's shared and what's not shared uh there have been you know a few attempts and things like uh uh uh adding annotations you know for you know restrict or or don't Alias or things like that around around arguments and around data uh which that tends to be somewhat problematic to use my personal thought is that something along the lines of of cpp2 or along lines of Val or even along the lines of rust um uh where where if you have sharing the sharing has to be explicit and the default is no sharing um uh uh you know use the direction that will actually get us to to higher performance general purpose computation on uh on a GPU um uh all of that said uh uh still uh you know the GPU isn't some some Panacea the the bigger problem is how do you find things to parallelize within your within your code base uh uh you know I see an awful lot of code that's written in in environments that have you know an async await model where the the code is you know looks like you know a weight to make this asynchronous call which really isn't introducing any parallelism at all it's uh uh it's you know it's just just uh a a weighting along along a single thread it maybe is allowing other things to execute assuming you have those other things and uh you know for a lot of systems it's it's coming up with you know unless you have things that are trivially parallelizable like you're doing image processing operations or you're doing ml or things like that uh you know it's coming up with enough work that's independent to execute across you know an 8 or 20 or or 64 core machine so so I think that's where the the larger problem is is is is how do we somewhat rethink the programming model to to scale better okay I think that is a great sentence to end uh this uh Hama thank you for coming Sean hey thank you again it was fun oh yes and with that I'm going to end the stream in a second any last words anything you want to say no if anybody has follow-up questions of like DM me and Twitter is probably the easiest way I'm at Sean parent so I'm easy to reach and thanks thanks for attending