reverse engineering um is used all over the place as you say is at a high level it's just trying to take something that exists and from what you have the thing you have trying to work out how it works so rather than sort of having access to the source code um or the original specification for the program that's written you've only got the final form or perhaps the source code at a low level and you're trying to work out how it all works so that you can then produce an alternative the classic example of this was compact when they'd cloned the original pc all the hardware was open standard stuff you could go by the chips off the shelf from intel for the interrupt control of the cpu and so on the key that made it a pc though was the ibm proprietary bios that was on a chip on the motherboard so if compact wanted to produce a clone they needed to give their hardware they couldn't give it the same software because that was copyright but they used to give it similar software that worked in exactly the same way so that when you loaded dos onto it when you loaded the software it ran in the same way so what compact would have done is reverse engineered the software someone would have stacked they would have taken the bios off the motherboard they would have looked at the bytes stored in that rom chip and then they would have worked out how that bios program ran on the computer and then they could then produce a specification to create their own another time you might use it you may have a piece of software that is no longer supported or has been around for a while you need to extract data from it classic example of this was the bbc doomsday system this was a phillips laser vision player which was a laserdisc multimedia system produced in the late 80s by the bbc running on the bbc microcomputer system that sort of captured the snapshot of the uk in 1986 but those later discs are now rotting literally uh and the data is inaccessible unless you can find a working player a working system a working bbc micro and so on so people have reverse engineered the software that to try and extract the data these days where people use reverse engineering is in cyber security um if you get a piece of malware you want to know what does that malware does who wrote it um sort of is is what i've seen it do the only things it will do always at some later stage waiting for to jump out and run at a later point to find out what that malware does and so again reverse engineering is one of the tools you would use to sort of work out what that malware does let me think about software for a startup you when you code something you then send it usually through some kind of assembler it turns it into a yeah that's a really good place to start if we think about when we wanted to write a piece of software we'll normally start off with an idea let's say we want to write a program to count words in a piece of text so we start off with that idea and we want to count words and then as we write that software we start to break it down into chunks we start to define how certain things are going to work until eventually we get to a point where we can write the program code and then once we've written the program code we can feed that through a compiler which will produce the machine code and it'll encode that in a format that the operating system can run because it's not just usually unless you're running something like dos or writing the bios on the thing just raw machine code bytes you've usually got some data around there that tells it how to load it in what's the program code what's data what are the libraries it might link to as well perform the executable format probably should do a video on that at some point so at the other end we're going to end up with a file on our system and let's just use the windows.exe extension so we know what it is so we're going to start from an idea and we're going to end up with the program code that we can run so if we're going in that direction this is programming coding software engineering whatever you want to call it so that's in that direction reverse engineering is basically going in the other direction we've got the program we may know what he does at some point because we've run it might be a word processor it might be a problem that counts words it might be a piece of malware we're unsure of what it does it might be the biosphere pc we've probably got some high level idea what it is but we wanted to go in the other direction so reverse engineer is going in the other direction so we've got some idea of what the program does but we also want to know how it does that how it's implemented because if you think about if we're trying to write a program that counts words the cat sat on the mat full stop we've got our text there now i want to count the words in that okay how many words are they i've got six six what are you defining as a word as oh yeah so i i would say a collection of letters that is preceded or whatever by a space okay so if we're going to do that so that would be one word separated yeah separated but that that would be two words that would be three words is the full stop part of the word or not uh yeah tbc and that's the point that's one of the things we have to define so we're starting from the idea we want to count words the next thing we have to do is we need to start to define that so we need to define those ideas in more detail and this is a simple program so we need to define what a word is and we could say something like a word is a run of characters that aren't spaces okay what's the space well that's a character of some sort in there yeah but again we need to define it so the space is ascii 32 that's the normal space we probably want to put the tab character which is ascii 9 line 3 carriage return so we've got 10 13 probably some others that probably do for now answers on a postcard for the definition of spaces we'll do a whole video on what space is and it can be no no i'm only joking but but the point i'm making is we have to define what these things are so as we go from the idea we start to make it more solid we start to break it down so we're sort of breaking the problem down just like we've done here we now know what a word is we now know what the space between these the separations between them we have to define that a space is that and so we could also say here that separate words by one or more spaces and for a word counting program we probably don't need any more definitions for that if we're building something bigger let's say we're building a word processor we would have data structures that we need to define how we're going to store a line of text do we saw a paragraph as a series of lines after they've been formatted or was a single block and then we say it's the end of paragraph at the end of that how do we define all those things we need to define those things so i'm going to say that we break down the program into a series of data structures and the other things we have is the program code or the other way of describing that is the algorithms nicholas worth read a book programs equals data structures plus algorithms fred brooks the author of the mythical man month made a a quote that sort of show me your flowcharts i your program and conceal your tables i.e your data structures and your program will be a mystery to me show me your data structure show me your tables and i want you to look at your flow charts and paraphrasing uh because the pro will be obvious and so we break down the idea into the data structures the algorithms we're going to use and then we will express them in a programming language and i'm going to use c because what else is there to use and then that high level language here will start to express these algorithms that start to express these data structures as code at this point we're probably still thinking in abstract terms and then once we express that in code so that's the actual coding part of it eventually we will compile and we will link this using our compiler to produce the executable and as we go from the idea here we're getting further away from just a raw idea we're getting further away from the data structures towards what the cpu will understand so it's becoming more specific is this kind of a is this a standard pipeline does everything go through this development pipeline or is it pretty i mean yeah you would probably i mean minor coding you may design a data structure but that data structure is there you're breaking it down it's not you're going to have it's not a waterfall nothing's ever a waterfall in computer science unless you're doing it wrong i'm only joking uh you've got the idea that it'll end up being more specific and so on when we reverse engineering effectively what we're trying to do is get to around this sort of stage from only having this so it might be that we want to work out some of the data structures how they're using the program like the bbc doomsday we want to be able to process the data write a new front end for it so it can be accessed on a modern equipment if it's malware we're looking at we're probably more interested in what the code's doing because we're interested in how it's doing that and things if we're reverse engineering the bios we're probably actually interested in both because we want to be able to sort of produce an equivalent and if we know how it's structured because that's what other things are using we know how it's implemented we can work out the ideas we can then go off and give it to someone else who can write a new version never having looked at the original and so on or we can write a report on how the malware works so we can then go and sort of look for certain things on our network we might see as we reverse engineer the malware for example that it's going to send data to some ip address or something we can then set the network up to detect that and then say hang on that machine's infected possibly then go and investigate so reverse engineering is going from something very very specific the binary and getting it to a more general thing so we've got more of an idea of what's going on you will use some of the same techniques you would if you've ever read a program you sometimes you get given a program the source code you're playing when you just open it up and read it because you want to extend it you want to add some features to it or you're just wanting to understand how it works you're already doing some of the things that you would do when you reverse engineering it's differences when you're here things are very very specific some of the things that you've got here like if you write a program c you'd probably be able to see what the data structures will look like because they will have a struct and you'll see them laid out you will see an array uh if you're running something in java you'll see the objects define the classes that define those objects and so on when we've got a binary when we've got an executable you can't read it at the human level if i um well let's just have a look at a binary if i just cat a binary here wc then what we end up with there is some text in it we can see it's got the apple certification but the vast majority of it is well unreadable we can make things slightly easier for ourselves and we can run it through a hex dump and just have a look at the heck the actual bytes their values as hexadecimal values so we do the same thing and i'll put it on screen we can now start to see what the program looks like we can see some of the magic hexadecimal numbers that apple used to identify this as a executable file and what you could do is find out if you looked at the format of this and again we'll do a video on executable formats at some point because i think it'll be a good one you can find out within the file probably around here where the program starts and you could and i have done this on a couple of occasions work this out manually you could look at the hexadecimal bytes and say that five five that's what we call the op code the code that represents an operation that's this that has this effect four eight has some other effect and so on and we'll work out what the prone does that's the manual way to do it the alternative is that we can use a tool called a disassembler and there's various ones around the one that is most commonly used is probably ida the interactive disassembler which i've got open here and when you open up the program in ida it converts it into the op codes that make up that program so for example rather than seeing a series of numbers i see that this is pushing rbp onto the stacks the machine code instruction push takes the value in a register or some other location and pushes it onto the stack for you and so you can start to read what the program's doing and then you can effectively do the same sort of thing that you do if you're reading a program to sort of work out what's going on but as i said this is the level that you're dealing with there's no thing saying this is a data structure you may see the program storing data in a memory location or reading data from a memory location it's up to you to piece together what these instructions are doing to understand what the program's doing now you can do get the software to help you so for example ida has a view where it'll sort of break the program up based on where this sort of loops and what you don't have loops in machine code what you have are branches or jumps which you can use to create loops by saying if this condition is met then jump otherwise don't jump don't branch and so what ida tries to do is to sort of break up the program into these blocks and sort of show you with lines between them what's happening at different point that makes it easy to see things but it's still exactly the same code not all disassemblers do that it's a nice feature for looking at what's happening so what you end up doing when you reverse engineering is a bit like being a detective you've got to follow what's going on the program code as you read it will give you information about what's going on and you can infer from that certain things and so you can look at things and say okay that's likely to be an array or that's likely to be forming a linked list and from that you can start to infer what the data structures are you'll probably get it wrong so you'll need to keep notes and then you'll some come back and say okay no it's not that type because of this therefore i can work out what's going on here so what i've got loaded up at the moment is the word count program just to see how you can start to unpick what's going on in this program this program i've never opened up in ida before now one of the things that makes it easier as a job is that it's unusual for the code to exist in isolation if it wants to do something it's got to talk to other bits of the system this program if it's going to run needs to talk to the operating system if it's talking to the operating system it's going to have to call system calls which are defined so if you look on microsoft website you can see the windows systems walls if you look at the documentation on apple's website you can see the ones they use same for linux for example here i can see that this program here is using the call instruction and it's calling the get opt library function which is used to find options that are in the program so just by opening it up and spotting get up there i can see that it's also passed a string to get opt and if i look at the documentation for get opt command 3 get opt then we can see that it takes in three values the first one is the number of arguments the second one is the array with those arguments in the sort of standard rc rb that you get in a c program and then the last one is the option string and that option string is defined here as containing the following elements individual characters and characters followed by a colon to indicate an option argument is to follow so we can look through that string and we can spot that string here and so immediately just opening this up with a disassembler i now know that this program can take the option c l m or w and i can see that it's setting rdx one of the registers to have a pointer to that string therefore because i know how functions are called on the x8664 architecture that i'm looking at here i know that that's going to be the ops string argument i can say that okay this program has four possible arguments c l m or w okay well what do they do well we can continue reading through the program and see what they do in the program and we can also see how the program works at this point so that's just a quick example we're not going to go through the whole program to work out how it counts the words although we could leave that as an exercise to the viewer you can download a free version of ida pro or other disassemblers is binary ninja there's a command-line one called redare there's ghidra which is available from the nsa and things that you can play you can work at look at these things so something like the word counting program is relatively simple and we could have gone further and looked at how it actually sort of counted the words we could have seen by looking through that codes sort of what does it define a word as what characters would it take of defining or what series of characters would it have taken as defining a word what series of characters would they have taken as defining the the gaps between the word the spaces and so on and we could then produce a specification for how that program worked we can do exactly the same thing with any other piece of software whether it's the bios chip on a pc whether it's the doomsday software we can understand how the data structured on that whether it's a piece of malware we can use the same ideas looking at the code looking at how it manipulates data and sort of use that to sort of infer from that evidence of how the sort of data is structured and then we can test that we can come up with in and what do i mean by testing that well we can say well if this is say we think if this is a linked list say we think we see some code that says this might be a linked list or we can say well okay is it checking for null at the end of the linked list which is what you'll often do can we see the code doing that um if it isn't maybe it's a ring buffer and it's doing something like that we can start to ask questions based on the deductions we make whether something is true whether the deduction stands up and as we look at more code that will become more obvious or it'll contradict that deduction and we can start to sort of piece what's going on in the program as i said you can do this with something like the bios with the doomsday discs with the word counting program or with a piece of malware and again there you do exactly the same thing to find out what is this malware doing what part of the system is it trying to infect how does it try and hide itself on the system does it even try and hide itself or is it just completely destructive um is it trying to talk to any other systems on the network it's not the only tool you have for something like malware but it can really help you to see what's going on and you might find things that you wouldn't spot in other ways new feature new feature probably is right sean is currently reverse engineering his camera to find out how he's worked because he hasn't back home because he hasn't read the manual but uh i haven't read the manual uh it's classic it's got about four pages and then it's look at the pdf yeah yeah that's the standard