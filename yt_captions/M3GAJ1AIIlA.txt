Hello and welcome. I'm James Murphy. And in this episode, we're talking about chained comparisons in Python. By a chained comparison, I mean an expression like this where I have multiple comparisons. In this case, I have two less thans that appear in the same expression. So, this kind of thing is totally fine in Python. You can have as many of these strung together as you want and you can mix and match operators. I can use less than, less than or equal to, equals, those kind of things. And as long as each of the things pairwise makes sense, like 5 less than equal to 10, as long as each of these things makes sense, then this is a valid thing you can do in Python. However, what it means is a little bit non-intuitive. Python tried to make things work a little bit more like the way that math works. So, this expression, x < y < z, is supposed to mean what it would in mathematical notation. Namely that, y is between x and z. This might be a little bit counter-intuitive especially if you're coming 
from a different language, or if you're trying to comprehend, like: "Does this happen left to right and where do the parentheses go?" that kind of thing. So, if you tried to think about it and you said: Okay, I know y less than z returns a boolean. So, is this supposed to mean, like y < z, okay 1 is less than 2, that's true, x is 0. 0 is less than true, that's true? And you know putting the parentheses over here wouldn't really make it any better. If I did this, you'd still be like comparing a true and a false versus another thing. But in Python, they sort of did away with this idea that you pick a left to right or right to left way of evaluating the parentheses and instead they made it mean following. Whenever you have something like this, where you have multiple comparison operators in a row, then you basically just put an and between them. So, what I had before is equivalent to x is less than y and y is less than z. Doing it this way can save a little bit of typing, sure. But one of the main benefits of doing it this way is that if I have a temporary variable where I don't really want to give it a name if I have something like, you know, I call some function and I get the return value of the function, I don't have to now call this function twice. If I wanted to do it just in the old written out way, then I would have actually two calls to this function. And if this function was an expensive function and I didn't want to make two calls or if it was something that like had side effects and I didn't want those side effects to happen multiple times, then I would sort of be forced to make a temporary variable storing the value of the function call. So, allowing these chained comparisons definitely saves on more than just the typing. It does prevent you from having to do this kind of pattern here. But the language is actually very very flexible about chaining these comparisons together. So much so that, I think that most of the time you probably shouldn't use this unless you're just doing a very simple comparison like x is less than y is less than z. I think intuitively once you understand that this kind of thing is happening, it's pretty easy to follow and it can make code more readable even. But look at all of the things that you could use in a chain comparison. So, you can use a less than and greater than, less equal, greater equal, equals, not equals, is, is not, in and not in. All of those things for the purposes of Python are considered comparison operators. And they can all be chained together. That means that here I could do something like this I could say x is less than y is greater than z Now mathematically, what is this supposed to mean? I mean, I know Python and I know that the rule is that this means x is less than y and y is greater than z. But looking at it, just looking at x less than y greater than z that no longer really makes sense to me. It makes way more sense to have the and in the middle there and to have a temporary variable for a function call if I need it. I don't think it should really even be allowed to mix like less and greater like that in these chained comparisons. I don't think you're going to do anything but confuse people if you mix a less and a greater and a chained comparison like this. So, let's just go over some examples of what I think would be good use cases versus questionable versus just outright bad. So, here what I would consider good use cases. I would argue that in these cases, it's actually more readable to use the chained comparison and it agrees with mathematical notation and just looking at it it makes sense what it's doing. It's more readable than what you would have if you wrote out the explicit like 0 is less than x and x is less than 1. So, for this one, clearly I'm saying x is strictly between 0 and 1. That makes sense. You can express things like closed and open endpoints, you can express loose inequalities, you can do things the other way around, all of these things just make sense. It even makes sense to have three things all being equal to each other. I think what makes these good cases is that they're all using sort of the same direction of comparison operator. I can still go x is less than or equal to y and y is less than or equal to z. So, x is less than equal to z. It makes sense to skip from the very left to the very right. And that's because these comparison operators are transitive. That's that property. If I have x is less than y and y is less than z, then x is less than z. So, as long as you're sort of respecting the transitivity of the operator, then I don't really have any problem with chaining the comparisons. Okay, let's look at some more questionable examples. For these examples, I wouldn't necessarily be upset if someone tried to submit a pull request that has something like this to one of my codebases. But I probably wouldn't write something like this myself. Just because I know that when someone sees, you know, a big long expression like this, they're going to have to stop and think, like, What is even happening here? Like, they're going to have to take a second to realize that this is a case where they need to think about it as a chained comparison. What this one is saying is that y and z have to be the same, x and y are between 0 and 1 with x less than y. It's definitely cluttered and I would consider refactoring to make it more readable.  But I wouldn't say that it's bad. In this example, this part is completely fine. And I think that this example is only questionable because it's not really clear how the not equals plays into this. Is it supposed to be that none of these things are equal to one or just that z isn't equal to 1? Well, since we're saying that they're all equal, it doesn't really make any difference. So, that's why I would still include this in an okay to questionable use as opposed to a bad use. So, I think that this example and this example are not actually that questionable. I only include them in this questionable use-case scenario because I think that most people probably aren't aware that is and in are considered comparison operators and can participate in this chain comparison operation. If you didn't know that is was allowed to participate in comparison, I would probably just think this is a syntax error. But once I think about it as a comparison, then yeah, it makes sense that I'm just saying that x, y and z are all identical. They're pointing to the same object. There's nothing too radical about any of these examples and as long as you have a general awareness that the rule exists, then you're not going to be confused by any of these examples. However, let's move on to the: Why are these even allowed examples? These are really bad use-cases, in my opinion. I'm actually not sure why this is even allowed. If you read the documentation, it's clear that the person that wrote the documentation knows that this is confusing. They say something like: Oh yeah, this is allowed. You're allowed to use mixed, like, less than and greater than or any of the comparison operators. But it's not pretty is the term that they used. So, why this is allowed I'm not quite sure. But it's clear that they knew that it was a bad idea, basically. My only guess is that it was due to something about the ease of implementing it in the language and perhaps due to limitations of the parser. Here's another bad example. x is not equal to y is not equal to z Now, if you were to write this in a math paper, it's probably going to be interpreted that none of these things are equal to each other. not just x is not equal to y and y is not equal to z So, in this case, I think this actually disagrees with what your intuition might say. My intuition looking at this says: This should mean that x, y and z are all distinct. But it actually doesn't have that implication. It still could have the possibility that x and z are equal to each other. And that's what I think makes this an especially bad use. I think any time that you use a not equals as part of a chain comparison, it's probably going to confuse people, especially if there are multiple not equals. And of course, you're allowed to have as many of these things mixed together as you want. So, you could write something like this and this is perfectly fine. Who knows what it means! I don't even really want to parse it. I just wrote it to show a bad example. And here's the motherload of all bad examples that I could come up with. Leave your bad examples in the comments below, by the way. We're mixing less than and greater than and we're mixing the right and left bit shift operators. If anyone knows what this code is supposed to do, go ahead tell me. Now obviously, no one in their right mind is going to write something this terrible except maybe for an obfuscation contest where you're supposed to make code look as unreadable as possible. But I'm just trying to show this as a point where why is this even allowed in the language. Now, I know Python has a lot of sharp corners. It has a lot of features. I have a whole video on what I think is the sharpest corner of them all, a sort of a hidden thing that Python does that's really unintuitive. And that's sort of just expected. Every language is going to have these things that are counter-intuitive or if you don't know the rule, then it's not really going to make sense to beginners or you know that kind of thing. But something like this, I just think that really shouldn't be part of the language. Now, I'm not sure how the Python core developers would feel about potentially breaking old code that depends on this. But I think it is a good idea to probably rein in these chained comparisons and not allow things like less than and greater than to be used in the same chained comparison. So, I'm not saying that we should get rid of chained comparisons altogether, just the ones that inherently don't make sense, like using less than and greater than together. On the other hand, I would like to see an expansion of chained comparisons to other cases that do make sense. So currently, as of today, if you have something like a NumPy array, it's not currently possible to do something like this. I can't chain together 3 is less than x and x is less than 5. So, this kind of thing doesn't actually work in Python today. And I think there is a proposal about a way that it could be made to work. But that is one direction that I think that it would be okay if we expanded chained comparisons. And that's all I've got. Thanks for watching. If you liked the video don't forget to like, comment and subscribe. Special shout out to all my patrons and donors. Thanks for watching.