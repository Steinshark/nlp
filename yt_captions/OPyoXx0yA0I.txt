something you'll quite commonly do in your application is talking with other apis so today I'm going to look at a few options for doing that in Python in particular requests ioh HTTP and httpx I'll talk about the differences between these packages and why I think out of these three you should use the one that has the least number of stars on GitHub and not just because I like to support the underdog now before we start I have something for you it's a free guide that teaches you how to design a piece of software from scratch you can get this at rm. codesign guu contains the seven steps I take when I design new software and hopefully it helps you avoid some of the mistakes I made in the past iron. gold/ design guide the link is also in the description of this video the def facto package to do HTTP requests in Python is called requests now it's not the only Library not the only packet that is available there are others as well for example there's IO HTTP not exactly sure if I'm pron pronouncing that correctly and the newer one httpx so today I want to take a closer look at these different packages and see how they're different and which one I think you should use so requests is the oldest package ioh HTP is slightly newer than request the main thing that it does differently is that it's built on the concurrent model so it does allow you to do HTTP requests concurrently and that can actually make a massive difference in the responsiveness of your application I'm going to show you an example of that later in the video and finally we have httpx which is the newest one of the three packages httpx also supports concurrency just like IP but slightly differently now if you purely look at popularity request is the most popular looking at the number of stars on the GitHub rep story ioh HTTP is less popular but still growing and then we have the newest one httpx which is growing fast in popularity I think within maybe a year or or maybe two httpx will overtake ioh HTP in terms of popularity I want to start by showing you a very simple example of how request works this you probably already know this but just to give you an overview this is a simple script that I wrote which has a couple of fetch functions there is a get a post a put and delete which all use different HTP verbs what I do in this example is that I use a website called HTTP bin. org which is very useful for testing HTTP request so I'm just trying to do get request I send some post request and then actually HTTP bin will return that data to me as a result so I can return that as a Json value here and same thing with put and I also do a delete request and then finally I have the main function where I record the time so that we get some performance metrics these don't say everything but it's still useful to see what's going on and then we have get post put delete and I simply print the result of these requests so that's basically what requests does right you can send off these HP request and get the result and then do whatever you want with it and then after I've done that I record the end time and then I calculate how much time this took in seconds so let's run this and see what happens so you see it's now sending out all of these request and in total this took 1.65 seconds there is some variability in the time if I run this again you see you'll get a slightly different time 162 sometimes it can take even longer like over 2 seconds depends on how congested the network is but that's the general idea and you see that these responses as I print them they come in one at a time now the nice thing about request and this also why it's so popular is because it's ridiculously simple to use if you want to do a get request you just call request.get and you pass the URL and it does a get request that's it you can supply timeit and of course you can supply lots of different options like a timeout that pilent is complaining about here or you can add headers or anything else that you need requests supports all of that it's just very simple to use which explains its popularity now the issue is that because it's so simple to use it's optimized for Simplicity and not for performance so request in its default way that you would use it is not very optimal in terms of performance the main problem with using a request in this way is that you create a new session you create a new connection every time you send out a request and that takes time now a better way to use request that's way more performant is by actually using a session what is a session exactly well a session manages a pool of connections for you and that's actually way more efficient because then you can reuse connections instead of creating a new one for every request that you send out so by default this is not how request works but you can actually use sessions with requests and it makes it way faster so here's an example where I modified that same script to use sessions now instead of just calling directly get and put post request Etc so what I've done differently is that I first create a session a request. session and then I pass that session object to each function and then I'm using the session to do the get post put and delete request for the rest the script is exactly the same so when run this you see that it's actually way faster it's like twice as fast 0.82 seconds instead of 1.6 or sometimes even two seconds so this makes a huge difference so sometimes you see it's still slower but overall it's going to be way faster than if you didn't use a session and this is something that's relatively easy to add to your application that's going to just make it way more performant just using sessions in short if you use requests in the default way it's going to be slow you need to dig in a little bit deeper to figure out that this is what you need to do to make it a lot faster but that's not the only problem the other problem is that request doesn't support concurrency we're still sending out these HTTP requests one after the other we wait until we get the result from the previous request before we send the next one there's no reason to do that we could send off those four requests all at the same time and get the result back whenever each of the requests get the result and we don't have to wait for one request to send out the next one because there is no dependency between them sometimes there is you need the information from the previous request to send out the next one but in this case we don't so we can optimize this by calling these requests concurrently now request does support that but that's where a package like IO HTTP comes in which does support concurrency here's another version of the same script that uses ioh HTTP instead of request now actually at the moment this doesn't run because I'm using using python 3.12 and IP has some issues with releasing a version that's compatible with python 3.12 so I'll just show you how it works now in the video but I hope by the time that you actually download the example that you can actually run this without any issue now the main difference between IP and request is that while request optimizes for Simplicity iosp optimizes for performance so the default behavior in IP is that you have to create a session and not only that if you scroll down you see that we create the session here which we pass to each of these functions but then we also need to use a context manager when we call session. get to retrieve the response so you always have this layer of two with statements and that makes your code a little bit more complicated now this is the fastest way to do it but it does mean that you will have extra boiler plate codes even if you just want something very simple and you don't really care about performance I do do get the difference in approach between ioh HTP and request but they also understand that most developers are probably just looking for the simplest solution and they don't always care about performance all that much which is why request is probably way more popular than ioa CP there's also a few other things that IP can do by the way like hosting a web server but I think most developers probably want to use dedicated library for that like Fast API so I'm not sure developers are willing to make that tradeoff of performance for Simplicity but I'm curious what's more important to you simplicity at the cost of performance or performance at the cost of Simplicity let me know in the comments the final package that I want to talk about is httpx and what I like in particular about httpx is that it's like completely compatible with request it works in exactly the same way you just import httpx instead of request so here you see an example I simply have htbx doget post dop put. delete no complicated things it's very simple and then in the main function it looks exactly the same now just like request this is not the most performant way of doing it because there's no connection pulling which we want if we want to have fast HTTP request handling so just like the request package httpx also has a connection pooling mechanism but that's handled via a client so in this case it looks almost the same but then we create a client we pass that client to the various fetching functions and then we call get postp delete on that client and when I run this then you see that it will also be pretty fast except now for some reason it's very slow obviously let me try that again yeah there we go so seems there was just some Network issue so now we're back at less than a second again and now it takes a lot longer so there's a certain level of unpredictability in doing things over the Internet unfortunately but connection pooling definitely helps make things a lot faster and by the way if you like these kinds of deep Dives you might also enjoy my Discord server that you can join for free at discord. ion. codes it's a really cool Community lots of knowledgeable people people helping each other with coding questions design questions lots of senior Engineers there as well so join for free via the link I've also put in the description of this video now finally I want to take a look at concurrent requests with httpx so like we've seen we have these multiple requests that we're currently executing in all the examples that I've shown you until now I just went through the request sequentially waiting for one request to complete in order to start the other one but if you do it concurrently it can save you even more time so with the current connection pooling mechanism we're at about 0.6 to 1 second on average but if we do it asynchronously if we add concurrency to the mix can be even faster so here's an example of a script using httpx that uses concurrency so what I'm doing here is almost the same as what we had in the previous script I'm passing a client but this time I'm passing an async client so next to being fully compatible with request httpx adds features that allow for concurrency and if you want to do that and combine it with connection pooling which is optimal then you need the async client so also now these functions are async so I'm python if you want concurrent Behavior then you need the async and await keywords so I've turned these functions into async functions and then I'm awaiting the response so that's the concurrent part and then I'm returning the Json data and I did the same for post put and delete so each of these functions is now concurrent and then what I can do in the main function is that I do a with asent client as client so that creates the client I create the tasks so these are the calls to these four concurrent functions get post put delete and then I'm calling ASN k. gather which is the method in Python to perform tasks concurrently so this calls these four functions concurrently and then we get the results and then we can print the result and again I'm recording the starting time and the end time and then I simply compute how much time this took so when I run this version of the script then you see it's even faster and it just prints out everything all at once because it runs these requests all at the same time so let's try that again so 0 to 71 seconds 49 seconds 69 seconds 0.39 seconds so without doing a complete comparison you can already see that this is even a bit faster and the more of these requests you can do concurrently the bigger the gain is because then you're going to save even more time because you don't have to wait for the previous request to return the result in order to start the next one so when you create a script that needs to talk with different apis make sure that hey you use connection pooling because that just saves a lot of time and B send out requests concurrently wherever you can there's one thing you need to be careful of which is raate limiting so if you're sending out concurrent requests to one API and then Lots at the same time then you may hit a rate limit and that's of course not something that you want to do so that's what you need to be a bit careful about but overall sending requests concurrently instead of sequentially makes a massive difference for your application final thing that I wanted to mention about these three packages requests ioh HTTP and httpx is the license and that's often ignored by us you know we simply see it on GitHub and oh let's use it but actually when you use it in a company you always need to take a look at the license as well you're able to use the tool commercially now all three of these libraries you can use commercially there's no big issue that's a slight different between the licenses request and ioh HTP both have the Apache 2.0 license whereas httpx has been released under the BSD 3 Clause license now I'm not a lawyer fortunately because I would just say objection you're honor the whole day because it sounds so cool but in short these licenses there are quite similar and that they're both remissive they're for open source the Apache License offers a bit more legal protection especially related to patents uh between contributors of the package and the users uh the bd3 license is a bit vague in that regard so if you're dealing with patents a lot and you want to be well protected then probably you should go for the package with the Apache 2.0 license but I don't know how important that is to you I just wanted to mention it as a difference I hope you enjoyed this deeper dive into HTTP request packages in Python if you did give this video a like it helps me reach a wider audience here on YouTube now if you want to learn more about concurrency I did a video a while ago where I covered the async io package in more detail you can watch that right here thanks for watching and see you soon