recently on developer voices we took a look at the zig programming language and a few people got in touch to say well if you're interested in SE like languages you should look at hair as well it's a language in the same space but it's got quite a different set of goals it has different ideas about memory management and types about metaprogramming and probably the most ambitious of its goals is to become a 100-year language a language you'll still be using in the 22nd century I can't even begin to imagine what programming will look like Next Century but Drew dult Our Guest this week has plans to make sure hair is on the list and if 100 years sounds like too lofty a goal for you he makes the point that sometimes it's hard enough to get a 5-year-old project to compile might be quite refreshing to have a language that just guaranteed no breaking changes this decade so what are hair's answers to the problems of SE what's Drew's strategy for the long long long term and for bonus points we end up talking about Aries which is the operating system that Drew's been writing in hair to prove you can write an operating system in hair let's get stuck in I'm your host Chris Jenkins this is developer voices and today's voice is Drew [Music] Deval [Music] joining us today we have drew Dev Vault Drew how are you oh I'm doing great how are you doing I'm very well I'm very well I'm looking forward to Christmas it's that time of year around here likewise I just uh wrapped up my partner's presence and stuck them under the tree ah so they're probably hiding under the tree scratching at it with a fork right yeah well the cats certainly is perfect so the other thing that's keeping you busy apart from wrapping presents you you're one of those people that has a tremendous ambition here because we're going to talk about uh your programming language you're writing a programming language and an operating system at once right I am yeah that's you're either mad or a genius so we're going to spend the podcast finding out I'm not sure the two states of being are discernable from each other that's true it's generally in the results that you figure that out right but let's start with your language which is called hair and it's firmly in the sea tradition of languages right yeah more or less I'd say that what makes it not C why wasn't C good enough for you well you know C is uh very popular and it has a lot of staying power um but it wasn't exactly designed to it just kind of accidentally ended up being a staple because uh it was attached to Unix and it was capable of doing a lot of important things uh so I think what distinguishes here from C is 50 years worth of hindsight that c never had um and so it's got a bunch of uh features which address shortcomings in SE which is things like um improved safety features improved era handling a dramatically improved standard Library things like that okay well I mean that the thing that raises is 50 years of hindsight there's a heck of a lot to choose from oh yes and you could look at something like I don't know you could look at Haskell and Idris mhm for instance and they'd say our 50 years of hindsight says let's throw mathematics at it right what what do you learn from 50 years of hindsite well you know I would disagree with the haskill group on the basis that uh functional programmers uh tend to imagine an ivory Tower uh where everything is made of pure math and I imagine the computer which is sitting in front of me and try to think about what it can do um you have to excuse the jab at the functional programmers I do appreciate them no I I will neither um I will neither defend nor be offended I want to know what you think of the world yeah yeah I mean so when I look at C I see a lot of things which uh are important and which some of them can be attributed to its successes some of them are better perceived as failings um and I think uh you kind of see something in C which is like it came around from Unix and Unix was kind of designed for a certain purpose and in a certain time where um you know you see these trends older operating systems where there's a little bit less thought in the design and a little bit more about what can we make work and at the time it was great and it made Unix possible but you see a lot of these baggages surviving on and so some of the things we can learn from C is you know a broad broad applicability to many problems um a really great sense of portability a nice standard in many implementations uh and access to low-level Primitives which is all very important and we can also see things which we don't as much like so we see a lot of the baggage of Unix and posic which is a little bit iier things like a global eror no um is kind of like a an example of a weak decision um and we've seen in the time since eror handling become understood to be much more important than it was understood then and so there's an opportunity there to revise that design with its importance in mind and with a more deliberate approach and so it's things like error handling and memory safety and some of the craft of the standard Library which was evolved organically more so than it was designed yeah these are great opportunities to improve okay well let's tackle error error handling what's what what can you fix about that well the way it works in C is essentially uh they have a global variable called AO um which from the outset was quickly determined to be a problem as soon as multithreading got involved um and so now we have a pile of hacks to make that work uh but if you do anything uh That Could That Could fail um like opening a socket or opening a file um it will return um often like with a a negative uh number to indicate that it failed or something um and then it will set the error no value to something which describes the error from a global list of possible outcomes that affect everything that could fail um and then the type system doesn't really do anything to to make sure that you're understanding the difference between an error case and a successful case so it's up to the programmer um you know if they call F open and it fails they still get a file pointer in their variable it's just set to null and then if they keep using it without doing the extra work to check the error then they're in trouble and this is a very common uh failure of working with c and then if you have third party libraries outside of the standard Library they might have their own error conditions and their own approach to error handling which doesn't exactly fit into what the C library is doing they can't really expand arono with uh additional domain specific errors for example and so everybody has to come up with Creative Solutions and none of them are make it actually easy to do good error handling in your program so what what have you done what's your solution well uh I think that there's a number of ways that people have approached error handling outside of c um and the one that we favor is tagged unions um and the idea of a tagged Union is it's a kind of type which can store uh values of different types so a single value which is of the type tagged Union can be one of several types and only one at a time so you could for example have a tagged Union of an integer and a floating Point number and it could store either of those but it only stores one at a time and it indicates in the value which one it is so it might say the tag is zero to indicate that the value is an integer or one to indicate its floating Point number and we've created first class support for tagged unions they're kind of ad hoc so unlike Zig or rust where you have to predefine them and they're kind of like a super % of unms uh in here they're ad hoc um and what you do is you create a tag Union of all the success cases and all the error cases and error cases are set aside special in the type system with a flag that says this is an error type and if you're handling a value which is a tad Union that could include an error type there are some additional constraints imposed by the compiler on what you do with that value that basically forces you to do something about the error before you can use the value of the success case okay so have you got something where like your file open example it can return file not found or file not readable or file successfully opened and here is the handle yeah exactly so in C the fop calls return type is a file pointer and it can return either a valid file pointer or null and when it returns null it separately sets the error number to the the Cause right uh whereas in ha our OS open function which is a similar equivalent it returns either a valid file handle or it returns um file not found or access denied um and it encodes that information into the return types that the language can be aware of those different cases and uh tell the programmer they have to address these cases and they can address it either by explicitly testing for each case and adding different Logics so you might want to do something differently on not found versus access to n um or you can address it by passing the error further up the call stack and centralize your error handling somewhere else or you can use an error assertion which is just the bang operator which is an assertion where the programmer says I promise that I've done the math and I don't think that this error case is actually possible under these conditions so just assert it that it's not possible and give me the file handle directly only handle the sucess case but then the the programming language automatically checks your work it's an assertion so if that error actually does come to pass at runtime it'll terminate your program okay so you can optionally say I don't want the bookkeeping but it's okay for you to crash at runtime if I'm wrong exactly yeah yeah yeah do you still have nulls in the language we do have nulls um but you can only use them through a pointer type which has the nullable flag set and again if you have a nullable pointer type using it requires extra work so you can't just directly to reference the pointer you have to check for null first okay and do you have exhaustiveness checking on that like yeah so you can make sure I check all the different cases if I need to uh I should clarify we have some exhausted testing uh we have switch statements for testing against values and match statements for testing against types and right now switch statements do have exhaustivity testing uh match statements the specification requires exhaustivity testing but we haven't actually implemented it in the compiler yet okay still a work in progress however we have implemented an assertion uh where if you get to the end of a match expression and none of the cases were matched will throw at a runtime assertion because that's not supposed to be possible okay cool um how about my other big um sticking point with C mistakes made yeah I don't think the macro system is terribly good in C I agree I don't think that's a controversial opinion what have you done with macros nothing we don't have them you threw them away yep there are some uh languages like rust which prefer like um like semantic macros I think they're called where like your your macro execution phase of expanding the macro gets a copy of the A and can do smarter things with macros and I think that's significantly better than C but we have decided like as a goal we're kind of assuming metaprogramming generally and macros are a form of metaprogramming because we think that for a language where it values Simplicity and transparency metaprogramming is kind of an anti- pattern for us and so instead we use codenation um sometimes uh we have have tools that can interpret a DSL or can even rewrite a hair file um and output generated code which fills some of the need where macros are currently used without actually having a macro system okay is the code generation like a tool built into hair or a separate thing that you would use uh somewhere in the middle so our standard Library includes a hair parser so um if you're writing a hair program you can import a parser for the hair programming language and get an AS it also includes a type Checker so you can run the type Checker and make sure that is consistent with the semantics of the language and then you can also unpar the EST using the standard Library so if you could take an as and turn it into code um so if you wanted to write a tool which did code generation or manipulated herir code in some way there are resources from the standard library to help you do that but there's not exactly like uh plug- andplay code transformation tool okay and is that like the the part that turns in your newly constructed or newly manipulated as back into code does it turn it back into string like a file that you write to the system or runable code that this program can now execute uh it just turns it back into a source code string and it does that by writing it to um uh the file handle abstraction we have an abstraction where you can do it can be backed by a file handle opened on the system like Unix or you can Implement streams in user space so like you could unack the a um into adesive stream into the network socket for some reason um so it's flexible in that sense but not in the sense that it can produce machine code through this SE okay what else about the you said about the standard library and that's novel having the language sort of built into the standard Library what else have you added to the standard Library uh we have all sorts of things uh we have basically everything you would get from uh a c standard library is is present um so we have support for all of the Unix stuff like groups and parsing Etc password files uh we also have all the networking TCP UDP DNS uh we have a much better DNS API than libc provides where you can like do arbitrary DNS queries so we've kind of rethought those abstractions from C and then we've also added a bunch of other stuff um we have a finite scope for the standard library but it's a bigger scope than live SE and so we have things like uh hashing functions we have FV CRC uh those kinds of hashes we also have a cryptography Suite which supports a whole bunch of um modern cryptography Primitives that we've impl implemented ourselves we also have a fundraiser to audit our implementation by the way um and we have a some other stuff like buffer IO which is um again the abstraction has been rethought from the C approach so that those Primitives are available for you to use and more concrete manner so there's all kinds of stuff in the standard Library I think it has a really good amount of batteries as it were um especially compared to C but it's still finite in scope and then we also have the extended Library which is a collection of libraries that exist outside of the standard Library per se and they make different stability guarantees in the standard library but they're still under the perview of hair and they're considered important for the ecosystem so for example the HTTP implementation is in the extended library right yeah that stability leads to another question what status is hair at is it production ready is it research project it's uh somewhere in the middle um so we have this goal uh of becoming a quote 100-year programming language which is something that we're working towards so stability is one of the most important values of hair um but we are not actually achieve that yet um we want to get to the point where we release hero 1.0 and we say we will promise to Forever support backwards and forwards compatibility from this day onwards which is a big goal um and we're getting there but we're not there yet that said um setting aside the overambitious goal of freezing the language forever uh which most programming languages don't take on I would say Hera is somewhere close um to the stability of other languages that don't have that goal um it's still missing a number of things and we have some plans which could introduce large breaking changes like we're going to research linear types for example for memory safety yeah and those could uh could break your program and we also are still sometimes doing large refactorings in the standard Library which break people's code um but it's a language you can use to write serious projects today and many people are using to write serious projects today okay if you got an examples like what kind of things people using it for um so the postmarket OS Project has some people specifically affiliated with the X sxo uh desktop solution for mobile phones which are using hair to build some some tools uh for mobile users and uis for mobile users uh integrated into their desktop environment um I'm also using it to work on uh a a secret storage manager which is like a generalization of a password manager uh and that's stable and released and to some extent in general use people are working on build automation tools and UI toolkits and all kinds of things of that nature okay okay so let's zoom out because you've mentioned your 100-year language goal yeah and and this is something I find really interesting about hair you've got you're saying we've got 50 years of hindsight to learn from and we're aiming at still being the same language a hundred years from now yeah how on Earth can you possibly look a hundred years ahead and predict what's going to be needed we can't and we're aware of that um so something we've acknowledged is that hair uh 1.0 um we'll we'll do 1.1 and 1.2 keep maintaining it and working on it but it will not be a 2.0 but her the language as it appears on the day that 1.0 is released is going to become a time capsule and we acknowledge that um and we're happy to let other languages continue to develop and work on Innovations and I think that's something that's very valuable for the ecosystem going into the future um but this approach to stability is kind of a counterweight to um what I think is a little bit more mainstream right now which is kind of Reckless instability to be honest if if you for example try to find a binary um that was built for Linux three years ago and run it today you're probably not going to work um and that's something we kind of want to correct for um and so if you're writing software that you have want to have that kind of longevity I think hair is a solution that we want to be available for you and it's true that hair will become more um ideologically obsolete over the next 100 years for sure um but unlike a lot of languages which are going to keep with contemporary uh language design ideologies her is still going to work so I think that's an important difference you know I think a lot of languages as they look today um those languages are going to keep evolving but software which is written today for those languages has to evolve alongside of them whereas hair um we're hoping that all of the software which is made for hair will also have that longevity you built into it so you're saying if imagining you've released 1.0 and someone's written a large program in 1.0 yeah now we fast forward 50 years and I have to write a new hair compiler for a new architecture of Chip architecture that's out there yeah but you think the program that was written today will still compile to that same spec 50 years from now I think so I mean we have some uh constraints around exactly how those guarantees work so so for example if this big program has components written in assembly obviously you'll have to Port those to your new architecture but any program which is written against the standard Library using portable code will still work the pitch that we give is um on the day that hair 1.0 is released if you write a program in hair in 100 years time it will still compile for new systems but we also say if on the day that hair 1.0 releases you take the specification and you write a compiler based on that spe ification on day one in 100 years that compiler will compile contemporary code right okay that's the promise that so that instantly makes me think how on Earth are you going to know when it's time to say this is version one I would be tempted to always put that off just a little bit longer while we are out the edge cases well basically uh we have a plan in mind we have um a fairly fix a number of research targets uh that we want to evaluate before we consider the uh scope of the language complete and that includes things like the linear types example uh also another thing we want to research is alternative approaches to memory managers um and we also have a handful of little design things uh that we're kind of playing with um which uh similar cavat applies they're fixed in number for the most part that that list of smaller things still grows but we want it to grow forever um but once we run out of these uh these predetermined design areas that we want to do research in that might change how the language Works we're going to arrive at what we think should be her 1.0 and then we're going to begin a process that we call acceptance testing where we're going to create uh multiple teams uh within the hair programming team which is about 100 people today really um we're going to create we're going to subdivide ourselves into teams based on areas of expertise and domains and we're going to um run over the whole language with the fine tune Co we're going to have areas as narrow as things like networking support um or IO uh and also things as broad as like Linux support um and these teams are going to evaluate the whole language on those terms um and produce reports and make recommendations for things that need to be changed and this acceptance testing process is expected to take a few years um and that's going to be the majority of the work that goes into hair for a while uh from the uh official team Upstream as it were and once we have completed that process we're going to release 1.0 and that's still probably going to have mistakes there's going to be some stuff where in 20 years time we're going to be like really maybe we should have thought this differently but we're going to do our best and because this longevity is a goal I think that we have to be willing to compromise on not having imperfect for you know so you're saying there will be I'm thinking of the human an appendix there will be parts that maybe in hindsight weren't actually necessary yeah but but you're placing above that the guarantee that for the whole hundred years of the language there will be stability yeah there I mean the compromise is that the language will probably have an appendix for 100 years but it will also probably work for 100 years yeah yeah that's fair enough much like us humans yeah exactly yeah roughly although not all of us make it do 100 not all of us have an appendix either so there we go true okay okay so that you've you've mentioned this twice now linear types um and I think we have to dig into that because that's the other mistake thing we thing we would do differently in hindsight about C is memory management yeah and garbage collection is one solution which has problems for system programming rust has another which is borrow cheing what's your solution to it so presently we have some featur features around memory safety which are more features and less of a comprehensive approach like a borrow Checker uh or a garbage collection uh for example uh all of our slices um we have slices as a first class feature uh arrays of slices indexing them is always bounce checked by the compiler and will terminate the program rather than do a buffer overflow we also have some features in the works where we have like working proof of concept but they're not done yet with respect to things like address sanitizers um and so this kind of thing we're working on but it's less of a comprehensive model like uh like rust uh or go garbage clastic languages have um and our answer to the comprehensive approach should we decide to to try that is um to use linear types possibly um and we might also research a borrow Checker uh but I would say that we are satisfied with the degree of memory safety that is achieved by hair today which is not a comprehensive system but it's enough that I think you're not going to get nearly all the mistakes that you didn't and see which is a a statement that some Rust Advocates may become controversial but nevertheless um regarding linear types which is this comprehensive solution we're researching um it's not actually my domain it's being led by other uh hair maintainers um but my my Layman's understanding is that linear types is basically a system wherein uh a value of a linear type uh has to be used exactly once and you can um if you use it zero times you get an error if you use it two times you get an error and so if you need to use a value multiple times you have to use it in a way which creates a copy of that linear type aspect um uh kind of like an SSA form and if you um free it that's using it so you can't use it after free and if you forget to free it like a memory leak you've use it zero times and that's also invalid so it kind of t uh checks for those kinds of aspects of your usage of values and I think it does provide a relatively comp apprehensive uh memory safety model but again that's not my area of research that's some other maintainers working on it can you I'm going to risk pushing you on that even though it's not your area of expertise then but can you can you explain how that would work in practice because I I I've dabbled a little bit in linear types but I think most people won't know why this is an interesting idea well um again with the caveat that this is definitely not my area of expertise all I've done is read some of their emails about it um but the like for example if you want to work with a file um you open a file you write to the file you close the file and one of the possible errors that can occur under that condition is writing to the file after it's closed um and so this is a kind of a generalization away from memory management this is other kinds of resource management that this technique applies to and if you open the file you do error handling which is separate but at the end you get a file handle and this file handle has a linear type which means that you must use it ex exactly once and if you pass it into the right function uh to WR to the file that's using it and so the the linear type value is then consumed um and then in order to use it again for another right the the right function will essentially return um a copy of the file which is a brand new value that you again have to use exactly once and if you pass it into the file closing function because you're done with it uh it's different from right and that it doesn't return a copy of the file handle it consumes it and then you don't have an opportunity to use it again and so through this approach of uh use exactly once types you can't forget to close the file and you can't write to it after you've closed it so it's like a kind of resource management that that adds these safety features through this kind of only use once approach yeah that makes some sense CU we do have this situation where we're managing different resources like Network handles or or and we've got we've got solutions for managing generic resources like with for example and then we've got solutions for managing memory like Russ boroch cheer but nobody's really trying to unify that uh I think some people are maybe trying um I imagine the r type system might be able to accommodate this I'm not sure but yeah it's definitely something that I think we're uh appreciative of that this generalizes Beyond memory management into general purpose Resource Management okay so how does that play out in language design if you're interested in adding that to hair but you're not doing it this presumably isn't a benevolent dictator for Life model well there is a benevolent dictator for life and that's me but um that means I try to be as benevolent as possible okay um that's actually so my responsibility as the bdfl is explicitly outlined in Doc bdfl DMD in the repository which elaborates on what that role actually means and then we have a separate document for maintainers um but my bdfl Approach is as hands-off as possible so I I want to be used as a tool that the community can utilize when my feedback is necessary so that includes for example uh being the financial Steward of the project I'm responsible for all of the money as it were and that's something that other people don't have to think about they can just work on the code um and then I'm also have um you know the the vague role of providing the vision for the project and I also have the vague role of you know if there's a conflict in the community I'm the deao mediator of that conflict and if people can't agree then I the GNA be asked for the final say uh but this is something that the community asks me to do because it's a tool that they can use when it's useful um rather than an imposing dictatorship kind of thing and so I try to give as much autonomy and agency and authority to other contributors as possible so like there's um you know bdfl is separate from maintainer there's I think four or five top level maintainers with responsibility over the entire project and they have the latitude to make a lot of decisions um without my input and we also have an RFC process which is um informal and op in so if you want to make a change to hair you don't need to make an RFC but if you uh feel like it's a larger change or requires some discussion you can opt into making an RFC or somebody can ask you to make an RFC where you can explain the purpose of your change and have that discussion and seek consensus before you do it and so I think the linear types research is an example which is still early and pre RFC but we have other large changes which go through that RFC process and if they acquire consensus you know there's no explicit approval is just read the room if the vibe is that people like the idea and think it's refined enough then go ahead and write the patches and if not keep talking about it so if you achieve that informal consensus through an RFC you're likely to get a large change to coin uh and you can go ahead and start writing the codes and making the change happen and you know do all the planning you need in the RFC discussion okay that sounds very very soft I mean compared to something like an Apache project that's a very loose approach and yet you're managing a 100 programmers you say does it well managing you know there's that's the number of people who have commits right it sounds like you're less the benevolent dictator and more the benevolent Midwife to this yeah maybe I mean um you know anything any any responsibility that the bdfl traditionally has is annoying because of a busy guy and if another contributor is good at doing those kinds of things and wants to take it on board I'm thrilled about that so even like stuff like Community Management we have a conduct enforcement team which is not just me it's me and two other uh contributors who are trusted by the community um and so bdfl is useful uh to have um have reserving the last word as it were is something that can be definitely useful to the project but I think it's there because it's useful not because it's imposed and the project for the most part runs itself and we establish a culture of consensus and of people taking uh responsibility for the parts of the project that they're interested in and uh want to work on and then also giving them those responsibilities and rewarding their agency in that respect creates for a really healthy Dynamic where things can get done in a way which is informal and rewarding for everybody which is important because they're all volunteers yeah yeah I can see that working very well for like language capabilities and individual areas of language design but how do you ensure that it keeps a cohesive hole as a language rather than becoming an archipelago of people's best ideas so there's a couple of ways uh you know we have for example a canonical style guide and everybody is required to adhere to the style guide um and part of the consensus making process involves you know getting your API design uh approved by the consensus on the basis that is conformant with the design approach that we take everywhere else um but also there's this really nice thing about hair which is that a lot of people have remarked about this the language is quite simple um it seems to have exactly the right scope because uh you don't get enough rope to hang yourself with but you get enough rope to do what you need and the consequence of that is that a lot of the time if you're designing an API in hair for the standard library or for your own library or for anything um it usually happens to be the case that the first API design you write is the right one um and it's to the effect where there's like almost just the one way of writing hair code so if you have a problem there usually one way to solve it in hair especially in terms of API design and because of that uh there's not a lot of conflict about like design style and so on in the standard library because it all tends to converge towards the same self-consistent result okay if you're finding that in practice that's impressive yeah I'm very happy with that that's one of my uh one of my favorite traits of what we've accomplished here well maybe that speaks to the the typical user of hair if someone's I mean there's there's competition in this space for lowlevel systems languages yeah um and without without saying anything about the competition directly okay like why would someone be drawn to hair more than say rust go Zig or just see I think hair has a lot of advantages in that respect um it's certainly has a lot of advantages over c um and you know for example uh somebody with a C++ background might prefer something with a similar level of complexity or or tools that they can use and hair is really not for that it's for people who prefer the simplicity so people who who are using C and um the they're not you know held hostage by C because of their job or their their their target use case or whatever they they like using C or they have Stock B syndrome maybe um those people I think at the target audience for C who value that Simplicity and also it's just a really fun language to use um I think the standard Library provides a perfect number of batteries where a lot of stuff you want to do is going to be accommodated by the standard library and it's going to feel good to use we have really nice tooling so we have a command line documentation viewer which is super super Pleasant to use as part of your daily workflow uh we have super fast build times um you can actually bootstrap the entire tool chain including the back end and the front end uh from scratch running all of the test Suites in less than five minutes and so it's fast it's simple it's easy to use it's fun to use I think that appeals to a lot of people in our community how many different architectures does it compile to presently three it supports x86 64 arm 64 and risk 564 I'm just wondering how if someone wanted to add a fourth to that how large a language does it turn out to be as an implementor um so uh new architectures are supported through our backend which is called Cube um Cube written by Quinton Carbono I think it's spelled QBE I've never actually said his name aloud so I really hope that I pronounced it right um and it's a weird code BAS I'll be honest with you it's a bit of a strange code Bas it's a perfect tool for hair and it makes a lot of sense for a use case but getting into it we have a number of hair contributors who work inside of cube as well and it's definitely a different experience um but adding support for a new architecture is not super difficult but almost all the work is going to end up there you have a little bit of work uh to Port the hair standard library to an architecture and a couple of other places that might need to be updated but mainly you're going to be putting all of your effort into Cube um and risk five support uh actually came about about because um we asked [Music] um Michael forny um a really smart guy to actually Implement a risk five back in for cube uh so we could use it in hair and this took him like he's a really skilled programmer to be fair but it took him like less than six months um and in the end like the risk five code is uh 2,000 Lia code or something um and so implementing a new architecture non-trivial but also not super hard okay yeah because it must happen if your vision comes fruition over the next 100 years there will be new architectures right yeah and we plan to Port it to a few more cells we want to do power PC want we want to do some 32-bit targets 32-bit Targets in particular are going to be a little bit more challenging that will require not only adding it to q but also doing some refactoring in our compiler um 64-bit Target should be pretty straightforward I think if you just add those to Cube that's most of the work done um and we also we we're going to Target for the primary hair standard specification uh 32-bit and up for architectures that we support but we're also going to make a supplementary specification which loosens a lot of the rules to support 16 and 8 bit targets possibly without guarantees of portability between the two um and for that purpose we might do some other fun ports like z80 or something okay so there's still hope of me getting hair on my Commodore 64 yeah it could be in the future but you know you could also maybe forgive us for not prioritizing it yeah I think I will so one architecture I know you're going to be um well not architecture what one target I know you're going to be compiling to is your other project if you're not busy enough already is a is your operating system yes I am writing an operating system in hair and uh it have support for running hair programs in user space before it has support for running seed programs in user space as I sort of hope so I mean it's tempting to talk about the life management issues when you're already busy enough but tell me about the OS what what do you need what when you're already so busy why add writing and operating system to your work deack well I um you know in a way working on this operating system is contributing to hair because one of the explicit design goals for hair from the start was we want to be able to write arting systems we want it to be useful for colonal development and we have to actually write an operating system in it to prove that we've accomplished that especially if we're going to freeze it for 100 years and then 20 years later we try to write an OS and whoops actually it's not possible you know yeah but also like I said you know the hair project almost reads itself like I don't have to do a whole bunch of work because I endow everybody with responsibilities and agency over the project and I try to do this in all of my projects that have aerg of community I try to empower the community so it's not a huge drain on my personal resources and also I work uh full-time in free software I have my own software company and it's part of our mission to work on stuff like this so it's not like I'm doing this in the evenings and after I exhaust myself at a day job this is my job okay um but yeah I'm also writing an operating system because it's really really fun how do you get to the point where it's fun how do you learn the basics enough to to get to because it's such a hugely scoped project I mean I wouldn't even know which side of the mountain start climbing uh I mean the first step is to to write enough codes that you can boot your PC up and it says hello world this is not too difficult as a matter of fact um but you know I think that there's definitely uh writing an operating system is uh very ambitious but also quite possible uh if you're willing to put in the time um and if you're able to put in the time which not everybody is uh but it definitely you know it shouldn't be your first programming project but I think somebody with like 5 to 10 years of experience programming especially syst programming is totally well equipped to try writing an operating system uh especially if they're comfortable like reading CPU architecture manuals and like the source material they're not going to rely so much on wikis or blog posts or whatever uh this kind of programmer would probably have success if they wanted to write NOS okay so are you just doing it to um to exercise hair or do you hope that you're OS becomes I mean you are you can you see a future way you're the next line of Tov volt I really don't think so I think is far too entrenched but I am designing it seriously because at least I want to use it and um anybody else who has similar needs to me might also benefit from using it so it's general purpose and it is a serious project and maybe someday will be useful but like I'm not exactly setting like be the next Linux as a goal because I don't think it makes sense to do that and it's also kind of outrageous true true I'm not even sure lonus well I'm certain lonus didn't see it becoming mainstream when he started it right it was just a hobby project yeah yeah it won't become big and serious like G new yeah yeah he did say that so but are you are you trying anything new with it or is it just you just want to learn to do that uh I am trying something new kind of but in the The Same Spirit of hair I'm to some extent stealing a lot of other ideas into one package um but I think it's being done in a novel way so I'm mixing a lot of ideas that have never been mixed before and doing them in a way which has never been done before but it is still somewhat classic operating system design uh although I will say that the operating system design components that I am drawing from never really made it into the mainstream so it's drawing a lot of inspiration at the kernel level from an operating system called se4 which is a formerly verified operating system micr chronal uh and it's drawing a lot of inspiration at the users Space level from uh plan n perhaps more so than Unix but also doing some of its own stuff which is different um and so it incorporates a lot of these ideas into something new and I think it's distinct from those ideas but also those are ideas that a lot of people really haven't been exposed to in the mainstream so it's going to seem really Norful to a lot of people okay we'll teach us a few of them what what ideas do we not know about operating systems that we really should okay um so for example from the4 inspiration um the uh implementation of hair is is of of Helios is the name of the kernel of the project the implementation of Helios is quite unique and diverges substantially from4 but like the kernel user space API uh it also diverges significantly from4 but it's very clearly uh inspired by4 in terms of the kernel API design and the way that works is with capabilities so it uses capability based security uh where a capability is an object with which represents an unforgeable um handle to some resource on the system and um you know this is analogus to a file descriptor in Linux so if you have a Linux program which opens a file you get a file descriptor which is a handle it's just a number uh and it's backed in the kernel uh by all of the the memory associated with the file but if you have that file descriptor it's an unforgeable right to use that file um so if you call fopen on a file which is open by root you get a file handle and then you for example will set uid to a nonroot user your program couldn't open it again but you already have the file handle and that's your right to use the file capabilities are much more General so everything in Helios the kernel is represented as a capability and that includes things like memory um so if you want to allocate memory you have to have a memory capability which establishes your right to use some memory um but also everything else uh there's an idea called endpoints it's very important for a micr kernel to have a good inter process communication support uh so an endpoint allows you to exchange messages with another another process and if it's a driver for example it's running in user space and if you have a file open which is uh ultimately sored on a dis you have a capability for that file which is analogous to the file descriptor and when you write to it it sends a message to the file system driver the file system driver has a capability for the block device the file system is stored on then it forwards those rights to the block device the block device has a capability for the ports of the PCI memory mappings that it needs to actually implement the device driver and so each process in the stack from the user space all the way down to device drivers is running in user space in a sandbox where it only has access to the resources resources it needs through capabilities so you're saying that that sort of implies that it's a very small kernel yes most most things are in user space and the main job of the the kernel is to manage AG who has the right kind of sandbox yes the kernel uh I think the Helios kernel is about 10,000 lines of code um and it's mostly feature complete at this point it's not done but it's close to feature complete in 10,000 lines of code and is responsible for enforcing capabilities uh by being the thing in route that does message exchange for IPC uh running in kernal space it's also responsible for anything the colonel is the only one that can do so for example um managing um memory maps and virtual address spaces owned by user space the actual uh configuring of those um it provides apis for user space that has a memory map capability for example can ask the konel to do a memory mapping but actually doing that operation requires you to be in kernel space on x86 and so on so that ends up in the kernel um but it has also the only other responsibility has is bootstrapping the system because it's the first thing that runs on boot so it does those three things and nothing else everything else is in US space right so this is getting around the problem where I can if I want to write I don't know a new device driver for Linux I get I can I can accidentally or maliciously access an area of memory that I'm not allowed to and just muck around with it yeah like if you have a floppy disc driver on Linux it's compiled into the whole kernel and it's running in ring zero with the rest of the kernel and if there's a bug in your floppy disc driver it can do anything it wants to compl completely compromise your system on Aries your flist driver is running uh in the user space and only has capabilities for talking to the floppy dis device and the worst it could do if it had a bug is overwrite your floppy disc right yeah that seems like it' be very useful for security right oh yes inherently yeah I mean it's tempting to ask why the idea hasn't gone mainstream but I suspect the answer is because operating systems are huge and you can't change them very easily um there is a number of microc coronals which have been built uh and to to some significant degrees of of support even seal4 this micronal which I drew a lot of inspiration from um has a project called genode which provides a more or less complete posix environment on top of it um but I think the really main reason why we don't see this so much in the mainstream is operating systems have a lot of inertia yeah yeah you can't just rearch Linux and you can't come up with something that's Linux is with a new architecture and expect people to install it tomorrow and you have to acknowledge the fact that a lot of the software that people are using today is not going to be portable to a new operating system especially because for example you could implement the Linux CIS call ABI and some people have done this there's an emulator for it on BSD for example but at that point you're designing an operating system within the constraints that Linux was designed under and you're kind of really constrainted your ability to innovate but if you don't do that then you lose access to a lot of contemporary software so it is definitely a challenge to try and get adoption for a new operating system which is part of why it's really an A on my goals okay fair enough what about um concurrency is that is that a goal of your micro kernel um I mean it's a thing that micr Kernels have to do I guess um because it facilitates multiprocessing it's um I guess that's the fourth thing it does is it facilitates multi-processing so we have support for for Threads and multi-threading and multiprocessing implemented in Aries um which is kind of a requirement for a modern kernel to work you could do like Cooperative multitasking but it really doesn't make sense especially on a multicore system um but that is present uh we we do Implement uh threads or we Implement tasks which is kind of a a generalization of both threads and processes and then we have user space uses tasks to implement threads and process processes um but yes concurrency is supported by by the system within that 10,000 lines of code yeah yeah uh we don't have S&P support symmetric multiprocessing but we do have preemptive multitasking okay so if I wanted to learn how to write my own OS would this be a good reference guide uh possibly um it's very small and self-contained and is quite straightforward to follow where the code goes and see places where you could make changes uh there's also a great resource for getting started with operating system development it really doesn't take you all the way but it definitely gets you started which is the osdev wiki U and the osdev IRC channel is also a great resource to talk to people who work on operating systems so anybody who's curious about learning an operating system or operating system techniques definitely the helos source code could be a great resource um it definitely demonstrates how to do a lot of things very simply and then the OS Dead Wiki for sure is a place you need to be depending on okay I'll link to those in the show notes cool and if someone's not feeling quite that ambitious but wants to Tinker with this what state is Aries in right now what can I run on it um so it's still very much under development ahead of having like a useful user space but I do have a laptop with Aries installed and it supports ext4 file systems and fat file systems and virtual file system a very basic virtual file system is there so you can mount them and you can set up a boot process which getes some where uh an early version of the shell is working and I've ported the Ed text editor and it's at least good enough that I use Ed to write a blog post about Aries from Aries on Aries um so you can definitely tin it with it I'm gonna I ported Doom to it a long time ago and it doesn't work anymore but I'll fix the Doom Port so you can play Doom with it if you want did you port Doom before you ported an editor yes hero nice I might let you call me once you've got Vim support I think that's my threshold okay Vim is going to take a while okay especially because we don't intend to implement like a Unix style TTY that VI depends on oh okay but yeah you can you can mess with it and if you want to get involved in the project without having to necessarily commit to learning how to be an operating systems developer from scratch uh a great place to do that is write a driver um because the driver is very constrainted you don't have to worry about booting the system or dealing with memory management uh lowlevel stuff so much you just declare in your driver manifest what resources you need from the system like PCI memory mappings and things like that and then you write a normal program it goes to Main and runs and you can use that to implement your your driver and that's a great Target like the PS2 keyboard driver for example is like 800 lines of code Max quality I have a friend who works on U emulation of the igga operating system and he would probably find this a lot of fun yeah I bet yeah yeah and and pulling back to something for up a bit more production ready hair is that something I could reasonably start to make production projects in you can um you're definitely going to have to be aware that like you know subscribe to the hair announce and the hair users raing list where we tell people like we broke this module in the standard library to make it better here's how you update your code um but people are using it already to make production ready stuff and it's there's a great tutorial on the website and there's a great Community to help you learn how to use it definitely if you're interested in the project you can pick it up and write code today awesome I'll link to those in the show notes and I think it's time to get coding all right Drew thanks very much for joining us yeah thank you so much for having me this was great thank you very much Drew so all of that leads me with a new goal in life what I have to do is learn hair and then write a lisp compiler in hair purely so I can refer to the project as my hairbrain scheme before that pun sends you running for the hills please take a moment to like or rate this episode if you've enjoyed it share it with a friend subscribe notify follow all those good things because be back soon with another episode until then I've been your host Chris Jenkins this has been developer voices with Drew Deval thanks for [Music] listening