so hello everyone uh my name is Siana muta I am developer from gen digital and I recently joined the C++ committee and my main interest in is in concurrences so that's the reason I want to talk about memory model today so first of all why do you want to care about memory model actually when you will be in some company will meet some concurrency code one it seems to be broken a little bit I'm sorry everywhere because like world world is not single threaded and you need at least a little bit of knowledge about concurrent programming and how to solve the issues so it's actually some kind of basic knowledge you should be able to provide and uh even a tiny little piece of concurr code may cause huge problems if it's not written correctly and to avoid this it's good to know all possible synchronizations techniques to be able to choose the correct one not to be stacked on the only locks and mxes and to know what is the whole range and what all you can use so it's good good to know all of this and also the synchronization is still evolving like maybe in the time when you were learning about it it was in different state than it is now it's in each version of C++ it's there's something new about it and it's so it's good to know the current state and to update the knowledge and of course if you will know all of this you will be able to recognize possible problem because they will cause huge problem because the pro problems in concurrent code are pretty hard to find out and you will be be hero everyone every company needs because it's really valuable in knowledge and also it's fun so to make it a little bit more understandable I Chosen hka and Dan to be our guide through this world and to provide a real world scenario actually HRI is small girl which life loves to which last hiking and she made up a trip which looks like this she will take a bus go to some medieval uh Castle stay in a camp go to the lighthouse you see all the it here and there's also Dan who read this description of this trip online and he loves it and want to go there too so actually we have our first two threats which we want to synchronize little bit but they actually don't know about each other adva don't know that reads online her trips so they went to the trip and they don't know anything at all about each other until one of them Shar some information in form of share data so now we are on day two of the trip which mean waking up walking to the light Lighthouse takes some picture update them and enjoy some time on a beach nearby and then sleep in a camp so uh to be able to synchronize howow we will take social media as a shared memor so Heda will upload her beautiful photo from uh from the beach not from the lighthouse and get then will get notification about it let pretends it's immediately he will read it and he knows that hea is on the beach okay so does he know if she seen Lighthouse already actually no he don't know it even if that look like uh the visit lighthouse in know is on program uh before Beach time it's not sure that she was already there because maybe she was wearing already swimming suit and jump to the Sea before because it fits her better but the same may happen with your coat your coat may be reordered pretty widely and you can't say at this point that when when you see Beach Time picture that you already visited Lighthouse and it's the it's really important to understand it to to appreciate why the memory model is here and what it provides to us so I will I will get a small view of what does happen in memory to be able to understand why is our code reordered and what are um consequences for us so first how do we this is very simplified just to be able to understand the basic points which are which are necessary for us so if we want to read some value we we want to work it with with we need to transfer it to registers from my men to registers where where we can work with them but we won't transfer that alone we W uh we transfer whole cash lines through the whole large hierarchy I have there just a simple one but the hierarchy is actually pretty huge and it's in here it's important to notice that it's not the only one value there's a whole line there's more you transfer together but it's pretty straightforward but what will happen when we want to write to my May it's not that straightforward because we have the store buffer in there which is waiting for more writes to happen and then publish them all together it's some kind of optimization which is actually uh present on every processor you can find so it uh it's good to know this because your right will be delayed somehow it doesn't happen at the moment you you think it is and it may have an impact on what you expect and what you get another scenario different processor wants to read the value from the same cach line like the previous one it there's no conflict at it but The Cash Line is now in two different branches of that tree and it will have consequences soon but now it's okay reading okay there are two copies in two different processor it's fine they are just reading it but what happen if the first one wants to write to that one the writing is pretty expensive operation because it's not only tracking up up the tree to the main memory but you have to ensure the consistency in between different caches so you have to write down to all the caches which already has that line so it's really it's really slow and complicated it's good to know that right is slow so to adapt to this flow there are several there are many many of optimization which compiler does for you so first who will reorder your code is compiler I have just two examples of what can May what may happen here you have just a simple Loop over uh two dimensional uh buffer and you you are reading in in columns what will happen in a cach you can see that you will get one one value from one cach line another value from very different and what compiler will do for you he will just switch that four four cycles and now you have it pretty aligned and the memory impact will be much lower so that's the first example what may happen second one is uh what may happen is when you have a value in the registry you want to use it before you lose it so here you are uh loading uh A&B then do some computation and after that using the A&B what will really happen those VAR will be C coupled to actually use that value which is already loaded to not force uh load again and again while it will be loose and there are many more optimization on compiler which will actually cause that your Cod looks absolutely differently it's uh it's okay in single credit you won't notice it but in our case in concurrency code it's really important to notice there's another person who can change your code order and he a processor he's in charge of uh Dynamic optimizations and it mean that if you have this four instruction in here getting value a getting value B and then using them so maybe even if it's written in this order you may get the result from the get value B sooner so the laters will be switched and those are the dynamic optimization which are work of processor so they and the last one which is good to know about is that store buffer I showed in an illustration which uh may cause that your value actually is pres uh printed into memory later than you expected because it delays it those are just simple examples to understand that your code isn't executed in the way you wrote it and it's absolutely okay in single threaded applications but when you want to synchronize you can't expect anything in a in man in a manner of what is first and what is second so as we explain this one we can go back to our hike and meanwhile the hike became pretty popular and everyone wants to join it and so Hada organizes a trip for introverts everyone wants to go their own way but they need to synchronize time to time so uh there are critical points where they need Comm to communicate between each other actually our hikers will be our threats so they need to get to the same bus they need to wait for every want to be there they they will try medieval armor or them to take a nice picture like only one person will fit in there at the time then they will sleep in a camp where three of three people brings three parts of the tent they assemble it and they can sleep in there but they have to be all three of them present to be able to sleep there then they will enjoy Lighthouse where only six people fits in because it's really small Lighthouse so they have to be sure that only six people are inside and then at the end they will celebrate on the final lunch which they have to order and pay so those were those will be our examples on presenting uh our mechanism but if we go very very naive way we can say that we will see everyone in bus this way but like uh we will count how many hikers are there they will get some snack they will travel about what may go wrong in this one actually almost everything first concurrent right to Shared variable has unknown unknown result because when more threats will be writing to the same variable and they are not synchronized anyhow they they can change it's not atomical operation in in while one is writing another one may may start modification you don't know what will be the result there's no this it's undefined Behavior you can't do this like this I will go to correct approach soon there's also busy busy waiting which will drain your CPU and it seems like this is not good technique we will have better technique to do such an operation and we have also the danger of RA code because we see that at the beginning you will get some apple as a snack to the bus and when the bus steps on a GU station you will buy another snake but actually what what will compiler do he doesn't see an operation on a snake in between he will just couple it together he doesn't know he needs to wait until you will reach some gas station he doesn't see it you don't give any hint of it and also the visibility uh of a changeed Val value is not guaranteed to be immediate like it may lay in store buff for some time and you may get wrong number even if someone already changed it you may see alt well so what can we do with this because like it's all wrong but we need to synchronize somehow so this is the reason to present the memo model to provide some techniques to achieve actually the synchronization to be able to synchronize somehow so what memory model does is that it describes the interaction of threats through memory and their manipulation with shared data actually it uh it will uh give you techniques which you will understand your compiler will understand your processor will understand everyone will know what you want to achieve what you are what what uh what restriction are you are giving and when you are using it you are able to synchronize your shared data but uh good to notice is that we still want to have as less keep uh as many optimizations as possible it it means that you you don't want to share data when you don't need it because as we seen the a flow through the memory hierarchy it's pretty expensive and the restriction on optimization because when you are sharing you give basically giving restriction on how compiler May optimize your code it's what you are basically doing so you want to share minimal amount of data because it's has huge performance impact and also to provide uh best performance possible the set of rules in memory model is minimalistic it's it's just wants to provide still the compiler some freeh hands to do at least some optimization so these really minimalistic rules uh leave us with possibility to run into undefined behavior and we need to be careful about how we work with them and how we handle all our uh techniques so what is safe and what is not safe when we are talking about share thata when multiple threads are reading the same value we don't have any problem at all no one is modifying it it's absolutely okay when one threat is modifying that memory location and no one is reading it no one is writing it anyone else it's actually okay too but at the moment when one is writing at at least another one is reading or writing doesn't matter just touching the memory location then there we have a problem and we need to uh go with do synchronization it's okay when it's uh from one threat if it's not if the reads and writes are from different threats we need to Define happen before relations actually I will I will present examples on all possible techniques which will which will guarantee that happened before relation and uh the Third option is to access this location anatomically which which actually uh doesn't allow anyone to skip in into your process you will be so fast that no one will be able to interrupt you everything is else is undefined Behavior or more optimistic if if you will follow the rules you will be fine but is sometimes hard so what we found about memory model so far is that data flow in memory Hier hierarchy is complicated and expensive and your code maybe and will be reordered during varel optimization step so uh data sharing is really expensive because uh using those techniques doing it correctly uh prevents for reordering it's uh it prevents from some optimization which may be really important for your code so uh a memory model set rules how to communicate your intentions of sharing how to communicate your intention of uh synchronizing uh and so the compiler will understand you and what R your work and always consider if you really in need of sharing like it's fun but it's really hard to find hard to find the bux after it so let's go to the examples and the techniques so the first one is everyone is seated than to the ledge so we have a bus and we are waiting for everyone to go and go in and then we are leaving so first we have the ledge in here which is a kind of single use meeting point which is initialized with counter actually when you the counter reach zero everyone is is allowed to go forward so you may if you are a hiker you are going to bus so you will arrive to the bus Which decrements that count counter and you will wait until it will reach zero after it will reach zero all the waiting threats are allowed to continue their work but the driver doesn't have his books uh seat reserves so he's just waiting in a large it's possible to wait even when you didn't participate in in that in that decrementing so you can just wait on that ledge and also you can just count countdown those are the hikers Which F which are excused they F they are sick or something they just called okay we won't come but you de commmand the counter you are not waiting for them and they can continue immediately again they are not waiting so this is the very very basic synchronization technique which is actually pretty powerful and we are able to go to are trip thanks to it the next one is the most popular I will guess this are matx MX and loocks and we will use them to uh be able to wear that medieval armor and take cool selfies so actually motex is a primitive providing exclusive access to critical area you are able to lock the mutex or unlock it and in between you are guaranteed to be the only one who access that area what is uh tricky about it is uh you can't uh distract uh Lo locked mutex and you can terminate the threat which is holding an mutex and it it may become a little bit tricky to handle all the all the branches like maybe if if you are check and your bus is leaving soon to another station you want to return immediately and not take another picture but here you are leaving your motex locked and you are big in big trouble which are hard to find you should do it like this in every every uh exit you have to unlock your motex so there's easy way easier way to do it to handle it we have a kind of wrapper which is a lock guard and in the moment when you create it it's locked and as and when it will be distracted it's unlocked so it locked the wall scope there's a reason for the curl bracket around because we want to share selfies when we are out of armor we don't want to block it for someone else which is really important because under the lock you should do only the things which are related to the locked resources everything else you should do when you give your resources away and you can do it after that but uh you still may be some missing some functionality with log guards so we have even more sophisticated ated ways to approach it and it's a unique lock which allows you to lock and uh oh which allows you locking and unlocking again and again so in our example we got an full armor take a selfie and found out that we want better pictures so we will go to look for another photographer so we will to arm armor down find someone and lock it again so we are able to lock it and unlock it again and again and you are even even able to uh create it when it's unlocked it's not it's not necessary uh to construct it locked so it's a much s um it's uh yeah much more versatile but still safe way of how to use mutex I have another last kind of uh locks and this a shared one because sometimes you know that a lot of threats will be reading the values only reading and they can do it concurrently but just one writing will destroy it all so you may allow all those readers to access it together and only the one who is writing gets will uh accesses with uni loog or loard so for the one who is writing and here is the one I gave an option like you want to wear this armor on or or you can just visit exhibition where they are displayed so maybe 30 people can see the exhibition when the arus is display but no one can do it when someone else is wearing it so if you want wear it you need to have unique access to it if you want just see the exhibition you might go with f and other person together and of course posting post your pictures after unlocking everything and good not is always use the simplest possible version because the complexity comes with it spray it's not for free and actually in most cases you will be fine with L guard but it's good to know all your options so those were locks and we are arriving to the camp and we will use barrier on two examples in here barrier is a little bit similar to ledge but it's reusable you can arrive to the barrier multiple time let you can use it only one time and have it have one more parameter which which is pretty important and it's a completion function like when everyone who are expected to arrive to the barrier are there then the completition function is uh run only on one of the one of the waiting threat will run it uh and then all will be allowed to continue it's optional value you don't need to Define it but it can be very useful in here we have uh we have hikers arriving to our camp and in the morning we want to press present new program for new day so everyone should be in the one place and only one presentation will be held so so first there uh those we which went sick during the first day and want to go home they they just came by say hi I'm going home just don't count with me and this is there's a really important thing it doesn't decrement the country only on this barrier but only on all of the other FES like I said it's re usable so when it will be uh initialized again it will be less that uh the counter will be decremented already by those who dropped in previous so on on the next camp on the next you won't be waiting for those who went s sick on the previous one and who those who want to wait will just arrive to camp and wait for everyone to together to and after one of day them will start another day we have and what is important and different from LGE you can't wait for barrier you didn't participate in in ledge you can just say wait and you didn't need to decrement in barrier it's not possible and it's good to know you need to arrive to be able to wait so also I said they they are sharing tents in groups of three people and uh so each of these three people are is carrying one part of it so I created uh that struct it's it's there because uh there's no default Constructor default Constructor for barriers so I had to make some special struct to be able to create array of two STS like each three people have their own barrier they will arrive to and what will uh okay everyone who will drop uh the Expedition will need to drop the tent too and uh what is different in here when you will arrive you can you can split arriving and waiting to two parts you can arrive say okay I'm here but I will do something else in between and I will come back to check if every everyone is already there so it's possible to split it into to operation and do something in between yes so everyone is sleeping now hopefully so next step next station is a lighthouse where only six people can go inside so we have a semaphor which is initialized by CRA Al also but it has different meaning it means that six people are allowed to go inside and as long as the as this counter doesn't reach zero you can go inside one everyone who will Who will acquire this acquire this semaphor will decrease the counter and when it will be zero you will have to wait until someone will release it actually you can initialize it even on a zero because you can release more than you acquired it's not like mutex it's good to know about it there's a huge difference between them you can have a capacity of zero and the first operation may be released and it's absolutely okay it's uh it's different approach so you can also try acire try it for some time try it on until sometime there are more more options for all of those techniques I shown you but it's good to know to find in documentation but it doesn't fit in examples so uh what what is different is there's no log guard like you've seen on MX because it doesn't work like MX I said you have to take care about releasing your resources correctly what is also nice and not possible in M Texas one threat May acquire and another threat May release so we have the group family group one member of family will buy tickets for all of them they will go inside and leave one by another and releasing by DEC it's absolutely okay you can't do it with mutex mutex has to be released on on the same threat it was acquired so there's a question what will happen when we REM remove the ledge there is actually the ledge that waits for all the family to arrive before going to to that Lighthouse even when the head of family already has a tickets because maybe the one who is buying the tickets is not the first one to arrive so then then uh the first one will go there without any permission because he doesn't have still the tickets because the one who is buying it is not not there and what will actually happen at the end if there won't be the ledge you will increase the capacity of the liouse because when you release something you didn't have you increase the counter and now there will be seven places in there so uh last one is condition variable I will and condition variable is synchronization primitive used with together with mutex and uh waiting threat will be blocked until shared variable reach expected value uh sorry so we can imagine it as we are on the LUN we are ordering some food and there's wait waiter standing next next to our table and he's waiting until everyone on the table will order something so he needs to be counts of orders equal to counts of visitors and until then he can't leave so he's waiting to that correct he has to wait with uni he can't use Lo guard he can use uni loock or other unlockable lockable and unlockable M because the waiting inside is locking the condition variable only in the moment when it's checking its value because when it will be if it will hold uh the lock for all the time you can never change it you are only in time when you are checking if the value is correct is locked and then it's unlocked so when you are passing uh your lock inside is has to be unique lock at least on the other other side there's there are guests which are placing the uh orders and they can use l guard because they're just changing it and going away and when they change the value they have to notify the waiter because he's not like inating over and over he's waiting for the signal when you notify one you will notify just one one threat waiting for it they may be many threats waiting but we know we have only one waiter so we can notify one otherwise you will notify all if you want to get know all all the waiting threats okay so those were synchronization PR Primitives which defines happen before relationships those are all which are present in C++ 20 there are no more so you know them all now and they have what they have in common they uh ensures execution safety by blocking the for the progress and they limits the possible code reordering you have usually some critical SE section which can be reordered you can uh you can do this optimization while locked and what is really important they may introduce deadlock you have to pay a lot of attention to be releasing on resources you acquired it's sometimes hard because you escape somewhere you forget that you are in lock it's it's what is hard about it under other head we have atomics which doesn't R run into Deadlocks it sounds nice sounds easier but actually it's not easier at all but you don't have that luck in there that's nice atomx there are the other options on how to synchronize if you don't want to use previous techniques and uh the main purpose of them is to be immediate no one can interrupt you when you when you're doing a operation it's done it's it's one operation you do and no one will interrupt you it's safe and you can make Atomic of any trivially cop copiable type basically and uh often they are mentioned as L free Primitives so what is guaranteed this the atomic Atomic flag is look free other don't needs to be but it's internal issue you can you can use them just fine uh yeah and what is important to not is uh something which is sometime not obvious because it's not in the logic we are usually used two subsequent Atomic operation may be inter Le I know it's logical but sometimes when you write code you forget it because in here when you we evaluate the condition and then we decrement it okay we decrement it atomically but in between the condition and decrementing they may happen whatever they can they may happen happen many many stuff and that's that's the point where our most mistakes come from I I guess so what is possible to do with atomic uh types we have on integers we have uh add addition substraction logical operation you we have overloaded operation or you can write it explicitly as you seen on a on the examples I have heard several recommendation to use explicit because when you write a overloaded operator and you read it again you didn't not you don't notice at all that it's Atomic it seems like just plain integer you don't know it's Atomic and you may mess it up when you change just one line so it's maybe better to use this more uh this full name than operator but it's up to you and there's also one line which is good to uh pick up because the two lines the last two lines are not the same the X+ equal one is atomic operation the next one is not next one will load X to some temporary Val variable at one and then it will store in between then there may happen whatever it may be absolutely different value in between so with floating Point types you can use add and uh addition and substract substraction but uh so far it's not uh supported on doubles it will will be in next version but it's better to check documentation because it changes through the through the version of C++ on what which types supports which operations so uh and operation which are not only on Integer or types are which are on all atomics types is you can always ask if it's l free as I said only one which is guaranteed to be log free is uh Atomic flag but usually you have much more of them which are L free and you can you can check it you can load on and store you can do it by load store function or by overloaded operator and what is interesting is ex exchange operation exchange will replace the value on that uh Atomic for the one which you provided and will return you the old one you know what was there before you change it and it leads to the most important Atomic operations which are on which are based or look free programming probably now use our compare exchange strong and compare exchange weak there uh what compare exchange globally do is you will provideed value you believe that Atomic has and it is if when it's true it will exchange if it's not true if it's already has different value it will return false and doesn't change your value for you the difference between strong and weak is that the strong is guaranteed that when when the condition is met when the atomic has the has the value you are expecting that the operation will be done the weak doesn't have this guarantee and but maybe maybe better maybe May perform better because it's actually designed to be used in a loop I will show you on those two examples this is example for strong when you you are playing a cards you have some bet there and you want to double the bet you need first to read what is the current bet then you will increment it and then you will try to put your beton there but you have to be sure no one else in between Place more money in there but you are not so sure about your cards you want to double it only once if someone else already give that you will go away so if this uh compare exchange will return false you say okay I gave up I don't I'm don't have such a good card but in the week is okay I know I have the best cards okay someone else put there but I still want to double it I will double again the new value which I got actually I will get the new value to uh to the first parameter to bet to be doubled it will be updated and I will do it so long as I until I will be successful it uh will perform better but it may happen that even when when that Atomic value is equal to equal to the value expect it will return Force it's from it's from performance uh reason like it may be uh too expensive to write at the time and someone else wants to acquire this resource to and it will be faster for him to get it so he so when you when you are accessing it in loop it's better to use weak but when you want to do one time it's they're strong for you so there are few more I I will just summarize few more uh features you can do with atomic there's also notify one notify all and weight it's similar to condition variable but there's so one significant difference because weight with parameter old value wait blocks until the value of atomic is different than the one you provided it's not waiting until the condition is met it's actually other way around is waiting under the condition is false this modifying it works in the same way and I will show you example on this one soon another important is atomic ref which is really strong because you may have a plain value plain variable and you want to manipulate with it uh atomically so you may make an atomic ref out of it and then you can access the the plain variable as if it was Atomic you are you are not allowed to work directly with the uh with the value referencing B Atomic ref during the lifetime of atomic ref but you can make Atomic from every variable you will meet and important you can have shared pointer atomics which allows a lot of operation so let's jump into one small example on atomics to see it in context so we will pay our lunch with atomics we have there another uh important keyword it's a threat Lo threat local which is actually varable uh variable which every single thread has their own it's not shared you have the your own value and their so everyone will place their lunch price everyone ordered something different so they have their own copy I don't they don't find fight about it and how we will uh pay it we will use fetch sub which is one Atomic operation which will get the um amount the bill which is not still paid and we will uh decremented by by our lunch price we will pay it so the bill will be small by our PL and what we will get back is what was there before we decremented the old value so we need to decrement it once again after we will check if if there if there is still some something to pay on the bill and if there's nothing else to uh pay we will notify everyone okay we are we are okay we' cleaned the B uh bill and we can go home and if it's if there's still something remaining you will be waiting for that Bill Clean to be true is it clear okay so and the previous this this is something like I shown you on conditional variable is this the same situation like ordering the lunch but done with atomics what is different here is uh uh that that the customer is the one who is checking if if he's the last one because we have to because the waiter is changing doesn't have the full condition like before there was is the order amount equal to zero no this is it done false true false you you're checking just the change of the value like it's different than what you expected so the last one has has to say okay I'm the last one and the waiter will know that what is another interesting thing about it before we expected that waiter just appeared by our table but how he should know he doesn't know anything about our threats so we will call him to to be able to call him we we need to know that only one is calling him so we will use that compare exchange strong we are expecting that waiter is not there and when he's not there we we will make him come if if we if he already there we will never go through creating a waiter making an appear so that was about the atomics so I want to summarize it a little bit they they allow us to perform several basic operation on shared data without risk of data race uh for uh arithmetic and logical operation are for integer and floating Point data and for all the atom types you can use load store exchange compare exchange strong and compare exchange weak and you can also wait notify notify all we can manipulate with pointers using Atomic Shar pointer and reference ordinary value by atomic reference uh we have overloaded operation overloaded operator for basic operation but be really careful about them because it's hard to miss that you are working with atomics when you are just reading and what is important the last line always keep in mind two consecutive Atomic operation aren't Atomic together they may happen and everything in between and there are more advanced options to explore on atomics this is a just some brief introduction but it will take another whole talk I guess and there are plenty of them already but before exploring those Advanced option be sure that you understand the basics because it's really tricky to go into those others options so what we found out we found out how the data flows through the memory hierarchy why and how are is our code reordered and why do we have memory model actually from those reasons and what does it Define and what techniques we can we can use uh we still haven't covered all possible topic concurrency of course if you want to look for more there's pretty interesting topic on Parallel algorithms Lock Free programming or memory ordering which is the advanced atomics as I talk about and if you want to dig a little bit deeper into it uh we I I have all the example all the hiking example with few more cases uh you can you can find it in here and play it with all those synchronization Primitives to try by yourself so thank you very much if you have some question so do you have some questions okay yeah my question is is I heard that performance of different mes varies wildly right yeah I have no experience with that myself did you maybe have any success using I don't know some form of some spin lock spins or custom okay so if I have any experience on uh how different MX uh locks performs uh I actually didn't measure I know about the spin locks which is uh which may perform much better but I didn't per didn't measure it by by myself so I don't want to confuse it yeah test test hello yeah um the the examples You' have shown center around having a single instruction running on multiple um threats basically um what what is the most eligible way to have multiple processes uh use shared mutex or locks or something like this so if I have um two different code bases I compile but I want to sync them up in some way um in in the past this has been done for example with um pops up stuff for example or so but if I if I want to like share memory between multiple processes running maybe on different machines um do you have a good answer on how to performant um share memory and do mutexes and stuff like this over multiple machines or processes oh I'm I'm if if I know how to okay yeah you had mic sorry uh I'm I'm sorry I'm not sure I can answer I answer this one it's actually different different topic a little bit I don't I don't want to say something which is not really true yeah it's it's really huge topic and it's actually different topic this one it's out of the scope sorry I have a question about one of the examples from the very beginning if you could go yeah back to your first example where you talked about reordering code I was thinking about having different um somewhere like here uh a bit before that I think where you basically said that we can't uh oh the the have some okay I mean this one yeah exactly um I was thinking about if you have when you have external functions that you call like you only know the head of it are you guaranteed to have strict ordering in that because I'm thinking if I want to have a struct in the structor self manager own mutex I'm not going to directly lock the mutex myself I'm going to call a member function for example that locks it internally am I guaranteed to have strong ordering in that that if I call function A and B and both lock the mut takes that a happens before B or do I I'm guessing that's the case but uh oh like if you're sensing by mutex you should be fine like this is just when you're not I'm I'm not sure if I got that question correctly but you say you're locking it so you should be fine yeah but the main thing is that it happens in a different translation unit uh so can I have synchronization across translation units without like knowing that the other translation unit is locking the mutex okay hi please stop me for making wrong assumptions but I have a question about the Su first so that was a measure to limit the number of threats in a section right so you made the lightest example but still you have to make sure it's safe there right so okay so it's bit different category so I might need to combine there okay yes it's a different category yes thank [Music] you is it Poss is it possible to statically check all those um issues that you just highlighted um automatically so I I let a static analyzer run and it tells me well there's a up there's a up that is broken that is broken it will be nice actually yeah it would be nice right wouldn't it um dynamically it should be possible dynamically right is it possible statically I don't know about such such an option it's okay I'm afraid it's not possible it's yeah yeah there are some yeah tries but I it will be actually very useful to be to have such an option so to add to the previous question if you're using clang and lvm then they have threat sanitizer which does this at run time thanks for your talk it was very interesting but um I would have a question about why do we actually need all these synchronization Primitives which I usually call bottlenecks because they limit the amount of concurrent execution yet you can exploit on your machine um the in my opinion the problem lies elsewhere and this is the we're living in the shared shared mutability chain uh quadrant of execution and we probably shouldn't go there in the first place do you have a better answer to avoid shared mutable State such that you don't even need this kind of yeah synchonization I understand your question but it I find it a little bit philosophical yeah I I don't have this yeah forat don't do threats do threats yes right that's that's the correct answer you're the winner actually I wouldn't do that I would would use uh would try to uh to express my concurrency and desynchronization with cues and not go with a shared state that you can mutate during the execution of your program but you won't get the better performance now with Q um yeah but you have different techniques to handle that I'm I'm not ever if it's possible to solve somehow else so okay I think if you will find way everyone will be happy but um yeah so cues is like in my experience it's a better answer chromium does something like that it's sometimes refer to actor model basically all of your synchronization inside the queue and you don't share how any shared State and you just pass messages between the cues um someone have to implement those cues basically using those techniques yeah but as soon as that's done you don't do anything else yeah okay we use it to the most manageable part encapsulate away but you still have to deal with all the Primitives yeah you still have to deal um you have used the atomic template on simple types only in the presentation and uh you mentioned the restrictions the basic type has to have but that still leaves a lot of room and uh I imagine you could use it on string for example uh but that doesn't sound like a good idea is is there some uh like use uh the atomic on more complicated types yeah uh usually they will be blocking they will be they won't be automic it's when they got larger but yeah it's it's always better to keep it simp simple of course as I said reduce the amount of shared data so when you get a complicated structure you are increasing the amount of sharing data so it's again against the philosophy so it's better to keep it as simple as possible okay okay I see it oh so thank you very much thank you