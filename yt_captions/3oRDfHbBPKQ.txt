uh this is a talk on grpc with C++ um and some solution some generic solution so welcome everyone uh my name isaka carotti I work as a senior software engineer in alter engineering uh for those of you who don't know alter alter is uh a global uh leader in computational science it provides software solutions for uh simulation HBC um data analytics Ai and much more um if anyone wants to know more you can visit the website and uh you can even ask me after the talk or you can contact me uh by email so today we're going to see uh a solution in order to embed uh grpc uh into existing applications that probably uh have some uh all their complex designs uh where it's not very easy to discretize or uh componentize some functionality we need to share among apps um by using the uh client and server applications uh existing data model so what we're going to go through uh we are going to go through some Theory first Basics uh what is grpc why use it uh the protuff serialization mechanism that is commonly used with grpc some info on how to build uh install and use grpc uh next we're going to go through the basic features of grpc uh naming RPC types and the service API types it provides we are going to see the standard approach like the common approach when you are going to create new Services uh to use um with grpc we're going to see an example simple example the restaurant example the autogenerated apis that are provided uh by grpc see why we do not want to use the the autogenerated apis um and next uh we're going to move to another approach uh by wrapping up drpc and prot buff to a new library um and make it possible to use generic services that have no direct grpc dependencies see the benefit buet of course that goes along with some cost so what is grpc uh grpc is a remote procedure called framework G stands for Google this was originally created by Google uh it is very modern open source um high performance it connects services in and across data centers connects devices and mobile applications and browsers to backend Services it gives you all the support you need for load balancing tracing uh Health checking and authentication it comes in multiple language and it's crossplatform on the bottom you can see uh the websites where you can get all info for grpc and the languages it supports now protuff uh again uh provided by Google is the common uh serialization mechanism that is used along with grpc as a serializer for structur data it is language neutral and platform neutral it generates native language bindings it is smaller much faster than other formats like Json or XML and talking about protuff uh uh we not only mean uh the definition language in our DOT Proto files but also the code that the Proto compiler generates and the serialization format for the data so to use grpc into your apps and services first you need to clone a repository from GitHub naming the release tag that you like uh there are very clear instructions on how to build with basil and this is what zpc recommends uh you can also use cmake um you will have no issue with cmake also uh and you will need to get the protoc compiler and all other uh dependencies again the instructions online are very clear and very straightforward so what are the common RPC types that grpc provides uh uh first we have unar calls where the client sends a signal request to the server and gets one single response back we have server streaming again the client sends a single response uh it gets a stream uh of a sequence of messages to read back there is client streaming uh where uh the client writes the sequence of messages to the server and gets one single response back and and then there is uh B directional streaming which is the most generic of all where both the client and the server exchange a sequence of messages to read and write back now uh on the service API types uh currently grpc provides uh three basic service API types it is the synchronous API named also blocking um the client sends a request to the server and blocks until completion the server immediately responds back with the outcome and the status of the call uh there is the async API that binds a compl a completion Q to an RPC call and the server uh gets to handle multiped requests at the same time there is also the call back API which is again an asynchronous API uh the difference here is that uh RPC directly calls user specified code at the completion of the rpcs and that is done through the usage of reactors there are also some mixed mode um service API types uh that combine messages types with the API types um we have the ow API in an asynchronous mode uh this is is a complete async API that uses a uh Roby buffer as the request and the response message type there is the uh raw call back API uh which again is a call back API and the message types uh are using aite buffer and then there are the generic apis uh that come as async and callback again uh the message types are just Roby buffers and they accept all rpcs and host and uh the difference is that they can initiate an RPC by name which is mainly what we want so we had to choose among the two uh for our solution um the generic callback API is the one that we are going to use and you will see uh as we move forward how and why uh differences between asyn and callback API uh on the async API we're using a completion Q for our rpcs it is the application that uh must provide and manage its own threads so the application must pull continuously uh the completion Quee to determine which a sync uh actions have completed and it is the application also that is responsible for executing any action upon an RPC is uh complete uh notified by the completion queue on the Callback API uh the user code is run from the library's own threads this is a reactor based um API there is no explicit polling required for uh notification uh of completion of the rpcs and the library is responsible as we said before uh for executing any user specified code uh at the completion of the rpcs so this is what we chose to move forward with uh now let's see a simple example uh of using grpc the standard way uh as I call it uh using a simple client and server architecture so on the right uh we have the server the server um in this case provides um for example one service and in the process I call it um an order Service uh with some uh methods grouped uh under the service and uh again it publishes uh the message types that is going to to exchange with a client that is done through a DOT Proto file that we will see uh on the next slide so on the left we also have one client and when the client comes in he would like to make a request to the server now this is where uh grpc uh fits in um so grpc will be available for the client uh to make an order in this case the client will say um hi I would like some lasagna a salad and a glass of wine and then the client will initiate a call to the server through the grpc and the client will decide that uh he is going to block until uh the completion of the of the call so this is a synchronously called um RPC another client comes in uh the client again will make an order um say I would like a cheeseburger and a Diet c p and we'll start uh another RPC uh to the server through grpc and client 2 decides that uh she will um make a phone call until her Mill is back so this is an asynchronous process so how do we model that using grpc and Proto buff this is the dot Proto file uh where the server initially uh will publish um the services um uh it provides along with the message types you can see here we have one service order Service uh this is a uh this is grouping uh a few methods here we only have one for Simplicity it's called prepare meal uh it takes uh one single request named order and order is defined as a message containing four string Fields an appetizer and Main of course a dessert and a drink uh the sver will process the request and gives back a meal to the client the meal consists of food which again we defined as a repeated field that means a list of recipe Fields uh the recipe field can contain other things like uh ingredients or anything um and also a double field which is the c poost so we start by providing that dot Proto uh file to the protoc compiler and uh the protoc compiler will give us back some autogenerated code that contains uh the data model and uh the client Library we call that a stab the stab uh is a component uh through which the client will uh interact with the server so all the these uh service API types that we you saw before are accessible to the client through the stab so originally we get uh two uh files with autogenerated code uh one is um the data model here you can see that we have four classes for the four message types that we uh provided uh we have a recipe a food order a meal all those uh Implement uh some basic uh protuff method type and they contain uh they they are ready to use classes they contain uh copy semantics move semantics everything you need for efficient memory allocation um queries and you can use all directly but now the problem for us is that we already have these classes in our uh data model so we would like to use that instead uh together with the data model there is another um uh autogenerated file that contains as we saw all the the uh the available service API types so the simplest one uh the the base of all is uh grpc Service uh this one provides um a blocking API so we see that the way to call prepair meal through the stab would be by providing a context an order request uh a meal response that we will uh eventually get uh back and a grpc status which is the status of the call that is originally um uh written right after uh we have an async uh API that is called request prepare meal in this case uh that also takes a context a request uh a response writer to get uh the response back a completion Quee for the client a completion Quee for the server and we also need some unique uh tag uh for each RPC the Callback API uh you see that in this case we call prepare meal there is a special type of a context in this case um to exchange and uh again uh we give the order we will take back the meal in this case um originally uh the method returns um a server unary reactor because we defined uh this method as a unary method uh and through that reactor we are going to react some way uh on the server side and uh there is also the raw async API you see that this is identical to the previous uh a Bing API that we saw the only difference is that uh now uh the request and message types are of type grpc bite buffer and the same goes for uh the Callback raw API where again zpc bite buffer is what we need for request and message types so what do we need on the server side to call uh these apis our services need to implement one of these um grpc provided service classes uh on the top you see the uh blocking base uh grpc service then we have async service call back service and two um generic uh service based classes for uh the async and the Callback apis so to implement and call uh a unar synchronous uh method uh named prepare meal uh we need to uh two implementations on both sides uh on the server side and on the client side on the server side as you can see uh we have some uh order service implementation that implements that synchronous base order service service uh Base Class and we Define our prepared meal there uh along with its implementation where we will we will uh create food Calculate cost um create a meal using that and just giving those back to the client and on the client side um our implementation needs to have a unique stab uh in order to generate the stab we need a Channel of connection uh so first we create uh the channel uh outside uh the class uh then the stab and through the stab uh we call prepare meal after we have um calculated our input some way and uh transform it into a uh protuff message type uh of uh type order uh and then immediately we get both the reply and the status of the call back so this is pretty simple and pretty straightforward now on the other hand if we need to call uh a bidirectional callback prepare meal method we actually need two things we first need to implement the reactors on both sides and the services like we will see on the next slide so the reactors uh as you can see we get one reactor on the server side named prepare Mill reactor and we have to do that for every method that implements a server by directional reactor uh taking an input uh of type order and giving an output of type meal in this case uh we get uh three callbacks as you see uh one for every read operation one for every right operation a final one named on Dan uh which we have to implement as it is a pure virtual method um and we decide what to do um upon every read and what to finally do at the end uh where does prepare method um prepare meal method uh definition um fits in here uh usually as you will see on the examples on GitHub you will see that they they all use some next right uh method where they fit in the prepare meal calculation and then they call next right upon every read uh after calculating the output so on done on the server side will take us to Onan on the client side on the client side also uh we are implementing the same call box every read from the server uh upon every right to the server and when everything is done um the difference is that uh on creation um of the of the reactor on construction um we will use the stab to Define um that we are going to call prepare meal with the context next and uh the whole thing initiates by using this uh start call and uh the service in this case uh in both sides is implemented a different way it will actually uh in both cases it will construct a reactor so on the server side uh the implementation is just giving back a new reactor and everything is going to happen through that and on the client side um again uh upon construction of the reactor the whole uh RPC is going to initiate um this is why we see uh a message on the bottom that uh your order is getting ready so the PC has initiated and it's being processed by the server so everything seems good so far but uh for us uh that didn't work quite well because uh now um on our applications we have uh added some direct grpc and also protuff dependency with all the extra dependencies compilation and whatever else it needs we also uh on our server and client applications uh we those already share an existing data model we would like to may use to make use of uh our our existing classes uh if we choose uh to make conversion between those classes uh that could be complex and inefficient um as this classes may contain a lot of information um in some complex way and also the third Point uh the existing apis may not cover our needs there are some things that you don't get for free uh with grpc for example uh the row or the generic apis do not cover for unary methods uh the row apis cannot be extended in the sense that uh mixing RW data with structured data is not possible and at some point you may want to do that and also there is no clear objective on the Callback apis on where this service method implementation should be like you saw um we use next right in that case but this is not clear anyone can decide to place that definition anywhere so with that uh we will move to a new approach uh a more generic approach for the same example so now that we're going to see uh a client server architect using a new library named my grpc what we're going to do uh we will move this do Proto file from the server to around uh grpc we will add some generic services in there uh basically only one is what you need um with a list of some generic methods me and uh uh messages of more generic types that we will see uh uh we will use this Proto file to uh generate code that will be internal and hidden from the user and we will use our own apis to access um the services that eventually the server will provide so this is our new DOT Proto file now um it is one and only and it's hidden completely uh the user doesn't have to know anything about Proto buffer you see that there is one service called uh my grpc generic Service uh here there is one method named call for and you can name it whatever you like invoke sometimes is the most common um takes a stream of requests and retains a stream of responses this stream Now does not refer to a streaming process uh but rather is used for message chunking so in case of large messages you can model that as a streaming process as the messages get chunked and read on a uh sequence basis uh for the message types we use a protuff type of bytes for all data uh we can add some optional fields to denote the the end um of the message if we would like to chunk it anyway so this is why it's optional um and this is like the most generic uh RPC signature of all so given that Proto file um with grpc uh we will wrap that uh and use some uh other components uh for our library so what we're going to need is my uh grpc generic service that we saw before um some handlers uh for the methods uh a service method call uh that uniquely defines uh one RPC my service method reactor which will be an implementation of uh a generic that we saw before a generic by directional server reactor and the same goes for the other side of the client so again we're going to have a reactor a Handler for the methods a method call for each RPC initiated by the client um without of course my GPC generic service which is uh only the implementation on the server side and this is all internal uh nothing is uh exposed from these components and uh the exposed components contain uh two types for request and response which eventually wrap uh that uh Proto buff message types a server um a server class uh for in order to to access uh the server apis uh my service which will be now our new base for all of our services and my stab uh which will be the stab that we're going to use uh um in the client to access the um to to initiate rpcs and access uh the server uh services so also we need to decide on what our uh common service method signature will be just like grpc it has to be unique and common for all the methods so looking on the data uh my request and my response the only thing that those provide is actually a standard stream uh for the client and the server to read and write back and the library now is responsible to manage the uh lifetime of the request and the response stream um the client and the server only uh acquire this stream uh to make read and right operations and uh behind the scenes uh the internal implementation of my request and my response as you see also contains uh a my zpc request uh as defined in the generic dopro file Setters and Getters and uh possibility to slice the data so getting the next slice um once the message comes along uh this is just uh the same thing that we talked about only in code so you can see that the internal implementation contains two things and standard IO stream but also uh a mypc protuff message type request uh it has the possibility to get and set the next slice and um eventually uh get the grpc request um in terms of uh again uh Pro buff messages uh the response implementation is just exactly the same as the request so on the server you will see uh on the right uh that we have my grpc generic service implementation where this call for code uh uh the implementation is and this is the RPC entry point for each call we initiate from the client uh so once uh an RPC comes there um it creates a generic reactor like we saw before through the reactor everything happens the reactor also performs uh any slicing that we would like to do for really large data uh it creates a method called instance um that includes an ID name maybe client initiator ID for each call and we also have a Handler to um to keep track of all the calls um and manage the lifetime of the calls and externally uh we have my service now all of our services are going to implement just that um uh the my service implementation will contain a list of methods uh using the common signature but also there is get method and get method needs to implement it for each method uh in order to bind uh the particular method to a standard um uh function object that we will be able to call by name my server provides apis like uh start stop register service all those are quite the same just like uh grpc so here is uh my grpc generic service you will see here that it only implements grpc service blocking uh base class but it doesn't matter because in here here we can include any uh service API type that we would like and we will see how um as we move forward so you can choose uh to implement call for uh the way you like as a unary synchronous uh call as a bidirectional uh streaming synchronous call um as a by directional call back call like we do uh on the bottom and this is basically what we do do what we choose because this is the most general of all so uh call for uh will uh take a context and return uh a type of uh server by directional reactor using protuff my grpc request and response and returns uh my server method reactor which is an implementation of such a reactor this is the the uh the server method reactor that uh we have in our library um as you see this is an implementation of server by directional reactor so it includes all the call backs that that provides uh including any other that we would like to add um that is undone what happens on every read what happens on every right what will happen on cancel and then that next right that we saw before in this case uh we'll call uh any of the methods that we would like that are provided by the server by name this is the my service oh sorry my service interface uh as we saw the only thing that we need to implement here is a way to bind our method uh with uh a standard function object that we are going to call so if you see this this is an implementation of the previous interface uh how we're going to implement now my order Service uh in contast in contrast with what we did before so in this casee we have chosen to have a Boolean prepare method prepare meal method that takes my request as input and gives my response back as output how to implement this um we get the service from the request we will deserialize that using our own data model derial the serializer uh we will calculate the response so we will uh create the meal um response and we will Ser serialize that using again our uh meal in this case uh serializer and on get method we will just given the method name there's uh a missing statement here but if the method name is um prepare meal then we will bind that prepared meal to a standard function object to call now this is a basic difference on the server API uh so uh you will see that to start the server uh in grpc um we are doing actually uh one thing before uh really starting the server we create all of our services and we register those services to the server in this case we have an extra step uh where we configure my grpc generic service the way we would like so how do we do that uh we will use some uh grpc internal uh apis to create a service method the RPC the grpc way uh we will Define the RPC type as you see as by directional streaming um the uh RPC type as a as cback uh RPC and we will add this service method to the service so this is a way to uh Define methods uh that you can use um in using uh any RPC type you want and any um service API type you want so you can have multiple methods with different Service uh API types grouped on the same service then uh we registered my grpc generic Service uh this is the common grpc approach through a server builder of grpc uh and we start the server the grpc way through the build there using build and start and next on the client side uh what we're going to expose is a stab that will group all these uh method apis for call 4 um internally uh that all will be handled through a method called Handler uh that again is is it is a a mirror approach of what we're doing on the server um sorry uh so the Handler keeps and manages the method calls uh which remain live until uh completion um you can see that the RPC trigger point uh is basically through our generic reactor in this case uh and that um that run method over there uh will start uh the call to access the server through the server reactor so now you see what we can include uh on my stab now um I have added a call for blocking and a call for call back but normally you wouldn't do that um normally you probably uh would have just one API or um to make it more fancier and better we would have like separate stabs um a blocking stab or a um an asynchron stab like this is what happens in Java um The Blocking API returns a status and apart from request and response it also takes a service name and Method name uh to be able to call a method by name uh the Callback API for call for uh again takes a service name and mage method name a request and a call back um you can see uh with the signature of uh uh getting a drpc response um uh giving back a response and a status and this is a Boolean uh method uh so there are two points here uh in case we need to somehow simulate um a streaming process we may also use an API using a vector um or some list uh of requests for the streaming calls uh you can see that the context is missing here um this is because uh we Define everything at a higher level um and internally but if you would like to exchange metadata uh per RPC then okay of course uh we will add a context um as an input and now you can see that uh we can choose to return um a status of our RPC for example if we need to make some uh monitoring on the client side uh uh for the calls uh if we need that we can also return a status we can basically do whatever we like uh point two yes uh choose among blocking or call back API or combine the two uh or just separate the stabs like we said uh uh we have the option to add a callback even for synchronous rpcs if this is something that we would like to add choosing the signature of the call back is one benefit we get uh and also if we already have some uh signaling uh mechanism in place uh we can even completely omit uh the call backs we embed that and our signaling mechanism we just signal through uh the reactors back to our code so the change if you see here uh this is what we did before so the standard way we saw that we um we implement the reactors on both sides implement the service on both sides but now if we would like to call uh prepare meal uh our new way uh we will just have our call back and from the client through my stab now we will call for order service prepare meal given a request and binding that call back to the call and on the server side uh we will just uh Implement get method to bind this prepared meal with some um function object and implementing prepared meal so this is this is a very clear place where we Define and Implement all that so what what is the benefit that we got in the end uh so we removed all Direct grbc dependencies on both sides now also the clients can decide on a synchronous or asynchronous or call back mode previously this was just defined by the service the service was the the service implementation was uh the one that decided uh um how the clients uh will initiate rpcs we get the ability to group multiple methods with different API types under the same generic service we get more intuitive client LPA apis uh we also get cleaner code we now have the ability to to to add extra functionalities on a higher level so for multiple services or even servic methods like we did with message chuning uh the same we can do if for example we want to event a progress callback um or anything else on some higher level and the cons of course um since we are using our existing data model all our classes need to provide their own serialization mechanism so that along increases again the development cost cost and this is C++ Only Solution so there is no multil language support for that if we would like to use any other language then the library needs to provide bindings for that language also so as a summary uh we saw a few things in theory about grpc how is grpc is used uh with protuff and how it is used on newly created services and applications uh we saw an alternative approach that we can use in our existing applications and our existing data models and of course since we actually paid the price of developing such a library um we got the extra bonus of the flexibility and the freedom that uh uh we could use uh in our newer apis so thank you [Applause] hi thanks for the talk uh I have a question about uh keeping um changing the um grpc definitions over time with this break compatibility with like older clients that still use an older grpc definition of of my AP especially if I use the generated um headers uh changing the definitions of uh grpc uh is even um even better handled in this way because there is a common new library that will be maintained and you know by uh someone and not by everyone so you will obviously have to maintain the library and you have to keep up with any latest update uh but that will also uh uh move to your client and your server implementations without any cost from their side okay so I can just update my trpc and the client doesn't have to change in any way and can still use as long as you keep your a apis uh you know in a generic form that will not change over time then you get the benefit of um changing the implementation internally and with no cost on the server and the client side thank you hi uh I sort of had the same question uh as before but I want to be more explicit uh in when you want to change the schema of a particular message or payload and how you handle uh API versioning specifically in in in parallel so when you want to support multiple versions of your API when you actually change fields in the schema uh the the schema of the uh that genetic schema that you saw obviously will not change because it's only row bytes you will not change it ever now of course if you want to change the schema in your applications the only thing that you need to maintain is your serializers and that's it that that makes no actual cost for this Library I would need to maintain two czers like for each version that I'm I want to support in clients yes but uh in this case okay we are uh we are actually uh using a common data model in both so you ultimately you will have to do that yes I would like to continue the tangent that we're already on um is it now not the case that your client doesn't know your API anymore if you use this generic situation then you have have just robw bites so if you want to expose some kind of API to your clients stating these are the methods we support yes you will Yes actually uh you will have to do that uh for us we're using some Json um you know uh uh format to uh so that we um uh reflect uh what kind of services and what kind of uh data uh we provide uh from the server to the client uh if you want to do that um uh without any connection so just for Discovery um otherwise uh if you would like to just reflect what is available on the server after connection to the client um you can uh have a reflection um method uh included in your generic Service uh that will basically mirror whatever is available from the server to the client reflection also is used by by drpc okay thank you still staying on a serializer I think you might have answered some of my questions already but what format did you use for your serializer did you stay with a Proto of your Custom serializer Custom Ser yes custom serializer uh just uh using uh standard streams standard stream yes on the same page of the other questions is one of the advantages of grpc is that you and basically you can violate the API you can violate the contract so now you have this stream Rob bites uh so did you have any issues with calling for example the wrong method with the wrong B stream or something like that and you maybe catch that bug in some ways in testing for example any experience to mitigate these issues because this this solution suffers the very same problems of Json that you basically can't uh statically avoid these kind of issues no we have not we didn't have such issues um but um maybe you can avoid these issues if you use a variant instead of you know separate uh types but so far we didn't have any issue thanks a lot thank you