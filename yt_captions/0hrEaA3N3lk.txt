Hello and welcome, everyone! I'm James Murphy. And welcome to mCoding where we try to get just a little bit 
 better at programming every episode. Here's a trap that every single Python 
 programmer will fall for at some point in their career.   There's pretty much no setup. All I've got is a small class with a 
 class variable "__count," a getter, and a setter. We create an instance of 
 the class and print the count just as a control. Then, instead of using our setter, we 
 manually reach in and try to change the count. And then we print it. Couldn't get much 
 simpler of an example than that, right? So what do you think it'll 
 print when I run this main function? I'd give you a minute to think about it. But it seems like the answer should be very obvious. The first print statement should print zero, 
 that's the default class variable. And the second should print 42. But when we actually run the 
 code, we see zero printed both times. But there's what, 11 lines of code here. What could I possibly be doing wrong? If you don't already understand what's going on, the frustration of a bug like this, THIS IS OUTRAGEOUS, IT'S UNFAIR! HOW CAN YOU BE ON THE COUNCIL 
 AND NOT BE A MASTER? No, I'm not using a non-ASCII look-alike 
 character or some other thing to trick your eyes. But yes, it does have something 
 to do with the name of the variable. In particular, it has everything to 
 do with these two leading underscores. If you just name the 
 variable 'count' instead of '__count', you would get the output that 
 you're probably expecting in the first place. So something funny is 
 going on with the underscores. But if I use the setter, everything 
 would have worked fine. It was only when I tried to 
 directly change the object that it didn't work. And to add to the 
 confusion, the value 42 is in there. When I directly set the value of the count, and I print it out by directly grabbing its value, we do see the 42. It's just the call to 'get_count' that still returns 0. To figure out what's going on let's print the dictionary of this 
 object after setting the count with both methods. Very surprisingly, if you're not aware of this feature, the dictionary contains two different count variables. One of them is the one that we intended to set. And the setter apparently set this variable. W H A T ? And likewise, the getter 
 appears to be getting that weird variable, not the variable that we set in our code. Well, let me introduce you to the questionable 
 feature behind all of this confusion: Private Name Mangling Basically, if you're inside a class and 
 you name a variable with two leading underscores, then Python will replace all uses of that 
 variable with a mangled version of that variable. The reason for doing this is 
 to sort of support private access specifiers like they have in other languages like C++ and Java. Suppose I'm building a GUI 
 library, and I have a base widget class. I keep count of all the widgets and 
 increase it whenever I create a new one. I also use the count to give each widget a unique ID. But there are going to be tons of 
 different widgets, text boxes, labels, buttons. But in some subclass, like this 
 button, I might also have some kind of count. In this case, the button's count 
 means something totally different. The button is counting 
 how many times it's been clicked. Whereas, the count in widget was like the total 
 number of widgets that had been created before this button. But maybe, I have a whole class hierarchy of widgets, And I didn't write all of them. Most of them were written by a 
 mix of ten different open-source developers. And of course, anyone that uses 
 the library is free to create their own widgets. Because of this automatic private 
 name mangling that happens, there's no conflict here. All uses of this '__count' are automatically 
 replaced with this '_widget__count'.  Whereas, all usages of this '__count'
 get replaced with '_Button_count'. Because of the private name mangling, the author of the 'Button' 
 class doesn't need to know or care about the variables and private 
 implementation details of the widget class. Everything just works, and there's no conflict. At least, that's how it's supposed to work in theory.   But in reality, this picture 
 comes with a lot of asterisks. The first very important asterisk here 
 is that Python does not have private variables. All variables in Python are public. This private name mangling 
 just changes the name of the variable. It doesn't actually prevent anyone from accessing it. So if you know how name mangling works, you can still reach inside the 
 class and change anything that you like. The intention of name mangling 
 is to prevent accidental reusing of variables, not purposeful modifications by 
 a nefarious class author. The second asterisk is that 
 the rules for how name mangling works and which variables it applies to are pretty weird. Python does this name mangling 
 if your variable starts with two underscores. Unless it also ends with two 
 underscores, then it's not mangled. Including if your variable is 
 just two or three underscores. And it does this for all 
 identifiers, including local variables. So if you were to look at the local 
 variables of this function, you would see this. Including, for some reason, imports, unless the import has a dot in the name. And it doesn't just do 
 this on 'self' and local variables. It does it on any usage 
 of a variable name of this form. And the mangling is done based 
 on the class where the code is defined in. Not the class of the object. So this statement will 
 try to set this '_a__version' of the x variable. Even if b isn't an instance of a. Because this init function 
 was defined inside of the A class. It's going to use A here. But it doesn't just use the class name. If you add underscores to the beginning 
 of the class, that doesn't change the mangling. So, even if you have a bunch of underscores 
 at the beginning or, more realistically, one underscore at the beginning, the 
mangled name will still just have one underscore. Unless the class name is only underscores. Then nothing is ever mangled. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  If you're interested, here's a Python 
 implementation of how the mangling would actually work based on the given class name and identifier. And if you're looking for the actual 
 CPython implementation, then you're looking for this 'Py_Mangle' function. Don't worry. I'm not 
 actually going to go over the C code. But the one thing that I do want to take 
 away from this is actually the name of the file this is in. It's called 'compile.c'. That's right. As if it wasn't already confusing enough, name mangling actually happens at compile time. Yes, Python is compiled and it is also interpreted. And the name mangling happens at compile time. So that means if I have 
 this 'get_count' example like at the beginning, the usage of '__count' here isn't 
 mangled because it's not inside the class definition. And we see 0, just 
 like at the beginning of the video. But if I had defined this 
 'get_count' function outside of the class and then assigned it at runtime, then because when this function 
 was compiled, it was not inside of a class, this usage of 'self.__count' doesn't get mangled. And therefore we see 21 instead of 0. So literally just moving where the function was 
 defined can change the behavior. That means in any class 
 depending on this private name mangling, you can't use many 
 of the dynamic features of Python, No dynamically created 
 methods, metaclasses, or decorator magic. That's not to say those things can't work. But it just becomes incredibly, 
 incredibly confusing in order to make it work. If you want to stay safe and not worry about it, you're pretty much 
 limited to features of static languages. Which is not completely bad. In fact, I recommend 
 that, especially for larger projects, you self-impose a lot of the 
 restrictions that static languages force on you. But that's besides the point. Just be aware. If you're using mangled names, there is a very high chance that 
 other developers, including yourself in the future, will be confused by what's going on. In order to get a feel for when 
 and how Python does this mangling and to verify that it actually does 
 happen at compile time, not at runtime, I highly recommend you check out Compiler Explorer. For Python, It shows you the 
 bytecode output of your module. You don't need to understand all the bytecode 
 in order to see what's going on here. Put in a recognizable constant so you can 
 find where that corresponds to in the bytecode   Very nearby. Notice we have this "store_attr". And there we see it, a mangled name. You can see how if we don't 
 meet the requirements of a mangled name, like just having a single 
 underscore, then the mangling doesn't happen. Same thing if we had two 
 trailing underscores. No mangling. We can use this to see that the mangling 
 still happens even if we're just using a local variable.   And we can see that it still happens 
 even if we have a deeply nested dotted name.   Any use of this identifier will get 
 mangled as long as we're inside the class. But if we're not inside a 
 class, look for that constant here. Then the name doesn't get mangled. Please try this yourself. Check out all the different cases 
 of variable names and class names and whatever. And see for yourself when 
 and where the mangling happens. My favorite absolutely cursed case of this is this.   Of course, I've literally never seen an 
 actual module that's prefixed with two underscores. But just so you can see what the compiler does. We can see Python does 
 not mangle the name of the module, But it does store the 
 module under a mangled name. But if we just import a double underscore module, then both the stored name 
 and the imported name are mangled. And I guess it's mostly just curiosity at this point. Even I wouldn't do something this cursed. Now that we understand that 
 name mangling happens at compile time and after a brief break to calm down, I just wanted to address 
 what's usually the most common question. And that's how does name 
 mangling work with 'getattr' and 'setattr'? Mangled names are just names at runtime. So if you want to use 'getattr' and 'setattr', you need to just manually mangle the name yourself. And additionally, mangling 
 does not apply inside strings. It only applies to identifiers. So think variable names and dotted names. If you use 'getattr' or 
 'setattr' and forget to mangle the name, you're probably going to 
 get an error or set the wrong attribute. So finally, we need to 
 address the elephant in the room. And that is, because of the 
 confusion and complexity of name mangling, do people actually 
 use private name mangling in practice? And should you use 
 private name mangling in practice? In my actual experience programming in Python, I pretty much never use this. And I pretty much never 
 see it in anyone else's code either. So what do I see? The most common thing that 
 I see is single underscore variable names. Now, different people will tell 
 you that a single underscore prefix means that a variable should be treated as a private variable or a protected variable or an implementation detail. And I'm not going to argue about the 
 technical definition of what it should be called. Suffice it to say that the convention 
 and the popular unspoken rule is that an underscore prefix variable means "don't touch me." If the author of the class 
 meant for you to be able to change it,   they would give you a way to do that. Often through getters and setters. Rarely, I do see this dunder 
 form of an attribute to mean private. But actually, I more often see 
 that as a public kind of magic attribute. More like a dunder-len or a dunder-str. These are typically not private. It's very common and 
 expected for a class to override these. But the problem is that these approaches 
 don't actually solve the original issue that we had.   Remember, we had a hierarchy of widgets. And we didn't want someone writing a widget 
 to have to understand the implementation details. And avoid the variable 
 names of all the parent classes. If I just use single 
 underscore prefixes on my variables, that's certainly clear to readers of my code that: This is an implementation 
 detail. You're not supposed to touch. But in order to know what all 
 those attributes are that I shouldn't touch, I need to end up reading all the 
 source code of all my parent classes. Otherwise, how do I know that my  parent
 class doesn't have their own 'don't-touch-me' variable? And so you have a choice, a trade-off. You could use a single underscore. And force that every class that inherits from you 
 needs to know the implementation details of your class. Or you could use private name mangling. That way people that want to subclass your class don't have to worry about 
 any of your implementation details. But you pay the price in 
 terms of using this confusing feature. And you lose some of that 
 ability to use Python's dynamic capabilities. Or, and this is also a very questionable idea, you could manually mangle the names. Subclasses don't have to 
 know about your implementation. There's no unexpected, hidden, or confusing side effects. But your code looks 
 horrible, and your co-workers hate you. Honestly, it's a trade-off 
 you need to decide for yourself. But full disclosure, in the wild, the most 
 common approach is to use the single underscore. And to just hope subclasses 
 don't clobber your implementation details. If you're very good about keeping your 
 classes defined as if they were statically typed, then you could also write a letter rule to help you. But in any case, go forth and decide for yourself. As always, thank you for 
 watching and making it to the end. If you enjoyed my video, please do subscribe. And if you especially enjoyed it, 
 please consider becoming a patron or donor. Thanks to all my patrons and donors for their support. Don't forget to slap that like 
 button an odd number of times. I'll see you next time.