hello everyone over the next few videos we're going to be using what we've learnt so far in the series to create a simple little avoid the falling blocks game all right so let's create a new project I'll call this episode 13 and let's just set it to 2d mode over here being in 2d mode just changes a few small things I won't go over all of them but for example you can see in our scene view can no longer rotate around since we're in 2d mode up here if we do want our 3d workspace back we can just toggle that and the main camera is set to orthographic instead of the usual perspective projection if you don't know what that means it's essentially just that there's no depth so if I create a cube here and move it away from the camera you can see that it doesn't get smaller and if I just rotate this a  and say scale it out in perspective mode would of course expect to see that vanishing into the distance but in orthographic projection everything is the same distance away from the camera so we don't get that sense of depth okay so the first element of the game that I'd like to get working is the player movement so we're going to be getting this cube just moving left and right across the screen and is an added challenge rule to make it wraparound so if you have the one side of the screen then you appear from the other end if you'd like to use this opportunity to test your knowledge it wouldn't be a bad idea to pause the video and try get this working on your own all right let's start off by creating a little cube object to be our player I'll just reset the transform on this and move it down and just rename this to player in the hierarchy and create a new C shop script called something like the player controller which we can attach to the player object and open up so we'll launch a public float to determine the speed at which the player moves set that to maybe seven by default and then we can just go about the by now probably a fairly familiar process of making the object move will first want to get the input so we can say float really really interested in the input on the x-axis so we can call this input X is equal to input get access rule we want the horizontal axis then velocity is of course just the direction multiplied by the speed and our input X is the direction so we multiply that by speed and then we can say transform dodge translate we want to move horizontally so we'll say vector 2 dot right multiplied by the velocity and we'll also want to multiply by delta time alright let's save this and make sure it is working as expected so if we now enter play mode you can see that we can indeed move our player left and right so when to do now is get it wrapping around the screen so the sort of crudest way to do this would be to just move our player along and look at the x-value that it has when it moves off the edge so it seems to be about negative nine point five and on the other side will just be positive that value of positive nine point five so let's just use that value for now and once we've got it working I'll show you a better way of actually calculating that value from the code so in monodevelop we will have a float can call this screen half width in world units all right so usually we'd measure the screen width in say pixels but here we want to know what half the screens width is in world units and we saw that to be roughly nine point five so we can say that if the transforms position on the x axis is less than negative half the screen width in world units that means that the player has gone off the left edge of the screen so we'll want to set transform dot position equal to a new vector2 for the x value will want to have positive screen half width in world units and we want the y-value should just stay whatever it was before so we pass in transform dot position dot y all right and then similarly let's just copy and paste this if the position on the x axis is greater than positive screen half-wit in world units want to set it equal to negative that value so let's try this up now save and go into unity and we should see that when we go for the left edge we reappear on the right edge and likewise if we disappear on the right edge will reappear on the left edge now what what we've done clearly works it's not a particularly good idea to have this value hard-coded like this because if for example we wanted to zoom the camera out which on an orthographic camera you do not by changing the Z value over here that will do nothing but rather by increasing the size variable if we zoom out like this you can see that we'll have to go and recalculate the screen half width and that's tremendously annoying of course and also if we change something like say I rather want the aspect ratio of this to be three by five so we get this nice tall view once again here the screen half width is gonna be completely wrong now happily the screen half width is actually incredibly easy for us to calculate when we're in orthographic mode because this size value over here is actually equal to the screen half height in world units so if we take the aspect ratio of the camera that is to say the width divided by the height and just note that the width and the height are measured in pixels but of course since it's a ratio the units don't actually matter they get cancelled out so then if we multiply this ratio by the orthographic size which remember is half the screen height in world units that will give us half the screen width in world units all right so if we go back into monodevelop let's not hard-coded value for this variable let's instead calculate that inside of the start method so we can say screen half within world units is equal to you can go a camera dot main which as you can see from the summary just such as the scene for the first camera tagged main camera which is the default for our camera in the scene you can see it's got the main camera tag applied to it there and we can get the aspect ratio from this and then we can multiply this by once again camera dot main dot orthographic size all right so if we save now we should see that this is working we have one problem now though and that is that we aren't taking the width of the player into account so it's actually screen wrapping when it's only halfway through since that's the center of the player so we just want to imagine that the width of the screen is actually half the width of the player bigger than it is so if we go into the scripture and say float half player width is equal to simply the scale on the x-axis divided by two then we can just add that to our screen half width so plus half player width all right now if we press play you can see that this is working correctly this of course means that if we decide to change the scale of the player at any point that will take effect in our calculations and things will work right off the bat all right so we've got everything working nicely now it's probably not entirely ideal that we're including the half player width in the screen half width variable doesn't really belong there if you'd like to take it out and instead include the half player with in the calculations down here then that's something that you could puzzle off on your own another thing you've probably already thought roof but just like to mention anyway that of course if we change this to be a minus and then change this to a minus and this to a plus then instead of a screen wraparound or we've suddenly got is a simple screen collision system you can no longer move off the edge of the screen but I want to keep it as a wraparound system so I'll just revert back to that okay so in the next episode we're going to start by spawning some objects in at a random position above the screen and just having those fall down so if you'd like to test yourself once again then I'd recommend you try get that working before watching the next video until then Cheers