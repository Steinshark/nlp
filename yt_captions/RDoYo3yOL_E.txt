as part of doing bits and bytes and fairly low level stuff we have mentioned the possibility of a thing called binary coded decimal and that effectively ibm in their mainframe days led the charge on this now done a video on this and how it led eventually to extended binary coded decimal i'd like to talk about what is bcd why is it necessary and in particular that's to answer a question that i did vaguely think about in my early days of doing heavyweight macho calculations overnight it's effectively how does this stuff ever get printed out i thought well what's the biggest ratio between actual computation and fairly quick printouts i can think of not my quantum calculations they're minor league those of you are familiar with douglas adams and hitchhiker's guide to the galaxy which was made into a bbc series here and also became a movie i think we'll know that douglas who was a very far-seeing guy it had this idea of the ultimate computer called deep thought [Applause] and it was years ahead of his time because i'm pretty sure that deep blue ibm's chess machine deep mind the ai machine that's doing go is it and so on and you know deep learning deep everything i'm not at all sure it isn't all down to douglas adams i just have to point out here that the ultimate computer was the earth oh and there will be some fans who might point out so um oh i see so just nevertheless deep thought was i was asked deep thought what is the answer to life the universe and everything and several million years later presumably even with quantum assistance you're really not going to like it tell us the answer to life the universe and everything is 42 42 42 42 and my first thought when i was laughing out loud at that was i thought what's 42 in binary is there something special about it and yeah how would you convert the binary string for 42 into being literally 4 and 2 on a piece of line printer output 42 in binary is 1 0 1 0 1 0. how do i know that that's 42 well starting at the right it's powers of two so two to the zero is units then twos then fours then eights then sixteens and thirty twos on with that knowledge we say okay it's a two plus an eight which is 10 plus a 32 is 42. pretty good look a six bit representation for a two digit decimal number but if you feed that into a printer you're not gonna get 42 printed out because by and large they do not interpret binary so where does the printable form of 42 come from and the answer is it goes way back to the fact that ibm and their computing machines way back at the start of the 20th century they were the horith company you know doing census details controlling elections from punch cards and some ibm early electronic computers i think the ibm 650 was it actually did work internally on decimal just like tommy flowers i think they both used by quinn but the pressure was on from binary based hardware to say it's this is more efficient by far you'd be mad not to use it okay says ibm but although it's got to be a binary representation we want to directly link it to the decimal that will ultimately be printed out now think about it that's easy to do but what would this binary coded decimal be for 42 every decimal position can range from naught to nine so how many bits do we need to represent nine well we know that three bits isn't enough three bits goes up to one one one which is seven but you need eight nine so you've got to go to that fourth bit and you end up of course with eight being one and three zeros and nine being one zero zero one ah i hear several of you say but you don't stop there you can go onto hexadecimal and this is precisely the thing with bcd you must not let it go over into the hexadecimal range from 10 to 16 because the average person wants their answers out in decimal not in hexadecimal so here we go then look 0 1 0 0 taken as a grouping of bits on its own that's nothing in the units column zero in the twos column one in the fourth column zero in the eighth column that represents decimal form right next door to it is a separate four bit entity if i write down zero zero one zero that represents a two in its simplest form that is what binary coded decimal is and you just use them in four bit nibbles now we all know a nibble is half a byte a byte equals eight bits well it does in the modern world so half a bite well the name nibble caught on for obvious reasons a nibble being a small bite and i'll use an eye but some people like to extend the joke as much as possible and actually spell nibble with a y i don't mind and the nibble can hold a hex digit you might say oh well that's it then if i fed 0 1 0 0 down a serial line into a printer it would cough into life and print four no not quite but we're getting close because what we've got to ask ourselves is this whole printout thing is treating decimal digits as characters they're not being thought of in their numeric sense at all it's just any other character it's like an a a b a z an exclamation mark or whatever the ascii committee in the 1960s didn't just work in a vacuum they knew what ibm who they loved and hated had been doing for years and it basically said it is so much easier if you base what's printed ultimately on a bcd representation but put a special marker at the front of the bcd to pad it out to a an 8-bit byte but do it in such a way that in a sense the codes that are gonna do zero to nine are in a sensible place now what does that mean well let's do ascii first even though historically it was second um in ascii the digits occupy from three zero hexadecimal to three nine hexadecimal what it means is if you have got shall we say this four oh one zero zero that is your hex nibble for four all you have to do to make it printable as an ascii for is to glue on the left hand end hexadecimal 3 which is the same as decimal 3. it's 0 0 1 1. so 0 0 1 1 prepended to 0 1 0 0 gives you an 8-bit entity which if you fire that down as a line printer it'll cough into action and printer 4. notice that when i say glue on at the front in order for it to be efficient you don't want to be adding on something that was will cause carriers if you see what i mean you need to park it on a multiple of 16 and then what will happen is that whatever way you convert your four into being 34 hecks it will not cause ripple carries which are inefficient okay say ibm mainframe types why not historically tell the youth of today what ibm did originally same idea ascii learnt a lot from what ibm did in ibm stick you don't prepend a three hexadecimal you prepend an f one one one one but the principle is the same yeah it's cleanly on that boundary so that's an absolute crucial fact in making bcd to print it out results be fast and efficient you need to be able to put something in there that's low cost because you're going to be doing millions of these bcd to ascii ebstic conversions so that is a very sort of crucial fact to get hold of to try and reduce the conversion burden before printout so in many ways then that's much of the story if you once got it into bcd then both ascii or if it's still on ibm mainframes ebstic do make it easy for you to get into a printable form very quickly and of course the io routines hidden underneath fortran and c will be well aware of this converting from pure binary 101010 to 42 bcd zero one zero zero zero zero one zero they look very different when you get on to telling us how to do it it's not going to be a cheap operation is it because that's the hard bit it's all very well saying getting from bcd to ask his piece of cake but what about getting from binary to bcd and the answer is there's bound to be overheads there and it's bound to be something that you probably want to eliminate and to that effect some people in the commercial computing center say look binary to bcd will turn out to be expensive tell you what if what we do is totally trivial and really isn't rocket science wouldn't we be better off to try and devise software or even hardware assistance circuits to do all the arithmetic on a bcd notation never convert it into pure binary because if all you're doing is adding up how many voters in you know norwalk county or something have voted for such and such you don't need all these huge great binary things that numerical analysts use you're just counting numbers and even if you're looking at somebody's balance in dollars and cents surely that's simple enough arithmetic it's better to perhaps pay a little penalty for doing bcd arithmetic because you can overcome that penalty a bit by having specialized hardware why not do it all in bcd and then you don't have the binary to bcd overhead all you have to do after you've done your bcd arithmetic is slip a four f's on the front end if it's heb stick a three a three hexadecimal if it's asking and that's it prints out there is one classic one well you really can pick up that it's very advantageous to do it in bcd if you think about the number 0.10 which might represent 10 cents shall we say you know your your bank account's been drained down it's down to its last 10 cents so here you've got 0.10 that's 0.1 in decimal what is it in binary oh dear you look at what it is in binary zero point three zeros one one zero zero one one zero zero one one zero zero and it goes on forever there is no exact representation of 0.1 decimal as a binary expansion it just doesn't stop and accountants and actuaries get paranoid about that oh i know it'll never happen but i hate the idea that rounding might go wrong and my client should my client's balance might drop to nine cents instead of ten sets how about some other examples of things that use bcd just to finish off with i don't know if i've got it here i might be able to dig it out of there sean eventually is a little hand calculator what better place to use bcd it's utterly display dominated apart from things like square root that's probably about the most complex thing that you can ask a simple four-function calculator to do but mostly it's addition subtractions simple divides and all that they use bcd another example of simple devices you see in a shopping mall or whatever that could use bcd digital clocks it makes eminent sense to use bcd because it's the display and the change in the display is happening all the time every second but the actual incrementing is trivial you don't need to convert into binary to add one second to a digital display you really don't live with the bcd focus on the display because that's what matters above all else the luckless dawn was faced with these guys holding this black box and i said don we hear via back channels from your users they are not happy with the performance of your machine on the was it called ias their database