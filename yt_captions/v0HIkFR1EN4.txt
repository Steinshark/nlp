I work in the functional programming lab Here in the School of Computer Science   We're interested in finding programming languages and techniques For making it easy to write pretty programs And we believe functional programming is the way to achieve that Functions are quite simple in the way you specify them Because it is easy to put big systems together using small reasonable functions But then the question is, okay,  we talk about functions in the mathematical sense and it's easy to understand how you might write a function to, say, compute the square of two sums or something like that   uhm But, can we also use it to write say interactive applications, or games, or musical applications, that's not too clear then. We have an application here, it's called the arpeggigon, it's patterned after something called the reactogon Which to say is a so called chain reactive performance arpeggiator And this was implemented using functional programming and then more...specifically, a variation of functional programming called reactive functional programming it is tailored for doing this kind of interactive applications ok, so now that's one way in which we can do write games or animations or musical applications in a functional language. BRADY: I'm liking the sounds. Do we need all this equipment to make this work. NILSSON: No it's all sort of midi based. So we can just make ... Connected to a software synthesizer for example. And then everything can be contained in the laptop. But because it is midi based you can also use it as a component of a larger studio setup for example. BRADY: Now I have seen applications like this sort of thing in the music world before. So what's new here I suppose? Why would somebody consider going down this route. NILSSON: Well, the thing is that time is of course central to music, right? And indeed two kinds of time. We have both continuous time and discrete time. So a musical note might start at a very specific point in time. But if it has say a crescendo or accelerando or something that takes place over a period of time gradually changing. And writing an application like this for music, it is a nice to have a language in which you can express aspects about time in a way that really fits the application domain and functional interactive programming supports this kind of what we call hybrid systems both continuous and discrete time aspects okay, in a rather high level way so it's easier to write this kind of applications So the arpeggigon is based on something called the harmonic table The harmonic table is this kind of hexagonal grid musical nodes are placed on this grid on each direction has a specific musical interval so if you go north it's a perfect fifth if you go north east it's a major third and so on and so forth BRADY: Just so people if they are not that musical understand the idea of this is that harmonics and things mean that it'll sound musical, it won't just... NILSSON: Yes, so for example if you play a note and the perfect fifth and a major third we get a major chord which sort of sounds nice together it's very easy to play sounds together it sounds nice if they have this kind of layout BRADY: Can you show us what that would be like on a keyboard? NILSSON: You mean here? Well, a major chord on a keyboard would be something like this, right [synthesizer plays major chord] What's mostly interesting here is that we have this two-dimensional layout So, we can use that to sort of for example implement a kind of pinball game if you like so we can place these tokens or counters on the grid and this, we have a few different ones here, meaning that can do different things so that thing there with the dot that's a start token so when we press play that's going to put the ball on the grid and shoot it off in the direction indicated with the arrow and the other one there is a ricochet token and whenever the ball hits it's going to sort of bounce back in the direction of the arrow And whenever the ball hits the token it's going to play the corresponding notes. If I start this you will see [musical tone] this ball is bouncing back and forth and you get a kind of musical pattern there, right And we can even, if we want to, we can even modify the layouts dynamically, so you could imagine performing with this if you wanted to we could put more start counters onto the grid Now, with a different distance between them and that means if I hit play here we are going to get a more of a polyrhythmic pattern we have gotten two different patterns, two different lengths playing at the same time BRADY: So they go out of sync? NILSSON: Yes, and then in sync again, right. And we can continue playing this game I can place a few more of these ones up here and the last one there And then we press play And that's quite nice, I think at least - depends on your musical taste I suppose but I like it. BRADY: And are all of these guaranteed because of this pattern in this layout to be musical; You couldn't make a cacophony, or could you? NILSSON: I guess "musical" depends on the listener, right? But it is certainly a lot easier to make it musical because you have these specific intervals, absolutely, yes. BRADY: And could people play with this themselves... Yes, this is free software, it is available online, you can download it and play with it. Right now it is a bit rough around the edges, but we are working on it to make it more polished and easy to use. BRADY: Why is it...you mentioned time, let's try and clarify that then Why is it easier to write something like this in your functional reactive programming rather than say, Java or... NILSSON: Right, so the thing is that in functional reactive programming or FRP as we say, we have a number of language constructs that deals with time directly. and in both continuous time and discrete time. So if we have these elements at your disposal, you can express in this case musical ideas much more directly than you could in, say, Java or C. Obviously depending on the specific context sometimes you might want to write a piece of C code or whatever and obviously if you work hard enough in C you can maybe implement this kind of support in C as well, right. But here we have done this for you in that sense. And in a very principle way which makes it fit for a functional programming context. BRADY: Can you see other applications for this, other time-critical things? NILSSON: It's been used for games, for example and the ideas of reactive programming is seeing increased use for banking applications and things and whenever you have this system and they sort of communicate, you can view these communications as signals over time and then you can sort of process them using FRP-like ideas so it's a quite big takeup. Now FRP is not just one system, it's a lot of different systems as it is more of an umbrella term and depending on this; exactly what to do, there are different implementations of FRP that are more or less suitable but the idea as such has really caught traction. Um, and in particalar in a distributed setting it is important that that everything is purely functional because if it is not fully functional then it is very difficult to handle the side effects - but if everything is pure, then every node in this system has a function and they communicate by signals. it is a very good fit for very complex distributed systems BRADY: So is FRP a language or are the languages the...? NILSSON: Um It's a umbrella term for a number of related languages, let's say. BRADY: What's next for this project, then? We would really want to make it into a tool that people can use for example in a large studio setting like this Because we think actually this is the only software implementation of of the reactagon that we are aware of and if people like to compose music in this particular way I think it could be a quite nice application, ignoring how it is written, just for an end user to use. BRADY: What, you did mention this rectagon, I mean what is that, how does that look normally, is that a piece of hardware or..? NILSSON: It is a piece of hardware, yes, you can google "Rectagon" You'll find it on Youtube and see this big, impressive table with lots of hardware on it. And you can... there are these physical things you can place on all over the board and interact with it. That's very cool but this is easier to use, obviously. > Right, we've done B we can count that as done. So, C next right, so we are here we can't go to S we can only go to L, that's a nice, easy one so I need to find L so L goes to C and it's three plus two, it's five so L comes in just underneath A, like this.