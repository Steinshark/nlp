let's get started um so I'm going to talk to you about core routines um this is me you can find me in various places on the web um I am one of the co-organizers of Munich C plus plus User Group which is one of the biggest user groups in the world since the pandemic we have been meeting a virtual which means also for people who are not in Munich feel free to attend one of our events if you want to give a talk practice a talk give a lightning talk please reach out to us we're always happy to welcome your faces in my day job I'm currently working as a runtime engineer for woven Planet which is the software spin-off for from Toyota um and the topic today is going to be core routines um and if you looked at core routines already in the shape that they were shipped in C plus 20 you will probably have noticed that they're quite hard um so on the one hand they allow for extremely complex transformations of control flow which makes them very powerful but they do so through an uh Arcane syntax that changes some of the fundamental rules of the language which like gives a the correcting code a very weird feeling um they're quite hard to understand but what makes matters worse is that if you don't use them on a day-to-day basis then it's also quite difficult to remember how they work if you come back to them after a long time um so it's it's very hard to learn them in a way that they stick right and one of the goals of this talk is to to help with that problem a little bit so um in particular I I want to provide like certain like guides and cues that help you to remember them more easily so like if uh like mnemonics if if you want to think of them that way um the feature is too big and too complex to introduce all of it in one talk so this talk is only only focusing on the the syntax side so like what is the the core language mechanism that is provided in C plus plus 20 that you would want to use when you want to implement your own core routines um this is very different from the user side if you just want to use core routines as they are provided by a library then you actually don't need to care about most of this so this is really about like the guts of the language features which also means like we have to look at all the really complicated Parts but don't get scared away by this if um if it's it's too much to take in if you just want the user's perspective then like most of this actually doesn't matter um but we are here to um yeah look at all the technical details um so what are we going to do today um we're going to you have a very quick look at the essential use cases for core routines why we want them in the in the standard um then we're going to uh examine them like from a caller's perspective like how a user of a library would would interact with them for example are we going to look at all the steps that are necessary to start up a new co-working we're going to then look at suspend and resume which is the the core feature of core routines um and then we're going to try to draw a map of coroutine land that will help us to to navigate all of the complexities of the of the features um and thereby get an idea for how we can interact with core routines in our code um so a short disclaimer up front um as I mentioned the feature itself is extremely powerful and flexible and it's very hard to squeeze all of that in a one into a one hour talk so I'm going to simplify things in places I'm going to ignore some of the more advanced features um just to like keep explanations streamlined and all of the code that you're going to see is slide code it's going to be very reduced so please don't take this as best practices for writing core routines code it's just meant to illustrate like certain points but it's mostly not something that you would write in in real world code so with that uh let's take a look at the at the basics so um the the bearish essentials are that uh coroutines is something that you can think of like a function that can be paused in the middle right so you're executing up to a certain point and then you said now I press the pause button uh the function stops executing control flow returns to the caller of the function um and now other stuff happens and at some point later then um you can resume uh the execution of the core routine and the function will just continue executing right at the point where you resume where you suspended it earlier um and all of the surrounding state will still be intact so that's that's the core features right like all of the local variables that you had on the stack uh for the function when you resume they will be exactly in the in the state where you left them um a consequence of this is that the core routines always have to be stateful necessarily right because all of this local state needs to be saved somewhere when you go into suspension um so if you think of like when when you when you call a co-routine for the first time don't think of it like a function call uh but think of it like a factory function that creates this state right um and then like the actual execution is is something that might be triggered in in various ways afterwards um but really like when you see a co-routine call um really think of that like like a factory function and we will uh we will see an example for that very soon um lastly the core routines that we have in C plus plus 20 are stackless coroutines that means whenever I suspend a core routine control flow always returns to the immediate caller um consequence of that is um that I cannot suspend from something that is not itself Authority um and I cannot I cannot suspend through a normal function right like if you think for example you're um you're calling an algorithm and then you pass a predicate to to the algorithm and you want to suspend like from the predicate through the algorithm back to the caller they won't work because the algorithm itself is is not a core routine um coroutines in other languages don't have this limitation but in in C plus plus we have this so let's look at some example code um so one of the most important use cases for core routines is asynchronous computation and the example for that is like if if you used azio you've probably seen stuff like this um so you want to read some data from a socket this is an operation that might take a long time to complete right the easiest way to do this is just to call the blocking read function right that will just block for some time and eventually you get the results back like an error code and the the number of bytes read which were which were filled into the buffer um so since this is a blocking call um it's not very nice it doesn't scale very well so um you usually want to use an asynchronous API for this in in most in like real world applications however the asynchronous call looks very different from the blocking call right now instead of getting the return values back I have to pass a callback as an argument with a function um and what now happens is that when the read completes this callback gets invoked um and what was before the return values the error code and the number of bytes read is now passed as arguments to this callback and if you ever worked with with an API like this you will notice that like this creates a weird inversion of control flow that um makes it quite difficult to interact with this API especially if you're not used to working with that if you write a lot of code like this eventually you get used to it but there's a barrier of entry and there's an additional complexity in particular if you think like this this read call happens inside a complex function that is doing lots of other things before and after the problem is when you actually wake up inside the Callback all of the surrounding context from the function that you had before is gone right so you need to manually transfer all of that into the Callback to be able to do whatever you want to do when the read completes um and that's that's where the complexity comes from so what core routines allow you to do is they transform the second call so that it basically looks like the blocking case um so you now do an async read and you call Co await on this and the control flow will be the the same as before right so with with the async read you will actually you will stop executing the function at that point and you will be woken up like the same as with the Callback when the when the read completes but because it's a core routine now all of the surrounding state is still intact so the code looks pretty much exactly the same as it did in the in the blocking case which is much easier to to reason about um then there's there's a second use case which you see often and that is um uh suspended execution to um think of like some computation you you want to start the computation and then at some point you you want to say okay I'm going to stop and you need to provide me more data before I continue execution right and so the the user like continually provides data and the function always like executes some small step it might return some partial results um but like it moves forward in in like individual steps um the simplest case of this is uh a generator function which like uh simply like generates values when whenever you call it that you can then iterate over and we will see an example for that right now um because like the first example that we're going to look at is think you want to write a generator that just generates a sequence of numbers right let's say um I chose here as an example of the Fibonacci numbers I just want a function that generates me this sequence right so if you get if you're presented with this problem the first thing that you might come up with is probably an interface like this um so I just specify as an argument how long like how many numbers I want to generate and I give you back a vector with all of the numbers of the series so if you think about this for a minute you can probably see some disadvantages of this interface um so one thing that you might notice is um this actually requires um requires you to allocate all of the storage for the series up front right so if you generate n numbers you need like um storage for n integers um and in some cases that's okay but in many cases when you process a range like this you process them element by element and you don't need to save all of the range at once right it's enough if you like get the individual numbers to process it um so yeah having to allocate all that storage up front is potentially wasteful um another limitation is that this only works if you if you know you're n up front right you can't just say okay like let's just keep generating Pretend This is an infinite range um and then at some point I'm going to I'm going to stop generating more but I don't know when right this is this is quite difficult to do with an interface like this so how how could we address these problems what would be a better design um so one thing that that you could do is you just say Okay instead of um like returning the range saved in a vector I'm going to give you a generator object which is able to do to give you all these numbers so um I'm going to give you back an object this object has a next function and whenever you call next you get the next number in the sequence as a return value from this object right um and this is something that um that you can write right like if I gave you an interface like this and and said like please implement this in C plus plus 11 or even 98 you could do this right so um is is makeshible generator is that actually co-routine and it doesn't have to be right the answer to that is maybe it could be a core routine but it doesn't have to um and that's an important thing to um to realize like core routines don't allow you to implement something that you couldn't Implement before um they just make it easier right so um it doesn't increase like the um the the expressive power of the language um it just makes it easier to express some things and also makes it more efficient in some cases so the only thing that we see here um at this point like from the user's perspective is the the interface of of the co-working right and uh we don't actually know whether it is implemented in terms of core routine or in in terms of normal function code um so if we just look at the signature um the most important thing that we that we get back is this this return object from the function and it's it's type its interface determines how we interact with the underlying correcting um so that is the first the first thing that that we're going to look at now um so I said in the beginning think of a core routine call like uh like a factory function at the return type that is what your factory function produces um and like conceptually what this contains is the state of your core routine right so we said the core routines are always stateful they like contain whatever state the function has um when it's suspended and the factory function is what what creates that state um and the interface of this return type determines how you can interact with the core routine right like how you can resume it what data it gives you back and you don't need to understand anything about the implementation if you understand this the the interface of the return type that's enough that for for you as a user of this function to know and you don't need to know anything about core routines um and there's actually no way to tell from the outside whether it really is a core routine um and the important thing is the return type is is just it's just a Class Type like any other right and we can do whatever we can do in normal classes we decide what the interface is as the implementers of the core routine so we cannot tell from the signature whether function is a core routine then what actually does determine whether it's a core routine or not so the answer to that is quite simple it's a core routine if the body of the function contains one of these three keywords that's the rule right if a compiler sees one of these three key words in the body it says okay now it's a core routine and all of the chlorotine rules apply and that actually has quite drastic impact on the on the rules for what what can happen in this in this function uh just as a simple example you cannot use the return keyword inside the body of a core routine that will not compile you have to use the co-return everywhere um so let's look at a very simple example on let's say I I want to implement my Fibonacci function as a core routine um and this is what what that would look like so we have the co-yield keyword in there um which makes it a cover routine um but otherwise like this looks actually like if you like mentally think of like the very first version that we had that just filled the vector it would actually look pretty much like this right the only difference is that instead of the cold yield we would do a push back into our result Vector but the overall control flow is exactly the same um and that's that's very much by Design right because like the the feeling of the vector that's that's the most simple most straightforward way uh to generate this series and the um the core routines allow us to um to use that that simple control flow um so we still don't really understand how this works right like uh the core yield is there but everything else makes no real sense like for example this this fibo generator return value here where's that generated right you don't see a feeble generator anywhere inside the body um so for the rest of this talk we will actually try to understand what's going on here what's going on under the hood um and how we can write a function like this ourselves so let's take a step back and let's try to write the simplest smallest core routine that we can think of so this is the simplest one that I could think of it's basically empty I need to put like one of the three keywords in there so that is not a function but the core routine so I just use an empty core return right that's all I do so this doesn't compile because I didn't Define my return type yet so that's that's the next step um so again let's try to do the simplest possible thing let's try just an empty type right um and now the compiler is going to complain um it's going to complain that it cannot find the nested promise type for this return type okay let's let's try to make the compiler happy um just put it as as an asset struct in there um and this now actually gives us the second important player in the in the core routine mechanism and that's this promise type so what is This Promise type why why do we need this um so if you hear the name promise type you might think of a future promise from the threat Library um and the quarantine promises work somewhat similar they're it's different but like as a very rough analogy in in future promises the future is the thing that you give back to the caller the promise is the thing that you keep inside the threat where you actually like put the values like it's the the future is the one side of the communication right that you give back to the caller the promise is the other side that you retain inside the thread and it's kind of similar here right you have the return object that you give to the call of the co-routine and the promise type is the thing that remains like within the core routine um so the the other end of the communication Channel but don't take this analogy too literally right because apart from this the core team promise looks completely different [Music] um so in particular one of the responsibilities of the promise typing core routines is that it determines what happens at essential points in the quarantine lifetime so it allows you to customize uh what happens on starting completion of the execution of the core routine and it also allows you to customize what happens when you exit the core routine through a co-return or through an exception um so let's try to implement a simple promise type um if we try to compile the code as before with an empty promise type we again will get a bunch of compiler errors that it's missing a bunch of functions inside the promise type um particular the first thing that it wants is a function called get return object and this now resolves the mystery where the um the actual return object that our Factory function returns to the caller comes from uh because what will happen is the compiler will magically behind the scenes call this get return object function on the core routine store the the object generated here in a special place and then when the core routine suspends for the first time and control flow is returned to the caller it will hand out the object that was created here to the caller right so that's why we didn't see the construction of the return object in our make sibo generator function before because it actually happens here inside the promise um the second thing that we need to provide is a handle for um how to treat the return value in this type I just in this case I just had an empty call return statement so I need to provide the return void function um if I actually return a value in in my code return then I need to provide the return underscore value function here in this case I'm just not going to do anything with the return value so I'll leave this empty um I also need to give an implementation for unhandled exception like if I exit the function the core routine why an exception then this is the the customization Point that's being called again I'm not going to do anything here um and then I'm going to provide two functions uh which are kind of curious initial suspend and final suspend and they allow me to customize what happens so with the initial suspend that is like right after the core routine was constructed do I want to suspend or like what should happen on on this initial suspend and for the final suspend like what should I do uh if I reach a co-return and the correct or the core routine flows of the end of the function so it's like I reached the end of the core routine right these are the two um points here and like the other three functions that's pretty straightforward what they do but like these two are now again a bit mysterious um they have like these these weird special return values uh suspend always or suspend never it's what you typically find there um but we don't really understand how that works so um yeah those are a bit mysterious for now um but if we get to this point then our code actually compiles and we can try play around with it and what we see is if we have the initial suspend returns to spend always then what happens is when I when I call my core routine so I now added a print statement to like make the control flow visible and if I now call this then I don't actually see anything printed to the console right so the core routine starts but it's suspended immediately so I never actually reached the print statement it never executes um but if I change the return value from the initial suspend from suspend always to suspend never um then I actually do see the print statement right so then the quarantine doesn't it doesn't suspend it doesn't pass at the beginning but it it it it continues execution into the body of the function um so this is already something that that we see now is that like through these through the return value of this initial suspend function we can like we can push the pause button right we can we can suspend the execution of the co-work team so let's try to understand what what is actually happening there what's going on there and for that we have to introduce like the last major um component of the mechanism and that's the awaitable so what's an awaitable um the the simplest way to think about it and the way that I like to think about it is the awaitable is something that you can call Co weight on okay if you think like call weight is like an operator and the argument of that operator has to be an awaitable type okay so like anything that you can call wait on that's inevitable and we will see shortly what the requirements are that make a type a valid awaitable um conceptually every call to call weight is an opportunity for suspension that means Whenever I Call weight the awaitable decides whether the core routine is suspended or not so it can also like if the waitable decides so then the coroutine can just continue executing doesn't go into suspension but it's an opportunity for suspension right so if I want then that's where I press the pause button and return control flow to to my caller um the weightable allows us to inject code that determine that is executed before we suspend and after we resume similar to how the the promise type allowed us to customize what happens when the core routine starts or or Returns the available allows us to inject code for suspend and resume so let's try to do the same thing as before um let's try to implement the simplest possible awaitable if we start with an empty type it will complain that it's missing three functions um the first one that I need to implement is a weight ready so wait ready is called by the compiler to determine whether I actually want to suspend at this point so if a weight ready says um no I'm ready so it it returns true then that means we don't go into suspension right we're ready to continue execution right away and then we just go on like if you think for example um if you do asynchronous IO right you might already have the data in the in the local buffer so you don't you don't need to go to sleep right you can just continue execution so in that case a weight ready would just tell you would just return true and you don't suspend if it returns false then we actually trigger the suspension mechanism and then the next thing that's getting called is a weight suspend weight suspense gets passed as an argument this co-routine handle that we didn't see before um and this is basically this this is the code that gets executed right before right before we go to sleep right before the quarantine uh goes into suspension so this is where we need to set up all of the stuff that we still need to take care of before we are being paused the chlorotine handle um the easiest way to think about it is um so we said so the coroutine function is like a factory function that generates this carotene State somewhere um this carotene state is created by the compiler automatically in some magical place right like the the um the promise type for example that's not something that we as the user create the compiler creates that force behind the scenes and stores that away similar to like all the state inside the co-routine body that that all gets created initial uh implicitly the quarantine handle is like a pointer to that state right that's that's that's how you can think about it um and the important point is it's not a smart pointer right there's no raii semantics here it's just a pointer that that's the simplest mental model for this uh and we will look at what you can do with it uh in a moment um then the last function that is missing on the awaitable is oh yeah one more thing um the quarantine handle we had it here with the empty template brackets you can also have that specialized on the promise type that we saw and this is this is the promise type that that we had earlier also um and then like the counterpart with your weight suspend is the way it resume that gets executed like so our core routine is in a past State the caller now does other stuff in the meantime and eventually we want to resume execution of the core routine and immediately before the core routine wakes up and continuous where it left off before um it calls a way to resume and we can like bring it back to a state where it can continue execution so those are the three of the three functions on the awaitable um and the easiest way to implement this is to just say like on the await ready I'm just going to return false so I'm never ready I always want to suspend and I just leave the other two empty um and if I do it like this then this is actually the suspend always that we saw before so STD suspend always is that's the implementation for it um and you can probably guess what suspense never will look like it's exactly the same except the the return value is true there right we're always ready we're never going to suspend so now the um the only thing that we need to look at we're almost through it no this is a lot of stuff but we've we've seen all almost all of the stuff I just want to quickly take a look inside the core routine handle what is in there um so the co-routine Handler has an interface in particular it provides a resume member function and that is the that is the the thing that I need to call if I want to wake up the core routine again right I can suspend it by calling call weight inside the core routine that's what puts it to sleep uh but then if the caller wants to wake it up again it needs to call resume on the core routine handle um the other important function that we have here is uh the destroy member function and that allows us to um to destroy the core routine so in particular if the carotene is suspended at any point I can always call the destroy function on the core routine handle to like safely shut it down and this this cleanly shuts it down right this is it frees all the resources because of the destruct calls all the destructors so this this does what you would expect but you have to call it manually right it's not a smart pointer it's a raw pointer so you have to decide what you call destroy or whether you call it at all right because if the core routine just runs to completion control flow just flows off the end and uh you don't suspend on the um on the final suspend then it cleans up itself you in 90 of the cases you don't want to do this but it's it's a possibility um and then the other two functions that we have here are just conversion functions that allow us to convert the core routine handle uh to the promise type or a static function to uh construct the core routine handle from a promise and those last two only work if we use the version of the core routine handle that is specialized on the promise type right so in in some cases it's it's just enough to know like I I have some core routine handle and I just want to resume or destroy it then you can just store the the unspecialized co routine handle right especially if you have like a generic list of like many core routine handles um but if you want to interact with it in in some more involved way then you usually have to um call these uh these promise conversion functions at one point and then you actually need to know the promise type so that was a lot of stuff so um let's let's let's start by writing a little cheat sheet of what we have so far and the way that we that we read this is um if we read this from from top to bottom then it actually takes us through all the different steps that the compiler goes through in the execution of a core routine and whenever we we see a slash on the line that that means like we have the option to either take the one or the other so like in the beginning as we've seen we need to uh we need to specify the return type for our like Factory function core routine function um and that can either be like directly the struct of the return type as we saw in the example or you can also specify this through a core routine traits function and that is useful if in particular if you deal with return values with return types that were not designed with core routines right like you can't have a core routine that just returns an INT or even return returns void and you can make that work if you um like customize it through the core routine traits but mostly you want to use the return type then the return type um through its its nested type Dev points out the promise type the promise type gets constructed implicitly by the compiler on the first call to the core routine and one neat feature here is if we provide a Constructor on the promise type with a signature that matches the signature of the core routine function then we get past the arguments that were passed to the initial call of the core routine also here to the promise Constructor but this is purely optional then the next step is that the promise get return object function gets called to create the return object um and then the initial suspend function is called to determine whether like the core routine should suspend right away uh or whether it should continue execution and that's that's the entire startup um and then when the core routine actually finishes execution we go through the the shutdown steps so first depending on what kind of core return we have we either need to have a return value function that gets passed the return value that was given to co-return as an argument or we have the return void function uh we need to give the unandled exception in case that we accept the core routine for an exception and then lastly the final suspend is called just before the core routine ends execution um and then we also have the awaitable with the three functions the weight radio weight suspend the weight resume and hopefully like now just from seeing the names you can still remember what those do and those are all of the key components um this is a lot to take in so if you're feeling overwhelmed that's that's completely normal but you're now through the worst right now you've seen everything once and the only thing that we now need to figure out is how they connect what what is the interaction between the two but if you understand like the the roles of the individual things right so the return type that is what is given back to the caller that's the interface to the core routine that determines what we can do with it the promise type that is like the the thing that remains within the core routine um and that customizes all of the actions on on start and and shutdown and the awaitable is the the thing that that you pass to the call weight call so this determines what happens when you when you try to suspend the quarity right so these these key roles you should keep in mind and then yeah the quarantine handle is just a pointer to to the state and now we can actually talk about uh resuming core routines right so we saw before with with the simple example where we we had the the initial suspend how we can put the core routine to sleep but now we want to wake it up again so let's go back to our example from before right I have my hello from core routine if if I just call the hello core routine it goes into suspension right away I don't see the print on the console now what I want to do is I want to resume it again so I need to provide on the interface of the return type some way to resume it again and we already saw that the only way to resume a core routine is to actually call the resume function on the core routine handle so what we need to figure out now really is how can we get from the return type to the core routine handle because like what we have so far is like we have all of these things but they're all disconnected right so the caller has access to the return time right because that's that's what we hand out that's that's what he gets back from the factory function similarly the core routine has access to the weightable because like the core routine calls the call weight and the awaitable that's the object that that we handed there and we can get from the promise to the core routine handle and vice versa via this conversion functions but other than that this this is all a disconnected mess so let's try to to make some acquaintances now so the first thing that we see is if we remember on the promise type we had this get return object function right that creates the return object that we had back and you can see already on the colors here we have like two components that are disconnected so far and we have them both in the same place so what we can do is like get a return object that's just a function right we can do everything in there that we do in the normal function and I'm just going to say okay when I construct my return type I will just pass it the correcting handle as a parameter to the Constructor and then inside the return type at the bottom I just I have the Constructor that gets the the core routine handle as an argument and I just store it inside the member variable right this is just there's nothing magical here this is just like how normal classes work right um and now since I have the core routine handling a member variable implementing the resume function that the caller has to call to wake up the core routine is really easy because it will just call the resume function on the handle and again in 99 of the cases this is how you want to do this um so in particular if you're suspending on the initial suspend you need to store away the core routine handle somewhere so you either give it to some external entity like a a core routine manager a threat pulley thing scheduler whatever or you give it back to the return type if you do either of these these things you just created a core routine that you can never access again right because it goes into suspension and then it's over right you need to get the core routine handle to a place before that and this is the typical pattern this is how you usually want to do it you just give it to the return type and then the the user has access to it through the return object whenever it wants so that gives us our first connection here right so the caller can use the the handle that is stored in the return type to get to the core routine handle of the promise what is still missing now is the um the core routine and the awaitable they're still disconnected so what can we do there um and the um the connection Point here is the await suspended function because if we remember back that gets past the core routine handle to the function that we're about to suspend as an argument so again also here through the await suspend function we can get to the core routine handle and to the promise and now we have all of the parts connected right so the get return object that's the initial con connection between the promise and the return type and then uh through the handle member and the await suspend function it's all connected and now let's let's actually try to to implement some simple core routine logic using this really two essential things that you need to be able to do and if you understand how those works then you basically have all the basics in place to to do core routines um and this is how do you pass data from a core routine to the to the caller to the to the function that that you suspend to and the other way around how do you pass data from the outside into a core routine when you resume if you can do those two things then all of the other stuff you you can uh you can basically do yourself so let's let's look at those essential examples so first the direction how can I get how can I pass data from the core routine back to the caller so start in the core routine right um and I'm calling call weight so I somehow need to pass the data to the awaitable how do I do this um so in this case the core routine it just does a cold weight and the value that I want to return you see the integer 42. the only thing that I can do at this point is pass it to the construct of the awaitable right that's the only thing that that I can do at this point um so let's do this like we pass 42 to the Constructor and we just store it inside the member variable of the awaitable so now the the data is in the green awaitable but the caller cannot get to the awaitable right so I need to store it further down inside the promise and the way that I do that is on the await suspend function that's when the awaitable gets access to the promise um so here I use the core routine handle to get to the promise and then store the value inside a member variable of the promise object so I'll pass the data all the way down here to the promise now I need to get it back to the caller so the past from the caller is it has to go through the return type to the handle and that's how it can reach the promise so this is how the uh the the bottom is how the code would look like uh for the for the caller right I I call the core routine and when it when it suspends then I know the value has been stored and I use the get answer member function on the return type to get it back and the implementation for get answer is just I go from the handle to the promise and the promise has the value as a member function that's where we stored it before and that's the complete path and like with this picture I hope that this is something that that you can work out right that that helps you remember what what the control flow looks like here so let's now take a look at the other way um I want to get data into a core routine from uh from the outside so here I have to start on the caller side um again like the the common point of interaction is the promise that that's always where we need to get to so um for the caller it would look something like this um so I have a cover team at some point the core routine suspense um it cannot continue execution until are provided with more data so in this case I provided with more data again the number of 42 as an example um and now the when I call Provide it it stores this value it resumes the code routine um and when the core routine continues execution so at the top you see the call weight call that's that's where we go to sleep right that's that's the point where the core routine said I I need more data I want to go into suspension here and now when when provide resumes the execution then the code the call weight wakes up and the return value of the call weight operator that is now going to be the the the 42 right so when I resume execution then the um the answer variable inside the core routine will contain this value 42 that the caller passed in so how can we do this um we saw in the diagram that we need to go through again through the handle on the return object to the promise so that's pretty straightforward right so this is this is the implementation of the provide function again I just call like the the promise function on the handle go to uh uh the member variable that I created inside the promise and just store the value there and then I call resume so that the core routine actually wakes up and can do something with this value I don't have to do this here I could also like decouple it have one function that just stores the value and have another that resumes it but like this this is the typical pattern that you find that it happens in in the same function so again now the value lives in the promise so how can we get to it from the other side so the quarantine again has to go through the awaitable um so the the only place where how the awaitable can get to the promises on the await to spend right but the await suspend is is is only part of the picture right because when we call the weight suspend that is before the caller provided the data right that's when the core routine goes to sleep so I cannot actually do anything at this point except store the handle that that I get passed as an argument away some somewhere right and now the caller needs to needs to do its thing needs to provide me with the data and only when a weight resume gets called then I can actually retrieve the value from the promise um and what happens here the the part that we did not talk about is that now the return value of the await resume is also going to be the return value that falls out of the core weight call that the core routine did earlier so this is one missing Arrow here right the the return value of the weight resume that is how we hand the data back to the core routine so let's go back to our example from uh from the beginning again um so here we had like the Fibonacci generator and we wanted to we we can now just say we do the the call weight and we have this available new number available and that's how we hand the data in and then we do the whole dance that we saw before like forgetting the data out of the core routine we can do all that but this is a lot of boilerplate that we have to write for a very common pattern um and that's why we get a shortcut in the language for this um and if you remember back to the to the example what we actually used there was this co-yield keyword um and called yield is really just syntactic sugar right like if you understand cold weight you can already do everything with cold yield it's just a little bit easier um in particular the only thing that that co-yield really does is um so if you think of this code right what you need to do here is you need to specify the awaitable right you need to say this is the weightable that actually handles the whole mechanism and with co-yield you just you just say this is the value that I want to give out and the only thing that called yield does is the compiler goes to the promise type and it looks for a yield value function and that yield value function now tells you what the available is that is going to that is going to handle the mechanism um so it's like you can always transform this back to this in your head very very simply by by looking at what what the yield value function does so it's yeah it's really just a shortcut um for um for a cold weight call but it's a significant shortcut because you might notice um the yield value function now is on the promise type right before we always had the thing we call Core weight on the awaitable type but now we're calling yield value on the promise type so that gives us a shortcut right I can just now store the value right away in my member variable because I'm already in a member function for the promise and I don't need a complicated waitable at all right I just say suspend always and it works so that's that's the true power of of code yield that it gives me a shortcut from from the core routine right to the promise and and I don't have to in most cases I don't even have to write a customer waitable to make this work there's one last thing that I want to talk about and that's a really cool feature called symmetric transfer um normally with core routines when we go into suspension it's always we give control back to the caller right so in in the in the case of the initial call um whoever like called the the factory function did the initial call to the core routine that's who I return the control back to in case of suspension we have a call resume that's the one we're hand control back to um in some cases what I want to do though is not hand the control back to the caller but hand the control to another core routine so in particular if you think about use cases like Cooperative multitasking right then I just like I have a bunch of tasks they're all executing and they just want to hand control flow to each other um and this is something that you can do with symmetric transfer and the way that this works is um on the weight suspend function so before the await suspense function always return void in our examples If instead of returning a void I return a call routine handle then that means I want to do a symmetric transfer to that core routine right so the correcting handle points to a suspended core routine and now the await suspend function will actually like it will swap out the core routine frames right like the currently running cover team will go to sleep uh it will like free up the stack and then the new core routine will start executing in its place um and what makes this a bit confusing is that we now have two core routine handles on the same interface so the one that we have uh as a function argument the one on the bottom that is the core routine that is going to sleep that is the core routine that's about to be suspended and the one that is being returned that's the core routine that I want to transfer control to um so one possible implementation that I could do is say like if the promise has a handle to another core routine that then I will just wake up that one if it doesn't then I will just return myself back so I can do more work right if somebody else wants to do work I hand control off to them if there's nobody else I just continue execution so that's that's a simple example for this all right so this this was the whole mechanism this this is all the syntax that you need if you understood all the examples um and you probably haven't understood them all from the talk but I hope that this gives you enough material to now start sitting down and start playing around with them um these are all the basic principles you can construct everything else pretty much from from Justice um learning the syntax is the boring part here right this this is this is not exciting but this is also the easy part understanding how to now use them efficiently and effectively that is much more difficult but it's also more fun um so I hope now if if you um visit an advanced core routine talk at another conference maybe um then this will help you to like understand this better and actually enjoy the fun Parts about it um designing libraries around asynchronous control flow is a very deep topic um and I hope that we will see many talks in the future that actually focus on this and don't have to get stuck up on on all the technicalities that we talked about today um phonologists hope that like this cheat sheet that we created will will help you like navigate this uh this part of the language a little bit easier in the future so um again like for the return time and the promise type just read it from top to bottom and hopefully like you can remember what what is actually happening there in the different phases for the weightable like I think the the three member functions are mostly self-explainable um and then this which I think is the the real money maker that allows you to understand how it's all connected and how you can pass data between the different components um some references for you and if you want to have like all of these diagrams on a single A4 page this is a QR code to uh um to a PDF that contains this um yeah with that we have a little time left for questions and thank you very much [Applause] Hannah please yeah yeah I have a question uh is the way how to provide a allocator to coroutine which will be consulted on the allocator right um yeah so the yeah so the thing with the allocators is like we I I mentioned this briefly that the compiler has to create all of the like the promise type and all of the state in like some magical place and usually that means it has to do a hip allocation right and if you're in in an environment where it's not when you can just call Operator new you might want to use an allocator for this um the way that you do this currently is that you have to overload operator new that is the customization Point Um this can be a bit tricky to get right so um but in principle it works so you can make it work but it's yeah if you've never used allocators before you're in for a treat but um yeah I've I've tried it and it works in principle other questions oh yeah one more please yeah thanks for the talk um so many of us have probably used azio and if we go back to one of your first slides yeah you compare the call blocking read and yeah I read with code wait yeah this is what I want people to use yeah just swap out the Callback and the Callback hell that comes with Asia with cool weights basically but then you've got this one-hour talk that is very dense explaining all of the details of coroutines and how they work how much do you think we can omit the part where we teach people how core routines work yeah we just teach them well effectively swap out your callback just use color weight yeah yeah don't worry too much about the implementation it's complicated but don't look too much in the Box yeah if you already have a library like and Asia is probably the best example for that at the moment that provides these Primitives then you don't need to know any of this right you can completely ignore this talk and that that's the good that's the good message the bad message is that at the moment we don't have a lot of libraries with this and in particular we have no support in the standard library for for any of this like we're going to get generators now with C plus plus 23 but generators are by far the easiest of this so for now if you want to play around with this usually you have to go to this level um but eventually like if you have a library that that like does something useful like azio and supports core routines you don't need to know this at all right you just look at the interface of the return objects that you get back and then you know all all that you need to know with Asia it's a little bit more because you want to call weight yourself on on the on the calls so you need to understand a little bit about what core weight does but you don't need to write your own promises or your own on a way to build you you spared by that yeah yeah the Asia examples are actually pretty awesome so if if you want to play around with this in a real world context look at Asia's documentation it's it's really great about you oh oh the mic is off did we run over time or they won't no did you just want you to say that I will I will try to repeat the question so uh the the question is whether you can quarantines across threats and I guess like in particular whether you can suspend on one thread and resume one another yeah that that works perfectly well I mean you need to take care of like all the the obvious like fretting fretting concerns that like you don't introduce races and you don't do something on the resuming threat that that is not safe for some reason but in principle yeah you can just take the return object pass it off to another thread and that that will work yeah no restrictions there and then like one last question before we wrap up what is the actual cost of using core routines are the what the cost the cost um that's a good question um so their the the nice thing about the C plus plus 20 core routines is that they allow very um aggressive optimization by the compiler um in particular if if the compiler can like steadily verify certain properties of of core routines um it can make them Disappear Completely uh it can even like uh omit the memory allocation and all of that um but it depends on on the use case what what what you want to do them with them right so the more complex like your logic is surrounding core routines that the more costly they they get um but the most expensive part is is really the creation of the state right the Hebrew allocation that you have to do there that that is actually the expensive part the suspension and resuming um that is quite easy to do right because you just I mean all of the objects are already in the correct place and now you just move around the instruction pointer right so it's really not more expensive than a function call uh in in that sense and that's that's actually one of the one of the good parts of the C plus plus core routines that they're extremely efficient especially compared to coroutine implementations in some other languages thanks Caleb and with that we're on time so thank you very much and have a nice day [Applause]