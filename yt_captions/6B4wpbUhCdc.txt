so welcome to my talk I will give you a deep dive behind the curtain of standard function so let's start with some words about me so in case you cannot compare that's me I'm Andreas and on the internet you can find me as our mind everywhere on GitHub Twitter and so on feel free to contact me I give online presentations trainings on-site trainings about C plus QT clean code is one of my favorite topics so you can also hire our company we will help you write software projects and on the other hand we are also always hiring so if you have interest in doing deep level C plus plus a lot of Open Source projects then you overcome yeah so that's what I said work for us just a disclaimer in the beginning like almost everyone even though I give lectures I'm also just learning nobody is considered an expert in C plus plus it's just moving too fast and so let's go then before we start with the Deep dive we should level everybody up get on the same page so start way on your surface and then we go deep really deep I hope so goal is that everybody even an expert should learn something here so let's start with a simple C plus plus function I hope everybody agrees that's the simplest C plus function we can write no return type just the name and first thing I want to mention here is the training return type comes from the Lambda syntax and in all my trainings I find there are some developers who don't know it and those functions are equivalent so the same return type does nothing magically here just the return type is on the right side and not in the beginning so next thing function signatures are types in C plus and for example if you write this that's a type Alias called void function which is just another name for the type of the function signature of the Void function returning nothing and the trading return type of course also works here so you can write it the same so no matter how we write our functions if we leave out a function name and the implementation of course then we get a signature and the signature is a type just like a normal type but it's not like your regular int or something because what's the size of our type unit anybody knows no it's not does not depend there is no type no size so and it's like white white also has no size end up yeah and the function itself the signature that this type has no size like void and like void the only useful thing we can do with that is create a pointer from that so that's the next thing so we can create a pointer and then of course we want to use it and white pointer has nothing to do but our function type has a thing to do you can call the function so first we can declare variables when we say okay our normal function just just avoid function can be assigned so we take the reference the address of the function and assign it to our pointer and then we can call it just like that so any questions so far was clear for everyone so next step the function pointer of a function is always contextual so it doesn't matter if the function itself is contextual that means the function is executable at compile time but the pointer to the function is always contextable you can always write this the interesting twist about it is how does a compiler know at compile time which address the function has I kind of null in modern operating systems the address of the function is only known as runtime because we have address randomizations so the function is loaded anywhere in the ram we cannot know before but how can the compiler pretend to know it yeah it just does that it pretends to know it there is no address that's also why we cannot in in extra context access the actual addresses the the compiler does not allow it we cannot print it or convert it to a number or something because the compiler doesn't know it doesn't know where the variables live and there also doesn't know where the functions live so but it pretends to know it and tries to keep that illusion alive okay and the concept extra function pointer can also be called so yeah let's summarize it up so function signatures or types that's the fifth Point second we can store point of the functions and it's the only thing we can store form functions and function pointers are known at compile time so far all basic C plus I hope any questions great then let's continue the first question is always why would you use standard function anyways what's the reason and I want to use this opportunity to also introduce you constructs we use later to implement the standard function and let's start with a good example where would you use standard function and the first thing would be like in a callback so we have for example a button the user clicks the button and we want to trigger some action but the button class doesn't know which action you want to introduce so you can give a button different label like okay or cancel and then you want to do different stuff depending also on the dialog for what's happening so how do we do that so first thing we just learned function pointers let's try that function pointers so some code I won't show you all the button details only the important parts for us so we have a button and this button has to somehow call back something so we can call function pointers so let's install a function pointer and then let's try to use it and write a edit dialog and the edit dialog has an okay button and a cancel button and yeah we have two functions in the dialog one who should handle the okay case and one for the cancel case but how can we get this cold these are member functions here and so we have to know which dialog the function has to be called in so the button only has one pointer I cannot just call the function not a member function that's won't work so next challenge then is you have to somehow call the instance method of the dialog instead of just the global method or Global function and we say okay we only know normal C plus plus then the only thing we can do about it is to have a white pointer because we don't know which dialog is implementing the button or is using the button could be just file dialogue could be a different dialogue should be print dialog for example different classes so we don't know anything about it it's just a void pointer is bad but yeah let's look how it works so we have an instance pointer now on the button and also the function pointer which uses the instance then to call it and yeah it seems this leads nowhere because we can do that but having no types no type safety is probably bad so we have an extra pointer but it's c-style uh yeah I don't know if I would recommend it try to avoid it if you can so any other idea how to do that the thing that comes in mind let's loot use an object oriented approach so what I mean we can create a simple interface and say okay you have to implement this interface and the button is just keeping a pointer to this interface and then we can call the virtual function first gotcha here is in C plus plus we always have to do a virtual instructor here in the interface otherwise it's simply too easy to create undefined behavior in interesting ways so then let's try to use that so we have an edit dialog again there's two buttons and then we scratch our heads how should we Implement an interface here we have two buttons one dialog so dialog can only Implement one interface not two of the same kind so we would have to have new subclasses just for handling the button case it also becomes really awkward and is not really feasible so object-oriented approach yeah we have this clickable interface but yeah got nowhere no real implementation that we would want to use I would say so I think the solution is obvious isn't it it's the elephant in the room we should use standard traction for that that's why I'm talking about this topic in the first place so let's see how it's used in this case so first we include the necessary header so we have the functional header where standard function is defined we say okay our callback is an instance of the function template with the type signature so we don't expect to return anything so it's just a simple void function and then the button just has this an instance of this function template instance and the edit dialog now can simply implement the Constructor and we can say okay in the OK button we assign a Lambda to our click Handler in the button that's the main 90 use case for standard function I would say so easy solution use standard function it's typesafe it's easy nice any questions so far um to play devil's advocate here for the op approach in this specific use case couldn't I just have used a pointer to your member function with an interface I mean I wouldn't do that myself but uh because here we have bought well-defined lifetimes and don't need such generosity at the moment the you can always make it work I would say yeah and if you can make it work for for your use case then it's okay but I would say you jump extra Loops anyway to get it working and standard function is simpler and more safe because now you have to as you said define okay my my uh destruction sequence is always known and so on so it's not a faction you don't care it just works or not um yeah other questions okay but this is not the only use case for standard function there are different use cases so this use case we always have something like one pointer where we want to call our function Handler so a member function somewhere else and it's as I said like 90 of all instances of standard function are this simple but a more complex instances and use cases for standard function and one extreme example is for a task scheduler so like in the morning keynote from Daniela we have an uh async task scheduler somewhere in the background and she scheduled some various tasks like handling network connections and so on so let's sketch that also so we have a generic scheduler and the scheduler is supposed to schedule a task I named it qrb task and then it's supposed to later run this task on some thread at some time when it's appropriate how do we find the task here and the simplest implementation for that is simply use a standard function because the scheduler itself doesn't care what this function does it only has to capture it once once you when you queue it up and later has to execute it and all the parameters that the task would want to work on and so on it should capture by itself and then for example we have just the queue where we queue up all the tasks and then later we have a thread somewhere who's requesting uh is a task for me give me that and I execute it on the sweat Hill and for example if you have think about an image processor then the whole image would be captured in this function so it's not just one pointer to some member function in a class but it's the whole object it can be captured here and the scheduler doesn't care you might have the pointer you might have array or a vector doesn't care how big your object is it's always working so in this case you have much bigger objects you'd want to hide in a standard function not just one pointer so to sum it up a bit as standard function can store any callable no matter if it's small like one pointer or big like whole image it's always typesafe and yeah most use cases are small ER bits so we should optimize for the small or for the most often used use case and then also make it work for the task scheduler use case so any questions so far on these examples um it doesn't sorry I'd like to nitpick on the types if it is function still does not care about the constants of like a member function um so what that's one in the function ref papers that's one of the changes they make to system and exhausted function because that's a rough spot there are problems of course yeah but the use case works and it's more time safe than having void pointers everywhere so now that we know how standard function Works what C plus plus contracts are then let's go and and deep dive behind the curtain how does standard function do that thing and I want to introduce you by just writing a new implementation of it so we now have seen the use cases so this is our golden and we want to write a naive implementation that works for the use cases we described so far and so let's start with that so the first thing we somehow have to support the use case where we say okay we have a function this is a template and we have a signature how do we get this thing to work then so we create a template that's the strange angular vertical and what goes in this comment here exactly function signatures are types so it's just a type because like any other template it's just the type can be a signature but how do we access the arguments in the return value now so we somehow have to know which types of the arguments what's the return type of the signature and the thing we used for that is partial template specialization so what we do here is we say in the first thing we say okay there is a struct named function and this is a template and it's templated by one type argument and now we say we have no implementation for that we don't know how to implement functions for any type but we know how to implement function for a function signature and this kind of pattern matching is supported by the C plus plus compiler and it says okay if this type we give to the template is a function signature so it has this structure like a return type and then a lot of arguments then we have an implementation so it's the first trick to get this working and now we already have in our specialization to return type and all the arguments and now we have just to implement it so first thing we have to do we want to somehow call an instance of this function and for that we can use the call operator from C plus so it's just the operator keyword and then run brackets and this is the function name and then we have another round brackets for the arguments and what goes there in the question marks any ideas yeah go ahead um yeah from the template signature basically so let's add that and it's actually that simple and what's the implementation now we don't know but you have to call Operator at least and actually we cannot know how would we Implement that we can only Implement that through some other mechanism so let's pretend we have somehow stored a pointer and then we can call the method on that call and just forward all the arguments and the return type is returned from our call operator and yeah how to get this kind of API working let's try again the object-oriented approach and pretend we have an interface for that so we write a call interface and then have a call member method and the only thing we have left to store is the pointer and to make it easy we saw a sharep pointer so we don't have to think about how the lifetime is managed just to get working here so far everybody can follow so we have now an mptr as a member and we can call the interface with it so what's now left is to is to implement that so the implementation has to be templated again by a concrete callable so that's different that's not the the signature of the function but this is a concrete callable like a Lambda type we cannot name otherwise and this call input now has to implement the interface so we derive and say that's the final implementation and to make it work we store the callable as a member and overwrite the call not what you do here have you just call our callable so in the simplest case our callable could be a function pointer and this would work but we can expand a bit very easily there's a construct like a standard invoke and if you use that instead of the call Operator directly we get some features for our function implementation extra we inspect that later so what is missing then we have to somehow create a call input any somewhere so what do we do for that we have to write a Constructor for our function and this Constructor has a strange thing that is templated again so we have a template function and we have inside a Constructor that is also templated but this type again this is a concrete callable and now we have to be have to be a bit careful here because we say this is template and this template would match any type compiler does know or care about the names we give it so callable could be our function object itself and then this would be a copy Constructor but we don't want that and if you don't want that we say in a requires Clause just callable should better not be a function so if it's not a function then this is this Constructor is callable if it is a function then we use the copy Constructor from the regular C plus okay and then all that's left is initialize Our member pointer by constructing a new instance of the implementation and give it our caller and to make that work we also have to give our call implementation a Constructor that also just stores the callable yeah and strangely enough after only four slides this is it it's the implementation of a very basic function that's all the code we had also sneezed in some blank lines here but I cheated and put all the code on one line so any questions about our naive function implementations of her in the back so does this also now handle a member functions yes because we use invoke because of invoke yeah okay thanks so but we will see later how this feature actually works so I will give some slides for that why do we need child pointer here why don't we use unique pointer for example what do we share um we start sharing once we clone our function instances so if you have two of them then we only have one object constructed and both point to the same object that's why we share and to work around this we could use unique pointer but then we had to somehow Implement a clone function to get a copyable function objects and to make it simple let's this this code is shorter without a unique pointer that's the reason and also a unique pointer wouldn't help us that much so why bother and always the first goal is to get our API working that's what I want to show here so we had done some use cases and we said let's Implement only the code that is necessary to get it working and it's if you want to implement yourself it's already difficult enough so let's not bother this unique pointer you can always do that later you're in front but hang on if I understand this right this now has a very different semantics from such function because if you copy as that function it's going to copy the underlying object whereas this is gonna just share it exactly so that's actually different from set function now probably because we just did an if implementation okay so just checking if I understood what you were doing yeah we go deeper so this is only the beginning here okay if there are no questions then let's summarize it again so what have you done we just used partial template specialization to get one implementation of the function going you have to call interface and a shared pointer to the call interface and a templated implementation of this interface so everything works together now and there was already the question now about the standard function interface so the question now is what is defined in a standard that we do not yet have implemented correctly so let's compare what we have already and one thing we have we got the template signature right we didn't intend that but that's the same as in a standard function and next thing there's a standard mandates that store copy and invoke any callable can be consumed by a function implementation we also have that and we have to call operator so far these are the only three points we have but there are a lot of points we don't have let's investigate so first thing that comes to mind is the empty State we didn't bother to think about what is the default constructed function containing and the standard gives it a name it calls its empty state so if there is no function stored in a function object then this is empty and it calls when we try to call such a function then there should be a bad function called exception so on so strong exceptions is a bit debatable but that's how the standard mandates it and with this empty stator also like some apis that come with that first thing is we can check if a function is empty it should be possible to prevent calling an empty function if it's always an exception so we have an operator pool now to extend that to our implementation that's very easy we just check if our pointer points or something so if it's not initialized then it's a null pointer so we can easily check that next thing is the standard mandates that there are Constructors for the null pointer overloads so when we construct our function with a null pointer then we should construct it with the empty state so it's explicit we say Okay assign a node pointer it's empty so in this case in this Constructor we don't have to do anything because to our point of Our member pointers already in the pointer by default and we can also assign node pointer this case is a bit more involved we have to reset our pointer to ensure that it's already a node pointer and then return analysis so so far no not a big problem the only use case that is left here is I won't Implement that is Raising exception if you try to call it with an empty state because I don't like it and also throwing exceptions is easy and we don't need that now and there are more interfaces for that so we can also compare for a new pointer now so we compare a function instance object with a node pointer and normally you would have to write more combinations of that so you can compare left null pointer on the right side a function object and also this way but we don't have to do that because in C plus was 20 if you just Implement one of them all the remaining parts are implemented by the compiler for us that's also the reason we're able to use a free comparison operator here and the implementation is also kind of easy we just have to check if it's the pool operator overloads it to true or not so that's all about the empty state and then the standard also mandates uh an interface for swapping and this is also kind of curious normally I wouldn't write it that way but let's look into it so the first thing is we have a member function swap so it gets one argument that's the other function and we are supposed to swap to this function with the other one and the implementation is just calling standard snap so the member function calls the global standards web function and now we have also to implement the overload the standard threat function and Implement that and I know we implemented in with slapping the pointers yeah so the member function does the actual swapping and the global overload calls just the member function so why we need the member function I don't know um but that's what's defined for standard function okay next thing we also have to have some types it's also kind of interesting and now in C plus suspending the only thing we have to provide is a result type and that's our return type basically of the function all the remaining parts there were a lot of types defined they are no longer necessary for implementation so we skip that because we don't need it and it seems like the the function API was somehow created and rushed and everything that was needed or deemed needed was put into it little someone said yeah we don't need it let's remove it so now we come to this strange thing with the member pointers so our faction object should be able to handle member pointers to functions and data members has anybody used this kind of feature one two nice three four five not bad I have never used it before so I was kind of surprised to find this feature so let's explain how this works so we implement or include our functional header and then we have a class or abstract to make it shorter then you don't have to write public and such stuff so it has a data member and now we have a function signature from the standard function that expects a pointer to this object and Returns the member value of the end and if you have an instance of this struct we can create an instance of our function so it's an instance of a standard function be constructed with the member pointer to the data member so it's not an actual data pointer it's just if you have a struct then extract media member data and then we can call our data func simply by calling it is a pointer to our example and that's the member data and let's also look how member functions work so we change the data member with the member function here and then we can do the same and invoke it the same so our function also abstract about data member or data member function in this case and as I said I never had a use case for that so I think you have to expect that to know this feature and then uh also say okay let's use it here and so far never happened to me but there are more strange features instead of function and one of the most strange one is the target type so standard mandates we have a member functional function a standard function Target type and it should return a type info object so that's the RTI information about the object we stored in callable and then there are two functions to extract this object so you as as a user have to provide a concrete type and once this type matches to our callable we get a pointer back to the callable has anybody used that feature so far well cool and I think it's a very very strange feature and I would think 99 of all usages of standard function will never invoke this method but we have to pay because the runtime type information for all the types we put in a callable has to be stored in a program because we cannot know if this function is invoked or not and it's a virtual interface so yeah we have to to make this work it's a lot of Hoops we have to jump and yeah if you don't use it why do we pay for that so that's all I have so let's summarize a bit so we had this empty state that's what kind of easy to implement a bit of a strange tweak with the with the null pointer I don't know if this is actually necessary but yeah it's okay uh can live with that just another API then there's a bit strange swap implementation but we need swap anyways so have an extra function is not a big deal and then we start to get somewhat questionable as a member pointer but we've seen some people use it so it's also not like we have to do a lot of stuff to do it just standard invoke and it's implemented we already have that and then there's a strange Target type feature that seems nobody is using and it's still in the standard yeah any questions on this so far am I missing something okay sorry just a quick comment because you mentioned these argument type first argument type second argument type things and you said something about we didn't get the interface right in the beginning or something just wanted to clarify they were there because they needed them for support of the old t plus 98 binders stood bind first instead of the second and stood not one and we we removed all of those things because you're not supposed to use them anymore because lambdas are much better once I've removed dose and then we didn't need those types either because they were to support these other things that we removed so that's why they were there and that's why we removed them just so it's not a mistake in the beginning because it was needed for compatibility but now we have deprecated the use case and now we don't need it yeah we have removed the use case you have deprecated it in 17 and we have removed it in 20. and that's a good thing we don't need that anymore that was kind of broken anyway okay great for the Insight thank you anyone else we missing something maybe a small comment about Target type it could be used for partially comparison functions because function STD function doesn't really support comparison and sometimes Target type can be used for this okay thanks so we have at least one use case but I would still argue that 99 never will use it because most of the standard function usages will never be sorted or partially sorted so yeah but we are missing one big thing so the standard mandates or recommends which is the same in practice that we should avoid dynamic allocations and that's the thing we always do with the SharePoint that we always allocate and it also describes that we should for uh callable that only holds a pointer and a member function pointer should not allocate and I was a bit confused by that what or and combines here and yeah so let's look how in practice the standard libraries Implement that because that's the feature we can easily observe and also let's compare the standard libraries how they do only remaining features and yeah let's go go for comparison here what other implementations did I look at so the first one is the Microsoft sdl it's open source now so we can look in all the code we have the GCC standard Library the ellipse standard C plus plus we have the AEM project they also have a lib C plus plus replacement Library um curiously standard function is like the first value object they implemented API incompatible to each other for some reason I don't know I would guess that C plus plus was first and then GCC was not in the mood to copy that and so they created their own and now they're incompatible but it's just my assumption I don't know anybody and spoke to nobody then there's the Facebook Folly Library they come with a function implementation and then I found an interesting function implementation to function 2 Library uh I would guess nobody uses it because I couldn't find many comments about it but they Implement a lot of extensions that go far beyond what is in the standard right now we will look have a look better later so we want to go fast I guess but I have to tell you I won't provide any benchmarks here because these benchmarks are highly dependent on your use case so if you have a large function for example that takes a lot of time to process your standard function overhead will be doesn't matter but if you have a small function then it will matter and how much it matters depends on your use case and also the compiler will do different optimizations so many compilers now know how standard function is implemented how they know how it works and they will try very hard to optimize that that's my assumption because for standard function they do optimizations they don't do for other stuff and so it would depend on your use case if those optimizations are taken care of the compiler or not so making benchmarks here is almost useless and the benchmarks I found online also suggest that there's basically the same for basic benchmarks it has not a big difference between them and what kind of benchmarks would you want for your applications so one thing is for example how long does a call take but it's only part of the equation because you have also to construct these function instances and also destruct them and depending on your use case you will also just copy them or move them around and so on and how much time it takes will depend on your use case and how you combine these features what is most often used by yourself so measure your use case and don't rely on any benchmarks in the presentation and I won't provide anyone so yeah but there's a different Benchmark that always counts and that's the size so that's the low hanging fruit and like the hummingbird the smaller you get the faster you connect and that's the same for standard function implementation and we have seen in the sea comparison that we need two pointers one avoid pointer and then a function pointer and I've set our benchmarks and we know what to compare to so let's see how our standard libraries compare to that so Microsoft yeah big numbers here so let me explain a bit so I counted pointers so depending on your system bits a pointer has a different size on 64 bits a point was eight bytes on 32 bits it's four bytes but using pointers makes it comparable between platforms and Microsoft decided for example to have something like six pointers plus 16 bytes for whatever reason so this always computes the total size and this these two numbers here are you have eight bytes for your function object itself so that's a small memory buffer and there's two by two pointers overhead so eight pointers in 32 bits or for your function callable and two pointers are overhead for the function implementation itself so once you go beyond eight pointers and 32 bits you will have to allocate memory on the Heap it's the whole thing and the total size is in 10 pointers when in 64 bits it's six pointers and two pointers four overhead so the glue Library always has two pointers for your callable and two pointers overhead lip C plus plus uh it's a bit more strange to have I couldn't find out or couldn't find any compiler that could compile 32 bits that way I don't know it and on 64 bits it's two pointers for your callable and four pointer overhead kind of massive Folly uh is more like Microsoft it's like always eight pointers and function two actually a function tool you can provide trades how big your small memory buffer should be but the default is like 32 bytes all the time that's why the the numbers differ a lot between the platforms and if you look at the whole chart then we will realize there's always more than two pointers so I would say okay two pointers should be enough why do we have like ten pointers eight pointers or whatever kind of strange if anybody knows why and the strange thing is they I think they realize now that it's too big but they say we cannot change it anymore because if we change the size of the function object then we change the API and it'll break all the old code cannot combine this anymore and this incompatibility also already bites us because in lib standard C plus plus and lib C plus plus because you cannot cross use your C plus libraries with that so I have to compile again all with the same standard Library so one motivation to roll your own function implementation would be to make it smaller but you don't have to do it your own there are already implementations there are quite a lot of them and as I said there are some possible extensions you want to use and I want to present some of them so the first one would be to use call qualifiers so in our signature types we can also encode something like no accept or const these are the called fire qualifiers they're not like comparable to a normal type so if you try to remove Concepts will not remove it from the signature these are different kinds of cons after all and what does happen if we would create a function tool with this signature then the call Operator of our function object will also be no except so this might help to prevent your compiler from creating exception code in cases where it's not needed and it would also mandate that to construct such a callable such a function object you have to have a callable that is also no except callable and it would also work for const and non-const and so on so it's the first extension next one would be to have multiple overloads in one function object any idea when this comes in handy or useful one useful thing is for example to visit a variant with that kind of function object and then for different contents of the variant you call different overloads on your function object and if you for example have something like a network API where you get different kinds of packages then you have different handlers for these different commands for example and one I want to shut down the system one command is updated or log in the user and then you have different overloads and can easily also extract some State objects that only exist once in this kind of function object so example would be to have one callable with two overloads of the callable operator and you can also create it by for example deriving from different lambdas the the overload pattern basically and then yeah depending on which type you give as an argument you call different overloads okay then more ideas there's the move only which is also implemented by function two and by C plus 23 standard we'll have a look a bit more in the detail how this works then there's the idea about non-owning function objects so instead of owning the callable we can also have like a pointer to the callable or a reference depending how we see it then you'll manage the the lifetime of the callable somewhere else and have just the reference there were also a lot of proposals for the standard for that but so far I think none got through and uh yeah then you could customize the small buffer Behavior to tune your size depending on your needs so if you have a task scheduler you might say Okay expecting large tasks here use a small bigger function object because we also have a queue where every node is allocated anyways so why allocate twice if one allocation would be enough and memory is in this regard cheap that we don't use it as long as we don't use it um then there's also like a polymorphic allocator support might be thinkable also function object function two implements that and we could also customize the empty handling so instead of throwing an exception all the time which is for example bad for embedded devices where you would want to disable exceptions you would like to have something like if it's empty then call my standard implementation or create a default implementation when it's possible if it's not possible I can provide a standard implementation for example if you have a function that returns a reference there's no way to default Implement that apart from if you were turning it you can default Constructor in and to turn that and there's also like an idea to make a constant usable so far standard function is not exposable um I don't know if nobody got around to do it but it seems also very difficult so far I couldn't come up with a solution for that um yeah we could also write an extension where we totally disable allocation and say yeah if my function object doesn't fit in this small buffer then let's make just a compile error and avoid using Heap for embedded systems for example and then one more thing I implemented and needed is the C API wrapper we'll say I have a function object and I have a c API and the C API gets a void pointer and a void function pointer and I want to make this work so I want to extract these two c pointers out of my function object so anybody else with extension or ideas I think you can see that there's a lot of possibilities and as you see like uh four are already implemented by function two and one is already implemented by C plus plus 20c so let's take a look at move only function because there's also some other things to learn here so the first thing as the name suggests move only function means we have a callable that has not to be copied to copyable for example if you have a Lambda that captures an unique pointer this won't be copyable because the unique pointer you cannot easily clone so we have no copy support in it that's by name and there are some other interesting traits they got right now so for example they have the call qualifiers correct now so you can have a const or no except in your signature and that also applies to your call Operator of your function and yeah you can again construct it with any callable object like data members member function pointers and so on still works and it also supports the In-Place Construction so the standard function you can only uh give it a callable as a copy and then as we implemented it it moves it or copies it into its internal container but move only function supports that you give it arguments and it constructs it on the Heap or in the small object buffer directly so in a some overhead that might be mitigated for that and also they got rid of the runtime type information so there are no longer Target type or Target so if you need that use case then it's not usable but all the other features think I think make it more usable than standard function in many use cases because yeah smaller smaller surface less functional implementations but that it's a different API also means it's incompatible to a standard function so it's not like in place you can change it and then it should work um there are differences um there are not many implementations so far the implementations I have seen they are not smaller so if you compare the size between a standard function and the move only function they're the same they use the same amount of small buffer like you use in standard function and interesting business if you read the standard they also change the wording on this recommendation so now only recommend that for small objects you do not allocate on the Heap but I do not say anything about member pointers or pointers anyway so what is a small object is now totally implementation defined yeah so that's all I have here so let's summarize all the the extension parts um for the whole talk again function signatures are types that's the main thing you should take away here because it's also useful in different scenarios and standard function was very useful it has its problems as we said in the beginning already so the world is bigger than standard C plus so you can use for example function two which implements a lot of extensions and there's also the move only function now in C plus 23. so with that again I'm Andrew could you find me on the internet here's our company if you need help I asked if you need training or work for us if you want to work for us and we are located in Germany president so if you want to work for us you know 100 100 remote now and speaking of Dresden there's also the user group interested so far it's uh we have no presentations this year and we want to restart it next year so we need presentations if you have an idea then speak to me dealers if you speak you also get a tour and Dustin if you come to us if you click remote then you have to come extra to listen let's combine that so we also do video recordings of all the talks and if you don't like it then we also don't publish it so if you want to try speaking you can also review the video and then say no let's not put it on YouTube if you don't feel comfortable and the other thing if you talk interesting I will also drive to your user group and also give a talk there if you want to and one final thing my project is like all modern big companies now building other languages I describe it as an big experiment nothing to do with C plus plus only the compiler is written in modern C plus because I like C plus plus best and let's build it with the best language we have so far but the idea is not to replace C plus plus but try different ideas how languages should evolve far beyond whatever exists today so everything imaginable is possible and if you have interest in languages then speak to me as well so heck more so going deep in the standard function who wield a lot of facts I hope you learned something and that's so far at the end of The Talk and now I'm open to questions [Applause] there's one in the back so I thought that a student move only functions was a renaming of the function ref and function ref has the nice property that it it's very small and it never allocates but that seems not to be the case it's not definitely not the case is there any is there anything I should be looking for if I'm looking for function ref other than function ref obviously yeah take a look at any third-party library that you like um I have to say I looked for it and and didn't find anything that was compelling to me because it's not that easy to implement it correctly and so far I think that's also the reason why it's not in a standard yet so as Nico said yesterday we need more experience with these kinds of constructs and then we have to standardize daily use stuff instead of inventing stuff for the library and then afterwards realize ah runtime type information in a basic type like standard function might not be the best idea that's one here in the front specific question about function ref I'd like to point out in cute we have a private implementation of function ref it's like one paper Vision behind I think nowadays but if you want to look for code and are happy with lgbl look into cute core private function with yes control why is standard function why doesn't it support move only callables by default and why do we need a new type to support it um did we need a move only function because the normal standard function mandates that it's copyable yeah I mean why can't we just change the standard to say that oh no no I mean it as far as I can tell it would not break any kind of compatibility as far as I can tell that's why I'm asking the question right for example if I'm not copying the standard function then I should be able to pass a move only call the board right no no why I can explain the explanation is basically how do you implement that that's the part we skipped by using a shared pointer here so how normally is you would implement it so we had the interface and our interface had only one Function One virtual function let us call and to implement something like copy or move you have to add more virtual functions to that one would be copy and one remove and there will also be something like destruct so distract us to Destructor but yeah depending on on your use case you want to make it explicit and the yeah and then you pay for it because there is a virtual method for that and the virtual method has to be implemented because the virtual function pointer has to always exist and because it has to exist the object also has to be copyable and if you make a move only then the virtual function for copy would not exist so the callable doesn't have to be copyable you know okay and uh in the actual implementations they don't use Virtual functions but they use something similar so thinking about virtual functions might is correct or good enough here so if you want to go further in this going deep then we can talk offline I guess I didn't want to go much deeper than here how it's actually implemented more questions if there are no more questions then you get some questions there's a bonus quiz so very simple questions the question is how big is the thing what is printed here we have one more less different answer it's always 23. no exactly it doesn't compile someone who keeps up with me good so someone learned something and one interesting caveat about this GCC has an option permissive and if you enable that then you get one so one is also somehow a bit correct but normally in all the compilers with C plus 20 it won't compile so next same question how big is that hmm good question yeah but can you be more specific even without knowing the platform yeah it's just the size of the white pointer it's just the point of size and it's four on 32-bit and eight on 64. correct so now more what's the size of this no it's the compiler no standard Library involved here so answer is correct so far but yeah it is but what are the the actual numbers here no no um not exactly so I measured it and one thing is too on clang and GCC it's always two pointers so and on Visual Studio it's one pointer exactly Visual Studio has some Curious uh special cases if you have multiple inheritance involved in your class hierarchy then it would be not one pointer not two pointers but one and a half pointer because they use 16 bit for the index they assume you cannot derive from more than 50 65 000 classes I guess but the strange thing is even though Microsoft has the smallest member function pointer it has the biggest standard faction object that's strange okay are you so let's uh learn one more thing so to invoke this thing you have to write this strange syntax everybody knows it okay so then I want to show you one more trick to get around knowing all these kind of syntax and also to prevent having to store two pointers for a member function we just work around this with a Lambda so we Define a signature that takes the the object and the arguments from the member function and we create a Lambda and assign the Lambda to the pointer this works because our Lambda doesn't capture anything so it's basically a glorified function pointer so it converts and now what's the size of the pointer exactly it's one point always it doesn't matter which platform we are it doesn't matter how many classes we derive virtually or whatever it's always one pointer and to invoke it we just have to call it there's no special syntax about it okay that's all photocus [Applause]