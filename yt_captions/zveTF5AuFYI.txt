thank you and uh a hearty welcome from southern germany from me as well and welcome to my talk about hexagonal architecture and this uh which should be the standard for cute embedded hmis but i come to that so over the last 25 years yeah you see my gray hair that's how long i'm i'm working already professionally so over the last 25 years i built my fare share my fair deal of cued applications first i built a couple of desktop applications with qt so an ide for formal verification of asics and an ide for bluetooth and 6b development they are still around so they are still used these days and then 15 years ago i switched to a cute embedded hmis so hmi is written in queued running on embedded systems and they are built you see one of them an operator terminal for the corona forage harvesters then one for sugar beet harvesters for metal sheet bending machines so doing metal origami and one for medical cleaning robots and then i did some infotainment systems for for cars obviously but also for e-bikes yep same as cars and for for planes so what i what i didn't notice over the 25 years was that i was unknowingly converging towards the hexagonal architecture and i figured that only out two years ago when i found the article from aleister coburn and it dated back to 2004. so i could have probably saved me a lot of time and dead ends and bloody noses and so um reading that article earlier instead of figuring that out myself but maybe i would i wouldn't have understood the article in 2004 and so i went my went my way and arrived at the hexagonal architecture and in this talk i will argue that hexagonal architecture should be the defective standard architecture for embedded hmis not just cute embedded hmis you could also say for hmis in general but i limit myself to cute embedded hmis and um what what are what are the main characteristics of an architecture so you see that on the left hand side so it should be a good architecture it should be technically sound it should be the right architecture meeting stakeholder needs and it should be a successful architecture meaning it delivers value to the customer so or to the to the company who builds uh the cute embedded hmi and well most of us me including start with a big ball of mud architecture and which is definitely not technically sound it might meet the stakeholder needs so if your if your hmi only has to live say for three years you you might avoid the the big rewrite which inevitably comes with a big ball of mud and but if your architecture has to last for 15 years then it won't do and then the it will so the value you can create will go down exponentially exponentially while your technical depth is going up so what i what i found pretty quickly was well i could use a three layer architecture so with the gui layer with a middleware layer and then some data layer where a data layer were going to the to databases or going to the machine so doing the machine communication and finally the hexagonal architecture is actually uh you can you is it's a generalization of the three layer architecture and so let's let's dive into that um ah one warning before that um why is architecture important architecture is like an iceberg only one tenth is visible and the titanic disaster teaches us what happens when we ignore the other nine-tenths and i've seen too many projects who started without an architecture over the wrong architecture and then they hit the wall typically after three to five years and where they had to re-implement basically everything or large parts of their their application and we had we are easily talking about a couple of millions of euros or dollars you can sync with that so it's important to get the architecture right and to find the right architecture the motivation so what's the motivation for the hexagonal architecture it's also called the official name is ports and adapters architecture um the idea is the same as with usb ports in modern um pcs laptops also you you only find usb ports so my macbook here one has two usbc ports and well an audio check on the uh check on the other side uh so i need adapters for everything but it's the same with my build server under the table and so you have an adapter from usb say to can to rs232 to uart you have these uh wireless lan dongles or adapters to ethernet you have hdmi adapters whatever and it's all goes into usb which is standardized so if you uh if if your adapter implements the usb interface correctly the usb standard correctly then it will work and the the advantage is while you just have one type of uh interface that's good and not uh five or ten as 20 years ago and different companies can build the different adapters now let us transfer that idea into software and here is the hexagonal architecture of ports and adapters architecture so the pc is now the business logic and the business logic has well not usb ports but it has ports to different adapters like a port to a to the gui which serves the the models as in model view controller a port to the cloud to pass out say diagnostic information for for remote remote support or it allows over-the-air updates and so on and obviously there's a machine communications a machine port with a machine adapter and typically there's a database so that's that's a very typical uh acute embedded hmi and i've i've written enough of them so the port is an interface between the business logic which is the inside the which is the small red hexagon and the adapters on the outside um we have two types of so an adapter is yeah we have two types of uh adapters actually so we have the ones like the gui who use an interface so the gui uses the model classes so as in the the model view pattern so the gui uses these classes um and then we have the other type of adapters and it's the ones that implement an interface so the the machine down here the machine adapter implements uh the machine port or machine interface so they are also called originally they were called uh driving um adapters and that's the ones above the blue line here and below that that's the driven ones so the ones that use an interface and the ones that implement an interface as you can see a port can have or an interface can have different implementations of different adapters so the machine port for example will implement the the real communication with the machine say over can or ethernet or bluetooth it will typically have you will typically have a simulator which you can use during uh development and you will have some kind of mock which you use during testing the same goes for for the database um and the other and all the other adapters so the important thing and if you if you have to take one thing out of this talk it is this point here the last point the important thing is that the code from inside the business logic must not leak out into the adapters and vice versa so that is that is an absolute no-go and i've seen i have seen business logic which happily uh uh uh references qml properties in the in the gui so it's it's completely the wrong way around that goes always from the gui into the business logic never the other way around or you have business logic that where people happily write sql statements and to query the database that is totally wrong so that is exactly this this point so one adapter doesn't know anything of the other adapters they always have to go through the uh through the uh business logic and they can do so by signal slot connections um yeah that's the the typical way in in queued actually so that is the important point there are clear interfaces and the business logic doesn't know whether the machine uses um can or ethernet or just simulates or whatever it shouldn't it doesn't know and it doesn't know whether you use an sql database or whether you use an uh ordinary database or just a json file that it shouldn't care about that and that has a lot of good consequences so for example if we if we look uh on our product over time so how that develops in our version zero well we have the gui of course we have a database and we have the machine and our application talks to the machine over can or git you can get it out release it customer is happy in version one well uh we found out hmm uh the can boss doesn't have the uh uh doesn't have enough bandwidth so we uh exchange we replaced the can boss boy and ethernet connection to get a much higher uh bandwidth so it's just the the only affected component is the machine adapter and so it uh we replace the all the can boss code by ethernet code and say get some mqtt um messages instead of ken messages the rest of the application doesn't know about this change for the rest of the application the machine uh still looks exactly the same as before as in version zero another thing we might add in version one is an updates component so we extend uh the our hexagon our application and extending it is all always good so we that's always okay so it it follows the open close principle where you are open for extension but you are closed actually for modification and that's what you do here you add a new interface that's in a clear extension and you will have to add some functionality or some interfaces here in the gui port and maybe even don't know yeah probably the port only so you're extending things and that's that's okay and in the version two you might add say remote diagnostic and support via vnc let's make that easy and ah you might decide okay i don't want the message processing in the same process as my gui application is running i move that into a separate process maybe so that multiple applications will see the ken messages so once you have multiple applications that need access to your machine messages then you have to move that into your your own process and then the communication here is done via ipc in the process communication with a separate process which does the uh message handling the message processing and again the rest of the of the application the business logic and the other adapters don't see anything of it and you you can use this uh you can use this in for other configurations so during development you use a simulator probably you don't necessarily have uh can adapters lying around on and a machine standing in your office that's typically too big so you use a simulator or if you want to test the gui in the in the system contacts well you write tests for the gui and you use mocks for all the other adapters and then you can the business logic is the real thing and then you can test your gui in the system context same if you want to test your update component in the system context so how do you or how do we get a walking skeleton a simple implementation of hexagonal architecture into place where we choose one driving requirement or an architecturally re architecturally significant requirement so and the the the one i chose is uh the gui shall show the current engine speed while you know these uh these uh dials in in cars and uh harvesters and tractors and so on which show the engine speed so there is an engine ecu and electronic control unit which sends the engine speed in a can bus frame over can bus to our application to our terminal so that's communication over canvas in the vehicle and then going to a different ecu which is our terminal so the machine sees the uh sees the can frame and stores it in a twin of of the of the real engine and it transforms it into converts it into a quantity so we uh the business logic must not know about ken frames so we have to lift the abstraction level and create a quantity and the quantity is just a number the 930 and a unit which is the rpm in this case so the business logic has has a model a main model in that case which is the model for the view in the gui and well you have to to be able to access something like a quantity object in a qml gui you have to derive your quantity from a queue object so that is the technicality you have to deal with uh uh when you go to from c plus plus q c plus plus to uh the qml uh so it derives from a few objects so you have a quantity object and then you can display the uh the value and the the unit in in the gui so it's what the driver sees is 930 rpm so the important things again is neither the gui nor the business logic have any clue uh that the machine uses can can messages or whatever messages the business logic provides the c plus plus models for the qma uh gui and the gui must not depend on the machine so the gui always goes to the business logic to get some information from the machine so now i'm looking into each component so we have a machine we have a business logic we have a gui component and we have to create the hexagon in the main function and i show you some code and you can find the code on my github repository so we first have the machine port with the product adapter so that would be the machine adapter we use in our real uh product so it's nothing simulated nothing mocked that's the real thing so we see that the well there's an uh engine ecu sends a ken frame so socket can frames uh over to the uh to our terminal uh which uses linux that's why uh the terminal sees it as a socket ken frame and the cue can boss device class reads these uh ken frames or it gets them from the from the linux kernel and creates a cue can bus frame from it so that's the first lift of abstraction then it passes it on to a can bus router so the can bus router does two things first it decodes the q can bus frame into a quantity so it has to figure out that the third and fourth byte in this uh engine speed message uh is the engine speed and there are other there's other information encoded in it so and then transfer transforms it into a quantity object which is stored in the engine twin and the business logic can actually access the engine twin and then the quantities uh through the machine so there is a there is a getter in in machine in the machine interface which returns an engine twin so that's uh the basic schema the basic structure and in code it would look a little bit like this or it looks like this you create a qcan bus device and it's actually your socket can there are other uh can variants which you could use and you use the can zero network interface and then you pass this you inject this into your can bus router which decodes the message and sends it to the engine and this sending from the router to the uh to the uh engine is done by a signal slot connection so um a signal slot connection is it's it's very much like uh it's published subscribers so if you if you know the public subscriber pattern you know signals and slots so the router here publishes this new engine quantities signal and interested classes like the engine will connect to that so they will subscribe to it with the update quantities slot that means whenever whenever the router sees some uh some messages coming on in some ken frames coming in it will collect a couple of them in a list and then send it to the engine twin which will catch it in the update quantities uh slot or function and that is actually the signal slots q sickness slots are an excellent means to decouple a sender and a publisher and subscriber so it goes through an auto generated mediator so the router doesn't know anything about the engine and vice versa the the router only knows about a mediating object and the uh to which the engine also subscribes and so the engine knows the mediator the router knows the mediator and this connection tells the mediator oh whenever you see a new engine quantity signal coming in from the router uh well please tell the engine twin uh and call the update quantities uh uh function and that's autogener the mediator is auto generated in q that is what the mock the meter object compiler does actually good if we now say we uh we don't have a real canvas the canvas adapters are pretty expensive so 250 bucks for one uh not that cheap actually so you replace the uh the actual ecu with the can bus simulator that just generates uh ken messages and then instead of the q can bus device uh you use the mock can bust your device which derives from which implements the q can bus abstract interface um and does everything um well uh in in in the process so it doesn't read it doesn't uh read anything from the linux kernel and uh or from the uh real can bus it just gets the messages the two canvas frames from our canvas simulator you can actually use the canvas simulator to uh playback recorded can traces so if you have a bug in uh in the harvester so in in the on the field then you record record a ken trace on the harvester and then you play it back in the canvas simulator so it's a very very effective means to find problems in the ken communication on your machine then it goes the normal path as before into the can bus router the engine twin machine and then finally into the business logic nothing changes there and that's again the thing so the business logic doesn't even notice that you are simulating the canvas now in the code the main change here is this connection where the simulator whenever it has generated some some fancy messages uh emits a signal which is uh caught in this slot in the mock can bus device the rest of the code is basically the same you can take that a step further so you can have a test adapter which uses just the more can bus device where you can actually observe messages while going to the can bus or you can control what messages come from the can bus and a controllability observability is pretty important in testing again the so the business logic is now replaced by machine test so you can test your complete machine component with that pretty neat you can and i mentioned that already you can say three years down the road you have to replace can by ethernet because of bandwidth problems while you do that you just replace your can bus device by q network interface and then you have mqtt router say you're using mqtt to send messages over ethernet and you get an qmqtt message and from then on the mqtt router decodes that in a quantity and from that point on it's the same so again the same the business logic won't notice fantastic how do you create the machine component well i went for a very simple way of doing it just it's a global function actually where you pass in your configuration and it can be say a product and then you create a product machine object or if it's the simulator you create a simulator machine and you can do the same for for testing for the mock and so on and you can create different adapters for different uh use use cases and you will use that in in main as well good then it plays a role so you uh cannot only switch out the adapter so say from ken to mqtt or to to a mock adapter or a simulator you can also use the uh the adapter pattern to change where your adapter is running where it is deployed so so far everything was done in the in the main uh in the main thread which is obviously wrong to do so you shouldn't do that on a harvester you have something like twelve hundred one thousand two hundred ten messages flooding in per second and you don't want uh twelve hundred can messages hit the gui it will start stuttering and freezing and eventually crashing so you better put your uh can bus routers into uh their own thread and you do that for each can bus has its own thread and then you connect that as before it's connected to the uh to the engine twin or the ecu twins and now it's a signal slot connection from one thread to another thread and that means it's done asynchronously and that's done automatically by cued so the it's not the signal slot connection is then is not a direct function call anymore but it creates an object of the quantity puts that quantity object in the message queue of the uh engine twin on of the main thread of the other thread and um yeah that's fine and then eventually it processes that in the main thread so qt takes that for for you you can go a step further put your message processing into a process of your of its own and use an inter-process communication mechanism like cute remote objects for the communication and again it looks for both processes here it looks very much like a signal slot connection the the marshalling and de-marshaling of the messages is done by tutoring mode objects behind your back or you could take it even a step further and put that on the microcontroller which is often available on modern socks and use rpm sg to communicate with your microprocessor and that's that's shared memory in the end and well the the thing is the business logic won't notice that where your message processing is done whether it's done on a microcontroller on in a separate process or in a different thread it won't notice the business logic is pretty simple um it's a sandwich between machine and gui uh it sees an engine twin and it will be connected to the main model and the main model will be available through in qml through singleton so business logic is a singleton and exported made available in qml and then you can access it as business logic dot main model so the business logic constructor gets a machine so it's a it's a dependency injection in a constructor and then the model is created on demand and stored in the member variable and then you have the signal slot connection between the engine which you get wire the machine interface um the engine speed signal is connected to the set engine speed slot sorry of the main model and yeah so it's it's always the same idea so you you you pass on information from one uh from basically from one layer to the other layer uh or from one object to the other object with signals and slots it decouples enormously hui component um pretty simple now we are we have a language switch we are now in uh in qml and um so we import the models with this statement and that allows us to define a property main model and then we use our singleton to retrieve the main model and then we can here in the text things we show the value of our quantity object so we now are working model.engine speed is a quantity object and we take the value and show that in the gui and we show the uh the unit the rpm i'm jumping over that a bit faster gui port with test adapter while we could uh flip out the gui uh with uh with uh tests or tests for main view instead of uh having uh the gui driving this we have some test code driving that so that allows us to test the gui in in system context with the real business logic but with mocks for the uh for the other for the machine object maybe for the database uh object and so on and the mocks can be reused from the unit tests of the machine and the engine twin so that was one of our configurations of the hexagon configurations we saw earlier and the interesting thing here is well we create a machine object here it's a it's a shared pointer using our create machine function with the mock now not with a product it creates a business logic object where we pass in the machine and then here in this case we store for testing we store the model or in a member variable and then we can start testing it so we tell the machine to emit an engine speed here the engine speed with 930 rpm and then we can compare that actually in the next line and so we can test that our terminal really displays the displays the engine speed and as we also have some gui tests for our qml code we have the whole thing covered and the final thing is we have to create the hexagon that is now easy because it's basically what we did in the gui test nothing much different and so we have in the main function we create our machine with the create machine function and now it's a product obviously not a mock anymore no fakes anymore now it's the real thing and we create the business logic pass in the machine we just created and then uh that is uh well that's the way to get the qml gui up and running with the main.qml and that would then show uh at the moment it just shows the uh 930 rpm uh actually it uh it counts it from i think from zero zero up to three thousand rpm and then starts over again and shows that so and that is it is very simple but uh our very simple uh use case showing the engine speed allowed us to create a walking skeleton of the hexagonal architecture and what you hopefully have seen now is well there is some additional complexity yes there always is if you use uh patterns uh but it's it's pretty uh pretty little so um the the positive things here is high testability it's actually more or less uh ingrained in the uh ingrained in the uh in the architecture that it's easily testable it's highly modular so different teams can work on different adapters and uh yeah on different adapters you can split your teams according to the adapters uh you have and to the business logic if you want to do that i i would prefer to to have uh well one team doing everything so the vertical slice but it's possible and you can easily modify so you can extend it thanks to the interfaces you are using use the open close principle extend your interfaces don't modify them then you're breaking the modularity and it's should be fairly easy to maintain and find find box so what i hope is that i could make my case that the hexagonal architecture should be the standard architecture for acute embedded hmis and it's definitely a successful architecture so it delivers value to uh to the customers uh here are the resources i used for the talk you find the source code down here and it i will uh um yeah uh improve it over time pretty quickly so you will see more functionality now it's time to say thank you here's my email if you have questions feel free to ask me i have a website where you will see uh similar posts about hexagon and architecture and other stuff about cute embedded systems and i write a new monthly newsletter if you're interested so thanks a lot it was a pleasure giving this call thank you for the talk and i'm open for questions i liked it very much um and you're right jens with the might want to use make shared yes of course um but i know it's like a demo code on a site so i don't have that there yeah you do not have infinite space there yes sure um so yeah if you have any questions you can post them either to the q a tab which i don't see any questions in or to the chat um and i right now i don't have like any question but i find your approach interesting to basically use the signal stopped methods to you know communicate between boundaries and then to uh also kind of miss kind of use this to um plug in like different models and mocks and that yeah that is that is one that's i think the the beauty and strength of sickness and slots it decouples uh the two uh things talk objects talking to each other well you have some overhead obviously but normally that isn't a problem and the only question i i directly come which directly comes to my mind is like what do you use as an interface how do you use that if you can't use cute on the other side of the code well then then it's typically uh if you can't use signal slots well i think uh boost has uh signal slots as well by now and uh oh yeah they do they have to they they have influx libraries exactly so you you could use that as a pure c plus plus implementation of it and the other way is typically then you would use uh dependency instruction in the constructor so you have to like you saw it for the business logic where the machine is passed in and then the two uh then the uh models in the business logic could call functions [Music] and then have that connect exactly i think there's a question on the channel what is the major difference to mvc or in the vmware model view view model um the um model view controller pattern is uh is only used in the uh in the gui part i think so it is um so um if you well uh and it is actually used here so the you saw the main model you saw the qml view that's a model view that uses the model view pattern um and but the rest uh the all the other adapters don't use model model view but the idea is obviously similar so it's uh yeah but it's i wouldn't call the whole thing a model view controller uh pattern that is just a pattern on a on a much smaller scale so we are now talking about the the whole applica an architecture for the whole uh application but there are elements even the uh the three layers architecture is actually pretty uh similar if you have the uh hang on if you have the this hexagon you see the three layers if you go from the gui through the business logic to the machine so that's a clear three layer architecture then you can unfold gui business logic and database so that's another three layer path or updates business logic database so you you can unfold your hexagon in the three layers architecture and then you're coming close to model view controller or the presentation abstraction uh controller the pack pattern also so if you if you're looking at three layer architecture you're getting closer and closer to model view controller so i can see your uh i can see your question or how that uh flows into the hexagon the hex hexagonal architecturalism is a generalization of the three layer architecture understanding that it's not just three layers but each each layer or the say the bottom layer of the three layer architecture would have different typically different components uh different libraries here would be the database and the machine library and that isn't really reflected in the three layer architecture so and when you when you move it around in the hexagon then you have uh two clearly separated uh components so it makes things a little bit clearer i think yeah i think you're not limited to one hexagon it's just four maybe three you may find seven adapters or maybe eight but that's a lot so and this is a good number the other thing what i found interesting like when you talked about send a receiver like that um or like you know signal slot that this is so close to what the standard is trying to do is send a receiver now just in in in a way more high level way than what cute already has yeah and on the other hand i see we are going a bit over time and i think i want to thank you for the talk really really nice overview great great content thank you so much for that and um i'm going to take us now in the break and then we're going to have the next session in a few minutes at three o'clock thank you very much see you in the lounge okay