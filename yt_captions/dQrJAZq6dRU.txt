today I want to show you how I built a tool that uses AI to automatically generate quizzes now this video is going to be a bit different I'm not going to focus a lot on the actual code I'm going to focus more on how I set it up in the cloud what kind of architectural decisions I took and how that led me to be able to develop this kind of thing in just few weeks and hopefully that also gives you ideas of how you can improve the way that you develop and deploy your own applications the tool is called learntail tail with AI and while it's in bedside you can use it for free and play around with it if you want to try it just go to learntail.com I did put a cap on the maximum number of users that can register just to avoid that I end up with a huge Cloud hosting bill or something but as long as that's open you can actually register and use it for free before I talk about the architecture let's take a closer look at what the tool actually does so the idea is really simple you can just type what you want the quiz to be about and then it's going to generate a quiz for you for example I could type I want to do web about software design principles and then I'm going to generate the quiz so now it has created a quiz using Ai and you can click Start quiz and then you can start answering questions so let's see this is actually a pretty simple question so this obviously this one that we do next open for extension that's the open closed principle so it seems to be pretty focused on the solid design principles so that's the list of substitution principle and what is this this is the interface segregation principle and then the final question dependencies easy and that's the dependency inversion principle I got 100 that would have been pretty bad if I didn't get 100 out of this one anyway so this is how it works so you generate the question you can just do the question you can share it on social media and you can see what your score is and what's really cool is that you can actually create quizzes not just from text but also from URLs so for example if I go to python 3.11 page explaining what's new I can actually copy this link and then I can paste the link in here and then generate a quiz about what's new in Python 3.11 and now we have quiz about Python 3.11 and then we can answer the question I think I've got to do pretty bad with this one because I don't know all the uh peps by heart anyway another thing that's really cool is that this doesn't just work for regular websites but it also works for YouTube videos so for example I can paste in the link to my YouTube video about data classes and then that actually also generates a quiz about data classes so now I've started quiz so basically now I can do I can answer questions about data classes here's another example of a quiz that I actually made from this video that you're watching right now and that was actually pretty hard to do because I had to go into the future you know create a wormhole and then a Starship to go through it get a tight suit with no pockets hire some red shirts and get them killed yeah it's like a whole thing but I made it anyway the idea of the tool is that instead of just reading a blog post or watching YouTube video you can now actually immediately do a quiz about it and train your knowledge now I have lots of ideas to build this out more in the future but I don't want to develop anything that's not going to be useful so I would really appreciate your help with this so play around with it let me know what you think of it what do you like about it what would you like to see added to this type of platform do you see yourself using this at all let me know in the comments how did I set this up let's break down the overall architecture so obviously this is a web based application and I'm using very commonly the client server architecture for this so in the back end we have obviously I can't really draw that well but we have a database and then we have a back-end service that communicates with the database and of course the back end again communicates with the front end I'll talk about each of these components a bit more in a minute but this is a pretty standard setup for a web-based application now next to this the backend also communicates with a few other surfaces and notably one is of course the open AI API so I'm using actually the GPT 3.5 turbo model to generate these quizzes I might switch to gpt4 in the near future I'll see how that goes so that's an obvious one a second service that the backend integrates with is an email service because when you want to log into the platform it sends you an email with a magic link so that's send grid that I'm using and finally this is not yet there but we're working on this we're also integrating this with a payment service so that later on we can add let's say a paid version of this particular application and for that we're using stripe now there's a couple of architectural choices that I made that allowed me to develop this very quickly in just a few weeks actually one of the choices is that I'm not using microservices this is basically a monolith I have a single backend service I'll show you how that's set up in the cloud in a minute but that's it that contains everything it's built using fast API that integrates everything I don't have to worry about messaging dependencies Etc so this is really quick to set up another thing that I did is really rely heavily on let's say ready to go surfaces things like the open AI API obviously so I'm not let's say hosting my own open source AI model also services like send grid and stripe they're really easy to set up and you can directly integrate them into your environment even for the database I'm using a database as a server so I'm not hosting my own database but I'm actually using a surface because that also allows you to do backups it's really easy to set up there's a web access so you don't have to worry about accessing the database that's all ready to go and that also goes for the libraries that you use typically I try to use whenever possible pre-existing libraries and do the least amount of coding myself because for every line of code that you write you're probably also going to have to write a software test which is more work it might contain bugs and with existing with existing libraries these things are typically just more stable from the get-go because more people have been using them than just you basically don't try to reinvent the wheel and it even goes for deployment just make sure that it's as simple as possible especially initially when you're just setting up an application when just launching something new you can always add more complexity later I don't have the time to go through all the architectural choices in this particular video if you do want to learn more about how to build systems like this and you'd like a step-by-step approach of what you need to do at what stage I'm going to launch a new course this year called the software architect mindset already quite few people have pre-registered for this and I'm only able to offer it to a limited number of people initially because I have some things in mind that I want to do so if you want to pre-register you can do that for free just go to iron Rod codes slash Architects fill new details and then I'll keep you up to date on what's happening with the course so the way I've set this up in the cloud is actually really really basic I'm using Google cloud in this example but Amazon and Asia also offer these type of options I basically have four containers that are running these are all Docker containers I have backends at front end and I have a Dev version of the back end and the front end so that means that we're actually running the whole system twice there are two back ends and two front ends the development version it's part of what you could call a DTaP Street development testing acceptance and production so we have the actual production version which is learnset.com and we have a development version at another URL that we can just use to test whether what we built actually works in the cloud before we push it to production and that's actually pretty useful to us it also helps to preview how the site feels and works without having to run it locally on your machine so that's why we find this is very useful and of course we have like I mentioned before we just have one single backend which is a monolith and we have the front end which serves the actual HTML in Google Cloud you can use something called Cloud run to host these containers and it does automatic scaling and things like that you have Alternatives as well in Amazon and Azure that do basically the same thing and then the back end communicates with a database and for that we're using mongodb Atlas which is a hosted database solution if you're happy with a nosql solution actually this works pretty well I've been using this in several projects and what's really nice is that the sandbox version of these database are actually free to use forever so you can just create an account you can have a shared database which is actually still pretty fast I mean there are some limitations like you can't host those things everywhere it's in a limited number of places it doesn't do backups and there are a couple of other things but then later on if you need more features you can always upgrade to a paid version of the database but for new projects just getting started and you're okay with no SQL I find this a perfect option so within our setup we have two databases a development database which we use for the development version of the site and we have a production database and there's two collections here quizzes and users and that's it and a quiz has a couple of fields like a title description keywords and this is basically what we generate with AI and we store it in the database so that later on we can actually easily access it by using this slog so this is what we're using to construct the URL that points to the quiz another thing that really simplifies working on this code is that we put everything into a single repository I have to learn till that's the learn tail repository that you see here and there's basically two folders backend and front ends and we have a couple of settings so these are GitHub workflows I'll show them in a minute but for example the back end I built it with a fast API so this is what the folder structure looks like so we have the docker file which is the container that we're actually running in the cloud and then we have the main file where we set up fast API I have a rate limiter that I'm using a couple of other things and then the actual code lives mostly in these folders so we have routers which Define the actual routes of the API authentication quizzes and users we have the database layer so we have separated the router code from the database interaction code so here for example we have a quiz which has all the operations that we need to perform with quizzes like counting the number of quizzes getting quizzes made by a user delete all the quizzes by user etc etc and same for the user so we also have some operations to find the user to create new user updating a user etc etc basically everything that you need and the next of these folders we also have a folder test so this is currently pretty limited because we actually moved pretty fast so we didn't really follow a strictly test driven approach here but this is the basic setup so we have our test folder and we can use Pi test to actually run these tests and make sure that these things actually work so that's the basic setup of the back end so the front end we actually didn't use Python at all but we used typescript next JS and some Frameworks like react so here we didn't really add any test because front-end testing is actually pretty hard we are thinking about adding more end-to-end testing to especially the front-end code in the future but the core of the front end is that we're using next DS which is a tool that does building for you that's also defines a lot of the structure that you need in order to serve your front-end application so for example what you see here is we have Source folder that contains all the code so there is a an app folder that has all the pages for example so you see we have the home page we have different types of alerts and cards different types of components that are in here but you also have the page itself which looks like this one there's some typing issues here I didn't install most of the libraries on my machine here so that's why we get these arrows but same for all the other pages so for example here is authentication so we have login we have registration we have some verification Pages if you change your email or if you verify a particular login token things like that and then we have the actual quiz pages so each quiz has a slug like what I showed you in a database and then in the actual page we retrieve the quiz by providing that slogan that communicates with the backends and then that uses other components to actually display the quest so you can actually do the quiz in this case that's a quiz player component in order to keep the pages that we show relatively small we use a framework called Tailwind which is actually a CSS platform and this actually works quite well the pages are relatively small it offers a lot of flexibility and it's also pretty easy to use now since we have these two folders here backends and front-ends another thing that we wanted to do is make sure that if you commit let's say a change to the backend code that it doesn't deploy both the front end and the back end so we set this up with GitHub actions and what we did is that we created a build file for each folder so we have one for the back end and we have one for the front end here's what that looks like so when we push a change to the main branch we're going to filter on path so this back end build is only being run if something changes in the backend folder or if we change something in the workflow file itself then we have some environment variables that are being used in the build job and one in particular is interesting so this is the back ends and file so we put all the secrets and API keys and things like that in a Dot N file which we store as a secret in GitHub you can attach that to your report story in the GitHub settings and we read the value of the sequence in this particular environment variable and then in the build job what we do is that we write this value the NFL contents to a DOT and file in the back end and in order to store the secret we've encoded it using base64 so that's uh line breaks and things like that are being managed properly and then for the actual build stops we just follow a pretty standard approach so we first authenticate with Google Cloud providing a credentials key then we authenticate then we validate that the repository actually exists we prepare the environment defining image names and storing the m-file then we actually do the build using docker and then we publish by do using Docker push and finally we deploy it to Cloud run using Google Cloud fronts and actually looks pretty similar so we have a front-end and file then again we authenticate with Google Cloud we follow mostly the same steps actually and build and publish and then deploy the artifact so by doing it this way we make sure that whenever we make changes it's all in a single repository but we're only deploying things that have actually changed which makes it a lot easier to work with I hope you enjoyed this overview of learn cell and it'll give you some ideas for how to set up applications yourself again if you want to try it go to learntil.com just let me know what you think of it I'd love to hear your feedback one thing that I didn't talk about at all in this video is how I actually communicated with the openai API and I used land chain for that if you want to learn more about how to use Lang chain to build tools that use AI I did a video recently where I covered line chain in diesel you can watch that right here thanks for watching and see you next week