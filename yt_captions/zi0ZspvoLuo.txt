I feel like this article would have been sacrilege only a few years ago under protection of this newfound trendiness and react to this pleasure I'd like to finally say my piece dude I've been saying my piece for a long time never never be worried about saying what you think okay uh don't be mean but don't you know say what you think about technology I don't care I don't much care for react and frankly I'd say the same uh same is true for most even if you have yet to actualize your resentment trust me you hate it uh well I've been using react for quite a long time and uh long enough to say I'd prefer the company of another I mean I'm practically a react developer for Pete's sake my last company this company probably my next company I can it can't seem to avoid it you'd think I'd stop caring so much after a while but it just takes one look at the alternative to wonder why you'd ever stay yeah actually okay I agree I'll tell you react is not all it's cracked up to be I mean it was It was obviously when react came onto the scene it all looked so elegant component code would focus on locality of behavior your Dom was inlined is sat right next to the event handlers your code looked modular and was neat actually I really do agree with this I really did like I think reacts initial starting was incredible for those that weren't there when react started it was like it was incredible it was the same feeling I got when I started using jQuery like when I started using jQuery from using nothing it was just like wow right it was like such a wow moment and then going from using jQuery and this to react it was such a wow moment I really loved it it was a cool moment in life yeah tutorials were born books were written gurus were created react had erected oh yeah hell yeah we're gonna get a solid erection from this one and Empire faster than I'd uh seen before no jQuery definitely did uh the developer experience was unparalleled but better than that it was obvious the first uh the first to try a taste were the conference goers the think fluencers the nerdiest of us the library spread how could it not it was syntactically simple we all bought in then we were gifted hooks huzzah to be honest they were a bit foreign at first but the clarity Newfound Elegance quicker to type faster to iterate easier to read react was the correct choice I actually felt like hooks is where things started to fall apart honestly I I know that's a very unpopular take but to me it's like the worst middle ground between fine grain reactivity and uh like this class component based I really think that fine-grained reactivity solid.js is the route to go this Middle Ground of hooks I feel like is the worst ground to go I always feel like compromise is the worst place uh but then years pass and you start to notice a wealth of Alternatives every new month a new name okay well that's just JavaScript being terrible and we scoff at these new fangled weekend projects they'll never catch on react is Battle tested react has molded itself perfectly into a whole weed previous that we found previously there is no room left for a new kind of spackle what a great I like how this reads this is great this feels really good my nose is itching I forgot to shave today look at how big my beard is I can't be going this long and then people start uh speaking too positively too consistently it feels like everybody is happy with their new things and less happy with the old thing yeah I mean that's always true uh but those are just passing pads nothing like how react stood the test of time from his launch in 2015 uh and iteration in 2019 and constant Evolution you know react doesn't feel so stable anymore I mean maybe it's the best choice but who really knows I thought we were done iterating but I just kept getting swept along with some new change maybe there's a better way than I haven't seen yet it can't possibly hurt to look and yet it does reactant hooks Evan you right this is the uh you guy The View guy I mean I'm always so curious about this uh I've heard such mixed reviews of this person I don't know him I'd love to get to know him maybe one day I'll be at a conference with him and I can sit down and just talk to him uh hooks created a lot of problems that simply do not exist in idiomatic JS I hate that phrase uh difficult to optimize absolutely too heavy to invest in runtime semantics which makes it difficult to evolve in a direction that makes more use of compilers I know all those words absolutely individually I can Define anything hit me but when you put them together I don't even know uh hooks uh isn't react but honestly it might as well be react hooks in the distinct from react itself you can still use class components after all however it has taken over the react landscape to the point where hooks seem inherent to a reactive development when I refer to reacts model of things in this article I'm referring to react hooks okay uh I recently read someone's astonishment at how smoothly the react ecosystem translation to hooks was how everyone was unilaterally in agreement on its benefit I was not I've been just I feel like I remember when we were making this upgrade at Netflix and just like researching it oh gosh I must spend four years ago and I was just like such a proponent like dude I don't I don't know I don't know I don't like this how everyone was unilaterally in agreement on its benefit not let's say this is not the pass I remember I remember quite a bit of uh contention particularly on the orange site but not exclusive to it I think I understand now where a lot of the ideological resistance to hooks comes from thread but not necessarily siding with the anti-hook crowd it's starting to get a weird sounding it sounds like politics at this point but I do think a lot of the concerns were warranted react hooks existed within an environment controlled by class components to allow this transition react had to be a fully compatible with class code and it was this compatibility compatibility combined with composability and readability improvements used uh ushered the industry as a whole to adopt hooks quicker than one would predict I generally I do genuinely think hooks brought both the improvements while it's not universally agreed upon I'm in The Firm composability over inheritance Camp yeah I agree with that for the almost all cases and I think sharing Behavior via functions is drastically improvement over class inheritance I can also get behind that for most cases as the readability while the length of your code may not be directly correlated with legibility yep react hooks improved locality of behavior I would agree with that as well locality of behavior is why I like solid yes your eyes do less scanning and smaller components event listeners State Transformations and rendered output can have your eyes jumping up and down and hooks can improve on this I find function components do uh write let's see I find function components both right uh quicker to write oh my goodness and easier to read uh I will say that one thing they're missing right here is there's like this whole higher order components phase that is just like completely skipped dear goodness dear goodness about readability at least in the intermediate sense does not itself go hand in hand with complexity hooks lower complexity via localized Behavior but increases it by abstractions it had to make I think about this out of context quote from Amos a lot or rather it's half truth that conveniently covers up the fact that when you make something simple you move complexity elsewhere yeah I fully agree with that statement abstractions don't necessarily make things better they just change things when we abstract over complex systems we don't eliminate complexity we move it in our case complex system is not front-end development but react hooks move our mental model around to think about State Transformations and synchronization instead of life cycles or at least it attempts to absolutely there were some sacrifices to Performance brought out by this movement its bandages visible as hooks use memo use callback uh I know someone that calls it use memo never liked that finding memos I don't mean to imply that memoization did not predate hooks in react I did react memo I'm saying we now have to memorize State initialization and Transformations due to the improvements we've made in localizing Behavior there's a common Community conversations on memoization in react much more so than other Frameworks value caching is important in all Frameworks but hooks force a lot of that decision making onto the component author not the core Library yeah like the thing is like if you use something like solid.js there's a lot to it and that if it's something that's rapidly changing has the same value you can use something like memo so it doesn't keep firing but for the most part like due to its speed I've rarely even thought about it it's like really nice solid.js is really nice I'm also curious how felt does a lot of their stuff I haven't played this felt enough to know about it we'll get more into that later but we'll continue alright there's a model you'll often read about in react stocks or YouTube videos that let's see and there's what is really happening or at least there exists a mental model more true to the actual Behavior than one uh and one I think is important to go over okay a better mental model it's rare to see a conversation around react itself without seeing them in terms of vdom sprinkled about Dan abramov doesn't seem to be a fan of this I agree with him here the react V Dom should not be our Focus react is not it's vedom the vdom is a consequence of react not the cause of it although when discussing the immediate differences it's something easy to point to we should instead be focusing on how react components are meant to be pure this term seems immediately misplaced when we remember that components have state state seems directly contrary to the idea of pure functions something that produces the same output for a given set of inputs no matter the amount of times or ways in which we call it so this whole idea remember that or one that that video we watched earlier or that uh that article we watched earlier about how we how you create the state and functions and returning out those objects and we called it oop versus uh functional effectively hooks does the same thing it just does it programmatic for you you know what I mean I'm excited to see where this is going but hooks in some sense you can imagine our properties on a class or functions on a class it's the same thing but slightly different it's hard to explain if you're not pretty familiar with programming but it's like it allows for a bit more composability which is nice but I find that often I don't really like I don't use it in such a way that I use it in multiple places right it's like I always am just using this in this one area it's not really like I'm not really composing anything I'm just defining a class that's set in a function with these properties that I pull out programmatically you know what I mean like most the time I'm not composing anything I don't have this behavior that I'm spreading to multiple classes I have this behavior that I'm spreading to a singular item and that is it state is yet another input and the react land uh calls to you state or another way of receiving input State lives in the react V Dom state tree components are called in a very order mannered yep you state will pop inputs off the provided stack both state and props are kind of inputs uh calls to set standard signals to reacts internals not to direct mutations these signals will in turn update the component States stack and rerun the component the component will then produce it so yep yep yep yep yep yep yep it makes a little bit easier let's see components let's say react components might as well be a a black box to react yep its internal behavior is not viewable we can think of components themselves as being reactive objects instead of individual pieces of state that's commonly what people mean when they describe reacts reactivity model as not being fine-grained yep it sits on the component level not at the property or individual you know at the individual point of render uh this reason reacts react needs a way to not rewrite the entire Dom on each update therefore must run through a diffing process yep and that's where the V down comes in state tree component tree this is react a relationship between render and reconcile the pure component Behavior this lack of direct connection between State and Dom updates in react components are real and the Dom is not hmm perhaps this is why react makes such a good choice for non-web renderers we can use react to describe a UI and updates but swap out the process in which these updates are applied to our UI as a web developer This Is Not Great enough upside um the quickest obstacle you'll run into as someone new to react will be is something like this all right here we go look at that we got this thing going on infinite Loop suck it yeah isn't this great don't do that whatever you do don't do that uh try to make uh State updates at the top level of a component will result in an infinite Loop State updates rerun components this doesn't mean the Dom updated it means another state update which will trigger another rerun of the triggers yet blah blah blah you'll probably find this bug pretty quickly if in Loops like this are aren't too difficult to spot when you don't know what you're looking for they're very difficult to spot right it sucks the first time you solve it it sucks if that makes so much sense now you didn't know this yeah so so that's why the Dom doesn't update because the Dom so you'll notice something the Dom can never update so you can make a bunch of updates to the Dom but the Dom itself will never update until the JavaScript process event Loop has been like is you're off and you're about to go back into it and so you can just like make a bunch of updates and then while true and it will just sit there Frozen on the screen until this thing pops up and then goes back up and so it's one of those things where this that's all that's happening is all of your components render it sets at the next state it does all the state the state then gets triggered mutated and all that and then it triggers the next render and it goes through and it does the same thing does the same thing and it just does this in a tight Loop it doesn't let the process of you know it doesn't go off the process of end Loop it instead just stays within the same one you can imagine like a while loop while dirty is still true keep on re-rendering let's see things get more complicated when you start using react context and start signaling updates and parent components the render Cascades maybe one component fetches some data some components remount and you rerun your state update again delayed by a few seconds this pattern is common enough to be deserving of its own article but this isn't the article to know how to fix reacts problems it's a rant components as a reactive object let's continue the discussion as components existing as the reactive objects not State there are some consequences of this pattern all right look at this Beauty look at that little beauty right there this makes so much more sense now yeah if you don't think about how react works it can be really confusing to a lot of people a lot of people don't uh you should always here's a little tip for you whenever you use something take a moment and try to just imagine how you would write it you know what I mean just take a moment and try that every time you use something just just even for five minutes not a lot of time and you will find that it opens a lot of doors to how you think about things it's just trying to imagine how things are are written honestly it's it's very good for that practice because then you would kind of think about like how does you state work like even for me I don't quite understand the exact use State order and how it's able to maintain you state perfectly but I I have a lot of ideas of how it works yeah yeah I get that because it it depends on the order called so you can't swap these the you state you know like so if you have a use state in an if statement it can totally F things up all right anyways let's get let's see I'm oversimplifying this component uh for the purpose of not causing you to immense pain but anyone who has worked with forms in react knows that they're often more complex I regularly see form components with 300 lines who've involved is a state transformation validations and air views a lot of it is inherent to forms not just react yeah forms are very hard forms are very hard I love the song that's playing remember components are reactive not State when working with controlled inputs we are causing re-render on every key press in our input this means we're potentially running State computation code regardless of anything that's being touched yeah but the V down fixes all that that seems to be prevailing in the anti-anti-v Dom fallacy the vdom perverts extraneous Dom updates not State uh computations your component is a function that is quite literally being rerun each time you need to check for updates while the Dom itself may not be touched the code is running may not neither yes exactly okay so he's he's 100 correct on this one right here do you know what I mean this is 100 100 correct is that vdom only saves you from changes in the Dom it doesn't change save you from from JavaScript being re-ran right all right let's see here we go uh imagine the following component here we go label text uh label two title case text input all right just make sure we have everything here uh return this on input value on input okay there's just so much going on here it's kind of confusing a more realistic example I think we need to fix the Let's see we decided to fix label inputs provided to us by transforming them into title case from now on it's fine I've decided not to memorize anything because the computation seems simple enough but what if things uh change what if two title case grew in complexity perhaps over time we slowly added features to create the ultimate title uh title caser yeah and now you're doing this every single time on every keystroke we now have to rerun two title case in every component our use let's see our use of use state has made our entire componentry reactive yeah oh no I mean is that a problem browsers are pretty fast Hardware is pretty fast maybe it's not an issue I hate this I hate this take I hate this take that's fast enough right fast enough should not be a reason to have crappy code well it isn't uh it isn't until it is yeah incrementally by adding computation in different places won't cause much harm but keep uh doing that it'll eventually you've created a sluggish experience now you must face the problem that there is no single source of performance pains it's everywhere [Applause] this is always the problem of writing shitty code over time is you get this thing right here right and you can't optimize it because everything is slow it's everywhere fixing uh this requires a lot more work than you'd like to expect but aren't you forgetting about use memo ah yes that I wish there was confident a confident consensus on this for every Pro memorization article there's one against it well the problem is memoization by the very definition memoization is expensive and people don't understand that I think uh I preferred the FP guy damn but real talk like the problem with memoization is that you need to memorize which means you need to check something so remember you're doing a hash map minimum check if they're using a hash map or an object lookup I assume they're using a hash map right you're doing some sort of hashing and keying into a hash map with the arguments going into this thing therefore you're getting something back out of it right like it is it is non-trivial remember hash maps have to resize hashmaps have some non-trivial hashing function that's involved it is faster to put objects in an array for small amounts and just walk through it and individually compare it as then to run a hash map right I wanted hot takes but this article is making so much sense it really is it is making this is actually one of the most sensible front-end articles I've ever read in my lifetime uh Dan abramoff has repeatedly pointed out that memoization does still uh incur the cost of comparing props absolutely there's many cases for memorization a check can never prevent a re-renders because the components always receive new props as this example damn people this is emotionally painful me to read uh the comment was in reference to react memo slightly different uh yep yep you have memorization entire component stops at the Cascade of renders from not needing to check its children this feels like a sensible default to put the reacts team seems to think the performance cost of comparing props outweighs the average performance cost of letting massive re-renders Cascade take place I figure that's probably wrong Mark seems to agree yeah all me and my homies seem to agree I I actually I'm I'm on team react with this one and the reason why I'm on team react with this one is that you should know when you incur an additional cost for everything because that additional cost for everything may only be useful in a very specific circumstance and so you should only enable the very specific circumstance when you need it right like you really got to be you really got to be careful about that hey Brian just watched your front end Masters video on YouTube it's very nice presentation oh thank you oh why delete carbo wait what Mark mark my words Mark uh it also makes the type uh look uh ever so uglier most code bases I look at tend to avoid react memo until it's absolutely certain they will create a significant performance improve it's another argument against memorization that is easier to that it is easy for a react memo to be ineffective when the parent code isn't written correctly absolutely this is pretty cool this is actually a really good uh I really like this we're comparing props let's see uh we're comparing props in the fastest way possible shallow equality this appears to appears like a new prop on each re-render since re-renders are common we need to be aware of this absolutely components being the reactive Primitives here so we can fix some of the memorization by moving States through components I don't particularly enjoy this kind of discussion when I'm trying to create a product yes I said use memo not react.memo fair enough let's talk a bit about that we fall into the same performance considerations absolutely it's totally a depends people don't realize that there is no golden hammers like look at this what what they're not even speaking about is that you've got to remember so let's just say you have thousands of components rendering every single time it renders you create this array this means this array that gets created continuously every single render is gonna have to be garbage collected later on because it's held on to for some amount of time every single time this function renders this function right here is created like it's not a zero cost even just setting it up is not zero cost which means that you now incur more GC time GC time can be very important especially as your product scales especially on a server servers is where you really experience these slowdowns not so much on the client client's ear you're probably not going to see it nearly as much if you're on a fast computer but on a server this is where like this separates your 25 requests per second maximum to your 100 requests per second maximum it's very very very different it's just very very different don't spend too much time reading uh that it's just nonsense for demonstration purposes uh whoopsie daisies I should have read ahead people but did you notice something weird there are two discrete State Transformations one is a list operation the other one calls some function resulting data we've actually memorized too much what happens if a randomizer changes we rerun the whole function which should have been written like this we have a c now look at this now you're creating four required pieces of cleanup garbage right this keeps on growing right it keeps on happening and people this this is the hardest concept I think for a lot of JavaScript Engineers I hate using the term of a language and engineer together I am not a rust engineer I am not a typescript engineer I am a software engineer and I'm good at typescript and rust right now our values are more specific change randomizer oh yeah yeah yeah yeah yeah yeah yeah yeah the day is saved I think I tend to automatically memorize data when I see a list operation uh is that a qualifier I don't know I just do it most notable issue with memorization is that it's ugly okay so I don't like that I I mean it is ugly but I don't really consider that a big like loss here uh I don't know that I'd call that a coat smell I've read that before but it definitely might make code harder to read memorization might help sometimes but only if we're careful in both components usage and composition caching is not a feel let's see is not a field of complexity exclusive to react but we're forced to deal with it manually yes yes memorization solves problems that but that I can feel it's frustrating to think about when when and where to memorize it's not that the ergonomics is poor I don't like that term either the problem is is that you can't know that answer without observation and most people don't know how to observe that you know what I mean that's the true answer of this how do you know something is faster or slower you don't know until you can measure it uh the pedagogy the pedagogy I I forget what this word even means I feel like I should know this word right off the the method of practice of teaching especially when okay yeah yeah yeah yeah yeah yeah yeah yeah uh on the method of teaching that's what I'd love to focus on I've made a hobby out of researching programming pedagogy over the years I've been focused on let's see how do I most effectively communicate programming Concepts I don't think I have an answer just yet but I know how you do the opposite reacts has traditionally been taught as the simplest component system where the state is connected to the UI over time I've had the pleasure of teaching quite a few people react people relatively new to Frameworks to react or to coding in general react isn't easy and it's made even more difficult by obfuscation and teaching material okay is this uh these Concepts these mental models were going over they might seem trivial to you if you've been working with react long enough it isn't for most people it isn't obvious that your computer re-renders on State updates How would how would that even work there's no name to go along with each state usage how does that even remember these are all really good I'm going to skip that part but it is a good point it's a good point you know what I mean we can't change the articles there I'm going to skip over that uh I want to revisit the forms discussion the pain I've been felt a lot let's see the pain has been felt long enough for there to be some change in forms best practices uncontrolled inputs are all the rage these days component updates uh come from State updates controlled inputs force a state update on each form interaction we just let the form do whatever we let's see whatever when we only need to update on submission and validation steps this pattern has been popularized by a formal formic and react hook form I don't know what this render field is oh use form okay render field input okay interesting I have to play with this a little bit more to know yes we're adding some complexity here but it helps with State updates and affecting the components we'd like that this brings us to an interesting point however when we look at react ecosystem we find a whole lot of libraries that exist for the express purpose of fixing reacts shortcomings when you see these Library advertises about 100 speed up and ergonomics improving what they're doing with react when I build libraries for react ironically when I build libraries for react ironically I don't really use hooks like you state user or whatever one of the best perks and foot gums of managing your own State outside of react is that you get to have full control over what your components should render Tanner's also a good guy he's a smart guy you should listen to Tanner uh which for the record I'm not against it's just um let's see it's just abstractly funny to watch the ecosystem review I renderer work so tirelessly to keep using it while you avoid every part of it is there anything left in here okay this just goes over the the counter of it which is just fine grain reactivity solid yeah solid JS let's go solid.js we'll read a little bit about solid what would a framework uh integrate fine grade reactivity look like probably something like solid.js so here you go this creates a signal you set the count right here by calling it plus one set count blah blah blah uh then you can return it and so then only this part gets updated right here solid it's fun to bring up a react discussion because the API looks rather similar to react the major exception is that we don't uh need to wrap our code like this and use effect exactly react uh this kind of code would result in a nasty bug where we created a new call to set interval every second for Frameworks that don't need component-based reactivity the distinction between components kind of Fades away they are useful for setting up for setup and UI generation the state is all truly matters during your lifetime your applications exactly so this so for those that don't know what solid.js does right here is that this is a Constructor it's not a renderer so if you're used to if you're used to react you'd look at this as a renderer which means that this gets called every time we render but it doesn't this gets rendered which is what you return and it changes based on this little hook of reactivity but this function theoretically only gets executed once now obviously if inside of here you make it such that when this thing changes you render a new component then yes you will render it you'll reconstruct it but you don't re-render it every single time and so that's like the big difference between solid.js and react and I find that once you make it over the hump using solid.js I find that it's just tremendously easier to think about because this these are like little LSP things you can kind of Trace through your program it makes a lot of sense you know that this is the point in which it changes whereas with react you have to find the progenitor the one or the producer of said uh state so wherever the state gets produced that's the point that causes the reaction whereas in solid.js it's the point of using it that causes the change and that's a fundamental difference in thought process but it is amazing it just makes uis so much easier to think about just saying I just think it's a lot better now obviously I haven't written large uis with solid.js so I can't really say it's better than react I have been a part of large uis in react and I've hated every single moment of it I'd rather go drink toilet water at this current point but I'm just saying solid.js so far has been a great experience for me really have enjoyed it all right I'm done with the article hey the name is the prime machine like And subscribe and give me your Twitch Prime baby gotta