today I want to talk about thunder methods when to override them and when to basically avoid them we've all seen and used Dumber methods before the most common one is the dunder in it method to initialize an object and they offer a lot of flexibility they allow you to basically change everything that python does under the hood but if you're not careful and you use them in the wrong way it leads to really confusing code and it makes your programs really hard to understand in short with great power comes great responsibility which by the way I learned is a quote from a Spider-Man comic so now I'm in Marvel mode holy list comprehension Batman before I talk about Dahmer methods let's take a step back and explore the history behind the python data model python has a language was created with a strong emphasis on Simplicity and readability Guido for Rossum the creator of python you want the language that would be easily understand and express ideas in a really concise manner and to achieve this python Embraces the concept that basically everything is an object that means that every piece of data in Python doesn't matter if that's a number a string a list or even a function is represented internally as an object and this Choice led to the development of the Python data model so what exactly is the python data model well at the core it's the model that defines the rules and protocols that Define how objects behave in Python it provides let's say a standard interface and a set of protocols that objects follow and that way they can work seamlessly with built-in python features like determining what the length is of something Central to the python data model Rd donder or double underscore methods these are special methods denoted by double underscores before and after the names that allows to Define how objects interact with various operations and built-in functions in Python so this gives us the power to completely customize the behavior of our objects and that is what makes python such a flexible language donor methods are like hooks into the python interpreter and by overriding them we can Define operations such as object creation how objects are being represented accessing attributes iteration and lots and lots more typically these download methods are not going to be invoked by yourself but by the python interpreter so that looks like they're being called by Magic and that's also why donor methods are called Magic methods so it's another name you might encounter from time to time now the data model is of course not static I mean every new version of python that's going to be new donor methods that extend the capabilities of the language and that means that every time there's a new version you can override more download methods and customize more Behavior like I said before overriding donor methods can be really powerful and useful but you have to be careful so here are some guidelines for when to override dominant methods and when to avoid doing that a first case where it's useful to override donder methods is if you want to implement custom Behavior so I have an example here it's a class Point As an X and Y value and you see I've implemented the wrapper donor method so this is going to give us a developer focused developer oriented string representation of the points class so when I run this then you see that it outputs the string representation of the point so this is where it makes a lot of sense to add a donor method so that we can easily when we call print on the object then we have control over what is actually being printed so we Implement custom Behavior other examples of where you might want to do this is overriding get items so that you have square bracket access to a list of things things like that another reason why you might want to override donor methods is if you want to simulate some sort of type or if you want to patch into another system that relies on something being of a specific type and this is especially useful for built-in types like lists and dictionaries and so on for example I have a class accounts here which is a bank account and then I have another class called bank which maintains a dictionary of accounts and what I've done is that I've overridden a couple of dollar methods like length to get the number of accounts get item that gets a specific account from an account number and also having iterator access because of that I can now iterate directly over the bank object and get access to the accounts so if you take a look at the main function here create a bank I create a couple of accounts do some deposits doesn't really matter but then you see here I'm access seeing a specific account using the square bracket and that's possible because of the get item donor method that I implemented similarly I can very easily retrieve the number of accounts in the bank by simply calling the Len function on the bank object and also because I have implemented the iter dominant methods I can now write a for Loop for account in bank and then it's going to print the account balance as account number and that's all possible because of these Thunder methods that bring dank closer to operating like a dictionary and because Bank implements its dollar methods I can also pass it to other functions that for example require something to be an iterable or things like that and you see when I run this code then we're actually going to get the results that we expect so number of counts and we have the balances and the accounts number so that's the second reason emulating built-in types the third reason why you might want to overwrite Dollar methods is if you need operator overloading so in this case we have a vector class that has an X and A Y value and I've implemented a couple of dollar methods here like add for adding two vectors or for checking whether one vector is the same as not a factor and of course you can add more like um maybe you want to have also the subtract version of that which is simply going to return the vector and subtract the X and Y values you may want to add multiplication um you might you may want to add it for different types so there's lots of features you might want to add to the factor class simply by overriding The Operators because now what you can do is we can create all of these vectors and we can call for example a plus b and that's going to use this dollar method to compute a new vector and as you can see that it works as expected so that's a vector so vector 1 2 plus Vector 3 4 is factor four six and also comparison works because I implemented this donor method so if compare A to B which are different vectors then the output is going to be False A and D are different Vector objects but the values are the same so this is going to Output true and that's also what you see when we run the script now if I didn't have this equal donor method and then I would run the script again you see that now actually the second comparison returns false because actually A and D are different objects so when you compare them the result is going to be false and that's what the equal dollar method helps us solve because of course in Vector math we want these things to be actually the same factor so building these kind of objects where you need to define the behavior for these types of operations donor methods are really useful and it makes total sense to overwrite them another example where it's very useful to override under methods is if you need a context manager so here I have an example this is not actual running codes just to show how it works but we have a data connection class that gets a host a username and password and there's an insert and an exit dollar methods and these two methods are needed if you want to create a context manager by the way there's also a decorator version of this that uses the generator but I'm using this to show you why it makes sense to use dollar methods in a class and then when you define these methods well then you can use the with statement and you can create this database connection objects pass the information that you need do some query and then after that the connection is automatically closed at the end of this with block because then exit is called and then self.connection.close is called by the way this is a very basic example you can do many more things with context managers for example exit can return a Boolean to indicate whether an exception should be suppressed or not for example but I kept this really basic so four cases implementing custom Behavior emulating existing types operate or overloading and building context managers so quick question have you seen these users in your own code base are there other reasons you can think of when it makes sense to override domain methods let me know in the comments so clearly there are cases where it makes a lot of sense to override donor methods but there are situations where you might be tempted to override dominant methods but you actually shouldn't so I'm going to cover four of those cases in the second part of this video so the first one is that if you override dominant methods you have to be careful that you might actually increase complexity without even realizing it so here's an example of that I have a validator class and the goal of this little program is that I wanted to create something where I can have multiple validation functions and then run that on some values so I have here a function that checks that values even that it's positive you can add more to these obviously then I have a class called validator which has a list of validator functions so these are callables that get on end and returnable so examples are is even and it's positive and then I have a method add validator where I can add a validator function that just adds it to the list and then I've overridden the call donor methods which then runs all of these validator functions on a particular value and what this does is that it allows function like behavior on an object this is actually syntactical sugar for a function sort of so in the main function what I can then do is create a validator object by passing it to validators and then I can call this object as a function because it has the called Thunder method so I can perform the validation by doing this and then it's going to print a results of four yes it's true because it's both even and positive and seven is going to return false and when I validate seven that's of course going to Output false because it's not even so let's run this and you can see this actually works the problem is that here we're actually slightly over complicating things why do we need a separate class that contains a list of validators and then we need to overwrite the core method it's a bit complex a simpler way to do it is to actually not use the class at all but simply use a function for this here we have another version of the same code but now it has a validate pipeline function that gets an iterable of validated functions returns another validator function and then this is the body of that function so what I'm doing here is I simply create a new function that takes a value and then calls all of the validators on that value and then return that function so this is what we call a higher order function that's a function that gets functions as arguments or has a function as a return value and this actually has both although validators itself is not a function it's an interval then we Define validate functions as usual and in the main function it's actually really simple we don't create any objects we simply call valid pipeline that creates a pipeline validator function for us and then I can call that function to me this is simpler than using the class with the dollar methods but if you're not comfortable with higher order functions I can also totally understand you would maybe opt for the class based approach or you might not even have this return function but simply get a value and a list of validators that's also possible there's lots of ways in which you can solve this but my point is that overriding a dollar methods is not always the right or best solution and what's actually really important is to always keep this argument of Simplicity in mind also when you're doing code reviews always ask yourself the question hey can this code be simpler can we remove things can we make things easier to use and if you want to become better at doing code reviews you should check out my workshop on co-diagnosis that's you can get access to for free by going to iron.goal diagnosis it's about half an hour takes you through a lot of practical examples showing you how to actually look at code and diagnose problems fast so iron dot code slash diagnosis this is the link I also added a description of the video the second case where you want to avoid overriding donor methods is if it violates the principle of least astonishment I like that it's a great name and this basically means that you should write your code in such a way that the behavior is as expected and the thing with donor methods is that it's very easy to do something that is really surprising that you wouldn't expect if you use the object in a particular way because you change the way that the donor methods are doing their job for example here I have a class payment where I have overridden the new donor method so new is basically what gets called when an object is created and what I did here is that I accepted a payment type which is a string and then if it's PayPal I'm creating a Paypal payment object and if it's a card I'm creating a straight payment object and then after pay method and then these things are subclasses with with their own pay methods implementations and then in the main function I create a payment object and then I pay a certain amount so when I run this actually you see that it cost paying one dollar using stripe but that's because the payment initializer now actually doesn't create a payment object it creates either a stripe payment object or a Paypal payment object which is very surprising because if you look at this code you would expect this thing to be a payment object which well it is due to inheritance but you wouldn't expect this to create anything else then a payment object and that's potentially very confusing you may think it might be nice because now we can pass a string and that's going to determine what kind of object we're going to get which can be useful you know if you read the payment type from a file or if you get that from an API call or something like that but by doing this non-standard thing you're potentially creating all sorts of problems because for example a developer might look at this and think oh hey the payment class doesn't have a pay method implemented so I should probably create my own subclass now to actually Implement that payment method but notice on lesser because we already have those but that's not clear from the code itself basically it just makes your code harder to read or to reason about so avoid those type of things so how do you then implement this in the correct way well here I have an example where I slightly change this so I added a payment methods class using python 311 string enormous by the way I still have my Paypal payment and stripe payment classes and then I have a function create payments that we provide with a method so that's one of these two so that's exactly the same behavior as we had in the before version and then depending on what the method is I'm creating a different type of object and then I'm using a simple payment protocol class that simply States hey you're getting an object that has a method called pay that's it and then we can use then almost the same way so create a my payment object with by calling create payment but now it's clear we're getting something of type payment and then I call the pay method on it and this of course gives me exactly the same result except that now I'm paying a hundred dollars using PayPal a third reason why you might want to avoid overwriting Donald methods is because it can have performance implications not so much the Dynamics themselves because they're at the core of what python is but by implementing them in the wrong way it might lead to Performance issues because these Thunder methods are being called internally by python in many different places for example I have a point class here the same one I showed you at the start which has a comparison method and I also have this wrapper method and let's say I wanted to be smart and think like hey you know what if we have three dimensional points I don't want to have to change the comparison operation I simply use the string representation of the points and the other thing and then I just compared those things and if you want to make it a bit more precise we should probably even use a not string but wrapper because that's actually what we want to call right this may sound smart because now I can do this and add a z value like so and then the only thing I need to change is here self dot Z and now I don't have to change the comparison operator sounds like a great idea but by using the string representation this is going to have serious performance consequences I have an example here main functions where I create a bunch of points so let me also add the Z value here and then I create a Target point so also add that and then I measure the performance of this particular operation which checks if Target point is in the points list and this operation in USD equals dollar method to perform the comparison to verify that an object is actually in the points list and then I'm running that like uh 10 000 times so when I run this code you see that it takes two and a half seconds which is quite a long time well it's also 10 000 points you might say but I have a simpler version here and to make it fair let's also add the Z value here there we go here I'm implementing a more traditional way of Point comparison which is simply comparing X Y and Z and when around this 10 000 times then this is what happens so instead of taking up 2.5 seconds it now only takes 0.2 seconds so that's a factor to 10 performance even more performance Improvement so the bottom line is be careful when you override dominant methods make sure you're not accidentally affecting performance and the fourth reason which is a more General reason for avoiding overriding donor methods is that they may hamper readability of your code not all developers are comfortable with seeing Dumber methods and they might not fully understand what a dollar method is doing or when it's being used and that simply makes your code a bit more complex and harder to understand and in the end having code that's easy to read easy to understand is actually a very big asset so that's something you should always have in the back of your mind the bottom line is be mindful of the extra complexity you introduce by overriding donor methods and always ask yourself the question whether that's really necessary or if there's a simple way to achieve same thing so good examples of when to override domain methods are when you need to implement custom Behavior like string down the methods when you want to emulate built-in type like addict Or List when you need operator overloading for example if you want to build a mathematical library or when you need to have contact management and you need to implement the answer or exit methods cases where you don't want to overwrite Dollar methods are if they introduce unnecessary complexity um after violating the principle of least astonishment and it leads to your code not doing the thing that you expected to do if you don't have a clear understanding of what the effect is going to be on performance by overriding the donor methods and finally avoid overriding dominant methods if you want to make sure that your code is easy to read and easy to maintain by a wide group of developers with different levels of skill S I hope this video gave you some food for thought on how to deal with the flexibility that python offers us another area where python is really flexible is that it allows us to choose between functions or classes now I typically tend to go for functions initially and only use classes if that's necessary but there are some other considerations as well in order to take that decision of when you use a function when you use a class if you want to learn more about that watch this video next thanks for watching and take care