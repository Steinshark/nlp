orders of magnitude are a real testing ground for architectures every time your demands on a system go up by a power of 10 I think the game changes and gets more interesting so this week we're going to think this through in the Realms of databases one query a second that's easy mode even even an analog system like a podcast host can manage one question per second 10 concurrent queries a second we've just lost Microsoft Access last time I checked I think it had a single Global lock system so no concurrency farewell access not going to miss you too much I must admit but pretty much any other database should be comfortable in the 10 to hundreds range for concurrent queries by the time we get up to a thousand the game begins to change some relational databases will be happy with that some are going to start to push you towards connection pools caching read only replicas and that's completely fair enough they have a lot of work to do which isn't just to do with querying but I think above the thousands range we are probably leaving a lot of pre- interet architectures behind Okay next level up 10,000 queries a second that one might even tax your operating system depends of course but you're probably in the realm of tweaking kernel parameters definitely load balancer parameters at 10,000 we're maybe even thinking about clustering multiple machines and that is a game Cher but even with that I reckon experienced but naive me I reckon I could build a system that handles 10,000 concurrent queries a second provided I get to choose the kinds of queries we support and I know that's a big caveat next level up I have got to call it quits I'm lost at 100,000 queries a second I don't know how you'd architect that I really don't so it's time to call in an expert cuz I know it's possible I know they manage that kind of scale at places like LinkedIn and Uber with a little something called Apache Pino so who do I know who's a Pino expert Tim Bergland and he's about to do a wonderful job of taking us through the architecture of penino and the constraints that go into building a query platform that gets a good balance of flexible arbitrary queries and a really high performance Sweet Spot I'm intrigued by that I want to know how that's built and Tim is not afraid to go down into the guts and explain it and as a bonus this week Tim has a wonderful voice for radio so this week the name developer voices lands particularly sweetly let's hear from him I'm your host Chris Jenkins this is developer voices and today's voice is Tim berland [Music] joining me today it's Tim Bergland Tim how are you Chris doing great as my grandpa used to say any better and I'd be twins it's good to see you I've not heard that one before it's no no you're grandfather must have been a creative man run in the family definitely was I um so the reason I've got you in and I'm going to back I've almost literally just got off a call with a friend of mine who's kind of a junior developer looking to get into the larger world and he asked me why we why there are different kinds of database and particularly why there are transactional analytics databases I gave him my best answer but it wasn't recorded I'm not on record you see what this is going go on record why why do we have different never really thought about that one now [Laughter] it is an excellent foundational question and it's good to remind ourselves of of some of some of the wise um I've just been doing a lot of history of tech reading and interviewing and assembling and kind of looking through that from a historical perspective um which we needn't entirely get into but you know computers digital computers started out as batch analytics machines so at first you had a a bunch of stuff on on Punch Cards you fed it in and you processed the data they were they were doing analysis yeah um and then you hook up a terminal they get a little better a little faster a little cheaper you hook up a terminal and you can actually interact you know you can you can write an application where now some knowledge worker can can do things and as it were input transactions you know do do crud over entities um yeah so now there's this idea of a database that's changing and um and and yet you still need to find the story in the data fast forward you know a few decades let's just kind of aideed aideed that for purposes of of brevity um I think it comes down to this uh when you're in transactional mode generally speaking okay as a as a first order approximation you're usually worried about a thing you're making a thing you're trying to select a thing by an ID uh maybe to read it maybe to to read it and change it put it back um but there's there's usually the one thing that you're optimized for and in analytics you're usually looking at many things you you want to find you know I get into this ideally not read through the whole database but but select in some intelligent way the things you're interested in get some measurement and and run a reducing function over that measurement basically you know that kind of filter aggregate or fil filter uh filter aggregate thing is is sort of the bread and butter of analytics and so you're concerned with these things so transaction world you have this thing analytics world you have these things and um the the the physical world being what it is uh you know with the limitations of of Just The Way M ma Mass works and electricity works you know you can only do things so fast um it's it's probably impossible to build one system system that's optimized for both things if you look just think about caching okay okay just think about caching for a minute uh caching is going to be your friend because you're you're doing IO and there's various tiers of ways of storing things and you're going to want to cash stuff in the transactional case uh there's you know you're you're reading and writing a certain number of of IDs these these things and there's probably a small set of your overall number of objects documents in your database that you care about that is amenable to caching right that that works well you've got this power law distribution probably of of your stuff and your doing this well now layer on analytic queries on top of that and that distribution is at least going to be have a a a fatter tail you know you're you're now scanning all these things maybe all the things sometimes and and well that's not amenable to caching you don't get to do both of those at the same time so you're not going to be able to build one system that that does both well um okay yeah that's how I think about it I think there's a lot of ways you could tackle this but yeah but this is why you know this is the joy of uh running this podcast I get to see different people's ways of thinking I'm um I can hear someone in my head arguing that they have got a system already that's optimized for both but your definition of optimized is a lot more focused right I mean I can take I can take an Oracle database I think and happily get 200 parallel connections yes and I I believe you wouldn't be impressed by the number 200 I well depends what you're doing um you know there's there's uh the the old kind of departmental database of the 90s that that Paradigm and moved into the world of the web at some scale you know that might be great um if you're looking at a broadly scaled smartphone app or a website with you know user population in the hundreds of thousands or millions and a lot of concurrent users and serving queries um you know live powering features in that application then that's a horse of a different color still really achievable in the transactional world with kind of the received tool set like we know how to do that in the analytic world that's that's a very different thing right no Nobody Until recent very recent years has thought oh yeah let's let's do that analytic filter and aggregate group and aggregate kind of thing um in the user interaction Loop um that's a little bit of a Leading Edge kind of thing yeah yeah at that kind of scale so coming at this from a solid background of relational databases and how they query right how how do you solve that problem how do you go from the system that will happily do 200 parallel queries happy enough to hundreds of thousands yeah um well if it's okay I'll take the the transa or the the the analytic end of that I mean there's there's a lot of answers to how to do this on on both sides of that divide yeah um and there's lots of folks who kind of have solutions for the the the transactional side of things you've got the Cassandra kind of approach um you know you've got various ways of scaling a postgress kind of thing you've got cockr DB and um you know all all those on the the transactional side on the analytics side um you you kind of have to engineer a system with those requirements in mind you have to say you know what what we want to do and and by the way we need to back up a step and say um you said coming at this from a relational database background you know the the tradition of Analytics sort of pre- big data in the the span of careers of of people of a certain age you know kind of going back to the the 90s all that stuff happened on relational databases traditionally right it was fine that that was the technology I mean you you built schemas that that didn't look anything like the third normal form you learned in college but uh relational databases can do these things but if you're going to go to this kind of scale it's it's a it's a different tool set if you're if you're has to change the architecture has to has to change because you've got these non-functional requirements that present themselves of you want you want you know orders of magnitude literally maybe uh 100 a thousand times more than those 200 uh concurrent queries um so you got you got kind of radically scaled concurrency um a freshness requirement a sort of a streaming ERA Real Time data era freshness where an event happens and it takes a couple three seconds to make it through a streaming Pipeline and and then it needs to show up in results right it doesn't doesn't get to wait around you're not there's no bash job um and latency again if if this is going to power not um again the origin of all this is kind of printed reports right um yeah originally printed on green bar then printed on Laser Printers that all turned into dashboards um in a browser tab um and and those are the typical dashboard is just a faster report right and if it's the data is 15 minutes old it's probably fine you know it's that's not a big deal if it takes a minute to refresh something that's great nobody's gonna get excited but now if it's a feature in your user interface I tap on a thing and and a query happens I'm not gonna wait right that that needs that's you got 100 millisecond you just don't wait that all no I I certainly don't I'm I'm it's not a positive character trait but notoriously for things like that even people like in marketing who want those reports or an analysts and they will wait 15 minutes CU they're being paid to they'd rather exactly but you know users making choices of things people like me that's make a break that's make a break so yeah you get this concurrency latency freshness uh Triad of nonfunctional requirements and so uh you have to you have to start from the beginning and um the I think the the fundamental kind of rate limiting thing that goes on inside an analytic database anol app database is uh scanning right you're you're getting to where there is some Metric that you're trying to aggregate yeah uh you know you filtered and maybe you're grouping by some other thing but still you got to you got to scan values of some Metric that's the hot spot um and so you want to uh there there two things you can do do one is scan less and the other is scan faster and I I hope that that brilliant Insight oh good Tim thank you for explaining this yeah I'll go with that I'll go with that so far today's episode of developer voices is brought to you by um right so you can scan less you can scan faster and so um uh I I go oh I'll give you a third one you can split the scan over multiple machines exactly and that is uh uh it's a corollary to to scanning faster you're and it's and I it shouldn't be a given it should be stated but like any system like that these days if it's not duck DB is is going to be a distributed system you know there's there is that interesting case of like hey what can I do if I don't want to be distributed you know yeah what are cool things I can I can do in analytics database and a system like Duck DP is is all that but yeah you're going to split the scan over multiple machines so that you can in effect scan faster yeah okay so patchy Pino I mean there are a few options out here and they they all take slightly different strategies to get to that glorious scan faster scan less scan over multiple machines thing and I'm interested in design choices that Pino makes to get yeah shall we just uh kind of walk through it yeah let's just let's go right down into the give me some give me some date structures ex yeah right this is I said to my wife give me some data structures oh yeah we talk about that all the time okay that one might not work for me at the same way but um so [Music] um let's um yeah okay so the fundamentally in Apache Pino um you've got tables there's there's nothing weird in terms of data model in terms of query language you've got tables they have columns columns have data types you query the tables with SQL nobody gets hurt right um of note skipping around to the side a little bit you don't create tables with SQL you create tables with Json um and and that's I I it's an interesting design Choice the the kind of classical way is like okay I'm going to create a table I'm going to give you the schema and then I'm going to tell you a little bit about some indexes that I'd like and we'll sort of build this thing up over time and mutate the thing you know yeah um and typical vendor extensions to create table like well here's the schema and here's this custom bundle of key value pairs I'm going to put in there you know I think the approach that penino takes is that that this is this is going to be a complex thing let's just kind of back up and here's a here's a Json spec and you'll you'll create a table Define a table that way so anyway you got a table um um and and that's not essential uh obviously there there could be a future change where more DML is is implemented and you can kind of do it syntactic sugar over the top of that exactly exactly um but see you get tables tables are broken up into pieces called segments um and this is the the fundamental structure that that leads to the distribution that is the distribution model in Pino right uh so as a table is created there's two different ways to create a table one is out of batch data the other is out of streaming data however you're doing it you're creating segments and so a segment is a uh an approximately time ordered time time delimited chunk of rows and okay why time is your like segmenting strategy um and and it's not it's not strictly I mean you wouldn't you wouldn't call Pino time series database but um you uh it's I say approximately because say say the the batch ingestion process right uh maybe there's a collection of parket files in a S3 bucket and you're you're ingesting those you're iterating over those and and you'll iterate over them and say well I've got enough I'm G to call that that's a segment I've built a segment let me let me load that into the cluster okay uh and so during during that process um and in the streaming case when you're ingesting say from Kafka that's a bit more explicit you know you have messages that you're consuming and then you cut that off um okay it's um yeah I probably shouldn't even say time because that gets us thinking of a bunch of questions and maybe we can dig into those but um but but we're starting think about the difference between The Logical table which you're saying feels very familiar and the underlying dis model which is where things get tasty hey it getss tasty yes you have these segments right um segments and it would be worthwhile to let's just let's just call a segment a chunk of a table for now it be good to dig into what one looks like in a little bit but um here's this chunk of rows and um we need to put them somewhere so um that's that's now let's get into kind of the physical architecture of of Pina the the components of the cluster um there is a component called the server or the servers and uh um I don't I don't know if I'm the only one in the the Pino world who maybe regrets that naming a little bit because it seems like kind of aren't they all servers uh but hey look there they are they're really the true heroes of the cluster they store segment data and they do when it comes time to compute queries they do most of the compute work okay um yeah so uh the segments table is composed of segments segments are stored on servers um and let's see where shall we go next um would you like to talk about how segments are built or do you want to try to do a query let's let's go through a query and we can dig in on the way yeah okay so in ingest and more to say about that the inest process creates segments segments are distributed uh among servers through some process which is interesting in itself and now here they are you've got your table there these segments um maybe there's you know one server in a Docker container on your laptop maybe there's 300 in your cluster in production yeah um to make a query happen we have another element we introduced these are called Brokers um there are usually fewer Brokers than servers but it is again a scalable element and this is where uh a client process will actually connect to um an endpoint uh you know an API endpoint on a broker submit a little Json query document that basically just says hey here's the SQL I'd like you to execute um and that broker now will take that that uh query and say all right um we've got some table is implicated there I see some predicates and here's you know maybe the you know the the uh aggregation operation not going to be of of so much concern to the broker but here's a table and here's some predicates let me try to figure out which servers ought to or need to do the work of doing of executing this query because it'll it'll based on uh metadata that it's that the broker knows should be able to make some good guesses about where the necessary segments live depending on the predicates depending on the table metadata it's going to try to route that query in a Smart Way in other words not just it to all servers that have any segment of that table sometimes which would have to do but you don't want to do that the the word guess is interesting there guessing yeah you say it makes some guesses about which servers to talk to okay um that's I think me being a little anthropomorphizing a little too much it's actually not probabilistic it's deterministic we no you do know okay good good you know uh either we can prune certain segments from even needing to be consulted right uh or in you know in the worst case you can't and you're literally going to scatter to everything and and and do a lot of gathering so it'll it'll do that it'll figure out um which servers should get the query and there are you know various levels of configuration and optimization and things that that you can introduce to to help that work well uh but in the basic case you've got say maybe there's a a Time column um and you're going to know well this segment definitely only I'm aware of that time column I was aware of it at inest time it really only has things from time T1 to T2 and your query has a predicate outside that range I'm not going to bother with this segment right yeah yeah what if um I I may be derailing your architecture diagram but what if like I can see how let's say you've got all the food all the data coming in from Uber Eats right and I can see how that be spread over 300 machines whatever now I come along and I am hankering after barbecue food as an analyst so I want to know like how much money was spent in Texas since the start of the Year okay right so that feels like the start of the Year isn't a very useful filter and I'm going to really have to hit a lot of the cluster yeah to find all the places with the Texas in and that's okay um I mean that's that's fine the and you as an analyst who likes barbecue food I definitely love that Journey for you um and want to help you with that query right um but the the the Main Place Pino is pointing itself is more towards the person who says I want some barbecue I'm in San Antonio it's six o'clock um you know what's going on right now what what what like what's my what's the delivery time now um based on you know the recent history and and and things happening in the last few minutes even if it's 610 delivery time might be different than 557 um okay so you are explicitly optimizing for queries that have a a sensible date range um not so much that no I mean that that large date range is fine that's just going to be a lot of segments that's maybe going to be a query that takes longer there's more scanning happening um but the the user facing analytics use case is more what Pino is thinking than the internal business analyst facing thing um now that's that's not exclusive there there are in interesting real-time internal facing um business analyst cases uh but I think fewer of them than once analytics once once you take that same set of data and turn it into a feature in your application and deliver it to a user then that latency concurrency freshness Triad of non-functional requirements impose themselves on you and you need all this stuff that Pino does if okay if you're just saying you know which zip code sold the most barbecue at dinner time in January or since January yeah it's okay if that takes a minute I mean who do you think you are right just go ask snowflake it's going to be fun um that's interesting because as I say design choices lead to different sweet spots right um and how it plays out in the world it's interesting that you're optimizing specifically for a kind of interactive user and that's well that's how Pino was born and I there's there's a whole bunch more architecture to get back to um and I mean hey you're asking the question questions here so we're going to go there but do you want to do the origin story quickly or it's it's it's important I think yeah um okay we benchmarking your origin story against Madam web in cinemar for about three more minutes if you can do better than that you're doing actually if you can only do better than that that's not good enough that's not a lot yeah um ouch well okay it was born at it was born at LinkedIn just after Kafka so as the the Kafka fication of LinkedIn was happening um and and that was really you know the framing of that story as we get it really has to do with data pipelines and not so much reactive microservices and that that whole angle of Kafka and I know there um you know links in the show notes you've got some great episodes that that talk about both those things yeah um thank you uh yeah um the recent Bobby Calderwood interview I think for for reactive microservices I mean that's that's my description of it I don't know if that's what you guys you you or he would call but I thought was great um so you've got Kafka creating these real-time pipelines and and sort of having its impact uh at LinkedIn and now there's all this realtime streaming data um but LinkedIn was still uh a resume and Rolodex site it it wasn't the interactive social media site with a feed that we know today that I visit often um and the first thing that they you know somebody conceived of this idea and I I need to find the PM interview them uh but the the who viewed my profile part of the site and yes that was the that was the the beginning of real-time data and they wanted it to be real time I mean strikes strikes me that you could make that a batch thing and it would work but that's not what they wanted to do so they built this and I they had it was either elastic search or something like elastic search they had a you know a Search tool and they they built it and did the the what was essentially an analytics uh use case on top of that and they used like a thousand nodes of whatever this search search kind of was back then that is probably how you would have done it yes yes this is like 2013 uh said well that's bad and and it's kind of funny to hear kishu gopala Krishna he's my boss co-founder of star tree co-creator of Apache Pino he didn't want to write a new database I mean then this is this is really the story of I think like a a relatively healthy person what's the one thing you don't want to do well you definitely don't want to write a new database that's terrible idea right something has to be wrong and he tried not to but that the team ended up building sort of primordial penino right yeah in the origin story they took that thousand nodes down to 70 uh with increased traffic and then decreased latency and just all these wins and like okay this might be something and so it was born of a user facing analytics requirement and then at LinkedIn they started using it for lots more things like that you know analytics on posts the feed is built on penino queries so you're you're doing lots and lots of Pino spread there from uh from LinkedIn and uh this was this was the early days of of gig economy meal delivery so door Dash was relatively new and Uber was responding to Door Dash by introducing Uber Eats and uh they adopted Pino to to drive some Uber Eats functionality and okay let's get back to the architecture you've brought me nice back to thinking about food so if I've got that what's going on in San Antonio right now that I can order query take me through how the architecture of that is processed got okay so comes to a broker we're going to look at the wear clause and see can I um and and well okay sorry we're a broker right yeah we are in possession of uh fairly comprehensive cluster metadata what tables there are of those tables um what segments there are what servers they're hosted on how they're replicated um and perhaps certain other things one might know about the data in a segment like time ranges um there is a notion of partitioning which we'll come back to when we talk about the the Kafka integration um so a broker knows all those things and I'd like to just take a brief detour to introduce another comp opponent um the broker knows those things because there's this element called the controller uh that really is the the metadata uh Clearing House it just makes sure uh metadata changes happen to the controller and it's responsible for pushing them to Brokers uh and making sure that that Brokers are always up to date with the current state of the cluster okay so it's not the server telling the broker like I've changed the server tells the the um sorry what did you just call it uh controller and actually what happens is when you um load a new segment that is you know insert data you've you've ingested some new data you tell the controller um and the controller then makes sure that data gets to the right servers and then pushes that information those metadata changes to the Brokers okay so it's the it's the the place where metadata changes happen in the cluster and and needless to say there's a little zookeeper hanging off to the side actually remembering all these things you know inevitably it's it's and thinking of itself as the the true and perpetually undervalued hero in every distributed system yeah absolutely anyway that's we got up basically we might get to minions if there's time but that's the the the pieces on the map we can do a query now okay query comes in broker being in possession of all the metadata because the controller is helpful and does its job uh says all right based on my predicate um I'm going to I I I see that there are these seven uh segments let's go with eight segments um otherwise we think are you trying for power of two here yeah no no no actually we'll go uh go five there's five there's five segments okay five segments that are implemented or implicated in uh this query and so now the broker will say um to to how many servers can I scatter this query uh because it would like to parallelize that work right right now uh I'm I'm gonna avoid going much down this Rabbit Hole there's a there's a page in the docs that does a pretty good job explaining this but um you on the one hand want to scatter so that you parallelize that work that was one of the ways that we could scan faster right yeah um on the other hand um you know maybe not necessarily all the way all the time because uh that will increase tail latency that will reduce um reliability you know you components that can fail or you might have a GC somewhere so there is this little bit of tension between I want lots of people doing this work and I don't necessarily want everything doing this work yeah parallelization isn't free so you you build in that cost exactly exactly query routing is a is a deeply complex subject with lots of little knobs in it um but in basic case if you don't want to touch the knobs then this thing happens the segments are are distributed to servers uh the the broker will figure out which ones it will then scatter the query to those servers and one server might have two segments and and need to run this query across two segments might have five of them you know it's it's it's it's however that works out but let's just say it's it's nice like we were building a slide for a presentation and there are five segments and there's one each on five servers and it's it's a beautiful world and gets scattered those um servers now uh do the filtering and scanning they they do the io on the segment um and do the compute whatever that might be uh you know I've I've I've scanned this metric it's delivery time or it's temperature it's whatever uh and now I'll average it or do whatever it is I do create that result set and those servers then send that back back to uh the broker the broker collects all of the results it has scattered and uh does that final reducing operation whatever it is and and and you've got a result okay so there are shades of map produce inside this map produce always always pop it's down in the corner winking at you and you thought it's what 2024 you thought you know 11 years ago you you were too good for it and it was a pain and it's just there and saying yeah no I'm I'm still I'm here and you can't get away from me um it gets better okay it gets a little more mapper here uh okay I mean the thing about ma ruce is it it it really was a quite General Paradigm that that just simply is the case um yeah yeah if it wasn't invented someone else would have it's kind of discovered invented it it was discovered and and keeps getting rediscovered so yeah that's the uh single stage query engine I just described um right I can um bu configuration um or by an option on each query say I would like the multi-stage engine please because that single stage engine works real well for that filter and aggregate thing I just described right yeah um but what if it's a join what if I have two large fact tables um that I have to join and then do some computation on the result well that that would cause you know gigabytes or more of of results to stream back to the broker in you know a really ugly case uh and Brokers aren't built for that so uh the way that works is in the multi-stage case the broker will compute this multi-stage plan it'll figure out well yeah okay to to begin with you know the kind of root scanning that we have to do to get started sure these are the servers uh that that are going to do that work but they will then stream and Shuffle again M produce down there like I never left um thinking of the uh the two astronauts looking back at the Earth it's all MCE isn't it always was yeah so anyway the um that that first tier of servers will stream you know potentially lots of data because now this is built for this to another tier of servers not brokers who might say and to make this a little more explicit say there's a a join an inner join uh and then an aggregation on the results well you'll do the left join maybe a filter if you can sorry the the select for the left table may be a filter if possible the select for the right table maybe a filter if possible servers are doing this work they'll stream the left and the right results to another tier of servers who will actually do the join right stream to another tier that actually does the reduce uh the whatever the aggregation is and then um stream back to the broker back to the broker the Brokers so the initial the broker at first is doing this query plan and then almost drawing a map for the how the data is going to travel eventually back to me yes yes um and the the the Shuffle step which has to happen there is because if you're doing say an inner join uh you know at some point you you've got a leftand table and you got to go look at a thing that's your right-and table and what is that thing well it's going to be a key value map in your memory probably right so you got to get those keys in the right place and is it as it's shuffling that is it resharding it so you're trying to deal with a subset of the keys on each later stage um um that's a good question I imagine the answer is yes that gets to a part of the engine i i a level of detail in the engine that I don't know but um there there can be many stages there and so that that is likely that that happens but I don't want to commit to that answer because I'm not sure okay that's fair that's fair this is uh this is but this isn't quite a job interview or an exam you don't call them exams you call them tests very different maybe it feels like an exam over here it well I uh I I know what this podcast is about this is not a podcast for fluff so I don't I don't all okay good okay so I can see how that works but since we've mentioned map produce let's mention it one more time my first Association of map produce was Hadoop as it was for many of us poor souls and I associate that with parallelization I do not associate it with speed no no you don't convince me that this process be quick yeah yeah well um I mean the proof is in the pudding right there are folks who who publish results of of how this stuff works it always depends on how big the data is what the cluster is like I mean you know there are so many variables that that yeah um you know we almost need like NASCAR you know there's like one car that you can build uh and then the driver is the one that that uh that really competes I can't believe I just use a NASCAR analogy with you I I I just this is none of this is lost on me but um it's podcast British host let's talk about NASCAR um I'll pretend I I do actually know what Nascar is so we're we're on good ground there you go and and and no disrespect for the the whole ecosystem there I'm just not not a part of it but I mean the idea is the the car is standard and and the driver is what differs and if you had like a standard cluster and a standard data set then then you could start to make some some comparisons but this is all there's just everything's happens in oranges in this world but okay yeah um no it's this this again the design of this thing of of of Pino and the the the controlling kind of set of of non-functional requirements as constraints um concurrency freshness latency um that first kind of query you know the the filter and aggregate yeah thing bread and butter single single stage uh engine uh there are documented results you know users not star tree yeah um of like 10 12 15 milliseconds P95 latency uh on on meaningful production data sets yeah yeah but what I mean is so I'm not doubting the speed what what I'm kind of asking is I mean what's going on cuz 12 milliseconds right from the architecture you've described you could easily have spent that already just on networking and serialization uh so yes and that's not a join right so one of these fact TOA fact joins on large data sets and that this could be a query that takes a second um he said with horror yes yes no that that's that's not a a typical Pino kind of latency but again once you start coming off you know coming away from the hyper optimized thing into generalized joins well yeah it's going to take a little bit but not not Hadoop time that's the whole reason um and and the world into which Pino was born was a world of Hadoop and Hadoop pivoting into spark and and same thing with spark I mean what are you going to do that that takes less than 10 seconds that's that's the that's a fast thing you know yeah um that's anathema and we get into reasons for that but um I there are interesting decisions about the coupling of compute and storage the pre-allocation of storage the pre-allocation of compute like are these things going to be on demand or reserved and and how tightly coupled are they going to be and there's kind of a you know you can make quadrants with those two and and Pino lives in a place on that quadrant typically where storage is tightly coupled and storage and computer pre-allocated they're they're ready to go you don't go find resources the resources are there and the compute happens in the server right where the data is on an SSD on the other side of a pcie connection um and and that that coupling is key to the scan faster right is it going to typically be the case that the Brokers and the servers are on separate machines but in the same rack um yes they will likely be in the same um rack you don't know but um you know same uh availability zone for a clout deployment and okay definitely separate machines right in that case I think to get the next piece of this puzzle we need to start talking about indexes because we haven't mentioned that at all no and that is a a key place where penino has decided to elaborate and introduce complexity and and differentiation and things so okay uh key key point um is it a good it might be a good time to to just remind ourselves those segments that that we make when we ingest data um those are columnar in nature so you've you've got inside a segment little little chunks of contiguous storage that store the column values of a table in no case you have a row all stored together um that goes back to the are you transactional or analytic if you're transactional or oltp you want the thing and probably the whole thing so put the whole thing in one place because you want to deserialize it or serialize it all at once if you're analytic you're you're you're probably scanning over some chunk of metrics so metric values so put those in one place right yeah so um so when a when a row comes in you're actually creating lots of different segments one for each one for each column right yeah well it's it's called a segment but internally in that segment you've got chunks of columns yeah right and indexes indexes uh a segment is all of The Columns of the rows that it comprises plus the indexes that you've built on those so what have you got um uh of of note there is um an invert inverted index um you know I've got this value can you tell me the the documents rows in which this value occurs um that's good for you low cardinality Dimension type columns city state country um there are a couple of different text indexes if you've got a column that's a a blob of of text of unstructured text um Pino has essentially uh a text index that is Lucine so anything Lucine can do it can do because it is embedded Lucine and it also has recently in the last year and a half grown a native text index that's like a higher performance subset um of the the common kinds of prefix suffix uh phrase Boolean regular expression stuff um there is this is all building up to the cool index so just give me a second we're we're we're we're getting somewhere JS index yes there's a Json index so imagine I mean a lot of your data you may be ingesting could could be in Json format that you're going to flatten and things but imagine if you've got a like a a sub document uh an object sub object nested object is the word I'm looking for in that Json um that is sparse you know there there are 200 keys that might show up but you usually only have five of them say right yeah the scheme is very flexible the data is quite narrow yeah yeah yeah uh you know you could have 200 columns that would be a life choice um P gives you a Json index where you could say let's just take that uh embedded object bring it in as Json in that column and Json index it uh so now you can you know index into fields and array values and and all the all The Usual Suspects of what you might want to do are you saying specifically which paths you want to index um I don't think so no no you're not you're just saying this thing go index it and so look through all the paths in there and build something sensible yeah okay cool okay um there's let's see we've got text we've got J is a geospatial index because uh Uber was an early adopter obviously that's going to be a thing they kind of care about where things are so yeah got to know where that barbecue is that's a whole podcast in its own and I I I I will be clear I frankly know not much about uh the GE spatial index I haven't really put that through its Paces but it's there and and highly productional lied uh let's get to um what am I missing oh range ranges uh metric ranges so um uh you know something yeah just a numeric uh column um that that won't work well with an inverted index because the cardinality is very high you might have you know a number of unique values that's equal to or in the same order of magnitude of the number of rows in the table and so the range index will just chunk that up into ranges and build an inverted index out of those ranges same one right yeah yeah yeah and the cool one cool one they're all cool the star tree index not to be confused with the company called star tree which was named first the star tree index was named first right okay yes um if you named the index after the company that would be dorky naming the company after the index is cool is cool exactly and it well it is an implementation detail that leaks leaked into the interface happens to everybody um but it's cool and even if five years from now the star tree index is old news and there's newer and cooler indexes we'll still have a cool name yeah um anyway this is basically um uh like a like a a pivot table save to disk um you pick columns and and and this is the use case here is a filter and aggregate query so there are some columns that may show up in the wear clause in some order some combination of them say three of them four of them we don't know which ones are going to be there um and then uh you want an aggregation on some metric sum average whatever you can actually have several aggregations computed in in the index and it will actually build a tree of of the uh you know the the the different different values of the different um uh predicates that show up you know the different columns in the that that are that are going to participate in the index and so now you've got this log in uh search through the index where you get the pre computed aggregate so you don't even you just read the index you don't even have to go scan the column anymore so this is where you get those crazy 12 M second latencies right if you if you can pick the columns that everyone's most frequently asking about and the kind of sums that everyone's frequently asking about yes you design the index because you know there are these queries uh that are going to happen and this the typical response is when a person first first you know configures the index and runs a query everybody always thinks something's broken or like this has to be in a cache somewhere this can't be real you know it's it's too fast it's too fast I just I can't believe it stop stop you're giving me too much no but it's it's a super cool index because that is um you don't want to be limited to that right um the filter on these few things and compute this aggregate um that's a lot of what you do in an olap workload uh so you can really optimize the the Daylights out of that makes me think of Google analytics where okay so in their case you can't ask any question but there are certain combinations of fields you're pretty flexible about and you can get those quickly and yeah presumably they're using something very similar to that kind of index one imagine and failing to do the rest because I've got questions for Google analytics that they can't answer but you power users well that'd be a that'd be a good Google anal Google analytics pm get them on the show yeah so you can get Google people on the show but you can't get their lawyers to sign off on releasing it that's the thing anyway that's an aside I want to pick up on one quick thing you said um which was I maybe I've misunderstood the size of these segments but if you're storing the data and the index that seems a bit strange to me because the whole point of an index is it tells you quickly where else to go but where else sounds like it's right by way you already are um yes uh and there you want to think of a few hundred megabytes usually segments get get chunked off into you know something less than a gigabyte okay um and that's variable but that's a that's a common sort of size um but the indexes are uh are there remember that you've the broker is is doing its best to make good decisions about which segments are actually going to get asked questions um and there's a little bit of metadata um around that there's there's even an index it's it's it's called an index that's uh it's it's it's not exactly an index but it's called the bloom filter index so if you've got uh equality predicates known known equality predicates that are likely to happen on a particular column uh you can have the broker you know be able to consult that broom Bloom filter and know sorry not the broker the server be able to consult that bloom filter and know should I even bother with this so um the uh the the the reason the indexes go in the segment is because you've got these little bits of metadata where the broker is is trying to do a good job not just routing to smart smart places but um pruning in a smart way uh and so right what you don't want to do is scan through all the values in a segment you really would like to try not to do that so you can more efficiently read indexes or consult portion of the index in memory and uh make better decisions about how to scan that's the scan less priority right yeah so there is there's a thing about indexes that tell you where to go efficiently and that part that role is happening on the broker and then there's a thing about indexes of gathering the data up quickly once you're there not and that's happening on the set there's there's table metadata that the broker has that is something that the process of building an index might tell you um but it's not properly a part of the index it's just table metadata like you know we have this timestamp column we're going to tell you the first and last time uh the highest and lowest time in this segment um or you're partitioning on this other column uh you know we're going to tell you the the values of the partition key that are in this segment so that metadata is owned by the broker and it's index is you know like I said could be the output of a notional index computation process but it's not a part of the index the role of the index on the server is to optimize the actual scanning of values in a segment yeah okay I can see I see the distinction but it's certainly allowing you to narrow down a good chunk yes that was just what you want to do scan faster scan less you know you can only optimize your IO code so much yeah uh and so scan Less in in smart ways is is where you're making money okay so I'm gonna get into I want I want to gradually get into getting the data in here yes I feel like we haven't we haven't gotten a lot of we must in order to get there I think cuz we're going to end up talking about kafar I know it this I don't know how we could it's sort of contractually obligated when you and two of us yeah yeah absolutely but you haven't really touched you've talked you've mentioned but you haven't really touched on you have two kinds of tables you have bat and streaming I think you said at the start but these all seem like batch tables to me um yeah it's it's um I I think when explaining this stuff I always start with batch tables uh and the the terms of Art in Pino are offline and real time uh Now offline tables are quite available for queries all the time again we know where that word comes from but it's it's a little bit misleading so there's offline and real time tables and yet I think it's just easier to start thinking about the way real offline tables work um right because real time tables are just offline tables plus this extra thing a l from a logical standpoint okay there are also hybrid tables which are actual combinations of ingested batch data sources and ingested streaming data sources um but um let's put that to the side for a minute and let's just okay talk about ingestion okay we'll save that for the Christmas special that's for the Christmas special all right so offline table ingestion batch table ingestion um formally is done outside of the server and outside of the broker it's it's a it's a process quote unquote external to the cluster and you could you could literally there's an API you can write a spark job write a Hadoop job if you're into that kind of thing uh that that takes some external data source and and makes it into a segment um and then presents that segment to the controller for uploading into the the cluster and movement to the servers and all that stuff right so you can actually using Pino apis create segments put them put them into the server and and that's that's a little bit I don't want to say it's weird I mean it's perfectly great thing to do if if if you've got a lot of lifting to do if we could just go back to the case of I've got all this CSV in S3 or something like that or parquet files or Avro whatever it is um there are you know built in command line tools where you can point to those things and you've created the table and and you you table has a schema and you write a little ingestion job spec file the only place yaml really appears in in Peno unfortunately those ingestion job specs are are yaml uh and there's another we're going to introduce another component uh called the minion servers uh and this is where and we just kind of know there's going to be these background things you need to do right you're you're going to need to go through and um you know uh delete things for gdpr Appliance or they'll they'll be reprocessing of segment data and so the the minion mechanism is that it's just a little distributed job distributed computation mechanism on these servers over here off to the side um and batch ingestion is is typically done if you're not writing your own in spark or whatever it's done with with minions you can not even really know that right you're just kind of following the script and running the ingestion tool and pointing to the things and writing the spec and okay it's running and I can go to the UI and I can see it running and oh it's done now right uh but what's happening there is these minion tasks are being created and distributed among the available minion servers to read the inputs create the segment files present the segment files to the controller transfer them to the servers all that stuff yeah okay that's batch with good enough should we should we move to all right okay make it more complicated for me yes but more awesome so penino co-evolved with Kafka right Kafka was was young and I don't know what version I have to look at the history but it might have been like you know before Kafka even had replication there was there was protop Pino being built alongside uh and so the grapes were being squashed they were they were being squashed before Kafka was was the force it is now and as a result its integration with Kafka is um very um what's that first class filial you know they their brothers sisters growing up in the same home right um and so the the the typical way if you have a database and you have Kafka you know you have maybe something like Kafka connect to read from a topic and write stuff into the database none of that here penino is its own Kafka consumer uh and so when you have a real- time table part of the and and we could consume from pulsar and Kinesis and other places too just keep keep talking about Kafka here to keep it simple part of the table configuration which remember is this Json file uh literally contains bootstrap server URLs credentials topic name to be a real time table is to be connected to a streaming Source oh I see okay what you do is you consume messages from that streaming Source um and have options like do I start at the beginning do I start at the most re all that stuff is is is there um but that's that's what it means to be that table and so as soon as you create a real-time table uh it's going to try to connect to that Kafka cluster and start consuming and and it happens okay is does that mean that the there's a minion looking at a cafka topic reading create constructing a segment and what's it going to do is it going to wait till it's got several hundred megabytes and send it off to one way to do it which would be terrible yeah uh and so uh the answer is no minions are not involved in realtime uh table ingestion only servers so um the controller is going to make some decisions about you know how many partitions there are how many servers need to be involved um and there's there's actually um is it it's not time for this yet we're going to come back to this let's just let's just say the server well we'll add layers onto this but servers are Kafka consumers directly uh and so uh the server is told by the controller um this is your topic you consume from it it may even be told um don't let the cluster tell you what partitions you get you are consuming from these partitions and that's a configuration difference fact we just go there uh there's the the difference between the high level and the low-level uh consumer and the highle is hey server just take stuff you know consumer group protocol you'll get rebalanced you'll get partitions nobody gets hurt low level is um we are going to keep track as a cluster of the key of the partition key and its values and uh these partitions will be assigned to you these partitions will be assigned to you you you only get to consume from these two partitions um and then that partition key if it's a column in the table and it shows up in queries later on now we've got a new way of pruning segments uh because we remember what we we know based on you know the segment that gets created we know what what partition it came from um right right yes there's uh detail in there it would it would I would I would like to just keep it at that hand wavy it's trust me it's cool if you know you have that as a predicate now the server uh is a Kafka consumer whichever way it works it's it's getting messages uh and as soon as it consumes a message it puts it into an inmemory data structure called the consuming segment and right that consuming segment is participates in queries just as if it were a segment on disk okay um and so that's the key as soon as a mess message is successfully consumed from a topic it can show up in a query result so there's there's there's no additional latency there it's in the consuming segment we're done right okay that answers my question yeah that's yeah that's that's why it's not that terrible thing and then it fills up for whatever you know your configuration knobs that Define what fills up means yeah uh now we create a segment and there's a whole process where the server uh you know has various ways of of talking to the controller and the controller is going to make decisions about what server that segment now lives on and it might not live on the same server as the one that was gathering it up it's possible for it not to and we we get into stuff here where um I I I start getting fuzzy on the details of these things yeah we'll sa that for p 202 this yeah this is way down the it's just interesting that that can happen yeah and and yeah so uh you got the consuming segment it participates in queries and then it's just creating segments uh through a process that looks an awful lot like what a menu would do okay so it's quite a different mechanism under the hood but the end result is transparently the same segments on disk uh this segment like thing in memory that is a segment for all I can tell um and uh yeah and again if if I've got a bunch of batch data sitting around that has the same schema as my Kafka topic then I can create a hybrid table where I've ingested that batch data and I keep ingesting new stuff from the Kafka topic and um under the under the hood there are actually two tables uh but that gets abstracted away and I I just I just see one okay yeah it's great oh there's so much more I can go into but for time I think I should probably pull back out slightly to user space there you go yeah because I I know there are some fun ways that people are using this and I want to get some idea how it's being used in the wild so yes um a fun thing last Christmas uh early in the season Last Christmas I you know it's just I want to say you gave me your heart I knew you yeah very next day I gave you my heart very next day you gave it away um you were supposed to save that for the Christmas specialty there you go but it's you know every day can be Christmas really you know um I believe it was strike uh published a dashboard around American Thanksgiving time that that weekend um that was fed by real-time data of transactions on their payment platform seeing live updating numbers right um now that was to some degree I think um advertising on strip's part right like hey look we do lots of stuff and and they've got a cool story you know you think of mom and pop and small merchants and and um it's great stuff to talk about but they are penino users and so all transactions um through the stripe platform um live in Pino and so it it uh and there there was there was more to that story there are a bunch of interesting pieces to that that dashboard yeah um on the application side and and all that but with all that data in Pina well it becomes fairly straightforward um to to build such a dashboard because those queries are are going to be cheap things that you just get to run and and uh show to uh web users and the application programmer there is genuinely expecting to run each time it wants to display that is it going to probably be running a the same query I mean are you expecting the the web server to run as many queries as there are users asking for the data um now my my answer is in terms of the shape of what it feels like as an application developer to use Pino my answer is yes and I don't know in the case of that since I'm talking about a specific thing that happened just a few months ago there could be more details there sure but me as a developer I would I would be I wouldn't be immediately thinking oh connection pools extra caching layers that exactly exactly you should you should guard yourself against thinking extra caching layer um now caching is not bad caching rules everything around us there you go um it's it's an absolutely necessary part of of computation at every meaningful scale in our lives I'm not trying to say it's somehow bad but when it comes to data um particularly analytical data uh the answer used to be let me pre-compute this and put it somewhere I can read it let me run this job and fill up my key value store because that's the only thing that I can query with the latency concurrency and freshness requirements that I have to be user facing and now it's out of day and I have to precompute and if it's multi-dimensional my life is terrible and all this yeah when you when you go to that I'd better cash this that thinking is an artifact of the way things used to be and that's not how you want to use penino you want to use penino like you'd use an application database and I you know suppose there's been caching there as well but uh you'd rather not right especially if you're if you're actually reading and writing entities you know I don't want the cached version of my account I want to see what my actual account is right now yeah that's that's nice because I mean writing that caching code is never fun and always ends up like you've accidentally got a second time of database yes yes it's it's and again I'm I don't want to be heard as you know giving some sort of anti-h invective it's a thing but in it it's it's a very specialized kind of thing and um you as an appc speaking to fellow application developers you don't want to build that um that's going to be hard to get right and so Kino is trying to say that's not a thing you need to do anymore we've got analytics just ask me the question and yeah yeah there you go nice because no one no one builds cashing because they want to they build it because they have to right right unless they are specifically doing and I want to build data infrastructure kind of motion which is great I'm glad there are people who do that and that's sort of what this episode is all about yeah but yeah you don't as your job as an application developer is to not build data infrastructure yeah yeah cool so if I want to go and give Pino a try where do I go and what do I expect to happen to me next there you go um you could go to devstar tree. that's my favorite place uh for people to go and there's uh a little link quick start at the top and the current form of this as we record this episode is is a oneliner um it's a it's a Docker image it's the the Pino Docker image and it's got some little built-in magical quick start things that simulate all the components being present give you a little web interface it's all kind of there in a can it's it's wonderful because it's one line you can play with it um you can't then modify the docker compos file and look at the data and it's it's all you know you press the button the light comes on so we're in the process of building and by the time you hear this or few weeks later uh there that might be the form of a proper repo that you clone and a Docker composed file and data um coming coming very soon as we we talk about this you'll be able to kind of see what it looks like um there's also uh pen. apache.org and docs. ao. Doc doc. p. Apache doc. aino that's not Mario here to it's a modern tongue twister the doc site put Link in the show notes Pino links in the show notes I think is the best way to put that uh where you can read more and star tre's got a great YouTube channel um I've seen they've got just really handsome guy fronting that doing great work great voice I love that guy yeah uh no there's and and other people on the channel too uh but some some great tutorials and kind of intros and and a lot of this isn't I mean how penino works is always of interest if you are a technical person you want to know that but some of it is you know why is this not snowflake are you are you stupid and you're just trying to make a different snowflake you know it's not and there's some we've talked about these Concepts but we've got some other little videos that just help drive those home like why would you even want this thing it's a different way of doing analytics and one I think is going to be a lot more important going forward cool well we will find out Tim berland thank you very much for joining me thanks for thank you Tim Tim ended there with a bunch of links so I'll just remind you you can find them all in the show notes including a link to the episode I recorded with Bobby coldwood Tim mentioned uh it's an episode all about Event Systems so if you're into Event Systems or you don't yet know what they are check it out it was a very interesting discussion before you click away to there or wherever you're headed if you've enjoyed this week's discussion please take a moment to click like share rate or whatever feedback buttons your user interface currently offers you and make sure you've clicked subscribe because we'll be back next week with another discussion from the world of software until then I've been your host Chris Jenkins this has been developer voices with Tim Bergland thanks for listening for