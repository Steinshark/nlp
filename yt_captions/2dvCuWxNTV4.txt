on developer voices this week we're exploring the ever thorny problem of SQL or SQL how you pronounce it is the minor problem the big problem is how do you use it from different programming languages how do you bridge that gap between your favorite language and SQL which is the de facto language of databases we've seen a lot of different approaches to this problem over the years from the basic of munging SQL strings together by hand really error prone kind of a security risk I wouldn't recommend it two very abstract approaches like hibernate or active record but as far as possible try and shield you from knowing the database even exists which is great for the simple stuff in my experience it breaks down pretty quickly as soon as you want to do anything really sophisticated honestly I've never been happy genuinely happy Crossing that object relational Bridge so when I heard about a new library that's making a few waves I thought we should get the author in and he can break down what his solution is so my guest today is Lucas Eder he's written a library called Duke that's j-o-o-q and it's firmly of the opinion that SQL is the right tool for dealing with data and databases and what you should do is adapt the programming language to fit it really really well Dukes of jvm Library so you can use it today in Java Scala kotlin but more generally I think his approach is also ripe for taking inspiration from importing to other statically typed languages so let's dig in and break it down maybe you'll learn a new and less painful way to talk to your database I'm your host Chris Jenkins this is developer voices and today's voice is Lucas Eder [Music] I'm joined today by database programming Guru Lucas Eda can I call you that yes sure Lucas how are you Lucas yeah I'm Lucas hi I'm great how are you Chris I'm very well very well looking forward to chewing over one of I don't I don't want to say it's the biggest Topic in our industry but it's certainly a topic that just about bothers every programmer at some point and that's the mismatch between objects in their programming language and the database they're trying to store things in which is one you've wrestled with actively so so have I so as most programmers but you think you've tried you've solved it right well I I would say I've solved it by circumventing it in in the sense that uh I just don't believe in the object oriented Paradigm at the client side as a representation of the model in the database the database model is Superior in my opinion so that kind of makes things easier so you're you're I know you're a Java programmer you are rejecting the Java notion that everything is an object yeah so actually even Java starts rejecting that notion uh since recently since uh they've started adding more data oriented data structures like records and then now they're really abstract data types uh pretty soon so um I think this kind of Paradigm that is very familiar to SQL developers will will be more popular in the near future so this object oriented thing where you have objects with identities and you have graphs of objects that are related to each other like in an orm is one side of the coin you can obviously model your stuff like that and it makes sense for some use cases but for other use cases which are more data oriented um the SQL version of uh the representation of data the relational one might make more sense and in my solution which is Duke I've never tried to bridge between the two worlds that just ignores the object-oriented one and uh you kind of stream the tuples directly from the database and you still treat them as tuples and the client so there's there's this dichotomy in programming some people treat like treat Java as the center of their world and postgres as fancy storage right and some people treat postgres as the center of their world and Java is fancy processing you could say it like that yeah and you're very much in the the programming languages fancy programming for tuples side of the fence it's just how I feel about it I don't impose this way of thinking or anyone I mean if you don't think like that like uh the SQL Centric way then uh maybe Duke wouldn't be the right solution for you anyway so I'm not trying to convince anyone to change their way of thought but if someone thinks already the way I do or I think you as well you did something similar in closure which is also very data oriented of course yeah um then people already think this way and then they will look for a solution like the one I'm providing okay so you know you're not trying to change people's mental model you're just providing the tool if they're already in that space yeah it's a lot of work to change people and and often it's not even the right way I mean it's my my way of thinking and they have good reasons to think differently so so I'm not trying to convince anyone of that yeah I'm kind of of the opinion that if all you're doing is storing objects by ID and pulling those same object back out by ID probably this let's characterize it as the hibernate way of doing things where we're very much just trying to pretend the database doesn't exist no not necessarily I mean IDs are very uh ubiquitous also in the relational model right so every table has a primary key if you're in the first normal form and uh you probably are right so you're normalizing your database schema so you have those IDs and it makes sense to think of the records as well not just the data sets so um the way I usually compare orms and and SQL that that Gap that you've mentioned is it's basically just an inversion of arrows so in the relational world the child points to the parent whereas in the object-oriented world the parent points to the child much more often right so the parent contains the child uh which might still point back to the parent but the main thing is you have a book with authors so you have a list of authors in the book and that's how you think about it also in a graph database you do it this way and in the relation model it's always the opposite it's always the other way around so the the author in this case with points to a book with via a relationship table do you think that's what makes all this hard then the way relationships are modeled not necessarily I think if if you if you think about it thoroughly then it's just really this inversion of arrows right so the the the most of most of the Gap that uh has been experienced in the past is that SQL as a language makes it kind of hard to serialize this data in one or the other format so if you serialize your data with SQL uh in the classic sense SQL 92 didn't have many constructs to Nest data structures so uh you would have probably used joins to denormalize your data and then you have duplicates which you have deduplicate again in the client and you need you kind of need an or on to the all all this uh boring uh mapping work so in the end you have the same representation of the data in the database and in the client just inversion of arrows but the rest is the same right so you if you're using for instance jpa then you will also use a relational model of your data you will not use the same Concepts the same kind of annotations like many too many many two one one too many or whatever so you have the same way of thinking as there relational one you're just inverting those arrows and then you let jpa do the the serialization which is the hard work right so the problem is that SQL itself the old part the old standard didn't Embrace nesting of data structures so you had to do this manually somehow with lots of Tricks but in more more recent versions you can actually do all of this in SQL as well okay so take me through what Duke it's j-o-ook j-o-o-q and you're pronouncing it Duke right okay take me through how that actually plays out as a solution what's it look like as a programmer so uh joke is an internal domain specific language which models the SQL language directly as a Java API so you can write SQL in Java it looks like Java code but it also looks like SQL code at the same time and the Java compiler will type check your SQL statements directly while we write it so first off this makes uh for syntax correctness in terms of the SQL language but there's also a source code generator that reverse Engineers your database schema which means that you have all your tables and your columns directors Java objects with type information associated with them so you can always have a types of access to your database model as well that's pretty much it so it's a a SQL Builder uh with a lot of type safety embedded in the Java language or also kotlin and skull of course uh okay it works nicely as well there do you have you have three versions of it for the three different no it's it's one API with some extensions for the two other languages so it's basically written in Java and there's some extensions for kotlin and some for Scala where it makes sense okay so the code generator if so you're saying I don't come to this from java land I probably got a schema already set up in the database and it's just going to generate from that so that's uh at the core of chook is the idea that you have your database already you're a database Centric developer probably uh it still works if you're not but if you are then Juke is perfect for you because no matter what the schema is how many tables you can have hundreds and thousands of tables and Views and store procedures or whatever and you can do something with those and generate code for them so you can access those objects and and you're probably going to have a schema that survives your client application or you may have multiple client applications maybe a python script that accesses the same SQL database from a different endpoint and the SQL database is always more important than the application accessing it so this is the mindset of Duke yeah that makes a lot of sense you nearly always the database will outlive the particular application that talks to it yeah so let's dig into something like you say these uh nested relationships in SQL right if I have if I have say one table that models nested data as an array inside a column and another table that models it as a relation to another table how is that going to look by the time I get to Java land um well on joke's side uh it's a one-to-one representation so if you have a foreign key relationship then that's a different table for Duke as well if you have a nested data structure like an array or a user-defined type then you will notice those things and will Nest those things as well in the table where you reference those types so Duke will just have a one-to-one representation of your actual database model you will never try it's not trying to absolutely on behalf okay yeah and then presumably yeah it's because you already designed this model and you want to use it the way you designed it right yeah yeah that makes a lot of sense so you're not taking any opinions on how the data should be changed to fit the world of java yeah okay so we don't even need primary Keys you don't even need any constraints you don't need any normal forms you can do whatever you want and still query your data because you designed this database the way you want it right so Juke won't judge you yeah yeah I'd like to not be judged by my programming languages for change I feel judged a lot I will judge you but not joke oh okay that raises questions about support but we'll Dodge that right so if you're largely generating the code entirely generating the driving code from um from the schema of the database are you doing something like regenerating it on every release and storing that code in change control so you can see if the scheme has changed in unexpected ways that's how I would do it personally but isn't opinionated about this so uh there's just a code generator it's a it's a standalone Java program which you can use as a maven or a Gradle plugin as well if you want you can make it a part of the your CI CD pipeline I've also documented how to integrate that with test containers for example so you could spin up a test containers postgres instance just for code generation where you migrate your database change changes directly into this in-memory postgres instance and then run the code generator against it so you can do it in any way you want so typically the ideal usage would be indeed every time you change something to the database in whatever way you want you regenerate the code immediately and you test everything you have your integration test Suite uh which runs on the regenerate the code so presumably a system like that means you can start to get compile time errors for schema changes yes yes that's the point right so yeah whenever you change the schema object like for instance you change the data type of some some column or you rename it or you move stuff around you want your client code to break because there's a lot of stuff you have to fix so this way with joke you will immediately notice where all the places you have to fix right now so I think this is superior to uh to approaches where you have embedded SQL in string form so maybe Ides these days can can help you with the syntax correctness while you write the SQL but to validate if it's correct at compile time you probably still have to run the SQL first which you don't have to do that necessarily I mean semantically you still have to check it at runtime but at least syntactically you you can be quite sure that uh all of these changes will actually affect your code yeah at least you're guaranteed that those column names still exist that kind of thing yes yeah you can also search you can use your ID to search references to columns and stuff like that so there's a lot of uh added value to having a generated code from your database schema so you can document your database schema with comments in SQL there's a common statement in postgres and other databases so you will have a javadoc representation of that comment directly on your column also in Java code okay which is really nice so uh there's a lot of benefits to this approach yeah if you can persuade the people doing the um ddl to comment their code which could be tricky yeah but once you notice this that this exists you start using it right yeah yeah having the tools there to support it is the first step to actually making the use of it yeah and so if we get from the code generation side into the actual programming side I've had a look at Duke's syntax and is trying to be very much um Java flavored SQL so it's a fluid API where you'd say dot select column names Dot from is that is that hard to make it work across all the different features of all the different databases yeah there were a couple of caveats that are not easy to solve obviously because for instance some some SQL keywords are also Java keywords and you can't use them as method names yeah like if or else or these kind of things case so uh The Simple Solution is just to append an underscore and then be done with it yeah yeah um other things are some methods are weird because they're already reserved on on the object API like weight there's actually a weight keyword in SQL and I can't use a weight method because object weight is a thing so that would have a different semantics yeah or also equals is a method on object and then it would be a nice method to use when you compare two things in SQL so it's not equals so some things are uh they're just little caveats it's not a they're no Show Stoppers obviously but but other than that um I think pretty much every SQL language feature can map to this sort of DSL uh pretty in a straightforward way I've documented this a very long time ago in the Juke blog how you can automate this even using an API generator from a BNF notation of your language so uh when you have a BNF notation of the language you have choices or repetitions and stuff like that and that always translates one to one to some some API usage uh in Java almost so uh sometimes I I make a couple of uh compromises like for instance if you have a keyword and then you have a parameter like uh fetch first five rows only which is a SQL syntax it would be a bit weird to have to write rows only as well in Java so it's it's just limit five so this is the MySQL or postgres all syntax uh it's kind of easier this way than having to use Superfluous keywords in a Java API so sometimes there's a compromise to be made but in in most cases if you think in terms of SQL you have the SQL syntax in your head you want to write it exactly the same way in Juke so this is the the main philosophy behind the API design so there's no new invention of something that exists in SQL and in joke it's called entirely differently for no reason right because that would be cognitive friction you would have to think about this and learn the API in a much harder way than it already is so it's not hard to learn because once you know the SQL syntax you you know okay it's got to be like that like this in Juke as well right yeah that makes sense and again you're going for this like path of least friction like what people already know and believe is the right way to do it just make that possible yeah I think this is a wise choice to make otherwise I've seen a lot of similar libraries in other languages like slick and Scala or there's doobie as well I think and in other languages in kotlin there's exposed and they all invented new uh DSL constructs so exposed for for instance I think they use slice and I don't even know what slice means slice is something coupling specific when I hear slice I would think it's a connect a collection and you want to slices it into pieces but I have no mental model what this would mean in Sequel yeah and at the other way around if I want to write a SQL statement and I have a where class is where slice or is where something else I wouldn't know so I would always have to think about it so if you're an experienced exposed user obviously you will learn this language but if you're the new person on the team and and you have to read this code maybe it's it's much harder for that for that person to to understand what's going on and I really wanted to focus on on on not having this friction at all so a SQL Developer will immediately see okay where is where and having is having a group buys Group by yeah there's already no no uh surprise here that raises a big juicy question about learn whether developer should learn SQL but I just have one more thing about your mapping first which I want to check right so one problem I've had with I've seen libraries that do something like this before where they're trying to translate SQL into um a native programming language API some of them say okay so just support the standard and then the particular feature that you like in your particular database isn't there some say okay postgres is the best one so it will support the standard plus everything in postgres what do you do for the things that are kind of specific to specific databases so in general the standard should be the thing that you decides on so if a feature is in the standard then Duke will try to use that syntax uh assuming that some implementation is also implemented it of course so if it's a very esoteric standard then maybe it's not a priority but a lot of times the standard feature is the one that everyone else will converge to eventually maybe in 20 years or so it takes a long time but yeah you can assume that eventually database implementations will will implement this standard like as I said before postgres already had limit and then I think SQL 2008 introduced the standard fetch syntax which was already available in db2 and then Oracle implemented it and usually once db2 and or Oracle Implement something they put it in the standard because they're very generous with us and uh invent all these things that they make available to all the implementations so um now postgres adopted this standard as well you can still write the limit but I think they even switched Now the default in the in the documentation what they recommend you use so you start using fetch first instead of a limit also because fetch has a more more features right so you can have uh the width ties clause which is not very well known but uh it can be occasionally useful when you have 10 rows you want to fetch 10 rows but if the 10th and 11th rows are tied you get both so you can do that with the fetch Clause you can't do that with the limit clause so you have two ties in the ordering so you want to have both yeah I didn't know about that one that's a hint yeah yeah that's great and the standard also has percent you can have fetch the first 10 of Euros which is also occasionally useful I think postgres didn't implement it yet but they will eventually end it won't be available in the old syntax it will only be available in the standard syntax sorry yeah so that would be the default uh but but on the other hand there are a lot of vendor specific features which are really interesting as well uh people love to use them so um the standard for instance would be to use merge postgres had didn't have merge for a very long time I think 15 introduced it finally uh they in they invented their own syntax one of the few times the postgres invented something on their own rather than following with the standard which is a bit weird in my opinion so they inserted in the inserted they invented insert on conflict which is probably more useful most of the time but it's it's less powerful and lacks features that merge has and now they invented they implemented merge as well so what to do in Jukes so Juke obviously had to support on conflict as well so uh Duke users could use this powerful feature for upserting Duke already had my sequels insert on duplicate key update which is almost the same thing but simply different uh so Juke now has all three right so uh on duplicate key update from MySQL which is the simplest one but the the least powerful one and then on conflict which is more powerful and then merge which is the most powerful okay let's say I I have picked a relational database that you've never heard of and it follows the standard and but they have one extra feature that you've never heard of and I'd like to use that can I use Duke because it's mostly standard can I add this feature myself without begging you as a pull request I got a lot of support requests from people who use Duke with some arbitrary database that I've never heard of and they were successful because I mean there's some that some dialects are very standard compliant I wouldn't say postgres postgres has a lot of postcode specifics for instance the the cast syntax was different for a long time in Juke or maybe uh some data types which are different but functions I don't know if you know about hypersonic hskldb predecessor of H2 uh it's very standard compliant H2 as well so so those people usually have been quite successful using the those two dialects and and pointing it to some entirely different database which is kind of Standards compliant of course they will always run into regressions eventually so it's it's not necessarily a good idea to to go all in on this integration because for instance if H2 or hsql DB adds a new feature which is a better feature than what they had before Juke will support that and maybe change the default rendering of some some implementation right so you you relied on an emulation of some feature which wasn't optimal and now Duke can make it more optimal for the Target database product but your database product which is a different one doesn't support this so you will get a regression at runtime so it's not supported but you could get it to run so is there anything I can do to extend it like can I in my own code base teach Duke new syntaxes so um if you're doing function calls or stuff like that like if you have vendor specific functions that are not supported that's very easy you can build a small Library there's always a plain SQL templating feature that you can use so you can use string templates uh where you can compose strings based on strings and Nest them arbitrarily uh kind of like uh in my my batteries which is the XML based Library where you can also use XML files and Nest them arbitrarily to create templates and you can do that with Duke as well and extend the DSL in any way you want this works for simple Expressions but once you want to have something like a select Clause it's more complicated because you you can't easily put that inside of you wouldn't know what where to place your claws but you can patch I mean you can you can patch the generated SQL with a regular Expressions if you want so there are there's a last resort yeah it's the last resort but it works well I mean if you know it's always something that happens right before the where Clause you just look where is the workload and replace yeah I mean when you're using a database product that's not supported so I guess you're you're open to this kind of a solution if if Duke still adds a value okay that raises the question which databases do you actively support yeah there are about 30 of them so um I'm not going to list them all here so all the big ones plus a lot of smaller ones so our Duke has been uh immensely popular in the in recent years with uh especially with those number crunching database products where it makes a lot of sense so I think if you have a number crunching database uh like bigquery or a redshift or snowflake you're not going to use an aurum anyway I mean it it doesn't make sense you're not storing transactional data you're querying it for analytics so your queries are super complex you have uh tons of dynamic SQL as well which is uh which is where Duke really shines so if your SQL is dynamic you can compose arbitrary SQL fragments very easily so with those database products Juke makes a lot of sense so and and inventors have been adding adding new and new dialects all the time so um they all compete in terms of performance obviously but also in terms of syntax unfortunately for for users right yeah so you're not just supporting relational databases like anything with a standard-ish SQL interface well it really has to be SQL I mean some products claim they're now also support mongodb or uh uh what's it called again elastic I mean they they have select from and where maybe and and they call that SQL it doesn't make sense to use Duke with that but uh yes I mean uh I mean what is a relational database product in the end if it lacks primary key can it still be relational in my opinion yes it could be I mean you can still store your your data in terms of SQL tables and columns and and these kind of standard data structures so once they actually embrace the SQL language and the SQL standard then yes yes you can support that okay that's interesting um so when we should go back to that honking great topic which you hinted at which is do you think that programmers should know SQL I mean should should you expect programmers these days to learn that kind of way of thinking and come into a new project knowing it absolutely I mean I have an entire talk about it on YouTube um which has about 50 000 views views by now it's been a really popular talk uh which I've given it Vox Zurich I think and uh the talk is about um getting the most out of your relational database uh you can do it two ways right either you do it in a in a Java way and that kind of make fun of the Java developer approach which uh is creating pojos and creating Getters and Setters and writing equals and hash code and writing abstractions like factories and Factory Builders and stuff like that and they have so much infrastructure and not even a single line of business logic and it's really it's really hard to change the system very easily you have to change so many components to have a new business requirement whereas in SQL you just describe the requirement and you have your results and you're done right so that's kind of exaggerated of course but um SQL is a wonderful language for for uh a lot of things so once you have a query something that can be expressed as a query and a lot of requirements are queries right how much do we earn in this uh in this year how much did we earn per store in this year whatever these kind of things you shouldn't calculate them by hand because you'll be always doing low-level stuff like putting stuff in a hash map putting stuff in the list sorting lists and extracting stuff and eventually your stuff your code is slow you have n Plus One problems irrespective if you're using orms or if you're writing handwriting SQL if you're if you're not thinking in terms of data sets then you will run in tons of uh performance problems but not just performance problems you're also performing yourself very slowly because in SQL you can just change a little bit of the of the syntax and you have an entirely different query very fast and it's going to be correct because all the the algorithms behind the scenes to fetch the data and materialize it and put in the form that you want are certainly correct right so the only thing that could be wrong is the requirement itself or your way to translate it into a formal language but um I'm always surprised about developers who think SQL is something old or wrong it's I mean the syntax reminds of COBOL and that may be the only criticism that I think is valid but if someone is data oriented they're they're going to use for comprehension in any language and what is a four comprehension right so if you use the mathematical notation with the curly braces you have the curly braces which is the data set and then you have for all X which is the from clause and then you have the pipe and then the where cloth it's the same thing it's always the same thing I mean this way of thinking of SQL is no different from any other mathematical way of thinking about data it's just a kind of weird and quirky syntax but that's it I mean it's a wonderful Paradigm and uh I think people should embrace it for for the purposes where it makes sense yeah personally I also like xflt for instance apparently a controversial opinion but I mean the syntax is also the problem there you have a lot of opening and closing brackets and and attacks but but the the programming model is wonderful you have a stream of elements that go through your processor and you transform it in a functional way with this wonderful X query language or or just XPath you pattern match your XML document and your output is a new XML document so you really have to hate XML itself for weird reasons to not like xslt but other than that it's it's a wonderful Paradigm really it's it's I I don't understand why it's not not more popular anymore people think Jason is better but uh Jason has to reinvent everything XML had because people actually wanted that stuff like Jason schema and Json processing now we have Json path it's all the same thing it's just XML headers from the start yeah yeah it's um I wonder why it can't just be syntax actually it could just be syntax knowing the programming world no it was over engineered I mean all the namespacing stuff I don't think I've ever needed that right so you can have nested namespaces and declare everything in xsd files and you would have tons of errors and it would take forever to get it right and soap was so over engineered right so to just have a single endpoint on on the on the internet somewhere you have to declare this huge huge huge wsdl file and and it took forever but to understand what you had to do but uh other than that the core of XML hasn't didn't really have a problem in my opinion except I could never figure out whether something should be an attribute or a nested element yeah the attributes so yeah I guess that was a mistake the attributes they came from the document oriented uh uh usage of XML so you had those two basic usages right yeah document oriented and data oriented and probably didn't need the attributes and the data oriented one yeah so let's talk a bit about data oriented programming yeah because that seems to be the unifying idea here that brings in SQL and um data processing generally in functional programming and do you think that is back on the rise yeah I I couldn't tell you I mean it's everything is going up and down all the time like a server and client-side computation right so we did we used to have mainframes and then we did everything in in servlets and back to the server and back to decline and it's the same thing with with imperative or object oriented which to me are the same thing and functional programming so either you have state and you want to manipulate State and that has its purpose for instance if you have a rich client UI you want to have that you have a window which is kind of an object and you want to send messages to it and manipulate its internal state whereas when you have data you kind of think of a stream of a flow of stuff that goes through a processor and the processor doesn't change the input it just generates output and it's both are one wonderful paradigms and for some reasons developers always think it must be either or they create these false uh dichotomies which don't really have to exist both things have their purpose right so I wouldn't implement the UI entirely functionally I I can't imagine it probably people do it but uh I I kind of find it hard to reason about a rich client like a Windows application with uh with Windows in an entirely functional way probably could be elegant but I think object oriented oriented program is better suited there okay I can grind my own ax on that one and try and convince you I can grind an ax and yeah I could try and convince you that actually the functional way is really elegant in the front end could be yeah well as well with xslt in the past so it generated uh HTML in the end so and it was a complete stateless uh request response model we should do a pair programming video where we thrash this one out yeah but I do think they are slightly I mean we love a we love a holy war in programming from the days of editors all the way up to how you actually Implement problems but I do think there is a difficult to reconcile difference between imperative or object-oriented programming and data oriented functional programming and the biggest one is mutation and how you deal with statefulness um they just seem to have such different ideas of how that works that you I think you have to choose one or the other is that fair in in theory you shouldn't have to choose but practically obviously you have to right so I always say to people who object that SQL is kind of stateful I tell them actually It Isn't So if you have a perfect database product which is entirely perfect and doesn't actually destroy any state with your update or delete statement in theory you have a database and you all you have an append only database and your update is also an append operation you create a new record that obsolets an existing old record and you don't mutate the actual record you just append stuff so you could you could design a SQL database in an entirely um side effect free way in theory so I don't think anyone actually implemented this because ultimately you have to remove data again to to uh to uh avoid a huge data pile that you can't manage anymore right so if you never delete anything in a large system that might not work but the SQL standard has a version and and a bi-temporal features where you can actually uh tell the SQL engine to not actually update the record but to split it in two and and mark the old one as deleted but it's still there and uh and that would that would be very very nice right so uh I think in the in the closure World which you're more familiar with I guess um the atomic works this way more or less you have an append only database and uh it feels like you update stuff but you're actually not updating it you're you're changing you're adding to it and the result is a new database so you the input is the database and the output is a database and it doesn't modify anything so I think this elegant world can exist and you can interact with it in an imperative style but it's not actually mutating stuff so I think imperative languages in principle could be made entirely functional in in that sense I guess yeah because we have that in the we have that in the programming world like when you it looks like you're mutating um an immutable data structure but really you're creating a new one becomes and the past doesn't disappear we actually had um James Henderson on this podcast a few weeks ago about talking about xtdb which is another attempt like datomic to do exactly that are you ever attempted to go beyond the uh the interface library and build your own database no I still have a life next to my job I don't think that would be very easy it'd be very challenging and fun to do but uh I mean Duke is already enough work yeah and I have a lot of plans with Duke itself so I think I'll let the database stuff to the to those experts yeah it's a very very deep rabbit hole Yeah a much deeper I guess yeah so what are your plans for Duke um one of the features that I've been working on in the past in the recent past has been a multi-set support multiset is a standard SQL operator that allows for nesting uh tuples in a relational way so you can have arrays multi-sets or sets that are nested in inside of a record um in the early 2000s or dmvms were a thing so there were object databases at the time which tried to say okay SQL is now over and we have to do everything object oriented and the SQL databases kind of adopted these features into or dbms like as I said arrays and stuff like that so um postgres is one of the implementations Oracle is another one and the third one which is less popular infomix have this feature so joke implements this and behind the scenes usually generates a SQL Json because other dialects don't actually support this natively so you can actually Nest stuff in a Juke query as if all those databases have supported SQL standard so this is really powerful you can then map it to lists or sets in your Java apis and everything is type 6 you have a typesafe tree mapper that can map arbitrary levels of depth of arbitrary objects into uh into Java classes which is super powerful so everyone who has tried this will never look back it's it's it doesn't get enough Buzz I think but uh once people try this they they really see the superpower of having typesafe embedded SQL yeah that that sounds like we're getting to the point where mainstream relational databases might consume the market share they lost to document databases yeah Oracle also did its part for that so um they they implemented something really fancy in Oracle 23c which has been released as a developer preview and will be soon GA they have this Json relational Duality feature where it can declare a Json tree being backed as your relational tables and you can update the tree and it actually translates to updates to the nested collection so this is super powerful they kind of did the same thing I did but in the database you can declare a view and then do arbitrary things so so you can even update it so this this is something you can't do with Duke directly so I'm going to be looking into that very soon on supporting that feature in Duke so uh they exposed the nested Json data structure as a Json schema so you can have typesafe queries on your nested data structures of your relational model and I I guess juice code generator will then generate uh Java classes for those Json objects so Json will just be the serialization format behind the scenes in in that use case so you can have uh I guess a rest API and have it completely implemented with a Juke uh and between and then Oracle so you can manipulate stuff in between I mean you could even uh Oracle has rest apis directly into the database so you wouldn't need middleware but in case you actually need the middleware to do any additional manipulations uh Juke will help you there okay so there's a lot of really cool new features coming in all the SQL databases so I'm hoping Oracle will standardize this particle feature uh once it's standardized I'm pretty sure postgres will implement it as well um or there are graph features which have now shipped in the latest SQL standard which I find very very exciting so there's uh neo4j has implemented the cipher queer language and invented a lot of cool features there with their own syntax where you have kind of arrows to declare your graph relationships yeah and that has now been part of the SQL standard as well I've downloaded and bought the the standards document from ISO and and looks really well done Oracle already shipped an implementation as well so they were big in the team of standardization and implementation so I've tried it so it kind of really really makes sense you kind of have your relational model and as I said before what you're doing is you invert the arrows so now the parent points to the children and you can model your query in terms of parent-child relationships like this and and pattern match your graph across your schema in in in this way so I'm not sure about the implementation yet so I'm not sure if it's fast but uh it's an elegant way of thinking and I'm pretty sure they will make it faster if it's not fast yet yeah I've seen people do it just in like probably about 10 years ago I saw people trying to do it in um I think it was postgres yeah yeah postgres has an extension I think yeah it was possible it was kind of slow and all the queries were really hairy the generated ones or the the ones you're usually inevitably hand rolled up with yeah um not to be recommended but if that's being adopted into the standard that might yeah we'll get better eventually yeah is um how do you figure out your development roadmap do you look at what other databases are doing do you look at the do you read the iso standard and see what features you're going to need to do next or you just listen to the people who are using it well the iso standard isn't really advancing very fast so it's not the biggest source of inspiration so uh this uh graph stuff is kind of the biggest change in a lot of years I've seen in the stand of course SQL Json is a big new feature of the standard but Duke already supported some of it uh because postgres uh had a lot of vendor specific API in the past already so it made sense to support this as well um but yeah I do check out release notes of uh database products and if there's something really cool that joke didn't do yet for instance once I supported teradata a very old uh and popular database from the 90s which is still around in a lot of systems and they have to qualify um a clause to the select statement qualifies like having but for window functions which is really powerful so for instance if you want to have a query where you have the ties like I said before and your database doesn't support it you can you can query for the rank of your row ordered by your ordering criteria and and you don't have to Nest that query to calculate the window function so qualify is a vendor-specific extension which has been adopted by I think at least Snowflake and I think excess Soul maybe has it and H2 has it and duckdb also has it so I see this being adopted by a lot of vendors because it's so obvious to do it's such a simple feature and it's such an obvious value addition and I think there are people people are discussing standardizing it now I've met someone uh yeah who is looking into standardizing it from the postgres community and um uh can't promise anything can't say if it's happening but it does make sense so this is a discovery I've immediately implemented in Duke for instance once I started supporting teradata and Joe can emulate it in any database right so you can use now qualify and any dialect that supports window functions because for joke is just either it's supported natively or just generates a derived table and that's the query and filters on on the window function okay nice okay so it is so this is some this is detail I've missed sometimes Duke is generating not just the the direct translation from what you've typed but actually stepping in and saying oh what you mean in SQL is this yes if it's really not there if there's really no vendor specific way to do it then there's an emulation like on conflict in the past so if you write on conflict uh from postgres and you you want to start supporting Oracle as well in your application not just postgres then Google automatically generate the merge statement for you okay which is equivalent to whatever you wrote was on conflict which database you're using yeah yeah because of the SQL dialect that you pass did you if people want to give um Duke a try where's the best place to find it.org.org easy and just it's just a Java library right so you download it you probably use it with Maven there are example projects where you can start our demo project there's not much you have to do to set up all you need is a jdbc driver a database connection and you can get started boom and uh Skylar and kotlin too yes absolutely okay well next time I'm connecting to a SQL database which shouldn't be too far away I'll give it a try excellent Lucas thanks very much for joining us thank you Chris for having me cheers thank you Lucas do check out Duke there are a lot of ideas there to use if you're on the jvm and still some ideas to steal if you're elsewhere I'll put a link to it in the show notes but if you're Googling for it it's j-o-o-q also while we were talking we hinted it a good way to implement functional user interfaces if you're interested in that I think the best place to start is by searching for the elm architecture but again I'll link to that in the show notes maybe we should do an episode on functional user interface is in the near future that'd be fun if you want to make sure you catch future episodes now is an excellent time to hit like And subscribe and follow and all those buttons and you will let me and the algorithms know that you want to hear more as ever if you want to get in touch my contact details are in the show notes for Twitter and Linkedin and all the usual and with all that said I think we're done until next time I've been your host Chris Jenkins this has been developer voices with Lucas Eder thanks for listening [Music]