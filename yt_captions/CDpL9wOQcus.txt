So, I think it's what we're talking about we're talking about multiprocessor systems then is that we're talking about systems where you have multiple CPUs to write your software for so as people said as we talked about things like the keyboard have a CPU in them and all of the times we're like the Atari or the Amiga or even some of the original PCs to process the keyboard and then just send the data to the computer, but that's not usually a CPU that you're going to Program yourself, write part of your application to run on in the same way most modern Intel motherboards the management engines on runs on a CPU embedded into the chipset that's running on there and Providing no one hacks it then you're not gonna be running your code on those. It's it's a CPU It's doing a task, but it's not one we're going to program with. If it's not the central Processing unit. It's an additional processing unit. Is it still a CPU? It's the central processing unit of that subsystem When we talk about CPU, we're talking about the central processing units a bit at the heart of the system Doing things so people are rightly pointing out that we have CPUs But we're not gonna write our software to run on them You can and if you look at some weird bits of software They would sometimes shove things down onto this keyboard CPU; I remember there's one virus on the Atari ST that did that to stay in memory and things but we're really talking about the real Central processing where we're gonna write the software that's going to run to do the tasks we need and that's what we're talking about but there is a class of Effectively processing units that you do find in machines that are running part of our software I mean the classic example of that would be something like a floating-point unit so these days our CPUs whether it's an Intel chip or an ARM chip or something often have Built-in support for doing floating-point maps I adding 3.1415926 to some other random number and so on after they're built in support for that But they didn't originally if you look at the original IBM PC, I want the XT behind me So let's take the lid off this while we're doing that So got a screwdriver built like a tank So inside the original PC and if we look just down here next to the power supply we'll see that if I take this card out It's read-only the serial port at the moment We can see what's going on HT 250 serial card eight bit. I suppose said it wasn't called that then so if we look down here We'll see we've got on the motherboard an Intel 8088 CPU. That's the main CPU in the original pcs What all your PC is easing now derive from whether it's a Macintosh or Windows machine as oh they all have a chip Which pretty much still boots up like the Intel 8088? Did from 1983 but if you look next to it, you'll see there's an empty socket with nothing plugged into it And that was deliberately done there for two reasons one where they designed the 8086 or the 8088 they deliberately built it in the way knowing that they might want to add support for what's called a floating-point unit or FPU which is what goes into that spare hole there and the FPU was a chip That you could buy and put into the PC or put into any machine to have support for an after you to handle the floating-point Mathematics so if you wanted to do add floating-point numbers together You could either do it by writing the software add the two numbers together or you could do it by having a floating-point chip inside your Computer and the floating-point chip would then add the numbers together and the advantage of that was you could design the floating-point hardware To run a lot of faster than you could just write the software to do with the same speed so you can build dedicated hardware To add floating-point numbers together in the same way. You can build dedicated hardware to add individual numbers together, which is what's inside your CPU so when they designed the 8088 chip and what the 8086 chip they Left support him for this and so there were some instructions which have us if the opcode for that instruction started with specific binary pattern would Allow a floating-point unit in the system to take control reading the values that are accessing from memory So the CPU would work with the floating-point unit to load the version from memory And then the floating-point unit would go off and do the floating-point calculation in parallel at the same time as a CPU kept money Doing into your stuff and so you did get some sort of parallel pricing, but it wasn't a general-purpose process at this time All it could do was floating point stuff if it needed to access memory It was the CPU that started things off There was support in that to actually do some fetch further values and so on using direct memory access but in general it was reliant on the CPU to do a lot of the things so it's all supported the CPU but gave you a significant speed boost compared to doing it all in software the nice thing was is that the CPU if you run those Instructions would throw an exception so you could write software then catch them implement those instructions and software but if the CPU if the FPU was present it let the hardware do it in parallel so you could get the Best of both worlds you could write the software To use floating point Maps. Don't worry about the floating point unit being there. If it is there you could then take advantage of it now the reason why the machines shipped with an empty socket is because the empty socket probably cost a Few cents a few pennies to put in but the CPU cost about a hundred dollars, I think Minimum if not more than that to put in the machine So if you were just doing using something like word processing on the machine You don't need a floating-point unit for most of the stuff you're doing You would you wouldn't bother but if you're doing something that did heavy number crunching then you could drop the floating-point unit into the machine when it was built and you'd have one that would work a lot better to Do those sort of? operations now of course is the machines developed through the 81 86 the 286 or 386 or 486 the software developed and by the time the 40s it was popular we had sort of Fonts being drawn from outline descriptions things which actually involves doing floating-point calculations and so eventually the floating-point unit got built into the CPUs themselves so it can have sort of protesting units, which aren't There as general processing units, but they support the operations of the CPU do they take some of the operations that run on the CPU in software and They don't add any new functionality. There's nothing that you can't do without them But by doing it in Hardware you get a speed boost by doing it in the case of the floating-point unit on the original PC Or you could get the same for the sort of Motorola machines You could perhaps get a hundredfold increase in the speed up to do those floating-point operations everything else rather at the same speed but for the floating-point, operations in about 100 times faster Which of course meant if you've got a lot of them you programs around about 100 times faster if you weren't using them You didn't get any benefit at all. Another one, which is quite interesting, which you'd find in things like some Atari STS and in most amigas is what was called the blitter chip and the bolita chip basically implemented what was called the bit block transfer routine or bit blit often referred to And this was developed at Xerox PARC in the 70s on the outter machine I think it was and it was basically a generalized algorithm for copying Blocks of memory round particularly in the way that you want to do raster graphics one of the things that both the Amiga and the Atari had and the only reason I'm looking at the Atari here is Because it had it as a separate chip on the motherboard which is annoyingly under the network part Atari developed another Chip which implemented the bit block transfer algorithm because he Vantage was then that your main CPU wanted to copy a bit of memory Was set up this chip will just appear as an i/o barrel and say to this copy this bit of memory From this address to this address combined with what's already there Using this sort of combination and you could do some very fancy graphics effects, but the advantage was whereas on the implement in software you had to read the instruction for memory that said load this value from memory and then load it into a register and Then read those instruction says load that value from memory and it was loaded into it register And then do the combination and write the value back out This could just have a few Hardware counters directly inside it that loading the value from memory Loading the next value from memory combined them wrote them back out into memory so you could do it a lot faster. You could run every clock cycle Doing some useful work as opposed to some of them having to fetch the instructions that were doing what we needed to be doing So by offloading it onto a dedicated support again, just like with the FPU. You're not doing anything. You can't do with the main CPU But you're offloading it there you having it run slightly faster, and then the CPU can get on with other things although in this case It had to wait for the British ship to finish it but it was still faster than doing it manually for all what the smallest of operations the Amiga did the same thing you had a British ship along with a couple of other things which gave it the advantages in terms of Graphics, of course the problem had and which a Charlie found. Is that as your CPU gets faster You also have to make the blitter chip faster or your CPU becomes much faster than the British ships There's no point of having on there So the Atari TT for example, which is a thirty two megahertz 68030 as opposed to an eight megahertz, six eight thousand Which also had a cat that 68030 also had a cache Ran so much faster that the instructions would be in the instruction cache So the CPU could just fetch the data At full speed from memory and write it back with the combination done without the need for the blitter chip And so you very quickly you CPU gets faster You've got a more general architecture You can do whatever you need to do there And so actually the British ship became redundant in some of the Atari is pretty soon after it was in lamented Well, they didn't put a faster version Into the Falcon which can be useful in certain modes acorn on the other hand when they built the Archimedes They're roughly the same sort of time as Commodore Amiga and Atari ST have the blitter chips They said well actually our CPUs so fast that we don't need it. There's no advantage to it now but the same approach was taken with graphics cards in computers that you would end up with the graphics card having support to do some of the basic 2d Operations that Windows is wanting to do and so on So rather than doing them on the actual CPU You would hand that control off to the graphics card to do that things like copying the memory about perhaps drawing a straight line Which you can very easily implement in hardware And so you've got this balance between do you you get your CPU to do this as a general piece of software? Which you can change and update Easily or do you hand this over to a dedicated piece of hardware where you can implement it in a way that's faster And so on. So for some things like the graphics things and floating points They very much now been taken over by dedicated bits of hardware if he's only delicately it's a to Li harder and it more we get GPUs which are effectively general-purpose processing units But they're very much configured and designed in a way that makes them very amenable to doing particularly 3d graphics processing but also 2d graphics processing as Well and almost all CPUs these days and desktop machines and laptops and so on have a floating-point unit built-in because we're doing stuff That needs those floating-point. So it makes sense in some cases to have Hardware to do that in other cases It makes more sense to have it in the generalized nature of software Sort of be responsible for cleaning it yourself You could be responsible for managing the house and things or you can employ someone else to do it on your behalf So you can employ a cleaner or someone to sort of clean the house Well, then you haven't to do it yourself as some people might choose to do. It's the same with the computer