and we're live with the next talk today we're going to now we're going to see about the talk from Nikolai faul um who's going to talk about variable monitoring with declarative interfaces really interesting topic which I think applies to a lot of our work um so please take it away Nikolai thank you I'm Nikolai Fu and I work at Sean Gesa and I like to show to you some some approaches and some some methods for for large scale monitoring in like industrial Control Systems uh I'm not going to show you a recipe that that you can just use right off the bat for your things but it's more going to be if you you can pick up some ideas and some techniques that that you might be able to employ in in your software project so that's kind of my My Hope for for this talk so uh a bit about me uh I have a background in electronics engineering and in process control uh I started doing mostly embedded CAW work uh for the last 10 years I've been working mostly with with C++ so so a bit higher level uh I've been in offshore oil gas and Renewables uh I've bit in the defense industry and in automotive and I've had a something in in the medical industry and um last but not least here now in in the energy and again in in Renewables so that's sure all about me um yeah so first I would I'd like to talk a bit about like SE I always find it interesting in in these talks to to know about a company and how they how they use C++ to to solve their their problems um I guess it comes as no surprise that we do wind turbines uh so we do big offshore wind turbines and like some some slightly smaller onshore wind turbines i' like to talk a bit about like what goes go on inside of these things like usually I guess you just drive through them or drive past them maybe every day so so what what is going on in in one of these um but first uh a bit about the the people that work here so so we have a a very large range of backgrounds like we have people that have go to math we have physicist we have process control which which I'm part of as well we have people that are very good at mechanics and and Hardware and also we have people that are that are good at at software but the thing is it's not not everybody is equally interested in in this software part itself like like they use software as a tool to solve their problem and and that's basically what what software is is it's just a tool that we use to solve a problem it's a very good tool and and it's a very flexible one but still just a tool uh some people they they prefer just having a a on liner to to instantiate some some fairly comp comp Lex logic they they don't want to understand like if there's some integrate software design behind all of this they just want to get their task done now we can't all get get tears in our eyes when we see a beautifully written piece of software um now this is software engineering so so there's some a compromise between pragmatism and and delivering something and and idealism so we do need to to deliver projects and one of my jobs is to to to give people the tools some suitable tools that they can use to to solve that task uh yeah so back to the to the wind turbines uh so what goes on in the software of for a wind turbine so I'm going to give you a quick brush up so in a typical 7 megawatt turbine you actually have a complete generator uh a whole power plant up in the N cell here and we have around 450 different kinds of sensors that uh that monitors everything that that goes on we have around 150 different actuators uh we have valves we have pumps we have fans we have Motors we we've got basically everything uh I here we even have a sensor which is basically a microphone that can sense if uh some technician had has lost a tool while he was up there and it starts to make a lot of noise we have a sensor for that so a lot of sensors uh our code size with around 2.5 million lines of code so fairly sizable um piece of software uh and what this software does is like primarily we want to to optimize power production so that can be something as simple as like turning the wind turbine into the wind if the wind direction changes of course we need to pitch the blades in the right way so we get the most power out of the wind uh one other thing we do is that that we have some Control software where we try to minimize mechanical loads on the turbine because if if we can do with a with a thinner towel we can save on materials and and that makes it it cheaper to produce the turbine to install the turbine and all that and that you can actually do in in software so that's another thing that we do uh last but not least uh we need to monitor a lot of state and we need to report alarms if there's something not working quite well and we need to take action in case there there's some kind of undesired Behavior like for example if there's over current in something maybe we need to throttle power output a bit uh if there's smoke in somewhere probably good idea to to shut down the turbine or something like this that can be different kind of criticalities in this and we you need to deal with each of these in in different ways and we do this by by controlling all these valves and pumps and fans and um and Motors so that's brief overview of of what actually goes on in in a wooden wind turbine and um what we use to to to to control all this that we have some some PC some industrial PC not unlike the one you see here in in this picture uh it's running some publish subscribe middleware which allows us to have different components talking together uh some of the components might give us some some Hardware access to all these sensors like to read in data and to send out data uh we got a lot of State machines running which controls all the different subsystems that you have in in the turbine all the states in those uh for this power optimization and mechanical loads we have a lot of algorithms that that where we have models of the wind turbine we can see okay if the wind is like this what what how should we pitch the blades in order to get the the maximum amount of of power from this wi turbine so so we have a lot of algorithms that that are running on this one for for control as well and last but not least we have the monitoring which will be the the focus of of this talk so yeah we can look at monitoring a bit in detail so basically it means we have some signal that comes in it can be some kind of measurement it can be some derived value like two measurement that you merge somehow and and that's another signal or it can be some some manual input you could have a technician in the turbine with his tablet U inputting some data or or setting valves manually or something like this uh and those we need to do some kind of check on so is it in range is the status good it could be any kind of check and once we've done the check we need to do some kind of response so the response could be control and actuator for example put the wind turbine into the wind if the wind changes Direction uh if we have some kind of unexpected situation maybe we want to set an alarm uh we can also stop the turbine uh we would try to do that as the last result because it is very expensive to to stop a turbine so so if we could could rectify it somehow then then we prefer to do that so so that's Basics that goes into to monitoring um and that allows us to to give us our our problem statement now how do we give our developers KN our developers how do we give them some good tools to create uh monitors but but the the problem is here what is how do we measure good uh of course it needs to give us the the functionality that that I just mentioned but there's more to to it that than just that uh there's these things called quality attributes like the non-functional requirements I taken some from from this book it might be a bit a bit high level here because it deals more with software architecture but it has a list of of some non-functional requirements I'm going to mention some of the ones that that are are quite important especially for for this and and for this kind of software the first one uh is scalability as I said we have a lot of inputs we have a lot of outputs we have even more monitors that monitor all these things so we have several hundreds of monitors so you need to be able to to scale your monitors uh quite well another quality attribute is usability uh bendine he had a presentation I think that was called make it easy to use and hard to misuse and and I think that's that that should be the first mantra for for any library and utility developers because it is so important that it's easy to use this H if it's hard to use then the users will just not not bother or they'll not be happy with it and and it's um yeah I I consider this to be one of the most important thing especially I consider readability to be part of of usability as well so uh so yeah a very important attribute and the last thing I'm going to show here that is modifiability because as we all know uh change happens we have a new requirement coming in we need to be able to modify our uh software I don't think any software has ever been written that has not had to modify in some way if you write your software not to be modifiable you're doomed to failure so we do need to have something that's very modifiable uh yeah so with those in place uh let's get started I'm going to show you three different approaches to to this problem with monitoring and then I'm going to give them scores for these quality attributes now they can all solve all these functional uh requirements but but I'm going to look at how they solve the the non-functional requirements as as well and the first one I'm going to look at is the the ad hoc approach which is the one you you usually just start out with when when you when you do some solution now must tell much of this code is is slideware uh like it has been working at some point but then I copied it into the PowerPoint and and had to change a bit here and there I've done way too much coding in PowerPoint for this presentation and I'll tell you PowerPoint is not a good code editor if you take anything away from this presentation it should be that anyway here goes so this is some some code that could be an example of some kind of publish subscribe uh framework that gives us the ability subscribe to signals and to send signals and in this case also alarms so so the Subscribe here is a function that subscribes to some signal in this case M signal and we can set the Handler which handles whenever this uh signal changes and and and here you can kind of read what what's going on so whenever M signal changes if the value is in the range from 0 to one then we disable this alarm otherwise we set the alarm and that's fairly that's fairly okay it's it's quite easy to to reason about uh the problem with this is that it gets complicated fairly fairly quickly now let's imagine we have some signal that's a bit noisy so we don't want to immediately set an alarm the the first time the value goes above one so instead we want to have a delayed alarm so instead of setting an alarm immediately then we start a timer let's say we wait 10 seconds if it's still not in range well then we want to set the alarm uh and if it's in range again we need to stop the timer and we need to disable the alarm again and then it gets complicated fairly quickly now it's not immediately easy to to read what what what exactly is going on here what is the the the core logic behind what's going on here now this is still a fairly simple example but but it can get quite complicated very very easily one more thing is that it's very easy to make mistakes especially when you start scaling up a bit if you need to do 100 of these what is the risk of you forgetting to stop the timer in the else Clause it is fairly fairly uh easy I should get caught by by testing of course but we know that that doesn't always stop bux come from U coming through so so this is one way this an ad hoc approach you you can you can do that fairly quickly but uh but let's look a bit at the uh quality attributes here so I'm going to start the place where where it's really really good so modifiability it get Tops Mark top marks because you can modify this code to your house content and you won't break anybody else's code it's is really great for modifiability oh I would say usability is not the best uh in particular here I would say readability is not that you can you can get all the logic from reading the code that's a good thing but you do need to read quite a lot of code in order to understand all of it so usability is is not really uh optimal and you do need to write a lot of code as well if you want to do a new monitor uh there's a lot of like explicit logic you need to do you probably need to do the same thing over and over again uh so so so usability is not the best scalability again it also comes to the fact you need to write the code again and again again if you have this code out a 100 different places and there's a bug in some of it you need to modify it 100 times so so for that it doesn't work that well but I think quite obvious that hog approach only works for very very small um uh problems where it's it's quite specific it doesn't scale at all so let's try a second attempt where we use classes to to get some some code reuse uh reuse from this so we could make some classes that contain all of this business logic that we' saw before in this ad hoc um method so here we have two different classes one called or we have a component first which has these uh three monitors two different types so we have a monitor signal quality and we have a monitor limits and in our Constructor of this component then we can uh construct these monitors uh I notice here we've got this little o parameter as the first one and the O parameter is is just some kind of handle to this publish subscribe uh framework it's not really important for for the sake of this presentation exactly what is in that but just know that that that is a way to to subscribe and to send signals with this I'm going to use it a bit through this presentation uh but but the good thing here you can kind of read what what's going on here like we have we have a monitor we monitor water pressure a when the signal is bad we want an instant alarm of pressure alarm for the wind speed monitor we want to one monitor wind speed when it's higher than 10 then we want to send out the signal uh wind speed is higher uh and it's quite nice if the classes are coded fairly sanely you can reason about what's get getting done without having to go through all the if then else Clauses it's kind of H kind of reads out like you would read read a text also because we use this pops up uh framework it's it I would argue it's a declaratory interface because once we have instantiated this this monitor everything just kind of works you don't need to worry about it anymore and that's a very good quality to have for some developers that don't want to ER explicitly call the monitor every time and and do all these checks they just wants to instantiate it they want to read what is it that's getting done and then think the monitor just need needs to to do its thing so it's very good for for our developers here uh yeah so I it it's a declarative interface now there is one problem with this approach which is uh the passage of time so as you probably also tried yourself people want some new functionality no problem we just add it to this monitoring class it doesn't quite fit the bill it's not it's not covered by this monitoring class but you make a new monitoring class you do a copy and you change it a bit and then I I think you see where where this is going all of a sudden we have 18 different monitoring classes some of them are completely different some of them inherits a bit as it's a bit of a mess and and we've actually worked a bit with with something like this uh it works for for for when you don't have too many monitors but when it gets more specialized you get a lot and it becomes a bit of a pain to work with uh and I think that the reason this happens is uh because it broke some of the solid principles in particular the open close principle like we every time we need to add some new functionality you open up the class you you edit a bit and then uh then you get on with your life but you but you risk here breaking somebody else's uh code and that's not really good you can't do your changes without everybody having to to recompile everything and and it's um it's not really good so so we can look a bit at the the qualit attributes for for this solution and here we have we do have scalability it's very easy to make a new class you can make hundreds of them you can even put them all in a container and and it it works uh so so that's that's quite nice um usability is also good as I said you can readability in the particular you can just read what's going on and again it's easy to make a new monitor it's um for that it works it works Works quite well however modifiability is is really not the best it's it's hard to to modify these you need to go in and open up the code find out what what is was this guy thinking for for this particular monitor uh and that can be be quite hard you also need to find which monitor can I use for for my particular um thing so so modifiability it doesn't really get good marks there the ad hog got better so so ideally we would like to have all of these we like to have scal ability we like to have usability and we would like to be able to to modify these so so how can we do this let's try a different approach and in this one we would try to adhere to the solid principles which is single responsibility principle open closed Lisk of substitution interface agregation and dependency inversion I'm not going to talk about all of these and I'm not going to focus on all of these uh the ones that I find uh important in in this one is is the first two ones so so single responsibility class should only do one thing um and the open closed it should be open for modification but oh sorry how it's open for extension but closed for modification so you should not be able to open up your classes you should not have to in order to to extend their their functionality so if we try to to uh go along with these ones and tries to to um design something uh something new uh so let's try to break it down a bit so as I talked about before we have some signal we need to do some kind of check on this signal and in the end we need to give a response so so in this diagram here we have some signals coming in we need to check some kind of condition if that condition is violated we need to call some amount of handers and we want to be a able to customize all of these things now in reality this condition will probably a compound of many different conditions so we have condition one or condition two and not condition X or something like this and that that we would like to be able to do as well so so imagine now the the following monitor graph so we have my signal that comes in it could be the wind speed it needs to be larger than two and smaller than 10 and if it's not we need to to print a violation that we would like to have something like this so we can try to express that in code like note here I'm I'm going to approach this not from the implementation side from but from the API side so how is our users how are they going to use this uh this API so here we can express this Express this in code so we have a monitor we want to monitor my signal with this pops up framework here's the O comes again so I want to monitor my signal with the condition that it should be larger than two and smaller than 10 and the Handler should print a violation if there is one that would be nice to have and then let's say somewhere else in our system we publish my signal with the value of one then the monitor should print out violated true if you publish my sign with two it should print out violated false and and so forth so that is that is what we want now you can get quite creative with the naming here as well like for example we could make it even more readable by saying I want to monitor my signal it must be larger than two and smaller than 10 when not we want to print the violation so this is even more readable but but you need to be a little bit careful with with naming here because naming convey meaning so so in this case we have changed the meaning of it because when not uh only is it's only executed when when it's when it's not like when there is a violation so we would not call Print violation but there's no violation so we've changed um we changed the Handler here we would not print the uh the false in in this case so so sometimes you need to be a bit careful with with this naming to make a a nice API and what's that when that's not surprising so so I I would go for for the other one where you have the generic uh condition and Handler that then it covers all the B so how can we do this if we want an API like this how can we do it uh I propose something like this there's a bit of of template here but it should be still fairly understandable I propose that we do a kind of monitor Builder which is basically a tubal builder in some case uh it holds a tual of conditions and it holds another tub of handlers and then it has three methods and the first one condition returns a new monitor Builder class that has added the condition that it takes as a parameter same went with the Handler it returns a new monitor Builder that has added a new Handler to its uh tole of handlers so we can kind of use these to build up the uh the conditions and we can build up the handlers last but not least we have the operator pen which checks a set of types TS for the conditions and calls the handlers and that's it uh we can use this now I've got the monitor Builder here again I've removed all of the the templated to get some some space on my slides but it's the same thing as before uh so we can now use a function that creates a default monitor Builder so it takes some amount of types uh and it returns and monitor Builder with two empty tubles so there's no conditions there's no no handlers and it just takes some types the parameters are just two empty tubes and now we can build our monitor like this as we want it monitor my signal with the condition should be larger than two with the condition it should be smaller than 10 and each of these condition CES just adds to the tubal so in this case we'll have a tual of a larger than two type and a smaller than 10 type and we will have one Handler in the in the Handler tub which will be the the print violation uh type and and we can we can change this again like we we're flexible because we can we can have a condition that says it needs to be larger than two and smaller than 10 and my odd condition it can be any kind of condition really you can you can add these without influencing anybody else's code we can add more handlers in this case uh we want an immediate alarm activation if the condition is violated but we want to to have a delayed alarm deactivation if the condition becomes nonviolent we don't need to open up a new class in order to add this functionality we can do it in our own code only and that's a very very good thing about the the open close principle if you follow this you you can do these things now note here I have not uh done the the logic to to deal with subscribing and and calling the monitor like in reality we would again need the monitor to take this o parameter which gives us a handle so that we can subscribe to to my signal for example and and we can send out alarms if if we want to uh so so our monitor Builder would probably look more like this we would have a Constructor which take the app pops up uh some kind of type that gives us a handle to the pops up framework but given that every popop framework is is different I'm not going to go into detail as to how you can actually do this because I can't really say anything General about it um so yeah just note that that here sometimes I skip over the that part of it but all the the methods all the the the the tricks and tips can still be applied even though though that one uh is not implemented but yes how do you then write new conditions so a condition is just a callable which returns true if the condition is violated so in this case we can have one that says larger it takes two parameters and it returns whether a is smaller or equal to B so if it is then it's true and it's then it's a violation of this condition you can also take parameters into your conditions so we can have a minimum uh condition and we give it a parameter that it needs to be minimum uh this value here we return a Lambda which take the Val is the value we want to check and the minimum is the minimum value it needs to be and then we just return whether this is violated you can also use a generic Lambda makes the code even even simpler so in this case we have an even um an even condition so the value needs to be even and here we just return a generic Val generic lamba it can be any kind of value as long as it's even uh it's it's um it's not violated if it gets uneven then it uh or if it gets odd then it's um then it's violated and and you can do these generic lampas it makes the code much much easier also for all the other ones uh all the other conditions that that you want to make and the thing is here that that you can go quite crazy with these conditions without bothering anybody else so so here I made Max variance Windows it takes a window of X samples and it calculates the variance and make sure that it doesn't go above something uh and that I can put into my specific little component which monitors this particular little condition I don't necessarily need to add this function to some framework it can just be local to my code and nobody else will ever know about it because they don't have to it's only me that's interesting in this very particular condition and you can just add it to your monitor as you would do with any any other kind of monitor now one thing I haven't talked about yet is that we need to do something to to do this this Boolean Logic on conditions as I showed here uh because given that they're just callables you can't just do this uh immediately like you can't add an or uh or not um calls together that needs to be done uh in some other way so so yeah a competition is a callable it takes some parameters and it returns a Boolean so so if we have a collection of callables they all return Boolean and they take exactly the same parameters then I would say it actually makes sense to use this kind of Boolean Logic on them so so so let's try to overload the operator and and or uh everybody wants against it again I think it was bendine that had a talk about operator overloading where he said overloading or and and don't do it um but what does he know we're just going to try it anyway so the way we do it is that we wrap our callable in a class uh which basically just yeah wraps the callable completely now wrapping a callable completely is a bit tricky but for our intents and purposes this this is this is okay I have I should do forward and and all these things but this is slideware again uh but but but for our case this is okay all you need to know is that this logical f as I've chosen to call it just takes a function and and has an operator parent that just forwards it to to the to the wrapped function and what we need to do now is then add this um and operator to this logical F we also need to add the or and the not operator and what it does is that it takes the the current function that we wrapped and it takes another function and then it it captures those in a Lambda calls the two functions and Returns the ended uh value of of the two results and we will wrap that Lambda again in a new logical F so that we can keep on doing this and or and or and not however we would like to do it uh and that of course we need to do for for or and and not again but but it is somewhat the same way to do it uh one more thing we need to do is that our conditions will need to get wrapped in this logical F so before we just return the Lambda now we return a logical F of this Lambda so so not a not a huge change to be able to do this so the next thing in the in the monitors is how can we write uh new handlers and and the handlers they are they're even simpler because a Handler is just a function or any kind of callable that takes a Boolean parameter whether or not the conditions that were checked have been violated doesn't return anything so in this case we check is it violated or not if it's not then the monitor passed otherwise the monitor didn't pass you can also add some kind of state to this Handler so if you want an immediate alarm activation we can have some kind of alarm interface which allows us to set a certain alarm we just return a Lambda which captures this this alarm by reference and we just say if it's violated activate the alarm it's it's as simple as that we could also add that if it's not violated anymore then we need to deactivate the alarm so so so each of these things each of these handlers each of these conditions are very very simple in their own it's a single responsib responsibility principle a bit they only do one thing and they do it well so so you can you can test them easily as well it's you can test them in isolation so which is quite easy with this you don't need to spin up this entire monitoring framework in order to check whether your your individual conditions or or handlers do what they're supposed to do and and I think most of these conditions and handlers like they they pass what what I think we can all agree is the most important software criteria which is the PowerPoint test if they fit in a slide they understand and you can reason about them so you heard it here first PowerPoint it's good for software development not so much for code editing though anyway let's get back to to our component so so here we we will try to recreate the members of our component as as we had them before so so we create a monitor for water pressure a we take this pops up framework into it uh we have the condition that the state should be good and the Handler should make an immediate alarm activation of pressure alarm when the condition is violated same for the wind speed we have the condition it should be less than 10 and the handle should set the signal uh wind speed high and you can see it it's quite the similar to to the previous approach that we had uh it's a bit more tur true but you you can still kind of read what what it is that's going on it's a single line that instanes this this entire Handler um so so I think we still have quite good readability in this uh one thing you need to note is that given that that this monitor here is a separate uh type um the the the component member like the MW PM for example needs to be some kind of typ erased uh type and in this case stood any would actually work quite well because because we're using the pops up framework we only need an instance of this monitor to be able to do all the things we actually don't care we don't need to control the monitor after this maybe we need to to destroy it if we don't want this monitor to be there anymore but we don't really want to need to control it anymore so we could just put it in a St any and and we're good to go uh you could also do your own type of of uh type eras if if you wanted to if you do need some kind of handles to to control the monitor but uh but but given that it's an a a declarative interface we actually don't really need to to have any control over it afterwards we just put it inste any we just need an instance we don't care what type it is it just does its thing so we can now look at the the quality attributes for this solution here uh and I would say for this Builder way and this thing that that that has the the solid principles like we have good scalability we can create a lot of these s and it's it's not a lot of code that that we need to add it's easy to maintain all the different things so so scalability is good usability again it's it's quite similar to the US to the utility classes like readability is quite good you you can easily extend them if you want to and what we've gained here is modifiability because now we can add different conditions we can add different handlers without having to open up this monitor class class itself and we don't need to influence anybody else's code if we want to do something that that seems a bit mental to them so yeah I'll show you the implementation now so so what we've had now is actually mainly just which API we would like to have but but the implementation of the actual monitor Builder I'll do here in about three slides so the Constructor of this monitor Builder just takes some conditions it takes some handlers and it saves them conditions and handlers that's these tubes of conditions and handlers so this is all it does there's not more to it what gets a bit more interesting is these Builder methods but it doesn't get a whole lot more interesting because it's still just a couple of lines all the condition method does is that it takes the condition parameter and concatenates it to the Tule of existing conditions and then it returns a mon is a builder with the new conditions the existing handlers and the types we want to check similar to the Handler it just takes a new Handler type it concatenates it to the existing tubal and creates a new monitor Builder so that way we we we build these uh conditions and we built these handlers using these um these methods in the end we have this Checker method the one that actually does the logic in in this class uh again it is six lines uh of course there's some utility functions that that I have made here don't want to show them in this slide I'm going to tell you what what they do so so apply functions here it just calls all the callables in a tuble with the given parameters and then it returns a tuble of results so in in essence what it does is this so results zero Z is M conditions zero called with the arguments results one is M conditions one called with the arguments and so forth so now we have a tu of whether or not these individual conditions have been violated any true just returns true if any element in a tubble evaluates to true and in the end call functions just calls all callables in a tuble with the given parameter so it does this it calls M Handler zero with the violated parameter M hand plus one the violated parameter and so forth so again it is it is quite a simple implementation as a bit of of template in in those uh internal functions but it is it is definitely doable um yeah I note I have not included again any of this specific pops up framework specific code here like here we just made the the operator pen uh in order to tie it into a pops up framework you you need some logic that subscribes to the signals that that you want to Monitor and it should call the operator pen when they change that that's basically what what it boils down to so it's not a it's not a huge task actually to do this one thing that that we would like though which I haven't covered yet is that these conditions until now they have just been hardcoded we say you should be larer than one and smaller than 10 for example but that's not really flexible we would like these conditions to depend on on another signal which can be some kind of parameter which you can set at runtime as well and the monitor should be should be run again ideally now now for this we could make a specialization of larger than which takes a reference to to some kind of parameter type which could be the minimum and then it just checks the value uh for for this uh for this reference uh the problem with this is that's a bit of problems actually so the class that owns the monitor like the class that has instantiated this monitor it needs to have an instance of this parameter and we like to avoid that if if we could because it doesn't really belong there it should belong in the Monitor and also I think that's a bit more tricky is that if this parameter changes during execution then the owner needs to like the one that that created this monitor class it needs to make the monitor check whether these conditions are violated so it needs to subscribe to this parameter and then call this operator paren whenever it is changed uh so because that's not something that's done by the Monitor and the problem here is is that this larger than method doesn't know that it belongs to a monitor it it is just returning a callable so so so it has no clue that that it's actually part of monitor you could actually use it for any kind of other thing where you want to check if something is larger than something else uh so so so how do we how do we um couble this this larger than specialization or this larger than um condition to to the monitor to be able to access this pops up framework and we could give the larger than this o parameter as well that would help a bit then we could get updated the the the parameter but we would still not be able to trigger the monitor which is ideally what what we would like now one solution to this is that we could make all of the conditions we make take an implicit first parameter which is a handle to the popof framework so a bit like this this o parameter here so instead of having a a larger than function that just returns a um a um a a a callable which takes a single value it also needs to to take some implicit extra parameter which is a handle to this pops up framework and and if you don't want to subscribe to anything if this is not a parameter that that can be subscribed to then you just don't use this first parameter you just throw it away but if you want to subscribe to something like this my lower bound parent type is a type I can subscribe to in that case we do use this implicit first parameter and we have in our lamp that we have a subscribed Boolean as well that checks whether it has subscribed so when the monitor does its first um check which it usually should do at construction time because we always want this monitor to run uh then the uh the the we will also subscribe to this uh this um parameter and and the pops up here should also trick trigger the the monitor again once this minimum parameter changes uh so so that is a way to to get this kind of functionality which we would like where we can have parameters that are um that are part of this pops up framework as well so that they can trigger the monitor whenever parameters change as well now it's not only the signals that will trigger a check it's also the parameters now now granted I'm not in entirely happy with this solution because it's very invasive into all of these conditions all our conditions now suddenly needs to take this um implicit first first parameter so so i' would like to have a better way of doing it I haven't yet come up with with a good solution I thought about maybe you can do some SV template trickery to to try to call without the implicit parameter and otherwise called with the implicit parameter and it will all just go in but but I'm not sure it um I'm not sure that's a good way to do that's still work in progress uh so one last thing here should we override and for the handlers here we look a bit at at readability again should we do something like this so that we can say the Handler should make an immediate alarm activation and a delayed alarm deactivation of an alarm it reads out very well the problem is that it doesn't really make sense logically I I think here it falls on the category never do this just because it it reads out fine in text doesn't mean that that it makes sense logically I think this is a case of just because we could do this it doesn't mean that that we should and handers are not not really logical types anyway the conditions I would argue are the kind of logical type handlers are not they don't return anything so yes that's it and I'll answer any questions that you might have I have a GitHub repository here where I'm playing a bit around with with this it's as I said it's not something you can take out and use just as it is it's a bit of a playground for me to to play with this but but you can have a look at it if if you find it interesting and uh and want to clone it be you you can do that thank you thank you for your talk that was really a good overview on and how design interfaces with this um so if you have questions and want to do a further discussion on this with Nikolai um join him in the lunch table and then um he'll be there and I hope that he could answer all your questions in chat and so um join him in the lunch for the questions if you have any questions left you know want to give him feedback and ask him about his um GitHub repository for example and with that we're going to go now in a break and then the next talk will continue and until break you might want to join uh Nikolai at his table thank you Nikolai was a great talk thank you