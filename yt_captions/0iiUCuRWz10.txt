and our guest speaker tonight is Andreas FK who will speak about C++ 20's Co routines for beginners which I think is a really interesting topic to hear about and with that hello Andreas Welcome to our user group hello y yens hello everyone thanks for having me um yeah I think K teens are very interesting topic that C++ 20 brought us so I'm always happy um being able to talk about it so thanks for that opportunity I'm Andreas ftic I work as a trainer and sometimes consultant for C++ I do speak on events like meetups or conferences and I've written a couple of books and the one tool that's called C++ insights that you also might have heard of um which now by the way uses clang 18 but um a blog post is coming about that C++ 20 SCH tees as I said my name is um ftic that's my last name and um some of you might be from Germany so you know the meaning of vertic um some of you might come from a different country so let me briefly explain my last name is an adjective in German you can translate it to English as finished ready complete or completed so very nice adjectives all the time meaning that you're in a state where well you're maybe ready to go to bed or something like that or your project is is ready um your new release is ready something like that so it's a really nice meaning and it's a frequent word in the German language we say that a lot of times the trouble I have often is um as an adjective it's spelled with a lower first letter in German but um as my last name it's spelled with a Capital first letter and um the spell checker has a very hard time understanding when I'm referring to my name or to the adjective and we are still sorting that out and maybe AI will help um to well learn at some time that if I write Andreas fatic then it refers to my last name maybe C++ can help us with that or me what's about C++ and Co routines so enough about German back to C++ one thing that you know are functions right there exist in every language um beside C++ as well so you know them very well and now this new thing came along called K routines and the question is what's so great about them and why didn't functions no longer work for these scenarios or do so on the left we have a typical control flow of a function call we have a caller that places a for call to a function and that function runs does whatever it has to do until some point where we return from this function it can be a early return that can be a late return we can have multiple returns in that function it doesn't matter you know how the game works once you return you give a result back to the caller that could also be void and everything that you computed on in this function on the stack during this call it's destructed it goes away the caller obtains control again and it can call the function again but it starts from zero which is a very great um option usually cortines on there their hand they provide us with something that they can be resumed so they Preserve the state my control flow here looks different so we have a caller that calls our Co routine and more precisely it's also referred to as a cortine function so it's more or less like a function but a special one so my C te now takes control and it does some computations that at some point it decides to give control back to the caller but as opposed to regular functions a cortin has the option to co yield to co weight which isn't shown here or to co return so it's not a sole return we have multiple options the core yield as I show it here means we're giving control back to the caller but the coroutine itself still continues to live and it still preserves all the state of all the computations it has done so far so giving control back to the caller that means the caller can now do something with the result very much like if we call a function and get a result there so caller resumes its regular work and then at some point it decides to invoke the cotin function again and that one now continues where it was left off so it's resumable quines are also referred to as resumable functions so my ctin and my example here now continues to do some work and at some later point it co yields another value to the caller the caller now continues it its processing and for one final time it invokes the cor routine function again this one runs at the very end it then cor returns so if you core return from a cortin function that's very vital this is very similar to returning from a regular function it means that a cotin is finished at this point so it's fertic and you're not supposed to invoke this cortine version again if you do so that's undefined behavior and we don't want that so this is the big difference between cortines and functions cortines can be resumed they preserve their state all this works roughly that we get a handle of a core routine which we will refer to later to resume the coroutine again this is how we can preserve the state here and on a bigger picture cortines where they first so cortines are the super set of functions because a regular function as we have it is just a specialization of a cortine which does not pause it's simply Co returns you can see it like that so despite functions in reality where first cents were added later even not just to C++ but in general to programming languages cortines are the super set okay and regular functions are just a specialization of cortines the term cortine has been well established in computer science since it was first coined by Melvin convey in 1958 if you look at cortin across programming languages you will see two different terms coming up stack full and stack less Co routines first of all C++ implements stack less cortines and what is stack less and stack full refers to is what I just showed you in the picture that a cortine can be resumed still preserving its state that's no magic what we are doing here is we are storing that result somewhere and this somewhere can either in an implementation be on the stack so we have a dedicated stack space where we store this ctin information and all the data on the ctin stack or we do not store It On The Stack that means we store it on a heap so in a special Heap allocation or special Heap segment which is what C++ is doing this is why we call that one stack less okay the information still has to be stored somewhere so do not get fooled by that but we are not using the stack we are using the Heap it also means that by default each coroutine you create for the first time does a heap allocation okay there are ways around that but they are more complicated and do not work all the time but there are ways the default is he allocation if you're talking about cortines you also often talk about Cooperative multitasking versus preemptive multitasking as you might know it from St threat for example which is another interesting property I will talk about that later what are cortines for well cortines can help you to simplify your code we can replace some function pointers AK callbacks with ctin and our code becomes more readable because we see the control flow better parsers can become much more readable with coroutines I wish I would have had um coroutines in the language years ago um some of the passes I wrote would have been easier to write and to read and to maintain and all that this is my third point a lot of the state maintenance code that we usually have in our code for doing things without cool routines this bookkeeping is now done by the compiler by the cool routine which means that we are free of doing so that means our code here becomes well less it becomes with that easier to read to maintain to BU fix and all that so these are interesting features of Coe routines how can we interact with a cortine in my initial control FL chart I already showed you the various options in C++ 20 we got three new keywords in the language Co yield Co return and Co weight Co yield and Co return are more less an output action so we pass some information back to the caller the difference between the two is if I co yield the state of my co routine usually becomes suspended means it's pothing and waiting to be resumed or to be destroyed cor cor return on the other hand the state after C returning is Ended as I already said you should not invoke a cotin that Co returned that's undefined Behavior it's similar to function that is returned the third in the game is co weight Co weight is the opposite of Co yield and maybe Co return it's an input action so this is how we can while the coretine was already started pass information into the coroutine the cotin can say it coits for more information the next bite the next user input whatever so this is an input action the state of murtin is it's usually suspended at this point because it waits for more information this is like a delayed parameter if you want to a function so usually we pass or we have to pass all the parameters during the function call to a function and with Co weight we have a delayed version asking for more information for the next parameter so to speak so these are the three new keywords you have there's a bit more what are the elements of a coroutine in C++ a coroutine consists basically of two um elements I would say the first one is a reper type this is the return type of your core te functions prototype so if you have a function and you look at the return type this return type here for core team this is what I refer to as a reper type this reper type has a couple of Specialties the compiler looks for and with this reper type we can control the coroutine from the outside world so this is what we are getting back once we invoke the coroutine for the first time so this gives us the control over the core routine so we can for example resume the core routine or we can pass more data in responding to Coe all that by storing a handle of the coroutine in this reper type so in a very simplified model you can think of a coroutine when you first create it like you're creating a regular object with new what you get back is a pointer with this pointer you can control your object you can invoke all the member functions you know that are there and once the ctin gets created the first time we are getting such a pointer peack the pointer to the Heap handle in the end and this is stored sometimes sometimes not in the reper type and if it's stored it gives us the ability to control the cotin from the outside well the second part now that's mandatory is that the compiler looks for a type with the exact name promise type inside this reper type so inside the core routines return type and with this reper type we can control the co routine from the inside so we have a lot of customization points there and this is the part that makes cool routines in C++ less beginner friendly because you have to configure them as opposed to python where you simply can start um this allows us to trim Co routines in C++ to nearly every use case and make it real efficient for all the various use cases but the one use case that it doesn't Excel is starting as a beginner with a coroutine so you cannot have all this promise type the name here this type it can either be a type Alias a type Dev or you can declare this type directly in the reper type so having a struct inside a struct for example there are two optional parts of a CO routine one is an avitable type that comes into play once we co weit so this is a special thing that we have to care for when we co- wait I have an example um for that later and the fourth part is an iterator because cores can really easily model an infinite stream of data what we often want to do there is iterate over this data and this is the iterator part so the letter two are optional the first two are mandatory and with the customization points I already touched on that point a cotin in C++ in the end is a finite State machine that can be controlled and customized wi the promise type so this is the big secret behind them and the actual cotin function which uses Co yield Co weight and Co return for communication with the outside world so this is what we have here and um this one gets heavily transformed by the compiler to well touch all the hooks we created in our reper type compiler expects us so this is the theory behind it now we are ready to look at some examples so C routines life and in action but sadly before doing so there's a disclaimer um I wish I wouldn't have to put it in there but I fa it's necessary in my experience cotin in C++ are somewhat difficult ult topic mainly I think because of the customization points so I wanted to give you an overview about core teens and do not distract you by other parts of the language that you might or might not be familiar it's simply a risk of distracting you so I try to keep the code that you will see on the next following slides as simple as possible I wanted to focus on Coe routines only in production code I work with way more public and private as well as potential Getters and Setters additionally usually I use way more generating generic code in production to keep repetitions low I decided to totally get rid of templates for this talk um my goal here is to help you understand co- routines or make you familiar with them and I'm confident that you can improve the code that you will see with the usual C++ best practices yourself okay so that's all fine there's one little cave um I also never declare more than one variable per line believe me I I teach that um slide code and to be precise this talk is some so far the only exception so bear with me there sorry for that but I only have so much slight space so here's our first Co routine our Co routine here at the top and line number one in a is called fun and what fun return returns here is a type called chat okay so we haven't seen chat yet comes on the following slides but we know it's the return time if you're looking in the body of fun we can see it has a cool yield a cool weight and cool return in it so I'm really happy I could squeeze all three in but nevertheless one would be enough to say okay this is Co routine so this is a similar check that the compiler does and that means the compiler and we know that chat is a reper type it must contain a type called Promise type if that's not the case this code would not compile so we know that without knowing anything else about jet now what my cortin does is in B here it co yields a stood string hello in C then it co waits for another St string so I'm simply using the type here waiting for new St string and printing that one out to see out and finally in D the co routine C returns here so that's all this koutin does I use it down in use in E here I'm invoking the coroutine fun for the first time and that means I'm getting back a pointer so basically behind this fun call there is a allocation in new and I get this pointer nicely wrapped back in the chat object so chat here I call this variable Marco Now controls or holds the ability to control the C routine the first thing I do here in F then is I call marco. listen so Marco listens to the noise that's around here using the co routine and then in G Marco answers to something he heard and says where are you and then finally in h Marco listens again with the routine so you haven't seen all the functions that's fine for now if I would execute this kurtin the kurtin would say hello and Marco would say where are you and the kurtin would reply here so very basic chatty thing so that's all it takes right and this code here it's really nice fun doesn't have to store any state where it left off it can simply continue so for us humans control full Dev this is really nice to read and I would be really happy if we could stop here and um that's all about coroutines but it isn't so we need this reper type but inside this reper type we have this promise type so let's look at the promise type first in a here at the top you can see H the real dry I have this two stood string variables declared in one line and I picked two because I wanted to make it clear that one holds the data that goes out of the cortin and the other one holds the data that goes into the cortin technically I wouldn't need two variables because I know they do not overlap but this is the easier to read Word I guess so cortines can hit exceptions um what to do there and how we control that is out of scope for this talk but in B here we look at the first customization point for our Co routine unhandled exception you have to spell all the customization points exactly as on the slide if in um the case of final suspend it must be no except for the others no except is somewhat optional and the return types can also vary the first custom customization point that we need I would say all the time is the one in C get return object get return object gives us a way to construct a chat object wrapper type around it and return it the difficulty here from a compiler's perspective is the compiler doesn't know this type chat so does it have one parameter 2 three four what are they in types references pointers and so force and it's hard to teach the compiler that so the easiest way is let a compiler call a function like get return object and in that we as programmers can Define how to call this function we create the object and simply return it so this is the entry point this is where the compiler gets the ability to create a chat object without knowing what Constructors exist as a force now once this coroutine was created the first thing the compiler does after a couple of bookkeeping things is it hits the first suspension Point called initial suspend so that is a very early one you can say it's the one after the col price opens something like that so the ctin has been allocated the parameters have been transferred to the core routine frame and local variables if necessary things like that so this is where you can decide to pause this is what moutin here does it says suspend always or you could also say continue to the first real suspension Point by returning in other new type here so suspend never suspend always and suspend never are two helper types we will see them later that C++ 20 gave us they the names hopefully speak for themselves and um technical details aside this is what initial suspend here does the first real suspension point in my case for the cotin fun here is when I say Co yield for the first time so that would F be F here yield value yield value is one more customization point I return suspend always so that means after I'm yielding the ctin is suspended and this parameter to co to yield value I can take everything I want so every type that's known in the type system at this point it can be a pointer a reference an R value reference a cont reference and so forth so you have the full flexibility it can also be a throwing function in my case I simply um do not throw here so no accept is fine is fine tuning what I do in yield value is I take this do string by copy and then move it into MSG out and after that returning suspend always default constructed because fun also contains a core weight you have to handle that one and there is a customization Point called a weight to transform which is see in G which here is invoked with is a St spring parameter it's the same pattern as for yield value we can have different overloads to these customization points to take parameters we could have one for St string one for IND and so forth and they get overloaded so my a trans form here is the reason why I co- waited for a St string object for an empty one to invoke the function G or the customization point in G away transform here a very transform now does something that I started doing more and more with Co routines it declares a struct waiter inside this function because it's only needed and required there and only makes sense there a waiter stores a reference to the promise type and it declares the three member functions a wait ready a weit resume and we to spend these are three more customization points that are abstract in other cases by suspend always or suspend never they implement the same thing so here is my own version await ready return returns true await resume here this is invoked when the ctin gets resumed and that means I'm moving the message I stored um into the internals of the coroutine so to my see out inside fun and a way to spend allows me to be notified when the ctin get suspended and getting to know the ctin handle of this ctin and I have an example for when that's interesting later so then I'm returning a freshly created avator struct at this point and um the final two customization points we have are return value and final suspend return value is different to the others because it always returns void it's return so we cannot decide whether to resume the ctin or not the rest is the same I can have return value for a St string for an INT overload if the rest of the Machinery here can handle that that's totally fine for the compiler I take a St string like in yield value by copy and move it to MSG out in I here and then finally in final suspend I simply do nothing returning a suspend always I can also decide to say never here that means the cin would flow um to the end of the control flow and to some decree destroy itself I have an example for that also um in a different context later so this is the promise type and then here is the reper type chat line number two here is also somewhat un nice I'm not doing that in production code this should simply visualize for you that the promise type that I just showed you on the previous slide goes there copy and paste basically so what my coroutine chat here does or my reper type is in a I'm creating a CO routin handle a stood Co routine handle is a new data type in C+ plus 20 typed was my promise type and then I use that to say that chat here now takes a promise type by reference and it invokes a static member function from promise on this ctin handle um for a promise type and this one is able to convert a promise type to a Quin handle so it fetches the pointer that's behind that stored in some compiler handled translation table that's all so this is my Constructor because of this handle thing because this is much like a pointer your reper type most often should not be copyable because then you're duplicating the pointer and you destroy one object and the other one well doesn't work anymore typical issues with pointers here so this is why in C here I'm saying my cortin is move only by providing only this function I automatically disable the copy operations and there I'm simply exchanging the handles from the right hand side to my side and store it this handle is also the reason for the Constructor that you can see in D here if this reper type here gets destroyed I have to take care of the cotin handle so I check whether the handle is still valid and if so I call destroy on the handle that frees the memory behind the cortin and the cortine ensures that all the objects on it get destroy first and then we have in E and F the two member functions that you previously saw being used so listen here returns a to string it checks whether the cortin is not already done by invoking done on the handle and if so it resumes the cortine by using the cortin handles resume function once the ctin has been resumed and suspended itself again I'm using is to move using the handle to get to the promise type reaching for the MSG out variable moving that one out of listen returning it to the caller in my case marker answer is the other way around I receive a stood string I move that into the core teens promise types MSG in variable and I'm checking whether the ctin is not already finished and if that's the case I resume it you should never invoke a ctin that's already finished or done that would be undefined Behavior again so these are the pieces in code that we need to make our ctin work in the picture shown on the left we have the user written code so this is what was in the function used previously I have this courtin creation storing that in the um variable markco and then I have the invocation of listen answer and listen again we also saw the reper type chat and this reper type now it must contain a promise type but what this promise type contains aside from the customization points the cor compiler doesn't border so that I have two stood string variables in there it's totally optional to the machinary it's just required for us to store the information somewhere and the same is true for for the two member functions listen and answer in the reper timee this is my design you can spell answer differently you can spell listen differently you can avoid them totally and give the outside world access to the co routine handle that's all fine that I store a coroutine handle in the reper type that's also optional to the compiler it's necessary for my application but in there are others where it is not required and the thir box on the right this is the the compiler implementation this is the hardest part about core routines in general here for compilers because my actual cotin function the one where I'm saying co- yield co- weight and Co return that gets transformed so all the calls to co yield for example get transformed to call to yield value of my promise type so this one gets heavily transformed by the compiler the other part is the parameters to this function or all local variables they are not on the stack as usual the compiler transforms them to point to data on the ctin frame even the parameters so they get copied there so this is when the compiler does the he location for the ctin frame and it places all the parameters into the local variables in the ctin frame so this is the compiler part and this is where the heavy transformation happen all right so our first core routine excellent I have a few more and for them I have two definitions the rest of this talk I will refer to a task as a cortin that does a job without returning a value and the generator donates to cortin that does a job and returns a value either with cortin or Co yield okay so for now these are the two definitions for the rest excellent I promised you showing you the helper types so here are the two helper types for my cor routine suspend always and suspend never they come in the C++ 20 STL so you do not have to write them yourself the only difference between the two is the await ready result await ready for always way returns false and return or AIT ready for suspend never returns true okay the nice names should all only indicate what's happening and I already showed you with my a waiter that we can Implement these customization points ourselves and there are couple of examples coming where we do this more excessively good so let's have a look at another task for core team interleaving two stood up stood Vector objects what I mean by that is I have a St Vector a and a stood Vector B both filled with a couple of integers and the result that I want print out is one element from Vector a one element from Vector B one element from a from B and so forth so inter leaving the two if one runs out of elements only the other one um continues to be printed out so how do do we do that with ctin here's my Approach we looking at a c routine itself this time it's called inter Lea it takes two St Vector objects of type int by copy and it returns a generator object so once we start scanning this function we can see in line number four a CO yield so we're talking about Co routine that means generator here is a promise and must contain a promise type it is a rer type starting to look into inter Lea I managed to squeeze lambdas into this talk because lambdas can be coroutines as well so the first thing I'm doing here line number three I'm declaring this Lambda lamp and that one does not capture anything but it takes a St Vector of in by reference and it also returns why the trailing return type a generator object here and internally it uses range based full loop to Loop over this Vector over all the elements and yield each element from this coroutine so this is a nice and easy way to get a stream of data that can be interrupted I use this Lambda Now to create two more Co routines so actual Co routines this time in X and Epsilon in line number seven and eight by invoking the Lambda with the two parameters A and B subsequently and then I'm using this ctin X and Epsilon in line number 10 in a y Loop this is another pattern that you will see would say often whis Co routines this infinite Loops that are terminated by some other condition then really um the one that we know of so in my case here I'm calling x. finished and Epsilon not finished so I'm checking basically is this coroutine X or the cor routine Epsilon not yet finished and if so I go into the Wilds body and there I do this check again so I'm checking first is X not finished if so then I'm Co yielding X not value and next I'm resuming X so we have the functions finished value and resume here this must be functions member functions of my generator type we will see them later and then I'm doing this same thing for Epsilon so that means that thing here checks first that a ctin X is not finished if so it yields a value from X and then continues or resumes the Quin of X and then it goes to Epsilon and does the same thing for Epsilon and would one of them run out of values it would simply no longer be processed but the other one would still generate values so this is in 21 lines how we can inter leave Co routines without looking look at a promise type and reper type right my promise type this time luckily is I would say short so the promise type here stores an INT member Val it implements get return object by returning a generator the pattern is the same as for chat I'm passing a d reference disp pointer here I Implement initial suspend by saying this time never and doing nothing just returning that final suspend as always and yield values as also always it takes an INT parameter stores that internally and then we have return void here doing nothing this is what's required if you do not have a cool return in your cool routine so you cannot have a return value then you have to uh Implement return void despite it not being doing anything here and I'm not handling exceptions so that uh customization point is also empty the interesting thing here is my initial suspend because this time I'm saying suspend never that means once the ctin gets created I continue running until I hit the first real suspension point and this is vital for the code that I just showed you because there the order was yield a value from X and then resume X and this is only possible because course X already holds a value because it reached the first non-initial suspension Point here is the implementation of my reper type generator as previously with the fun or chat example I'm storing a coroutine handle M handle here my Constructor takes a promise type by reference converts that into a cotin handle it's move only it cares in the Destructor about destroying the ctin handle value now uses the handle to reach the promise type and we start getting exit access to the value member finished checks whether the ctin is done or not and resume users finished to check whether it can resume the ctin so these are the um member functions that you saw before so and this time the code is shorter than I would say for the chat version and this gives you the ability to interleaf the two St Vector objects as I shown you the usage here is the following I have the St vectors A and B I'm calling my ctin in Le here moving the two St Vector objects into in Lea getting back a generator object and I'm now using that with this y Loop here check checking that my coroutine isn't finished and if not I'm see outing the value stored in coroutine and after that I'm resuming it well that's easy okay is it I mean yeah the cin works I like it I don't like this part particularly I don't like the Y Loop um the previous one all right that gets hidden into the ctin but this is the code that users have to write and that one is not nice it also has the risk that somebody calls resume before calling value and either it crashes or the people then miss a value so that's that's not great not at all so I would say the next task is that we require blastic searching not the regular one one for code this time so not changing your skin or so I'm sure you also would like to use a range based full loop instead of the Y Loop that I just CH you right so let's make that happen let's see what's necessary to achieve that we need an iterator so this the third part or initially it was the first item on the elements of a core team that I showed you so an iterator must satisfy the iterator concept that means it must be not equal comparable increment and de referenceable what you see in code on the right here is such an iterator i store a cotin handle here I implement the equals operator I'm on the positive side and in C++ 20 the compiler understands to transform a not equal to an equals equals so I'm implementing that one here that one takes a sentinel there just stood default Sentinel and C++ 20 because I do not care about the value from the other side the ctin itself knows when it's finished with its function done so I'm using that to get the knowledge whether the ctin is done or not transferred out I implement the pre-increment operator here that one resumes to C routine and after that Returns the reference to itself and a implemented e reference operator that one fetches the value with the promise type where the handle and Returns the integer here so this is the iterator part let I would say all right what's missing here to make the whole Machinery work is our generator must now consist of the two member functions begin and end the other version would be using free functions but that's more complicated for that example so let's use the member functions so begin here returns a new constructed iterator object where I pass the handle to that's stored in generator and end returns a default Sentinel so this makes the Machinery work and the is rator encapsulates everything this brings us to the much nicer code at the bottom right of this slide here I have as previously my two stent vectors A and B with a couple of numbers in it I call in the Lea moving the two vectors into that Co routine I'm getting back a generator here on object of type generator and now thanks to what we just did to the C I can use a range based full loop looping over the values from this generator and nicely seeting them so this is a real cool abstraction because this is easy to use and very hard to misuse so apis should be like that the previous version with the by Loop was way too easy to well get yourself in trouble so this is why iterators often come with schol routines in C++ 20 or in C plus plus in general now all right that was in leaving two student vectors what's next well another task is scheduling multiple tasks right why not so how does that look like but first let's compare Cooperative to preemptive multitasking preemptive multitasking as I initially said is the thing you get if you're using a St strad that means me um the thread itself has no control over when it runs on which CPU it runs or for long how long it runs this is controlled by the operating system this is often real good we want this um The Sweat should simply run as efficiently as possible and so forth but sometimes we want a different level of control and this brings us to Cooperative multitasking there the threat decides for how long it runs and when it's time to give up control to another threat okay these are two interesting features you can actually also try to pin it to a CPU but let's neglet that one one major difference between the two um things you can have here the two different ways is instead of locks in preemptive multitasking we use Coe yield or Coe weight in coopertive multitasking so you practically can go lock free because your threat Now controls when it gives up control and it can do that when it knows it processed all the data something things like that so that makes your code easier but you get different properties how does it look like let's say I have a Schuler here I want to implement something like a very simple operating system I have the Schuler in line number three and call it Schuler and after two tasks task A and B and I pass a scheduler to them and then I'm invoking the scheduler scheduling the tasks until there's nothing more to schedule and then I would return so this is the overall picture my two threats or two tasks A and B here look like this they're more or less exactly similar to each other there's only a slight difference in what they print out so task a says for example hello from task a while task B says hello from task B so this is basically the only difference the one says a the other one says b both take a schedular object by reference both return a task object and both print out something and then they use Co we and use that together with SC do suspend so this is here my suspension point this is where I give up control to the other task so where either a gives up control to b or vice versa as long as I'm not saying core weight I'm uninterruptible assuming you're not using um preemptive multitasking with threats as well in parallel so what does implementation look like first of all here's my schul my schul uses a stood list of cortin handles this is a special cortin handle as you can see it's type with nothing so it's a void ctin handle and this is enough for me in this scenario because all I want to do is resume a ctin and for that I don't need to know the specific type of this ctin handle so this is type eraser to my benefits I call this list tasks here and then I have my function schedule schedule pops the first item from the list checks whether this cortin is isn't done and if so it gets resumed and as a result of schedule the answer to his tasks empty or not gets returned so are there more tasks to get scheduled suspend looks a little bit like what we saw previously with um a weight suspend I'm creating a AER struct this time a slight variation I'm deriving from suspend always just to show you that this is also possible I'm doing that because I basically implement this to suspend always here the different is the difference is my await suspend so my a waiter here stores a reference to the Schuler and this is why I need a Constructor here to set up this reference but the only thing I really want to override from suspend always is a weight suspend because this time I'm interested in the co routine handle once the coutin gets paused my weight suspend gets invoked and I'm using that to reaching for the schedu task list and push back this coroutine handle so this is how I inserted into my task list and as a result of the spend I'm returning such an a waiter struct constructed with d referencing um the disp pointer essentially getting a reference to the schula down so this is my schu you can perfect the ad way more it's a very simple non sophisticated schul but it does the job and this brings us to the potentially shortest promise type and repid type that you can encounter it's my repid type task which contains my promise type here get return object returns a default constructed task object nothing to do here initial suspend says never I want the task to start directly you can control it here you can also say well I want to kick it off at some point so do not um start yourself initially and suspend final suspend says also suspend never so this helps me here because task doesn't store the handle of the cool routine this helps me that a compiler can clean up this Coe routine automatically I do not Co return so I implement the customization Point return void leave that one empty and I'm not handling exceptions so that's it these are all the ingredients to need you need to build yourself a very simple schedule what if you want to implement a variant of that variation let's say you want to be able to spawn tasks without knowing the schule that means we most likely have a global schule trying to indicate that in line number six by naming the variable now GCU for clobal schu but my tasks A and B they no longer take a parameter the rest Remains aully the Same here are my two tasks A and B as previously with a slight um variation they obviously do not take any parameters anymore and that means my core weight can no longer reach for the schedu I could of course you know invoke the global schu GC but let's say we do not want to do that I'm co- waiting on a new created object of type suspend here so I'm always creating a new object here so slide variation what does that mean well for my schula itself it doesn't mean very much I changed a couple of things so now I have a suspend function here that takes aurity and handle and pushes things back to the list that's just a small beautification and I have my schedule function that's exactly the same as before getting the first entry from the list checking whether it's done or not and returning whether there are still tasks in the list to process the major change is this one here in line number one I have a global SC object now I made that one static and in line number three you see the new type the new struct suspend and suspend and this is the reason why I wanted to show you that implements a core weight operator so in C++ 20 among a lot of other things you also got a new operator and this is the co weight operator and that comes into play with Co routines where we say Co weight and the nice thing here is now that is more or less stateless Implement my operator here I use the same trick as before I say I clear a struct a waiter that one derives from suspend always and it overrides the await suspend um M function here or customization Point doing the same thing as before taking the co routine handle as a parameter and using the clobal schedular object to push it to the list of tasks so this would be a way where you can say okay you want to suspend on different schedulers so you can have different suspend types that then hook you to the different schedules so this is another way of implementing a scheduler in C++ in general it's always about scheduling when you're looking at coroutines even for my coroutine chat I had a scheduler I didn't name it that way but my function used did schedule the coroutine because it decided when to resume and when to put data into it so this is one instance that you always need with coroutines the controlling instance whether you call this a Schuler or something else but you need something that handles your cines okay it's very important cortines come with a couple of restrictions or limitations a Conex function cannot be a cortine subsequently the same is true for const evolve functions available in C++ 20 so we are not doing at least at a moment coroutines at compile time neither a Constructor nor Destructor can be a coroutine if you well briefly think about that I think it makes sense um what would a half constructed or half destructed object mean so this not possible it's All or Nothing in this case a function using VAR arcs cannot be a cool routine and these VAR arcs are the stuff be inherited from C so if you're looking at a printf function um where you have the three dots this place where the stack and this cannot be a CO routine a vartic function template on the other hand works because this is a template so we know all the types everything is preserved so that one works with the cotin a function with plain Auto as a return type or with a concept type cannot be a CO routine Alo with trailing return type on the other hand works I showed you the case with the Lambda and there I showed you the trading return type my Lambda would otherwise default to returning Auto and it's not possible so we need to tell the compiler which Co routine it returns or what the rep type looks like in this case so per ctin cannot use plain return that leads to an error you must either use Co return or Co yield and last but not least some other thing that cannot be a coroutine is main the same thing as for a Constructor would apply but would a suspended main mean you need something from the outside that resumes it but well what's that that um top level main so main cannot be a ctin as well and lambdas I showed you that they can be cortines but you have to watch out and use the trailing return timee this is cortines in C++ 20 I hope um you learned something today and I could well gain your interest for cortines I think they are real great tool for C++ 20 and 23 and all the upcoming standards if you have more interest in cor teens you can head over to my newsletter And subscribe and getting a cour in chii it contains three pages relating to the talk here where I try to you summarize um very briefly how you can interact with cour and so forth there is a longer chapter a dedicated chapter in fact in my programming with C++ 20 book so you can also um check that one out or of course there are plenty of talks recorded on YouTube either by myself or by others talking and teaching course roues I hope you had fun with that and um for my part I am ftic and waiting for your questions thank you thank you Andreas that was a great talk um especially about Co routines so see you know let's coate the questions all right so um you already quickly mentioned 23 so just let's start with you know what what's going to make it easier with cortines and 23 um so 23 gives you stud generator um the generator is a type that's uh yeah that was missed in C++ 20 because we have to write all this boiler blade code ourselves um for a lot of use cases I think the generator is a helpful new element in the standard library but you will well probably find out um after using it for a while that it does not satisfy all the use cases so I didn't apply to generator here for this talk because um it does not work um I think in all my cases because that one is more driven from a ranges part of view where you get a constant stream of data which you Loop over but it's hard to interrupt them and so forth so for some scenarios it's a great thing but this showed that um providing a library type which is a question that very often comes up um why do we have to write all this Boiler blate code coming up with a library type is very difficult because quines are so flexible so every type we can come up with likes to generator limits them and for some of us this is great because this is what we need what we want and for us it simply doesn't work so other than um the generator I'm not aware of other changes to co routines in C++ 20 three sorry all right so the next question is from or not sure if I understand if coroutines can run parallel like threats or if each time it progresses a different part function okay that's a good question um one can argue that even your threats do not run in parallel um because even there you have a schul that decides that but you can of course distribute them on different cores so cortin in the end is a function that means one runs at a time it runs until it co- returns it co- weits or co- yields okay this is the suspension point that gives in not Co routine a chance to run um I hope my um schedule example may be Illustrated that a little um or the chat example before you can also use that in a way that it chats with different people but it does not run in parallel in the usual sense we mean it when we are looking at for example St threat you can of course mix things so you can mix Co routines with st threat um a threat can invoke a coroutine and pass that one to another threat such that that executes it further and so forth but I think for yeah for simplifications it's easiest to sing about coroutines as functions and they themselves do not run in parallel I hope that helps yeah I think um parallelism is a different context then and coroutines do not paralyze by themselves yeah they inter Le I think that's um that's a good thing to seed with respect to restrictions how deep can a chain of cortines go E A chotin calling another chotin calling another chotin in particular with regards to the frames that are stored on the Hep well I would say you can go as deepers you have Heap for that um so there are no restrictions you you can in fact um have cortines inside cortines um the generator in C++ 23 supports that elegantly um the only thing really that limits that is your HEAP in the end um so you can do it yep um question on standardization do you know why when all and when any Co routine versions have not been accepted to 23 do you know why I have not been have not been accepted to C++ okay um no um I I don't know or at least I don't recall um are you involved on the committee with cortin I mostly spend my time in ew WG and this is more Library question so um no not not not really so the the standardizing questions or the future questions or what what should be standardized this prob um so uh one thing I want to say is like keep your questions on LinkedIn short um because this is a bit too long um thanks Adreas your first slide was Co routines versus functions and the main idea was to retain State maybe an additional slide with coroutines versus fun as functions with state would be relevant uh people have been using functors for this for decades implementing simple State machines and I wonder how much uh more convenient is using coroutines for this versus the old way maybe there are sub subties not clear to newcomers justifying addition to the standard yes um thank you for that um I have a longer version of this talk but this also usually does only touch on the surface um showing the difference between functors or um callbacks and all that stuff and cortines usually requires a bit more code and with that a bit more context so a month ago I think more or less today I did a class um at CPP online um a one day training about C tees and there was time for that because this is the the real interesting part but it's um I haven't found a nice way to capture it in in one slide or to to um yeah compare the two to each other I have one um if you want to reach for that um I gave a talk an extended version of that one at CPP North last year um after the first hour I show a um a passer implemented in a more traditional way compared to a Quine function but it requires simply more time for this talk and it's still not um not sufficient but this can give you a better picture of of how to two compare if a cortin runs for very long will it be preempted no um it will never so you are in Full full control that means you are responsible for that um if if you're counting CPU Cycles or things like that and you can try to trim it very nicely to the Cycles you have left or the time let's say in milliseconds your operation takes but if one violates these rules and takes a minute where only 10 seconds were allowed you have to well detect the situation and um reboot or terminate whatever um you cannot preempt a coroutine it's a function you cannot interrupt the function aside from sets Okay um Paul asks will cortines affect how we code with Boost AO that's a tough question um I'm I'm not sure about that one um there is another feature another Library feature in the pipeline for C++ 26 um senders and receivers and I think that one matches more closely what boost ACO does than coroutines I think you can do similar stuff with cortines and maybe more easily or or more with the standard but um I think senders and receivers will get you even Closer by um yeah providing you um standard Elements by the standard Al so I think it depends a bit on AIO if AIO provides basically implementation of coroutines so that you can actually you know coate an AIO function um because as far as I understand that it's like a library thing yes yeah um and so you know um we just love ask like where do we have more information on this topic resources links um I would simply ask the chat to post things and Pages they know about and maybe also Andreas to do that later and um so um Andreas has a website as you see he he links to ftic to subscribe where you can go can have us um kurtin cheat cheat sheet yeah no cheat sheet that's the way and there's his book so um these links are probably helpful and Andreas can you know probably add a link to his blog Etc um to the chat later um what added coroutines brought that what yeah basically what's the difference like you know multi threading is different from what coroutine is doing and I know that is like a difference which lot of people don't really um understand so much um yeah that's another good question um there are the two models are fundamentally different so um cortines because they can suspend that a point um and can be invoked later and preserving their state there are real great tools for the already mentioned parsel to implement um your multi spreading does not do you any good there um the other thing is I um it depends on um on the the the task you really have um in in this this one day training I did I compared quines to threats and my example there was a very simple ping pong so one thre says ping the other one says pong so one comes the other one comes and so forth and I did the same with school routines and I let it run for whatever thousand turns or something like that and um in each and every try the cor did beat threats by a lot because they are Lock Free and if you have such a pattern then you might look for core routines because they can save you time you also are out of all this oh I did forget to lock a data structure now I have corrupted my data um this does not happen there at least not that easily so this is only true if they do more or less the same things um once you do more ready like things then cortine might be the wrong tool so we had this question before if you do not want to care when to give up control then cortines are obviously the wrong tool for you okay you you want to get interrupted like with a St thre not notice that and everything is good so it's just a addition to your tool set that you can use now in in different or new places or exchange it with existing implementation as I said parcel is getting easier there's nothing that's really nice to solve is St threats um if you have simple tasks ctin might be faster than St threats and courtines are lock free so you do not have to care about locks there so these are variations and of course you as I already I think mentioned before you can mix the two together so that makes it even yeah more interesting I hope this answers the question I think it um one thing I've noticed with the generator example was that it's basically very similar to the zip view which we get was uh 23 so I wanted to ask you like you know um would that be better what's the difference to like using Kines and to use as zip VI I saw implementations using CES implementing that zip view I'm not sure what they finally do um I wouldn't be surprised if they're not using cortines but it might depend on your perspective if you're the user then you might not care which one of the two you're using if you're an implementer you might care about which one you're implementing um in the end I understand they are both doing or they are both giving you the same result um sure sorry so basically what you're saying is that the code routines are potentially the implementation of the zip View I am I remember or I think remember seeing one implementation like that yes but I'm not sure if this a final implementation because the ctin would do a heap allocation and I'm not sure we won that with the zip VI so yeah this is um I I would assume they're not using cortines but I'm not 100% sure well regarding usage examples in addition to pares could you name more of the typical examples and use cases where using coroutines would be beneficial well paros is um I did a lot of networking so I wrote a lot of parsel um this my usual example but what they usually have is some some way way some call back informing you that you received enough data to form whatever it is you want a frame or something like that and um this is a callback so call backs are essentially the other example or or the the broader topic of examples in um in mechos there is a um a way to register for hotkeys for hotkey WS if I press um Apple t or something like that that can be notified this is a typical example I have this register function where I pass a call back to and that one gets called later and I'm not seeing why and variance of force with a coroutine you can register there and get paused until you or your user hits the corresponding key action and you get resumed exactly at a point where you left off okay so you see this Handler a little bit better and you do not have to play this IND Direction at least visually for our eyes with the function pointer so function pointers are something that you can get rid of in a couple of places at least and replace them with cortines and it always boils down to your code becoming more readable because you then see better what's going on and where you left off this is something I can offer from the top of my head had um yeah I think we had to Z few examples or things like that I think that's something I can agree with that basically when you have a call back and you then you can call Co weit and you know pass the context of the current running function into the next function and then wait until uh that Returns the value you usually would get to the call back okay there's an EST question um will the parallel sdl algorithm execution policies gain a coroutine version or would that be useful so it's once again more for Library Evolution um I haven't of such a proposal um I'm not sure if it would be useful because remember it would not be really parallel so you have to give up control and I'm not sure if for these types of algorithms this is an interesting feature yeah I think that is um from the extens of questions I can see currently everything in the chat if you have really question um added to the chat um so there's one thing I see here is like um Cod routines are not for Io okay um they can be used for that but there's other use cases for Io for for cortines than IO right um I'm not sure um what's really meant here but um quins for example could in fact be a nice tool to um if you're on a microcontroller and um one event happened and you have to read that one let's say data from the serial um Port um simply write it in a buffer things like that I think that could be a candidate for quartin instead of a threat um especially if you go with low resources you might not have threats avable but you can pour there wait for more data and and then um say okay I've received enough here um somebody handle that but yeah maybe a question is too broad to really say yes or no you show the schedular example which you know basically could be used as a game Loop which CPU and GPU so um it can be used for Io and IO is definitely a use case when you like you have a function opening a file and you wait for that in the code and um but it's not the only use case and it's not meant for it to be like IO we still need a counterpart format to get rid of IO streams so that brings us to the end thank you for your talk Andreas um any last words um well um thank you for having me um enjoy the rest of your day wherever you are and um hopefully until another time there's some more questions um um actually you you mentioned embedded now we get an embedded question uh special OS support when using coroutines for instance an embedded system where we run rtos like few rtos that's a very very good question and the nice answer for you is you don't um this is the one of the major differences between St threat and cortines for St R you always need operating system support cores are a language or compiler um feature the compiler does a lot of heavy lifting there but in the end because we are simply talking about inter Le functions there is no support from your operating system required in fact your operating system will not know um whether you're using cortines or not the only thing that you need which makes it a little bit difficult for embedded systems is Heap access as I said you can try to control that but then things get more difficult but this is um yeah this the only thing um is there a chance for stack for cor routines and C++ I would say yes um in the beginning there were proposals for stack full what be went for stack less so if one a proposal for St full cortines um outlining where they are beneficial yeah um I would think so the Machinery or most of the things I think wouldn't care whether we're using stack full or stack less um so yeah that that could be possible and was you hinting that you know heas are not needed are cines allocator aware no not not in the sense like other STL elements you you have the basically the option to provide your own operator new and delete for your promise type or for your repper type allocators for cortines sorry well I was thinking about like PMR allocators already give you very nice control on where your memory comes from this is yeah that would be one solution but it's not that you have a um a parameter or template type where it can pass in your allocator so it's by overloading the operator new and delete for your promise type mainly and the tricky part there just to dive into that is knowing the size so you will get an allocation request that is larger than your promis types size because the cortine frame requires some bookkeeping and true in addition to that the cortin frame also stores the parameters to your function so this is what makes it tough and um I yeah this is this is what basically makes it hard so you have to over allocate to be sure that everything um fits but once you solve that you can go with PMR with your own handrolled um stack allocator or whatever you have but also then we left the uh beginners guide to co tees for a long while I guess but it's nice to know that this is possible and I see someone posts uh link to this um and we're having like more than 20 minutes of questions um so thank you Andreas um if there's any more questions later in the chat because people are going to watch this tonight um maybe you know an can take a look at this tomorrow morning and answer some questions in the chat um and with that generally you know thank you for coming and I will then say goodbye to the stream and um the final final words to Andreas bye bye all right let's call Co return