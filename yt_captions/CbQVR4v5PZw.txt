all right I do want to find out is Zig actually safer let's turn down the music a little bit for you all right when is ziggs safer and faster than rust there are endless debates online about Zig and uh rust uh this post explores the side of the argument I don't think is mentioned enough that rust is just simply better than sick I think that's what this opponent of this article better be about and if it's not it's just Zig propaganda else it's the truth okay that's the only possible options here intro too long didn't read I'm sorry or congratulations that's really what you should say is I'm sorry or congratulations I feel like that's the better tldr these days I'm sorry congratulations I was intrigued to learn that uh the ROC language rewrote their standard library from rust to Zig what made Zig a better option uh they wrote that they were using a lot of unsafe for us and I was getting in their way they also mentioned that Zig had more tools for working in a memory unsafe environment such as reporting memory leaks and tests that's very interesting okay making an overall process much better okay okay so is Zig a better alternative to writing unsafe for us hmm I always have so many questions here like why are you writing so much unsafe for us I mean I know you do it for performance but I don't know I just get I just get someone it's so many levels of curiousness you know what I mean like what's what what is going on to get to this point I I don't even know I have given Zig a try I don't really like Zig the problem is I have this I have this problem where Zig I don't know what Niche it's really trying to fulfill meaning like carbon I think is going to be the true like successor to C plus plus and I think rust is really going to be the safe practically as fast and if you're writing good C plus plus faster alternative right so if you're writing good C plus what I mean by good C plus plus is that you're doing shared memory pointers and unique pointers you don't play around with pointers you know what I mean that's what I mean I know Zig is supposed to be the C uh the c replacement I I'm very curious how the c community feels about that I'm just very curious because to become better than the Sea World you also have to like a you have to somehow change you know that whole culture in there from using C then you have to fulfill all those Decades of libraries like to me that just seems like such a hard thing you know what I mean by the way I haven't picked a lane do you see my beard is really growing out I accidentally Let It Grow for the last four days and now look at me now Look at me I look horrible uh take a culture of these nuts okay okay I'll take that into consideration thank you they wrote that they were using a lot of unsafe for us and it was getting in their way they also mentioned that okay I already read that so Zig is a better alternative to writing unsafe Russ I just wanted to test myself and see how hard unsafe rust would be by building a project that required a substantial amount of unsafe code then I would rewrite the project in Zig to see if it'd be easier slash better after I finish but okay so first off right away I will say that there's a huge barrier right here this is a huge barrier the first time you were so I don't know this person's experience level yet okay just to be fair so writing something the first time in a language you're probably not going to do as many idiomatic items second off writing something and then rewriting something you're gonna just do it better the second time you write it you already have like everything in your head floating in there and you program into the future for those items that tricked you up the first time that tripped you that made you do the wrong thing so I I do think you have to write the project rewrite it in Zig and then rewrite it from scratch again in Rust and then truly see which one was actually easier because I think it's just I think it's unfair to do first try in a language and then second try in another language you're just missing seeing all the the hard Parts you know what I mean uh let's see also I finished both versions I found that Zig implementation was safer faster and easier to write I'll share a bit about uh building both and what I learned uh I'll let's see we'll be writing a bytecode interpreter or a VM for a programming language that uses Mark and sweep garbage collection the garbage collection is an important part it's hard to make it work and be fast and be safe because it's fundamentally a problem that doesn't play nicely with the borrow checker interesting interesting interesting uh there are two ways that I can think to do it and say for us using reference counting and using Arena plus handles yeah yeah Arena plus handles is like uh you have like a numeric offset into a large chunk right or you have some sort of double identification for like Arena plus offset into a larger chunk right and you just have these raw undone datas and then you have like a memory mapped piece of data into uh some raw binary right is that is that what they're trying to say kind of like you know you can have a struct that's laid out in memory and then you just need the point the pointer to the struct in in the uh in the Sea World and boom that's what it is so if you just have a bunch of you know if you just had one big memory region you could just do that with rust I assume in the unsafe World using pointers that's what I assume okay correct I mean that's what I assumed that's how I assume what this means because I've never actually done that in this capacity I've done it but I've never done it to this to this level or in this the specific byte code Implement uh interpreter implementations from my favorite books crafting interpreters uh I've thorsten Balls book by the way the interpreterbook.com I don't know if you know about that in particular it's a stack based VM for a language that supports functions closures classes instances Etc it'd be strange if it supported classes but not instances you may Define one you shall not create one all right unsafe for us to implementation overall the experience was not great especially compared to the joy of writing regular safe rust I agree with them so much joy unsafe rust is hard unsafe rust is hard a lot harder than C this because unsafe for us has a lot of nuanced rules about undefined Behavior thanks to the borrow Checker that make it easy to perniciously break things and introduce bugs this is because the compiler makes optimizations assuming you're following its ownership rules but if you break them this that's consideration or that's considered undefined Behavior and the compiler chunks along chugs along well I can't read today C makes you be easier yeah it does you can more easily you be with C than rust it's just that's what it means okay you can just have undefined Behavior easier all right applying these same optimizations and potentially transforming your code into something dangerous okay that's interesting that's really interesting that it could the compiler could introduce bugs which is also something that maybe is a fixable problem to make matters worse rust doesn't fully know what behavior is considered undefined so it could be the right lucies so you could be writing code that exhibits undefined Behavior without even knowing it oh interesting I do want to follow that article but I don't want to you know I don't want to play the game of the forever follow let's see one way to alleviate this is to use uh Miri it's an interpreter for rust mid-level intermediate representation that can detect undefined Behavior it let's see it does its job but it comes at its own warts oh interesting Miri is showing me undefined Behavior no item granting right access for deallocation to take this oh interesting yeah you're really I mean when you're writing code like this you're really in some deep Waters right here interesting the most challenging part aliasing rules the most challenging source of undefined Behavior I ran into was related to Russ aliasing rules as mentioned before Russ leverages its borrow Checker ownership rules to make compiler optimizations if you break these rules you get undefined Behavior so how can I even write this the trick is to use raw pointers oh you know you got a rod dog them pointers boys okay if you're not raw dog and the pointers okay what are you even doing with your life um allowing you to sidestep the borrow checker for example you can have many mutable references or uh mutable console raw pointers you want then the solution be easy right no not quite okay if you turn a raw pointer into a reference you'll have to make it make sure it abides by the rules for that type of reference okay for the duration of its lifetime for example a mutable reference cannot exist while another immutable slash immutable reference exists too okay so you have to do all of your mutations within unsafe mode is that what they're trying to say I assume that's what they're trying to say if you're trying to convert back and forth perhaps it just makes it a lot harder maybe I don't know I again I've never I've never written a line of unsafe rust ever in my lifetime turn the raw pointer into a mutable reference if I create another reference immutable or immutable while the above reference is live that's undefined Behavior okay that makes sense I mean that does make sense right they missed the point of rust well I'm curious why even if you're writing unsafe stuff and you're doing Arena stuff why is this happening to begin with I'm very curious but maybe I again I don't know the problem space I don't know the problem space okay all right I don't I really don't uh this is a easy to violate you might let's see you might make a mutable reference to some data call some functions and then like 10 layers deep in the call stack one function might make an immutable reference to the same data and now you have undefined Behavior yeah I I could see that I'm curious what the undefined behavior is does anyone know what the undefined behavior of that is because to me it seems like technically it would just chug along would it be a problem I mean you might get some like some data but you can't I mean can you even get data races unless if it's multi-threaded I'm not sure if the thing's multi-threaded or not I guess maybe that's part of the problem right now is that I don't know the uh oh Alias aliasing is undefined interesting we'll use after free well duh duh handling handing out multiple mutable immutability to pre-allocated arena is impossible without unsafe rust yes yes yes I've always wanted to play with some unsafe for us I feel like I need to do that at some point just to like know that I can do it you know what I mean I think that that would be a lot of fun I'd love to do some sort of some equal form of Arena allocations you know what I mean uh okay so what if we avoid making references entirely and only use raw dog pointers there you go so that was my question that was my question well the issue is that raw pointers don't have the same ergonomics as references okay yeah firstly you can't associate functions that take a self as a raw pointer okay that's interesting okay so that's a good point so if they had an unsafe class that could be pretty interesting right it's really crazy that they call this struck class my like my eyeballs can't even read this without like wtfing right now don't even for an example this is like right now I'm just like what the hell's hey what the hell is even happening okay so that means you can have no you have to purely do it by functions and not do it by uh you can have no methods okay I mean that's inconvenient it'd be really nice not to have that uh there isn't any nice pointer D referencing syntax in like uh like C's the code is uh littered with this okay that's unfortunate I feel like hmm it's disgusting I would say that it's inconvenient for sure I wonder if you could macro this out you know real talk I wonder if you could macro that out where what you do is like the first thing you give you give a list of of pointers and then you give a block of code and then the block of code just gets Auto pointer updated like everywhere that the pointers reference that just gets I'm not sure if that's possible I don't know I you know what I mean but just seems interesting Russ wants you to explicitly dereference the pointer yeah Russ does want you to explicitly dereference the pointer but maybe there should be a convenience you know like if you're already writing unsafe rust a arrow command or an arrow an arrow accessor really makes it obvious that you're dereferencing like to me this reads no different right this just reads as slightly less convenient version of this I know these some of these rules that rust makes like I hear about like no plus plus it just feels like people trying to be pedantic for the sake of being pedantic do you know what I mean like I don't really care if you use plus plus plus or plus equals one like it's the same [ __ ] I don't care you know I mean I don't get the plus plus I don't think anyone truly gets the plus plus one actually before we go forward let's do a little quick pull because I'm actually really really really curious about this uh let's do the plus plus one new poll let's do a new poll uh should rust use plus plus yes no undecided oh oh yeah okay let's see let's see we'll go like this should use post only plus plus how does that sound so only post side we're not even talking about pre-incrementing just only post side only post side so you can just go plus plus some variable and that's it like you don't like it would sometimes you have to add one sometimes you have to add one and that's that interesting wow this is actually a lot closer than I thought it would be for those that can't see here let me turn off uh I'm I I'm personally surprised at this I'm actually really surprised at this I would have thought it would have been like 90 yes plus undecided it's a lot stronger no I mean hey this just goes to show that it's really that nobody understands that nobody understands what people want yes let's add more features to rust well plus plus doesn't interact well with macros um okay okay that okay so that's a good reason that's a technical reason I like technical reasons I don't see how you know uh some some VAR plus plus versus some VAR uh plus equals one I don't see how that changes anything to me they're the same thing to me but if it's about like a specific implementation details like hey it really is hard to do it in this reason totally and totally in you can't say it's explicit plus plus is no less explicit than plus equals right bring me back to the time when Swift decided uh it wasn't going to be C like and remove the plus plus I I don't get any of the arguments of it's more explicit or any of those things those things all they all seem like the same stuff right we're all just it's all pedantic masturbation to me at that point like what is the limitations uh to me that it does seem interesting there's plenty of redundant stuff well that's why I said post only what about plus plus versus Parts I I like I like having the options I use the options I just do I feel like macros are holding some completely new features back sadly oh interesting I wouldn't know that correct correct but when you use it on the same line the compiler is going to ignore it no matter what some macro plus plus might expand to the argument multiple times and cause multiple increments oh interesting okay okay plus equals is more explicit in my mind uh because it stated how to show when it gets evaluated when you read from top to bottom plus plus is less explicit because you know uh you have to know what it does not my main reason for against it okay interesting hmm I feel like uh plus plus post fix is added then prefix was added to since plus plus is already a convention get out of here with your free will conversations uh stores that yes well that's only if it actually does that's only if it does an actual thing right most compilers at this point you know they will drop they will drop out any of the extra things that need to happen right like if you're not actually using the value it's going to make the optimization it's actually going to turn it into plus plus that variable as opposed to that variable plus plus or it should it'd be crazy if it didn't um let's say I want to change uh my note to say that finally plus plus is or plus equals is sufficient yeah I just have no I have no strong preference on it other than I just or let me say it's I do have a strong preference on it but it's not that strong it's not strong enough to be upset you know what I mean it's just strong enough that it's annoying you know I'm like ah I wish I had that in my opinion it also leads to unnecessary code golf I I don't see that I don't I don't see that next there isn't a nice way to yes okay so I do I do like this I do I would like to see derferencing it really sucks when you have a chain of D references yeah because you know rust takes so much time with the await syntax to make it really nice this does look like that sucks I can agree that looks like it sucks can we agree that that looks like it sucks okay another problem okay so so what I'm hearing is that syntactically it's hard to work with okay so maybe maybe the argument is not against I'm curious if I'm curious if the argument is against the syntax or against are the ease of syntax versus the language itself because right now I'm saying it's like the syntax I know you could argue the syntax is the language but you know nothing prevents rust from adding an arrow function other than the people maintaining it and their reasons why they should or should not do that another problem was working with arrays if I have a raw pointer to my array of data mute T I can turn uh it into a slice mute t or a mute slice T let's see and I get to use a four in Loop over let's see any iterators yep but turning it into this basically makes a reference to all the data in the array so it makes it really easy to violate uh Russ aliasing rules yet again okay interesting interesting okay okay again the solution is to avoid making references so in some places I ended up writing regular style C4 loops on the array raw pointer but raw pointer suck in comparison to rust slices because you can't index them any and you don't get out of Bounce checking yeah yeah yeah yeah yeah yeah yeah yeah I mean I like I prefer I I personally do prefer you know avoiding me writing the actual for loop I mess things up you know I messed I mess up a lot of things you know what I mean okay hey unpronounced uh let me let me look at this here in a moment okay link it again here shortly because I'm actually curious okay uh Pub struct closure up values mute up value what's up value can't index raw pointer closure up values one well what's an up value have to do this and no autobounds checking oh interesting okay yeah Miri uses stacked borrow model uh so it can text you be related to these Alias these rules I mentioned above but it fixes that let's see but fixing them was challenging I felt like a lot of uh let's see it felt a lot like when I was learning Russ there are these rules that don't exist but I have a solid mental model of them I would have to figure out why what I was doing was wrong then experiment to find a way to fix it oh that's tough also note that the feedback loop was way slower because there is no LSP in my code editor uh guiding me interesting I have to recompile the program each time to see amiri's output oh that that's yeah a tool a tooling Gap is also a big problem there tooling gaps are big problems what's up doc I don't know let's see this really ruined my experience for me by the end of it I wasn't really enjoying rust yeah okay okay I get that uh just this weird half of Rusty language that was more error prone and uh and delicate okay so given the fact of all these I could understand that so I think the argument is that rust let me try to summarize the argument I think is that the tooling and the syntax makes unsafe rust not too easy to write is this true oh I got rated oh well let me say thank you very much hey Matthias thank you very much for the The Raid sorry I have I have alerts off when I'm doing uh article reading I'm sorry about that we're doing a little text stream we're reading about unsafe rust versus zig so I hope that you enjoyed welcome all 88 people thank you very much for the rate I really appreciate that uh just because you know alerts make things kind of you know blog uh to embed code on say for us has to uh are a focus for them oh interesting so this could be could you link this here when I'm done with this article because that looks really really exciting actually all right if you turn Rob let's say hold on all right so let's look at uh let's look at the next thing Zig implementation after spending a lot of time practicing the dark arts in Rust I was excited to leave unsafe for us to learn Zig and start rewriting the project in it apart from not having crazy you be like uh in unsafe rust Zig is a language that understands that you're going to be doing memory unsafe things so it's designed and optimized around making that experience much better and less error prone okay this is super cool this is super cool I like this this is a good argument for Zig on uh on in unsafe environments but it sounds like the rust teams their 2024 roadmap is to do this so that could you know that could yet again defeat Zig in what's the purpose what is zig's strong purpose and Zig any function that allocates memory must be passed it an allocator yep uh this was amazing because I made a garbage collector a custom allocator each allocation slash dallocation tracked how many bytes were allocated and triggered Garber collection if needed very cool I like that that's very cool that's actually super cool can't you override how memory is allocated in in Rust as well anyways whatever well I guess this makes more sense because then you can oh no you wouldn't want to do that because in global rust you have two different type of memories then right you'd have your VM memory versus your uh your Global memory whereas in in the zig world you have to pass the allocator so therefore your VM allocations can have one allocator and your program running the VM can have the other allocator I assume that's what's Happening Here Right that's pretty cool can you over okay so you can overwrite that the global allocator for just custom ones okay so then theoretically you could quote unquote achieved something similar in Rust if they had better unsafe mechanics Rock on uh to use anything for let's see hold on let's see allocators and rust are quite different unfortunately haven't managed to get uh much use out of them yet despite trying okay very cool this is yeah this is definitely a way out of my Waters here let's see constant GC struck the allocator was wrapped over okay inner allocators just an allocator bytes allocated interesting other fields Outlook resize and free are required functions all right okay cool collect if needed very cool uh what I love about this design choice of zigs it makes it frictionless and idiomatic to use different allocation strategies that are optimal in your use case I do think that that is cool this is a really cool feature of Zig that you can you have your own custom at first when I saw that I thought oh man that's a lot of overhead but as we were playing with it as I thought about I was like okay there could be some really cool things and this is actually a super cool example of it for example if you know some allocations have similar and finite lifetimes you could use a super fast bump uh Arena allocation yeah or a linear Arena allocation yes to speed up your program this stuff exists in Rust but it's not as nice and sick okay a special allocator which detects memory bugs when I use or when used it detects use after freeze and double freeze uh to it prints a nice stack trace of when and where the data was allocated freed and used oh very cool so it's like a debug allocator uh this in particular was a lifesaver during development absolutely okay that's super cool like a debug allocator that just allocates massive amounts of memory but has it all in there very cool that's actually super cool uh let's see non-null pointers by default most memory safety bugs are null pointer dereferences and out of bound array indexing yeah that's safe to say Lizzy Russ raw pointer types are nullable by default and have no null pointer dereference checking okay there is a no null T pointer type that gives you more safety I'm not sure why it's not the default since rust references are non-nullable uh let's see Zig pointers by default default are non non-null oh my goodness I'm saying the word non-null too many times and if you opt out to null ability you use the question operator okay and of course you get a null pointer D referencing checking enabled by default too I much prefer this it makes the default Choice the safest pointers and slices Zig understands you are going to be working with pointer so it makes the experience great the big problem with unsafe rust version was that raw pointers had terrible ergonomics the Syntax for d-referencing yep yeah we we saw that it was terrible if you didn't see it it was like awful like just just parentheses star parentheses star parentheses star like just constant layering on it's pretty much the same await problem in JavaScript is the pointer dereferencing except for pointer D referencing happens a lot more I find myself doing constant parentheses await accessing something Zig pointers have the same ergonomics as rust references namely the dot operator doubles as a pointer der referencing okay Zig also has some additional pointer types that help you disambiguate pointers to a single value uh let's see pointers to a single value from pointers to an array okay a point let's see a pointer to an unknown number of items like rust slice okay an alternative to slices when N is a comp time known constant wow uh they support indexing with an array syntax and let's see while regular pointers t-star don't which is really great for safety a cool part is that it's very easy to convert in between different pointer types okay okay traditional pointers uh like the ones you'd see in CC plus plus are very error prone Russ solves this by adding a facade layer over pointers it's reference type T and mute T but unfortunately for rust it's raw pointers still have the same issues as CC plus plus yeah Zig solves this by removing a lot of foot guns from pointers and adding additional guards Okay so again I assume rust could do something here right could we say that rust could theoretically solve a lot of these problems by focusing on unsafe and it sounds like they're focusing on unsafe so all right Benchmark results now it's time for what everyone wants to see the benchmarks oh yeah baby give me the good stuff the G-Spot the good spot is icon here are a few pics of the results if you want to look at a specific code uh 35th Fibonacci number this has no meaning in my life because it doesn't like how does memory allocation work here I don't even know let's see Han what am I looking at okay so this would be is this supposed to be the rust side and this is supposed to be the zig side zlocks Zig out okay so this is the zig side so it's like one second this is 1.6 seconds that's a lot okay that's a lot difference that's a lot different that's that's much much much faster if you're getting to this speed out of it that's good I mean it's a good argument right there I can buy that as a good argument uh method calling stress test well that's a big difference that's a big difference okay interesting interesting string of quality stress test oh interesting very very good I wonder how these all play out in um I wonder how these things play out in larger like larger systems do you still do are you gonna universally see larger faster items or is this a micro bench optimization meaning that you're doing the same thing a bunch versus you're doing something a little bit of times over a large field you know of operation so what what exactly happens I don't know what zoo is but all right Zoo sounds great so also again really fast so why was it faster for The Benchmark Zig implementation was around yeah it was like 50 plus faster uh why is that I tried profiling the two but I didn't get any useful information out I think the reason is that rust version uh there were a few places where I had to use indices instead of pointers uh for the stack next instruction call frame stack okay because it was too complicated to get them to use pointers and satisfy Mary's UB checks okay interesting is it because he was I mean ultimately using these checks was that part of the problem uh the zig version uses pointers for those places uh so super common operations like manipulation are the top uh top of the stack getting the next instruction or the current call frame was uh a simple planar D reference where Russ had to do pointer arithmetic okay okay so that would be a lot that'd be a little bit more expensive uh keep in mind those operations are happening super frequently uh in the VM so these extra Ops add up yeah absolutely I tried refactoring the rust version but each time I tried it would take a long time and I wouldn't satisfied Mary's checks so I gave up after bit okay reasonable if anyone has any other ideas further why the rust is slower and okay interesting and so Reddit apparently has a lot more so if you want to check out Reddit go check out Reddit I don't want to step through every possible one writing a substantial amount of unsafe for us really sucks and the beauty let's see sucks the beauty out of the language I feel like I was either tiptoeing through the broken glass of undefined Behavior or is writing in this really weird half rust half C mutation abomination of the language the whole point of us is to use the borrow Checker but when you frequently need to do something the borrow Checker doesn't like you should really be using the language okay interesting question this is an interesting question this feels like it was read by someone who likes rust he multiple multiple times refer to it as beautiful the joys of writing it it is amazing I absolutely like I mean this guy is all boners for us right so let it happen right uh the man's losing blood to his brain at this point uh let's see the aspect of rust doesn't seem to be talked about enough when people compare rust to Zig and definitely should be considered when you're going to do memory safe unsafe things like performance okay give them a pass okay this is not a zig chill it doesn't seem like as someone who loves Ross really does he love Russ I can't tell at this point I'm definitely going to explore using Zig uh more for projects I like the idea of being able to choose different memory allocation strategies and then performance opportunities that it brings while I was writing the zig version I took a comprehensive notes on my thoughts and feelings about learning okay this is cool this is actually pretty cool I think this would be a really great thing to go through if you want to learn more about these languages I might have to at some point go check this out I may want to retry to rewrite The Interpreter I don't know if you know the Thorson ball book but last November I tried to write out an interpreter in 12 hours using rust and I've never tried it and it was terrible I didn't do a good job uh but I would like to try it I'd like to try another swing at that here at some point Zig paid actor does rust Backward Compatible compatibility also applied unsafe interesting by the way where is the article it's on zackoverflow.com all right uh hey I hope you enjoyed it the name is the private jet hey like the video I got him this is YouTube Right There YouTube everybody