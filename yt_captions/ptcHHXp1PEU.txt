In the previous video we looked at our guess the Philosophy of writing software for giri's and I thought in this video we'd actually talk about how the programs are internally structured It doesn't matter what system you're using whether it's a Mac whether it's Windows whether you're writing for a risk us an Atari and Amiga x11 it they all seem to have a similar structure one of the things you find with GUI software is that   one GUI program is Very similar to the next GUI program or the previous one you wrote and so it lends itself to having sort of libraries or frameworks   Particularly object-oriented frameworks that you can use to write the software So these days you if you go and write say softer on a Mac you'd perhaps use cocoa To do it and you wouldn't necessarily see this structure   Internally or if you write it in Java you would use the Java frameworks to do it but under the hood The same things there. I'm gonna be looking at under the hood what's going on and how the operating system is getting the   Interaction from the user into the program so you can write what's happening   So when we talk to the previously one of the things we said is that with a GUI program   The program is no longer in control of how things happen to the program They can't say at this point how we need to enter this piece of text. It's very much up to the user That's driving you the users clicking on things. They're moving windows around they're in control And so you need to structure your program to respond to those events coming in from the user and then process them and do the right thing based on what that happens and the way that most QE programs are written is they have what's called an event loop at the Center of them and basically in that event loop the computer will be sitting in a loop because it's a loop Doing the same thing after again and you basically get a call to an operating system supply function and let's say it's called wait Next event. That's what was called on the original Mac on the Atari ST was called event message or event multi depending on what sort of side you wanted on viscose. It's called Wimpole Windows does something slightly better something slightly neater with some of them probably say but it's the same sort of thing We'll look at that in a second well so what the operating system does or what the toolbox that provides the user interface does is It's sitting there It's monitoring the input coming from the user whether it's from the keyboard whether that's from the mouse being moved or them It's been clicked and so on and it assembles those Inputs into a series of events. So if I press a key on the keyboard, we will get two events for that We'll get an event when the key goes down and we'll get an event when the key Comes up as well and those events go through the operating system as from the hardware up for the operation went into the user interface that part of the operating system and then they get passed to our program as Events. So when I press a key on the keyboard eventually when next event will return saying hey There's a key down event from the user and then I would have to write code here that says there's a key down event Do the right thing? in that Situation and then the village when you get the key up event when now let go of the key and you do the right thing there in the same way if I move the mouse or press a button we'll get an event or a message telling us that the mouse has moved and that the mouse button has been clicked and we'll get a mouse down event and a mouse up event as the buttons pressed and Comes back up and that event will tell us What the button was? The location where it was pressed and so on in the same way the keyboard event would tell us what key was pressed And what's happening so our program was sitting there Waiting for the next event So what you'll generally end up with is this will often return some sort of structure with the data in And then you'll have a big switch statement or series of if statements to switch on the event type and this is sort of pseudocode and then we switch on the type and if it's a keydown event, we do one thing if it's a Key event, we do another and so on and then we can handle those things These aren't the only events you get the UI toolkit will create lots of other events that you can do to do things So for example if we've got windows on our system Is there a more generic term for these things than windows just because windows is windows and no they are called windows I've not seen them referred to as anything else if we click on the window bar to move it around the screen Then we don't get a mouse down event there and have to track the window being moved around And they're getting a mouse of what the operating is What the UI toolkit will do is oK you've clicked on the title bar You've moved the window around I'll send you an event Once you finish dragging it to say the window has been moved to this position in the same way if I have another window Overlapping it like that and I then move that one out of the way suddenly this part of the window here Becomes revealed and I have to draw that part of the screen again or the operation has to make sure that part of the screen Gets drawn again, and so we can end up with lots of events coming from windows But they're constructed by the UI toolkit based in what's happening. So it may have a case for example that The window has moved or in my other case that the window needs to be redrawn and so what happens it's a program basically sits in This big loop and we do that Wow quit isn't true So basically we have some sort of things says, okay The programs finish that we get out and we set that to be true then we'll stop this loop, but we sit in this loop Continually going there waiting for an event If there's not an event Then this will just block the system won't let us continue Until there is an event there on the other hand if there's lots of events Will get them through one by one and we'll process them to update things based on what the users doing based on what's happening We've talked about the keydown event the key up Mouse-click events would probably wouldn't get worn when the mouse is moved If you think about as the mouse is being moved You've got lots and lots of events most of which you're not interested in you're probably only interested when a button is pressed or so on the only times pass that's different is if you're dragging something around the screen and in that case you will often say to you listen, well, I'm Dragging something here. Tell me about those events the rest of the time you're not interested in what's happening? At those points so you probably don't get mousemove events, but you can register them and you can also do clever things like I say actually tell me what it moves into this area or moves out of this area so that you don't get Multiple ones, but you can sort of track What's going through at that time? So our program is based around a Series of events coming in that represent the input coming from the user But we still have a problem. We still have to sort of direct these things to the right place I mean it's obvious if we've got sort of a window moved event We know that we're coming from that window and we know it's moved so we know what's it's being dealing with Likewise if we get a mouse-click event, it's pretty obvious where it's going we can find out exactly what windows underneath there But for something like a key down event, it's a bit bit more nebulous We have to have some sort of idea of there being a current window Which would then deal with it? But that may not be the right place for it to go. So for example, you may have a text box, but then someone presses ctrl Q Which means quit the program and so actually if the text box dealt with that then where you want on the text box quitting So it probably won't do it You want them to enter ctrl Q into the text box as data? So you need to have it passed back up to the rest of the program? You need to sort of work out where you want this to vent to be deal with them in some systems You have to program that into the logic of your code in others. You can sort of Direct where you want things to go so Windows actually made a nice optimization they instead of having this sort of way next event loop and then you Do the tests based on what was returned you have a similar structure? So you still say while quit? equals false and then inside that you have Your loop which says pink message so you have a look to see if there's something in there and that returns the event Windows causing messages rather than the events because you get a message from the operating system when the event happens it makes sense of things And then you run another function on it, which translates it slightly So you want the Translate message function and then you run? another function called dispatch Message and that becomes your main loop of a window So even if you look at most Windows programs They will have something like that there it may be hidden inside the dotnet framework It may be hidden inside MFC whatever you're using to write your program, but somewhere inside there you're going to get something like that That against so how's Windows handling it? Well, the same thing is happening. But what Windows did And this goes back way is when you create a window in Windows I'm gonna use an Atari window as an example here when you do on a Mac or on an Atari on risk-off You just create a general window and you tell it what you wanted to look like with windows you actually associate a function with its associated class with it and that has a function that handles messages with it And so what windows can do is when a message comes in it can direct it to the specific window Because it knows what function to call so you'll probably watch he doesn't have a big switch down It has lots of functions which are then bound to the windows that you want them to handle So that's basically how you write a GUI pro you Your event loop your message handling loop at the center of things and then as the user interacts with it you have to handle the messages the events that come in and Update your program state now There's two things that immediately jump to be obvious here you want this code that handles this thing to be quick? Because if it takes a long time to process that message There'll be a long time before the next message is processed So if you press a key and it's a takes for 40 seconds to handle that key being pressed It'll be 40 seconds before the next key would then appear on the screen? So you often found that you had to write your programs in a way that they do some Processing and then go back into the event loop and then carry on will do a bit more processing and do a bit more the event loop so they still appeared to Function otherwise you often get that effect where the GUI froze while it is impressing and then came back to life Which was not from to use as a program. So you had to basically have this happening all the time The other thing you can do is push things off into another thread and have them running at the same time But again that creates its own interesting issues for writing software But because we're dealing with Windows on the screen, we get some interesting things that we have to deal with So let's create some windows. In fact, let's just clear the desktop and Go to the clean one so let's say we're doing a bit of programming and we've got a text editor open there with some text and We decide you want to check mail. So we will now fidonet client to go and get the mail We need to open some files and then we decide we want to watch a video on YouTube so we've got lots of windows open and as we've seen each of these are separate programs So there's an event loop for this program Which is handling the event coming from there is an event loop for this one is an event loop for this one this event loop for our browser handling the Events all the messages that are coming for that But as well getting the events from the user and we can say well, okay This windows at the top say so the events will come to this one and then we go on that one and that one becomes on the top and so on the events go to that one as well as handling the events from the user as These windows are updated They can create events that mean that the other programs have to do things now originally Obviously a lot of the graphical user interface operate systems matthos Atari O's windows viscose and so on and you allowed one program to run it once You still have the same thing because you had desk accessories and things which were effectively separate programs that could do these things so for example say I am watching the video on YouTube and I bring my Text editor to the top because I want to carry on writing it while watching the video. I've now changed the position of that It's now the current window So I need to be told that this is now the current window so that I know where things are going They may have more than one text editing window Open but also as I brought it to the front I've revealed parts of the window that were previously covered up by the other windows And so I need to ensure that those parts of the window are redrawn now. There's various ways you can do it modern operating systems do lots of things to try and Speed things up because they have the benefit of more memory and so they cache things And they'll often have off-screen areas where they can each do all the contents of the window and it's stored So the operating system can redraw it automatically, but originally when you did this you would get a message from your Operating system saying you need to redraw this window And so it tells you that you need to redraw the area here or to speed things up It would tell you you need to redo all that bit You need to redraw this bit and you need to redraw this bit down here. So when you've got a message saying redraw the window You wouldn't just get a rectangular area to draw you may get several separate rectangular areas. So you need to work out Okay, and if you redraw what's in that bit and that bit and that bit now you could if you were a lazy programmer redraw everything Every time you got that message and just clip to the areas But the problem with that is that the computer that would take a while to draw that even today drawing Lots of things is a complicated thing can still take some time to do So what you actually try ended up how to do is work out Well, what bits are being revealed here and redraw that and so on But you could sometimes get those things even if you weren't on top So for example if I'm like that and I move this window in the right way I can end up revealing a section here and another section down here that I have to redraw So the events come not just from the user interaction But also from the interactions of the program with itself or with the other things every time you move a window the operating system has to Deal with that and tell you that you need to redraw parts of it and so on and tell you that the windows moved So Windows Aero, it's got see-through bit. Yeah, so who's peaceful step? Well, this is the thing and this is everything's Mac OSX Introduced this Windows Aero in Windows Vista and so on and I think way them probably just something similar as well. I'm not too sure What they do is they say oK, you've got lots of windows on screen And they're overlapping but what will actually do is will draw all of them Off screen so that they don't overlap and you might be can zoom out the other camera and so we've got them off screen Like that and what we actually do is we say, okay We'll draw them all so they're completely uncovered as separate blocks of memory And then we'll make a copy of that And copy there and some nice visual effects going to see that properly happening and then we'll make a copy of this And put it on the screen here I'll make a copy of this and put it on the screen here and a copy of that because we're copying Pre-existing things we can do our four channels we can do Transparency and we can make it all look pretty and you can have wobbly windows if you've got a weird gnome desktop It's interesting depending on the operating system. You're using Windows can be more or less intelligent Generic windows not the operating system So for example on the Atari system, and I think on risk was to remember brightly and it was at the programmers course The window basically was a container and that was it. You had a container than you drew in it On a Mac on Windows Windows can actually contain other windows and they can contain other windows so you can sort of build Things up and so actually all the controls you get buttons text boxes. They're actually Specialized windows that you can then combine together to form a whole That is a window and so on and you can specify whether they have title bars or not whether they have scroll bars and things, of course, the interesting thing about redrawing things is It's simple if you have to redraw an area here because that's Windows come on top of that window like that, but things get interesting If you scroll around the window You perhaps don't want to redraw everything because that will take time I mean When when? Gooeys are first being invented. We had computers that probably had an eight megahertz CPU that we're doing these things if that Went like the touristy or the original Mac these days They're much more powerful in looking about sort of five hundred times that speed four gigahertz sort of roughly three four gigahertz as a Russell speed, but even so What we're drawing on them is now a more complicated I sort of it used to be a one bit window, but now we have a sort of 24-bit color with alpha Channel lots of graphics and so on it and so it's a lot more complicated or doing the amount of data that needs to be correctly for that is Much more times that we've got a high-resolution displays rather than 640 by 400 and so on so yes, the computers got faster But so is the amount of data and also what we're trying to draw this more complicated drawing a bit of text relatively straightforward drawing a nice web page and so on becomes more complicated and so you still have the same problems is how do we Redraw the screen quickly when we scroll through what's on there? and so you have to sort of Work out what you want to do and sort of do things and we'll have a look at that in a later one now I've got the token so I can lay the value in add the valley from emerged or into it and Store it back and hand the target and now I've got the token again I can load something into it into my register add something onto it back and pass the token on and I've got it So I can load the value in add the value from a register story back