import torch 
import chess 
import numpy
import time
from model import ChessModel
from torch.utils.data import Dataset,DataLoader
import random 
import math 

class chessDataSet(Dataset):

    def __init__(self,boards,results):

        self.data   = [] 

        for b,r in zip(boards,results):

            self.data.append([b,r])
    
    def __getitem__(self, index):
        return self.data[index]
    
    def __len__(self):
        return len(self.data)


class Node:

    def __init__(self,board:chess.Board,parent:chess.Board,depth,score=0,move=""):

        self.board      = board
        self.fen        = board.fen().split(" ")[0]    
        self.score      = score 
        self.move       = move

        self.parent     = parent 
        self.children   = []

        self.depth      = depth
    

    def __repr__(self):
        return str(self.move) + "=" + str(self.score)


def fen_to_tensor(fen_list,orientation):
    #fen_list        = [fen.split(' ')[0] for fen in fen_list]
    batch_size 		= len(fen_list)
    board_tensors 	= numpy.zeros(shape=(batch_size,6,8,8),dtype=numpy.float32)

    piece_indx 		= {"R":4,"N":8,"B":6,"Q":2,"K":0,"P":10,"r":5,"n":9,"b":7,"q":3,"k":1,"p":11}

    pieces          = {"R":1*orientation,"N":1*orientation,"B":1*orientation,"Q":1*orientation,"K":1*orientation,"P":1*orientation,"r":-1*orientation,"n":-1*orientation,"b":-1*orientation,"q":-1*orientation,"k":-1*orientation,"p":-1*orientation}

    #Go through FEN and fill pieces

    for i in range(len(fen_list)):
        for j in range(1,9):
            fen_list[i] 	= fen_list[i].replace(str(j),"e"*j)

    for i,fen in enumerate(fen_list):
        try:
            position	= fen.split(" ")[0].split("/")
        except IndexError:
            position    = fen
        
        #Place pieces
        for rank_i,rank in enumerate(reversed(position)):
            for file_i,piece in enumerate(rank): 
                if not piece == "e":
                    channel                             = int(piece_indx[piece] / 2)
                    board_tensors[i,channel,rank_i,file_i]	= pieces[piece]
        
    return torch.from_numpy(board_tensors)


#Returns a list of all children boards as Nodes
def expand_node(parent:Node,table,depth=4):

    #Dont expand if past depth limit 
    if parent.depth == depth:
        return [] 
    
    if parent.fen in table:
        parent.children     = [n for n in table[parent.fen]]
        for i in range(len(parent.children)):
            parent.children[i].depth     = parent.depth + 1
            parent.children[i].parent    = parent
        return parent.children
    
    children        = []  
    legalmoves      = parent.board.generate_legal_moves()
    for move in legalmoves:
        #Create node 
        newnode         = Node(parent.board.copy(),parent,parent.depth+1,score=0,move=move.uci())
        newnode.board.push(move)

        #Add to parent's children 
        parent.children.append(newnode)
        children.append(newnode)
    
    return children


def minimax(model:ChessModel,base_board:chess.Board,depth=3,mult=1):

    #Breadth first 
    root_node   = Node(base_board,None,0,"ROOT")
    total_nodes = 0
    lookup_table= {}
    to_explore  = expand_node(root_node,lookup_table,depth)

    #CREATE BASE TREE NO SCORES
    while to_explore:

        #Grab item0 and expand it 
        curnode         = to_explore.pop(0)
        total_nodes     += 1
        to_explore      += expand_node(curnode,lookup_table,depth)
        lookup_table[curnode.fen] = [n for n in curnode.children]
        print(f"table len is {len(lookup_table)}")
    

    #FIND ALL UNIQUE SCORES 
    unique_fens         = {}
    to_explore          = [n for n in root_node.children]

    while to_explore:
        curnode         = to_explore.pop(0)
        to_explore      += curnode.children
        
        if curnode.fen in unique_fens:
            unique_fens[curnode.fen].append(curnode)
        else:
            unique_fens[curnode.fen]    = [curnode]

    #Compute all fen scores 

    tensors             = fen_to_tensor(list(unique_fens.keys())).to(torch.device('cuda'))
    print(f"tensors is size {tensors.shape}")
    print(f"total nodes: {total_nodes}")
    with torch.no_grad():
        scores              = model.forward(tensors)

    for fen,score in zip(list(unique_fens.keys()),scores):

        for node in unique_fens[fen]:
            node.score  = score.cpu().item()

    curnode     = root_node 
    while True:
        command = input(f": ")

        if "list" in command:
            print(curnode.children)
        
        if "root" in command:
            for node in curnode.children:
                if node.move in command:
                    curnode     = node 
                    break 
        if "up" in command:
            curnode = curnode.parent
        



    #Explore node


def play_game(model:ChessModel,max_ply=256):

    game_boards         = [] 
    game_outputs        = [] 


    board               = chess.Board() 
    #minimax(model,board)
    while (not board.is_game_over()) and (not board.ply() > max_ply):

        #Get all moves 
        all_moves       = list(board.generate_legal_moves())
        #new_boards      = [board.copy(stack=False) for move in all_moves]
        #[board.push(move) for board,move in zip(new_boards,all_moves)]
        fen_list        = []
        for move in all_moves:
            board.push(move)
            fen_list.append(board.fen())
            board.pop()

        with torch.no_grad():
            all_boards              = fen_to_tensor(fen_list,-2*board.turn-1).to(torch.device('cuda'))
            move_outs               = model.forward(all_boards).squeeze(1)                              #Scores were calculated from Other perspective. AkA we need to pick argmin
            #input(f"move outs: {move_outs}")
            corrected_move_outs     = torch.exp(move_outs * -1) 
            #input(f"move exps: {corrected_move_outs}")
            corrected_move_outs     = corrected_move_outs / torch.max(corrected_move_outs)              #Scale back to 1
            #input(f"move max: {corrected_move_outs}")
            chosen_move             = torch.multinomial(corrected_move_outs,1,False)
            #input(chosen_move)
            chosen_move             = all_moves[chosen_move]

        #Save states 
        game_boards.append(fen_to_tensor([board.fen()],2*board.turn-1)[0])
        game_outputs.append(1 if board.turn else -1)
        board.push(chosen_move)



    result          = board.result()


    if result == "1-0":
        pass
    elif result == "0-1":
        game_outputs = [i*-1 for i in game_outputs]
    else:
        game_outputs = [0 for _ in game_outputs]

    return game_boards,game_outputs


def play_graded_game(white_model:ChessModel,black_model:ChessModel,max_ply=512):

    board               = chess.Board() 
    r_n                 = 14

    while board.ply() < max_ply:

        randomizing     = int(board.ply() < r_n) * (.05*(r_n-board.ply())/r_n)
        #Make white's move 
        
        #Get all moves 
        all_moves       = list(board.generate_legal_moves())
        new_boards      = [board.copy(stack=False) for move in all_moves]
        [board.push(move) for board,move in zip(new_boards,all_moves)]

        #Calculate move
        with torch.no_grad():
            all_boards              = fen_to_tensor([b.fen() for b in new_boards],2*new_boards[0].turn-1).to(torch.device('cuda'))
            move_outs               = white_model.forward(all_boards).cpu().numpy() * -1                        #Scores were calculated from Other perspective. AkA we need to pick argmin
            corrected_move_outs     = [math.e**weight for weight in move_outs]
            corrected_move_outs     = numpy.array(corrected_move_outs) / max(1,max(corrected_move_outs))        #Clip to 1 
            #If below move 10, add noise 
            if randomizing:
                #print(f"move {board.ply()} rand={randomizing}")
                corrected_move_outs = [weight+(randomizing*random.random()*max(corrected_move_outs)) for weight in move_outs]
            max_move_i              = numpy.argmax(corrected_move_outs)
            chosen_move             = all_moves[max_move_i]
        
        #Play move
        board.push(chosen_move)

        #check end of game
        if board.is_game_over():
            result          = board.result()
            if result == "1-0":
                return 1 
            elif result == "0-1":
                return -1
            else:
                return 0



        #Make black's move 
        
        #Get all moves 
        all_moves       = list(board.generate_legal_moves())
        new_boards      = [board.copy(stack=False) for move in all_moves]
        
        #Calculate move
        with torch.no_grad():
            all_boards              = fen_to_tensor([b.fen() for b in new_boards],2*new_boards[0].turn-1).to(torch.device('cuda'))
            move_outs               = black_model.forward(all_boards).cpu().numpy() * -1                        #Scores were calculated from Other perspective. AkA we need to pick argmin
            corrected_move_outs     = [math.e**weight for weight in move_outs] 
            corrected_move_outs     = numpy.array(corrected_move_outs) / max(1,max(corrected_move_outs))        #Clip to 1 
            #If below move 10, add noise 
            if randomizing:
                #print(f"move {board.ply()} rand={randomizing}")
                corrected_move_outs = [weight+(randomizing*random.random()) for weight in move_outs]
            max_move_i              = numpy.argmax(corrected_move_outs)
            chosen_move             = all_moves[max_move_i]
        
        #Play move
        board.push(chosen_move)

        #check end of game
        if board.is_game_over():
            result          = board.result()
            if result == "1-0":
                return 1 
            elif result == "0-1":
                return -1
            else:
                return 0


def play_championship(model1:ChessModel,model2:ChessModel,n_games=100,max_ply=512):
    

    game_outcomes   = {"model1":0,"model2":0,"draw":0}

    #Play half of games as w/b
    for game_num in range(int(n_games/2)):
        outcome     = play_graded_game(model1,model2,max_ply)

        if outcome == 1:
            game_outcomes["model1"]     += 1
        elif outcome == -1:
            game_outcomes["model2"]     += 1
        else:
            game_outcomes["draw"]       += 1
    
    #Play half of games as b/w
    for game_num in range(int(n_games/2)):
        outcome     = play_graded_game(model2,model1,max_ply)

        if outcome == 1:
            game_outcomes["model2"]     += 1
        elif outcome == -1:
            game_outcomes["model1"]     += 1
        else:
            game_outcomes["draw"]       += 1

    
    return game_outcomes
    



if __name__ == "__main__":


    models          = {i:ChessModel(6).to(torch.device('cuda')) for i in range(4)}
    rand_model      = ChessModel(6).to(torch.device('cuda'))
    training_i      = 0
    training_model  = models[training_i] 
     
    t0 = time.time()

    iters       = 100
    n_games     = 128
    bs          = 16

    
    for iter in range(iters):
        print(f"\n\nTRAINING EPOCH {iter}\n")
        boards          = [] 
        results         = []
        losses          = [] 
        n_zero_games    = 0 
        n_allo_games    = 0 
        #Replace current best model and prep for eval 
        training_model  = models[training_i] 
        training_model   = training_model.eval()
        print(f"\ttraining with model {training_i}")

        #Play training games
        while (n_zero_games+n_allo_games) < n_games:
            bor,res          = play_game(training_model,300)
            res                 = [(r,i/len(res)) for i,r in enumerate(res)]

            if res[-1][0] == 0:
                if random.random() < .25:
                    
                    for b_,r_ in zip(bor,res):
                        boards.append(b_)
                        results.append(r_)
                    n_allo_games += 1
            else:
                for b_,r_ in zip(bor,res):
                    boards.append(b_)
                    results.append(r_)
                n_zero_games += 1
            
            #print(f"done game : {n_zero_games+n_allo_games}")
        print(f"\tTraining\tn_exps: {len(boards)}\t\n\t\t\t    qf: {100*(1-([nlp[0] for nlp in results].count(0)/len(results))):.2f}%")
        #Train 
        cd  = chessDataSet(boards,results)
        training_model   = training_model.train()
        optim       = torch.optim.Adam(training_model.parameters(),lr=.0005)
        loss_fn     = torch.nn.MSELoss()
        for i,batch in enumerate(DataLoader(cd,batch_size=bs,shuffle=True)):
            
            for p in training_model.parameters():
                p.grad  = None 

            gamestate       = batch[0].to(torch.device('cuda')).type(torch.float32)
            score           = batch[1][0].to(torch.device('cuda')).type(torch.float32).unsqueeze(dim=-1)

            #Uncertainty represents the distance this move was to the outcome of the game.
            # If it was very far from the end, the correlation of this move to the outcome may be decreased
            # Thus, we use the uncertainty model of:
            # .05 + linear from [0%:75%]
            # max(1,)  
            certainties   = batch[1][1].numpy()
            certainty     = torch.tensor([(item+.15)*int(item < .6) + min(1,math.sqrt(1.2*item))*int(item > .6) for item in certainties]).to(torch.device('cuda')).unsqueeze(1)
            

            predicted   = training_model.forward(gamestate)
            
            predicted_copy  = predicted.detach().clone()
            score       = (((score - predicted_copy)*(1-certainty)) + predicted_copy).type(torch.float32)

            loss        = loss_fn(predicted,score)
            loss.backward()
            losses.append(loss.mean().item())

            optim.step()
        print(f"\t\t\t  loss: {sum(losses)/len(losses):.5f}\n")

        #Check next best
        print(f"\tRunning pairings")
        pairings    = [[training_i,x] for x in models if not x == training_i]
        top_wr      = 0 
        wr_thresh   = .05
        lowest_wr   = 1 
        lowest_i    = 1

        for pair in pairings:
            n_games             = 100

            model1              = models[pair[0]].eval()
            model2              = models[pair[1]].eval()

            pair_outcome        = play_championship(model1,model2,n_games=n_games,max_ply=400)
            model1_wins         = pair_outcome['model1']
            model2_wins         = pair_outcome['model2']
            draws               = pair_outcome['draw']
            wr1                 = model1_wins/(model1_wins+model2_wins+.001)
            wr2                 = model2_wins/(model1_wins+model2_wins+.001)

            #If model1 wins > 10% of time and has > 60% winrate over other, its better
            if model1_wins > wr_thresh*n_games and wr1 > .6:

                #Replace best
                if wr1 > top_wr:
                    top_wr      = wr1
                    training_i  = pair[0]
            
            #If model1 wins > 10% of time and has > 60% winrate over other, its better
            if model2_wins > .1*n_games and wr2 > .6:

                #Replace best
                if wr2 > top_wr:
                    top_wr      = wr2 
                    training_i  = pair[1]
            
            #Replace worst wr 
            if wr2 < lowest_wr:
                lowest_i        = pair[1]
                lower_wr        = wr2  

            print(f"\t\tPlayed model{pair[0]} vs. model{pair[1]}: {pair_outcome}\n\t\twr1 was {wr1:.2f}\ttop wr={top_wr:.2f}\ttop model={training_i}\n")
        #Replace model 
        print(f"model vs rand: {play_championship(models[training_i],rand_model)}")
        models[lowest_i]    = ChessModel(in_ch=6).to(torch.device('cuda'))
        models[lowest_i].load_state_dict(models[training_i].state_dict().copy())
        print(f"\t\treplaced model{lowest_i} with {training_i}")
        torch.save(models[training_i].state_dict(),"C:/gitrepos/ChessEngine/models/bestmodel.model")



            

            

