[Music] welcome to my talk tonight I'd like to talk about how I started uh recently started a new project for C++ with cmake and um let's go so at the beginning I kind of first want to start with an overview on where I'm coming from with a project um which starts with last year basically learning cmake and looking at cmake generators to get projects off the ground fast and watching some talks and also this year Watching some talks so this the talks are going to bring us from 2023 to 2024 and then we're going to talk about the actual project um which is a good part of the talk [Music] um I figured out that for newer projects I should use cake because it's the most relevant uh build system out there um and that's why I started learning cake last year and I went through the learn cake and 12 easy chapters like the official cake tutorial uh on the Cake website and played around a little bit with it but I do not like have plans to become a cmake expert I I want to write C++ not cmake and I knew about cmake generators and I kind of like that idea to have a generator generate the currently good cmake you should use and then you can um you know improve that or build up on it um and so let's see if that is actually a working idea so what I've been looking at last year is the cak starter template from Jason Turner and the cake init cake generator on GitHub from friendly Anon and my impression with a cmake starter template was that for someone who just learned cmake it's such a strong and steep learning curve you get like yes the perfect kup set setup is is it's is really cool to have but um I I wasn't looking for a project which like you know has all those belts and whistles already running and if something is not passing um you get emailed because an action failed and then you get another email because another action failed um it offers fast testing which is really nice it has uh CPM uh which is a package manager for cmake integration um which is really cool and Jason Turner did some videos on this last year um so just by looking at this you have lots to learn and the GitHub setup wiard is then basically running and then you get your own copy of this um into your repository on GitHub um and if you read the last sentence this project gets you started with a simple example of using FTX UI which happens to be also a game so this is what you get this is kind of nice it's an application and it's good for prob to get started to to get running to have working C++ code and a good setup um but I actually was looking for writing a library and not an application and I don't need FTX UI and I might now have to see um to basically get rid of FTX UI again and have to do a lot of other setup things to uh get this down to the barebone thing I would like to have and i' I'd like to have more like a modular thing where the G we wizard um asks me more things what I what I need what I want and then integrates set um and this kind of is bit the idea of cake init which is a very nice project on uh GitHub but you also can install it via pip um it's a project generator which lets you create projects for executable SL applications libraries it does have support for Conan or VC package um it does not have a CPM integration right now that would be nice to have um and and it has like some other things which you can do um just when you you know look at this tomorrow at GitHub um or later that's generally something nice to look at I've played already last year with the dot 37 version around and um now the dot 40 version and since there is since um February beginning of February when I this um there is uh three minor versions releas so this is like really really in maintenance this project and under under development [Music] um regarding the package managers I do not know I suppose that Conan is a Conan to zero support because it's something new I think which has been added um but I'm not sure about that so I I do not have a project with Conan support generated by this at the moment I might give that a try uh I know VC package exists but I personally have a preference for Ken um so if you compare them um yeah one thing I wanted to point out is actually CAC init is a command line program it generates locally something on your system and it's not automatically giving you a project setup with GitHub um if you're looking for that cake template from Jason Turner would be better to automatically give you all the other setups and tools which you probably should or want to use or you'd like to see a working example of those um so that's really great work and really really wellmaintained work by Jason Turner thank you for that um and CAC in fils a bit of a different Niche um which can help you a lot in getting started and um that's what I've been using to do last year but then I was getting busy with a conference again and so I didn't really have the time to to have like really enough time to start a new project and all the other things in the retrospect I'm happy because I can now use GCC 13 and back then I was based on gcc1 because it was available back then uh to install on the system without compilation and so right now I'm build uh building the application with GCC 13 which is a lot better uh with C++ 20 and C++ 23 support like for example today I found out that I actually if I wanted to use sdd expected I could um so let's talk about talks um I was really looking forward to the talk from mikale about how to start a modern C plus project um at meting SE with us last year and I had the privilege to to see this talk I think we pre-recorded it twice so it's kind of a a good talk which um covers a lot of other angles it covers a lot more of cake um I I'm not the person to teach you cake so I'm not going to go into the newest stuff with cake or the oldest stuff or how you should do this um I think that it's great to have generators I like generators that's more my um thing um and he goes through a lot of other Technologies and stuff and um so that that's a great addition um he points to the C plus Conan 3 years later talk unfortunately that predates Conan to zero I think uh but it's by mates pus also great great speaker and um good info on how the setup with cake and Conan is and um I guess a lot of what he talks about is still true with con to zero but if you're interested in that we I have a talk on that later too um and last weekend I saw that also like you know start your C++ project today was a talk at the C++ serve User Group um by duzan and I I've watched this talk and it's again very different to this talk um this is also going a lot into Technologies programs and tools you can and should use for your projects uh this talk is is a good talk to skim through to watch if you have the time um he goes a bit through basil a bit through make it's kind of everything is being touched on um and then let me go to cake again we have a complete talk on cake and Conan next week with Diego Diego Rodriguez Lozada um talking about seake and Conan past present and future and we're going to uh see the recording with him so you basically can watch the talk in a group setting with everyone else and um watch the chat chat with people have your questions directly answered by the expert um re looking watch forward to that it's next week's watch party the first watch party and a few weeks ago was with fash work very well and so next week we're going to learn more about modern cake putting projects up running with Conan and how this works um with a weekend there has become two other talks from meeting C++ about cake popular uh these are both from Denis bardier which you know more modern cake and oh no more modern cake is two talks which he has given in 2018 2019 and these talks got Popular by [Music] being in the answer to a question at r/r rcpp and on Reddit so two people have like said you know this is cake if you want to learn cake watch those talks so I can agree with that that you should watch those talks um and there's more talks and the the reason I'm not giving a cmake talk is just that's not my part of what I I'm about right and um there's a lot of other content on it and newer talks on cake probably exist and we will hopefully see more cmake talks this year so if you want to give a cmake talk it would be great to have another cmake talk this year at the conference um or at cppp con definitely also will feature one of think um and then of course I just quickly want to give a shout out to the learn cute Guide channel on YouTube they have a cmake series where you can watch many episodes where things get covered in in depth about how to start and work with cake and I'm probably also going to watch some of those videos when I know have to added the generated cake um which I felt much more confident in doing with cake init generated code for cake than the Json Turner version um also by researching some stuff for cake I found this tutorial which actually is from last year um so it should cover more recent cake um and there's of course a ton of other cake online um choose the way you want to learn cake and how much you want to cake in learning um I for one wanted to see in this here um what's for me the best way to actually have the whole setup for S make for various projects be generated and then be it having having it like connected with my IDE which is cute Creator um so I finally had the time in generally to pick this up and my first thought was the one thing I didn't test last year was the IDE um I maybe missed that cute creater is up to speed and can generate cmake projects in in in the same way or in a compatible way and maybe it would be um just as good to use just cute Creator and I'd be done right one shop one stop and done um so my project is a CSV chart tool and I first want to start working on the CSV chart lip which is this talk about um and then later generate also uh the application and a GS CSV chart cute lip Library um the cute Creator created a library project which is um something I was a aware about cute crater having this um and then I added in this directory project um a cmake library project which Q make cute CR lets me do in the aftermath I figured out that the directory project is qake based and then I have just the C project in in the directory um which is kind of fine but um looking through the C code which came from this I was like Ah that's probably not what I want it's completely working cmake code which includes cute which is nice and helpful to have for future projects where I probably will have to implement that um but the see make itself was for me too simple cuz I wanted a different setup and this is basically most of the cake which got generated um I would like to have at least a cake project which uh not only includes building the library but also includes building an executable which is a test and I already knew that uh C inot can do that so my first attempt was just get give me your defaults right um that's the other thing which you probably see here the the standard you you'd have to change that it's here it's 17 that's how cute Creator got this generated fine with me um but I'd like to use C++ 20 at least so this is how I um generated it for the first time um the result of that was that it's actually too noisy um Clank tidy is picked up by cute crate and cute Creator starts checking like everything and you get everywhere Google Star Guide Google Star guide and I'm like ah um that's not how I want to live so my second attempt was basically for now doing away with Clank tidy because cute creator has its own Clank tidy cute Creator does cling tidy in a different way so um and at the same time I don't have CPP check installed at the machine which I'm working with this so I was like okay just don't need that set up at the moment um Can toy around with it later um the examples I left in but in the meantime I'm not sure like I probably going to leave that empty and remove it later maybe but removing it would be an effort um this is an internal library and it's not like in a library where I want to actually provide examples um how to use it so what I like is the test is basically default executable and cute Creator and um catch other Frameworks need to be added if you don't use a package manager otherwise catch 2 is automatically installed in your project I like um one issue with C Creator at the beginning was that I only got the source folder with the CPP files and the include folder um yeah that doesn't show up in in the tree um you can have it show up if you then add those files to the CME txt file again which I did and then it works and it still builds so I guess it's okay um and in earlier versions of cute Creator I always had like the issue that I needed to build the library first and then the executable and here it's like really nice to see that basically I changed something in the library it compiles links the tests and runs the tests and lets me know if you know my change was correct or not and my only issue with the test executable or generally with this project right now which I have to dive into when I have time for that when it really bugs me enough as I can at the moment in cute Creator I can only do debug builds um normally I should be able to do a release build but that doesn't show up so I guess I need to add a kit for that or something I need to understand a bit more of this corner with kits and cake and presets and that stuff um but that's stuff which I know want to look at when I when I need it so now that the setup is there I think it's time to go into the C++ code and write the library and see how this builds how it behaves how the tests run um at the beginning I want to compare this new approach with cake versus the old approach which was based on cute and qake usually um now I try to start with the library only which has an executable for unit tests I have focus on standard C++ and um try to implement the basic maybe I add some libraries which I need maybe I don't um and I add later the cute Library tests and a front end I usually try to keep the pure C++ standard stuff in in a separate Library um for licensing purposes so that this code is not like lgpl as cute as lgpl um and in the past I of kind of you know started the cute project which is a UI uh executable and I focused on features and progress I always have separated cute and standard C++ code if possible um but I rarely have put that in libraries or like have this actually more bundled like I can do now um there is no qake generator for projects uh cute itself generates via cute Creator basic projects but already like testing is in this not covered and with other idees I don't know if they like generate projects with tests for libraries in in the Modern Age oh that's the like lacking which is probably one of the reasons why so many things um are not in in the state where they where they should be was testing um but that's a whole completely different topic so the project architecture I have in mind is like have the UI executable which is the main program um it will handle some part of the parallelism but that's like a whole thing I'm not going to talk in this talk about um and basically plug together the application and um for the charting I'm going to use KD chart as a plan um which probably already also will be part of the library which uh the cute app Library which contains for example models the panels um a lot of the glue code to connect to the standard C++ code um and the CSV chart lip is basically what's currently implemented it's standard C++ code for loading and searching uh in a CSV file um and then the next step is probably to add the cep library and see that this is kind of you know playing nice that I can then quickly add the executable and then really have like this all being linked together and running and into an actual application um so the current version of this chart clip is what I've written and I've already made a lot of changes for preparing this talk and um some of my tests and some of the the the the when when when when you go bottom up you you find out that some of the classes um which you implement on top have a certain need for some functions which you didn't Implement yet and so you need to provide some services from your uh lower classes to the upper classes um and I thought I start with a class overview this is um at the top I have a document class which goes into having a container of data sources which then have have a vector of records and the record holds a vector of streamie string view value classes which represent the values that are in a string view in the record okay then I have completely different search condition classes value value range value list and unique at the moment um value kind of a self-explanatory and um value range is basically yeah I think the only one I have really have to explain is unique is a bit misnamed at the moment has an internal container and only counts the first occurrence of a value as counting and I probably should like rename it to to to First unique or something um then I have a condition list which has an enum for being and or and this then gets bound together in a variant to be the search tree which is part of the Searcher class and then you have the record holder which later will be again forming a transform which leads to the graph at the beginning I thought that uh the Searcher would basically return the graph but then I realized that I need to be able to Cache the search result and not automatically transform it in the end result because maybe I want to have multiple graphs from the same search uh and especially like when I want to display the result of a search in a graph but also in a map um I should not destroy what the record holder has and the the graph transform basically um you know the data you need for a graph is not what the records hold um the records hold a date and the graph transform is based on on a month right so you will completely be different there and this um will be very complex to implement and many graphs will have their own specific classes um so that's something which I will have to deal with later at the moment that it's like I have a few toy implementations uh for this um which help me test this but then later I will have to see how this fits uh into the overall application later and then I have a crtp based class which is kind of linking value value range Etc together also condition list and um allows me to to build this tree in a variant actually which brings me to the first class which is string view value um string view value has a string view into the raw data um and then has a variant of basic types and STD any um any is for the case that a user supplies its own conversion for a field um and as any can be anything I know this needs to be I completely its own support um and this Basic Value variant which is those basic types um at the moment is string VI Bool in Long in size T float double Chronos seconds and sdn I'm currently thinking about also using struct TM um I I don't support time stamps in the moment but I could with konos seconds why I better keep it but stru TM already has like all this data which you want to query potentially um while Chrono lets you easily do calculations with dates um I think in our context in this context struct TM might be the better choice to basically uh have this all there um in memory but strm of course is a lot bigger than this variant at the moment so I'm I'm not sure about that and then I have an enum which holds the indexes of those converted types so I can basically query the index function of the variant to see if that index is currently the index and compare against it [Music] um I have a conversion function which returns this type currently [Music] but when I started thinking about uh multi-threading it occurred to me that error Handler probably will be so error Handler is a class which is you're going to see a lot this the first time you see it maybe you should talk about this first error Handler is just a templated way of dealing with errors and forwarding and logging um conversion errors especially here and in a multi-threaded conversion you would not be able to know of your error Handler basically if that conversion has now happened to be erronous or not um so this should be an optional um or the C++ 23 expected would be something but I think I would like to keep error Handler around so that basically um you write your own error Handler which is also kind of not defined right now um I have a class which basically is the interface to this at the moment um and then we basically do all the conversions um if it's a string view I don't need to do a conversion I can just return raw data right um and if the type is already in the index I can just use STD get and return um that if that's not the case I need to do a conversion and with Bool um I kind of you know do it like that at the moment um which I'm happy with it's probably like still some some improvements in this code to be had but for the moment I'm happy with that and also I do not have the use use case that I actually need a bu conversion at the moment I think [Music] um I I do use a lot from chars and today also saw that there is already a conversion function on C++ 11 and then I think 14 or 17 added from chars and one of the interesting differences is that from chars does not eat um leading spaces so if this field has a leading space the conversion will fail here but if I then try the C++ 11 I think it's sr2 D and s2f and sr2 L um version this would then maybe converted so I'm I'm wondering if that's work um like you know writing another conversion uh if this conversion fails and if the conversion fails um that's basically where I saw is I um from fromont chars I get this error code and then I you know would like to be able to lock that somewhere and to keep this error message basically be constructed here locally that it makes sense in the context um when I convert this to STD expected I'd have to see if I still need error Handler or if STD expected can take care of this and then the error Handler doesn't not does not need to be brought in everywhere or how this basically then would look with s expected is an interesting question for me in the moment um Chrono needs extra handling the basic parsing from string to date is well supported if you know your format um but basically you're getting a CSV which can have everything and so um cute has some interesting functions where various text date formats are covered and I probably have to you know figure out how to implement that with here and then try to pass them all and see if one of them catched on um and this whole uh string is for the format string here feel it's like a difficult user interface um Chrono pass what not was not a level was not a level in dcc1 so I was not being able to use it um as I mentioned earlier now I'm on GCC 13 and I still have to look up if it's available but for the moment um that is the code um unfortunately also with uh Chrono pars I would have to use a string stream and the string stream at the moment I think is not able at least I couldn't find how to use a string view so I have to put this in a string and if the string is you know not having SSO enabled by the smallness of this raw data string View um we'll have an allocation here which is sad um then we read this into a TM struct that's also kind of why I'm thinking that you know we might might you know just put this into the varant and call it call it the day um and then we create from that the time T and the time T actually you can then convert to Chronos seconds was a time Point cast from the system clock and then you're good to go I've recently looked into one of the use cases I have and it came to my mind that I overlooked that um a date time could be a date and a time and so that uh CSV file has a date and the time in two different fields and I don't want to provide a functionality to join that together I might do that later but for now I at least want to see that if I can parse this and at least for Chrono it's like that you can pass the date but Chrono does not have a default type for something that is actually just a time without a date um that can be done but you would have to implement that and search that for yourself um there's some uh interesting comments from Howard hin on various online platforms about that um and actually the test case I had I when I know got this working with this is a test case and unfortunately this test case fails which kind of surprised me because this is basically code which I pass the date with earlier and now I pass the date time was earlier in the test case and then I copied it to part only the date and it fails um and I just you know I remove the output I had here for for debugging P purposes this is the line and the reason this fails is here with floor then you get to have the year months date to be April 15th and I assume that has something to do with that we do not generate a time here and then it's you know using the system clock or something um I I'm not sure about where this is coming from but if we use round it works I've been looking at like where did I get this and I was like this must be CP reference and I was like oh this is this is um also like you know is is this um correct for the example code and um this this run run this code on this is run this code button on uh CP reference you can actually run the examples there which is very cool and if you um add here round this is actually then wrong so you need you need the floor when you par the date time and that led for me to the question does this actually pass other dates correctly now or does it work for the date I picked so one thing I like to do in my tests now is to write a Lambda which gets the parameters I want to test and in this case I use um SD format to uh format this into a string and I need to do this because I need to compare against those integers um later to see if you know the cusing with Chrono has been correct or not otherwise I could just give it a string view um but if I give it a string view I have no idea what the these are and I found it interesting that um Chrono year is an integer which you know years can be negative but month and days cannot be negative so they're unsigned which brings me back to the string new value class I provide also uh conversion function where you get already an optional um to see if a field has been converted um the search condition classes convert and the search transfer classes access the fields um but it also now occurred to me that the transform also will have to access fields that have not be converted to an integer and the classic example is like counting Fields I have like a field which tells me how many things are in this line and um like for example there was tickets ticket sales as a CSV file and you get the number of tickets um you're not going to search on this usually you maybe search on a date to know the sales from a month and then display that in various things maybe but the counting field might be interesting to you in the in the transform when you know you want to display how many um tickets you sold in a month um the other thing is that not all of the Transformers will have to do sometimes you just want to access the field and um basically count it like a counter not like a sum and then you may want to convert it to check for correctness or just accept that it's there and just say plus one yay and this function is very similar to the previous function so I'm not going to spend a lot of time on this um Springs me to the record class it's basically a vector of string view values and I have a string View for the line here which I'm currently not using but if I ever need it it's there um I have two main methods here the one is for accessing a record uh of the string new value and then there's a condition check which gets the crtp based class for conditions and the error Handler and um some conditions will not have a way or will not need to access an index or like an actual value in the record they will have to check the record itself so I need to see if that you know if this visitor has an interest in the index itself and if it does not have it then it just you know for example the uh condition list um will just you know need to have the record and then call this function again with all its search conditions and its back door which already brings me to data source the data source class contains the string which contains the actual file that has a vector dra for the headers in a string view a map of the field names to the index and a vector of the records and something I didn't add here recent changed I saw that at least from the point of view of the application I should also have a vector of unique values per field so I currently have this in the data source um because it makes sense to generate this once and then basically have this available um the search records is just you know quoting things and Counting things and returning them at the moment um the interesting part is to create this class and its uh Factory function it gets a file system path and then creates it and returns this so um we read the file into an ifstream push this in in a string stream and then retrieves the stream the string from the stream and this is basically what this is based on then um we have a sync Lambda which gets the line and the fields and then basically call S and place back and I think I should you know move the vector then into the records [Music] um par CSV at the beginning when I started those slides still had the comma hardcoded um now there is a f Del meter function which gets the actual data I check for comma as a default delimeter and for the semicolon also kind of check for uh the position of the first uh line and this might have to be you know um improved with some error checking that you know we shouldn't do this on on like an empty line or something but at the moment I think that is like usess for then and the par CSV function reads the headers and the actual lines with the parse line function and then just generates the various data members which it has received bya reference um the par line function is basically an adoption of what of the code I wrot last year but I need to handle quotes with new lines in them and that's basically what I added that's just another mode and um I given like multiple talks on pausing csvs last year so this is covered um and not that interesting um which brings me to document um which binds us all together and logging Handler is a current error Handler implementation um I use reference repper here to replace it and basically have a default Handler um I'm currently thinking that it makes more sense to have the document class be a template and have this error Handler be the template parameter that the outside can provide its own error Handler instead of um having this hardcoded here so that's probably a change which is coming up um then I have various functions to to manage this I have an an add fun function to get the CSV loaded I can remove the data source I can visit the various data sources the document has loaded and I have a often a size function to return the size of the container for testing purposes and probably later in the application this also will be useful that are the methods for handling data sources and basically I have the same thing for handling the searches um I've moved the name of the search into the document and um the name for the search is not needed for the search class itself and basically is something which needs to be attached from the application to handle searches right um to display this and um I'm at the moment not sure like how I do want to do this and what's the best design for this um where to put the name should it have a name um should the library which just focused on the application handled this um these are kind of the design questions which I'm thinking about sometimes which brings me to the crtb based class quickly let me look into the chat um someone asked if I have thought about implementing a pure C++ solution for demo purposes no I have not I don't have the time for that I don't want to add a database and I don't want to Cache uh the CSV file content in SQL database um that's completely not the route I want to go okay um so there's a question on LinkedIn um I do not have the library currently on GitHub um I probably will do that later when it's a bit more cleaned up and I'm more certain about the implementation but at the moment I don't want to have people basically trying to you know send me their PRS and something on GitHub uh when the thing is not done and ready um and I I do work on an application here and so the library is not the main focus and I be soon busy again with um running stuff for the conference because the conference will be announced in April so let's go on um let's talk a bit about crtp um I kind of have the feeling that this would be a good way to implement the hierarchy for the Searchers and so I've looked around to read up on crtp again and there's a three-part series at fluent C++ which covers a lot of the things which you will see now um I know that C++ 23 also has something about crtp um but at the moment I do not use C++ 23 so this will not be part of this maybe I you know add this later um this is the basic class which I have uh class derived which is then um declared a friend and this Base Class is for all search conditions the base class um and private are the basic Constructors to construct The Base Class um I then learned from the tutorial at fluence C++ that you should have a method which is to derived um to basically not have to write static cast everywhere and constant methods you would have to write constant static um cast constant derived and derived and this way you get around this um this way you just call derived and you're done and um in this case we need to the two methods which are currently implemented are check and check record and name is the example which fluent C++ has and I think when I add serialization that I can basically save a document with a searches um that might be useful to basically have a [Music] general name um and another thing which would make sense is basically to have like the type ID be returned here um which I guess you already could do in the base class right you have you have the derived type and you could get the type ID and you could return the type ID and then that you don't need to imple implement that and the type ID would be um a nonhuman readable name of the class and in that way derived as a friend and can construct its parent and one else um I wasn't sure about how things play out and so I have at the moment um not the I'm not sure about the move in the copy Constructor at the moment that's there probably will delete it and see if it still compiles as a have tests and see if it you know works as as private I do like to you know when we talk about construction details here I do like to declare these as default um because I think it's it's often better to have this explicitly declared as default then to um just not have it there or to implement it yourself which you really shouldn't do um let's go over value range as an implementation um so here we see basically how I check if an error has secured currently I get the lock size and I see if the log size is still the same when we converted this and when I looked at this code and thought about error handling I began to understood that this is basically um this code will give you trouble in a multi-threaded environment because between reading lock size and reading lock size again someone else can have converted an erronous type somewhere else and then you do not return and you do not um convert this part which has been converted successful so I do need to return the type as an optional and then I have this encoded in the return value and yeah so so lots of that stuff is also new to me optional is a nice thing to have and I see that it's in a lot of places of things which return things it's a good thing to have um then I need to have a variant which is basically a templated using Declaration on all those uh condition types I have which is the downside of having it like that but that way um we then can construct the variant which holds a condition and so we forward declare the class condition list and declare search value types with string View and all other types in the condition list and then the search value variant is in the condition list class there is an enim for and or and a mode for which just by default and um because basically the Searcher has a variable of this and by default it should be and that's a good us user interface um and if you add a search condition list to a condition list then you have a tree which brings me to the searching part itself so here you see that the Searcher had a name but this got moved and I'm not sure if I'm move moving it further uh but basically the Searcher needs to have the condition list and the records of what has been the result and I have an add condition function but of course I should also have a remove condition function which I need to still Implement um I did this for the document but it's like something which I need to do here too um and then basically I have the search record function which just takes a record calls check record um calls add record if it's true and returns true otherwise it returns false um a lot of those implementations are very easy to write now um the transform search result is another thing which I'm now more sure about but I really had to try to figure this out for a week and to look into um what actually my uh you know this is not inside the Library the library does not provide the the graph format there's a graphing Library I want to use and this is basically what's supposed to go in there so I'm kind of implementing something which I have to look up which what what that is at the moment and the transform has access to the full record and as I mentioned you know might need to convert the field from string VI to a sum or any things um because they were not touched in the actual use case for the search the record holder in the moment does not copy the record um as the record itself uses a string view so copying the record doesn't really makes sense so I put that in a reference wrapper and then basically every record gets added to this and I provide some inter iterator interfaces that this is easily accessible in a for each Loop and it's just a simple class to catch the sear result the transformation as I already mentioned is a lot more difficult um in the end the graphs are often number based and I have to figure out what are the things that is needed um to be generated from this transform is it like one thing or the multiple things and how how do how how do I want to design this in the future um and the whole thing is just you know um sometimes of course you could just want to display the search result which is probably something which I do that you can see the search result which is also for debugging purposes when you debug this or actually want to see what what are the records which the graph is based on does it make sense or do I have to um add another search condition um so I'm definitely also plan to have like a table view which displays the records and then there's the whole topic of grouping you have group on a column type that's easy um per month or year so you need I have some functions um which basically return a string of a year month or something to group against or an INT um that's stuff of the future um I did a lot of dummy transforms and thought can I you know kind of write some Central things which is like the architecture of that and I reuse this architecture um I have not come up with something which is reusable at the moment um from cute perspective this will need to be held by a class which is a front end to the model view architecture um and then there's also like an easier way to do this to basically have uh Q vector be filled with a data and then is that is like one line or one row of bars in a chart data class which you add to the graph um but this is basically something which I need to start implementing when I know what cute needs and can test this against cute um and I have used model view and cute quite extensively so this is easy to implement um copying your data in a q Vector is then also a needed thing from from the cute interface um and have to see one one when to use one and when to use the other um mentioned I want to use KY chart for this which is a very nice library from kdab it's MIT licensed so when you have a commercial cute license you can use it when you have an lgpl open source cute version um the lgpl stays it has very Advanced charts also and has 159 page manual um which I've been partly reading through but not completely um I have many open questions and this will be a lot of fun for me to implement that in in this and probably the coming year um and the next thing to do is basically to write the application Library which uses cute things and provides tests for stuff which the application uses and then to have a CSV chart application which combines them but also I'm getting busy again um I have to still you know do a lot of stuff for the conference and get things ready so um I guess I will return to this in summer and maybe not some of the open questions I'm currently thinking about maybe uh I you know do do some of the refactoring for the multi threaded code which I see that is like a requirement um that would be interesting so thank you for your attention if you have any questions um please post them now in the Q&A section or in the chat um and I will try to answer them thank you much yeah I I see someone commenting um that CP is deducing this and I've heard about that but um I need to look into this and I do not have gcc1 14 at the moment and so actually being able to use uh deducing this would be really nice but I think that at the moment I'm going to shy away from doing that that's just I'm based on on GCC 13 and I'm probably for the F for the next year going to write code based on that and then hopefully be able to go into gcc1 14 and other adventures and as I mentioned this is currently not on GitHub but I have plans to add this later and um we'll do so probably within the year when the whole code is cleaned up and at some some point I have to edit to GitHub anyways to to have it um you know basically pulled down to other uh build platforms and have it on my notebook that I can take it with me and code in my holiday on it um and I see that Paulo is mentioning that if you need an educational license and you're a student or or like you know a teacher you can get that from cine for brins and yeah gcc1 14 has not released has not been released yet and so um I think that deducing this in C++ 23 is very interesting but I also wait for ISO to release D+ Plus 23 so at the moment um I try to learn C++ 20 and I I saw that I like as expected I could use because it's in 13 but um I I don't know if it's like worth dragging in a feature like that already and not like have people wait for it and and gain experience with it I'm not an early mover with my code okay so there's no more questions I think we reached the end of the talk thank you for coming thank you for sticking around and