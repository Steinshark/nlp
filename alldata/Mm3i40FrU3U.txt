hi my name is uh julian jamie uh i'm leading the software solution team at kitware and i have been involved with cmx since pretty much its inception about 20 years ago and i lead the development of c-test and c-dash it's a pleasure for me to be presenting at building c crossbar this year um so my talk is is going to be about cmec um if there are some of you that are not familiar with cmake i'm going to describe the little details what cmake does and what uh cmec is i would also uh talk about about cmake on the support for c plus plus 20 modules and at the end i will talk also about c make dependency only which is something that is getting more and more important in the field these days so uh kitware works in a wild range of industries and we have five main divisions uh at kitware uh we work on the computer vision fields where we treat a lot of videos as well as data analytics and scientific computing with toolkits that we have developed on applications such as vtk and power view and in the medical computing fields the software solutions team is dealing with all the software process and is also responsible for the maintenance of cmake and we also help our customers and the community to get in the ends of cmake and and what's a little bit better with cmake um [Music] one uh thing we do at kitware is that we develop platforms and solutions that are based on open source software uh we are known mostly for uh vtk the visualization toolkit which was developed in the early days of uh kitware and uh keep keep growing uh we also are developing itk the inside toolkit as well as power view and we are the main developers and maintainer of cmake one particularity about kitware about what we do is that we develop toolkits as well as applications but our toolkits are mostly c plus plus and they have a little bit of particularity that they are cross-platform so they have to run on any type of operating system linux mac windows and also android systems sometimes as well as mobile devices and also they have to work on a wide range of devices such as web desktop mobile cloud or high performance computing so that makes our life a little bit interesting and that requires for us to develop tools that allows us to quickly develop on on cross-platform functionalities um so for that uh we started with uh we see make and uh cmec actually started uh in 99 2000 in the year it was developed initially for the insights segmentation and registration toolkit itk itk is a toolkit meant for medical image processing and it was funded by the national library of medicine a branch of nih in the us and it's part of the visible human projects the visible human project is actually a kind of a interesting project that started in the in the 90s where someone gave his body to science and then he was scanned uh first cat scan high resolution at the time uh as well as uh mri so magnetic resonant imaging as well as slices of his body so his body was laid down it was actually frozen and it was sliced and imaged photography this is what you can see on the top uh right corner of this slide and this data was the acquisition was was controversial the project was a little bit controversial but but also it was a huge success uh because he provided for the scientific community uh the first of its kind uh data sets and uh in 99 the nlm looked a little bit at how the data sets were used and a lot of engineers and researchers across the world were using developing algorithms to do image processing on this data image processing such as segmentation so trying to figure out part of the body and extract part of the body in the digital way as well as registration what we call fusion so trying to fuse a cat scan with mri scan to collect the information put them together and um so the nln decided to uh to quickly uh to develop a framework that will allow to have a common uh platform for developing these algorithms so instead of having two groups across across the world developing their own algorithms in in in their corner to put that together and and they decided to create the inside toolkit so the inside toolkit is a base uh c plus plus uh it's it's an open source toolkit it's available actually at itk.org and it was a consortium initially was was uh part of academia and part of industry and kitware was involved with this and one of the first stars that kit were at was actually to develop a tool or wait for this toolkit to be compiled this toolkit cpr space toolkit was meant to be used and compiled because it's not an application by a lot of users on researchers that don't necessarily know about drill system or compilations so it was very important for them to be able to easily compile the code so the three main platforms were linux mac and windows and at the time vtk it happened had a tool called pc maker so that was generating visual studio projects so that's how cmx since pretty much day one had a way to generate visual studio projects which was one the unique feature that cmec has at the time and then he grew quite a bit so cmec the 1.0 branch was created in 2001 and then he grew from there and we discussed a little bit about that so what is cmake uh c-mac is a cross-platform so it works on on a wide variety of platforms and when we say platform is combination of operating system but also hardware that you might have uh as well as as the tool chains that you might have as well uh it's open source it's really under a bsd license uh and it's a build system generator meaning that it's going to generate for your build system and depending on what you have it's it's going to uh to do that one particularity about cmec is that actually it has to run on a wide range of platforms that i was mentioning and we are testing that every day so we um we see tests on c dash we've been developing ways also to test cmec and it happened that it helps us also to to test on uh house our other software um from day one uh the goal of cmake was and the philosophy we had was to let the developer use their native development tools that they loved the most the main reason for that is instead of imposing the compiler the toolchains and the ide we wanted to let everyone use what they loved uh because we think first they are more productive this way and they don't have to relearn a tool but also they are able to just keep what they have and use the toolkit so the adoption actually not of c mac itself but the adoption of of the toolkits that will be used uh would be greater so that was the philosophy we try to keep and that's why c-mac is this way now uh and it doesn't do it's not perfect uh but we are trying to to make it uh uh better every day uh for that so cmake for uh those who don't really have touchy maker know what it how it works uh cmg takes plain text files as inputs so basically files that are called cmakeys.txt to describe your project and what it does is when you run it you will produce project files or mac files so project files will be for xcode for instance or visual studio and make files we support quite a bit of make files as well and cmec is also a family of software development tools so of course for the build we have cmag but we have also component tools such as c-test and c-dash for testing and packaging we have also c-pack so cpac is bundled with cmake if you download cmake you probably have cpac installed with it if you compile it yourself you have an option to compile cpac it's a very lightweight executable that allows you to create professional platform specific installer that's what we use for delivering cmake and it will provide windows mac and also on unix you will support package manager such as xeon apt and so on so it's a nice way to deliver your application so being closer to continuous delivery we use that also for applications that we have at kit where such as power view and others and and again if you use cmake you in your project using cpac is actually fairly simple in about 10 lines of cpac code or cmak code that you add in your in your code it's immaculate files you are able to have a packager of course it doesn't do everything potentially but it will solve most of the packaging problem or solutions that you want to have another component application that we have to cmake is a c test so c c-test is not a unique testing framework uh as his name might suggest uh but it's actually a testing driver meaning that uh it will take your unit testing framework and i say unit testing it could be functional testing any testing framework basically and it will drive it it will drive the test it will run them it will collect the information and then you can do what you want with it you can check if the output is right or not what we do here at kitware is we use it a companion with another tool that we have called c-dash which is a web-based dashboard for collecting testing results from c test uh the screenshot that you see is an example what we have so each line for instance is is a different configuration that we test uh for c mac we have uh android builds that are generated uh if we every every night where we test continuously this uh based on merge requests but also on a nightly basis and and we drive the packaging as well so c-dash is is is not going to drive your test itself ctas will do that for you and uh a lot some people use it in in uh combinations with jenkins for instance or or chevy ci or security and other ci tools uh but it's a nice way to uh display and show the testing results uh at kitware we work a lot in the visualization fields so when for instance you have a rendering that fails a couple of pixels you need to be able to uh to show that and you need to be able to explore what's going on so c dash will provide you that in a web manner to do that so one thing we wanted to do with cmake is um the analogy we take sometimes is is we wanted to change the way we built c plus plus um so interpolated languages some interpreting languages they solve a little bit the cross-platform way by making you install the uh an application that will do the interpretation of your language so make it portable by default and the same way that boost aims to give c plus that set of useful libraries uh to be able to use them like java python or csharp or net framework um we wanted cmak2 aims at giving this c plus plus portability like the one like the compile wants one everywhere that these languages have and it's obviously not an easy task we've been uh facing challenges uh but the community have been uh has been uh really helping and we've been improving uh on top of that um the the idea is to have a the same build tool on files for all the platforms we all know that it's not always possible that you need to have sometimes a platform specific uh ways of of compiling but at least provide a unified framework for that and it should be also easy to mix both large and small libraries that's something we wanted to have as well so the key cmake aspect and the vision of cmak is is basically that we want to only depend on the compiler we didn't want to have to rely on other things than a compiler and that's why some of you have been using cmec the first thing that when you run cmake for the first time the first thing that it does is actually checking which compiler you have and how this compiler works and basically defining this compiler uh which could be obviously tricky for when you do cross computation sometimes but that's a different story um and we work course we want also cmake to work on any type of os compiler on id that would support c prosperous so of course the cmec team development team is is limited so supporting that at the greater scale is is requires community efforts so that's why we rely on the community to to be able to to help us uh supporting new compiler new ids and new operating system as well and uh and the goal is to allow linking not only for small projects but also for large projects and being able to do that in a in a seamless way i'm going to say but also to to be able to do that so that everyone can can use it so cmx reports a wide range of tools native tools we support actually pretty much all the version of visual studio starting for visual studio six and we are duplicating them as we go but even eight days ago microsoft announced that uh 2022 super cmax uh we'll talk a little bit about that we support volume make another type of make file ninja uh xcode as warm and we support quite a bit of ids most of these ideas actually have been contributed by the community so cmec is able to generate for this ide what we're seeing also now is that some ideas they will integrate cmec so they will make themselves basically understand cbank which is uh which is pretty nice to see from that so one thing about cmec is also that cmake it's it's a good system generator so the the part of the generator is important it means that it's not a build system itself so it has to to adapt to new technologies and new ideas and new compilers um so for instance we work with microsoft on the visa studio team to have their team working on cmag that has releases supports basically the new version of visual studio are supported after the beta comes out uh the same with apple on xcode basically uh weeks after the beta comes out cmake will be supported we work with the google team and the ninja team to support uh a little bit more cmake as ninja matured and with the recent shift also with apple silicon we've been having support with that being able to support that and uh also we work with compiler providers and and client gcc intel and others to be able to support new version of the compilers meaning making sure that you make understand this new compiler and and improving that cmac is actually also quite popular according to the jetbrains id uh c-mac is is the most popular build tools at 53 percent i went up from 82 percent uh 42 sorry uh a year ago which is uh which is great to see um and uh and it's getting a lot of traction uh so a lot of people are are starting to use cmake uh and um especially for supersports projects so about over 90 percent of of the code that cmec deals with this c plus plus uh we have also uh of course cuda and and and all the nvidia efforts that are supported a little bit c sharp uh fortune as well and um and a little bit some other languages that are a little bit more exotic that are not totally supported um or that are a smaller version of people are using we also uh i think about three years ago we looked at job openings we see mac experience an indian on linkedin and just uh to see which company was was looking for cma developers or cmec understanding cmake or stmx expertise and there are quite a lot actually um that are large corporations small corporation actually a startup as well uh looking for for cmake jobs so which is great to see uh it's uh it's great to see let's make this popular um one thing i want to reiterate is is cmec is is definitely a community effort the team here at kitware that supports and and develop cmec is uh it's fairly small but we have great developers uh here and and we also provide support on training on top of that but there is really a community there are books that are released there are presentations at conferences about cmake and how to use cmake sharing experiences about cmake all of this is is great way to disseminate and i mean the goal of of what we had in mind with cmake was to release an open source uh good system generator that would work for everyone so that's our goal um we're not saying that uh cmec is going to continue to grow and we are going to we are fairly flexible in trying to make it work for everyone we know that we cannot please everyone there are some projects that it might be difficult to to transition to cmake but most of the time we should be able to do so um and and the community has been growing so uh quite a bit um and and in this slide the comparison with auto tools is actually probably not fair um but we've seen what is interesting in the blue uh graph that shows that uh in google trends it goes back to 2004 uh but it shows that cmec has been has been growing in interest quite a bit and the community as well has been growing as we can see you would see a small step around 2006 in that graph that's when kde the k desktop environments announced that they were transitioning to cmec so they had been looking at they were using autoconf and then they moved to uh to python to westcon sorry they try scones and then they finally decide to to move to cmake um and uh we have the we still have the announcement somewhere uh it was uh it was great for cmake on the community and starting from there is like snowball uh into a lot of people using it including large corporations netflix have been using cmx c test on c dash for testing their streaming services for instance to to check the quality of the streaming um and they release a small blog about this in in 2014 so uh we are looking forward for the next decade uh of cmec potentially growing and adapting and and we know there there will be some challenging out there uh and working with with the simple space community and others to to make sure that we adapt cmake is very important uh so so we can ask why cmac is is popular and and actually i mean if some of you have used cmank uh the getting started with cmak is actually very easy the the level of entry is is very easy with simple commands like ad library ad executable you are able to do again cross-platform being able to generate a library and being able to generate an executable with one line of code i mean you need a little bit more of that but basically with one line of code you are uh able to uh to generate that um also because we are cross-platform uh because cmx is cross-platform you are able to generate we are able to touch more more parties and more users that that would be using cmake and and we have even some windows only developers that are using cmx because you make it's a little bit easier to uh to manage and to support than just staying with with the visual studio for instance only applications and a lot happens with this simple command that we have a lot happens behind the behind the scene that you that are under by cmake and basically you're trusting sima to do the right thing there and there is a lot to do but most of the c press plus nowadays projects that are starting a lot of them are using are using cmx so along the way we had we have some some uh unlikely but uh but pretty cool contributors to cmake one of them is in uh in the recent years we had a collaboration with minecraft so if you have kids or if you are younger than me and you play minecraft that this game is actually set up with a uh build with cmake uh because it has two um on multiple platforms so it's been a great way uh for us to uh basically get into the the minecraft uh the the collaboration and of course challenges because it's a fairly large project and so on to work with that uh also uh starting 2017 uh visual studio uh 2017 the microsoft is now shipping cmec with visual studio which is uh which is great especially considering that uh not so long ago we were reverse engineering the visual studio project files to make sure that they run with cmac so it's it's been it's been very interesting a way to do that and thanks to the microsoft team for helping us with this and making sure that we are working on that and and they are also helping us on on the module support for instance uh we wish that to you a little bit later uh it's been a great uh addition to to cmec and and also for the developers around the world to be able to do that especially the one using a visual studio uh we also work with uh bloomberg engineering so they added a couple of support uh like the uh improvement to the exonic of object file definitions uh for instance or improving also the cmx file-based api that they needed again for their project and that we put in cmak320 not so long ago again these are examples of of communities supported so these are functionalities that are needed for some big projects but also that are used for their projects and it's great to see that and the cute company also has helping us describe some of these as well so uh i'm not going to go into too much detail about coding with cmake uh if you are interested i i provide some resources at the end of this presentation um i just wanted to to just show a little bit for if some of you don't know really about cmake how it works but uh the way it works is you have your c press plus code so instead of writing a mac file or writing or having your visual studio or xcode generate the mac files for you or project files basically you will describe your project so what you want to do what are the targets what are the dependencies between the targets some properties and so on you will describe that in text files that will be along with your source code in your project and then on each platform you will have cmake installed so what i want to mention about cmake is that cmec is actually a fairly light executable it's written it's meant to to be cross-platform so to work pretty much anywhere and you can compile it assuming that you have a superspace compiler and it's it's fairly easy and it's plain text files so it's it's fairly easy to understand and to parse for cmake um and you will run that you will there is a configuration step and there there is also a generation step again i won't go into too much detail into that but basically at the end once you run cmake and you configure your projects you will be able to uh you will have a mac file or you will have a project file that you can run and then you launch your favorite id uh qt creator uh c lion for instance and you can compile your project um he will he will exactly know what to do that's the main idea behind cmake there are a couple of ways to run cmake there is a cute guri that is a cross platform again uh called simek gui that allows you to show that to your developer to show the options so for instance you want to be the documentation do you want to build testing do you want to add specific configuration along the tree uh you can specify that in the cma gui there is a so terminal cli cc mac that will allow you to to do that um and there is also you can run cmake from the command line uh as a non-interactive command line so basically being able to to run cmake again there is a configuration step on the generation step as well uh so this is an example of of the cmake workflow so so basically the first thing that you will do you will involve cmake and and if you can see from this slide of what cmac does is checking which compiler you have and it will check does do small configurations um check that your compiler and then it will go into the configuration and then it will go it would generate the mac files you can also call cmak dash dash builds that will call your tool chain and that will compile your project automatically and then also you can run testing if you have testing for that so again i'm not going to go into too much detail about how to use cmake uh i hope i gave you some overview of of what cmake is for people we don't know what cmx does it's available at cmec.org so you can check that there is also documentation and again there are tutorials uh online that are available um and ketu also does uh training if you are interested as well as support so now i'm going to talk a little bit more about uh something that we've been pushing in the past years uh about cmak and and the relation with c plus plus 20 modules which is something that we are very excited and a lot in the community i think are excited about the c plus plus modules but we need to find a way to support that so uh i'm pretty sure everyone knows uh how module works but this is a very light example of that is so let's say you have another world cpp uh file that has a module declaration so we export the hello world and we have an export declaration that export function hello in your main.cpp you will do an import declaration and then you will be able to call that function okay uh this is great but for uh from a build system perspective um you cannot you need to know the dependencies you need to know that you have to compile uh helloworld.cpp b4 main.tpp otherwise the compiler will not work and that's something that without parsing the code and having information from the cpus bus compiler you cannot infer that so basically you need to have an external hint and c make there's another parser simple suspension we don't want to have one so we need to have a hint uh how to build that on the order of dependencies um so the good news is well cmec has been doing modules for quite a long time over 60 years actually and one reason for that is because we've been dealing with fortran so kitware works a lot with the national lab the u.s national labs and and um in the scientific community a lot of photon code base and mixing with super sparse as well and they have been using cmx so what happened is that in 2005 um there was a an initial make file support for modules that was added to cmake barrier by breitkin actually at kitwer and i was added that i'm going to describe a little bit how it works but it was added to c-mac it was it was working pretty well and then in 10 years later we started to add support to ninja for fortune dependency five this was funded as part of the trainers projects from san diego national labs and the way it's been done is basically we had to fork ninja and we have to put the the functionality there and and be able to support um to support the modules um the good news is that four years later uh seeing that it was actually working well on the 14th job for this trillionaires project finos is a it's a very large project by the way it has quite a bit of dependencies uh the grill tree um is actually pretty complicated um and and with with the fault that we have a ninja work it will show that actually photon modules were working pretty well so what happened in 2019 ninja they merged all the changes upstream uh to support photon but that was done because also of cpr space module and they knew that um super space modules were coming and the system was actually would work for that um so how do we handle that in cmake for fortune uh and then i i talk a little bit more about the translation and how that can be done in c plus plus um when we move there but um so let's say you have a module math uh here and when you compile it in fortran uh it would generate a module implementation of object file uh mazda but you will also generate a mazda mass.mod which is a modular interface file and this file will be actually used by your program main so to generate main.o so basically you need to have main.o uh to generate sorry you need to have mass that mod to generate your main.o so the build system it has to we must discover this dependency order in order to build and rebuild the program correctly okay so building the program correctly meaning that it has all the information and rebuild meaning that if something change it has to know the dependency and do it correctly but also if something doesn't change we don't want to rebuild all the time we just want to rebuild what's needed so how does it work for cmake so cmec is a target based system so basically in a cmak project we organize the source files into groups uh that are called targets uh really i mean if you don't make files that premiere what it is uh and each target basically corresponds to a final real artifact artifacts a correct build so what we want at the end is the coil grid that means when the source file is changed uh all the outputs uh which are affected by the sources contents uh have to be recreated and so that's the first thing that we want and we want an efficient build like i was saying before uh is that that means that any outputs which are not affected by the source changes uh shouldn't be recreated and we don't want to lose precious cpu time to recompile something that was not needed so if we look at the build graph for single source for our fortune module dependency we can look at the f90 original source what what's happening is that we have a preprocessor so the build system has to pre-process the source file to extract the module references and the build system may pre-process the surface independently and concurrently because these are especially these are independents of the module constructs so we should be able to to do that uh the pre-process rule what it does it's it's performed by compilers um in our case and it under the resolution of the include and the defined directives for instance and during the execution of this rule uh basically cmec expects that there is a other dependency information that is going to be available and uh that stores in uh pp that uh f95 preprocessors so what we do after that we do a scan rule uh which is uh basically performed by cmake and the scan rule will extract the what we call the required and provides modules for a source file and and we start adding a ddi extension and once we have this ddi we perform a collate rule again this is performed by cmec and this is to collect information all the scan rules that you might have for your files and we collect that um uh collects all the information also collect rules about the dependent targets and uh we write um a model dependency uh information called gd file and dynamic definition dependency file and then once we are ready to compile we looked at his dynamic dependency file and one thing to realize here and the arrow that you see the blue arrow means that basically the compile rule cannot be run until the build tool that we are using takes the output of the of the collector so we have to the order has to be that uh the collect all the information about the collate has to be available for the compile to run so this is something uh very very important and that is what going to define the order so if we look at the graph for single target you will see that for instance if we have three source files a1 a2 a3 um we will do the same thing the pre-process as usual the scan and we collect collate sorry all the scan files output sorry and and then we use that to compile so what you see in this graph actually there is interdependency between the compilation output that will be discovered during the build so you remember that c mac is run configure generate and then you delegate to the build time so at build time you have to understand that and that's why we had to modify ninja so that ninja is able to handle these dynamic dependencies you will note also that in this graph there is no interdependency between the compilation output so if there are any they would be discovered during the builds and that's what we show here is that basically uh you have a mass that mode that is needed for uh the object a2 to be compiled that will be discovered by ninja at build time and uh and and this graph shows a little bit it shows that uh when a uh that dd which is basically our output of the correct file that has all the information we need for the dependency when it's up to date and we can read it um we'll discover a lot about our build graph and and the build system will understand everything about the big graph and what we can see quickly here is that first a1 and a3 can be compiled separately that a2 depends on a1 at this step and and we have that and more importantly that if something has changed in a1 we might have to recompile a2 but a3 should be good and again all of this is discovered by cmec and by ninja in that case and and we are able to to deal with this dependency and then it gets a little bit more complex when we do a build graph on multiple targets so then one thing we added is that the dd file actually uh the dependency the the dynamic dependency files um uh for direct dependent targets uh they are actually additional input to the targets so that means that modules that are contained within a source file in library b for instance uh that will be used in another uh use another certified in library c they we will get the dependency uh correctly uh for that um so i hope that that gives a brief overview on how the dependencies on the on the multiple step that we have the scan and and the collate and that does that does its job so how does c make handles the modules so basically we have a fortune parser that is based off magdeb f 90 which is a make dependency for 1090 applications uh it's a fortune purser it's not perfect um but it works pretty well that's one thing we want to try to avoid adding a parser in in cmake but i touch based on that in two seconds uh we had to patch uh ninja and now that's upstream so that's that's pretty good and we have also a dynamic dependency collateral inside cmec that is available and this one could be reused for c plus plus um so for the c plus first module actually uh we we can do exactly the same i mean we can uh we if we have l from the c plus plus uh compiler uh we can we can add the super source will graph and we should be able to skip uh this the pre-process form so basically we can just have a scan on collect and collate sorry uh and it will work uh pretty well exactly the same as as we've seen with the photon code and it will also work with compiled code generators as well so let's say you have j1 cpp.cpp here that generator executable that this executable is run at build time to generate code this a3 code we can do the same we can do a scan and collect on this generate the code and then scan and collect on the b system general on the a1 a2 m3 and then generate the dynamic dependency file for that and it will work exactly the same um so we are very confident and and talk a little bit more about that but uh we are very confident that the what we have done for fortune actually will work for uh for c cosplayers for uh simple space modules so there are basically options and and we wrote as part of the c plus first order we wrote some some recommendations but there are some ways to uh to scan and collate so one option is to scan the sources independently then collect them and that might be preferred when you have incremental drills uh with a small number of change files um because the scan rules on w5 will only be done when necessary we it might be recommended for a project with wide build graphs uh where the number of scans step at a given uh grass depth uh can saturate the build machine setup and also a project with a lot of generated sources obviously another option is to scan source all at once and then collect so that's something that is uh that is possible as well that might be preferred when we have from scratch builds and when we have also a platform with expensive process execution because you run only once the scan of course this step will require a more complex scan tool uh so because internally you should decide uh whether or not to update uh the output file uh depending on the source to avoid rerunning other words in necessarily so we need to we need to be a little bit careful when that would require a smart scan tool and the last option is is we can scan the sources and collect and collate all at once so this is probably the more extreme version of the previous examples and we'll need more more complexity for that so the the message here is that um we don't want to uh put uh c parser in c mac uh because we feel that well first like the compiler are doing that already so we don't need to redo that we also learned from fortune that um well we need to maintain that and when the language language evolved we need to make that evolved and the compiler should be doing that so basically we need we need compilers to provide support for that and and we think that the scan rule that has to be implemented can be implemented as phase four of the compiler um and idea ideally will the compiler will provide the name of the module to be imported and exported uh the name of the header units that are imported so basically defining the dependencies uh on the path of the file that i weighed by the preprocessors and if we have that information we should be able to uh to take that and the b system should know the dependency and we should be good so we so we wrote as i was saying um we wrote a couple of references and the secrets standard that are done and and actually a visual studio um release in 2022 in the version of visual studio 2022 there it is a version of the scan uh version that seems to work we tested it there are a couple of tweaks that we need to do in cmag but it seems to to implement on that so uh we are hoping that uh we will have support for there for uh gcc on others and in the short future uh for that um so uh hopefully it will work great next uh i'm going to talk about c-macon dependencies so as you know when we build a software most of the software they are not independent they are usually dependent depending on quite a few other libraries that are needed in our domain for instance for hpc simulations so high performance computing simulations there are quite a bit of libraries that are developed and for that so for instance either finance element libraries and neural nets libraries for hpc and they usually rely on on a lot of packages so like mfm relies on 31 packages mummy which is a cancer drug interaction modelling system for high performance computing they rely on almost 100 packages and a lot of dependency edges there so it's it's a little bit tricky um so the way we try to handle that with cmake is is basically with the notion of find package which has been around forever so let's say you have a library foo and you need png uh you would do a fan package png and then you would compile your library and then you would use the target link libraries foo and include png and the nice thing with cmake is that actually everything is doing well uh it will not matter if the target has been installed if the target is the package or if the target is actually sources that you are doing um cmake it should be transparent for cmake so cmec provides about 150 fine modules uh if you type cmake pass ourselves modulus you will get them but the question we have is when we add i mean actually in the uh in the past years is how do we maintain these modules so what happens is people will develop fine packages we will put them in cmake and then it will happen that these packages will not be supported so new version will be released and we would not have been able to to support this version because either the developer is moving on or we cannot keep up with it so up to like maybe five years or ten years ago i would say that we the idea was to create a full repository where people can commit these fine modules can help maintaining them um it never happened but a better solution we realize with especially with what we call modern cmake it's uh to export the targets so let's the third party application in my case in an example of the png library if it's using cmake and using the install rules of cmake actually cme can generate imported targets for another application to use my png library and because i'm the developer of that png library i know exactly what should be installed what you need to use that png library and uh and in that case i will be able to provide that and and provide all the information for cmak21 and that's what we do with the install export commands that we generate the library but also generate the targets so the definition of the target so that you may can re-import them and use them this is important and this is great and what we do is we encourage people to that are maintaining a third party libraries that are meant to be used by other applications to to use exporting targets um and uh coming back to exporting targets it's not something that is necessarily uh very easy to do depending on the complexity of your project but that's something that you can definitely uh do there are pretty good documentation online uh for how to do that a couple of other ways also to add a third party into your cmac project is to use what we call excellent projects also called superbuilds so that basically will allow you to build on importing targets at real time so this is something also that is fairly important for cmx so in in this example we point to a git repository with a github and we just add build time so when you type make it it will download and it will build that repository note that repository doesn't have to be cmek based it could be uh it could have make file it could have a different build system it would work as well i should work as well uh in three point eleven uh cement 3.11 we added uh something similar to super build which is called fetch content and this is basically you will see the signature is very similar to uh to the previous external project ad but basically it's a way to fetch the content at configure time so that they are available when you configure and it's a nice way to do that being able to deal with that so um also that cmake provides all the functionality to under project dependency with external project fetch content or they will never replace cmake with not replace packages package managers so if you have complex software you might be able to handle it and we do that for instance for pi view we handle it with super builds but especially if you use different packages different languages package managers are the solutions for that so conan for instance vc pkg spike are all good options for managing this large deeper space project so uh konam uh if some of you probably know that but it's it's based on cmake and and what they do now starting uh with a newer version they then now able to generate this configure file for cmake so that your package can actually be used by other applications using cmake spark um so spac is a package manager for super computers but it actually also allows you to um you don't have to use a super computer but being able to use it on on other platforms so that's something also that is very promising and spec claim of fame is also for some code at lawrence livermore national labs using pytorch it goes from days to configure a project to about 20 minutes so a huge improvement there um and at kitwa we also been working with the spec team uh to work us back on windows which is uh we we think it's going to be great um so a couple of things uh just to to reflect a little bit on the future what we'd like to see for cmake is uh as i was mentioning we would like to see uh travel the super space compiler provide this building interface as for the secret source module and also have a standard uh for cross-platform information for the cma quantifier so that the packages can be uh can be known by cmake as well i'm going to go next over new cmake features uh that we've developed um i mean that the community has been developing so in collaboration with microsoft we actually introduced starting in cmaj319 presets so basically it's a json file because you make reset.js and that allows you to specify uh the build directory the generator the cache variables all the information about your builds if you wanted to build on a different compiler most of the time you will have to define your environment different environments or create shell files a shell script nowadays presets allows you to do that so you can use the preset either from the user interface or from the command line with list presets and then you can use that presets with the dash dash preset command or directly from the command line by selecting your presets we added also a couple of new features and thanks for the to the qt company for supporting these developments we as you probably know qt is moving from from qmag to cmake which is great and improving cmake so we added to support speed up compilation the target pre-compilators commands available since 316. so basically allowing you to do precompilators we have also done unity builds so basically creating one source file to speed up the builds there is a documentation on these couple of options that you can set as well uh to set the size of the of the unity build and so on again available things uh cma 316 so most of you if you've been up to that we see like uh probably know that what it does we also introduced in cmac 317 um we introduced a support for new geology configuration so before if you wanted to have a configuration like debug and release on ninja you needed to have two drill trees now with the ninja multi-config you can just have multiple configurations in the same drill tree from ninja so it makes things a little bit easier for the developer to work with that um and we also added the custom command updates uh for dependency files for make files uh so that has been done a little bit more recently in 320. we've done that uh so that's almost the end of my presentation uh i just wanted to give you uh um some uh some uh tips and uh what if you want to learn more about cmake um we uh we at kitwa obviously uh do training and i know some other uh companies as well are doing training but um we uh we are also available for support as well uh but uh so uh the way if you want to learn a little bit more uh what i would uh encourage you to do is not to copy a cma code from uh from your friends unless uh it's it's recent code um when we do audit we usually uh can flag that very quickly uh but uh uh simek is a language so it's always evolving so i encourage you to uh to try to to keep up with the language and learn a little bit uh there are a lot of talks modern teammates on youtube and others platforms that are pretty well done there are books craig scott has been doing an excellent job on professional cmake we have also a discourse form that you can uh join and and you can look at the questions and ask questions and look at the answers there are documentation that is always up to date um not always perfect but always up to date and we have tutorials as well available on the website cmake.org there are technical guides that are available and so tutorial on ways to do things there are also other guides that are available out there on the web that you can find that are fairly easy to follow and uh and we are also adding uh ways to we are testing within cmake the documentation it's important for us to to make sure that what is in cmak is able to work and is always compatible with the latest version of teammate that we release so something very important and one thing also is uh this year we the bookmastering cmac is now open so you can uh download it you can download the pdf if you want to and look at it um we are still going to print a version that is going to be a little bit more lightweight if you like paper copy but otherwise it's it's available if you want to contribute you are welcome to and and again this uh cmake is a language so uh keep in mind that that is evolved and if you need more information feel free to contact me um thank you very much and i wish you a great rest of the meaning secret press conference thank you