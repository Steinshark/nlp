in this video I'm going to be showing you a quick optimization that you can use with enumerate and to get started let me just show you what we're going to be testing so when you have an enumeration usually you type in 4i and value in enumerate whatever list you want to enumerate or whatever iterable you want to enumerate so if we want to enumerate let's say A B and C we can do that with enumerate and when we print I and the value we're going to get 0 a 1B to C so it effectively enumerated the list and using enumerate returns an enumerate object and you can verify that by printing enumerate that list you'll get this enumerate object printed to the console and it's supposed to be incredibly efficient but we can also change this to a list so you can create a list from that enumeration and you'll get a list of tuples back so that's what enumerate looks like when you actually print it out bear but there's a small detail when using enumerate that you can use to make it faster and that is defining a start so if you wanted to start at one instead of add 0 you can define a start which will group the first element with one and so on I've seen a lot of people on the internet argue that this is actually quite confusing to read so a lot of people prefer to do I plus one instead of providing a style but the only issue I have with this is that each time you Loop through the list you need to perform this minor calculation so does this minor calculation really make a difference well I've prepared a quick test to find out just that so here we have the enumerate function that takes a list of values and it returns to us a list so we create a temporary list and inside here all we're doing is enumerating this list of values and starting it at 1 and then to perform some calculation we're appending to the temporary list so we can return that temporary list and the normal function does exactly the same thing except it does not provide a start it just calculates I plus 1 for each iteration and then appends it to the temporary list so they both do the exact same thing with the exception of start and I plus one so to time them I'm going to import from time it the time it function then I'm going to create the if name is equal to Main Check and I'm going to create a list of 50 numbers to time the normal implementation without the start I created a variable called normal time and then I timed that function with the 50 numbers in it so we have 50 elements that we're going to Loop through and append to a new list using enumerate and I'm performing this test 1 million times then I'm doing the exact same thing for the enumerate start time so as you can see here we actually have the start is equal to one as we've defined up here and just to make sure that we're giving the same result in each one of these functions I created a simple print statement that says output is the same and it checks that the normal function is equal to the enumerate function because we don't want to get back different results which creates an inaccurate test but if we run this and wait a couple of seconds you'll see that stat equals 1 was slightly faster about two tenths of a second faster than I plus one and no matter how many times I run this test that will always be the case and in Python 3.11 this is a much smaller difference than in Python 3.10 now I'm running this in Python 3.10 and you'll see immediately that we even save more time there so it's quite a minor optimization which can possibly save you a lot of time in your scripts but you need to judge that for yourself whether it's worth to save two tenths of a second or more depending on the operations you are Computing and as always I recommend you test these optimizations in your own scripts before jumping to any conclusions but that's actually all I wanted to share in today's video do let me know in the comment section down below if I missed something of this something that I should have added but as always with all that being said thanks for watching and I'll see you in the next video