so welcome everyone I'm Milian from kdub we have quite a few open source tools um I'm mostly interested in uh two of them Heap track and hotspot is uh what I've been doing those uh profilers for Linux one keep track is a memory profiler so Heap memory profiler and another one is hotspot which is what I'm going to talk about later is a UI for the Linux path subsystem and we also have tools like crazy which is a llvm based study code analyzer for especially for cute so it helps you for example to pour your code from Q5 to q6 and finds little paper cuts that slow down your application and whatnot and yet another pretty popular tool of ours that is also open source like the others is gamma ray um a cute visual debugger and introspection tool all of these tools are pretty interesting I would say and I could easily fill 10 minutes each but today we'll talk just about hotspot and um the thing here is um this is mostly interesting for uh Linux people but I guess or hope that there are quite a few of those in the audience and um historically and if you look at how you do profiling on Linux then sooner or later you will stumble over the Linux path subsystem so the perf record and perf report commands and those are pretty damn hard to use on the command line just to give you a quick example I hope you can roughly read what I have here [Music] um if I go to some application that I want to profile then I used to be uh I used to have to do something like half recall and then I have to remember that I actually want to do dwarf unwinding and then maybe I want to enable um the Z standard compression and then I want to run my application and um then it did something and if I report it then all I get is this fancy or not so fancy um standard console UI that is in my opinion uh not good enough so um I set out a few years ago to write hotspot which is essentially the same thing that I just showed you on the command line using the ready-made perf tools but in a UI package built around Q5 and KD Frameworks and the notable features really are is that it's much much easier to use and it tries to give you some context sensitive information which is what I'm going to show you next and a few other things that I will not show today like actually being able to very easily access the profiling data that you recorded on an embedded Target so let's say an ARM device Raspberry Pi you name it and then you copy the perf data file over to your development machine maybe different architecture there and then you just connect to this is root and the debug symbols there and analyze everything and that just works so um let's talk about some some demo time so as I showed you before I actually recorded some data and instead of just saying perf report like I did before I can just use hotspot as a drop-in replacement for path report it will look for the perv.data file in the same directory and then it will actually look at what is needed to analyze the data and now it's done uh you get a little overview page um hopefully looks like that you might have seen a little progress about earlier and that actually was me downloading debug information through debug info d uh which is pretty epic nowadays and then um the first thing that you really should look at uh is either the overview or what id do is the flame graph so if you haven't seen a flame graph yet please please educate yourself on this great Innovation by Brandon Gregg it is essentially A visual representation of this tabular data that you probably know from any profiling tool and it literally just divides the full width in fractions so if you can read a thing here in this Tower City landscape then it means it has a fractional large contribution to the overall cost half as a sampling profiler so that translates very nicely so 66.8 percent which you can see in the bottom corner is in this raw motherboard file pretty uh clear and now I can easily say I actually uh want to colorize it by some demo by the binary or whether it's in kernel space or user space so we can see here a few Red Towers that are kerners-based but the rest is all user space here and um I can see what is uh system and what is user space and um these are just different ways to slice and dice the data eventually um you will essentially go from top to bottom look for a white thing that you have under your control and in this case it's this draw motherboard one and as you can see at the bottom in this timeline view all the threads that we recorded and the CPUs and when you hover something you actually get to see when a sample was recorded that contained this frame on the stack as well and okay now let's assume I found something here right drum Underwood how do I figure out where in the code that is um you can right click view color Koli and then it's yet again a different way to look at the same data and here on the right hand side you would have a list of all the lines of code that actually got recorded you can sort by inclusive cycling cost and then you would see okay Monday boardline dot cpp.cpp line 40 is apparently costly and I can double click it and open it in an editor of my choice and I would see here is something that is apparently slow a different way to look at the same data is if you go to right click and then disassembly and this is essentially kind of like good bold but integrated and for profiling data so we also disassemble the data just like God bold does and then try to do this um what's it called basic building block colorization and then you will see the same line here that I just opened in the editor with the high inclusive cost and I can also look in the Raw this assembly code and find the equivalent costs there as needed if you need this kind of low level data it's all there now which is pretty cool and there are some more improvements coming along in this area so I would say for the 90 use case this is all of what I'm doing um in my daily job as a software developer when I need to do profiling of C plus code hotspot is Trivial to work it's super fast and I just do this a lot now one thing though that um I mean many tools can do something like that pretty easily right but one thing that is uh pretty nice is um I can also record data so I don't even have to remember these Arcane um command line uh tools and I can enable um more advanced path features for example the off CPU profiling which is pretty nifty so um let's start recording and I get here a example application and now if I try to resize this window it's really really slow right and well yeah I deliberately wrote very slow code here let's close the application and um if you are interested in what a command was run you could even just copy and paste this out and put it in a shell script or whatever there's no magic going on here really now we can view the results and again some debug info D that should be pretty quick because most is already cached at least I hope so uh Famous Last Words yeah okay so now and this is done and the summary in this case is actually pretty interesting because uh we see that for some reason this application starts 210 threads which is pretty stupid on a um laptop like mine which only has eight cores um similarly on average just 0.4 cores are running so not a lot is happening and down here in the timeline you can also see that really uh being the case right um let's jump over to the flame graph and make that more um clear so first of all we have this list of CPUs and um there is stuff going on but not a lot and then down here I see apparently some threads get created and then they get killed and then more threads are created and then they're killed and more and more and more and so forth this is very very bad code um similarly let's try to figure out where the code is actually sleeping so let's see as I said in the summary page it says on average uh most of the threads are just sitting around idly not doing anything and because I did this off CPU profile profiling I can now select the different cost source for the flame graph so by default it shows me the on CPU cycling cost sampling based but now I can switch to off CPU tracing costs through the scheduler Trace points and then the flame graph looks totally different and this is actually a sleep time cost now and when you look at this large screen is useful um but let's have a look at what happens when I hover the timeline I actually see the towers at the top I'm getting highlighted as well and for example here this thread is the so-called dbos thread it's um I can actually ignore that let's say exclude This Thread I'm not interested in that similar here is a um event thread which is really just this little part of the flame graph here in the middle so again let's say I'm not interested in that I'm going to exclude that thread as well and then what else do we have we have the main thread sometimes not doing anything because I simply um didn't interact with the window that you uh saw so if I zoom in here I can also say let's exclude this whole stack whenever this Frame is in encountered and bit by bit I can clean up my um flame graph that way until I eventually find the needle in the haystack which is in this case this left big chunk where a function that I have under my control apparently tries to lock a mutex and again I can just go to view caller colleague and sort by the off CPU time and find so here again it's on the right hand side and when I saw it by the of CPU time I go to manualbroad.cpp line 124 and indeed I double click and I instantly see the lock that is being um held here which is obviously pretty uh badly placed so let's quickly optimize this I just reduced the size of the critical section and then I will recompile give me a second and then I'll just quickly rerun that to show you the advantage here so um I just re-record and I resize I close I view the results I wait for the cache to be filled and now things look much better than before um there's actually some threads being used in parallel on average not much because I'm actually still um not interacting with the main window all the time but when something is happening so for example in this area here let's filter in on that then you can see all threads are more or less busy doing something and um the flame graph looks nice I can again look into um what is now on CPU what is off CPU just like before and then further look into my application try to come up with additional ways to speed it up so yeah if you have any more questions around hotspot Heap track gamma ray crazy any of the other tools come by visit us at the virtual table and thanks for listening thank you for the demo all right thanks sumilian from Caleb