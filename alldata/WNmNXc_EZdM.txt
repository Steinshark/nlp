today we're talking about a high impact security vulnerability that affects rust Python and many other programming languages on Windows the vulnerability we're going to be talking about is this recent cve 2024 24576 and this is a 10 out of 10 critical vulnerability this is the absolute worst rating that a security vulnerability can get taking a look at how the Russ team is responding to this they of course put out a advisory and have patched it in the way that they see fit and the way they describe it it sounds really bad it sounds like a 10 out of 10 vulnerability in short when you're invoking a batch file on Windows using their command API they say that they don't properly escape the arguments when invoking that batch file if exploited that means an attacker would be able to execute arbitrary shell commands as the current user the approach to mitigation that they took is a perfectly reasonable one they basically updated their API to error if it looks like you're giving an input it looks like it could be exploited thankfully someone has already gone out and checked the status of other programming languages and noted whether or not they're affected and here's where we start to see something a little bit fishy we have nine affected programming languages here and note that although Java is the only one noted as saying they won't fix it in total four of the other ones just say they'll have a documentation update which basically means they are also not fixing it they're just documenting it somehow that's kind of a weird take for five independent programming languages to have on a 10 out of 10 critical security vulnerability don't you think and no it's not just because these languages don't care about Windows they care let's dive into the code and see how this vulnerability might not be the five alarm fire that it was made out to be it's only an issue if number one you're running on Windows number two your program is accepting untrusted inputs and number three your program is passing those untrusted inputs to a subprocess that's trying to call a batch file that means you have to be running a bat or CMD or a file without an extension because that could also resolve to a batch file here I have a batch file that's just supposed to Echo out its arguments line by line yes chat GPT can write batch files although looking at this program really makes you wonder who is still writing batch files anyway the normal way that this is supposed to work is if I have a normal input and I run the file then we can see that it just Echoes out whatever the input was but if I give it a specially crafted evil input and run it again we see that it actually pops up my calculator so instead of printing out the argument Ampersand calc.exe like it did in the previous example it ran the executable calc.exe the surface level reason this is happening is because Amper sand is the special command line character to say do this command and then do this next command but this is such a simple example how could this possibly have not been known in the past well spoiler alert this has been known for a long time and while there's no question that this is confusing Behavior according to the windows documentation this is a feature not a bug normally when I use subprocess to call an executable in this case another instance of python the arguments in the list are passed as arguments to executable the executable can do whatever it wants with these arguments in this case interpret this string as a Python program to run and then pass the rest of the arguments to that Python program the Amper sand and Echo have no special meaning unless they happen to mean something to the python executable like the DC did the- C is a command line argument that it knows oh hey the next thing is the command I'm supposed to run however most programming languages offer you a kind of convenience escape hatch that allows you to run the command in a shell as opposed to running the python executable directly in Python you do that by specifying shell equals true because the actual command being run is a shell special characters like the Amper sand are now interpreted by the shell instead of passed to the python executable so the shell will read this as run Python and run Echo when we run it we see that that means python does not receive the Ampersand Echo LOL instead python runs and then Echo LOL runs because of the dangers of potentially providing a malicious user access to a shell programming languages do a pretty good job at warning users to never ever ever pass untrusted input with shell equals true so I think if your average programmer sees code like this where you're taking untrusted inputs and then directly passing that into a subprocess run with shell equals true I think we intuitively understand that this is just Dangerous by default we shouldn't be doing this and indeed if I run this with the ampersand cal. exe we see that it does a little speed test of nothing and then opens the calculator but with shell equals false which is also the default so if I just didn't specify anything then when we run it we'll see that it actually speed tests invalid syntax so we get an error as opposed to um getting hacked and now we come full circle back to the cve to understand why people are upset about this of course if we have shell equals true and we pass untrusted inputs then we should expect a security vulnerability the calc.exe got executed but that is not what the CV is about the cve is about what happens when shell equals false even with shell equals false when we run this program the calculator still pops up well that really seems like a bug in the programming language right why did it interpret it as if it was in a shell anyway and this is the point where people start pointing fingers mostly at the programming languages because they're the ones that wrote The Run function right why is this a mistake that nine different programming languages made well it's because again this is technically a feature not a bug here's the section of code from the cpython source code in the subprocess library that actually is used to create a process on windows so it's basically just calling out to this Windows API create process function let's take a look at that and here's the implementation of that if we scroll down what does it actually do ultimately it just calls this built-in create process W function which is actually part of the windows API so this has got to be the place where it happens right whatever we're passing in here has to be wrong so where did that come from well of course it came back from uh this call here which means where did these args come from these are the args that we're passing to the create process function if we scroll up just a little bit we can see that it's not that python forgot to escape something here is the where it actually does the escaping you might think well I guess they just must have made a mistake in this list to command line function but looking at the documentation and looking at the implementation they're following Microsoft's exact instructions and they follow them correctly Python and probably all the other languages too didn't make a simple mistake parsing command line arguments if anything the real issue has more to do with the semantics of how Windows runs batch files in the first place taking a look at the example again what does it mean to run a batch file a batch file is not an executable how can I run it well when you ask Windows to run a batch file it says oh that's not executable but I know how to run one of those I'll run it in a shell so even if you said shell equals false from Python's end it still runs the command in a shell because that's just what it means to run a batch file on Windows means to run it in a shell but now if we look at it this way where we're explicitly passing untrusted input into a shell it no longer feels like a cve it feels like I should have validated my inputs the confusion comes from the fact that the escaping that python does is escaping for Windows not escaping specifically for the command prompt just like python has its own Escape sequences like back sln for a new line the command prompt has its own Escape sequences and just like subprocess do run doesn't try to escape or quote your back sln when you run python.exe it also doesn't try to escape your command prompt specific Escape sequences when you run those it's just extra confusing because you might not realize that you're asking to run a command prompt when you run a batch file while you could take the rust approach and try to automatically Escape arguments to batch files a realistic compromise is for Microsoft to publish documentation on how to properly Escape arguments to command prompt and then to have languages Implement and provide some kind of batch Escape function additionally a lot of the confusion stems around the signature of this create process W function that Python and all the other programming languages have to call on Windows this create process W function is pretty much the only way to create new processes on Windows it would be a lot nicer if there was a version of this function that took an array of strings which is what programs are expecting so that there wouldn't be any confusion around around the escaping that we have to do just to pass to this function versus the escaping that we have to do in order to escape arguments that the command prompt is expecting if you look at the equivalent code for Linux you see that it actually uses this exec V family of functions the exact V family of functions takes an array instead of a single string and this cve isn't an issue on Linux