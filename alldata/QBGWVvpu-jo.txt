hello everyone welcome to episode 9 so today what we're going to be doing is getting these mesh chunks off in the distance to be drawn with a lower resolution and those closer to the viewer so as we move our viewer around we want these to sort of dynamically change their resolution based on the distance from the viewer so let's head over to the endless terrain script and riskily come down to the bottom of the scripture and creating a new class called something like level of detail mesh so each terrain trunk is going to have an array of these level of detail meshes and what this class is responsible for is just for fetching its own mesh from the map generator so we're going to want to have a public mesh object in here just call that mesh and then we can also have a public pool to keep track of whether or not we've requested the mesh yet so has requested mesh and finally we want to know if we've received the mesh yet so public pool just has mesh not finally in fact the other thing that we still want is an integer for the level of detail of this a current mesh so then we can have a constructor public level of detail mesh this can just take in the level of detail that we want so we can say this dot level of detail referring to the one defined in this class is equal to that parameter and all right and then we can have a public void so that we can tell the class that it needs to request its mesh since we're only interview requesting the specific level of detail mesh when it's actually required so let's call this request mesh taken map data and we can start off by saying we have now requested our mesh so it said that it true and then we can say map generator dot request mesh data we're going to pass in the map Josh we've been given and then we need to pass in a callback as well so let's just make a another method over here called on mesh data received taking in some mesh data and we can just pass that new method in as I'll call back okay so once we receive the mesh - so we're going to want to set our mesh object equal to mesh data dot create mesh and we can now say that has mesh is true now obviously we want to pass the level of detail into the request mesh data method so that it knows what level of detail we want so let's just change things around in the map generator at the moment we've got this level of detail variable up here but that's only being used for when we're drawing the map in the editor in fact I'm going to need to change its name just to reflect that so I'll call this maybe editor preview level of detail something like that just so we don't get confused now when we add a a integer called level of detail to our request mesh data method and we're gonna want to add that in the mesh data thread as well and just pass it in when we create this delegate so add level of detail in there and then instead of using the editor preview level of detail we'll pass in the level of detail that we've been given all right so we should be able to save that now and come back here and pass in level of detail okay so I'm going to now want to have a public struct called level of detail info and what this is going to define is first of all the level of detail that should be an integer and for that level of detail we'll want to know a float for the sort of distance with width in which that level of detail is active so I'll call this the visible distance threshold so essentially once the viewer is sort of outside of that visible distance threshold then it will switch over to the next level of detail a sort of lower resolution version and we're going to want this to show up in the inspector so I'm just going to add system dot serializable and we can now create a public array of these level of detail infos call us my detail levels let's just save and quickly set this up on the map generator got a error here what is this about okay so in the last episode of course we generated the mesh inside of the terrain trunk class just so that we could test that everything was working so we can basically just delete all of that now so save and everything is working so let's go into our detail levels I'll just make three of them for now and I don't notice that these two one two and three we can fill with that later 200 400 and 600 so then let me just delete this line as well actually the max view distance is no longer necessarily 450 in fact it's whatever value is last in the detail levels array so let's change that to a static variable so that we can change its value at runtime miss guru put it under the detail levels and then we can say the max view distance is now equal to detail levels we want the last element so detail levels length minus 1 and say dot physical distance threshold so now we want to pass the level of detail info array to our terrain chunks so let's just add this somewhere in the constructor level of detail info array detail levels and I'm also just going to copy that over here and then at the start of the construction we can just say this dot detail levels is equal to the detail levels we've been given and we want to pass that in when we create a new terrain chunk object of course so pass in detail levels all right so next we want to create an array for our level of detail meshes and then we're going to want to create a new array with that so level of detail meshes is equal to a new level detail mesh array with a size that matches the number of detail levels we've been given so just detail levels lengths and then we're going to want to loop through all of those so for into I equals 0 I less than detail levels length I plus plus we're going to want to create a new level of detail mesh so level of detail meshes I is equal to a new level of detail mesh and want to pass in the level of detail so that will be detail levels I dot of detail okay so next when we receive the map data we're going to want to store it so let's create a map data variable I'll just call that map data and just for convenience it'll boo map data received so on map data received we can say this dot map data is equal to the receive map data and our boo map data received is equal to true all right so then when we're updating the terrain chunk we're going to want to look at the distance of the viewer from the nearest edge and compare that with the distance threshold of each of the detail levels to determine which one we should be displaying so let's say if visible then we can Croatian into level of detail index starts at zero and we little for loop for into I equals zero I less than the detail levels dot length minus one I'll explain why we don't have to look at the last one in a moment and then say i plus plus if the viewer distance from the nearest edge is greater than detail levels i dot visible distance threshold that means that our level of detail index should be the next one on so level of detail index is equal to I plus one otherwise if it's not greater than it then this is the correct level of detail index and we can break out of the loop so the reason we don't have to look at the last one is because that will be the case where this visible bool is actually false as the viewer distance from nearest edge will be greater than the maximum view distance all right so we now have the level of detail index that we should be displaying but we'd like to keep track of what the previous level of detail index was so that we don't have to worry about updating anything if it's just remained the same so somewhere up at the top here let's create an inch previous level of detail index and I'm just going to set that equal to negative one to start with just so that it's impossible for this to be equal to that the first time round so it has to update and then we'll say if the level of detail index is not equal to the previous level of detail index then the level of detail mesh that we want to be working with is the one from our level detail meshes array with an index of the current level of detail index okay so if that level of detail mesh has a mesh then we want to set our current mesh so mesh filter dot mesh to the level of detail mesh okay otherwise if the level of detail mesh has not yet requested a mesh so should add a not here if it hasn't yet requested a mesh if it has of course it's fine we'll just wait for it to receive the mesh and it will set it but if it hasn't requested a mesh then reintroduce a level of detail mesh Gorge request mesh and pass in the map data alright and then only for a successful in setting the mesh will we say that the previous level of detail index is equal to the current level of detail index now obviously all of this is only worth anything if we've actually received the map data so if we haven't we don't need to bother with it so I'm just going to enclose this all in one giant if statement if map data received then do the stuff ok let's save and give us a quick try the first level of detail should actually be level 0 of just relized so let's enter play mode and that looks good you can see these are slightly lower resolution you'll see this better if we change our shading mode to shaded wireframe that makes it clearer like these around the edges to be even lower resolutions we just increase the level of detail it feels a little bit weird increasing the level of detail to get a lower detail mesh but it appears to be the convention in unity over this way around anyway that's looking pretty good so one thing I'd still like to do is to not have all of the chunks updating every frame what we could have is some sort of threshold distance that the viewer has to move before we bother updating them so I might create a PR a contest float called sonic descriptor of like viewer move threshold for chunk update quite a long variable name but I think it gets the point across set that to something like 25 and then I'm just going to copy this create a other constant flow called square viewer move threshold for chunk update and set that equal to this one squared just doing this because as most of you probably aware always getting the square distance of something is quicker than getting the actual distance because then you don't have to use the square root operation so if we keep track of the viewer position old we can then say if the viewer position old minus the current viewer position dot square magnitude the square distance between the two in other words if that is greater than the square move threshold for chunk update only then will we update the visible chunks and also first want to set the viewer position old equal to the current viewer position and then since this might not evaluate to true at the start of the game we'll just want to make sure that we update the visible chunks in the start method so that those first ones do get wrong this also gives us another problem if we just save this and press play so you can see that since the terrain chunks are no longer being updated every frame we're going to have to manually call update when we receive the map data and also and receive the mesh data so what we're going to want to have in the level of detail mesh class is a call back to the update of the terrain chunk so let's say system dot action call this the object call back and then in the constructor we'll take one of these in as well system dot action update call back set this dot call back equal to the call back we've been given and then when we receive the mesh data we'll say call the update call back okay so now when we when we're creating all of these level of detail meshes in the constructor of our terrain chunk we're just going to want to also pass in along with the level of detail our update to rain chunk message and then we're also going to want to automatically call the update to rain chunk when we receive the map data okay so now if we go into unity and press play everything should be working as normal but now the performance will be a little bit better because we're not updating every frame great so let's just quickly get textures working on that so we can say where's the this method that I was just in here we can say texture 2d texture is equal to texture generator texture from color map pass in the map data color map and then we can get the width in the height from the map generator this will both just be the chunk size and then we just say mesh renderer material dot min texture is equal to the texture let's try that out press play and I'll just go into shaded mode so we can see we're getting the texture nicely it's just as before the same thing repeated over and over so let's very quickly fix that by going to the map generator and making the the request map data take in a vector to center and we want to pass that in here as well vector to center pass it in through the delegate so that should be of actually two up there and then when it generates the map data it will pass in that center variable so generate map data will take in vector to center and over here when we're creating the noise map will just say crater 2 at center plus offset so now over here in the draw map in editor we're going to have to fix this as well we can just pass in vector 2.0 by default okay so save left to go back to the under store in and when we're requesting our map data we'll just pass in the position of this chunk all right so that should a little bit less repetitive now this is still not lining up perfectly we'll worry about that in the next episode until then Cheers