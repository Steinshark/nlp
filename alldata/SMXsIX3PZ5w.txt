Hi, James Murphy here. Back with another new feature in Python 3.9 Today, we're going to be talking about type hinting. So, let's just get to it. In previous versions of Python, if you wanted to type hint, say, a list,  well, you could do it like this. You could say x is a capital list of, let's just say, integers. Now, capital list we're going to have to import from the typing module. And that's because, the built-in list didn't previously allow parameterization like this. I couldn't say a lowercase list of int. That would just be a syntax error. But in Python 3.9, that's exactly what they've introduced. So, this syntax here is now deprecated. And instead, you should be using just the regular old list. And it looks like that. You can also actually use the list on the other side and it's the same thing. So, I could say x is list int and then instantiate it that way. Note however, that list int is actually what's called a generic alias. So, the type of x, if I run this program here. Well, let's actually print it. Even if I instantiated it this way, the type of x is still just list. However, list of int is not just list. So, if I actually look at the type list of int and compare that to list, this is actually going to be false. Let's just run that. You can see that those two are different types. Where, of course, if I compare it to itself, then it is true. It's not just that it's not comparable. So, let's just put that back. So, it's false again. And we can actually get that int parameter at runtime if we want it. So, you can actually see it. Because if I just print out the type itself, not the variable x, but this generic alias type, you can see that it does show up as list of int. So, that means that that information is there stored somewhere at runtime. And it's actually stored in this origin parameter. So, if I have my type t to be list of int, then the double under origin variable which is highlighted because my text editor doesn't know about it yet. Because Python 3.9 is still new. That variable will point back to the base class, kind of. It's not really the base class. List of int doesn't inherit from list. But it points to just the list part of it and... the args parameter. Let's just put that up here. The args parameter will give you a list of things back that you put into here. Now with list, there's just one thing. So, it's a little bit weird. This notation here actually means this is a tuple with one thing in it which is the type int. Which is exactly what we put in here. But if you have something like a dictionary and I type hinted it with Now, I can use lowercase dict of str and int, let's say. Well, this type dict of str and int I can now get back that str and int as a tuple using the args method. The args attribute, excuse me. So, we can see that when we run it. Now, the last line there shows the str and int classes. This also works if you have parameterized types. So, if I have a type variable T, which I will have to import from typing. And just so you know how it prints. You can see that it comes up with this tilde T. So, that's a type that I have now created as a generic placeholder for a type. If I make my little type t be dict of str to T and then print t out, you'll see that that type variable T is in there. And I can access it at runtime using the dunder parameters attribute. So, we can see that as follows. And that's going to give me back just a list of the type variables. So, notice str is not in there. Finally, let's look at some things that we can or can't do with this new generic alias. So, one of the things you might want to do is a runtime check of the type. So, you might think: Is it possible to check isinstance? So, is some list an instance of list event? And you can see that there are red squiggles here. So, my editor is correct that there's an error but it's not correct about what the error is. The actual error here is that you can't use in isinstance with a parameterized generic type. So, if you want to check to see if something is an instance of list of int, meaning, check to see if all of its elements are integers, then you just have to check all of its elements individually. So, this mechanism is actually a thin proxy layer on top of the existing list type. All it does is redirect all of the calls and method accesses and everything to the underlying list type. And that's why, except for origin args, parameters and of course, the square brackets getitem. But that's all. Everything else is forward directly to list. And if you scroll back up with me to this line 8, that's actually why this line works, and why the type of x is just list. Because it's just proxying that method call, the constructor, to the underlying list type. So, let's go ahead and comment out this line because we now know that that's not allowed. You also can't check to see if something is a subclass this way. So, if I wanted to check, if... the class list, say, is a subclass of list of int, you might think that that would be true. But in fact, it's not for the same reasons as the previous example. So, if we print this, this is again a type error and you see that they say that the second argument can't be a parameterized generic. So basically, you're not allowed to check if something is a subclass of or an instance of one of these generic aliases. But one thing you can do is, you can check to see if a type is a generic alias just by using is instance with generic alias. So, we can check isinstance. We can check to see if list of int is a generic alias. And we're going to have to import this from types. You can see with this that indeed that's true. So, that's all that I really wanted to show about the new generic aliases which allow type hinting of generics and standard collections. So, if you like this video, then don't forget to like, comment and subscribe if you want to see more. I'm planning on continuing to make videos showcasing some of the new features that have been added in Python 3.9 And if you are someone who is looking to learn Python, go ahead and look in the description. I've got a form there where you can drop me your contact info. I'm going to start offering live online courses, full-fledged nine-week courses, starting from scratch where you can learn Python with me.