okay yeah i like to show you something which i discovered or not really discovered but made two years ago at my former employer and that is compile time checking your user-defined literals if you're using user-defined literacy i recommend that by the way try to compile time check them and i will demonstrate that here why this is important for example oh by the way if you want to look at this afterwards here's the godbolt link where you can find this and you can play around with that uh at my former employer benox there we are we did a lot of stuff with networking and so we had our own type for ipv4 addresses here's a simplified version of it it's just a simple wrapper around a uint 32 bit integer and it's of course it has these four components for an ip address and what we like to have especially in unit tests is very often that we wanted to write something like that instead of writing ip address type and then somehow knowing what the hex code is for that or so that that we get the so we wanted to have some constants and user defined literals is great for that so we would define our own type here ipv4 it's called and you can write something like that and that is perfect and you can also print it like that and it compiles and everything is fine we thought at the beginning we by the way implemented this um the the function signature of such a such a user-defined literal looks like that and we implemented that by parsing this string using i think i o stream uh etc and so everything was done at runtime it was fine especially at the time when we implemented the original version which was i think around 2013 or so and but we realized that we got some problems especially for example if you are having something like that here you are writing an ip address type which is not valid you might know 255 is the highest number you can have for one of these four blocks here these groups and this one indeed is not a valid ip address and so uh yeah you might have other versions here for example you are missing one of the the numbers or the entire group or you're writing an additional group there or you are uh doing some knowledge like an empty string literal there or even if you wanted to do something like that uh adding some extra zeros this should be fine but we didn't like that and as you noticed the compiler is compiling this happily but if you try to execute this code you then realize oh this is not valid only the first thing here is valid here the output but the other ones throw exceptions from the implementation and that was not nice because we wanted to do that at compile time that would be would have been better and luckily later with const extra simplification for const expert we were able to do that and it's even better with c plus plus 20 with constival so now i implemented it differently that i use here some parser function which is entirely const expert or in c plus plus 20 const eval and uh if i encounter something which is not valid then i throw these yeah exceptions here it's just a string literal so that can use during compile time or by the way throwing in from a const expression is not valid so uh this cannot be evaluated during c in c plus 17 during uh compile time so that's why we're getting this here at runtime but um for c plus plus 20 when we use that you see oh it's not even compiling and why is that because it evaluates this at runtime and so i get here some nice uh output saying what did i do wrong okay here for this one version i threw uh i threw because this is uh not not a valid ip address because i'm uh have an invalid number in the group the invalid number i had uh where is it here 256. the next one saying oh it's a missing number here that's what we have here and here there's not even uh entire group for the number missing so the dot here we have some additional tokens at the end and for all these things i get these error messages now at run at compile time and that's what i really want because although most of these things where would have been used in unit tests we don't want to have the unit test failing just because we wrote it wrong and we want to capture these errors early so i recommend do that try to to check your your string literals during compile time and if you're interested how this is done here how i did this you can look through the implementation as i said the link is here just one note you can even get this to check during compile time for c plus plus 17 if you are calling this from an um const expression context and this is for example a static assert and then you realize um that here it's uh complaining because this here says it's not a uh not a constant expression anymore why is that because i threw something from a const exp function but in the next error message it tells me what i threw and why and what the error is so even if you don't are not able to use c plus plus 20 and a const well capable compiler you can luckily also get this if you call this from a static assert for example but still it's nicer if you use c plus plus 20 because then you just get the important stuff there and that's all i wanted to say so test your string literals and compile time and if you haven't used any maybe you should they are pretty cool thank you