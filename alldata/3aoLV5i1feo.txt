I was gonna tell you a little bit about uh something called Model driven engineering which is a subfield in software engineering uh so it's about developing software about uh an interesting new way different way of developing software so let me perhaps say a little bit about this idea of abstraction for us because that's been around in computer science for ages computers really only know zeros and wants that doesn't really work for humans right so thinking through a problem in zeros and ones is really really difficult so what have we done well we started building a language on top of that right originally there's a language where he said well there's certain commands that the computer can do these commands we can encode as a number that means we can encode them using zeros and once so sequence of those numbers becomes a program we kind of went okay well that's a little difficult still right I still have to think of these numbers so we started using something called assembly which is a slightly higher level language it's essentially taking those number codes unassigning a word to each one so we now write rather than writing seven we write at that's still complicated because you've got to write out every single little step and everything in there and So eventually people started developing what they called higher level programming languages things like Fortran C plus plus Java these kinds of languages and what they do is they give us a language that much more readable and much more writable much more understandable to a well-trained human being there's still a problem with that okay which is you've got to be a technically trained person to use these languages because what these languages are doing is they're allowing you to express a problem and a solution to the problem that you have in terms of a computer so you've got to say computer do this computer do that now do this but actually the problem that you had was I want to manage bank accounts I want to manage mortgages I want to simulate cell biology I you know problems that the computer doesn't have a clue about basically so in the programmer's head there needs to happen a lot of translation from these domain specific Concepts into something that explains them to the computer and all of that translation gets lost maybe let me try and show that to you a little bit in in in a simple example what I have here is a simple development environment as many software developers will uh will use in this day-to-day work and I've written a simple program in Java that allows me to play Minesweeper games now depending on your age you may or may not know what Minesweeper is so I've brought it up here as an example it was this sort of game I think it was came with with pretty much all the old computers and where you've got this sort of rectangular grid here and each element on the grid potentially hides a mine and your goal is to find all the mines without stepping on one and exploding them and so the way you do this is you click on one of these cells and it then tells you whether there was a mine there or not and if there wasn't a mind then all is fine and as in this example here you might see a little number that tells you how many minds are in any adjacent cells now in this case that doesn't help me much because it tells me there's one mind but but you know not a lot else so let me click somewhere else to get a get a bit of a start on this and you see oh this was better I've clicked on an empty uh cell here where there's no minus got lucky um but I got so lucky that I actually found that there's lots of empty cells everywhere around and it'll automatically open all of those up and how I can go and I can work out with these numbers where the minds are now the goal of this video isn't to explain Minesweeper to you so I'm going to kind of stop at this point as much as I love playing Minesweeper and I'm going to look a little bit at the code right so let me close this Minesweeper application here let's have a look at the code so here you can see on the left of the screen you can see all the various pieces all the various files that I've built to build this this program now my super is by no stretch of the imagination a complicated piece of software it's still a fairly simple full piece of software but you can still see you know as I developed this I sort of had to write quite a number of files okay and if I look into some of these files this is one of the classes it happens to be the one where everything starts and you can see there's a lot of code going on now a key question you might wonder about with Minesweeper is what are the rules of Minesweeper and how do I change them right if I want to build a slightly different version of Minesweeper or slightly different rules how do I do this right because that's in the end what you care about as a game developer you care about the rules of the game you don't necessarily care so much about how to explain to Windows or Linux or Mac OS or Android how to get the thing on the screen you in the first instance you're interested in designing the rules of the game and you want to be able to see them and you want to be able to change them the problem with this code of course is we've got nine classes or so here and the rules could be anywhere in there okay in fact there's all kinds all kind of stuff in this code right so this code here that we see here it's got stuff about the menu it's got stuff about initializing Fields but then in there if I look at this again it creates tables and it creates listeners to Mouse events so again that's about user interaction and not so much about the rules so all kinds of things are intermixed right and it's really difficult to find what the rules of the game are okay in an mde approach what we would take is we would take a step back from this and we'd say actually let's not worry about all of these details let's obstruct away from them just like Java abstracts away from the machine code let's abstract away from that and build ourselves a modeling language and then write a model that captures only the information that we care about okay so let's look here at a different way of representing Minesweeper in this file here so this is a little modeling language I built and a little model in that modeling language I built to describe Minesweeper and in fact it turns out that from this model I can generate automatically all the Java code that's needed for for running Minesweeper okay and what this does is it has these these field commands here which allow me to Define What fields there are what rectangular Fields let's open up one of those so the easy field here it basically says well it's 10 cells wide is 10 cells high and then it's initialized using this fill field thing which is defined down here and it has takes one parameter which is the number of Mines that we want to set up in our in in our field and we're setting this to 10. so in an easy field we have it's 10 wide is 10 high and it has contains 10 mines okay now the other fields are set up with different sizes Etc let's have a look at briefly at what this feel field thing looks like well it sort of says okay I'm going to use various strategies for initializing the field I'm going to start by randomly initializing this many elements cells in that list field with mines then I'm going to use this context rule to say I'm going to put ordering mind cells anywhere where there is already a mine cell somewhere and they they're going to sit around that and the bordering mind sells are the ones that show these little numbers when you discover them and then everything else gets filled with empty cells okay and that's the basic things that you need to know about setting up the Mind sweeper field right so you don't need to know more you don't need to care about how this setting up of these cells actually happens or anything like that you just want to say that's the rules Okay so we've mentioned these different types of cells so obviously we need to Define them and that's what the cell command is for right so we can define an empty cell we can define a bordering mind cell and we can define a regular mind cell basically all set up using these mind States thing here because the key idea in this modeling language is to say well actually each of these little cells that we have here has a little State machine attached to it okay so it can be in one of a number of states and depending on what the user does with the cell and depending on maybe what else happens it might change its state okay and so it's useful to just basically be able to do the rules of the game I guess are what states there are and what the transitions between those data and so we Define what this date machine is here using this mind stage thing here and you can see that pretty much this the state machine is the same for empty cells mind cells bordering mind cells because essentially they react to user input in the same way they go from this undiscovered State this hidden state so a discovered State and maybe you can add a flag state if you wanted to um the only difference is that they might be showing slightly different things on one they are discovered and there might be a different thing that happens right when you click on the mine things will explode when you click not don't click on a mine nothing will happen other than discovering the cell and then we say okay well what are the states well it starts with this hidden State and what's important about the State Board what's important is what it looks like it looks like a button with no text on it like an empty button and what happens when you click on it or when other things happen right so transitions that move it to another state but now we can do things here right quite easily we can say oh actually let's not go to the flat State when you right click on on the cell let's forbid that let's not introduce this flaxseed right the flag state is where you can right click on a cell and you can sort of put a little marker there to kind of go I think there might be a mind here but I'm not quite sure and if I save this here then it regenerates code for me and then let me just run this and there we are there is my Minesweeper and now I can try and right click on this but nothing's going to happen but I can continue to sort of left click and play the game okay and if I make this thing available again here regenerates all of this code for me and I can run it again and now I should be able to right click on here see and I've got the flag this cell here to say there might be a mine there I'm not quite sure okay so so really easily I've just changed the rules directly in this imagine if I had had to try and do that in my Java code I would have probably had to touch three or five four files remember the changes that I made make sure that I make them consistently Etc none of which I had to worry about in this case okay another thing that I get is and you might have spotted that briefly if I comment this out again for a moment here you will see suddenly this part of the of my model gets this yellow underline I go on this this says this state cannot be reached so this is only possible because in my model I have made it explicit that there's this idea of a state and that there's this idea of things moving between states and therefore clearly it's not a good thing if it's if I've defined a state I cannot be reached but because I've got these things explicit in my language I can actually do this analysis and I can actually check for it and I can give better feedback to people developing these things if this was a language I'll only allowed me to build minesweep but it'd be a bit silly okay so the trick to doing mde is to build languages that meet get find that sort of Sweet Spot between being specific enough that that the abstractions are useful to a particular group of people and that they allow us to do give compact expressions of the things that we actually care about and allow us to do useful analysis like invalidations like the one that I've just shown while not being so specific and narrow that we can only write ever write one program in the language okay and finding that kind of balance is a tricky thing and so one other thing you can for example Define with this language is this game of life here we're going to scale up I mean you know obviously for a simple cell program like this you can see this working but we've got programs out there with millions of lines of code haven't we I mean how how would it change that sort of development no actually actually it scales up really well right because because what it does is effectively reduce the number of lines of code that you're right right so every line of code I've written here in my modeling language translates into n lines of code I'm not quite that many perhaps in this example but potentially quite a few lines of code in uh in in the real sort of programming language but are you not making it so it's less less flexible process by by you know having to write a language for each one and then obviously constraining people within the what that language can do yes of course of course right so you are reducing flexibility um but that's that's always been true right in this process well so so there are things you can write an assembler that are difficult or impossible to ride in a higher level programming language but that's not necessarily a bad thing right because more often than not what it actually does is reduce the number of ways in which you can shoot yourself in the foot we'd like to thank scalar for supporting this computer file video if you like me love to learn something new then you're going to love scalar as a resource for upskilling they cater to everyone no matter what skill level which means that you're going to get a lot out of their programs whether it's their interview hacks the mentorships or curated computer science courses every techie should know about scalar scalar's programs are flexible and care for you choose a starting point based on your expertise and become a part of their thriving community it's easy to get started you can take part in a free live class by simply following the link in the video description the live classes are clear and accessible and you can simply sign up for whichever you fancy you want to learn the basics of machine learning in under 20 minutes build a chat bot or take a course in the fundamentals of system design they have it all if you watch this video because you're already a coder then take your coding to the next level with a scalar program tailored to your existing expertise a look at the website the scalar website shows scalar alumni work at top Global corporations and you can see their programs and events in software development and data science remember there's a link in the video description and thanks again to Scala for supporting this computer file video