i thought we'd continue looking at points and point clouds last time if you recall we talked about the iterative closest point algorithm and the idea was we have a load of points we have a load more points and what we want to do is try and move them closer together and align those two meshes i mean they're not messages that point cloud um with a view to maybe doing a 3d reconstruction or something like this now this is actually really really common right in 3d sure in you know in 3d modelling you might do this you might do it to reconstruct bunny rabbits but you might also do this on a street scene suppose you're a robot who is going through a scene and you're doing these periodic lidar scans you've got to take what you just scanned and put it up against the 3d that you've already scanned in the previous frames and you've got to do this really really quickly because if you don't you're going to get way laid by the 60 hertz rate of your of your lidar scanner what we're going to talk about today is something called a kd tree or k-dimensional tree and it's a neat little data structure that allows you to very quickly find what the closest point is given you know possibly millions of other points we're going to look at this mostly for my poor brain in two dimensions right but this could be three four five dimensional and it could be n dimensional or should we say there are k dimensions it's like k means didn't we do k means it's the same kind of idea right we don't know how many it's going to be until we actually have to implement it um but actually the algorithm is exactly the same if you do it in multiple dimensions just gets a little bit slower so i've got some points here and what we're going to pretend we're doing is trying to find closest points to some arbitrary points so suppose we pop down our finger here what's the closest point well it's this one and that's easy for me because i can see the whole picture but there's a question basically if you're writing a computer program to do this what's the best way of implementing this algorithm right so i've got a point let's say it's you know five five or something like this all these points have coordinates in x and y right so i mean just to be clear this is x and this is y and maybe we have a list of these points in memory so we could go okay so if a list starts with this one that's the distance we're looking at and then we look at this one and that's the distance is slightly closer so that's now the near the next closest this one's further away this one's further away but this one's closer and we can go through each of our points in turn and eventually if we record the current minimum distance we'll find the nearest point but you can imagine that for points more than this this is going to be a problem really really quickly right for thousands for millions of points possibly billions of points in a 3d scan this is not going to work what we do is we arrange these points in something called a data structure that allows us to better index and better search them right and there are a few data structures for off top of my head that you could do this with octrees for example or something that we could maybe look at another time but i like the kd tree because i think it's neat and i've actually used it a couple of times in research to find closest points to things so these are our points and we're going to imagine that there for now we're not moving about right they're not moving about these are reference points we want to find the closest point to here or the closest point to here or something like this and we need to do that as quickly as we can so what we're going to do is we can construct a data structure that represents these points in a different way to a list so that when we actually want to search through them it's much much much quicker so what we're going to do is we're going to split up our points into two groups and then for each of those groups we're going to split them into two more groups and we're going to complete this process until you know you can't split them up anymore and then every time we have a point we can very quickly whittle down where we're going to go so suppose we wanted to split up this point set if you're looking at this point set here where would you split it you know intuitively well somewhere in the middle across the middle right right splitting it here didn't make any sense right that's a waste of time because because if you happen to be looking for this point it's an absolute winner right but if you're looking for any of your other points it's hugely slow so yes binary trees tend to split things in two so that's what we're going to do all right so i'm going to use my let's let's start with my blue pen and so we're going to pick a dimension let's split um across the x dimension right and we're going to choose the median points at a point in the middle now i've left a little gap to make my life easier and it's this one so we're going to do is we're going to do a split up like this like this and we're going to split the data in two now actually what we're doing is we're constructing a tree so you don't actually physically draw these lines in so you imagine these are stored in memory maybe this is point a perhaps so what we're going to do is create a tree where the the root node is point a right and i'm going to sort of do this and hope it works now suppose you wanted to find what was closest to this point it's probably a safe bet that the place to look is this side of a rather than this side of a that's kind of where we're going but let's take this process a bit further let's split here now we've got two dimensions to split and so a nice convention would be to alternate splitting so we split first in x and then we sort of divide it into four by splitting in y and then we do x again and so on so let's do it i don't know with this uh orange pen right i've sort of got a strange mishmash of pens here so we're going to split it roughly in two so one two three four five six seven there's seven points so bears this point is roughly in the middle all right and so we're going to split it here like that and we're going to do the same for this side so under three so we're going to split it about here and they're not split in exactly the same place so the interesting thing about something like a quad tree is that they divide everything into two every time spatially so you would always split it into quarters and then eighths and sixteenths and so on but in here we actually split it on a point that exists so let's continue this so this is b this is c right and so we're going to have b as a child and we're going to have c as a child here like this so we're actually constructing a tree now of course these have points associated with them right so let's keep going where would we split this well probably in the middle so let's split this one here like this this one here we're going to split here is that right yes i think that's right and then this one and this one my lines are not really straight that's not really how two dimensions works but we won't dwell on it uh and then finally we're going to split here so actually i mean as an example i'm not going to draw out the whole tree but you could imagine that if this was point um d that's right yeah it comes off to see thanks sean um d e so d and e are children from b so let's move that around so d and e and so on right so that's fairly straightforward right now we actually do technically split again but of course it's not going to be hugely helpful because we've got no further points these are sort of leaf nodes right so something like this and so on okay good right so suppose now we're trying to find the closest point to this tree all right so we can start we know we know what the root root is and we can very quickly go a b e whatever this one is sort of go go in into our tree and search around because there might be other points and stuff but it's going to depend a little bit on where we're trying to find something so let's suppose i put a point in here all right now don't forget that we can sort of see the top-down overview of this but really the computer is just seeing this kind of extended tree structure here so it has to start at the top it can't just go oh it's this one right it doesn't work that way but you'll see how hopefully this is much much quicker than trying to find the closest point giving us a list of points so the first thing we're going to do is we're going to look at a which is our route and we're going to say right we're looking over here what is the what is the best side to look on right now hopefully you've all said this one so all we need to do is compare the x coordinate of this with the x coordinate of a and no then we know which child to go to so in this case it's going to be child b right if we look at our tree a would have an x coordinate and we literally just say well this is this is an x dimension we're looking at on this on this level so we want to go this way now this is going to be a y comparison here and then the next comparison and then a y comparison as we go deeper into the tree so let's look at b we probably don't want to go that way so this is going to be a smaller or bigger y depending on if you're a mathematician or a computer graphics person so we're going to go this direction now we're looking at e all right so e is a child of b and so we want to be on this side so we jump to this side and then we find ourselves at this end point here right so let's for the sake of argument let's call this uh g right just so i can name it so you might think well that's good right we found the closest point it's g now that's not actually true because we've only looked at a b e and g directly we've just gone down the tree we haven't seen anything else so it's possible for instance that there could be a secret sneaky point the other side of e that we're not considering or another point you know over here or something like this what we need to do is go down the tree and then slowly work our way back up the tree to make absolutely sure there's no hidden points and then we're finished all right so the first thing we can do is we can measure our distance from g to our point x or whatever this point is right so that's this distance here and we can say okay that's our current minimum distance so at the moment g is the closest point and its distance is this right now we have to move up one step in our in our thing so if g was g was down here right so we're going to move up to d i put it in the wrong place this is why you do it on a computer and not by hand right so g is over here that's better so we're at g this is we've got our current distance we're going to move up to e so we move up to e and we say well okay could it be e well it's not because this is the distance here right and that's slightly further than this distance so we don't include e now you might think well the next thing to do is to jump up to b and do the same check again but it's not quite because now we're at e we just have to make sure there couldn't possibly be something over this side if you consider right this is a little bit it's a little bit tricky to get your head around but this is our current minimum distance but we're only this little distance away from this boundary so it is possible that if there was a point the other side it would be closer so we just have to make sure there isn't first before we go any further so we go down from e into this point we look at this distance and we realize that's that's no good so we can ignore it and then we can return back up to e so as you're going you go down your tree right at the beginning and then you work your way up and you might visit a different node if there's a chance there's something in there that we haven't looked at yet all right so we're back at e we currently know that our closest point is g we're going to go up to b now all right now we look at b and b is not any closer than g so it's not b right so that's good do we need to check inside b i guess so yeah well you guess so but actually no because the distance from this point to b is this much and our minimum distance is this much so even if there was a point just beyond the line it couldn't possibly be closer than g right so we don't need to check there all we have to do is compare the distance to this line from here and say okay it could be nothing this side that could ever be closer than this point we've already found right so we don't need to look in there so we can jump straight to a completely discount that as being far away and again we do our check this distance to this line here is too far so anything this side can't possibly be closer than g and we're done right and this is one of the neat things actually about the kd tree is if you're going to calculate distances and thresholds and things and what's bigger than something else in many many dimensions that takes quite a long time for every point comparison you do but all the point comparisons we do here are in whatever um axes we happen to be in right now so it's either x or y and if there was if it was four or three-dimensional it would be x or y or z or w whatever you call your dimensions right as we keep going on um this is pretty quick maths right it's just is this bigger than this or is this greater than or equal to this pretty straightforward and so this is really quite quick and we've got what one two one two i need to not count my x's one two fifteen points i drew them in i should know fifteen points here so if we have to search for fifteen points um to find what the closest point is we can already see this is going to start to get quite a bit faster because we've gone one comparison two three and then a couple on the way back up five six points perhaps right depending on my example and of course the more points you have the better this will get if you have a million points and you divide it in two you're at five hundred thousand two hundred fifty thousand hundred and twenty five thousand and you and within a few layers of your tree you've already massively shortened the search that you have to do right you want to do the absolute minimum number of point comparisons that you can does this work for everything does this work no so for for point clouds it works really really quite nicely um for graphics in terms of sort of triangles and you know polygons and and vertices and faces and stuff no not really right and it doesn't work because it's not clear how you then start to split this stuff up it splits very nicely on a point less so on a triangle which has three points and a face and is facing in a certain direction and stuff like this this is when you get into the slightly more powerful data structures like the bounding volume hierarchy which is what underpins stuff like ray tracing it's a logarithmic function yeah it's log to base two so essentially the deeper you get she's never a good situation in some sense it plateaus out and i think mike's going to demonstrate this in a second is that log4j is like milk it's like water it's everywhere