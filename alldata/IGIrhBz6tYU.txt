I'm not gonna lie to you I feel a little bit dumb to be like I've never read this article when was it written 1989 I was three years old how did I miss this one okay the elements of programming style wasn't important and rightly influential book but sometimes I feel its concise rules were taken as part of a cookbook approach to good style instead of a succinct expression of a philosophy they were meant to be okay so this is interesting so I don't have I don't know this book obviously again I have no idea it's an Amazon link I'm not going to click the Amazon link because if I click the Amazon link I most certainly am going to be taken swiftly wait a second if this was written in 1989 how is this an Amazon link it must have been updated this must have been updated uh if the book claims that a variable name should be chosen meaningfully doesn't it then follow that variable whose names are small essays on their name are even better isn't maximum value until overflow a better name than Max Val I don't think so okay I'm already really excited about this I'm very excited Rob Pike I'm very very excited about this because this is a huge thing that I feel which is there comes a point when trying to trying to capture the like the semantics of how something will be used only works for so long right what follows is a set of short essays that collectively encourage a philosophy of clarity and programming rather than giving up then rather than giving hard rules I don't expect you to agree with them all uh there's I almost my my brain almost just started going with the Discord one I don't think you would understand it's a girl a real one uh because their opinion and opinions change with times but they're but they've been accumulating in my head not until let's say not if not on paper until now for a long time and are based on a lot of experience so I hope they help you understand how to uh plan the details of a program okay this is exciting obviously Rob Pike inventor of golang there's a lot of stuff he's probably done I mean I think we could all respect the opinion uh I have yet to see a good essay on how to plan the whole thing but then that's partly what this course is about I don't know if you can really I don't I personal opinion I don't think you can plan a whole project upfront you can it's it's more of a way to fall down a mountain is how I think of it uh it's like glassating right anyone stated it ever right you're you're gracefully falling down a mountain uh there's something about it whereas you know if you've done it enough times you can do it pretty fast but if you're not really knowing what you're doing like it can really mess it can be really bad so if you think uh let's see so if you find the idios in idiosyncratic fine if you disagree with them fine but if they make you think about what uh why you disagree that's better this is the this is the prime time in a nutshell uh under no circumstances should you program the way I say because uh two because I say to the program the way you think expresses best what you're trying to accomplish in the program and do so consistently and ruthlessly damn your comments are welcome okay issues of topography a program is a sort of publication it's meant to be read by the programmer another program or perhaps yourself a few days a few weeks or later oh that's the worst person ever to read my program because they think I'm a complete idiot every time every time and lastly a machine the machine doesn't care how pretty the program is if the program compiles the machine is happy but people do and they should sometimes they care too much pretty printers uh mechanically produce pretty output that accentuate irrelevant details in the program which is as sensible as putting all the prepositions in English in bold font I don't think as is a preposition but in certainly is I'm pretty sure as is not a preposition um anyways let's see ends definitely one I always say blank the log as the log doesn't make any sense as the log I don't think it is it usually describes something about the log right in the log okay that one around the log about the log is like a clause yeah uh that's how I always say in my head although many people think programs should look uh like the algo 68 report and some systems even require you to edit programs in that style a clean program has not made any cleaner by such presentations as a bad program is uh only made laughable this is funny because in golang it requires explicit formatting of structs such that the semicolons and types line up maybe so maybe some of his opinions have changed since 1989 just throwing it out there you know people change right a typographic conventions consistently held are important to clear presentation of course uh indentation is probably the best known and most useful example okay I stand corrected already but when the ink uh obscures the intent topography uh has taken over so even if you stick with plain old typewriter like output be conscious of typography typographic silliness avoid uh decoration for instance keep comments brief and banner free reasonable say what you want to say in the program neatly and consistently then move on all right so this one I feel like is going to be exciting variable names I feel like I like this I I'm very excited about this ah variable names the length is not a virtue in the name Clarity of expression is a global variable rarely used May deserve a long name Max physical addresses say uh an array index by the way I like see I once again I have no problem abbreviating some people hate abbreviating I don't care so if I'm writing okay this is not obviously this is not Java this is not uh but if it was and you had a promise new promise I'm fine going res reg right I don't it it doesn't add more clarity using the term resolve and a reject right like there's nothing to that that makes the program more clear in my head right and so people like I've had people die on a hill about this exact one like no it must be resolve and reject abbreviating is the Dead the Lord's the the devil and you're like really okay really so that's the case well I don't know when you say uh you know uh when you have Max and some I mean you know is it maximum is it are you messing up a little bit oh STD do you mean standard deviation why are you not saying standard deviation right I don't know people make the weirdest like arguments on these things uh read res as a result first it's it's resolve you know it's maximize I know uh an array index uh used on every line of a loop needing to be named more elaborately than I agreed there's people I have honestly got into a PR fight about with I versus idx versus index it's like stop it stop it saying uh index or element number is more to type or call upon text uh your text editor and obscures the details of the computation when the variable names are huge it's harder to see what's going on yes uh and so again I do the exact same thing pretend I have a thing of events right I am fine going const e of events right that's perfectly fine to me I don't I I see no problem with that and people will die on a dumb Hill it needs to be event not e e is confusing how is e confusing what world do you live in that e is confusing e is not confusing ridiculous uh yeah I mean I would agree I will first I'd say that your your styling is crazy okay put some spaces in there Rob Pike uh Rob Pike this is why golang probably has some of their stupid conventions with no spaces I believe between plus that is one of the things I probably hate the most is that they don't put spacing in between I think addition if I'm not if I'm not uh incorrect there I hate that uh oh someone has cringed did we see some cringe going on here someone said they they saw some some cringing going on I can't find it now I can't find it do you miss University no caress my ear holes I will let's Crest on the problem gets worse fast with real examples indices are just notation so treat them such pointers also require sensible notation NP is just a mnemonic as a node pointer if you consistently use a naming convention which is NP means node pointer it is easily derived uh more on this in the next essay yeah there are things I will abbreviate when I get used to them right like if it's something that's frequently uh you know in every single file I I feel like abbreviations like this they don't bother me at all right NP hard oh I'm getting NP hard you know what I mean uh and as in all other aspects of readable programming consistency is important in naming if you call one variable Max physical adders uh don't call its cousin lowest address [Applause] love it I actually love this this is actually this is actually great this is great uh and yes OG is an acceptable abbreviation of original uh finally I prefer minimum length but maximum information names and then let the context fill in the rest globals for instance typically have little context when they are used so their names need to be relative to be relative relatively evocative thus say magical Max of physical addresses not maximum physical addresses for a global name but not but NP not node pointer um for a pointer locally defined and used this is a large a matter of taste but taste is relevant for to Clarity yep that's that's fine I assure embedded capital letters uh in names wait what to my Pros oriented eyes they are too awkward to read comfortably okay Rob Pike that's the that's the that is strange I'm not gonna lie to you I do find it much harder to read I prefer snake case camel case [ __ ] you case or whatever this thing's called I'm not sure what this case is called what's the case of this thing uh this is so easy to read through it is so easy to read through uh I prefer underscores underscores is great no case Linux case pain case lower case uh [ __ ] you case I think it's correct I think it is correct Chelsea I think that's the only one that works bone case uh I have more problems with random acronyms American Business tend to throw around than abbreviations there you go have you ever been in a company that abbreviates everything that's way harder than in programming because programming when something is used you can tell what it is by this context in in business slang they just throw around so many of them it's like impossible you don't you there's not like okay I'm gonna start talking about map map is right like we don't do that be like oh yeah something's wrong with map and you're like what the [ __ ] this map hey Tom you're a genius what's map you know what I mean one thing I will mention is that it's good tooling makes a long variable names just fine xcode makes the objective-c classes so easy to autocomplete that's true uh but it's still a lot to read I do agree with just the reading of things like if you use a whole bunch of um that's painful if you if you work at a company that abbreviates everything it's hard but like if you ever go into a code base that has really long names it's also just hard to read everything is so big right uh it just it becomes hard yeah when reading uh we look at the pattern of the word anyways exactly like this is a huge thing and so it's like too big hurts too little hurts there's like there's definitely a sweet spot I really actually like I like this I can totally agree with everything but but this whole lower level things but hey you know but then again this just goes to show personal opinion's weird can we all agree personal personal opinions super strange that's why you can't that's like that's just why you don't take personal opinions okay it's just that simple all right C is unusual in that it allows pointers to point to anything yep that's the reason that is the reason why C is unusual uh pointers are Sharp Tools and like any such tool the used well can be delightfully productive but used badly they can do great damage I sunk a wood chisel into my thumb a few days before writing this oh yikes classic classic old programmer slash woodworker pointers have a bad reputation in Academia because they are considered too dangerous dirty somehow first off don't listen to Academia that simple right um but I think they're a powerful notation which means they can help us express ourselves clearly consider when you have a pointer to an object it is a name for the uh for exactly that object and no other that sounds trivial but let's look at the following Expressions node node sub I the first points to a node um the second evaluates say to the same node but the second form is an expression it's not so simple to interpret it we must know what node is what I is and what I and note are related by the by the probably unspecified rules of the surrounding program I mean this is a good point a a a a well-named variable even though I don't like NP as an example I really don't I really don't like NP as an example here um I I get this but I think this was also written during a time that you didn't have a language server and what I mean by that is let's just say like what is Rose do you know what Rose is well I know what Rose is that's what Rose is right like there's something about there's there's there's definitely something about naming and how you do things when you have the ability to to to invoke information about it and so I think in today's world it would be a lot more reasonable to say the word node than it would to say NP node pointer or something like that you wouldn't say node PTR right you wouldn't say any of those things because you already you can recall that information instantaneously oh this is you know like you can look at any of those things instantaneously so it makes kind of you know it doesn't make the same level of sense um but I do agree with this this is kind of an interesting one which is when you use an expression you do have to kind of work through what the expression does yeah I mean again you gotta remember that guys we're reading this in the in context of 1989 there's no numpy okay okay there's no numpy there's no no problemo right like none of this existed okay the first points okay actually no problemo did exist at that point uh and I believe Total Recall was just being made greatest show of all time I like environment variables because they're all caps yeah the first points to a node the second evaluates to say something like a note oh yeah we already read that uh nothing about the expression is isolation in isolation can show that I is a valid index of node this is actually a really good point uh let alone the index of the element we want if I and J are and K are all indices into a node array it's very easy to slip up and the compiler cannot help this is beautiful statement this is a beautiful beautiful statement it's particularly easy to make mistakes when passing things to subroutines a pointer to uh is a single thing an array and an index must believe uh be believed to belong together in the receiving subroutine I like that I like that I like this passing the thing and not a way to get the thing can be a lot more simple to reason about an expression that evaluates to an object is inherently more subtle and error prone than an object or an address of the other object correct use of pointers can simplify this code parent Parent Link eye type versus Link pointer type agreed if I mean totally agreed because if you get a link pointer you're only doing one null check if you're doing this you're technically doing two null checks right there's a lot of things that can all go wrong in this one situation or this gotta be careful whenever I see this it gets me it gets my Jimmy's all sorts of like it's level of careful right here it's the level of careful uh I Advance advances but the rest of the expression must stay constant with pointers there's only one thing to advance uh typographic considerations enter here too stepping through structures using pointers can be much easier to read than Expressions less ink is needed and less effort to expend by the compiler and the computer and really the person reading uh and related is the type of the pointer that affects how it can be used correctly which allows us some helpful compile time error checking you know like what he's talking about I do this all the time I keep going back and I I'm using uh JavaScript as an example but often if I have something that's like const e of events right and say events has some sort of message type on it I I would do something like you know type equals e dot uh message type right and then you could do some sort of if type equals I'll often do things like this because it just makes it I like to operate on single items I often don't like to operate on Expressions I find that it's just simpler to reason about my program when I just go like do the thing Define the thing Define the thing use the thing use the thing I don't know why that's just me I find that the more I try to do in a single phrase the more I just completely right and you know I obviously I take this with a grain of salt take it with a grain of salt sometimes I change it up but I technically usually try to break up small things together even though like sometimes do this as well right if I'm only using it once then maybe I'll do that that's fine right like I don't have a hard and fast roll I just typically try to smallify things you know what I mean typically uh like I do not like this stuff this stuff like anytime I do something like that right so if I'm doing something like uh let I equal zero is be less than of uh events.length uh I plus plus because I don't use four each I I don't use four each it slows down my program with millions of events by actual seconds so I can't use it at all this is strange whatever thank you co-pilot whatever you did uh I will definitely do something like const uh event equals events I then I would then I would do the whole event a message uh type equals whatever and which is also funny is that if I were to Define a variable I would most certainly give it a full name but if I were to use a for loop I would definitely do this isn't that funny I just realized that right now if I'm doing my own industry access I tend to give it a more complete name if I'm doing a for Loop that's doing my own industry access I do that yeah four four each is slower it adds if you if you're doing tons of iteration 4-H can actually make a dramatic impact into your program I'm doing millions of items so it really starts adding up weird things that happen I don't I don't understand why I do it but I'm okay with it I do not like the song that's playing uh what if you're doing a wall and do it well first off it's not called a while and do it's first off it's called The Lord's Loop okay a do while this is the Lord's Loop okay this is the most lord of the Lord's Loop of all time all right let's keep on going is that a joke right no no we we did read CSS as a uh for anyone that's watching on YouTube uh later on press the like button hit subscribe and also we will have a CSS as a server uh yeah video it's fantastic all right as a rule if you find code containing many similar uh complex Expressions that evaluate to elements of a data structure judiciously use of pointers can clear things up consider this go left P left equals P right left right left else right equals right left right uh would look like uh using a compound expression for p sometimes it's worth temporary variable here p yeah reasonable okay I think I see what he's trying to say uh procedure names procedure names should reflect what they do function names should reflect what they return this was written during a day of the the differentiation most people don't think of the differentiation between procedures and functions which is interesting because that's just not what's something you know that's just not something when I was going to college we still made the difference the differentiation of this right and the programming language book I had to read this was a thing you know what I mean I don't even know what a procedure is I believe if I'm not mistaken and procedures effectively something that operates over a bunch of things and does something right some sort of side effect it does something whereas a function takes in stuff computes a value and returns it they had they always have this like a method is a function or a procedure attached to a class yeah Pascal does have two different ones that's when I built a when I built a uh uh compiler for it yeah you know what I mean all right so if check size X is unhelpful because we can't deduce whether a check size returns true or an error on or non-air well that's a beaut so this is kind of like one of those funny backward looking things which is in a language that gives you semantics of describing whether or not a function returns an error you don't have to make that decision right you don't have to name a function in such a way that does that instead it's just a part of the language so result types are a good example of this if valid size makes the point clear and makes the signature or it makes future mistake in using the routine less likely for me I can see why this is better because it says what it's trying to do versus check size what is it of checking it against right you don't have an idea of what it actually means whereas this means like hey there's some sort of bound set by the program therefore it's going to do something and check to whether or not it's it's true uh procedures May return something yeah uh let's see a uh delicate matter requiring taste and judgment I tend to be error on the side of eliminating comments for several reasons I almost exclusively hate hate um comments and code I almost exclusively hate comments and code it's just one of the worst thing ever almost ex just always pishly hey happy birthday Presley I hope that you get much much fun today uh first if the code is clear and uses good type names and variable names it should explain itself almost exclusively this is true until there's like a really really bizarre piece of code one time I wrote a piece of code that uh operated over microseconds uh calculating frames coming in and creating like a a uh a synthetic video player but the problem was is that every 10 000 frame or something we'd get this weird overflow error and that's because I wasn't considering nanoseconds and so without the consideration of nanoseconds I'd get these weird overflow issues and so therefore I actually had to put a comment being like hey future me I keep track of the second thing called an overflow and the overflow will slowly accumulate and then once it crosses one this means I've actually had enough nanoseconds to affect my microsecond count therefore you need to have this right like give myself a little bit of reasoning why I'm doing such a bizarre thing because it's so unusual unless if you have deep domain knowledge on this one tiny thing you wouldn't know about it right uh and so there you go second comments aren't checked by the compiler so there's no guarantee they're right especially after the code is modified this is the reason why I hate comments a misleading comment can be very confusing in fact I would I would argue that no comments is less bad than misleading comments third uh the issue of typography comments clutter code agreed this is the worst thing about college is that they make you comment code like everything and the word they do the worst kind of commenting of code they make you do something like this where it's just like four const e of events uh go over all events and sum their uh you know values right and then you're like you know uh sum plus equals e dot e dot value right like that kind of stuff like that's just the worst kind of comment because it didn't tell me anything like it's it's it's code it's it's attempting to chat GPT code what this what this is doing it's like the worst but it gets you an A plus it is the worst though I do comment sometimes almost uh exclusively uh I use them as an introduction to what follows example explaining the use of a global variables and types the one so I don't I never do type stuff anymore because well you don't have to with LSPs and all that the one thing I always comment in large programs as an introduction to an unusual or a critical procedure um or to mark off sections of a large computation let's see there is a famously bad comment style I equals I plus one add one to I [Applause] hate it and then there's uh then there are worse ways to do it if I saw this I'd recommend the person being fired or I'd buy them a beer I don't know which one it would be I don't even know which one it would be right like should this person be fired or should they get a promotion to manager I don't even know sick Manor dog I know now I kind of want to start doing this now I kind of want to do it I kind of want to make a Vim plug-in called obnoxious commenter where you can do a quick comment and it'll just like blow it up dude don't laugh now wait until you see it in real life this is true avoid cute typography in a comment avoid Big Blocks okay I'm gonna tell you like I can't remember the exact one and I think I took a picture of it on my Facebook and posted it but I have deacted my Facebook years ago and so I can't remember exactly the exact thing and it'd be way too hard to find it but it went a little something like this it was just like some variable it was like int x equals and then it was just like a very long long hexadecimal number and and oh like and Ando something like some variable name VAR I forget what it was and then it said like this we like uh we mod seven because of two and I sat there and I looked at it and I looked at it and I looked at it and I looked at it and I could never figure out what the hell it did because there was no seven or hold on here uh let's call that thing a five and let's call this thing A4 right there was no seven there was no two I didn't know what it did or why it did it just it just sits there floating in this way in which confuses me there's no mod there's an ampersand sign like it just I couldn't figure it out I could not figure it out it had to do with radar and Ultra wide band and radar and how to select these buckets and it just like I could not figure it out it was the worst and that's where Ron comments are just the worst if your code needs a comment to be understood it would be better to rewrite it so it's easier to understand which brings us to love this I just speaking to my heart Rob uh complexity most programs are too complicated that is more complex than they need to be to solve their problems efficiently why mostly it's because of bad design but I will skip that issue here because it's a big one but programs are often Complicated by the microscopic level and that is something or programs are often complicated at the microscopic level and that is something I can address here rule one okay very excited about these rules rule one you can't tell where a program is going to spend its time fantastic bottlenecks occur in surprising places like my for each one I saved multiple seconds by not using array.4 each right it's crazy right uh so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is that's right uh two measure don't tune for Speed until you've measured and even then don't uh don't unless part one part of the code overwhelms the rest this is so this one's kind of interesting because the hard part about this one is that there's the whole problem of hotspot optimizations you often find yourself making something faster but then you immediately hit a bottleneck or a a limit of how much you can make your code faster I think I read an article about this a month or two ago but it's very interesting uh rule three fancy algorithms are slow when n is small and N is usually small fancy algorithms have big constants this is true that's why a map is almost always slower like check this out if you're in code and you go like something like this const a equals um you know a bunch of 14 items in here let's just pretend there's 14 items in here and you check thousands of times you do something like uh includes you know something I don't know a b and you do this thousands of times it is still faster to use this than const a equals a new map of uh you know string to number or something string to uh Boolean right it's significantly faster even in JavaScript which doesn't even use an array it is significantly faster to use the top version than the bottom version it's crazy right people don't realize that fancy data structures come often at a cost and people don't know that but maps are constant time and maps are constant time all right look at this they're even saying it right here oh yeah let's go all right all right uh fancy until you know what n is frequently going to be uh is frequently going to be big don't get fancy even if n does get big use rule 2 first for example binary trees are always faster than splay trees for work uh uh work a day problems I'm not I don't know what a work a day problem is and I haven't looked at the splay tree and long enough that I forgot what it is okay rule four fancy algorithms are buggier than simple simple ones yep and they're much harder to implement yep but that's what we have libraries now for the most part so I you know a hash table is Easy A B tree you know uh use Simple algorithms as well as simple data structures the following data structures are a complete list for almost all practical programs array linked list hash table binary tree it's a good list I would add in here that with modern programs we use arraylist a lot kind of the in-between of linked list and arraylist right a vector Vector array uh arraylist however you want to put it of course you may also be prepared to collect these into compound data structures for instance a symbol table might be implemented as a hash table containing linked list of arrays of characters yep uh rule five data dominates if you've chosen the right data structures and organize things well the algorithm will almost always be self-evident a data structure let's see data structures not algorithms are Central to programming I love this I love this this is great what is a vector uh just think of it as effective it's just an arraylist it's a dynamic array rule six there is no rule six this is good have you read mythical man I actually haven't read mythical man yet uh I think I read bits and pieces of it but I actually haven't read it I should read that rule seven see rule six uh algorithms or details of algorithms can often be encoded compactly efficiently and expressively as data rather than say lots of if statements the reason is that complexity of the job at hand uh if if it is due to a combination of independent details can be encoded a classic example of this is a parsing table or is parsing tables which encodes the grammar of the programming language in a form of interpretable by a fixed fairly simple piece of code finite State machines are particularly amidable amenable to this form of attack but almost any program that involves the parsing of some abstract sort of input into a sequence of some independent actions can be constructed profitably as a data driven algorithm I bet you 99 out of 100 people literally have no idea what he just said that's my guess my guess most people are gonna nod their head at that and go yeah dude totally Totes My Goats bro uh perhaps the most intriguing aspect of this kind of design is that the tables can sometimes be generated by another program by the way I really uh I really really want to understand data driven design I've never actually done data driven design I've never like tried to go through it and read it and it's like uh uh academic sense and so that's one thing I actually do want to do yeah sure called it damn it pick damn it pick my guess is that I have arrived to some sort of conclusion near data driven design and I just don't know about it too much D it's just enough D to make it fun uh a parser generator in the classical case uh the more earthy example if an operating system is driven by a set of tables that connect i o requests to the appropriate device to Rivers the system may be configured by a program that reads the description of the particular devices connected to the machine in question and prints the corresponding tables absolutely one of the reasons data-driven programs are not common at least among beginners is the tyranny of Pascal Haskell all my homies hate basketball Pascal like its creator no this is this is not good this is not good Pascal like it's Creator firmly believes in the separation of code and data it therefore at least in its original form has no ability to create initialized data goodness gracious this uh flies in the face of theories of Turing and Von Newman which defined the basic principles of stored program computer code and data are the same all man lisp programmer casual lisp programmer coming in or at least can be how else do you explain how compilers work functional languages have similar problems with IO this is why I also like this is why my functional programming journey is O camel this is beautiful function pointers ooh let's go first class functions another result of tyranny of Pascal is the beginners don't use function pointers you can't have a function value variables in Pascal oh I remember that gross well I guess during this time during this time I was heavy into c-sharp in Java and you couldn't have function pointers in C sharper Java during the 1.6 days of java slash whatever c-sharp was right you just couldn't have it using function pointers to encode complexity has some interesting properties the complexity is passed to the routine pointed to the routine must obey the some standard protocol is let's see it's one of the set of routines invoked identically but beyond that what let's see what it does is its business alone the complexity is distributed I can see this this is good there's an idea of a protocol in that all functions used similarly must behave similarly similar similarly that's a hard word to say this makes uh for easy documentation testing growth and even making the program run distributed over a network the protocol can be encoded as remote procedural calls okay I assume this is like I mean in some sense you're almost speaking about some sort of mapreduce here as well I'll say I can argue that clear use of function pointers is the heart of object oriented programming oh [ __ ] oh sh pick cover your ears pick this ain't it pick I don't I here we go here we go given a set of operations that you still let's say you want to perform on data and a set of data types you want to respond to those operations the easiest way to put the program together is a group of function pointers for each type this in a nutshell defines class and Method the oo languages give you more of a coarse prettier syntax derived types and so on but conceptually they provide little extra combining data-driven programs with function pointers leads to an astonishingly expressive way of working a way that in my experience has often led to a pleasant surprises uh even without special oo language you can get ninety percent of the benefit for no extra work and More in control of the result okay yeah I cannot recommend an implementation style more highly all the programs I have organized this way have survived comfortably after much develop development far better than those less disciplined approaches maybe that's it the discipline it forces pays off handsomely in the long run this is actually really interesting because a good type system like like right now because I'm just starting o camel and I feel like this makes sense how functional programming has an advantage real functional programming not JavaScript we got to stop dropping we got to stop with this whole just because you make functions bro does not mean you're functionally programming bro right we got to stop that I just wish I mean the thing is is this is why I hate it that I like rust because I I dislike Russ leadership and it makes me not want to use their language but rust is procedural functional programming it is f poo right it's it's like my favorite of it all right I just want to be able to program in a way that's C like but I want to have all the conveniences of functions and functional like semantics you know what I mean functional procedural oop classic let's go I know so I I want the problem is go the problem is is I want go to be more complex and the problem is that I don't want go to be more complex it hurts it's emotionally painful the Gopher is not cute I want to murder the Gopher okay the Gopher see the thing when you grow up in a small rural area Gophers are a sign of tyranny okay you don't understand okay if you know you know if you don't know you don't know okay some of us had the responsibility to go murder Gophers okay okay crabs on the other hand are delicious love a crab to come next to me you know what I mean they're a menace they are a menace see thank you somebody who understands Gophers are a menace they are terrible terrible animals that you should eradicate one simple rule include files should never include include files If instead they state in the comments or implicitly what the files they need to have included first the problem of deciding which files to include is pushed over to the user the programmer but in many ways that is easy to handle and that by construction so I think this is one of those things in which doesn't exist in more modern languages right um I think I see what they're trying to say right I think I see what Pike's trying to say here which is you don't want files with a bunch of dependencies because then when you try to import them they import a bunch of stuff and your program starts exploding um I can understand this you want your like Library files to be self-contained you know whatever ones but this paragraph predicts npm dependency out like that's a good point lately I've been struggling with some npm dependency problems because these peer dependencies have been biting me in the ass and it doesn't show up until run time when I try to evoke a typescript program with a library that has a peer dependency that's somehow's not making it through in the generated code and exploding it's been very very very upsetting so I mean I understand I I think I understand what they're talking about right I understand this rule I think Rob probably has a right he's probably correct but it seems impractical that's my PR that's probably the problem this might be an academic thing also uh don't do if deaths uh that can prevent a file from being read twice but that's usually done wrong in practice the ifdfs are in the file itself not for the file that it includes it the result is often thousands of needless lines of code passing through a lexical analyzer which is in good compiler is the most expensive phase see like like I said this might I mean though correct this might not be the same thing right now we pass those thousands of line through and we tree Shake hey baby you want to shake my tree it's a Stephen Miller song okay it's a Stephen Miller song and now it's also a JavaScript concept the name is the tree Shake again