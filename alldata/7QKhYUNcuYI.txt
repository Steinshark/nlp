in this video we're going to be covering lazy Imports in Python I'm going to be showing you how they work and how they can improve the memory usage in your program I'm also going to be covering the pros and the cons because they do come at a cost but it's good to know how to use them in case you do want to use them even though I don't see them being used that much in Python so to get started we're going to import OS and we're going to import the import library then from typing we're going to import any for typing in Python and you're going to have to install psutil in the terminal to use this part yes so we're just going to use the process and if you do not have that installed just type in PIP install PS util and when you tap on enter it should install it then you can close the console and import process from PS util and that will just help us measure the memory usage at a given point in our program and to get the memory usage we will create this function called get memory usage which is going to return to us a float which will end up being megabytes and first we need to create a process of type process which will equal a process and we want to get the os.getpid and then we can get the megabytes back from that process which is going to equal process dot memory info and we want to get the RSS back and we need to convert that to megabytes so we'll do 1024 times 1024. and that should give us megabytes back so we will return the megabytes next for the lazy Imports we do need to create this class and there are packages that help you with lazy Imports but we're just going to do this vanilla and create our own class for that so class lazy import and it's going to have an initializer So Def in it and inside this initializer we need to provide a module name and after that we can type in self dot module underscore name it's going to equal the module name then we're going to create another attribute and it's going to be called self dot underscore module so it's a protected attribute and that's going to be of type any or none so it's an optional that can have a value or it can also be none but it's initially going to be set to none next we need to incorporate the get attribute done the method and we're actually just going to use the getata and instead of item we're going to insert the attribute that we want to receive which will be of type string and that's going to return to us any so when we try to access an attribute from for example numpy it's going to call it here and we need to process that we need to make sure we can grab something from that package so we need to check if self Dot underscore module is none then we're going to import that package so self dot underscore module is now going to equal import Library dot import module and we need to provide the name and the package so self dots module name so it's going to import the module that we want to import as soon as we try to use it and all we need to do is return get the attribute or get attribute and here we'll type in self dot module and the attribute we want to get so that's the whole class for our lazy import and here we're going to provide the module that we want to perform the lazy Imports on and as soon as we try to access it it's going to load it into memory otherwise if we don't access that module at all we're going to save on memory by not using it but I still need to show you an example on how this works of course because up until this point we've written a lot of random code so we're going to create a main function and that should just be called Dev Main and inside here first we want to create numpy so numpy of type any and that's going to equal a lazy import of numpy this is the package we want to import and it's giving me that yellow error message because I always make this mistake and instead of typing init I type in int I absolutely hate this change that to init and everything should work from that point on but thank you pycharm for highlighting that so I could see that but now we have a lazy reference to numpy which means we didn't load it into memory just yet because we did not use it at all so we're going to create a simple script that's going to show you how we save on Resources by not loading it into memory immediately so for example pretend you have a script that has an infinite Loop and we're going to create a chatbot as always so user input of type string is going to equal input with you as the writer then we have a message list of type list of string which is going to equal user input dot split so it's going to split our message into an array or into a list and we're going to check that if pi is in the message list so if Pi in message list we're going to print the following we're going to say that the bot and we want to format that so bot says this we're going to type in numpy dot Pi so we're going to access that attribute from the numpy package but only if we ask for it so right now we didn't load numpy into memory just yet and it won't load into memory until we actually refer to something that belongs to numpy and I didn't mean to print this I actually meant to create a message variable here so message of type string is going to equal that else this message of type string is going to equal something else it's going to say bot and we're just going to Echo the message so here we'll just type in user inputs so it's a very simple chat bot that doesn't really respond but it is going to show you that as soon as we try to use functionality that has to do with a module that we have imported lazily it's going to load it into memory later so here we can type in also memory underscore usage and that's going to be of type float that's going to equal get memory usage then we want to print the formatted string of message followed by some parentheses and inside here we're going to type in memory and we want to get the memory usage formatted to two decimal places and we'll add megabytes after to make it look nice then finally we can create our if name is equal to Main Check and insert main inside that so now let's try to run this and if we type in something such as hello or hi you're going to notice that the bot is going to be or this script is going to be using around 16 megabytes of memory and this number is not fixed and it can change radically it can be eight megabytes it can be 30 megabytes it really depends on what your computer is doing and what your script is doing but you'll also notice that we did not have to load numpy immediately into memory which means now if we want to access something from numpy it's going to take a bit longer to load but it's still going to be saving on resources before we use it so if we say what is pi this response is going to take slightly longer to load and this can really change a lot depending on how big that functionality is maybe your program is a lot of functionality that has to do with that so the load time might take a bit longer than usual but we were able to load it into memory later when we actually did use it and because of that we now had 32 megabytes of memory being used but we were able to use that functionality so what are the pros and what are the cons of using this approach of delaying your Imports of lazily importing packages well the first pro and I don't know if this is still relevant in Python 3.11 because they improved startup Times by caching packages but the first pro is that it would reduce initial startup time because you wouldn't have to load all of these packages immediately you would only load the ones you use and you would use the lazy packages later when you actually need them because there's also the opportunity or not the opportunity but the chance that the user might never use the package that contains for example numpy dot pi and if the user doesn't use that why would you want to load the package into memory so that is one of the first pros and second now we have the option to conditionally use the module if we're not going to use it why should we use it here we can check that if we are going to use it we should load it into memory so that we can use it otherwise the user might talk to this chatbot for who knows how many hours and they might never run into numpy.pi so why waste time with that functionality and why waste time with using those resources and finally it can help you save on memory usage again because you're not using that package why use the memory to load that package and now it's time for the cons and the reasons why you would not want to use this in Python and one of the first reasons would be that you get no context actions for numpy you need to know numpy by heart to actually be able to use it because code editors will not be able to help you out if you do not import numpy at the top because again intelligent code editors rely on some information to give you some information back and if you import the numpy type you're importing the whole numpy package so you lose the benefit of the lazy input the second con is that you might get a very heavy performance hit because once again when we ran this script and we said hello the response was instant but as soon as we said something such as Pi it took slightly longer to load and that can really depend on the functionality you are importing so that might be something you're going to have to think about when the user is using your application is it worth it for them to experience this lag in your program and finally one more reason you might not want to use lazy Imports in Python is that it kind of increases the complexity of your script for something that might be very minimal because again now every time we refer to numpy we're going to have to keep track of this over here we might not import it everywhere and it just becomes harder to keep track of how you're actually using your script plus again there's no context actions so you're going to have to do some extra work so at the end of the day you might not use lazy Imports that much or you might decide to use them that's absolutely up to you but it's good that you know about these pros and cons and how it works in theory there were some attempts to introduce lazy Imports to the official releases but those were rejected as of python 3.11 they are still being rejected and I will try to find a link to that article and leave it in the comment section Down Below in case you are curious but as of today if you want to use lazy Imports you're going to have to create your own implementation or import custom implementations or packages from other users but I'm very curious to hear what you think about lazy Imports whether you use them in your projects whether you think they make sense or not in Python but as always with all that being said thanks for watching and I'll see you in the next video