Hello and welcome. I'm James Murphy. And today, we're talking about pre-commit which is a really cool tool that you can use to keep your codebase tidy and catch some simple mistakes before things ever get committed into Git. It happens. There's a new person on your team that doesn't really know about pep8 or you just forget to run your code formatter or you just make a typo in a config file somewhere. But at the time, you don't really notice. So, you just go ahead and git commit. Then, either something breaks or just the quality of your code base has gone down just a little bit. Well, a bad config you can fix and code you can just reformat. But still, wouldn't it be better if you could just catch those errors before the commit happens? That's what pre-commit is for. Here's the story of pre-commit. Basically, git has a notion of what are called commit hooks. These are things that happen either before you commit, or just after you commit, or when you push, or when you pull, things like that. Git will store this and a whole bunch of other information in the dot git folder inside a directory. Depending on your editor, this folder might be hidden. So, just look out for that. You might have to unhide it. This hooks folder is where git stores all these different hooks. The ones you see here are just samples. If you were to get rid of that dot sample on the end of the file name, then git would actually run that action at that corresponding time. So, if I have a file named pre-commit, then git will run that script right before a commit happens. But you don't need to go out and waste your time writing something like this yourself. A lot of really good scripts have already been written. The pre-commit project just makes it really easy to pick and choose things that you want to check for your own code base. Let's start simple. All I want to do is make sure that before I commit anything, I run my code formatter on it. Of course, I can just run the code formatter before I commit. But the point is, I shouldn't have to remember to do that. Why not just make it automatic? Well, it's super simple to set up. Open up your terminal and just pip install pre-commit. Then at the root of your project, just make a new file called dot pre-commit-config.yaml. Then it's just this easy to add automatic code formatting on every commit. You specify pre-commit hooks by just giving a git repository. In this case, I'm using Github. But you can actually use any git repository, even a local one. You specify the git tag that it's going to use and then some information about what command to run and what arguments to give it. In this case, I'll be using black to do the actual code formatting. Then you use pre-commit to install the git hooks into your git hooks folder. Now if we go and look in our git hooks folder, we see that we have this new pre-commit file. All right. Now let's add our files to git, commit and see what happens. As you can see, it ran black and the commit failed because some modifications were made and it's not going to commit anything automatically. I can go and manually inspect the hello.py file and see that everything looks good or just compare the diff like I normally would before commit. Note that these modifications to the hello.py file were made after the file was staged. That means I need to git add this file again or if something went wrong and I don't like the changes that were automatically made, then I can git restore the file to go back to the way it was before. In this case, I'm happy with the changes. So, I will add and then try to commit again. This time since everything passed, the commit went through. Note that, some graphical editors, like this one PyCharm, have built-in git support and they will automatically add tracked files when you try to commit. So, if that's the case, then it might look more like this. Here I have a spurious space in there and I'm going to go ahead and try and commit. Then I try to commit and I see the commit failed. And I can go to the console to see what errors. I see that it deleted the extra space. And then I can just go ahead and click commit again and then this time it will succeed. So, what else can you do besides automatically formatting your code? Well, you can write your own commit hooks. So, you can pretty much do whatever you want. But there are a ton of really good ones already written on this website here. Here are just a few of my favorites. You can delete trailing white space, make sure a file is either empty or ends with a new line, make sure that any yaml files have valid yaml in them, make sure you're not accidentally committing any really big files into your repository and check for any spurious breakpoints that you forgot to delete before committing. You can also run your linter like flake8. You can reorder and standardize the order that your imports happen in. You can check for outdated syntax and replace it with its modern equivalent. And this would also be a good place to run your type checker like mypy. pre-commit is most popular in the Python world but it's not something that's just limited to Python. There are pre-made scripts for doing things like running Clang-Tidy or Clang-Format, or some other code formatter for a different language. You don't have to reinstall anything if you change the yaml file. Just go ahead and commit. We see the commit failed because of a mypy error telling us that we passed the wrong kind of argument to this function f. Also note that, most hooks will only run if an applicable file actually changed. So, it's not going to be reformatting code that it already formatted and hasn't changed. Finally, there's the question of safety. How safe is it to automatically run programs on your source code before committing them? Well, this ultimately goes down to the project and whether or not you trust the project to do the right thing. Of course, these little scripts can be written by anyone. So, if they put something malicious in, then you're going to be out of luck. You can fix a specific version or even a specific hash in the config file. This helps mitigate things like, what if this project gets hacked and an attacker uploads something malicious. But as always, only use projects that you really trust. As far as accidental errors go though, like, what if black accidentally changed the meaning of the code. Well, that's something that I haven't actually run into. If something did go wrong, it would really be up to you to catch it in the git diff or by running tests. Of course, for an accidental mistake, you can always revert using the git restore command that I talked about earlier. Well, that's all I've got. I hope this makes your repos better. Thanks for watching.