um hi everyone I'm Victor thanks for coming I have the best slot in the schedule right after lunch everyone is going to fall of sleep now I'm fairly confident um by the way if you if some of you know um what company I work for uh or uh maybe if you if you enter the room hoping for some uh announcements or latest and greatest and that kind of thing this is not that kind I don't do those kinds of uh so um definitely the things I'm going to talk about uh today are not official uh company agenda uh I don't represent the views of my employer um and some of them might not even know I'm here uh and as always I'm going to have opinions um so I'm I'm going to present some facts uh and I can I have data and and links and references to prove them um and I'm going to compare some stuff and um I'm going to Pepper that with some opinions and and suggestions and questions for you so um by all means uh I meant this um as a dialogue so U feel free to interject at any point um ask questions share your opinion um preferably if you can do it on the mic so everyone can hear and gets recorded uh for better or worse uh uh if you're reluctant to do that on on record I'll be here till the end of the conference just find me anywhere I think you can easily spot me and just Corner me and uh say uh say whatever um you think about the topics but I do encourage I I sort of um initially I when I when I started working on this presentation I jam-packed it with tons of information and lots of details some of them technically interesting but not really relevant to the bottom line of the idea um so uh in the end I I opted for more of a bird's eye view of things and I've cut some of the ugly details although I reference them but I can chat about them offline maybe uh because I I want to leave room for uh people to breathe because I don't want this to be like a a fire hose kind of presentation where I go through a lot of uh stuff and uh people are just overwhelmed or have difficulties following and also I want to leave room for discussion and questions and interpretations um but first off um yesterday uh during the morning keynote I grabbed two bottles of water while kevn had te technical difficulties with uh the projector I grabbed two bottles of water out of the fridge here on the hallway um so um Can anyone notice what might be the connection between those water bottles and my topic do you have a good eye shout it out different interfaces at the top yeah yeah so uh honest to God I grabbed them from the same shelf in the fridge uh and they I even looked so they're both still water so I thought I grabbed two identical bottles not quite so um what does ABI really mean anyway um can mean a lot of things and depending who you ask uh depending on uh at what end of the foot chain so to speak uh they they spend their time um they they might give you slightly different answers um if you're asking a compiler engineer or Library writer or an application developer or a hardware operating system person so they might give you slightly different answers um is it the platform is it the hardware ABI are we talking about I don't know exotic architectures calling conventions language specification compilers how Implement how do we Implement standard libraries and how we share them how we do Dynamic loading and so on then all sorts of things they all sort of go on the this ABI umbrella that everyone uh sort of talks about so at the end of the day it's about the um you know when you say the devil is in the details well these are the details the implementation things and generally we need to agree when we build stuff we need to agree that stuff we're referring to means the same kind of things uh and if we're building uh those caps for those bottles they fit on on bottles even if they have like slight differences there at the uh top formation of the bottle so we need stuff to just work um so ABI stability isn't really technically a property of the programming language itself although people usually like to associate these discussions with Lang anguage discussions and standardization and it's really more of a property of a system or or its tool chain but because we strongly associate language names with the their tool chains or their systems or their vendors or their platform that they support we usually mix up these things so um some aspects are defined by the platform and the operating system some by the tool chain how the vendor choses to implement things uh or to support already shipped things and there are many situations when the platform owner actually requires you to build with a particular version of the tool chain uh so that it works on the the target operating system version um Apple would be prominent example in this in this Camp um and of course this is a really big deal if you care about Dynamic linking and about sharing libraries and even here we have a very wide spectrum of um priorities and Necessities depending on the kinds of things that we're building uh for for many application domains uh Dynamic linking just doesn't make sense uh isn't applicable or isn't a priority whereas for other situations sharing U run times sharing Library implementations thinking about code s and how you fit in the system or how you can service those components while they're shipped the ability for example to independently patch security vulnerabilities in in in libraries that are shared across multiple applications the the ability to service operating system fundamentals without requiring applications to recompile or retarget against those patched versions of the run times so those are different concerns so again we have a very wide spectrum of what applications need and usually prioritize what we care about so um trying to be more concrete here so uh layout of types that's the first thing that comes to mind when you think about ABI size alignment uh stride in in some situations this makes a difference when we talk about um Co inhabitant of types if you think about fanc constructs like enams that have Associated types and St becomes important when you think about array so size alignment offsets types of fields and their offsets in uh composite aggregate data structures vtable entries we if we have any uh any such things uh in our types calling conventions name mangling um metadata if applicable for for the language or or the runtime in question um and yeah name mangling matters because we're actually using um 70s era technology for linkers um so just to build like a common understanding of what we're talking here um we have a a source file that implements a particular definition for whatever types excuse me we're defining there and we we compile this together in in a unit uh and on some other side uh someone wants to consume uh some of this implementation uh and of course it will compile uh the source code against uh the definitions that we provide and hopefully these things should somehow connect together uh and I carefully plac those gears in in in in uh in the slides so that they look like they fit and don't grind together uh so yeah binary compatibility between separately compiled artifacts this is what the kind of thing we're talking about uh and it's not just about um evolving and modifying the type layout for for a particular type it's also about flexibility to upgrade or change your your tool chain for example you might have this uh separate um artifacts uh compiled with different versions of your of your tool chain uh or there I said maybe different tool chains and you're sort of trying to mix them together so we have to carefully orchestrate these kinds of things so that they just work and we don't have any surprises and surprises can be really weird it's not like we uh uh get nice diagnos sticks for these kinds of things or um we can easily uncover them sometimes they're really sneaky they can seem to work and then mysteriously um fail for some some reasons when you list expect it as usual um okay so the idea is we sort of want this predictability this stability so that we can freely mix and match um so that we don't have to share source code for a library for example so that we can access the most recent version of our compiler our tool chain be able to upgrade without worry that things might break or I have some third party dependency that I'm I'm going to have to leave behind or U recompile or um I don't know maybe the vendor went out of business and can cannot get a newer version of that dll or whatever so upgrading with uh is um don't com don't recompile the world maybe even like a um efficiency uh step in terms of um build pipeline like being able to just move forward without recompiling the world every time the ability to incrementally do stuff um and yeah I mentioned this earlier the ability to actually patch stuff um and address vulnerabilities in in shared libraries vulnerabilities in um operating system foundational components without requiring applications to to deal with that burden and uh size does matter yeah um when you're sharing uh a lot of even for the standard library or the the some runtime that you're consuming or depending on having that payload in every uh component that actually relies on it uh statically it's a cost that um not all environments can afford so being able to share that code again it's a win so the idea is that uh if you do want to to have this uh stabilization and and all these properties when should you look for them when should you opt in um if you do this too early you end up shutting a door on future compiler Library optimizations um miss out opportunities like I don't know Implement a better calling convention or um change the layout of a particular data structure so that it's uh more optimal uh or improve some detailed implementation of standard Library facility standard thread um and mind you these the these are not uh impossible things uh it's they're just tough problems so it's it's not one of these uh uh six impossible things that kevn mentioned yesterday it it's it's these constitute lots of small little details that can be addressed with enough effort and um desire to do so cuz I I will question that not everyone actually cares about these things so yeah we need to invest a lot of time um and solve them but there are potential Solutions so it's I I mentioned this earlier ABI stability is not necessarily a language thing uh it's I would say mostly a library Evolution concern and and how we choose to uh improve evolve the the libraries that we're building or consuming uh so um developers want to evolve their libraries without breaking API because then they'll have a better chance of their changes being adopted quicker uh they want to add new functionality fix bugs improve performance problems um these kinds of activities can in some situations uh generate uh AI brakes and hurt consumers um for example adding a field to a class virtual function we use some padding or some reserved fields and so on could have surprising uh effects sometimes uh and we've seen for for many years we've seen um implementations hold back on different um Improvement opportunities um because they just they're just afraid they they might break uh their client code so um if you're looking like a let's say over the fence uh when whenever you don't know what to do you look over the fence to see well what what do other people do um well I would say uh a bunch of our uh Usual Suspects there they outright claim that this is not an active concern uh they have different priorities uh well C++ were always undecided but I'll get into that um so for carbon for example um they State we have the explicit known goals for carbon including uh a stable application binary interface for the entire language and library and perfect backwards compatibility so they just don't want to deal with this now they have other priorities when building this emergent uh new technology um rust should be more mature by now um they have plenty of um facilities maturity tools um language uh means to deal with um additions and um fairly good tooling um still this is by the way uh this is comment is from 2015 but uh there's no new since so rust does not care about defining an an ABI so they're very much embracing the build everything um leave at head sure semantic versioning for crates but build everything for from Source uh so they they have no such priorities at least for now uh Zig natively supports the cabi for things well everyone tries to do that uh but Zig internally does not use an API meaning code should explicitly conform to cabi uh and all other assumptions are off the table so again no guarantees their focus is completely uh in other directions go pretty much the same thing uh by the way these are they're not properly marked on the slides but these are quotes from the pages there's this is are not my interpretations so Gobi defines the layout of data in memory and conventions calling conventions um this API is unstable and will change between Go versions like they flat out said it uh no no guarante is offered so I mentioned this earlier um when deal dealing with these kinds of things you have various uh considerations various constraints business priorities uh technical limitations um user demands and and so on so you have multiple choices multiple things that you need to consider and prioritize accordingly like what you want versus what you need or can deliver now to customers so um when we think about um layout and and stability of of type layout this would be the the gold standard uh for for stability right one level of indirection solves every problem I still feel in the room I have to acknowledge level of indirection in the room uh so yeah you can indirect everything through a pimple like interface but that's um it's it's not a scalable solution it's not nice um and it does come with with performance cost uh even even if you don't really need it so it's it's it's sometimes employed but it's not a pretty solution um just erasing every trace of type rigor and performance uh that's another Choice um we we can do that I I just heard any mentioned this morning um and of course we have the greatest champion of ABI stability and dynamic linking out there and by the way that c is not carbon it's the the old C um the new carbon doesn't have a logo yet okay so um when un sure always go to the roots uh I started programming in the '90s um I live through a lot of com uh do we have com survivors here in the room yeah okay cool about uh a quarter of the room I'm impressed uh so we we all remember the the the comway um where you actually want to change something you just have to invent a new interface so you force breakage through API and you force your users to uh uh use extended interfaces for example if you want to add one more function to your interface you cannot just add one more function you invent a new interface and by the way that uh two three suffix there that's not slideware this is the naming convention that we used for the folks who are not aware of those historical tidbits so yeah I I I I have vivid memories of using interfaces that had five or six at the end uh and there were not mine that was uh Windows provided stuff good stuff uh or uh you can take the stringly approach uh uh of um things like Objective C uh and go for more of an unstructured uh data type Erasure Galore Dynamic everything in directions everywhere so that works but um it comes with other disadvantages in in optimization opportunities in in type safety in refactoring capabilities and so on so specific stuff when you lose um type information so and now I'm getting to the uh uglier bits by the way um you haven't thrown things at me yet but I'm still available so um in February 2020 um the last prepandemic uh ISO committee meeting that took place in Prague um there was um I was about to say productive but it wasn't productive but was the most Vivid discussion on on API uh stability for C++ um and they took a series of polls uh and we decided not to break ABI sort of that not is weird because we also don't offered any guarantees that's not right sorry that's not right uh what do you mean we didn't we decided not to break 23 yeah I have a slide with with with those concrete things I think it's the next one oh no the next one is ugly uh but it's coming up um yeah uh so um like Daniela interjected I would say the the the outcome wasn't a definitive answer uh like all things C++ it was ambiguous so uh soon after that committee meeting uh quarantine wrote this article the day the standard Library died um and by the way highly recommended if you haven't read it yet highly recommend it that you read it it's not as Gloom as it looks in the picture so uh I I I I had to put this up because I I so very much love that quote from Titus so committing to ABI is like admitting that the standardized library is aiming to be the McDonald's it's everywhere it's consistent and it technically solves the problem but it's I think we could agree that's not really good food so that's one of the issues uh how far do we extend this discussion and not including the standard library in the ABI discussion is just like why are we talking about it if we're settling for a subpar standard Library just because it's everywhere and makes these stability guarantees without being any good um and we have plenty of examples then why are we talking about it maybe we're wasting our time so uh other two quotes that I loved here I'll I won't read them I'll let you soak them in and sip some water and this one stable C++ API it's useless for the platform apis if it doesn't Encompass the standard Library so you could have a compilation mode and choose between resilience uh and performance and I'm going to talk a lot about uh this Choice leave them couple of seconds on screen okay so uh I I titled this the king of mixed signals and ambivalent Behavior that's a weird build I have there anyway I have some slide malfunction uh I'll move over um so C++ does not have an AB res resilience model so there's no official um codification there um the C++ committee will just outright reject any proposal that could break ABI in existing STL components danela is shaking her head but I need proof that that this is happening that proposes that Break Stuff are accepted I need proof um okay they're not rejected but they're not considered am I doing bit this better okay I'm looking constantly at danela to see if she shakes her head so but I need proof that someone uh got a proposal that breaks something um okay C++ will not officially commit to guaranteeing ABI stability either so that's interesting so uh we we frown upon standardizing stuff that could break clients but at the same time we're not committing to stability officially and of course this is the tricky bit where uh people usually point fingers at implementers and say uh that they holding back on improvements um on existing standardized stuff and implementations that uh could be improved but implementors choose not to do them because then they will hurt uh adoption or upgrades and so on so that's another thorny issue okay uh okay now I'm getting to what danela mentioned so uh in in in in the prog discussion uh the committee decided it's not in favor of breaking AI 423 so I I qualify that properly um is in favor of an AI break in a future version of C++ but when that will happen we we don't know um we'll take time to consider proposals requiring a break as in sure uh at the same time will not promise stability forever so we're not committing to anything here and of course as always we want to prioritize performance over stability and I often hear uh some of these arguments uh mentioned in in in this topic but I I was so uh pleased to see them all on one slide and this is not my Slide by the way it is from um herb skot at CPP con this year I put the link at the bottom so the the most frequent thing I I here cited is the um standard string implementation uh where we did uh maybe I I don't need to spend time on this are people aware of the breaking change that happened in C++ 11 just a few hands unfortunately okay then I need to explain it uh very quickly so um the implementation requirement in C++ 11 when we introduced move semantic into the language was incompatible with a one of the existing implementations uh in in standard libraries U mainly the uh GCC one uh and that one used reference counting um and that was a breaking change they were incompatible so in order for that implementation to become standard compliant they had to have an alternative string implementation that was of course incompatible with the other one in many ways not just ABI uh so that introduced a sort of fragmentation in in in the users of of the library because many of the users had to rely on on the old behavior um and at the same time others demanded the the standard conform implementation and this was happening for over 10 years I think until everyone just on boarded on the on the new one so these kinds of horror stories are cited usually for um what can happen when you mismanage a situation like that and just throw people into a a corner and force them to decide and of course the the implementation let you op in uh in either of the implementations so you you you could op in for the reference counted string or for the the one with move semantics okay so uh why do we want to break ABI uh a few examples from the C++ world making standard regex faster also adding utf8 support tweet um making hash containers faster or having the ability to swap out the hash algorithm easily in their implementation um better conformance uh twixs to string vector and other container layouts um an interesting one if we're mentioning uh we we referenced calling conventions earlier uh ability to pass uh span string view unique pointer uh through registers uh rather uh than memory uh when calling functions this is more of a language thing rather than Library Thing but again it's a breaking change uh improving the implementation of Shar pointer um improving standard mutex uh do people know that shared mutex is actually faster than standard mutex on Windows does that surprise you it should because it's a more complicated class Shar mutex is is more complicated but because it's newer it uses operating system Primitives that are are more efficient uh the old one had to support Windows XP at the time uh and uses some synchronization Primitives that are less efficient because they're everywhere and if you change that in the existing implementation it is an API break because we're we're changing some of the internal structures so yeah share M exist faster for now so design choices again um languages like C++ rust carbon always prioritize a faster code they usually want heavy inlining um they want go for CPU um saturation and utilization mostly people in these um ecosystems prefer static linking whereas um in Swift um there's a strong tendency to prefer small code and and be iach friendly um also fit into smaller devices um outlining is the thing by the way how many people know about outlining I know everyone knows about inlining but outlining one hand in the back I won't put you on the spot I won't ask you questions but I have a slide uh and mostly Dynamic linking yeah they they want to share libraries so uh very quickly this is an interesting one U and by the way I linked two very nice presentations the first one um by Jessica pocket is a shorter one if you want to get started but it's a slightly older version uh the one at the bottom is a newer one uh but it's a longer presentation that includes many other things um so you have multiple choices when when opting for an optimization strategy when compiling you can either PRI ize speed or size and on on the extreme of sizing this is the outliner where you can actually uh use an and this is implemented in in lbm by the way uh you can the the compiler can actually look for similar sequences of uh instructions and sort of make up functions for them and and move them out of line so that it reduces uh code when it identifies similar patterns in code it's a very interesting thing uh I find it uh just from I don't know nerd point of view I find it more interesting than inlining uh definitely more newer research domain anyway um a side closed so uh for those who don't understand why I had Swift in the name or why I'm mentioning Swift or uh why I'm discussing Swift 50 is because it was the only one in the previous slide that had a yes instead of no in the in the bullets with all the programming languages that care about ABI stability so Swift actually invested a lot of time in how to do library Evolution and how to uh build an ABI resilience model so we can have both we can evolve things and we can have a resilience model that works so that we don't break everyone don't worry it's not all uh ponies and uh rainbows there are some gas I'm going to mention them uh so uh Swift who for those who want a primer so it's a compiled language it's not a dynamic thing um it was created to replace Objective C so it shares um the memory model in the runtime with with objectiv C so it has some some Legacy it wasn't like a brand brand new thing it had to interoperate with with the existing stuff um it has classes and inheritance interfaces generics every modern language facility that you might want um it uses automatic reference counting for uh classes um has simple function scoped mutable barrows um you can add notate arguments uh um nicely uh Ines own value semantics for structs and primitive types and only classes are considered reference types and are boxed using um Arc and they have reference semantics because they need to interoperate with the the old Universe of uh the Apple U libraries and Objective C apis so that was the bridge with the old world um and even collections Implement value semantics using things like uh copy on right and Arc under the hood so Lang the language was designed with Library evolution in mind uh and I think this is essential um principles of uh stable Library Evolution that they have is to make all promises explicit not imply that something is stable if it's not uh delineate uh what can and cannot change in a stable Abi very clearly in documentation so provide concrete commitments rather than hand wavy stuff like we do with C+ plus uh provide a performance model that indirects only when necessary so you don't have uh so don't pay performance costs when not needing and I'm going to show some of these tricks and let authors of libraries and consumers be in controled by having Escape hatches and opting in and out of these things uh I highly recommend this talk by dog Gregor um if you want to go deeper so just a very quick example don't worry I won't hit you with swift code that's the only Swift Code I'm going to have maybe one more slide uh so let's say we have a a structure uh and we might decide to reorder the the ID field at the top so we moved it up or we might decide to change its type from an integer to um U ID or we might decide to add an optional by the way the question mark isn't like pondering the universe it means optional in Swift uh so um maybe adding an optional color uh at the end of the structure there so the the structure evolved obviously it changed size um when the fields were added offsets of fields changed because we reordered stuff so stuff changed and if we're looking at the other side someone consuming it we have a a member there of that type and we have an array of those things so size and stride come into play there uh we're directly accessing um that field the name field there so we care about where it's in the structure because we're directly using it we're not calling any getter on it so on the library side of things type layout should be as if we had the complete view of the whole program so um the the person Library should lay out its type without any indirection uh and the metadata required to expose layout information should be a side thing a non-intrusive thing and we need metadata like size alignment offsets of public field so think about having all these kinds of details on the side like bookkeeping of describing this um this type layout uh and these kinds of things uh can be automatically computed uh can and we have two strategies uh I'm going to show concrete examples there uh of being able to have them as computed properties Swift has the concept of computed properties so they sort of work in a similar fashion uh so they can be computed at runtime or get this step can be bypassed completely at compile time when no runtime decision needs to be made and I'm going to explain when we can switch between those two strates so on the client external code the the external code indirects through layout metadata so to access a field it needs to read metadata for a field offset for example add that offset to the base object to figure out okay where inside the structure is my name field and cast The Pointer to load the field um if we want to deal with the stack we have to do a similar thing so we you you can actually do similar things even on the stack um uh read the metadata for the size of the instance and uh work with API such aloc okay um to set up the stack as needed where it's different is on the Library side of things the library code can eliminate all this IND Direction so you don't have to go through the um P pseudo computed Properties or to retrieve that metadata size because you directly have direct access to the layout of the the person structure uh from inside the Library code so there's no need for runtime uh computation and to um access that metadata so and this hash actually has some uh llvm support for example um I mentioned laying this out on the stack um llvm has support for dynamically sized things on the stack and Swift makes use of these so uh you can have a local variable uh of some struct defined in a stable library and you you don't have to to know the it size that compiled time you can you can compute these things at low time for example if you're consuming this from a from a dynamic library from a shared Library when you load that Library um the the loader can do all these uh metadata queries and they it caches all these things for performance so it only does it once when you load the library and it keeps a a side booking uh table for all these computed offsets because they they don't change once you have the system running so it's not like you're hot patching things um but you don't know them at compile time so when you load them in uh when you do a deal open for example these things are computed and cached um at runtime so uh and and llvm has this ability to to dynamically lay out these things on the stack for example if you want to store them on stack so you're not confined to um hi Hep allocations you can actually Leverage The the stack so how does um Swift handle this juggling between uh when I want to be resilient and when um I want all the performance so uh Swift does this using resilience domains uh so these are parts of your application that are where you define some boundaries for example parts that are always compiled together are part of a resilience domain for example the person Library there so all the green stuff are separate domains so uh all the stuff that it's compiled together are part of a resilience domain and inside that domain they have intimate knowledge of their layouts uh and and they don't need any special handling whereas when you have connection so the arrows between the resilience domains when you cross these uh resilience domain boundaries then you have to do this runtime patching where you uh need to compute those exact layouts using the the exposed metadata so uh you only pay the cost of of ABI resilience of this model you only pay the cost when you cross these boundaries so across resilience domains you maintain a stable API so users see a stable version of each other or at least a predictable way of interacting with each other and within a resilience domain all implementations details are fair game you can change stuff you can no no indirections no no performance Cost U no guarantees made so it's it's as if uh no such system is in place um and of course op ation need to be aware of these uh boundaries um you can go all the way up so if you to the extreme you don't care about you say okay I don't care about this at all you can consider everything uh single resilience domain you say okay I'm completely in a bubble I'm I don't care about the world um so you can consider everything one resilience domain so uh everything is fixed at compile time no cost you don't pay for anything so that's the extreme case but that deits the whole purpose um by default a type that is defined in a dynamically compiled library has a resilient layout that's the default size alignment stride of that type aren't statically known to the application uh it might must ask the dynamic library for uh its uh value witness table values witness table is sort of similar how to how V tables work or the same kind of thing uh it's a it's a it's a side bookkeeping uh information that you query at runtime um so it this is where you go to figure out for every type that you deal with to figure out its layout everything all the details required by its layout and I mentioned this is um cached information so you you um you do these uh calculations these synthetic values just once when you load that library and then you just uh have the values precomputed but it is an an indirection uh but it's the kind of thing that you expect from I don't know uh vtable access uh inside the boundaries of a dynamic Library where all the implementations are statically known the type is handled as if it's not resilient so no indirections no performance cost no nothing I mentioned that already what I love about this is that it's a default so you have to opt out of resilience if you don't want it uh and there are some Escape hatches a few of them uh for example you uh you can choose to explicitly inline a function and that prevents any changes to the function semantics because it's inlined in in in the usage location in the color so of course you cannot change its implementation because then uh you're going to have multiple versions of of that thing uh so when you op into this mechanism of course for performance reasons um you give out any um any future flexibility uh fixed layout it's another attribute that you can use to be explicit to say okay I want to opt out of resilience for this type I know I'm never going to change it famous last words right uh but in all fairness this is called pair what else can you do with it uh but anyway Famous Last Words fixed layout uh so you'll get a FAS fair if you switch members yeah possibly yeah if there are different types you could get that sure that's a good uh good argument um yeah uh so sorry it's fixed uh so this is another escape hatch for for a type um of course I mentioned this is not all perfect so there are some difficulties and some disadvantages of course um you have a fairly large runtime component although it's a statically compiled thing and it's highly performant it's an operating system level language and runtime it's a fairly large runtime it's not a thin thing like the C runtime for example right so you have the runtime type layout you have that those operations that need to happen when you load the library I mentioned those by the way you cannot really safely close a dynamic library because bad things will happen um you have handling of the metadata at runtime you have those witness tables and IND directions that you need to deal with generics are particularly hard to deal with uh and this is the part of the talk that I actually cut um but I I'm happy to talk about these things um if you want after that uh so there's techniques uh because dealing with generics in a resilient matter is very very difficult so there and this is because for performance reasons you generally want monomorph isation for generics um that means uh have Stamp Out concrete types uh for for for for particular generic types that you're actually using in the application uh but that prevents uh having uh monomerization commits concrete layout to those generics uh and those are and there are techniques to to go the other way like reabstraction anyway I won't go into details because I prefer to have uh more discussion and afterwards so um every language featur is harder to design you don't get to escape this one so sure you have the flexibility of having uh resilience domains uh but you have to think about when you're designing things you cannot just blindly uh Blast Away uh any any proposal for a change without thinking about the consequences for example uh reordering a pair for better access um so and there's also because of the deployment model because uh these run times and libraries um in Swift are deployed with the operating system uh you have weird limitations where you you're compiling a thing and you want to use the I don't know fancy new language feature um but if you're targeting an an operating an older operating system version you cannot really use it because then you'll have an older runtime and so on so there are weird um artifacts like that so it's not perfect I'm not claiming to be uh I want to close on a sort of positive note for C++ um there is I think there is a path forward even for C++ it's not Swift like but we can learn from from that uh so um Leb C++ aims to preserve a stable ABI to avoid subtle bugs yeah no surprise there um and at the same time you want to make AI braking improvements and the user to be able to opt in so there's uh ways that you can specify which AI version you want at build time right now this is what you have uh one means and that's the default means stable two means whatever you have there give it to me and three is for later when two becomes the the stable one um so okay it's not perfect but it's it's a Way Forward um and if you always want to use the cut most Cutting Edge version there's a separate find that you can use uh this is a nice article if you want to read all about these uh these details so I have time for questions and uh comments I do accept comments as well uh so that's it I have um couple of minutes for interaction on on record or afterwards as much as you want [Applause] go please if you can please use the microphone so that I don't have to repeat myself uh hi Victor uh thanks for doing this talk uh I have a question uh just about your opinion so I have only opinions nothing else perfect so you probably know about scoped lock and how it is like a different name to lock card because that would break API exactly that seems a bit insane uh because same thing applies with with the the mutex example I gave yeah I'm not sure I agree because log guard is a type that is specifically designed to be inside the function right so it's not really designed to be uh on the inside of a class that is provided to you by Library so my question is do you think there is some reasonable way to say okay these types we really care about ABI and these types we don't care about ABI and uh uh kind of that's a separation or something like that thank you I wish there was uh but people don't think in uh in in in such a grandular fashion at least not in in C++ um I haven't seen such discussions uh so we sort of have uh this idea of um break everything or break nothing sort of uh when eventually we'll decide that we're going to accept the breaking change to the to the implementation and I'm not even talking about a standard uh stance official stance I'm talking about a vendor let's say a vendor decides to break things they usually see this as a okay this is our opportunity pull in all the stuff that we we've been holding back like open the floodgates like fix all the types fix all the bugs and then we'll freeze it again for 10 years so this is the kind of thing I'm seeing and I this worries me because this whale approach of uh sure we'll decide um next year or the next version of whatever great implementation we're going to do all the breaking stuff and we're going to land all our PRS that we've been holding for five years and we're going to fix everything and users be damned and then we're going to freeze it again for 10 years I don't believe that what you say a more granular opin approach and being more explicit on a per type basis it would be much more flexible that I but I've I've yet to hear some ideas in this space what all I see is All or Nothing people are All or Nothing um so you made comparisons with Swift and rust for instance uh which are to my knowledge controlled by single organizations uh I would also include Java in this uh kind of language and I've I think it's a bit unfair because uh C++ is a very diverse uh language con considering platforms architectures implementations um and I've heard this from people outside of the C++ uh so that come from rust for instance that say the standard should say this and this and this and should Define all these things and uh I'm not convinced why is ABI not an quality of implementation issue so uh provocatively you are principal engineer for visual C++ why do you need the committee to tell you what to do uh I I won't comment for for my employer here okay uh but I can comment on the hallway [Applause] maybe that's fine then let's yeah so my my personal opinions don't necessarily align with the business objectives uh then then then let's say it's about a different implementation like GCC why does uh why does the committee need to tell the GCC people what to do or maybe if you don't want to answer that's fine I I don't think they're necessarily tied together I think you are right to some degree it's an implementation quality thing but implementations have users and um the engineers working on those implementations would want to ship you the best possible solution they have they just have to think they have to choose right now they have to choose if everyone is going to be able to use the latest and greatest or um if they get to ship the the brilliant uh V2 or the brilliant implementation so you have usage constraints whereas um things like you mentioned like rust or Swift Swift has the advantage of sort of a although it's an open source project it's sort of a single strongand uh organization right so it has um more tight control over over its Destiny let's say also traditionally developers in that ecosystem are much more eager to um upgrade so they they they usually and and when they make changes that are difficult they also provide extraordinary tooling to help with those migrations they provide excellent tooling for that and they're very aggressive about it they will push their users even if it's uncomfortable they will choose the immediate discomfort for the long-term better outcome so Apple will push their users and generally they've that ecosystem of users expect this kind kind of thing where they're okay they might scream they might make a fuss about it they but they know they don't have a choice like they will modernize by force so although they have like a big um code base behind them so there it's a big Community they they move faster whereas rust has although it's it's a mature ecosystem it doesn't have as much code AS Swift or C++ so it's it's different you I agree it's unfair to to compare but my my point wasn't to to shame or compare my point was can we learn something from the others can we borrow something right uh not everything is applicable we cannot op into all the fancy things we see but um just ignoring what happens over the fence doesn't solve our problems if we don't have any better Solutions so thanks that's my that's the spirit the spirit is not uh like compare the spirit was can we learn something and we have proof that it can be done sure in a different environment but it can be done these are not unsolvable engineering problems all right thank you sorry Victor we we're almost out of time I'm going to allow Mark last question last comment comment yes excellent yeah I work on leas and uh yeah we have this unstable AI but there are really no plans to make it stable in the near future especially because ABI issues but there are some people who compile everything from scratch and they use the unstable ABI because of performance reasons so yeah so uh you support my last slide basically right yeah but the problem I always see is that's it's hard to uh no what did I do this one yeah but there are no conrete plans to freeze it too so I didn't claim that yeah but if you want at least there's a way to optain the latest and greatest there is a way for this implementation not for others so thank you uh anyway so uh we have to wrap up uh officially but I'll be on the hallway so catch me for [Applause] everything