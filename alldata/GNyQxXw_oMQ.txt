welcome back Brian it's been two years that we've missed you now due to covert precautions and you not coming over the Atlantic but here you are yeah one of your colleagues a bit of Weinberger certain Brian kernaghan and a certain Alejo blew us all into the weeds with orc it did so many things were vaguely known about in other languages but which I had never seen in one package before I mean I'd force myself to do associative arrays in snowballed just to say I'd done them you know that it was a joy and a delight and a mystery and yes it did I think was a breath of fresh air for the community to show what a scripting language could do I guess it's getting rather long in the tooth now but I do notice that every time I guess a different Linux orc is still there it's not something you usually have to download it's really I guess there's a lot of stuff out there that does depend on having it around but I'd just love to hear your thoughts about what it's good for what it's bad for and the gotchas that can sometimes so I mean a lot of a lot of the Youth of today hiding fans say to me why do you use your walk at all why don't you use Python for everything so here's a man to ask well it watched that long of the tooth stuff because none of us are quite as young as we used to be but um no I I you're right uh it was a hell and Peter and I worked on it in 1977 originally a very short development cycle and it was intended as something that would make it really easy to process text and numbers in the same program with roughly equal ease or facility and I think it's probably the first really widely used scripting language you mentioned snowball four um and certainly I was I knew of snowball horror because it was developed at Bell labs in fact but I'd never really used it but that's where the the original idea for associative arrays Camp rep so an associate of array just for clarification is an array whose subscripts are not necessarily numbers but could be arbitrary let's call it strings of text something like that and certainly associative arrays are a very very useful thing and if you're only going to have one data structure that's the one to have because you can build everything else with it if you want you've done a video on that point as well yeah talk about long of the toothbrush replaying our lost youth or something like that but why would you use it today and I think the answer is that it's an example of what's the right tool for a job and there's not a single tool that works for every job some some tools are great for across a very wide spectrum of things and you mentioned python Python's obviously a great uh tool for all kinds of programming things and I would say if you're only going to use one program in your programming language in your life python would probably be the right one because you can do so much with it and it has this incredible ecosystem of libraries packages modules whatever that people have built so that's fine but there are places where it's overkill for what you want to do and what you want to do is something really quick and dirty you've got some kind of data and you just want to see quickly something about it gee what's in some particular column of a collection of fields or you want to just add up some numbers something that you know in your heart you could probably write in one line if you had the right language is the languages let you write it in one line because it takes care of a lot of the bank that you would otherwise need in some other language python you need the baggage of how do you get the input how do you split it into various components how do you write it out and all of those things happen for free and Arc and that's one of the reasons why Arc is our programs tend to be very very short compared to programs in other languages they run at about the same speed as they would in Python so yeah the the Gen generally used for short programs and very very useful it is too but you've got to be careful because it's essentially a pattern match language as to what gets done next it's not a straightforward linear flow through like it you can trace through a c or even a Python program you've got to be asking all the time okay well is this going to pattern match oh it does what do I do now and my worry always is that all my inadequacy as a programmer is shown up by the fact that the longer my list of matches gets the more I'm scared stiff of getting a premature match or a too late match because my ability to handle stacked up regular Expressions isn't as good as Orcs so you do have to be careful you can get matches you never expected right so let me back off for a second um because just in case people haven't seen it or don't remember the idea you know I guess as you say it's a pattern action language and so in our program is a sequence of patterns that will match against the input and each pattern has an Associated actionable issues what do you do when you see one of those in the input a typical aquagram only has one pattern and one action and maybe only the pattern or the action and so you don't run into that problem that you just described where you've got a long sequence of things and you have to get the sequence right typical program is short the patterns are obvious and yeah have a natural sequence and so that works out very well but then this kind of gets back to something you mentioned before what's the right language for the a particular kind of job and I think if you find yourself writing something it's very very very very long you know it's maybe not the right language for it that you're better off perhaps with something in let's call it python or some other language that you like the trouble is I think is that an awk program very often starts small you just got one or two things to do and then you say oh but I could do that better and you add some more and it tends to grow as all programs know that exactly and and so as a result the program evolves from something that we're very clean and simple into a Rat's Nest of stuff and this is true I suspect of all kinds of programs not just in these just different different kinds of rats nests on it yes do you keep it under active maintenance in some sense and are you anyone do you do four wall releases anymore affordable releases is too strong what what it is it's been on GitHub for quite a while now and um I haven't been doing very much active development on it most of the actual work is um Arnold Robbins who is the uh actually the maintainer purveyor of gok the gnu version of OC but Arnold is incredibly good at this kind of thing very very uh a good friend who is managing among other things making sure that Arc in the original version of it stays up to speed as well so I think of him as actually the person keeping an eye on it so he's got lots of killer test Suites Jose I've had test Suites for a very long time and Arnold has certainly augmented those the thing that I've done most recently uh it's always been embarrassment that awk only works with ASCII or or maybe 8-bit inputs but it doesn't really handle Unicode at all and so a few months ago I spent some time working with an incredibly old program um and and I have it at this point where it will actually handle uh utf-8 input and output so that you can have regular Expressions that you know pick up Japanese characters or something like that and that appears to work correctly it's sort of in a staging version on the GitHub site at this point and so that that that was actual real work trying to understand old code and insert something into it I think I've got it right but you mentioned tests it needs more tests yeah entirely me um the other thing I did was just a quick and dirty uh thing to make it possible to handle uh CSV inputs comma separated variables because that was never really done and so now if you have the kind of straightforward CSV input cool yeah something quote it will handle that properly on input so but that's that's basically all the development I've done uh the question of how do you test a program is is fraught um and and obviously uh big companies and even small companies spend a lot of their time in resources in testing code to try and make sure that it works because often it doesn't uh so for a very long time August had uh a test Suite quite an extensive test tweet at least for what we call amateur programming uh with probably thousands a few thousand tests that are all run completely automatically so you just say test me and it goes through and if not if everything works according to the test then you hear about that if you make a mistake the tests should in principle tell you whether it works or not and some of the tests are regression tests did it produce the same answer this time as it did the last time uh because that tells you if you change something something broke you got to figure out why some of them are sort of absolute tests where this program has to produce this output you know what the right answer is and it's not a question of what we did before but it there is an absolute right answer you know one plus one it better equal to two um and some of those are for specialized corners of the language like the regular expression mechanism yeah so there's a kind of a sub language in the testing which says this regular expression should match this and this and this but should not match this and this and this and so there's a bunch of there's hundreds of the very early days of all then was that what uh Al AO brought to the party as it were what Albert was basically regular expression technology and understanding the regular expression parsing in awk the recognition mechanism is essentially the same as it is in egress which L did as well um and it's fundamentally uh a highly efficient lazy evaluation of convert a non-deterministic finite determinant into the equivalent deterministic finite automatic but do it in a way that you don't get the explosion of States yeah and so and you don't spend forever building the recognize yes and so that was a really really really nice piece of work the code is pretty what's the correct technical word inscrutable yes but yeah but I uh fortunately I was able to figure out enough of it out that I could put in the UTF processing Unicode processing inside well done you yes but Al had been interested in regular expression technology for a long time so for our fans who don't know who our aho is I'll leave it to you Brian it's from Finland isn't it uh no he's actually from Canada but a Finnish Heritage somewhere back in time on his family it was finished and uh I if I recall correctly he actually speak some Finnish but it's not his native language at this point he's dreadfully difficult to hyphenate in Finnish he once told me well it's a nightmare yes but do carry on so going back again into the midst of time um Alejo was in fact an undergraduate at the University of Toronto a year ahead of me he was a graduate student at Princeton a year ahead of me he went to Bell Labs a year ahead of me and we were in essentially almost adjacent offices at that point and he's been variously my boss and of course Frankfurt at this point creeping up on 60 years but uh Al was very much interested in formal language stuff and that's I think we're part of the interest in regular Expressions came from and then he did his PhD thesis at Princeton that sort of thing and a lot of the work that he did on language design and implementation to compiler technology theoretical as well as practical I was actually recognized he got the Turing award last year along with Jeff Allman so obviously very serious computer science person that as well as a super nice guy yes so he's LDA in orc yes yeah and the W is Peter Weinberger who uh at the time we did it I occurred to me uh just as I was sort of thinking about what we might talk about today it occurred to me that Al and Peter and I were in a sequence of offices adjacent so the name is just obvious actually it's a pretty lousy name but it's it's okay no it's fine I mean I I suspect you didn't mind your initial coming last although that's not alphabetically correct largely because you can't think of any other sea bird called an aqua or something yeah Peter uh joined Bill Labs a few years after L did and after I did but by just luck of the draw very excellent luck he wound up in this office between us and uh so we worked on this together Peter has uh spent time at Renaissance Technologies in New York hedge fund kind of thing and then uh has been at Google for a very long time at this point working on things like go and so on but superb mathematician and cryptographer kind of person in the background yeah oh well I I'm flabbergasted I just obviously I'm not keeping myself up to date I didn't I did not realize that Al had been given the ACM touring award well very well deserved because I think one of the things that really struck me about all that he's done on eogrep and therefore behind the scenes on organson is that um he is remarkably pragmatic at times and not theological about it at all a number of of his own rules as it were that he just breaks because you can you can see immediately that on a problem this small it's not going to lead you into huge overheads and so on um I mean there are so many things in egrep that a purist would disapprove but that's his great strength I think oh yes in fact I came from a sequence of ideas one of which was grep which is the pattern matching program which I'm sure we've talked about in the book you've done one on that where did rap come from you've done it yes so we did that one one of the basic things in grep is the regular expression the pattern that you are looking for that is what grep is looking for in the input so egrap where e is extended basically said let's take the patterns that grep supports which is a particular class of regular expressions and let's extend it to a broader class of regular Expressions that are harder to recognize and that's what Al did he took his expertise in automata for recognition and made this thing which was a combination of excellent Theory and excellent practice and that is the program called egrep yeah and then Ark takes some of those ideas the patterns in Ark one class the patterns are regular expressions which are of the egrap class so that you can recognize very sophisticated kinds of patterns with uh an arc program and it's not the only kind of pattern but but things that involve very good Expressions use that Egret mechanism and in fact the code in Arc probably was just transliterated by L from what he had in egrip and then made to fit the framework within awk right from the very beginning your releases of Unix have had no end of text processing Tools in one source and another but what sort of texture bases were you drawing from what what were the problems you were trying to solve and this yeah that's a great question I think and this is a place where memory probably failed in some sense but clearly you start from the beginning it's a programmer's environment Unix is a programmer's environment so you need program you need a program like a text editor to be able to edit the text of the programs that are going to run on your system the operating system itself and all of the applications so you're manipulating text at kind of minimum level then you need to be able to find things in text of whatever sort and so the Genesis of grep which we've talked about is just to take the text editor rip out the uh preserve the regular expression pattern matching part of it uh I think a further extension of that then was Lee McMahon was very interested in uh basically linguistic stuff I think he was fundamentally linguist as opposed to a computer science type and he wanted to be able to process text and he had things like The Federalist Papers which at the time where G is a megabyte or two of data that's huge yeah and today is down in the noise but he wanted to be able to process those things and those were too large to fit in the text editor of the time so he built this thing called The Stream editor said so that he could stream The Federalist Papers past a sequence of editing commands to extract information that he wanted or modified along the way um and so that was I think one of the things that came into awk this idea that you could process text very easily with programs like grabman said but could you do more with it um and so I think that's part of it and then other people start to be interested in text as well uh for example spelling correction or spelling mistake detection not correction that Doug McElroy was very interested and for that you have things like well you've got text that people are writing because people were writing technical papers they were writing books and we had a dictionary that's all of this again fed into the there's lots of text you need tools to process it and and then the other side of that I guess was the formatting stuff of you've got text and you want to print it neatly and that's where you and I yeah started long ago and interacting on how do you process text to make it nicely formatted but I think in many ways it's that that emphasis has been in your favor because I remember the culture shock of coming to Unix which is simply wonderful and coming from the background although frankly you just didn't figure in the Computing firmament unless you'd really come from a background of inverting 100 by 100 matrices in less than a second and this sort of thing you know it was such a refreshing I mean text for many years really before Unix came along with its tools was definitely a second if not a third class citizen uh and if you weren't careful you'll be taken away in a wagon labeled COBOL or something like this and it wasn't seen as being part of everybody's concern to want to go have good text handling tools I think there's two parts there one is a big part of computing originally was engineering computations scientific computations for which Fortran was great but Fortran is terrible for text right the other side of it was let's call them business computations like I want to send out invoices I want to do payrolls and things like that and Cobalt is good at that kind of structured record-based stuff and it's terrible at lots of other things um and so there was this kind of Gap there or set of applications which were neither scientific computations nor business computations but they just involved taking you know strings of characters and showing them yeah and I think Unix fit that almost by accident perhaps because the machines were too small to do any serious scientific computation the early Unix machines didn't even have floating going Hardware no all right and so it was hard to do that kind of thing and nobody had any interest in business computations of the Cobalt sense I think I do remember it was a huge culture shop for me but came across Cobalt and it finally dawned on me that a lot of my problem in understanding what it was doing was that it was actually doing arithmetic on what came down to being character representations rather than pure binary in fact if you wanted it in pure binary you had to ask for it to be done that way and I thought I mean it hadn't come from as you say a physical sciences background I thought what other way is there other than the whole thing a floating Point numbered so many places and then several it's a fine because it's like a halfway house between that and what we're talking about associative arrays is treating characters as first-class citizens for a change yeah no Cobalt certainly did that although it tended to be if I recall I haven't written Cobalt for a very long time fixed record links there was no not something that's right but the other thing is so if you want to do Financial computations you have to do them accurately and floating point is not right the pennies because otherwise you know Sean you're doing all this wonderful stuff then on all coming you're not just going to sit on it and not release it presumably there is going to be a formal release for this and this bountiform questions like uh in what uh text processing language will you be writing this new Endeavor then if it's not you know written in orc itself right yeah so I think part of the trigger for trying to do Unicode in uh art was conversations that I've had with Alan Peter and our editor at Edison Wesley but whether undue version of the awk book would be appropriate the art book came out in 1988 so it's getting kind of long in the tooth as well um and so I thought what the heck a summer project while I'm on vacation in England would be to work on the a new version of the art book that would you know deal with things like well we can now represent Unicode characters at least plausibly but I think more generally the Computing environment is just incredibly different today than what it was 35 or 40 years ago machines are you know 100 to a thousand times faster memories are a million times bigger and that changes the way you think about things it used to be that you couldn't afford to run awk programs on big data now that's not true it processes megabytes in milliseconds and so uh that changes the trade-offs that you might make it changes the when do you move from let's say OCTA python to C or C plus plus or that kind of thing and so so I've been doing you know in the background playing with a new version of the awk book which one hopes we'll see the light of day but I don't I'm not going to commit to a schedule thank you um and I I guess the related question is what technology do you use to produce such a book when we did the first book this was kind of the high point of tools like t-roth and the related specialized languages that that you and I have talked about over the years um but what what's today that we would do trough itself is at this point you know kind of pretty much unmaintained although there is the wonderful giraffe uh that James Clark did that is absolutely a beautiful piece of work compatible with t-roth but at the same time lots of useful extensions that make it a lot easier to actually use in practice um and so what I've been using is g-roth yeah and the associated things like the table processor and the picture processor and so on that were all done as part of that uh the big problem is that t-roth doesn't really handle Unicode output very well and so I have yet to figure out the proper mechanism for that that's on the list shall we say and I'm I'm not sure what to do both I genuinely don't know yes we have James talk a big vote of thanks absolute stuff to my amazement you haven't decided to transliterate it it's all into later I can do it that way I'll let Shawn edit that one out as seamlessly as he can no but but you raise an interesting question I I literally yesterday I was looking at a version of tech which uh claims to support Unicode full Unicode with full proper uh Unicode character sets that is the glyphs that you could actually put on paper or in a PDF file um and I at some point maybe that's the right way to go I honestly don't know but that's a very active uh piece of work I think it's called xitech ztec I'm not sure how it's pronounced um but to Tech has a very very very big operation and I was going to download it as an experiment and they wanted five gigabytes and five gigabytes at the particular out in the boonies place I'm living would not be finished yet and so I'll wait till like yeah yeah yeah to investigate it yeah but if somebody else has done the work then I think that I could with a program not a knock probably in Python convert what I've got into something that would be proper intact input for a tech like latex or whatever um and that way somebody else would be doing the heavy lifting but at this point I honestly just don't know the last version of the book was in 1988 so uh so my question is where do you store stuff like that because is there like a floppy disk lying around somewhere some of these things you just carry with you over multiple versions of computers and so I actually still have all of this stuff I think I think I might even I have the post script I think that we used for that that predates PDF I've got no end of stuff in that room there related to rescuing your vacation memo and getting an early enough version of t-roth that would cope with it without me having to change the source code at all you just got to get the fonts all lined up in the way they used to be and uh actually what has always struck me with this is that when you have there's some vital component that was part of a release from Bella probably had to pay a fortune for it nowadays if you just dare won't use the verb grep for it some kind Souls made it publicly available rescued me so many times yeah and particularly going back to those you know very early days you think oh my gosh here were here was my version of the MS macros what was it like at Bell Labs at the time you can usually find out you can often find out yeah the Unix Heritage society's done a marvelous job of collecting uh all all software yeah over much of the history of Unix as far as I can tell and then some people are as a laborator of Love picked up a piece of code at some point and carried it forward and made it still work I found a version of graph I couldn't get my own version of grab to work but I found one on the web and somebody got it and it made it work and it produces essentially the same output so I've forgotten the name but I'm grateful to him or her oh of course I remember now I've used it quite a bit but not just recently yes yeah to then one of them might be a little bit bigger and one of them would be a bit smaller but they'll multiply together I'll just say thanks to Steve for our second camera over there thanks for showing for our first camera over there sorry for walking again will it be at least twice as good because it's got two cameras I mean