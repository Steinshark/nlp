um before we start who of you is already knows what tdd is or has been in F's great talk right now okay all of you that's great uh I assumed so much who of you is working on microcontroller okay about a third great so all the rest of you will get an impression what the difficulties in embedded really are um the ones who already worked on microcontroller maybe get a few new ideas how to apply tdd but first maybe a little bit of background so I used to be an embedded software engineer I worked in safety critical systems so when I got there I assumed there would be a lot of testing there I mean even before I was a before I was an engineer working in traditional software like server backends and desktop programming and even like 15 years years ago it was pretty common to do unit testing uh in this traditional software development some people even did test driven development so when I first came to embedded um I was astonished that unit testing is not really used that much and tdd was basically unheard of and I think this is still the current situation I mean more more and more people use unit testing but tdd is mostly not used deeply embedded projects so in this talk I will want to get an give an overview what the obstacles are if we can use tdd and um yeah present the state of the art and give a few ideas how we can improve from there so this will not be a talk about tdd itself yeah um we just saw all of you are basically familiar with tdd so what what's important for this talk is this tdd micro cycle first write a test um have a failing test because there's no implementation yet then you get the implementation right and you get to this green part and then really the magic kicks in because you have to safety net if you developed all the parts of your application of your program with tddd you can freely refector change things and you fall back to your tests and you know you don't break anything this is really for for the sake of this talk the most important benefit of tdd and this requires and this is really the heart um a quick and automated feedback loop feedback in this sense you try something and you get feedback if it's working as intended now tdd was made Popular by Kent Beck so um all of you want to read a good book test driven development um it's still relevant it's from 2002 but it gets the basics um really good so I highly recommend it so what's different and embedded than in traditional software in traditional software when you want to try it when you want to get feedback you run the program yeah and the in the most simple situations you just click on the binary run it click through the application and get to the part you want to test yeah it's a manual test but you can just do it in embedded it's totally different to to test something in embedded you need to get the microcontroller get the hardware you need to flash your binary on the hardware and then you need to execute it there and you cannot click through it in most cases um you need to use maybe sensors maybe send some data to it to get it in the relevant parts of the code so this process is much more manual and timec consuming yet um this this Ray here of of trying code is really like the standard yeah a lot of people working on deeply embedded stuffs do exactly that so in traditional desktop programming or traditional programming we got unit testing to test isolated parts of the code and this is really the the core of tdd yeah right good unit tests and the key of unit tests is that they focus on some parts of the code and basically can ignore the rest you abstract away all dependencies and then you can focus on Single part this means for example if your application has a dependency on a database you abstract away the database insert a mock or something and then you test against this abstraction and you can focus on on your code and the question here is can we do this in embedded abstract away all the code we don't need and focus on the parts we are interested in can we use things like unit testing and embedded and in 2011 there was really ground breaking groundbreaking book on it test driven development Med C from James granny who read this okay only a few people I can highly recommend this one as well um it's fully applicable to embedded C++ as well um it deals with how unit testing can be applied to the eded word and the important principle he established is so-called dual Target testing and we will first now focus on Dual Target testing so basically I will explain the most important Concepts from the book and then we will see what is still missing and how we can proceed from there so dual Target testing means you run your unit tests in different ways on target testing the part on the left means you run your tests your unit tests on the microcontroller so Target means microcontroller in this sense so to do this you need need to develop code and test you do this on your host yeah your desktop machine then you cross compile it so you use um embedded compiler like mgcc or Kyle you have a binary and you can Flash this binary to the Target and run the test there and of course you need some way to view the results on The Host this is called On Target testing you test on the microcontroller and it's kind of slow um because you have this Hardware dependency and it's a little bit difficult to automate so James grenning proposed a second way he called it of Target testing and in of Target testing you execute the test on your machine so you don't cross compile you compile with your standard GCC um you run your tests on your PC and you view the results there this is obviously much faster you can even run it on the CI so what kind of code can we test with of Target testing and what kind of code do we need On Target testing for let's first start with off Target testing to do off Target testing you need to comp compile your code with your desktop compiler um I brought a function here uh cc32 it's basically calculating a check sum and returning this so the inputs implementation is not really important the inputs are range of bytes and uh the output is um a 32bit value so this stuff is supposed to run on a cortex m33 three so an arm cortex controller can you just take this code and test it off Target on your machine okay why not exactly exactly we can't uh this header here probably won't be available on our desktop machine yeah usually a lot of these headers are just shipped with the tool chain so they belong to the compiler and they won't be available here or on our PC fortunately if you take a detailed look at the function this header in this case is only used for some custom 32-bit uh definitions and that means we can decouple this code we can say oh since C++ 11 we have this standard header STD int and a 32-bit value is in the standard so the code can be generalized to make use of the standard header and now it will behave the same on the target but we can also run it on our PC and this is great because of Target testing is the fastest way to develop and test code so we can write a unit test like this yeah give it some sample data uh run the function on it and compare it to some magic value yeah we get from some some example or maybe there are website generators for for CSC um we can get somewhere and then we know the implementation works uh you can screw up a lot of things in CSC calculation it looks simple but there are so many parameters uh you easily screw up okay if there are any questions by the way please feel free to just uh raise a hand and interrupt me I think we have enough time today for that so what is of Target testing uh what do you need to establish it you need a certain setup and for most Ed projects um who don't use this yet that's a new thing they need to set up a different tool chain yeah you need your your primary tool chain is your embedded compiler like Kyle you need an add another tool chain like a clang or Microsoft Visual Studio code or GCC or anything else for your host so if you use cmake for example you can use these toolchain files to to give it another tool chain and then you need to compile um parts of the code that you want to run of Target and of course you need to integrate a unit test framework for that the good thing is here you are off Target on your PC you have basically unlimited resources so you can pick any recent um unit test framework like for example catch 2 and then and this is really the critical stuff um for for embedded projects you need to make sure to decouple the relevant code from all all Hardware dependencies it's really easy to get a hardware dependency when you program for for embedded microcontroller yeah maybe some some included nested header is is some definition that won't work on your on your PC uh this is really the critical part decouple um especially for legacy projects okay but then we can run this code and we can have a quick tdd feedback loop so all the requirements are fulfilled we have automated feedback and it's really quick great so why we don't use off Target testing for anything there are two important limitations and the first one is there are risks and unfortunately even in safety critical systems a lot of people are not aware of these risks so I brought a slide here um with a little code snippet what you see see are two functions and Function One function two they are just printing out their name and returning an INT and there's a third function Fu taking two int arguments and also printing its name and in the main function you just call Fu with a return values of our two functions and if you execute this on your desktop machine of Target you get a different result than on target for examp example on the cortex M4 arm cortex anybody knows why this is in this case yeah exactly and this order of evaluation is unspecified the standard says this um is up to the compiler implementation basically so um yeah the C++ standard just says the order of evaluation of arguments is unspecified okay and this is a definition of unspecified Behavior it depends on its implementation so the compiler writer can basically decide which implementation he chooses and of course this can make a difference in program Behavior it's pretty obvious so of Target test would have a different effect than On Target um there are much more risks I won't go into details um there are other language specific uh things Hardware problems your Hardware can have defects um uh you can have bugs in the tool chain if you look up how many um open bucks there are in arm GCC you get really nervous and they are losing yeah each week more bucks are introduced than solved um most of this is rather um you you would hit these behaviors rather seldom but seriously if you do unit tests and you have an option to catch these things that will take you days and weeks in production to find uh why not use it uh so for for these risks to mitigate them you need to run your off Target tests also on the microcontroller On Target uh only then you test the object code that will really end up in produ um there's a second more fundamental problem and this is hardware dependent code so your CSC function could use some Hardware functions from your microcontroller so for example all these examples will be based on an stm32 um microcontroller and this controller has special function registers hardware pery for CSC calculation so you see this code really writes to this special function register here and here and returns some value of it and obviously you cannot compile this code for your PC uh your PC doesn't have these registers it just won't compile and the question now is I would like to write a unit test like before can I do this test this Hardware dependent code and the answer is of course you just just need to establish On Target testing and this means you have to take your codebase and again integrate a test framework if you use an embedded compiler um these compilers for all of you are not um working regularly and embedded um projects often have to use really old compilers uh for different reasons and these compilers don't support the latest C++ feature so uh sometimes you cannot use uh the modern libraries then you need to use maybe a c testing Library like Unity or cppu test but you will find a unit test framework that compiles also with your ancient um cross compiler so choose a unit test framework and then you adapt it so it compiles for your Target and somehow outputs the results yeah maybe stream the results to the U to the serial line and this you can catch on the PC and display so this is in principle um pretty straightforward um you can have automated feedback yeah you need a setup uh you can do it and this feedback can be quick the bottleneck is usually the flashing of the microcontroller but for many microcontrollers you can get down to like two or 3 seconds with decent tooling so it's Pro it's um possible to use tdd for this Hardware dependent code that's really important there there is there are no things preventing you from using tdd you can have this quick feedback loop which brings us to the I would call it state-ofthe-art in testing and this is pin Behavior I mean we are talking about embedded systems and they are called embedded because they are embedded in some environment and their primary purpose is to interact with the environment yeah maybe measure some some value with a sensor maybe control a motor um interact and this interaction happens through the microcontroller pins and only through the pins so a lot of deeply embedded code is about getting the chips to do the right on the pin level how can we test this Behavior I mean how can we test um this piece of code here it's um the the purpose is to set send four byes uh on the U and it's using the um Hull library from St it's called cbmx so basically within this yellow function here um the code will do a lot of accesses to special function registers to the periphery of the PIN to to get these signals on the line and what we need to what we want to know is if we write this code here will this have on the line that's a logic analyzer attached to the pin showing us the result and unfortunately that's state-ofthe-art you program it um and you look at the pins and this is really cumbersome because you need special setup you need to access a pins maybe you need to solder to access them uh you need special equipment like at least a logic analyzer but if you want to send data you need a Serial probe if you're working on C you need a can dongle all kind of pery and if you need it you don't have it or it's used by some colleague it's it's really a hazle it's really a hazle so what can we do how to test this manual based testing I just um um told you that and it's really the the common way um there's an alternative register based testing and it's I would call it industry standard but I think it's deeply flawed uh at least in the context of tdd so let me elaborate a little bit the idea is to not that we don't need to look at the pins the core idea is hey we have a specification we have our reference manual for all of you who don't know this is a very long PDF very long like a few thousand Pages filled with a detailed information on each page there's potentially important information uh it's crazily dense yeah but it specifies what happens if you write certain values to the registers and the theoretical idea here is okay we use that we rely on this specification and if we do what is written in the specification everything will work I don't need to test it um yeah so what does it mean here um let's say you are initializing the U here and inside this function um there will be a a part of the code that's setting the bout rate the speed at which signals should be transmitted so it should be uh 115.2 kilobit uh that's our goal so let's write a test for this using register based testing um let's execute this um code up to to the init and then we just assert against a specific register we look up the reference manual there is a about rate register it sounds great um so let's um assert against the content of this register the init function should set it so let's just test it okay how do we get this value and now it's get gets to real fun I mean Phil talked about the damine you won't get damine there I I will will tell you that so first you need to locate the chapter uh for this stm32 the U is in chapter 57 that gives you an impression already you you you you briefly look up how how long it is okay only 86 Pages that's okay uh you look up this register great you found the essential part and it actually doesn't tell you anything about the speed it tells you um I know this is a little uh small in in the back but the contents here not not not so important so it basically tells you um what bits you need to write to access a a value called user div okay that doesn't we need to look it up in the manual and then you find an equation and that's that's good the bout rate is some clock I presume divided by the divider by this user div okay great but what's the clock you go further and it's getting smaller yeah um you find the clock here and it's divided Again by some prescaler and another clock that's all in the U chapter so pretty easy 86 pages but the clock here this user clock it's described in a totally different chapter about the clock tree and this is really the relationship here on the left is your input clocks like an external oscillator And Then There are a huge number of configurations and then there is this clock coming out so yeah you need to know all these values to calculate the magic value for br to be sure that it's 115.2 kilobit and I think you would agree this is not fun but okay maybe we can do it but there is a fundamental second problem so the first problem was it's just complex to find out the correct values and it's not the problem is not so much the itself but the interconnections between different peripherals if you need to think about uard you will also configure the clock tree okay but you also need to configure the pins that for example this GPR pin switches to Art functionality and really prints out the U stuff so there are multiple components inter interacting with each other um so this is difficult to find the correct register values the second thing is much more problematic especially for tdd it's a white box test you test against a specific implementation because what what you did here is basically the same you would do when you implement it and whitebox tests don't fit into tdd because in TD you want this refactoring to work make changes to the code base and be sure that your tests catch if the functionality changes let's say you change the prescaler and the BR rate registers both by a factor of two this will cancel each other out the bout rate is the same but the registers look totally different so your test will fail so this is a fundamental problem in register based testing so sorry um we need to find a way to involve pin Behavior yeah to really test what is happening at the pins and not some thoughts about or or assumptions about our implementation test at the pin this is what what will drive success of failure in the in the production as well so what I will now tell you um is something we at my company um call open loop tests it's a new way of testing code that is Hardware related and make CH changes at the pin level so um open loop testing um makes three requirements first you need to have your pins accessible so you want to test on the pin level of the controller so you need to have it accessible second you have your code accessible so that you can call single functions in the code and see what they are doing and the third and most important one is you have to make your periphery accessible so that you can for example write a test that sends a can frame on the pins so that you you have a test system that can be configured that you can send frames on the pin level or send SPI commments or iarec or all the other Hardware periphery stuff there are a lot of protocols out there uh but on the pin level not in some simulation so um the following slides they are examples based on our execution platform this is our um first commercial test system for open loop testing but the principles I show you apply to everything else yeah you can with with uh the principles I tell you you can basically set up your own open loop test system so um what you can do when you have this kind of test system so the test system here this is important um integrates your specific microcontroller there are hundreds and thousands of different microcontrollers so um the test the microcontroller will be plugged into the test system now for our thing these little pcbs look like this so small pcbs with an connector and all the pins are on the connector and the chip is basically here um and then with this principle in place you can write tests um the tests uh for our system are written in Robot Framework it's an open source framework uh really good framework for all kinds of automation if you go into this uh Direction take a look at Robot Framework highly recommended and um all the functionality and the periphery is available here as keywords but yeah we have enough enough time I will make a brief demo let me switch [Music] here okay is it readable in the I can increase the size a little bit yeah it's okay great so what I'm showing you here is um an online version of Visual Studio code and this um Visual Studio code is connected to one of our test systems so we have physical hardware and we will test this SDM chip I mentioned earlier now so what I want to show you is uh U test so let's say we want to check that our device under test um do is receiving your data we send data to it on a pin and we want to test that this data is actually processed and is arriving there so on the C++ side we have this function here in a main function we initialize the U um basically um this is copied from from the um Cube MX from from St pins are initialized clocks are initialized um and then we have here this is important um the definitions about bout Ray uh we want to send eight bits we want to have one stop bit no parity um and then we start it yeah and it starts receiving here so this is the implementation on our microcontroller and we want to test that it's actually receiving data and for this we register a certain function we write a helper function it's called show Reed it's over here um it basically looks at the uard uh looks if there are characters that were already received and prints them now with STD out that's it no no magic here in this function um that's important stuff make this function available after this register the test system can call this function uh remember it's for for open loop tests it's required that you can call functions on the on the chip and then just messages from the test systems are processed so let's go to the um test sequence here the test sequence as I said Robot Framework um does a suit setup this is executed one time at startup um and this suitup suit setup flashes the firmware so it takes the result from the C CPP the binary flash it is it on the microcontroller and then um we call this endpoint the the interface to a specific periphery we this case um uart um our test system is configured to have a uart on these two pins the microcontroller is also using uh we initialize it with a bit rate no parity One Stop bit and eight data bits of course the same configuration we use for the Target and that's it we can write a test now um test that a single bite is received by the do or the microcontroller same here so for this um we will use the test system endpoint to transmit data so let's just transmit um hex data of maybe um 6B and now the the system will send this data on the pin and we need to read it from the microcontroller so we will use um do invoke this lets us invoke any function that registers on the target I think it was called sure received yep so received and then we need to get the output um that's written to SD output we save it in a variable this is now a syntax from Robot Framework not so important and then we can do our assert like in a unit test we can say should be equal and we take the first line of our output and now we need to compare it against the output of the um show received function so rxx and then the actual value should be 6B okay um I click on compile here and then I run the test so now this firmware is flashed on physical hardware and on a physical pin um the data is transmitted and it passes um great let's just copy paste this and make a few more bites um test that multiple bytes are received um let's use 7 C8 d e x 9 e and then we need of course to change the expectation 8090 let's run this test as well it's passing as well and what's important here what I want to show you is the speed of the feedback yeah I run the test or the suit both tests and within seconds I know that the implementation is working on the hardware no menual steps here and to show you that this is really running in Hardware I'm opening the logic analyzer um this demo system here is connected to a s it's a logic analyzer and um the test system can be configured to Output arbitrary data to the logic analyzer so we will this we we see the receive and transmit line here so let's start capturing just to see if there's happening really something happening on the physical lines and we are not living in a simulation um I'm running the second test um capturing stop this is great I need to zoom out a little bit Yeah so here's data on the receive line of the uard and these are the three B uh three bytes we really wanted to sent uh so you can always check that this is really happening on the pin level and you can compare um arbitrary signals um this is great for debugging I mean Phil mentioned it earlier uh tdd is about writing tests but in some situations you just need to debug and look at the pin level okay so that's a feedback loop but let's use this I mean we have tests in place let's change our implementation now let's say um you have noise on your line and you want to use parity parity is just mechanism that in the UR data one bit is calculated with a checkum yeah and this is done in Hardware so we use odd parity we don't change anything else we recompile and the only thing we need to change in our test is the configuration of our endpoint we need to match it of course so let's have odd and then let's assume you do this on your desk maybe you run a single test then you run this F first test um that's sending a bite and the test passes awesome seems to work we ship it to production now please not let's run both tests because an error was introduced here um I think it's you you won't be able to read it but um it tells it tells that it's not received it it should have received 7 C 8D 9e instead it received 7 c0 D 1e and uh this is one of the situations where an embedded developer uh pretty pretty um easily spots the mistake like Kevin said with his special date um values and so on um it looks like the eighth bit the the most significant bit is set to zero for some for some reason so obviously our change didn't work and for most setups this would have been catched only in production later yeah but we want to do test driven development um so we can take a look in the implementation again we set the parity and maybe we are lucky in the St documentation tells us what the parity is doing and yeah it says when par is enabled the computed parity is inserted at the MSP position of the transmitted data 9 bit when the word length is set to n data bits 8 bit when the word length set to eight datab bits so they have a pretty specific understanding of datab bits they basically say yeah datab bits is not just datab bits but also parity so they overwrite the data bit here um fortunately you can just set it to nine to the word length of nine and then we have the behavior we would expect um from other implementations so we recompile it and again we use the tests and now everything passes and this is really only possible if you have automated tests uh um in the case of the execution platform that's how our system is called um there's really everything automated so you need to write need to wire anything you can attach all the pins at runtime basically [Music] um this demo is by the way uh public so I will later have a slide um with a link if you want to play it it's it's free and public um you can experiment for yourself so let's go back to the presentation nope second yeah okay great so that was a demo um that was the example I just told you and now a little bit uh summary for open loop testing so the important part is really the setup to do this um in your projects uh you need to make the pins accessible the code accessible you need a way to talk to your code running on the chip and make the periphery accessible so if you need U you need some U dongle um if you need can can dongle and they need to be all scripted and automated now then you can build such a solution up um and then for each test you write the code compile it for your Target and you write this test and run it on your desktop machine the robot code is um running on the desktop machine and then we really have a way to use tdd even for code that's behav uh that's changing the behavior on the pins uh we get quick feedback it's automated um a few seconds if you do the setup right but even if it's 10 seconds it doesn't really matter yeah the important thing is you have automated feedback um and that's it basically on just just a summary and maybe talk a few seconds about scope so we saw off Target testing you can run all your generalized code on off Target testing yeah all the code that's compiling on the PC as well be aware that there are risks so if if possible that in any way run the same tests also on target yeah if it you you need setup for this but then you have all the benefits and mitigate these risks um On Target testing can be used to test in internal periphery so for example the crypto unit CRC um flash writing all this kind you can uh you only need On Target testing and the third um thing is open loop testing what we call open loop and for this um you need special special equipment but you can test basically everything the microcontroller does in the with the registers yeah because the pin level is the most important interface of the chip we should be able to test it um there are a few uh references on the left I really recommend uh this book here by James grenning um it's from 2011 but highly relevant okay that's it thanks for listening um of course I'm ready for [Applause] questions hi uh thanks for the talk so uh my question would be um like this uh On Target tests uh look more like integration tests when we like comparing to traditional this unit integration test um separation so uh like let's say in your projects how what uh part of uh like how many uh how much of the tests belong to On Target test and how much of to of Target tests so um basically all the off Target tests should be run on target as well so the the coverage from from um everything you can run off Target you can also run on Target and you should use that uh it's really a one-time setup and if you it it it really depends what kind of project you're working on um most projects we are involved um like industri scale projects maybe different microcontrollers and they are running for the the projects running for multiple years so all these project um can and they do make an investment in the test equipment uh upfront so they use all the the um testing also on top Target if um if I wouldn't have this setup um you really need to think a little bit strategically what kind of parts of the code are really the most important and focus on that ones I mean if you don't want to use on target testing you can also say um I'm using sanitizers and code checking everything and rely on that but in the end these are all tools that also cost uh money and effort to maintain so I would really introduce always introduce On Target testing for serious projects um and maybe um just it's a bonus slide because you you mentioned integration testing and yeah that's uh really a it's a discussion yeah what what are we doing here so traditional unit testing um is called like component testing and this test pyramid the the lowest level level and if you do open loop test um if you do on target testing I would say you are still doing unit testing just in a different environment because the concepts are really the same for On Target testing not for open loop open loop is a little bit more up so from from this perspective what you do in open loop testing is basically replace the you use mock for the external interaction that's what it really is so it's a it's a mix between unit testing and um in some Norms it's called Hardware soft tigation testing so this level here did did this answer answer your question good hi um I I was wondering CU I I'm a bit familiar with uh Rob framework and it's I know that it's quite the pile of python beneath yes uh how do you guys handle like even mild real time requirements like let's say I have a I don't know switch the bouncing routine to test take something really simple um how how do you handle like even the possibility to toggle the pins randomly fast enough yeah yeah that's a good question so everything that's running in robot is not um hard real time so you have basically no uh no definition how long these comments will execute they are running on your PC so everything that is time critical is moved inside our test system so in the system there is an F fbga handling all the um real time requirements and for everything that really needs real time you call specific keywords for example for this toggling example uh you have a keyword that sets a pin for like an arbitrary amount of time and you can run pulses with like 100 neros seconds or so because the test system is handling and not Robot Framework um is emulating um also with this work emulating the hardware instead of running it actually on the hardware yeah that that's a a really good question and there's a lot of debate about it but um so people tried this uh emulating the chips and for the simpler chips like from 25 years ago this kind of worked now and um they don't do it anymore because they just noticed the model of the periphery um to get it done in simulation is just too complex and has we we have too many faults in our simulation that it that it's really usable so for example um arm they they recently uh um offered um they call it virtual Hardware so um basically Hardware in the cloud and they are modeling everything up until the pins so they model their cores they are cortex M3 core M4 all these cores they they basically own the the IP and um they put a lot of effort into it to make really good models and this is working but from this level on um there are just too many many peripheries out there there are certain microcontrollers that offer this um but it's really hugely expensive and um you always have the danger that the actual model is not really using I mean to to to know that this is a problematic approach look at the erata like make up the erata basically says what's wrong in Hardware yeah and you you find it detailed list like 10 pages or so from really intricate things that they did wrong in Hardware and they make a lot of tests before they put this Hardware into silicon so it's really difficult and I would always uh recommend to really run on on Hardware I have a question is it on I think so um yeah so I have a question you said you had some experience regarding um functional safety um do you already have some experience how much the tff likes your tests um no not yet so what I do know is um there are different approaches basically to um to testing or to to assuming functional safety um there are this black Channel and white Channel definitions and um from what I hear um so our system was not yet used in a uh for for certification uh so I can speak to it um from what I hear they really um the the Norms are sometimes requiring for example an automotive but they um try to get around this pin level uh pin level testing really what they do a lot is like this register based testing yeah it's really a thing even in functional safety um and I don't know of any examples that use this test level like um this mix between unit and Hardware software integration testing for um certification if anybody knows an example I would be we should talk later yeah yeah um a question to to a test approach um that that we've seen um lately and um grow fond of um what do you think about basically unit testing what you can test without Hardware interaction and leave the rest to integration tests so the question here is first what is integration testing I mean I I know a lot of projects that use do unit testing and then system testing that's like in in Industry projects it's they have a department for testing and they do system testing um and what department is running the integration tests in this case and your your example it would be the system test Department then the system okay um so yeah it's a way to do it um what you need to consider is the feedback time yeah so if the basically in in these situations the developer does something and throws the code over a fence and then different department is acting on it and you have like a few days maybe weeks maybe months um feedback time and this is not suitable for tdd but yeah in I mean if you have these tests that's a good starting point yeah a lot of projects don't have these tests at all maybe a follow-up question um how many bugs did you did you find in the low-level pin tests I mean um for this for this to kind of trigger you would have you would have to have issues in either your configuration or in the final Hardware right um so most of our custom I mean we are selling the test system we are not um so so I can not give you precise statistics but most of our customers um they are like projects they write their own Hardware abstraction layer their own drivers because they just see um on the market there are different microcontrollers and they have a lot of projects but they want to reuse code make platform based development so they take the cheapest microcontrollers for each project but they want to reuse code so they need the same hard web section layer so basically they start reimplementing all this code that is sorry that that you see in the um for example the H from St I mean if you if you start implementing um the hull these functions here you have a lot of work and then it's not just configuration but really testing your specific requirements um against different families yeah maybe one is an arm and one is a um something entirely else a trior something so it's it's not about configuration it's also about configuration but um if if you really use to reap the benefits of this is when you also do the driver programming any others no nothing online okay I think we are done thanks again Daniel thanks for listening