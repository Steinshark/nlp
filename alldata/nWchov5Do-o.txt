all right the only database abstraction RMS are an indirection over your database an attempt to make SQL obsolete but solving problems in general ways mean one of two things either by the way this the intro this guy gave you zero there was no foreplay in this one okay we're going straight in I hope everybody's ready we're going straight in all right it's a technological breakthrough or a middleof the road tradeoff with existing take and I think you already know where orms fall honestly it's an abstraction most people use so they don't need to learn SQL and starting out it might work well but eventually you will end up with code that looks like this I mean these are good observations by the way if you use an omm to avoid learning squeal you've done yourself a disservice squeal is really easy it's not like it's crazy uh there's plenty of things that likes there's squeal builders that can help you build I think squeals squeal Builders are pretty fine to use and they can do a lot of the um they can do a lot of the sanitization for you there's a lot of already pre-built knowledge on sanitization how to handle it take a moment to understand like orm's aren't all great they aren't all bad sometimes they're fantastic sometimes they suck right like make sure that if you use an omm you use one that allows you to break out into some raw squealing because what's going to ultimately happen at the end is that you're going to be very upset and you want to be able to Raw Dog okay you just want to Raw Dog squeal sometimes as your use cases become more complex your time will be OCC yes the only reason why squeal is difficult is because of [ __ ] database Design This is 110% this is 110% by just reading the omm's documentation how it interacts with the database that's when the underlying issue starts becoming apparent an omm attempts to store your data in an objectoriented format it's a virtual object story running on top of your physical relational database and the two are by definition incompatible it's a well-known issue the object relational impedance mismatch just take the inheritance problem just get wrecked by the old mismatched impedance problem dude I like that just drop at the bombs like that sorry it doesn't work say we have a person student and graduate student OMS would create a table for every unique class but graduate student is still a person meaning it should be found when querying that table so the omm store the primary keys in the fourth table to ensure they are unique all of a sudden what should be a simple index select is join to get a piece of data by its primary key not this is actually this is first off this is this is no not penis mismatch impedance mismatch um this is actually a really this is actually a really good example where you should definitely design your database and then maybe consider an omm not use the orm to design your database you can get into some weird situations this to mention all the extra complexity we get from to Costco okay this every single video today I have yet to turn off alerts I don't know what's wrong with me I used to be so good at this I take a 15-day break or whatever it was and now I literally have negative IQ just like you viewer with negative IQ approximate the relational aspects comparative very simple case of creating a table I would argue that the two orms are less understandable than SQL they are leaking it all over just with a different syntax or let's look at this one when we are trying to select an object by the primary key the omm generates this SQL which instead of being an index lookup must do a full scan of the entire table and we can't tell because we're one IND Direction too far from the database I don't know how much these things still exist I don't know how often this type of stuff still still happens to be a real thing but I do know that there are some issues in which ORS will produce less than optimal squeal right like unless if you are fully understanding all squeal being sent uh out to uh the database you don't actually know what is happening like is it good is it bad where's your boyfriend at I don't even know the dev had no chance to notice they just had to debug after their production environment became unresponsive and every omm has to give you a leaky abstraction of SQL to support at least some more advanced use cases other than just fine by ID they all fall into one of three classes of query families query by example query by API or query by language and they are all bad let's just look at the queries for logging in typical typical typical workday right there that's just a typical workday me working in react user for query by example you would just take your model fill in username and password execute the query and then check that some model was returned if so it succeeded and if it SN the login failed by the way I dislike this this this style very very much I don't see why people prefer this over uh raw doggin some squeal maybe I'm maybe I'm old or something uh I don't know simple enough and actually works for this use case but what if we need to find users that don't have a particular username or count how many have the same first name we simply can't query by API is well this is that true on let's go back to that check that some model was returned if so it succeed isn't there isn't there like some sort of many I assume this thing just turns into a a select and if it's null the login failed simple enough and actually works for this use case but what if we need to find users that don't I mean I guess this is this this is a more compelling case right you have to try to select users that you can't that aren't like this what omm can't do this basic thing I don't know can I I haven't played with I I guess I haven't ran into the case can drizzle do a not like this totally depends on the implementation yeah the other one I I don't know about this m user how many have the same yeah oh count yeah I mean again when you get into these situations I don't know if it can count I don't know how many have this ability to be able to count how many exist like this but if they do seems I mean it seems reasonable this seems like a a normal use case I would see I I would feel a little surprised if they can't do that drizzle can use uh squeal template strings for that yeah we can do that no camel of course you can do that in no camel you can do that in everything oh so okay so I wouldn't be surprised if all these cases aren't covered by ORS so this feels like a little bit of a we simply can't query by API is well this just SQL but you call functions instead user find all where these things happen uh then do all these rows not found okay shouldn't happen but inevitably at some point it will yeah yes uh username password probably a bad example but just let's get the idea okay let's get the idea I don't know about you but to me this seems more complex than just a corresponding sequel query by well no okay so that was I I also feel like that was a slightly unfair uh uh comparison because this one does the squeal right so this statement right here would be the equivalent functions instead I don't know about you but to me this seems more complex than just the correspond yeah so I mean so here's the problem is that you still have to handle the not their case so there you still have to have something that takes it and then does the whole error handling side so he is missing the error handling side and is this simpler some people might find this harder I don't know I'm not convinced that this is easier or harder to me this is I know password like I know like I know just let it go remember I said he used bad field examples for their naming because you wouldn't do like like I mean he could have used anything last name right last name it would have worked out perfectly uh it would have worked out perfectly with last name right we wouldn't have worried about it yeah we also have to do some sanitization there I assume sanitization is part of it password is is the password like is hilarious it is hilar either way I I get what he's saying but I'm not sure if I love these examples like I do think that there's a there's a ton of things that are really difficult hey SMY thanks sm's weightlifting thanks for the five gifted Subs there is let Tim Cook we're trying to let Tim Cook but there is I like what he has to say and that the complexity of OMS you just write so much more code to accomplish the same thing that's not hard and squeal like I like that the examples I think he are giving like especially the password part is a little bit confusing I think it's throwing off it's deterring from the actual conversation sequel query by language it's just something like this or sequel with extra annotations also what is this is this acceptable partner is it executed in the database or in code and of course this does a full table scan and it might even do a cross join which would be terrible but we don't and can't know unless we run the app and check the query the omm creates oh also have you seen this latency numbers every I didn't get I I I I didn't quite get this as previous example um if your omm is adding stored procedures I mean I I agree that this looks terrifying whatever this is this looks very scary whatever's going on here likely link I thought link was always inverted how it did things but whatever's going on here this this looks terrifying it looks like also what is this is this acceptable partner is it executed in the database or in code and of course this does a full table scan and it might even do a cross join which would be terrible but we don't and can't know unless we run the app and check the query the omm creates oh also have you seen this latency numbers every programmer should know when we read from a database we send the data over the network clearly the size Matters enormously to the latency of the website omms generally just select all data the equivalent of Select star not even allowing you to attempt to tune it again probably fine for most use cases but when you need to optimize you are unable to I will also say one big issue that seems to be far more by the way that was a good point which was when you select all the data you do necessarily incur a much larger cost when transferring across the network and so being able to select out individual Fields is good I'm sure there's lots of ORS that do that but it may not be clear how they do that uh and it may require more programming just to get those names in there orms do allow you to select Fields but I'm not sure exactly like first off how do those select Fields work like Planet scale I know that what they have is they have an entire driver that does in joins right selecting to your mom okay fair but really uh like uh Planet scale they they they do big selects and then they do the joins programmatically in a rust driver like that they they've talked about that I know they've been wanting to shore some things up about that but that's like a real cost your application is going to incur when you have to do those kind of things in memory rather than on your separate server in a database that goes nice and slick and fast and does all of them for you right so out trying to out program so you don't know know exactly what you're getting at all times now Planet scale may have changed what they've been doing I don't want to like say uh that they're terrible I I don't know if they've changed those things but from the last time I read which was just like six months ago they were still doing things like that which is you know that you just may not realize what you're getting yourself into orm's can also have some bad optimizations uh they can have missing features right uh let's see is that let's see hold on my the let's see in my opinion the biggest problem with orm uh is that queries are not portable you basically need to run your project with the debugger to run your query or to rewrite this query with squeal manually uh this is the worst one for me that's actually a really cool point I guess I never really thought about that I never really thought about like the interoperability of debugging and creating and crafting a query for me a big thing that I have to do a lot or I used to do a lot at Netflix I haven't had to do it lately is that I had to go like log into the Big Data portal and go to Hive and play around with test tables and actually create um like craft a query to be able to get some data out do some joins really kind of like sift through all the things I need to do and then I have to take that query and I just raw dog run that on a little tool that I have whereas if I had an omm I'd have to then figure out how to convert that query into how the omm states those things which I think can be a bit more difficult you mean Prisma oh you're right it was Prisma my bad not Planet scale retracted everything I said about planet scale it was Prisma that does that which is an omm not Planet scale Prisma sorry I got that I got them confused my bad uh but like that's a real that is a real thing to think about which is how do you translate your queries and test your queries when you have them in uh om just something to think about you know what I mean come on but hey I do want to say that I love the idea of omms I love the idea of just having objects autocomplete everything just works you just put the things in and bada bing bada boom right with orm is not being transactionally correct meaning you write some data then you try to read it to write something else depending on the result clearly you expect the read to succeed you just wrote the data but because it's not running in the transaction another query came in here ran before your read deleted the data and what should be infallible fails sure it's also possible when just using SQL but it seems more common with orms I guess because most yeah I I assume orms have transaction mode I assume you can say like transaction I mean I assume a lot there's some omm that exist I get what he's saying which is that you do run yourself into some some sort of weird situation uh like I I totally get the things he's saying some do that by default that also sounds bad right like that sounds equally as bad omm's doing it by default sounds equally as bad as omm's not doing it by default or not exposing it so that you understand that you're doing it or not you don't really realize these things again I still think knowing RW squeal is always going to be more beneficial than knowing a program that translates into Ros squeal I just don't I don't I agree with a lot of the things he's saying it's just how he's making it come about seems a bit odd users think of it as an objectoriented environment without multiple writers so we get this massive data correctness problem with that being said there are good reasons to use orms they give you some nice tools like convenient utilities to migrate tables automatically that is when you need to add more fields to a table like adding age to your user the migration is automatically checked into Version Control and if you need to roll back things just keep working personally I prefer that's good uh yeah I I I've heard Prisma has an amazing database uh migration path and that people love using Prisma specifically for that fact I like that yeah this does not scale I've done literally this thing right here this is something I have done where I have all the migrations I've ever done in squeal that gets executed like when you want to create a new database it's like dot dot dot dot dot dot dot dot dot I've done this we just creating separate SQL files with update table statements and checking those in but I see the value you could also argue that abstracting away the database is a really good feature as well but let's be realistic most people would be just fine using the same database everywhere you probably that is like this is such a good take this is such a good take this idea of abstracting away a database is just stupid don't abstract away a database it it does it literally makes no sense you're probably going to use the same database until you absolutely explode and then you're going to desperately try to use Cassandra which you're a loser because you didn't choose Sila and you're going to be confused you're going to be in shambles you're going to be absolutely confused like why why would you add a layer of indirection like that when you're going to be using postgress you know you are post postgress squeal like you know you are like that's it you'll be using it for the life of your product and if for whatever reason you actually become successful where you have thousands of Engineers and your data no longer scales you will be able to hire the right people to abstract it at the at that point right you'll be able to do the right thing then don't like if if postgress does not work for your your uh what's it called your your current APP you're probably doing things way wrong right you're probably doing it way wrong that's all I have to say don't plan I mean there's an old joke that we uh that has been made many of times where I work which is uh we didn't plan for massive massive success and it's true and that caused some Growing Pains but at the same time if you pre-plan for massive success you may just intentionally create growing pains in which you don't even need it's stupid don't work at large enough scale where that's a Boton neic it's a solution invented for a problem that should have never existed but it happens you will probably still use some specific feature and end up with non database agnostic code anyway other good reasons include connection pooling deserializing query results into data structures I love these two by the way input validation Etc yep those are all great in the end OMS are kind of awkward and suffer a lot from the last problem they are so close to a 100% complete solution but fall just short I would say use the parts that make sense for you maybe even consider using something like goang or rust SQL X which is what I tend to do most of the time just don't constrict yourself too much to the omm's self-imposed Paradigm and unlock the real value of your database that's it for the video please like I love that ending that ending was so good it was so so very very good I absolutely loved everything he said after like the first Parts I don't think as examples were super compelling but right afterwards I think everything after like he just nailed it just destroyed the the second half of this video which is just so right um there is a lot of cool things like right I really do enjoy or I like the idea like I said I like the idea of of type completion and all these things and just kind of doing all that uh or if you're using an omm pick an omm that allows you to Raw Dog right you you use the omm for the simple things and the moment you need to do anything complex I'm always super super super skeptical about using orms om for type safety is fine but at the end of the day at the end of the day it's kind of nonsense I'm just going to be real about the whole omm's for type safety like it's nice because it comes with named Fields so you make sure you never mess up your squeal like I like that part that part's nice it has Field named safety right I like that but on the way out you know what that thing's doing right right you know you know what a type safe database omm's doing it's going through a row grabbing out a bunch of named Fields putting them into an object and as this user like it's doing exactly what you would do and as user or as whatever it's casting the object it's forcing the object into something I just don't believe that it's some that much more magical right this type safety business is just like a it is an odd argument because you would do the exact same thing either way it's either you do it or a program does it I prefer I prefer programs that do it right hydration magic much better I could do hydration magic you could do hydration magic but at the end of the day you're still just taking some raw dogged object and calling it a user right this is not you know just automated yeah intell gives type safety and autocomplete as LSP very nice yes yes there's a lot of plugins too that can read your database and long as you have the credentials available in like the N or whatever it will actually go through and say hey you've misnamed this field if you already have that that alone is 95% of what you're getting out of you know out of omms I love squeal I said it yeah hydrate these nuts absolutely I got someone with ey ladies the other day let's go ey ladies comment hey by the way YouTube do you know what uh ey ladies are have you heard of ey ladies uh you're not allowed to say eager anymore you have to say I ladies if you don't understand just ask me in the comments below I'll let you know the name is I just use my left hand and it feels slightly awkward AIT