we had lots of questions about how the actual dot git folder works in git repositories because that's doing kind of all the magic you might say and if something does seem pretty crazy magical like it's doing something very special but when you start to look actually what it's doing it's pretty simple and pretty efficient pretty quick and it's kind of nice how it stores everything you've done in the past if you wanted to investigate it yourself which is pretty easy you can just list the files inside the hidden.get folder so it's a bit of work to find it but then you can just look inside it and see what's in there there's quite a range of things there's like a something called head and big capital letters which is really just a link to a point in your structure and that is just a quick and easy thing that it can always reference to get to the latest point and if you choose to look somewhere else then it will just move that link to wherever you want to look in your history of all your files there's some things called like config which is a folder which has you know a range of configuration details like your username you're logging in with and the kind of details about your project that type of thing there's um a log folder and that's something that's being created on the fly which you can so if you type in git log you can see that log list and it's basically storing metadata about every commit you make so it's kind of like a a summary of your history which you can pick up very quickly um so we can display that to you basically and then the real kind of important bit i would say there's lots of other things in there which we could talk about but the real important bit is the kind of objects folder and this is all your past versions of stored files all compressed into this folder in different subfolders so they can be quickly found and picked up again all right and so when you do a git commit what it does it takes all your current files compresses them with the z-lib library and then just stores them in those folders and uses sha-1 hashing to get a unique name for that particular object it creates three types of objects basically one is it creates an object for the commits and one it creates an object for a view of the folder and then the other one is it creates an object for each file so if you really want to see what's happening then you can use something called git cap file which is just a command so it's git cat dash file and then if you put do minus t as a flag and then put in the hash then it will tell you what the type of that object is the fastest way to get and start to get familiar with it is um to start off with git log so if you type in git log and you'll see like a history of your commits and you'll see that one of the things you get there is like a long hash which i said it gives a unique hash for every commit and you can copy that and you can type in git cat dash file minus t and then type that hash in or paste it in and that will tell you for example that one is of type commit because you put in t for type if you want to see what's actually in it you can do git cap file minus p and then the hash and it will print out the contents for you basically so you can see inside that you have a few hashes and a few other bits of information like who it was that created the commit which was me in this case and then it has a get message in there as well and that git message is what you said was the description of that commit when you produced it which i just put as testing to in this case because i was testing so if you then want to see the content of that commit like all the files you had you can take that uh tree hash the other one is called parent hash and the parent hash is like the previous commit so if you want to go backwards in time you could do it that way if you wanted but the tree is the object which is the view of the folder so you can do git cat file minus t for that new hash and it tells you it's a type tree so we know this is a tree view of your folders and you type same thing again get cat dash file nice piece to print out and it will show you the contents that will tell you i've listed two files and each one's got a unique hash as well and that unique hash is a reference to a compressed version of the object so if you want to see what's inside that object first we can do git cap file minus t to see what type it is it'll tell you to type blob because it's a file compressed blob of data and then git cat file minus p for that will just print out the contents of that file for you so you can see it's pretty simple it's compressed an object it's made a text file view of the folder and compress that as an object and then it's created a new git commit object which is just a summary of information it uses and then compress that what's interesting though is that it stores it in a kind of unique way if you look inside the objects folder which we could do so if we ls to have a look right now it's clear for interesting so you can go into objects and list that out and you can see that it's got a few kind of like subfolders which are the first two characters of any of the commits um and then if you look inside one of those like with c8 one for example you see there's shortened file names for the compressed objects and that's really only doing time saving in terms of finding those objects again so when it's trying to call them up it means you don't have one folder with everything in it you've got some subfolder structure for optimization so but that's where all those things are being stored inside that objects folder it's managing all this stuff it's it's probably got kind of root access or something out there i mean how how does that work in terms of security so it's a good question i don't know the full detail but git will only really work within the folder that it's managing um so if you it won't it won't do anything with the parent folders and it won't do anything with other projects it's not in charge of it will just manage the folder that that dot get file is in the root of and all of its children so it will stick within that remit but you could have you know 100 folders on your computer each with its own git folder inside which is managing just the changes within that folder project essentially and one thing i often do when i'm showing what's happening is i create a git project on my computer somewhere any folder push it to a server like github or gitlab and then just go to another part of my computer anywhere and then do a get clone of the folder down onto there and then really you can like edit in one place commit it and push it and then pull it down to the next place to see what happens and you can see it updating basically the content of the two places um and then if you want you can do some clever things like change both places separately and then try and push them both up and see how it handles those kind of clashes basically they're called get more conflicts what does it do in those cases usually ask you does it well a very good question it does a few things if it can like if you edited different files in different places it will just merge them for you and say you did that you did that you know even within the same file you edited the top 10 lines they did the bottom 10 lines i can just i can do that for you and it puts them together um but if it can't then it says okay here's one file that has both of your changes in it and you tell me what it should do so in practice it's quite complicated um if you on one side on the left you make some file changes and push it to the server and then on the other side on the right make some file changes and push it to the server the second one it will say no you can't do that because someone else has put some changes in you haven't seen yet and it forces you to get pull them down to your computer and then it will say okay you uh we've pulled them down and here's your file joined with what someone else did and it basically puts them side by side here and it says as a human you're smarter than me so you tell me which of those two i should keep or merge them together and you basically just delete the metadata in between and it will um and then create a new commit and then you can push that to the server it says okay thank you i accept that because no one has to change anything we're interested in what happens in one more folder and that's the index folder what that folder does in general is that it stores what's going to be your next commit so say you are creating a new file and that's going to go into the next commit when you get add that file it essentially stores that information in the index knowing this is going to be part of the changes that are in the next commit so when you do type in git commit it takes that current status from the index file and uses that as the source of information for your git commit the real problem is when 20 people are trying to edit the same files at once and everyone's doing it before you do and you always have to emerge so you you imagine there must be some communication within team members and we could do a whole video i think on teams using that type of stuff together d e so d and e are children from b so let's move that around so d and e and so on right so that's fairly straightforward right now we actually do technically split it again i think mike's going to demonstrate this in a second is that we've got nothing for j is like milk it's like water it's everywhere