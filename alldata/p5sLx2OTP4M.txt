um so yeah it's nice to be back again um I want to talk to you about six impossible things I thought it's a nice way to start Sunday this is a a talk that its earliest Incarnation um was during the pandemic and I've done a couple of versions of this but this is the this is the one I've enjoyed putting together the most it's the most complete as it were because I've got two hours no I won't use all the two hour but it allows me to go a little bit further and of course because it is uh you know I I'll take some questions um at the end and obviously there's plenty of opportunity to discuss things um during the conference but I've already mentioned but I'll mention again for those on the stream my um social media details um you can find me in most places um but what we're going to talk about is the quote the title of this talk six impossible things uh it comes from a conversation between Alice as in Alice and Wonderland and the White Queen this was in um Lewis Carol's through the Looking Glass which is published in 18 the 1870s 1871 and there is this wonderful quote where Alice basically says to the uh says to the White Queen there's no use you know there's no use trying one can't believe impossible things and the Red Queen responds well sometimes I believed as many as six impossible things before breakfast now I've caught you just after breakfast but let's let's do six impossible things before lunch or alternatively uh if you are watching this in a US time zone hey before breakfast um so oh in fact actually let me just go back I want to clarify one thing these six things are impossible now sometimes you need to kind of be very clear about the words you're using when I say impossible I mean not possible because i' I've I've gone on uh you know I've gone on social media and asked various suggestions in the past okay give me some things that are impossible in software development and people come out with all kinds of great suggestions a lot of them are very entertaining but not all of them are impossible sometimes people say oh yeah delivering projects according to estimates it's not impossible it's a low probability event but it's not zero we are talking about a probability of zero okay it's not going to happen if we're saying things like wow that is so far beyond the reach of modern technology it would take Generations maybe thousands of years to achieve this then you've just told me it's not impossible you've just told me the scope and the means of possibility I mean you won't be alive to see it but that doesn't mean it's impossible that just means whoa that's really hard so do not confuse oh that's really hard for impossible okay we are talking about things that according to our current understanding of the way the universe works and that that could of course be incorrect according to that these are impossible so I'm going to start off we're going to do this as a counter which also by the way lets you know where we are in the talk yeah and of course I'm going to include a zero but yeah representations can be infinite now this is a thing that is impossible now let's be very clear maybe this will this will this is entirely possible it will annoy a couple of oh yes I ought to say this is a talk that will involve science mostly physics maths philosophy and code so perfect Sunday morning material importantly it might I might annoy a couple of mathematicians anybody here got a math background okay I might know a couple of physicists anybody got a physics background yeah okay yeah and by the way everybody can include themselves in anything here but I don't want I'm just picking on two groups to begin with everybody is a target myself included okay so I'm going to make an observation here uh there are no Infinities in the physical Universe Infinity is a mathematical concept not a physical one okay whenever a physicist says oh and at this point you get an Infinity that's that's how phys pH ists say we have no clue our Theory breaks down it doesn't mean there's an Infinity it means we don't have an answer yeah so when they use Infinity it's shorthand for we haven't a clue okay um computer scientists are particularly afraid of infinity so they use softer words like unbounded this sounds so much calmer and more gentle but yeah it means infinity or rather we have no clue now of course you might say well wait a minute sure I can get infinity on my computer yeah I can squeeze it I can squeeze it you know it's represented in my FPU I can put it into 32 bits if I want to I have bad news for you that's not Infinity it's like the word infinity is not Infinity it's not an infinite number of things it's a shorthand for we can't look at that we don't really know how to talk about it but we can give it a name sure we can name things that we cannot see and that cannot exist or do not exist I have a name for unicorns it doesn't mean they exist I'm sorry if I'm shaking your beliefs there but they don't we'll have to have a conversation about Father Christmas at some point as well but the point there is I can have a name for it now where can I where where's what's a useful source of the value Infinity well here's a useful Source yeah if if you need an Infinity you can just get it just like that now that is what i e 754 say mathematicians have a slightly stricter view division by zero is undefined for real numbers okay now oh it's the first the first point we're going to hear the word undefined today but it won't be the last in fact that's true for the conference it won't be the last time you hear this term but let's be very precise this is a mathematical definition there is no undefined behavior in mathematics because there is no Behavior it just is or it isn't it's right or it's wrong okay um if you have something that is undefined in mathematics it means we can't do anything here there is no Behavior we're done or you have an opportunity to create some new mathematics that's what mathematicians love doing if you find something undefined in physics it's an opportunity for new physics if you find something undefined in your C++ code that is an opportunity to not go home when you thought you were going to go home and if you work from home I'm sorry There Is No Escape at this point you are trapped you will never leave it no it's just I'll be I just another few minutes I think I've got this one so let's talk about numbers and this whole thing I mean obviously you know that representations can't be infinite in fact every single one of these or pretty much all of these impossible things you know if I if I State them directly but it's the fact that what happens in code sneaks sneaks up on us indirect IR ly and surprises us so a number of years ago I edited uh this book 97 things every programmer should know sort of crowdsourced and open source book and there was this piece from Chuck Allison uh who at the time was uh he was editor of better software magazine prior to that um he was contributor and editor of a number of C++ journals I've known uh new truck for a number of years um and he had in fact his curiously enough um it was it was this is the only piece in the whole of the 97 Things book that I actually asked somebody for directly with a title um I asked people please contribute whatever you want random people from the internet people I contacted directly but Chu was the only person I contacted directly I would like you to write a piece on floating Point numbers because he'd written a really good piece on series of pieces on I e754 I'd like you to write and I a title for you Chuck floating Point numbers aren't real okay um and and what do we know about floating Point numbers well I I came across this one very recently so thanks to guy Davidson for mentioning this on the um the BSI standards reflector for C++ he mentioned this the other week and I thought this is really interesting subtraction is functionally complete to be precise i e 754 floating Point subtraction is fun F complete that means you can construct any binary circuit using nothing but floating Point subtraction holy crap okay this is an article by Austin Peters um just a few weeks ago or a month ago um so this does not work if the numbers in your machine behave like the numbers that you were taught at school but it turns out the numbers that you were taught at school are kind of like an abstract fantasy from the perspective um of C++ okay they bear almost no relationship so I mean this is what you were talk to SCH zero nothing yeah please don't divide by it you can multiply it and it's an identity operation uh or rather it reduce everything to zero add and it's an identity operation this is fantastic however guess what welcome to the world computers we have a minus 0 which is actually slightly different and if you subtract minus 0 from minus 0 now I know the quiz is tomorrow night but let's start today what do you get minus 0 minus- 0 plus Z well done excellent and what happens when we subtract plus 0 from minus 0 I'm a mix of answers yeah okay and plus 0 minus- 0 you're getting the idea of this excellent and so plus 0 minus plus 0 excellent so that gives us this beautiful arrangement which kind of reminds us of a truth table uh in fact this is the first truth table um uh ever um this was uh invented by Lu viernstein back in published in 1921 um we'll be coming back to uh this uh work in a bit so um here's what we get now let's convert this to Binary we get that and actually what we've discovered is we've got an imply gate with uh inverted uh with inverted inputs this is fantastic so using just so honestly if you are bored with your work you can recreate the whole of computing from the ground up just using I 754 subtraction um obviously if you're bored please don't do this in in production code now the point here is that floating Point numbers aren't real as CH observes real numbers have infinite precision and are therefore continuous and non- lossy floating Point numbers have limited Precision so they are finite and they resemble badly behaved integers I love that phrase badly behaved I mean yeah let's look at how badly behaved integers are already so I'm known for kind of identifying and spotting failure screens um here's here's one you know blast from the past 10 years ago uh Visual Studio telling me that my license will expire well that's a very suspicious number for what I love is that if you are in software development you immediately look at that and go yeah yeah that's that's that's 2 to the 31 minus one cuz I mean who wouldn't know that the rest of the population is just like that's a random big number but it's not it's very CU this license will expire in that's very curious there's some kind something going on but what I love is that clearly something else is going on on the inside because your license has gone stale oh no I'm good for a very very long time as far as I'm concerned beyond the lifetime of likely lifetime of human civilization so clearly this is a problem that happened in presentation logic rather than um uh uh before it turns out that we have a few problems with our numbers because we've just gone very big and well H something's not quite right so let's look at some of the consequences of this um so lovely quote f was invented to avoid the awkwardness of realizing nobody in the room can binary search an array now I'm sure you can all binary search an array uh you're a competent bunch of individuals and even on a Sunday morning you can do this so let's look at this as a problem so here is a binary search implementation pstl that I've dug out of a book so early 1990s early mid 1990s um there are a few things let's just reformat it a little bit it's a little bit dense so let's let's uh space it out a bit tidy a few things up from a kind of like a spacing perspective and also Embrace C++ a little more um and so this is a binary search and what it will do is it will um return you the index of where a value is or where it would be if it were there um now why why is this particular implementation interesting well this particular implementation is based on the imple an implementation by John Bentley from 1983 a piece called writing correct programs it was in Communications of the ACM uh it was part of his programming Pearl series um so he pointed this one out he wanted to show the full version and do a proof that this works so he's kind of added in all of the various constraints the assertions the invariance that we are expecting at every single point um and he verifies this by proof this works one of the major benefits of program verification is it gives programs a language in which they can express that understanding and that is very much the kind of like the beginning of the era where there was a kind of a a boom well or an attempted boom 80s through the early 90s where formal verification was very much if if any of you went through a computer science degree um probably pretty much until the late '90s or early 2000s you would have been subjected to doing uh formal proofs in Zed or vdm um and uh the idea is like yeah this is good it can help you to now there's a lot of valuable tools we can pick up but there are some is issues first of all never fool yourself that this is the whole picture these techniques are only a small part of writing correct programs keeping the code simple is usually the key to correctness now I'm going to be a little bit skeptical and say I'm talking to a bunch of C++ developers so the keeping it simple it's not going to happen is it however I would like to impose uh on you that this is still a good idea on the other hand several professional programmers familiar with these techniques have related to me an experience that is too common in my own programming when they construct a program the hard Parts work the first time while the bugs are in the easy Parts oh this has nothing to do with formal verification this is the everyday life of a software developer you are very familiar with this experience you put so you you concentrate oh that bit's hard that is where the that is where the eye of Mordor shines okay you are there you are focused on that the armies of your intellect converge on the hard problem meanwhile a couple of little Hobbits sneak through and cause an unexpected divide by zero somewhere or an off by one error now there is a certain irony to this why is there a certain irony now this is some Java code this is some Java code that lived in the standard Library the jdk up until 2006 um what is relevant here is that this code was written um by Joshua block Joshua block was a student of John Bentley this is John Bentley's algorithm it has been realized in Java it is actually the same it's a variation of the same algorithm I just showed you before in C++ and this was in the standard uh library and this all worked because it was based on an assumption the problem is around 2006 people started using very large arrays and there is a small problem yes a couple of you got that well done um uh I did say there' be some science a bit of astronomy bit of radio ason tring be there uh very large array for those of you who are struggling um that is the very large array um the problem here is this because we have this ingrained at school okay yeah if I want to find the midpoint of two numbers it's the average of the two numbers you just add them together divide by two that's great there's only one small problem when those two numbers are really really big they run out of space because representations cannot be infinite but we don't see that because normally you don't worry about this stuff nobody ever had to worry about arrays being 32bit addressable until relatively recently because you simply had physical limits that prevented you from running off that so we can do it by finding this and this works this is fine so the point here is the Assumption was here the Assumption in the proof was here this is why he didn't spot the bug the bug was always there the code was wrong since 1983 okay that algorithm was broken from the moment it was conceived which is kind of ironic because it was called writing correct programs um um there is by the way if you're looking for a term for this there is a term muff's law mre's law if you write anything correcting or criticizing the quality of someone else's editing proofing spelling grammar or whatever there will be some kind of editorial error in what you have written yeah you could see this all over social media it's like I think you meant to spell it like this and then you find that you know or it's spelled like this and you use the wrong version of it you know just the universe is sitting there going like oh here's an opportunity for fun and of course it is based on variation of Murphy's Law so the point here is assumptions let's go back to philosophy epistemology and the the nature of knowledge a assumptions are a very curious piece of knowledge or a very curious kind of knowledge you normally know your assumptions when they are contradicted you discover that you believed something only when you discover that it's wrong you discover it in the moment you say oh I assumed that at that moment somebody probably told you yeah there you are working with your colleagues and they've just spotted something in your code and you that's not right oh oh yeah yeah it's like this and they said no no no no no this is not how it works the standard says this the database does that the network never returns that error code oh I had assumed that at that moment you discovered you had a piece of knowledge you didn't know you had it it was invisible had I asked you 5 minutes before you would have had no assumptions so assumptions are mostly discovered in retrospect like stepping on Lego bricks in the dark which is an experience that I recommend everybody try at least once but only once uh because then you know what it's like um but there is that point even if I tell you by the way in this darkened room where you can't see and you are Barefoot there are Lego bricks you know you have assumptions you just don't know where they are until you step on them okay so let's talk about this one so uh way back when over 50 years back uh structured programming ul yandal edar dyster and Tony Hall Dyer made this observation I've assumed perfect arithmetic so by the way this was published over 10 years before the um uh Bentley bug uh I have assumed perfect arithmetic and in my experience the validity of such proofs often gets questioned by people who argue that in practice one never has perfect arithmetic at one's disposable admissible inte values usually have an absolute upper bound real numbers are only represented to a finite accuracy Etc so what is the validity of such proofs if one proves the correctness of a program using an ideal assuming an idealized perfect world one should not be amazed if something goes wrong when this ideal program gets executed by an imperfect implementation in other words where reality contact you know comes into contact with the uh uh abstract ideas of your code so going back to this code I'll leave it in its original form we know that if we want to deal with this we can actually focus on that problem in C++ 20 I'd just use midpoint because that's guaranteed to be right that's it that's the point of midpoint okay and if we're doing that then we might as well realize that that's the whole of the algorithm is intended to do exactly what lower range does at this point you can actually get rid of the original code this is my favorite form of refactoring um it's just like oh wait a minute you can do this you oh it's in the standard Library um so there's there's a whole load of stuff like that so yeah we've got that now other things um so this this this ship has now being retired U it's um the Yorktown um uh so this is a US Navy ship and there was a problem this um ship was kind of stuck for about 48 Hours um they'd upgraded their system uh uh from some variant of Unix to uh Windows um data contained a zero where it shouldn't have the whole thing was taken down okay and when the software attempted to divide by zero a buffer overrun occurred crashing the entire network and causing the ship to lose control of its propulsion system oops um the uh so there's there's a kind of an observation here that clearly this is not actually directly an operating system thing because divide by Zer an application shouldn't have this yeah but what if it's in a device driver it gets a lot more exciting that's where that's where this stuff happens and gets a lot you know you're executing in kernel mode yeah it gets much more exciting um now I'm not going to blame windows on uh for this one however I would like to note that um the uh uh the world is a very unsafe place I'm sure we're all aware of that and I just want to ensure that you know how unsafe it is um is that the Royal Navy in the UK uh runs windows on its nuclear submarines and they have they use a special variant and it's called windows for submarines I just want you to think about that one for a moment and just yeah you know naming is really hard now you might be thinking well hang on kevn you just told us that dividing by zero gives us Infinity ah I did not exactly say that I said floating point division by zero gives you that integer division by zero that that's the emoji for undefined Behavior okay it's just so here is the problem the problem that we are dealing with as for told by Shakespeare um who turns out was a great programmer uh wrote whole wrote you know so um he wrote uh a whole uh play on memory management it was called Hamlet uh the most famous part of this one is to be or not to be um you know is this pointer valid or not I don't know have we deleted I good question not really sure there's a whole load of stuff that he carefully wo in uh he tended to use a script programming language um and favored the actor model um that's enough of that but let's focus on what he actually said in Tris and cres this is the monstrosity and love lady that the will is infinite and the execution confined that the desire is boundless and the to slave to limit we find a contradiction between what we want and also our imaginings as and the reality of what of our platform so let's talk about this one every question has an answer to be more precise about this I mean every question has an answer on the on the terms and in the frame that the question is asked so here A Simple Thing yellow so when dealing with logic we are very familiar that it's you know typically we think of logic by default we're talking about Boolean logic we are talking about a two valued logic so here's the problem yellow is more happy than blue blue is more happy than red purple is less happy than yellow is purple more happy than red look at that one for a moment and it's just like ah in the frame of two Valu Boolean logic there is no answer to this we simply don't have enough information we cannot we don't we can't conclude it now some people would say oh no kevn that that's false because you can't prove it's true yeah but you've just told me you've you've rigged the system you've decided a new meaning for false as opposed to we don't know you've decided this is one of the classic problems um with closed World logic systems things like prologue and many uh classic 1980s and early '90s attempts to reason automatically is they use a closed World assumption um if I cannot prove it within this closed World it must therefore be false which is not at all how um we think um so to be precise why am i showing in this font rather than something else well because I had a little conversation with chat GPT this was inspired by an article that I read based on the information you provided we can establish the following happiness ranking it does one two three correct yeah yellow great and BL blue blue happier than red purple less happy Yeah from this ranking we can affer that purple is indeed more happier than red what no we can't and that is because you need to remember this chat GPT is your classic bullshitter it is your classic bullshitter it will it will offer you an answer with confidence it is incredibly knowledgeable but not very good at applying it's knowledgeable well being knowledgeable in practice as it were it will try and offer you a people pleasing answer but it is bullshitting okay okay it's just going to offer you kind of confidence do not confuse confidence for correctness this is very useful when you're browsing social media and politics okay now here is the point what happened is it patent matched similar structures and said oh it must be like this cuz you know what there's a lot of reason there's a lot of stuff out there a lot of material that kind of looks this is this this is this that is that therefore what is this there's a lot of things it kind of matches some of the stuff that's out there and it kind of gives you an answer that's wrong and the article I took this from um was a piece um written last month mat because why chat gbt talks the talk but doesn't walk the walk humans REM remain remain unique in their ability to respond relationally relational frame theory propos that human cognition and thus intelligence is founded on our ability for relational responding in other words resp responding to one event in terms of its relationship to another so let's talk about events let's talk about things like time and our relationship with time and what that means for some of the questions that we ask and the answers that we can or cannot have so this is one I've used before um it it never gets old I mean it's Timeless I mean literally it is timeless um this was uh uh many years ago so to to tell you how far back it was it was before um Facebook decided to start destroying elections um and referendums and things like that so it was quite a while back and um there is one false statement here and we're talking about truth and falsehood uh your feedback will be used to improve Facebook no I've been I've been using it for a number of years since then there is no evidence that this occurred um however the thing that is of Interest here is this wow thanks for taking the time time to make a report that's quite a lot of time 1969 but 31st of December 1969 feels strangely suspicious it's not an arbitrary number again for the rest of the population it's just like that's an arbitrary number for or an arbitrary date no no you're going like that's really really close to the epoch okay the posic standard the time function shall return the value of time in seconds since the epoch by the way the C standard and therefore the C++ standard does not tell you this it just says something but most platforms follow the posix version and we know when zero is you can find you can find zero time so using sweet nothing here you can find zero time quite easily just look around um this is quite a good one uh now I don't I've been told that this is not actually a bug this is a feature um Intel were not curiously strangely enough Intel were not releasing device driver updates um uh on the internet uh in January 1970 for a variety of reasons um uh but they do this one because it is the beginning of time and therefore precedes all other possible things this is the driver that you should install if nothing else happens because there is nothing that happened before the 1st of January 1970 I'm not going to ask for a show of hands but there are some of you here who like me were born before the beginning of time and I'm my current rate of progress I mean of course it's difficult to predict the future we'll come to that one in a bit but I think it should also survive the year I should also survive the year 2038 problem which will make me eternal and therefore a number of you here yeah I am Immortal I was born before the beginning of time and I will live beyond the end of time I offer you that today okay now initially when I first saw this I thought to quote annel Dash you know the natural enemy of the programmer is the time zone I thought ah I see what's happened something got zero initialized and then it got shifted because I'm in the UK and Facebook is in the states so their servers are the US so therefore it got shifted West which basically puts first of January 1970 into the of 1969 that was my initial Theory and obviously we do make these various mistakes um I had this one last year um on the train from I mean we know that Britain has always had a very difficult relationship with basically every other country in the world but um let's focus just simply on the relationship to Brussels at the moment um and apparently the national rail online system which was created some years after Eurostar connected London and Paris um still doesn't get the fact that there's a time zone difference um still doesn't get this one right um so if you're holding dates and times without either converting to UTC or also holding a time also holding time zone data you are doing it wrong it's as simple as that by the way if you're doing both if you are doing these things it doesn't mean you're doing it right you're doing it less wrong there's one other thing you need to account for is the fact that sometimes government change time zones that is not accounted for but just the basics here however there is something else here I was thinking you go back a few hours into 1969 but since then I have come to believe that was not the problem that there is actually a far simpler problem I want to introduce a bit of negativity into your day not much negativity just just one minus one because all you need to do is go back 1 second from midnight and you're in 1969 so what do we know about that so here's a copy of the c99 standard the value time T minus one is returned if the calendar time is not available oh oh it's not 1969 it's there is no time before 1969 the whole NE this is a problem minus on systems that use the negative range to extend backwards in time you have a small problem is that the negative domain represent minus one represents two things hey something went terribly wrong or it's 1969 I mean maybe you did something in 1969 that has left everything going terribly wrong you know I can't I'm not judging um the reason that nobody ever worried about this is the probability that you ever encounter this area is this error is incredibly low but it's not zero is it because time is an operating system service you have no guarantee that any operating system service will return with a correct value you don't control the operating system the operating system controls you there are days that feels truer than others but this is a point it's a service it is an external dependency it is not guaranteed to work it has no requirement to work time May genuinely not be available at that moment and there are also other reasons sometimes you can have an uninitialized clock on embedded systems this is more likely but the point is even on regular systems this is still a nonzero probability event you need to think of time not as something that is all around us but as a resource that you get like a socket okay fact I'm going to quote an Hathway's character from Stella um Dr Amelia brand she made the observation we need to think of time as a resource so when you write things as your when you think about it as testing I mean I know she was talking about something else but um I'm I'm going to repurpose this and also make references to films because this is one of my favorite films um so the point here is when you are dealing with time in your code it's an external dependency you need to treat it like a file you need to treat it like a connection okay it's not just a value that happens to change it's a resource okay so let's bring things away from the nasty world of external dependencies into the world that we think we control the world of algorithms the the joy of loops and code that runs without reference to anything external what we're going to do is we're going to calculate we're going to write something that's going to calculate the arithmetic me mean now if you want to throw some Concepts in there feel free to do that however I want the code to be readable so I'm not um we're just going to going to find the mean the average of a bunch of numbers and I'm going to write it like this okay so yeah that kind of that kind of works we accumulate from begin to end divided by the distance from begin to end that's great so uh so again quiz moments but this one's easy we got some values 1 2 3 4 5 six begin begin and end great what we're going to do is we're going to take the mean of the this what value are you expecting 3.5 excellent awesome you can feel good with yourself right I feel so good that I'm going to have some water now we're going to change the game a bit end is the beginning so this is an empty range what are we expecting so I've had a zero there's a mumbling of different answers which seem to be an exploration of the I e754 standard n now I've seen this one use i i attended a conference last year where this was given as a you know quirks of JavaScript code okay uh I mean JavaScript is is kind of like it's a it's a highly improbable language anguage um and that's how it feels to program it so anything happens um but actually it's I'm not this doesn't get blame this JavaScript doesn't get the blame for this one it's because this is actually very well defined in I e754 to be n it's defined to not be a number which I think we're all satisfied with it is not a number but it's different from dividing anything else by zero so we love a bit of consistency um but yeah it turns out that dividing by zero does not have when we say dividing by zero in i e 754 gives you um plus INF that's not right because dividing Zero by zero gives you something else now of course we're all familiar with Nan I mean you know thank you LT answer for this one um here's your JavaScript experience trying to pass Nan but it is not a number whoa yeah you can see that this is what happens when some calculation further Upstream generated something got converted to a string and so on this is what we call stringly typed code um okay so let's do a little more explorations of of nans because nans are kind of like they're kind of interesting uh so I'm going to have a set of values um which I should have which I should have probably fully qualified sorry about that I I I knocked that one off and I didn't mean to um I'm going to insert zero I'm going to insert 42 iert - 273.15 okay that's cool uh the size of this no I'm not even going to ask you this one's easy okay this one's interesting what's the size now it's not four it's three because Nan does not behave it turns out that doubles don't actually respect all those ideas people spend talking about oh is it strict weak ordering is it no they're not it turns out that nans are incredibly badly behaved they do not compare equal to anything even themselves um but is a nan less than something else is always false and is something else less than Nan is always false so therefore sets do their comparison based on less than ordering and so therefore um once you've got once you've got something in your set there's no way you can add a nan even though it's actually a double okay let's try something else let's put the Nan in first what's the what's the size now correct once you put a nan in it completely poisons the rest now a lot of languages actually say yeah this is really bad um we want we want our sets and things like that to behave in a sensible way and they Define an ordering for Nan and sometimes what a language will do is they say Nan exists above all others so it always Compares great or Nan exists below so that doesn't change the less than or equal than but it changed the specialized implementation but C++ has not done this so it leaves you with this kind of excitement um okay and in fact you know we can do count of Nan that was and and that that's not undefined Behavior there it is okay okay that's one that's great yeah so so is that yeah in fact I don't even need that there it turns out that because of that relationship it's just like oh okay in fact to get a real sense of this if you put a multiset in there's there's three of those um so this is a point that Nan is is is outside it's the way that we answer is one of the ways that we answer a question that does not have an answer but the problem is it doesn't behave like the rest of the type we are answering outside the frame so even when we have a marker for it will surprise us how much does it surprise us well it surprised uh surprised us enough in 2020 driverless race car drives it straight into a wall so if you're if you're looking towards the driverless car Revolution just a little bit of caution here um during the initialization lap something happened which apparently caused the steering control signal to go to Nan and subsequently the steering locked to the maximum value to the right this is the cont I mean if it wasn't going to be the right it was going to be the maximum value to the left but the point is or it could have just gone Straight Ahead either way this is bad something failed when I retweeted the article when I retweeted the post I found this uh from somebody said oh my goodness they're writing the code in the car with JavaScript because immediately people think nans it must be JavaScript people are very disappointed or even more shocked to discover oh no the whole Nan thing that that goes back to the 1980s we did not have to wait for the 1990s for that one to happen we blame this one on the 80s okay um but the point there no uh it was mat lab if you're interested it was it was not but yes cars do use JavaScript just to make you feel less comfortable um now the point is that we often have this idea of something not being something something being answered outside something and this kind of classification I was going through some photographs recently some failure photographs some failure screens and I found this one you can tell how far back this is the resolution is terrible this is like 2006 2007 uh phones these days have amazing I took this at Paddington Station in London paddington's not that there it is okay and and then you're looking at this go oh that's been delayed 1111 delayed wow yeah it is delayed because the next train is uh at 1828 um I I feel a reboot coming on in a moment um and then you're looking Aran wait a minute that how do you get to Aran from Paddington I mean I mean if you know anything about the stations in London of course you can't get to Arkham from Paddington cuz Paddington serves the west and Aran is East that's not the only issue of course but then you realize it's not a train this is actually what we call test data and somehow somebody messed up the uh uh system and Aran is alphabetically the first main station in the whole of Europe I mean it's hard to beat two A's in a row yeah uh so let's talk about other places where this idea of something not being has a problem I'm sure so have you had this experience you know you go to something and you have this momentary thing and I get it I get it when I use most a lot of apps most websites there's this moment where apparently all your stuff is gone there's a depending how fast you know my my heart just skips a beat it's just like wait a minute all my stuff whatever the stuff is if it's orders if it's money if it's it's a meetings it's appointments it's whatever for a moment Bo there's nothing there okay some in some cases only logged in members have access to this but I am logged in I am a me B and then suddenly it's there this is this is an uncomfortable feeling but it's also a failure to understand what the nature of the question is and there is a question there a question here about state so John karmac games programmer extraordinaire a large fraction of the flaws in software um uh development uh are due to programs not fully understanding all the possible States their code May execute in let's understand the states what we've got here oh somebody was taking photograph if you want the photograph of the uh there we go this John carac picture yeah that was the universe that was not me that was the universe there we go okay oh the universe is is enjoying this I think this is jens's way of trying to make sure that the talk doesn't go on too long but I haven't even hit like the first hour so um the point here is the way that somebody's done it and people are often very not very good at articulating the basic state model and I'm not saying you should draw diagrams all the time what I'm saying is do you have an understanding oh the frequency is increasing this is fantastic um what we have is there is a container of orders when we create the object that we're going to display the containers naturally initialize it to its empty State and the first thing we do is display it we say it's displayable and now what we're going to do is we're going to go and load up and then there's a m there's a period of time because turns out the loading is not instantaneous and we get orders three and then we display that and that's seen as a dis a second display event so the first display event is we created a display what's the container have nothing okay that we'll display that the second event is now we've got the results to display this is not the correct way to write this code it is the most popular way to write this code but it is not the correct way to write this code the correct way to think about this one is we are in a loading State this is not displayable that's why it's called loading when you receive the data we can do it we can do it come on yes it's loaded there is a loaded event at that moment we have an answer up until that zero was not the correct answer one was not the correct answer minus one was definitely not the correct answer Nan was kind of close neither of the Infinities were acceptable but zero is wrong so the idea is that this is an answer outside the frame of this now I'm just going to are we are we getting a reboot do we have no there everybody's run around there so we'll just we'll just we'll just move on excitement of the blank screen is too much yeah the frequency has kind of increased and the duration has also increased which is exciting yeah that's exciting okay right so the timing of please weight was good right so that's the correct way to do this the correct way to do this the correct way to think about it is there is no answer to your orders your orders cannot be shown they cannot be iterated they cannot be enumerated they cannot be counted they do not exist non-existence the absence of something is very different to there are no things okay so um this is um I would uh I would uh drink all of this very very quickly oh hang on can I just borrow that bottle sorry can I borrow this bottle sorry this bottle has a really important property it's empty so this is an empty bottle it has zero content it's listed as having 33 L as masul and capacity okay currently has zero this is is not a bottle do you see the difference there is a huge huge difference and yet a lot of code confuses these two okay it's like confusing null with empty thank you doesn't make any difference up there but nonetheless um so the point here is thinking about it in those terms and an observation that Nicholas Nelson makes or will make in a moment in 97 things every program should know is oh was this one's got quite long are we rebooting so what we'll do is we'll just go back to give you that sense of continuity and recap for those of you who are watching on the stream you're wondering what's going on it's all craziness here because guess what this is the real world and it doesn't matter what the software thinks this is the real world so to get the continuity we've got the ah there we go thank you the real world is still biting us but I am happy to take any questions at this point if there are any hello one question yes um what's you experience are there some compilers that do it better than others in terms of the um Behavior you scratch the surface onto for example is GCC better than clang in these edge cases the problem is so some of these are not to do with the compiler so so first of all a lot of these are to do with the way that we approach it in other words if we are talking about floating Point numbers that's going to be I e754 if your compiler is not doing the weird stuff that I describe then it's wrong it's broken so you know that that's so that so in other words this is specified weirdness the fact that um set or rather stood less still does not apply a total ordering to floating Point numbers is problematic because that makes it less useful okay um the point is I would like to be able to represent all of the values or to use all of the values that representable in a double even if they are nonfinite I would like them to behave as parts of that set just as I can order pointers including with respect to null Nan is effectively the the null of doubles I have a total ordering that works for pointers why do I not have a total ordering given that it's actually a specialized thing I'm happy for the less than Behavior to stay as it is because that's actually required by I e754 but the fact that stood less does not specialize that's not a compiler issue that's a standards issue um division by zero typically is treated more as a platform issue okay so what does Windows do versus what does um uh Linux do is really the question there rather than what does the compiler do where the compilers can make a difference is by offering you advice and warnings and that one is definitely your mileage may vary um in terms of what are the customizable warnings um can I turn the warnings up to maximum I don't have a real sense as to whether um clang gives me more feedback uh than GCC uh in these case they they they're good at some things and different at others um but basically the the answer to some of these questions without changing the core language or the underlying platforms the best we can do is um is first of all better warnings but the other things most of what I've shown you is blind spots in in in our awareness and it's us it's not the tools we can't can't blame the tools but I will talk about using the right tools later has that stayed I now I've had my so thank you very much for that question um I've had my back turn to this has this been up consistently kind of yes um do we want to do another question from the online World while we added or you yeah if there's a question from the online World there is a question if developer can't rely on operating system Services respect of time te example what could be used instead operating system is often assumed as alltime working part in a system I'm aware of certified OS but what about system using others um if you can't rely on the operating system what can you rely on uh well the standard answer to this is write your own operating system um this is what created Linux um and has created countless other operating systems I think the problem is that I don't think there is an easy way around it whether something is certified or or whatever what we want is well- defined failure behavior um because you end up that went didn't it um you end up with another issue which is one way of doing reliability is what was my last what was the last known value in other words caching yeah there's a little bit of an issue with caching as well which we'll come to there is no easy answer to this one uh but it is making more uh is making people more aware it's the idea that time te should have a more obvious return and I I you know we can argue about whether that should be um uh optional expect um exception or whatever but the idea is that it is not clear to everybody that this can fail and that's not advertised one more question yes all right um I've been thinking about the binary search like sample for a bit now yeah because uh the Overflow behavior in specific and uh I've been thinking like and you I'm just here to confirm my theory because we're using unsigned arithmetic with size T there the Overflow is like forced to happen with the standard but but if it wasn't assigned into adjusts overflow is undefined uh the compiler could catch that and optimize that away into the more solution where it adds up the difference right the point the point is unfortunately in this one it's it's more a case that the it doesn't matter if it's signed or unsigned you have a problem um and that the compiler has to know an awful lot about the context that you're working in and that would lead to a case where the compiler go you know strictly speaking I shouldn't but this looks like you're doing the mid point this is like clippy oh it looks like you're taking the midpoint of these two values let me provide you with the correct one and that means it's very it's very sensitive to very subtle um a very subtle implementation Fe feature um that could disappear in the next version certainly wouldn't be portable so I would be very cautious about that so I'd like to acknowledge that actually it's a fundamental problem with any form of integer signed or unsigned yeah I just wanted to know if the with the unsigned arithmetic is forced to fail that's the main thing and with signed it could maybe optimize it way or yeah the problem is unsigned is guaranteed to to wrap around that's the problem yeah so it's kind of almost back to front from what we wanted yeah okay so this we rely on this one let's let's pick this one up in most real world uh situations people's relaxed attitude to state is not an issue we are very casual with our conversations and how we relate to the real world um but unfortunately however many programmers are quite vague about State 2 and that is a problem so let's let's pick up on that other problem I'm sure people have come across Phil Caron's observation that there are only two hard problems in computer science cash invalidation which is by the way the problem of holding on to the last known good value of time uh when do when does that become invalid because you're returning people an answer even if it's wrong you're giving them a non-error answer but yeah it could be stale the data quality varies and naming things we'll come back to the first one later let's talk about naming things so there is a problem we have in the standard Library there is a header file called algorithm now why why is that that's it's not correct and we even talk about this as algorithms I even talk about them as algorithms but that's not really true is it I mean it's not that it doesn't contain algorithms but let's be very clear what is an algorithm so there's this wonderful book logic Comics um so graphic novel that really explores kind of foundations of mathematics um mostly through the lens of bertr and Russell's life but it brings in a number of other key individuals um frager and girdle in particular and there's one point where algorithm is defined what is an algorithm it is a methodical step-by-step procedure described in terms of totally unambiguous instructions which starts at a specified initial condition and eventually terminates with the desired outcome is now those of you who've looked at the standard is that what you find in the algorithms library that it tells you exactly what the algorithm is for everything no that's not what it contains I mean there are some that you know so let's look let's talk about find if you look at find by definition the wording of find is linear search there is no other way to do that that satisfies the constraint reasonably so in other words it's implied that it's linear search it's never stated so it's called find but it's actually it's linear search now if we're talking linear search then that immediately puts us in mind of hey binary search oh there is something in the standard that's named after an algorithm so that is an algorithm it's one of the few algorithms in the algorithm header but frustratingly for as anybody who first looks at binary search discovers it's almost entirely useless um because it just returns true or false it's like yes and this is really frustrating it's utterly counterintuitive that probably what you want is lower R whose name does not give you at all a clue as to what's going on but this is a binary search this is the binary search we explored earlier but we can say that yes this is an algorithm even though it's got a funny name it is an algorithm this is the kind of the classic binary search um algorithm but then we hit stuff like sort the standard resolutely does not define sort it gives a bunch of con I mean I mean it could call it intros sort because that's pretty much every implementation of STL these days but it's not required to be so this is an important thing the one thing that the algorithm header is short of is algorithms it's got a lot of operations that you might choose to look up in an algorithms book but it doesn't tell you what the algorithms are so it's a misnomer I mean poal I got you got to feel sorry for the word algorithm it's had a really hard life not just the STL misnaming it sorry Alex stenov mathematician sorry um not just misnaming it he's correct in saying what you want to focus on is algorithms but AB once you abstracted the algorithm you have to say do I care about the algorithm or do I care about its effect and once you are talking about its effect you are not talking about an algorithm anymore okay you are saying there are multiple implementations that can satisfy this desired outcome both in terms of cost and in terms um uh of actual um relationships to iterators and the like so they are not Tech most of what you find is not technically algorithms but also recently the word algorithm um apparently there's a whole bunch of systems out there that use large amounts of data um and do an awful lot of linear algebra on them a whole bunch of Matrix operations and they are called AI systems apparently uh even though there is there's an awful lot of artificial but not a lot of intelligence um but people keep saying oh it's the algorithm no it's not the algorithms it's the data honestly the algorithms are really quite innocent um they're very unsurprising if I showed you all the algorithms involved in machine learning it would bore you to tears it's not exciting oh look you're multiplying another thing by another thing and then adding it to another thing and then dividing it by a whole bunch of weights and then doing it really is not very exciting the algorithm is really not the problem it's the data yeah people have data structure data and Al people got distracted by the wrong thing it's not the AL so algorithm as a word has come in for a lot of hard hard time but given that we're talking about algorithms I want to talk about something it does not sa satisfy at all the standard permutation sort not safe for work it has factorial time complexity or OMG complexity so I wrote a series of Articles a series of blog posts in the last couple of years about esoteric algorithms uh they're quite fun because they're educational they get you to understand various things in essence it's an unoptimized search through the permutations of the input values until it finds the one Arrangement that is sorted to give you a sense in the worst case if I have 10 items it will take over 3 million shuffles it literally just sh yep not that one yep not that one in fact we might say hey if I'm doing this in C++ I mean C++ I've implemented this in a variety of languages well done C++ you take the least code so it turns out that C++ is a great language because you can Implement permutation sort in just a couple of lines okay yeah now what we do is we can do it like this we've already got stuff that does all the permutation work for us this is fantastic however back to chat GPT I said I I've done I did one other version of this talk earlier this year shorter version slight different an emphasis and it was in Amsterdam um at cotlin com now I'm not a cotlin programmer and I said this to had who invited me along he said hey we'd love you to do the day two keynote um uh for this and I said hady I'm at Best of cotlin tourist okay I'm not a cotlin programmer and he says actually we'd like something other than cotlin because day one keynote is all about cotlin announcements so maybe something a little bit more mind-bending okay and I said I've got some code in my talk and I will translate it into cotlin that's fine no not a problem and I'm looking I think I'm I'm going to do permutation sort in cotland and I'm hunting around my Google Foo is failing me I'm looking for a standard way to generate permutations I've implemented this algorithm in C++ I've implemented it in groovy I've implemented in Pon all it's easy in each case surely cotlin a language which people value for its Simplicity and its directness and its commodity I couldn't find it and then somebody suggested oh you should go and you should go and look at chat GPT and there was a reason they suggested suggested it yes the cotland standard Library provides a way to generate permutations of a list using the permutations function awesome here's an example of usage oh okay yeah list do permutations and then I can iterate four permutation and permutations oh cool nice this will output what hang on this is your first sign that there is something wrong but then it continues in great confidence not permutations function requires a sequence of lists where each list represents a unique permutation of the original yeah this means the permutations are generated lazily as needed rather than all at once you know what this is yeah so this is pretty good so that means what I'm going to be doing is I'm going to be writing something like this okay for per so I'm basically going to list I'm writing this as an extension method permutation sorted and I'm going to go through the permutations of the thing for permutation but I need to have a termination condition if it's sorted okay okay the only time you're ever going to exit it is in permutations is empty hence you return yourself okay that's the only thing there does the cotland standard Library have a way to check if a list is sorted yes okay is sorted extension function now here's a point you know it's an extension function which basically means you get to kind of add it on after the class has been finished it's very much like C extension methods if you're familiar with those uh here's an example of how you can use it at this time it does correctly give me cotlin that's the language so therefore I can go through this if permutation is sorted return peration awesome great fantastic this is all great this is absolutely brilliant I can write it in an even shorter form okay I can make it more um cotlin esque this is fantastic there's only one small problem with this this is a complete trip this is an absolute hallucination neither of these functions exist at all anywhere but what I love and again this is the pattern matching and the bullshitting it replies with great confidence and great Precision oh look here I have an example for you the interesting thing is it actually gives answers that are if they were in the cotland library it would look like this so that's the pattern matching at least the pattern matching kind of works it just can't tell the difference between what I'm thinking and what's real okay uh we have we have whole we have whole specialisms in medicine for people to deal with that issue okay this is a condition unfortunately some humans experience but it's we regard it as we regard it as some something that we help people with we don't weaponize it and put it out on the web so what's it so it's interesting because it makes a number of statements it says oh yeah these should be extension methods yes they would be in cotland that would be exactly the right way to do it the naming that is entirely correct the use of lazy evaluation so that you don't have to evaluate everything in advance because it turns out there's a lot of permutations like I said if you got 10 items that's over 3 million you really would rather not use all of that memory all at once okay you'd like to walk through them lazily defer evaluation so in other words in many senses it sort of gets it right if it were but it can't distinguish between the reality and uh that so I I kind of wrote my own is sorted and then I wrote my own uh permutations and I kind of got it to work so yeah you can do it so thank you very much chat GPT for telling me what it should look like but that wasn't actually what I was after I was kind of after something simpler but there is a point here it didn't have an answer and rather than say I don't have an answer it bullshitted it didn't know it didn't have an answer not every question has an answer so surely there can be nothing worse than permutation sort surely yeah yeah hold my beer so the classic is Bogo sort BOGO sort is the the the job of bogosort is to just Shuffle stuff randomly is it sorted yet no keep on going guess what C++ allows this has to do this really easily as well while it's not sorted random shuffle now there is a problem with this in fact there are two problems I'm going to fix one of them immediately the problem is if it's already sorted then we haven't yeah we're not really using BOGO sort the one time I actually used do while okay I want it to be independent of its initial input excellent now this is true Boga what's the other problem oh that no that's that's that's the next problem that's the problem after the problem stood random shuffle it was deprecated and then withdrawn technically it it's not there I mean it'll work on every single compiler that you're using but technically it's not there and the reasons are not I'm going to say the reasons are not good um the reasons are not sound the reason that random shuffle which is not spe random shuffle is not specified to use Rand Rand is not specified to be bad there are lots of implementations of Rand that are not good and almost all implementations of random shuffle do indeed use rant but none of this is specified implementers are free to change it so that it's better and if somebody says backward compatibility so what that doesn't matter and you know it doesn't matter because do you receive security updates to any of your devices yes you do all the time and guess what those the purpose of a security update is to invalidate backward compatibility we engage in Breaking backward compatibility every single day either as the receiving end or as the producers of the breakage if we see that something is not good then whatever is out there that depends on broken Behavior does not deserve to be fixed there's a lot of discussion sometimes oh yeah but you might break an existing piece of code that does not deserve to work is the bit that they're missing the fact that it does not deserve to work is the is is the reason that you withdraw it because otherwise you have small things like oh security issues so the fact that this was withdrawn I think is unreasonable because it means that people no longer have easy access the the so how do we solve this I go and use a meryan twister so now as a user of the standard Library if I just wanted to mix things up a little bit I now have to go into the random header now the random head there's a lot of good stuff in there the entry level to random is like this every other language oh I just want random stuff C++ does not cater for its audiences there are three audiences for random numbers one people who need to mix things up with a lot of control and a high degree of control and to know this stuff that's what this is for repeat able results that are statistically random if you want to know the meaning of Randomness I suggest you go to Fran's talk tomorrow no Tuesday when is it FR Tuesday Tuesday last day yeah stick around re rebook your flights um the other audience is the crypto AIC world where you absolutely don't want repeatability guess what C+ plus caters to the first two it's the classic example of catering to the expert audience and then there is everybody else which is actually the largest audience of all I often use Python and I will just you know sit there and go oh I need to just jumble this up so that it's not this you know it's it does I don't care about all these other issues that people are doing if you want to do a quiz for your kids class and you want to randomize the questions are you going to sit there and go oh I wonder if I should be using the meren Twister or not no you will not the point there is the largest audience of random numbers is no longer C for which is frustrating however there is another issue here I mean John Von neyman made this observation anyone who considers arithmetical methods of producing random numbers is of course in a state of sin so we do find Value in pseudo random numbers that repeatability I often tell people if you are using tests if you have tests and you are using random data please do not use true Randomness I want my test to be repeatable make sure that people know the seed so that they can repeat it okay but we can do that if you want I can tap into the entropy of my device now I don't necessarily recommend doing it like this this is slow and you will exhaust the underly entropy but when people say here's an important observation software cannot produce random numbers but computers can that's where we start remembering the physical world again yeah there is there is there's a little bit of a little bit of heat there's a little bit of uh Randomness and arbitrariness or non-determinism at the lower levels which your operating system can quite freely tell tap into you can read it off your chip most most os's will allow you to access that so don't exhaust it just use it for the seed and we're all good anyway we now have a we we now have a BOGO salt that works the question is and this refers to the observation that was made algorithm the BOGO salt algorithm but is it an algorithm hopcraft and Alman in the late 1960s were very clear a procedure which always terminates is called an algorithm we're not actually guaranteed that bogus will ever terminate there is no guarantee it's not like running through a fixed set of permutations so we've got an interesting thing going back to this and the famous quote so if you wonder where it was from Esra program testing can be used to show the presence of bugs but never to show their absence we're about to find out that this is the case because how do I test my implementation of BOGO sort is correct if it's not guaranteed to terminate so I can take some stuff I can look I can BOGO sort actual begin end I can assert that it's sorted uh or sorry as of now I think it's called contract assert if I want to be correct but honestly until the contracts until until it's in the standard it's not in the standard so assert uh and then I can assert that the result is a permutation of the original yeah or I can make my life easier and just make it easy I just say that the result is expected now I will say that I have run this a number of times and obviously every single time it's termin because there's only six items um and randomly wandering through this you are expecting termination but let us be let's consider this issue what if it doesn't terminate then how how do I deal with this how do I assert that this will terminate by Infinity well let's uh this is a bit of a hack so what I'm going to do is I'm going to assert false I'm going to set an alarm for when there we go so if this alarm executes at in Infinity then we failed we didn't sort it yeah I mean that's that's a true statement I can say it in English I've just written it in code there a small problem with the execution there's also actually another problem here Infinity comes from the mass header and uh is effectively you end up with a cast and infinity to unsigned well that's just garbage um so yeah um so I mean technically here's undefined Behavior so what actually happens at this point well if that's undefined Behavior then actually I can optimize that and that means none of the code afterwards is necessary and there's that see now that's the kind of refactoring I like okay it's good optimization H okay that what we actually what do we actually do in practice we put in timeouts we just choose you know one second that feels reasonable and that's an important Point we've just fixed the halting problem how's that for Sunday morning but what have we actually done the point is that the halting problem is phrased in terms of can we determine whether or not in a you know a priority whether or not something will terminate in advance of its execution and there are cases that we can there are cases that we know will terminate cases we know won't terminate and then there's a bunch of others where we don't even know the answer that's the problem there but we can resolve this by adding timeouts because what a timeout does is it says we will always have an answer we introduce non-determinism we will always have an answer the answer is yes no couldn't tell in the time that we were given yeah but you always get to your guaranteed termination which is nice but you now have to expand the way you answer your questions now this relates to another point every truth can be established where it applies we kind of already hinted that this is going to get kind of weird Kurt girdle this is an English translation and uh in 1931 basically said yeah there's some stuff that's not decidable so bertran Russell and Alfred North Whitehead set out over a number of years to try and formalize Mathematics in terms of something logical and to try and show that it was complete and consistent um prinkipia mathematico is notoriously unreadable and notoriously ignored um and notoriously referenced by many people myself included who have never even looked at the original text and never want to but this young Austrian mathematician s sat down and kind of worked through it and kind of like oh it shattered the dream it shattered a dream this was a this is the story of the early 20th century by the end of the 19th century everybody thought oh yeah we're almost finished with mathematics physics is almost done we have answers for everything and then Along Came quantum mechanics and Kurt girdle boom any consistent aaic system there will always be theorems that cannot be proven within the system okay and in this classic girdle ASA one of my favorite books I've actually had to get a second copy because the first copies Fallen apart um uh and probably one of the most one of the best things I ever got out of relationship with particular girl when I was in my late teens um her father was a mathematician and he came up with all kinds of recommendations um so I was really there for hanging out with her father um all consistent acatic formulations of number Theory include undecidable propositions okay so do we have any examples of undecidable propositions yeah sure how long is a piece of string okay what do I mean by that let's let's use stren Okay so we've got stren I I'll use the implementation that's I think it's given in kr2 we start zero we iterate through while we're not null and we increment we return okay there you go nice linear search algorithm not too hard for the morning um under what circumstances does this work well Zer ah yes you see that's the thing the easy one is let's two there's two zeros that we're interested in one is oh that should not be null so zero but that's not it the other one is there should be a zero now you'll notice that that's in Gray and it uses the ex itial and Universal quantifier because you can't write this in C and it doesn't mean anything if you could because what you're basically asking for that there there exists for an N such that it is indexable and it is valid so therefore you cannot reference un invalid memory and although you might say hang on doesn't my operating system allow me to check if a point is valid yeah not with the kind of results that we're after here and also that's outside the standard even if that did do it reliably the point here is that there is no way inside the system of stralen in standard C that we can demonstrate that this will execute correctly or that it will even terminate well the fact is that we know will the only way we can do this is by having a real machine with real memory and a real compiler with a real operating system at that point we interpret this but we know that but that's the point within the system of standard C in the context of stren we cannot demonstrate that this does the right thing you can only demonstrate by looking at how it's called you need the next larger context out the next larger system out so here we go ahead this is well- defined Behavior be excellent to each other and Sten of that 26 awesome if I go ahead and do this let's set up five characters that's bogus it's got no null termination but guess what C allows me to go ahead and actually use the literal quotes deceiving you into thinking that there is you know all of them were deceived there was in fact not a null at the end and when you execute it hey maybe you get that or maybe you fall off the edge of human knowledge into the precipice of what we often call undefined Behavior but there's no such thing as undefined Behavior yeah let's be very clear undefined behavior is not a thing it's an absence of a thing because something's what undefined Behavior belongs in the standard none of you work with the standard in your day-to-day code you cannot code in the standard that's not a thing that's a that that's the point is the standard describes something and then there is an implementation everything has an implementation and so therefore something will happen even if it's nothing and this is my favorite one this is a very easy way to get undefined Behavior fantastic just don't initialize stuff I mean you'll get loads of warnings on a decent compiler but it's you know don't do do this don't do this yeah but I'm going to let you do it I'm just going to tell you you shouldn't do it okay I referred to Vicken Stein earlier on this is the closing um observation of the tract arus and that's a point something does actually happen at this point so there is an interesting observation here that particularly also when we come to think about machine learning I'm going to refer to Adrian coll's observation here one premise of many models of fairness how do we demonstrate that a machine learning algorithm is or machine Learning System is fair is you can measure or prove the fairness of a machine learning model from within the system we that's what we're learning um properties of the model itself perhaps the data it is trained on to show a machine learning model is fair you need information outside the system the importance of outside information is important significant I'm going refer you back to 20120 here in Berlin there was an artist Simon verer who undertook a rather interesting you know the streets of Berlin are empty it's lockdown he got 99 secondhand Android phones and walked around the streets of Berlin with a hand card causing traffic jams because you cannot prove things like this you cannot prove when somebody is saying you get Google Maps telling you there is a traffic jam here no it doesn't know that what it knows is there are a bunch of slow moving Android phones in many cases that correlates with a traffic jam correlation is not cation that classic reminder and he just demonstrated that people often talk about measuring engagement but when I look it up in the dictionary the dictionary tells me that engagement is a state of being engaged or emot involvement or commitment I don't know that applications do that they don't measure my emotions I mean if they did they'd probably back away and go okay I'm really sorry here that's what you measure you don't measure engagement you measure engagement the observation here you're measuring clicks and shares we must be careful to not confuse data with the abstractions we use to analyze them really important the answer that you seek is not to necessarily to be found where it is this relates to other things philosophical the future is Noble before it happens again another statement that you already know you don't know the future well I hope so I'm going to refer to Grace Hopper who had this lovely observation programming is more than an important Practical Art it is also a gigantic undertaking the foundations of knowledge so let us classify the way that we know things I'm going to use the scheme set out by Philip armor the five orders of ignorance he wrote this up in 2000 sensibly enough he started at zero the five orders of ignorance zero a lack of ignorance you know that you know something I know that I speak English lack of knowledge you know that you don't know something I know that I don't speak German well I mean I have spiser cart and deut but that's it okay I know that I don't speak German it is not a surprise to me that I don't speak German and cannot follow a full conversation on the other hand if you talk about C++ in your conversation then curiously enough I can follow half the words at least lack of awareness ah you don't know that you don't know something oh that gets much more interesting you don't know how to find out that you don't know something lack of process you don't know the five orders of ignorance well now you do so we can get rid of that one now we can reduce this to a much simpler schema the known knowns the known unknowns the unknown unknowns and the knowable unknowns sometimes people say oh but kevn you missed out the unknown knowns what they mean is assumptions that's actually unknown unknowns you thought you knew something but guess what you were wrong yeah that's already catered For in this model but the one I'm interested here is unknowable unknowns the way that you cannot determine in advance the outcome of something halting problem is a classic example in advance given all the information yeah you can't work it out you have to change the game such as adding a non-deterministic um uh possibility this involves mostly the future this was a lovely observation a couple years ago yeah great advice I keep keep hearing yeah you got to Future proof your code okay when naming things like tables always future proof if you sell wine calling a table wines will be confusing when you expand to beer beverages will be confusing when you sell ice products will confuse when you expand to services so recommend they be called stuff or table one yeah you thought I was going somewhere serious with this no I worked with a developer and we were doing a code review this was years ago we're doing a code review I I was going through yeah yeah okay yeah this is good and then my eye caught the title bar Paul you you can't call this file stuff. CPP he said yeah sure I can I mean he said it's not wrong is it well true it does contain stuff but just because it's not wrong does not mean it's right okay so let's talk about the hardware side of things when we try and predict the future we do it at multiple levels so there is Branch prediction which leads to speculative execution what is the cost of U of A branch okay well this is the interesting thing um it's down to how well your CPU will predict stuff okay there was pretty much an order of magnitude difference between uh correct prediction and a fail prediction if the branch is always or never taken you pay almost nothing except checking the condition okay what what happens is is the hardware fills up the pipeline with the instructions and guess what it goes there and it's all good the condition was correctly foretold okay it was true it was false we branched to the right place we anticipated we have loaded in advance awesome but if you don't have any guarantees or any other indic ation then it becomes much more arbitary if it's a pure 5050 to cost you have to suffer a control Hazard and discard the pipeline taking another 15 to 20 Cycles to build it up again so you're talking about the cost of one to two cycles versus 15 to 20 so in other words getting it wrong does actually cost okay so there is an idea here we're trying to predict the future but there is a cost for not being able to predict the future normally that averages out but of course sometimes it does surprise people uh if you remember meltdown and spec I love the fact that these two um uh security issues got their they didn't just get a name most most violations get some kind of name but these actually got their own logos I think that's so cool but it also introduced the world of JavaScript programms to low-level programming um you know JavaScript I had this observation to make many years ago before that JavaScript developers criticizing C for being low-level and idiosyncratic I have a very well-developed sense of irony or none at all it suddenly meant given that this was manifesting these speculative execution issues were manifesting themselves at the JavaScript level it's like here's a language that knows nothing of its machine and yet is being exposed to uh behaviors that arise from that and it has no way of talking about it because it's not in the system of JavaScript but it applies at the low level it also applies at the high level people often talk about product road maps it's a it's a very tired metaphor um but I think it's a really valuable metaphor potentially if you're trying to say here is where our architecture is going here is where our Rel leases are headed this is what we're going to be doing over the next year the next two years I think a road map is a powerful way of thinking um and I I used to say this a lot in workshops and then everybody got stuck at home in 2020 so you have more time to spend online I thought Ro I bet there's a bunch of templates out there so Google PowerPoint templates for road maps oh my goodness there are loads and half of them look something like this they you a road fantastic that makes the metaphor real they show you a road they show it winding and the idea is you fill out your bits and so now you can have a a really cool presentation to impress your colleagues in Thea management here is our product road map and that's great except there's one small thing about this metaphor there's only one road here's a map of Center Berlin you will notice that it has lots of roads that is the value of a road map the whole point of a road map is it has options it has possibilities if there's only one road trust me you don't need a map where are you going down the road there we go we've answered it yeah years ago my wife and I stayed on a Scottish Island and she I'd sit in the morning she like okay where are we going to go stay where are we going to look with the kids you know the cottage we were staying at and she'd See Me online just like what are you doing oh I'm just uh using the map to figure out where we're going to go she said Kevin is one road it goes around the island your choice is you go left or you go right that that's your choices okay you don't really need a road map for that and she was right so the point is the whole so you see I think a road map would be valuable it's just that people don't know how to draw road maps the whole point of a road map is it shows options here's where we will probably be in six months this is our preferred route but there's a couple of other possibilities you show possibilities that's what makes driving with these things actually useful hey here's here's the kind of Route we started with but here's another route it's 10 minutes slower but it's more Scenic or oh this route's now become blocked this other route is 5 minutes faster you respond to the situation real development is about acknowledging Discovery it's not about committing to a path that you said oh this is wrong we now know it's wrong but guess what we're going to do it anyway okay we we have a plan so we're going to we we would we were going to do we're going to do the plan but it's going to go wrong yes but we will go wrong with confidence I mean you know and the point here is we have no process of determining the future before it happens you can actually tell this I mean here's another one that I picked up okay this is one of part of my Google search in 2020 you can tell this was done in 2018 curiously enough nobody predicted there would be a global pandemic in 2020 and that that would disrupt every single piece of work that they and their clients were doing and force everybody to work at home so yeah it kind of messed up a few deadlines nobody predicted that because it's very difficult especially about the future now what I love about this quote and this quote is kind of like humbling I put Neil bore question mark because we don't know if it was him there's lots of you can go out on the internet and there's lots of people who might have said it Neil spor is my preferred one cuz I like the quantum weirdness of it but we don't know and thisen happed in the past somebody said this in the past and we don't know who they were if we can't tell if we can't predict the past honestly we're screwed for the future so yeah there is a point which also takes us to this observation people often say this I did say I talk about tools you should use the right tool for the job people say this so often I know I've said it I find it in books I find it in posts I find it in talks I want you to pause for a moment and realize it's one of the hardest things you've ever told some to do because we don't know what the job is we don't know what the right tool is because we don't have total knowledge of all the tools and we don't genuinely understand the nature of what we are building until we have built it apart from that yeah this is easy but that's the problem you don't truly know as it unfolds as the future unfolds we have no way of going to the Future and saying guess what our tool choices our library choices our platform choices were wrong this is what you should have done and then passing that knowledge to the Past physics currently tells us we can't do that so yeah we have a bit of a problem there and that problem actually manifests itself in other ways because people often talk about you know we're going to prioritize things by business value we're going to prioritize our features our requirements by business value the next piece of work is going to be prioritized by business value there's a problem here physics tells us that this is actually not possible because you do not know the business value of something that you're working on until sometime in the future so here's an interesting thing you you can estimate you can prioritize by estimated business value but you don't actually know the future yeah the wisdom of Yoda applies at this point so there another Point here a distributed system is knowable and this is very easy to run into again this is very easy to run into particularly when you work when you're focused on the world on your screen this is the programming world as I see it the source code as I see it the it works on my machine thing you look through the world look at the world through the lens of uh your editor and although you may be aware of a whole load of stuff that happens in distributed systems sometimes you don't think about it from those points of view you think about it from from the code that you see rather than the context that it's in so things we need to appreciate so Martin Fowler messaged me this thought you ought to know that United may have discovered a kink in the SP time space continuum over the Atlantic um the observation here being that the time to destination was zero and it was halfway across the Atlantic um that yeah this is really not going to happen um the point here is the distance between Heath row and uh Newark is 55,000 km that's not 19 CM that's 19 light milliseconds no it isn't it's a blank screen that's all zeros there it is oh it's gone 19 light milliseconds that's the distance between basically London and New York so therefore if you have servers in London and servers in New York and somebody gives you the requirement that these need to be in sync replication needs to be in sync with respect to 10 milliseconds you can't do it oh you're not trying hard enough no really you can't do it physics says I can't do it you know take it up with Einstein I know he's dead but you're as likely to get through to Einstein as you are to get through a 10 millisecond snc you know it's a point there is that you are dealing with a system that has separations indeed every system has separations and latency the processor is filled with stuff like this this is one of the things that makes caching hard is the fact that there is a displaced sense of time around a system we are always dealing with distributed system sometimes we're just very good at hiding it from ourselves so in this book that I wrote Kor with Frank Bushman and Doug Schmid we gave a definition of distributed system a distributed system is a Computing system in which a number of components cooperate by communicating over a network and that is perfectly acceptable but very unexciting answer Leslie land ports is always much better a distributed system is one in which the failure of a computer you didn't even existed can render your own computer unusable yeah that's more like it and we find this kind of loss we we find this issue this disruption of the illusion that we normally create the idea is that software when we create software we are creating an illusion and you get a choice in that illusion you are telling a story and that story it's like oh my story involves objects and functions my story involves these abstractions and these layers you are choosing the story you want to tell but you need to remember it's all an illusion and it can come crashing down when it contacts reality as is the case for one of my books um you know somebody yeah can't read your ebook in Pennsylvania that's my my it's my publisher O'Reilly well this is awkward due to fires and power outages in California it's unavailable due to problems with this device behind us the screen is currently unavailable um but this is a point here we perfect example of lamport's uh law now all of this ultimately boils down to Brewers theorem um which is probably better known as the cap theorem he proposed it as a set of principles Eric Brewer proposed it as a set of principles in the late '90s um but it was actually then later shown to actually be a theorem cap standing for consistency availability partition tolerance um so let's look at these first two consistency and partition tolerance the point is that you can choose any two but not all three that's what that's what cap theum is consistency on a network if we ask for data let's ask for data at two different points and we get the data value we should have an agreement on that if the two of us are sitting next to each other and we are using a social media application for example and I post uh an update and I can see that update and you do a refresh you should see that update as well you should see the same values okay consistent we see the same thing for correct values partition tolerance is the Obscure term here partition tolerance basically means if your network becomes a notwork okay if basically something breaks down it partitions oh we have one network now we have you know a router goes down or something goes down somewhere this basically says you either see the same thing or you see an error State okay we will never show you a value that is inconsistent with what other people have being shown but the application will still run it won't crash it w't go oh the Network's down somewhere or somewhere there's a fault crash it's just going to go no I can't give you I can't give you the answer that you're looking for at this point there is no answer we kind of seen that one then there is no answer the next one you have to imagine it for those of you online you're already seeing it the next one is availability in partition tolerance we always get an answer even when there's a problem we tolerate failure but what we do is we hold a cash we hold on to a value you get to see the older value so in other words there is always a value available but that value might be stale and it might not agree with what other people are seeing okay no still not back okay and then the Third option is the kind of curious option you can have a value and it is consistent and it will always be correct or we will crash in the presence of a netwk network failure that turns out to be less useful and people normally go for one of the first two but the idea is you can have any two of these you cannot have all three by the way there are some very interesting implications of this for things like nfts and cryptocurrencies um uh in terms of uh uh B but I'll leave that as outside scope for today so the wisdom of Douglas Adams disappears from the screen even as I speak but the wisdom of Douglas Adams there's a lovely bit in the original hitchhiker's book we demand rigidly defined areas of doubt and uncertainty the cap theorem is effectively a way of saying there is just a limit to what you can simultaneously know it's basically Heisenberg uncertainty principle for the distributed system there is a limit to what you can know you know more of one thing you get more of one quality you lose more of another so we can kind of return to Phil carton's observation that's where we get the cash and validation and naming things we've done the naming things cash and validation and you've probably experienced this one every now and then haven't you you you're looking at the screen and it says hey you have two of these things as you're looking at a list of three things I get this in a number of things I've had it I've had it with Gmail but I've also had it you know tumble at pretty much anything it's just like it tells you you have n of these things and there's either n minus one or n plus one but it's not in and you're looking at this going like how the hell did you screw up this badly because clearly there's a piece of code that has just iterated three times and yet you're telling me this and this is a real problem that we end up with because obviously the answer is easy this is a problem that you end up with fracturing micro micro front ends and things like that where what you're doing is you're holding one piece of data that you got from one query source and then you've got data from another query Source but you have not reconciled them and the point is that reconciliation is I mean you sometimes people say oh yeah well you know cap theorum eventual consistency that's why you're showing this it's like well no that doesn't make any sense it's a feature of a distributed system that it may not be in a consistent state but it is a bug for a client for a single thing that can be made consistent to be inconsistent with itself that's different you have total control over the local stuff if you have one process and it has two values and they disagree with each other then you need to reconcile that yeah you need a way of breaking the tie on that one so the final thing technical debt is quantifiable as financial debt now this is an interesting one because it's a this is an interesting one because every now and then people say oh well we got this much technical debt and they going quote a value in euros and it's just like yeah look it's it's on our dashboard this is how much technical debt we have in our code okay let's understand the origin of this and then the resolution an observation made by my Layman back in 1980 based on his work in the 1970s so is going back quite a away um as an evolving program is continually changed its complexity reflecting deteriorating structure increases unless work is done to maintain or reduce it this is a this is way before the termin techology that we now use to describe systems um was there but what I like is that he actually uses a term that we have somehow repurposed well not quite correctly maintenance he's acknowledging that the very Act of creating something will disturb the thing that is already there and you will end up with collateral problems that AR necessarily going to happen if you decide to cook a meal you will make that means you will end up with dirty dishes that's not a that's not a choice to not have dirty dishes the choice is what do you do with the dirty dishes your goal was not you know what am I going to do this evening I'm going to make some mess in the kitchen yeah but are we going to eat yeah maybe the the goal is we are going to eat I am going to cook something it is inevitable that there's going to be that and this happens when you even if you are the most focused on the quality of your coat as you are developing it it there will inevitably be some kind of collateral damage to your existing code because you are focused the nature of human focus and this is the dirty secret to a lot of these things when you are focused on one thing by definition it means you are not focused on everything else the concept of focus means you are ignoring good Focus means really good ignoring and you may have a number of ideas in mind but there is a chance that if you've changed some abstractions and you've changed some Concepts they are outside the scope of your focus and that's not a fault of you anymore than it's a fault of Being Human because if you've got good Focus that you you you will inevitably have this you then have to pull back and look at the kitchen and go oh my goodness who made this mess oh wait a minute even when you're doing the right thing you will discover things are not you will only discover afterwards it's inevitable it's not a kind of an option it's not laziness it's not it's an inevitability the degree to which it happens that's a separate question but that is what we talk about when we talk about maintenance in the real world maintenance is to do with the physical interaction of doing stuff and physical wear and tear if I have a washing machine then the washing machine can break because it's physically used we physically in are physically involved with it there is wear and tear we need to maintain it code does not experience wear and tear of itself you don't leave a piece of code for 10 years and then suddenly you come back to it 10 years later it's like oh man look at this the curly brackets are falling off it's so old the code does not age you may feel like it's aged but that's because you have changed that's not the code that's you that's a relative thing and that's quite a nice feeling you should hopefully always look back occasionally you look back at your code like wow I must have been on fire that day and it's just like oh man I'm causing a fire that day it's more often the the case you're looking at something going like oh and guess what well done you now know more than you you did then that's great because the knowledge that you you're always working with incomplete knowledge the knowledge that you need to do the thing you're doing today lies in the future but you're still able to make progress it just means that in future you will go now I know what I should have done now I know what the right tool for that job is because I understand the tools in the job but more importantly with that code we're saying you need to maintain it it's not the code itself it's our interaction with it now that kind of matters because is to do with the alignment of our metaphors when we often talk about these things we are talking about the language we use these days is often technical debt I hear a lot of people say oh we have a technical debt problem now I'm not going to say that people don't have a technical debt problem but I am going to say in most cases it's not the problem it's the effect and we've confused the cause and the effect technical debt is often the effect but the question you have to ask is how did it get there oh it just happened no it didn't just happened the real problem is not that there is technical debt technical debt is fine somebody says oh we've got lots of technical debt yeah but what's your problem what we just said Kevin we've got lots of technical debt okay think about the debt metaphor I've got a lot of debt okay I prefer to have less debt is it managed or unmanaged debt that's the whole point of the metaphor are we managing it oh yeah yeah we've got a really solid restructuring approach to dealing with our debt we rest Ure our debt we're repaying it every Sprint we we repay it oh you don't have a problem with the debt yeah you've got debt but you clearly got it under control you know my wife and I had a mortgage that's quite a big debt but guess what it was structured it was structured over time you knew exactly what was going to happen every month we also had control over it and in return we got a house awesome so there's a clear tradeoff there is not an intrinsic problem with debt people have misunderstood debt is not a way of saying this is bad the whole idea of debt was slightly different the problem that most people are experiencing is neglect we have the term neglect elsewhere like physical neglect emotional neglect the idea is and this is why neglect is hard to see because it's a thing that doesn't happen it's not a thing that happens it's a thing that doesn't happen you can't see a thing that doesn't happen it's really hard to spot most systems struggle from the thing that does not happen the way to look at it and this kind of came to me when I was thinking about think about this with a u one company I visited twice different periods of time well actually three times but uh there were two key visits one hey we got all this Legacy code we got all these problems we need to deal work out what to do with our Legacy code and so we came up with some ideas and they applied them and you know what that kind of worked out and then later hey we got all this Legacy code it turns out they'd overlooked one thing thing and so had I the reason there is a boat on the screen in a moment the reason there is a boat on the screen is you have to think you're out in that boat you're out in the water there are holes in the boat what are you going to do the boat is sinking okay this is fine I can take the water out you know what you get real yeah you start taking the water out yeah you haven't quite solved the problem it turns out one of the things you have to do is stop the water coming in as well and that's the bit we're not very good at we're very good at saying oh my goodness let's get the water out what do we do with all the unmanaged technical debt we've got but not how do we stop writing code that does that in the first place how do we not create the situation that we find ourselves in that's what's really going on however the question here that I want to explore is this actual specific aspect of the debt metaphor itself it was introduced by Ward Cunningham the debt metaphor was introduced by Ward Cunningham in 1992 but it was popular some of us were using in the 1990s variously called technical debt quality debt design debt there are a lot of terms Martin Fowler helped popularized it about 20 years ago technical debt is a wonderful metaphor developed by Ward Cunningham to help us think about this problem like a financial debt the technical debt incurs interest payments which come in the form of extra effort that we have to do in future development because of the quick and dirty design choice but the key thing here is the word metaphor it's a metaphor it's like financial debt but it is not the same as people often then make this mistake they make the mistake as as I tweeted found myself again cautioning the category error of treating technical debt metaphor literally and numerically converting the code quality into a currency value you do not know what the technical financial debt of your code is that is not possible there are a number of reasons it is not possible but I this doesn't stop people doing it it's it's a metaphor treat it like a metaphor it's a way about it's a way to give you language now why is it that you can't do this now sometimes people will say well no no we we know the technical data of our code look we've got duplication yeah but what is that duplication costing you you know come on come up with the Euros euros and cents value the problem is that some duplication is actually helpful because it introduces decoupling if you look at a large system some duplication is actually avoiding creating dependencies that's a contextual tradeoff you know enough to be able to say this one costs this one doesn't here's a whole bunch of dead code well sure we should write it off but the duplication in that code costs us nothing in fact nothing in that code cost us anything I mean we should delete it but it's not worth the same as technical debt that might manifest itself in the main part of the program so the point is the tools that do this do do it naively and incorrectly but then occasionally I get the idea sometimes people say oh well no technical we know the technical dat in our code we've estimated not in money we've me estimated in hours we've gone through as a team and worked out how long it would take us to fix the technical debt to repay the technical debt okay that's reasonable but that is an estimate of the work required to repay the debt but technical debt does not equal the cost of repaying the debt that's a misunderstanding of the metaphor the whole point of the Met for is The Disappearance on the screen is that technical debt is the cost of owning the debt that's not the same as today's repayment so the idea here the message of the technical debt metaphor it is not simply a measure the specific work needed to repay the debt it is all the additional time and effort added to all the past work the current work and the work in future from having the debt in the first place and if you're remember we can't predict the future you don't know what this is going to cost you you can you can work out how much effort it will take you can estimate that but that's not the same as the cost of the debt that was the point of the debt metaphor in the first place to allow you to reason about it it's actually a complex Financial instrument so we reach a conclusion and we reach lunchtime and instead of having time at the end I've ended up with time in the middle but I'm happy to take a couple of questions if the lunch you know but I'd just like to leave us uh with Alis huxley's observation reality cannot be ignored except at a price so thank you very [Applause] [Applause] much so um so you can escape if you want to um but we will take a couple of questions now um yeah there should be lunch outside probably upstairs maybe downstairs this sounds very probabilistic there's a there's a rigidly defined sense of Uncertain unknown as we learned today um I just ask an online question now what are the tools or language features to handle Nan um is Nan I mean really it that one is it's one of things it's well defined where it occurs it's really a question of awareness and don't just rely on yourself rely on other people rely on other tools as in static analysis if they're able to detect it but mostly the tools you're relying on is your colleagues and your own awareness use checklists when you are testing for things if you are using floating Point numbers always ask the question what happens if I give this a nan okay the one question I didn't answer with arithmetic mean is what happens if the input data has a nan I carefully remove that from the talk because it it takes a it's a much bigger question but the idea there is the tool you're mostly relying on is this and other people and anything else a static analysis tool will give you but mostly it is the awareness am I using floating Point numbers am I casually treating floating Point numbers as if they were just integers or real numbers and if the answer if you can see that then it's like okay here we need to check this but there's there's nothing magical I can offer uh beyond that well what are your thoughts on do things the first time practice do things the do things right the first time practice in software development versus have tradeoff between quality and focus on getting features out fast can quality and fast delivery go together okay yeah so this is a very this is a question that has a very big answer so I'll try and give a very small answer to it but with the acknowledging that it's incomplete um the idea of do do something right the first time um you're the probability that that will happen is quite low and the problem is that sometimes what we do in try it can end up we're working with a limited pool of knowledge in other words we start thinking oh I am doing it right but what we're doing is actually closing down we're focusing on something here and not looking at a bigger picture so what we end up doing is missing certain things so my my general advice is do something as well as you can the first time it may not be WR but but here's the trick play with an open hand what do I mean by that um card games card games uh vary in their format there's lots of different kinds of card games some many card games are closed hand you can't see what everybody else has got some are open hand or partially open hand you can see something else on the table you can you can see what's going on the idea is you want to play code with an open hand think about your conventions communicate what you're thinking as much as possible in your names in your structuring um any supporting documentation you offer things like adrs and things like that in your test don't make your test just test for correctness make your test Express what you're thinking it doesn't mean that what you're thinking is correct but you're playing with an open hand somebody can come along later and go oh I think you've made an incorrect assumption here that's someone might be you it might be in one hour but the idea is if you play with an open hand what you're doing is you're offering people here's what I was thinking your thinking might not be right but showing what you were thinking it's much easier for somebody to then come in and go ah yeah we can adjust this and we can Converge on what is right so my thinking on the whole process idea is play with an open hand uh be be wary of perfectionism um perfectionism is a is a dysfunction um it is actually behavioral dysfunction there's a psychological aspect of perfectionism and we often fall into without realizing it um but that doesn't mean oh you know what I know this is a really bad practice but I'm going to do it anyway no it's I am working at the level that I can currently work at but I'm going to show you what I'm thinking because I might be missing something yeah and that's the idea play with an open hand uh and be as as as open with it as possible but iterate allow convergence okay yeah and a real question from a real human being I'm not saying that all you people online are not real I just I just don't know okay I mean you could be dogs you know and there's not I've got nothing against dogs well done we'll we'll pause for effect okay so we are not measuring engagement but no only a few counts um continuing with the discussion about we cannot know the future so we have to estimate all our projects and we should estimate like what we expect now multiply it by three and assuming we get it the first time right with the estimation so we succeed then we have to write it again and from learning the second time we can write it for the third time and now it's actually a good program isn't it kind of the the thing is that what you get so the thing is that we we have a metaphor that we um often use um without realizing it we use a manufacturing metaphor in code and it turns out the compilers are great at this metaphor build pipelines are great at this metaphor we are not very good at this metaphor um when we are doing something most most of the time the reason we are writing some codee is because that code does not exist that means that we're doing something new now the degree of newness varies it's either new to me or it's new to the world you might be writing functionality that does not exist in the product or any product yet so there's a whole ratio in which it is new now what does that mean in practice it means that it's not necessarily repeatable which means that we've got to be very cautious about our ability to get better at our estimates because sometimes we do get better at mostly acknowledging oh this one feels familiar I see this problem there's enough familiarity that I can Converge on this one this however is a big unknown I cannot estimate it with the same uh with the same um uh variance it's got a much larger variance I genuinely don't know because I've not done anything like this before we as a team have not done anything like this before we as a company have not done anything like this before we are using a new technology stack we are dealing with a new product domain the more new something is the less likely it is that your estimates are going to be able to converge with any kind of meaning but the problem is because most software is about creating something that doesn't already exist you will always be dealing with some degree of variance so the trick is really look at the things that look at the things that become more determined but also be very careful to distinguish them and not mix them this is the biggest problem with estimates and adding estimates together in the world of estimates 2 plus 2 equals 5 because when I say that this takes two days and this takes two days what I'm saying is that this is two plus or minus some amount and this is two plus or minus perhaps a larger amount 2 plus 2 does not equal there's a skew in the distribution it ends up being five plus or minus and so that's the issue so the the real trick is to learn to distinguish between the things which are familiar and the things which are not and don't mix them by adding um in a simple way yeah so we can get some convergence we can get better at it but it might vary yeah and it's never perfect and of course it's never perfect the knowledge that you need is in the future but as human beings we are always very human beings have this wonderful ability we work with incomplete knowledge we are great at it we get up every morning we have no idea what's going to happen that day and maybe we have some idea but the chances are it turns out I mean if you knew what the next talk was going to involve you wouldn't bother going to it because you already know it the reason you're going to it is because you don't know it and that that may inspire a conversation that leads you to somewhere else else and leavs you to have a different conversation afterwards and perhaps you don't go to the talk after or you go to a different talk you can but that's fine CU you're human and your superpower is being able to work with incomplete knowledge the problem arises when you fool yourself that you have complete knowledge yeah that's the problem if you wake up and go I know exactly what's going to happen I've got a plan for this and this is my day and nothing is going to change that at that point your road map is set to fail okay and on that kind of big note it's lunch thank thank you