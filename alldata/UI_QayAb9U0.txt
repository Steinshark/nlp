and we are live with the next talk for meeting C++ 2023 today this talk is with our new speaker mikin um really looking forward to your interesting talk um also again interested in the same thing in starting C++ projects in the Modern Age so um I'm really curious to see what you have to say please take it away M hello welcome everybody today we're going to talk about how to start a mod C++ project my name is melkin and let's look at our agenda so the first thing is we're going to talk a little bit of my motivation and we'll try to start a new C++ project we'll talk about build tools project layout tooling dependency management continuous integration and even look at some IDs basically everything what you need for uh to create the project so before we go a little bit about me I'm a principal software engineer at remarkable I'm a C++ programmer for the last 12 years I believe mostly I'm was interesting in some more lowlevel stuff like networking framework libraries build systems not that much yes and I usually don't like to talk about myself as you can see um very shy uh but today I think I need to tell about my journey I think it's very relevant to to the context to understand how hard is to start a C++ project so I started as a bare metal developer and it was most C and some C++ uh then I started to work with the realtime operating system it was also mix of c and C++ and at some point I moved to develop Linux kernel and there was Zero C++ and by that time I wasn't sure what I want to do do but at some point I kind of uh once I touched C++ I didn't want to go back so I quickly switched to work with embedded Linux and by when I started to work with embedded Linux I almost the same time started work with a regular Linux I don't think there was a big difference between them but people called it differently so I just follow the tradition uh when I started to work with the Linux I also started to work crossplatform so that means I started to work develop my application also for Windows and Mac and then I attached mobile development and even web development most of my journey was C++ related in that regard and oh yeah forgot to mention that I also develop and Frameworks yes uh the interesting thing is what was the common between all of these uh jobs and uh if we just look at one job another one and yet another one so the the common was only subset of C++ so but what's more interesting is what was the differen is differences um the hostess was different uh the build tool was different C++ standard was different uh subset of C++ was different sometimes you're allowed to use templates sometimes you're allowed to use uh Ral keyword or exceptions or return code or ndi like it's so many things in C plus plot and depends on the project and requirements you might not able to use any of them so there was also different libraries I highlight two of the big one like boost and cute and uh yeah some projects most based in cut some projects was based on Boost and many other small libraries around uh the project layout was completely different and um it's basically from yeah project to project you can end up completely something new uh uh continuous integration and uh deployment was a different uh dependency management was different I remember when I just started there was basically no dependency management at all so it this completely different world back then and the tooling around was most different so what did I learn I learned that everybody Ed C++ but differently I learned that everybody built C++ but differently I also learned that everybody use some tooling but is the different options I also learn that some best practices are the same and I think C++ now has a lot of good practices around like don't use new use the smart pointers and you can find a lot of things on core guidelines C plus core guidelines so I think there is a big adaptation of this uh practices nowadays but still sometimes they're different and it also depends on the project so a bit of my motivation after I told you my journey so one year ago I started to learn rust and I was quite surprised how easy is to set up a project how basically how easy to build stuff easy to manage the dependencies and I was very surprised uh so also the go language it wasn't that straightforward at some point as rust but it has a good good default I would say uh and also one of the motivation was CPP front for those who doesn't know CPP front is the like a typescript for C++ from herb Suter and particularly I was interesting in that slide which you can see where herat says like it's basically CP from is one CB file and you can build easily just like that and I was curious is it like that so I decided to try to create a modern C++ project and see if we can do that as a her describ in that slide so let's create a modern C++ project um let's take a look at this pretty simple example where we have a Hello word very tradition one and let's try to compile it we will compile to GCC first and we will get our hello world then we we can compile this that and we will get our hello world as well and we can compile it with the msvc and suddenly we are getting our first eror um AIT spoilers we will get a lot of Errors today so and if you look at the error it says stream not includ path so kind of not really understandable but turns out what you need to do is you need to first um prepare the development environment you need to execute a script which will set up all the path and environment variables required by msvc compiler for those who never develop in Windows might be kind of surprised by that but yeah after that you can compile and get your hello world very easy uh next one is the Kang uh it's like a wrapper for the msvc you can execute this one will also produce the executable for Windows but um you don't need to set up the development environment that case it kind of manage it by itself okay now let's think is it actually a modern C++ project I mean that hello word looks like um I don't know 10 years ago so uh one year ago I've been at NC Tech town and there was a teamwork who was uh sh the modern new Hello World example which I kind of liked just for fun thing you see on the red rectangle it's actually me and I didn't do it on purpose but accidentally I end up to be in the color yeah so let's try to replicate that example and go even a little bit further we can actually import uh instead of print we can use eort SD because it's also part of C++ now modules so let's make it even more modern and okay let's try to compile it so the first we will take the g++ and we will get there on no type name import it doesn't really tell us what's going on but I guess maybe we need to specify the standard so I will supply STDs equal C++ 23 and we will get the eror fatal error module STD not found so turns out that GCC does not support uh doesn't provide a STD Library as a module yet so let's try with scal and as you can see we supplying standard also but we Supply a bit differently C++ 2B so first difference between the compilers we will see today and we will also get similar error and then turns out that also doesn't provide STD as um stud module yet so we cannot use it so let's try the msvc and if we Supply we say the latest standard you see it's again different we will get this error so I was quite upset when I first time compile I was like I thought it's supported somewhere at least but then after a couple of Googling I found out that you need to execute this couple of comments and then you finally get the hello world I I'm not going to explain why you need to do that but I'm just showing it so it's kind of hard so maybe it was too modern so let's kind of go back and reflect a bit so if we cannot use import STD quite easily so let's go back to the print version and trying to compile it again so now we're actually compiling already with the C++ 23 standard and they er again print no such file directory H turns out that print is not also has been implemented by GCC and if the same for Kang we will not able to get the print but Lily Miss now works they already implemented print so we can use it and get hello Ro so what we're going what what we're going to do should we go back to STD see out and E streams or we will able to still be modern enough and the answer is we actually can use fmt Library it's almost the same as a stady version and uh those who doesn't know uh stady print is actually based on fmt print so we can use that one Library instead of and be modern still so let's try to compile and you will notice that there is three red dots I actually not showing how many flags you need to pass to actually describe where to get fmt Library we'll talk about it later so just let's imagine that magically works we will get our hello world so then if we do the same for K we'll get the hello world and for msvc we again get Hello World perfect I think everything looks great but there is one BTS uh and uh I still want to use print if it is available because now I kind of set mod C++ project one line yeah I want to use print if it's possible so what we can we need to do is we need to do something like that and um so what it does is we kind of include version header which actually tells what kind of features available with uh standard library and then when we compile with g++ or clang we will we will check that if CPP Le print defined it will be not so then we will use fmt and we will get hello roote from fmt yes and when we compile this um msvc it will check that CVP Li print is defined and we will use the standard Library print so kind of cool but I think it's it kind of becomes mess already so let's summarize what did we learn so it might be tricky to start the modern C++ project you need to be aware what's the standard Library support uh with the compiler you chose and kind of tricky sometimes we also learn that the compilers are not the same the flag are not the same standard Library implementation is not the same and there's many many other CS which you can find when you build a big project cross project uh building is tricky so we kind of I said that these three dots you don't need to think how it is and where is the library came from so the flag are different so it's a bit tricky or it becomes tricky quite easily and the code could become messy very quickly so if you um if you look at the the final version It's kind of um yeah hard to read hard to understand and we definitely don't want to write code like that so what we're going to do after that is that we're going to go through all these three major pain points tries to solve them and we will try to learn something out it so let's start the compilers not the same flag not the same stand library is not the same so we need something that unifies that so we need a build Tool uh we have many build Tools in C++ which one to choose it's a very hard question but I I hope I have a very simple answer it's called cake and I know that cmake is not the favorite buildt tool in the C++ Community it has a lot of controversary I would say that it becomes the factor C++ turn of to and if you look at any um survey or polls you will find like for example this one it's from jet brains from their ecosystem survey most of the projects now migrating to cmake also there is a nice quote uh which was in the same survey is I'm record as um liking C to Stockholm syndrome for C++ engineer it has become the facto standard for better warse as demonstrated by the clear lead it holds over its competitors so yeah as I said not everybody likes cake and there is also another survey from isopp which also clearly shows that cake is most popular build system build tool right now also from the same isour CPP you can see that are major pain points is actually managing cake projects it kind of semi proov that cake is the P C++ build tool um but also there is also interesting other pain points is like how to set up a development environment and we saw it clearly like if you never worked on Windows you might don't know what you need to execute uh yeah people don't know how to it's like hard to set up the continuous integration pipeline because again you need to set up the developer of environment and many other things and managing libraries for Fore application and as I said we can of bypass it right now but we will come back to that later okay uh let's start with quick sake intro so those who doesn't know sake is a metab build system uh it's not actually cake is not actually building your uh C PP files it's actually uh generate some platform specific build files like Ninja for example Visual Studio files and Ms build and so on and then it's you kind of execute them or see make execute them for you uh it's cross platform so it works kind of on all major platforms it's configur ofish the reason I put is is that you can do so many different different things with simic and then it's kind of very hard to manage it as it was shown in isbp sorry and it's also scalish so you can do you can you can kind of build a mon ofish sake but at some point you will start noticing that configuration step is quite hard building is quite hard there's many things you will see so it's scalable until certain point in my opinion okay so let's um kind of try to make a small cmake project and look how it looks like so you need a here go CPP file and you need to add the cmakelist.txt and SED this file you need to say which minimum version you're are going to use of cake you need to also Define the project name and say Which languages you want to use then you create executable Target then you tell what kind of sources related to that Target and then you can Define some C++ properties for example uh we want to use C++ 20 standard and we don't want to use any extensions from the compilers want to have a strict so then uh until you have that file you can call the configur step and you need to say c-b build dot basically point to we're pointing where the build folder is going to be and pointing out where is the sources for cic and if you don't specify dasb built and just ignore it you will basically it cake will generate all the madness of file in in your Source folder and not really good so you can think about cm in that regard it's similar to C++ it it has B defaults so you always need to don't forget to do the right thing and then one until you configure the project uh you need to build it you just say c d d d build and you supply the build folder and it will build for you and then you can execute your executable we're get hello world so as I said c has bad defaults and you don't need you don't want to kind of all the time remember what to do and how to configure your projects so there is a solution for that and and it's called cake presets SX presets is basically a two Json files one of them you're supposed to keep into your repository so it's CX presets Json and the second one is cake user presets and the Jason this is kind of your user customization point so the idea this is this Json files supposed to tell how to configure project how to build it how to test it how to make a package out of it and how to run uh how to test not how to run youru C pipeline so it's basically a way uh to a way to provide the good defaults for the project so let's go step by step and look in each of the um presets first let's configure presets and you can say what's the name of the preset presets could inherit from each other you can choose which generator you want to use for example I prefer to use ninja multic config you can select ninja you can select make files or you can just don't select anything and then it will choose something by default uh you can also Supply the binary there and as you see now now when you kind of invoke your preset you will always be in the build folder with the preset name so your Source folder will be polluted which is great you can also specify the tool chain file this is might be important for those who has working some embedded where compiler and flag are not is foundable or not included is the platform so you have to have a specific tool chain file you can also Supply some cache variables which is basically could be your configuration something from your project you can supply some environment variables and condition when this PR is available for example could be only Windows preset or only Linux preset something like that once you add the configure preset you can do a build preset and the build preset is basically described how to build it um so yes um you again give a name the build presets can adher it's from another build presets you can tell which configur you should actually tell or you have to tell which configure peret it should be used because then it knows where is the build folder then you don't need to show where it is you can say which targets you want to build sometimes you want to build different targets for the different uh presets and again you can supply some environment variable and conditions when um that preset is available and to execute it you just say cake that D built D preset base and if you use a ninja multi config generator you can also choose which one you want to build debac or release or any other configuration um okay once we done the building part now we need to test our code and in that regard cake provide test presets and for those who didn't know cake has a tool called C test which actually is able to run your test code um most of the modern uh Frameworks in C++ provide integration with s test like if you g test or catch so everything kind of works out of the box as and again you can give a name for your preset you need to say what's the configur preset was to know where is the build folder is you can tell the execution policies do you want to fast fail do you want to repeat do you want to like how many threads you want to use and so on again you can supply some environment variables which which can affect your uh running of the test and the when this preset is available and to run the test you can say C- preset name of the preset and if the the configure preset was in ninja multic config you again can choose do you want to run debug or release once we've done with testing it's time to make a package uh for those who doesn't know cake provide a tool called CPAC CAC is able to take all your libraries or executables and package them in different types of packages for example you can create a targ z archive or dep package or some external packages you can use generators yeah uh basically it looks the same as three other before you give a name it could inher it from others you say need to say the configure presets you choose what kind of generators you want to use in that case we just want to create a Target z uh you want to you can say what kind of configurations that meant to be debug release or no uh and the variables here is basically variables for the generators like what's the name what's the version and so on yes and to execute you just say CAC D- pret base D- config release or debug if that's be the ninja multi config or just ignore so now we kind of know how to configure how to build how to run the tests how to make the package now it's time to go to actually look at our C so on CI basically you want to run all of these four tests or four steps in one that's why C the workflow peret which basically you just describe what kind of configur Step you want to run what kind of build step you want run test and package that's all and then you just execute cake workflow and the name of your workflow that's all and that's basically configures your project builds your project uh test your project and if everything is passed you will get the package which is quite nice so now like all the defaults are good because you are a developer of your project you set up everything that you needed and it's kind of easy to share with friends one last thing about cake and presets is that naming is quite hard so I in my experience came up to something like that this is basically examp um a way how llvm called dat triplets so it's basically architecture or compiler and linkage so some few examples like I want to configure my project for x64 Linux GCC and all all the librar should be static or like Dynamic um or for example for Windows that could be look something like that this is just me how I like to name the presets but choose wherever you want but I feel this is very kind of convenient you know exactly what you're building for and if somebody wondering right now can you select a default preset based on Hostess that is impossible unfortunately okay so you will have to type something okay now we kind of know the cake and um let's actually look at how to structure the C++ project um to be able to explain how to structure the the project I will refer to this talk by MOS pus about modern project structure it's uh I find it quite nice I tried it for many years and works for me well but lets me explain how that works so basically when you create um C++ Project based on cmake um you need to follow this partn where everything on the top of the project is basically a developer entry this is where you enable all your development features like dependency management warning T talks cash wherever you want and when you as a developer use it all these features enabled and everything is good but when somebody consumes your project because you actually don't know sometimes how is your how's your project is going to be because if you make a library maybe somebody will use you as ad sub directory maybe it will be a g sub module maybe it's going to be used for the package management so it's nice to have the source as a separate cmake project it's kind of U it's as I said the center point for consumers um for like ad sub director or package managers it does not affect development environment you are not in control here of which C++ standard it's going to be used what the warning levels and so on all of this is kind of done on top but the consumers they just consume your project your library your application whereever that and if you look inside the source folder um each of the sub folder is basically a module which you can enable or disable quite easily like command and un command sub directory so it's it's it's very modular and the pattern repeats kind of itself everything inside looks similar it was on level above so let's add a c to our C++ plus project so just reminder how it was uh we had this if def uh quite uh messy so let's assume we are going to do something like that so basically we moved all the logic to the debac HPP and we have one function called debac and based on the compiler or implementation standard Library we will choose either we for example G g++ L will use um mcbp print which will refer to fmt print and msvc since it has a um support of STD print so we will call SD print so just a some some goal for us let's see how it will U how do we need to add the cake for this project okay first of all we need to add a c list.txt and uh we will set the minimum requirement of cake we will say the project name and as you see I called it a def mcvp def which means like this is highlight this is for developers not for the users and here we will enable all the cach extra warnings dog generation testing and everything what consumers doesn't really care and then if we look at the source folder there is also another cake file we also Define the project and this one is actually has a real name m CPP uh yes we say again version language everything that was I have one helper function here at mcpp module we're not going to look into it it's basically sets all the good defaults one um yeah and then we add our modules like log and my application so if we look at the log it's also kind of we calling this ad mcpp module which creates a target for us we say it's interface uh cake has this uh thing called p uh static shirt and interface and uh you can create static libraries you can share it shared libraries and interfaces like header only since we don't have any CPP files we need to explicitly say this as a header on the liary so yeah as I said we create a Target we seource the files and we check if it's not msvc and we try to find fmt somewhere and then we say that our library depends on fmt and we also set the uh Define that we know that we need to use fmt so that's how it will look L our debug file debug HPP so if the mCP usmt is defined then we use fmt core if not we will use print and the implementation of the debug is not really important it's just it will be kind of similar uh also important when you set up a project is create tests and um here is an example we see the test folder it kind of follows the same structure as source and if you have a log module you will have a log sub folder where you basically have a test per uh test file per header and even if you're not going to write any test itself it's very nice to have a simple uh test file which just check that include is correct that everything is fine but you didn't um forget some includes or something so it's basically a signed check for the headers it's quite simple and I really recommend you to do it because you never know that everything works until you compiled and tested everywhere okay then let's look at our executable um create executable we Source the main CPP and then we say that we are depending on the lock Library so pretty simple let's try to compile it and for that I would use workflows so I will compile it for Linux GCC Dynamic and Linux Clan Dynamic and you will see most of them get the hello world so quite simple quite nice um and I would say it's pretty looks like standard arest here um now I kind of want to share my project to my friend and see if he will able to use it and for that I'm kind of trying to Sil it transfer to the Version Control topic uh I know that um I hope that everybody nowadays use Version Control so there is no debate into that but I'll still will explain why you need to use it so it's basically a history tracking you know why this line was there what was the reason it's kind of nice to collaboration this is a said I'm trying to um use it as an example here that I will share it with my friend and back up and recover I'm not sure how was it with you but I remember when I was started at more my workplace we didn't use Version Control and everything was on the local dis on a hard drive and at some point it was dead so it's kind of uh we was luly that was not a big project on that hard drive but it was still like a year of work so it's it's kind of nice you know to have something like that and of course choose wherever suits you most I personally likes GitHub G and GitHub but sure choose where we want just have something it's better than nothing and quickly few tips and tricks I've recently been doing a huge refactoring it was basically clang um clang format changes and some style changes and I've noticed that it's kind of if I use them Kit then my kind of git history is broken so I found a way that you can say G to ignore some specific commit in the history that the history will be when you do get blame is actually okay so the one reason the the problem is that git kind of doesn't have a native good integration so you need to have a file which called git blame ignore refs file and uh and you need to specifically say that oh G you need to use that file to kind of ignore some refs and the problem is if you don't add the file in the beginning of your project then by by switching from the branch to branch and if the file doesn't exist the git blame is not going to work so if you start the project just create that empty file and just leave it there there you know it will be easier you later when you switch between the branches and of course use G ignore file where you just ignore all the unimportant stuff and keep your repository clean and nice and safe so that been said let's actually try to share with the friend so let's say he will clone my project go to it execute the workflow as I said and suddenly it's not going to work remember I said about these three dots and that somewhere fmt Library come from this is the time to kind of talk about it because maybe on my machine I used Linux and maybe some of the packages installed the fmt and everything worked but of my friend machine he doesn't have a library how he knows where to get it which version to get it so let's actually talk about package managers a little bit so if after I show what I show you you still thinking why do I need package manager that he can just install it I want to show you this this is a a viig page of how to build cute five from git and um yeah just look at it it's kind of hard to see but but it's that's the point is to show on every single Linux distroy you need to install different packages to be able to do something and such Pages get out of that very quickly because the packages rename version rename or something else something goes out you don't really want to spend time on it you want some reproducible builds for all of your developers and I strongly recommend to look at the package management here so what are the options um last year at NDC I did a talk about the dependen management and I look at the colon and VC package and from my point of view it's um it's yeah they both cool they both similar they have a bit different approaches uh conon is Python and requires python VC package more like native cake integration conon support multiple build system so I would say choose anything what you like more which see to your case I like VC package more but that's just my pref differences so yeah that's why I said let's let's add VC package to our project and see how it works so how to integrate VC package to cake is quite simple we take our configured preset and we point out to VC package toolchain file that's basically it so and again this is a beauty of the presets but now everybody will get it automatically um you don't need to kind of ADD inform the developers and also cool of VC package that it just works out of the box which is called and then you need to add the V package.json and then you just specify the uh your dependencies I like fmt and catch 2 as a test uh framework so let's try to share with the friend again um yes I'm adding my changes to the git I committ it push my friend get pull rebase call and now everything is great the way asbc package works is that that runs before kind of as part of configuration step but before um the actual cake stuff so it's first install of the dependences and then the regular cake kind of runs so we so cool uh now I decided let's share a friend um is my another friend I have a lot of friends and this one is actually using Windows and again something is not going to work and I also love the C++ errors they so descriptive and this is actually a real error when you run when I run I got this one and um for those who wondering what's the error as actually if I go back to slide where I showed you debug HPP I kind of added the space so if you noticed the during the listening me plus one to you but if you don't that's that's quite fine because it's it's very hard to parse the C++ with your eyes and understand that everything is correct so yeah I deliberately added the space my point was to show is that even though something works on one platform it doesn't mean that it works on another one so and that is my way to to introduce the continuous integration so what to do with CI so I think there is many things you can do with CI but you need to do at least few things with C++ you need to at least build uh on Windows and Linux and Mac your project all of them um has a different compilers with a different standard libraries so it will provide you the biggest I think coverage in C++ world and we know that all compilers um a bit different so you will get a very good coverage to at least know that your project is buildable in my experience it was quite common you worked to many years on Linux and then you okay now we need to add support for Windows and then you spend I don't know depends on the project and amount of months monthes so yeah and then one thing is to fix the build errors the second one is runtime errors because in C++ there is lot of undefined behaviors so you never know yes so build at list with GCC and Kang and M SVC Kang has a two support two um standard libraries it can be work with this GCC and it has its own so I recommend to to build with both just to increase the coverage I would say cage that way yes I would also recommend build at least debug and release versions um because the debug version is usually not optimized and releas is optimized you will get different results uh sometimes compilers optimize too much and maybe you world code not in a good way so it actually will cause a problem but sometimes you basically the debug build will not work for some reason because compiler was actually optimizing own and fixing problems and the one doesn't work I would also recommend to run um some um static analyzers like cppp check and Clank ID because they will also check and notice what kind of fairs do you have on in your project okay so I want to suggest to add the GitHub actions because as I said in the beginning I like G and G H and I need some simple examples so I will just show you how to do it so there for those who doesn't know GitHub actions is basically yaml based thing so you need to create the yaml file where it describe uh on which events like push and pull request you want to run your job then you select what kind of highs you want to want and Define a straty so just for example how it could look like uh we Define the strategy we want to fail fast our metrix is going to be we want to run on BTU on Windows on Macos and we will choose this of the presets to run on and then basically we describe step of our continuous integration so we need a check out to get actual the the changes we need to install system dependencies uh basically what we need to install is like a compiler cake ninja maybe something else um all the H Runners havee pre-installed things but sometimes the versions could be out of date or maybe they too modern you're not supporting them yet so it's nice to install things which which you're actually working with and then you just invoke your cake as I show you workflow preset and the name of preset so it's quite simple but that basically save you a lot of trouble if you don't do it at the beginning and if you think that I'm kind of over over complicate things and I'm saying this is not really necessary to do I want to refer to one of them pull request from TP and you can notice that there is actually 40 successful checks to run and if you look at them you will see like Linux GCC debug GCC 4.8 mic Osos 11 Windows 20 19 wi 32 and there's there's basically a lot and still this Library fmt which widly used largely used by many other projects there are still backs there are still issues so even building on all of these um platforms and running fing doesn't really guarantee you that everything is good and very often you will see that when a new JCC or Clank is released there would be a followup PR say okay now we fix the build eror to that compiler to the new version that's quite common to happen Okay uh I want to quickly talk a little bit about the tooling which you can use with the C++ projects uh basically I would recommend to use some formatters like a Clank format which basically format your code I've been in companies where you don't have a Clank format and all files kind of either in a different format or people try to manually um manually review PRS and say oh this is a bracket is in the wrong line and so on so on I would say it's better to have a tool which does it for you and you spend actually time your time when you review on a logic on actual what actual PR does rather than stying so yeah I know the Clank perment is not the best tool it has its own issues um not all the styling options are available sometimes there is a problems but yeah I still prefer to to have this Tool uh the second one is a sake format basically the same as Clank format for C++ but only for cmake like our like C++ is so complex language that we even have a formatter for the build system so it's kind of you know funny in a way I also would recommend you to run few lters like Clank tidy which has so many different checks supports the CPP core guidelines it supports some uh company specific like Google style and so on llvm so very very cool tool I really recommend you to run um sometimes it Sav me several times yeah quite nice nothing to say yes there is a cazy which is if I remember correctly kind of BAS Clank tid but this is for the cute projects it's no about cute specifics uh the re PP check which is pretty simple static analyzer but sometimes it's fine some places where to improve so I also would recommend you to use include what you use because when you're in um um when you have a big project and some point you will have like included five 6 10 15 files and actually only one of them is using but the compilation and parsing is like increasing increasing and slowly to build so sometimes it's nice to clean up and this tool kind of help you use that I would also recommend to use commercial Lins like PVS Studio soner or find something else um they usually have a specific checks and specific atics to verify that your Cod is works I really recommend you to look at the PVS Studio the blog post because they time to time uh take some open source projects like um cute for example and after that you see that they find so many funny errors which yeah it's just yeah C++ and after that usually you see 20 30 PRS to cute which says like fix wherever PS Studio pH so it's quite nice quite interesting I would also recommend to use promit tool I didn't know where to put it but it's basically as I said git doesn't have a very nice integration with um what to do when you do commit or or like some other operations but the pre-commit is basically a framework around it um which allows you to add like Clank format cake format it can be the Clank tidy as part of your commit step for example you want to commit it will make sure that everything is great it's very fast feedback for the developers instead of like waiting when you push it on CI and so on but also what it's allow you to do is actually set up a specific version of the tool because Clank per mon for example breaks the configuration files uh between the major versions sometimes like you need to actually go and update it and it's kind of hard uh you can update it but then like somebody sitting on the old duun as a develop and he doesn't have that version so it's pre-commit basically solve it for you so I kind of like it and also as I said fast feedback is quite good so okay um I think after you listen me for almost an hour you was thinking okay okay there's so many things what if I just wanted to write a code I don't really want to focus on all of this somebody set it up everything for me I just want to write the code so what to do in that case and my answer is to select a good ID and I personally use VM and I spent many years to configure it but I understand that that's probably not an option for everybody that's why I can of cross them out IMX as well and I partially cross vs code is because vs code is not an IDE but it has a lot of nice plugins and the way how V Cod promote these plugins to for you to install it kind of helps I I found many times when I was sitting with the developers and they open um they open the vs code and they don't know what the file says oh this is a cake file you need to install cake plugins and now suddenly everything much better so I kind of half crossed it I also would recommend cine and that's a commercial actually IDE but it's in my opinion one of the up to-date ideas yeah they have yeah we will talk about sine later but I also need to highlight the visual studio Visual Studio is quite nice quite powerful the only one issue is the visual studio is only on Windows and um that's kind of limited the score because yeah not all development could have been done in on Windows you actually need to go on Mac you actually need to go on on Linux so that that's why kind of yeah if you're fully on Windows this is probably option but if not I would recommend to actually look at Celine and quickly about Celine um in my opinion this is the most complete code model so it knows so much about your source code and it can tell you so much about your source code so I kind of yeah I I have not seen yeah it's one of the best in my opinion uh I would also say it's BND and um and it's there also integration with C++ tooling so which is quite nice then you don't really need to think about it it's will pick ups the configuration files from um your project and automatically configures it so it's kind of good it's actively developed and maintained uh which is quite nice and I also would say for those who like cmax it's very similar user experience you can just stay in that ID and uh yeah everything is there so which is quite cool and just for simple small live demo I have a couple of minutes left I want to show them cine so let's open the project in cine I hope you can see that so yeah very simple and it as I said it knows a lot about your code base so this is a executable and uh you can just press the run and it will run which is nice you can go to the tests um and you can run the test as well so it knows that it's a catch two test it knows how to run it how to report so it's um cool and um recently they even add um they recently they added um C debugger support so it's kind of yeah it's mindblowing in a way like we in C++ even have a a debugger for the build system I just want to show you how it looks like I think it's like truly amazing I just put the breako here I will just run it and now we we're here for example we can look what this variable is and like a print this is the result so I mean yeah and um very interesting and very nice my opinion I I also believe that such tools like um theb of cake can actually help you out to understand what the cake does because as I said it's not easy at some point so such things quite help and yeah for you it's like a regular floww when you debug your C++ in a way yes so yeah it's a set it knows about your project you see see on the right on the right bottom is that it knows about Clank format it knows about my Clank TI settings everything out of the project and [Music] um kind of nice and there is also one cool thing is that uh you can even enter the presentation mode so it will scale down very small thing but still nice when you do presentations so kind of cool yeah it's also has a support of as I said this cake it knows about your it even has support of package manager it knows about VC package uh the Conan has a plugin provided for the IDE so yeah you basically can focus on on your work if somebody set up everything around so that's nice yeah as I said it's very very quick um cine view yes so how to start mod C++ projects I think we cover a lot um during the presentation to preparing to the presentation I actually created a small template which you can just clone or use as a template there is a small CX script where you can set what's the project main model name and header name and it will kind of configure it for you um if somebody thinking I'm in love with C that I ring in the script in C no it's not true the only reason is I did it because apparently there is no across platform tool which is in a uh supplied by every OS I tried originally using Sid but then Mac Sid is Linux seed is not um is not the same on Windows there is nothing so yeah end up to if you want to build a cmake project C++ project with cmake then yeah script and cake but there is many other templates out in the internet just find the best um so yeah it's just what I did during the prepar preparation to the presentation and kind of use it by myself yes uh thank you so much and this is the links there is a lot of um yeah there's a lot of good talks which I en carded um which I read oh sem artical which I read and some talks which I listen so yeah feel free to take any of that and it's online so I'm not sure if I will get any questions so anyway I will have this slide with questions here I see that there was some things in the chat but yeah thank you for this um there any questions uh mik will be on the table for the previous talk which was this one and so um if mik couldn't answer your questions during the conference uh in the chat then he'll be there and you'll still be able to discuss this topic which I think has a lot of topics and lot of angles to discuss um so thank you very much for the great talk yeah thank you for my pleasure y good if you have any question see him in the