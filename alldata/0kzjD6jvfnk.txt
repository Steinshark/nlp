today I'm going to talk about my favorite subject money cool Hard Cash and how to represent it in Python there are lots of cases where it is useful for example if you're processing accounting data or perhaps you're developing a backend in Python for webshop and you need to handle orders or your quantitative Trader or you work at a bank and you need to analyze Financial transactions and detect irregularities or you just love Capital now you might be tempted to use floats to represent legal tender but that's a really bad idea and I'm going to show you why then I'll show you two ways to do it properly but before we talk about though I'm starting to run out of synonyms here there are a few things you should know about how python represents numbers let's Dive In the most common types used for representing numbers in Python are floats integers and decimals so the flow type represents floating Point numbers and in Python those are represented by 64 bits double Precision similar to the double type in C sharp that's one bit for the sign that's 11 bits for the exponents and then there's 52 bits for the mantissa floating Point computations are really fast CPUs often have dedicated floating Point processor so that's one of the advantages of using floats however floats are not very precise I have a very simple example here I try to add two floats 1.1 and 2.2 as you can see when I run this we don't get exactly 3.3 but we get approximately 3.3 so floats are fast but it comes at the price of precision another very common type for numbers is integers now most programming languages actually have a fixed size integer can be 32 bit or 64-bit python actually has a variable length array that it uses to represent integer numbers and that means you can basically store arbitrarily large numbers in python as long as it fits in the memory of your machine so as opposed to fixed integer types you don't have to worry about overflow but that also comes at a price because the larger those integer numbers become the slower the computation also becomes however for smaller entity numbers performance is almost as fast as floats the final number type that's important to know about is the decimal type from the decimal package and this is also a really useful type if you need High Precision computations so the reason you can do precise computations with this is that it uses a base 10 representation internally and you can Define how precise you want these numbers to be obviously that comes also at the cost of memory use and performance to show you the difference in performance between these types I've created a small script so I have a couple of test numbers here I have an integer number I have a large integer number I also added some numpy integers to the mix to show you how that works then I have a float I have a large float and finally I have a decimal number and then I have a couple of test functions so this tests various operations on Integer numbers this tests the same operation but on a larger incident number then I'm doing the same for floats and for large floats for decimals and for numpy integers and then I have a main function where I'm basically running these functions each a million times and then checking what the execution time is using the time it package and so when I run this here you see the execution times for each of these operations so for integers this takes 0.12 for seconds if I use a large integer you see that the number actually goes up that's because it needs more space to represent these large instant numbers and that has an effect on performance flows is really fast that's a bit more than half of the time it takes to do that computation with integers and you see that if you switch to very large floats that doesn't really make any big difference at all because well the floating Point representation itself doesn't change you have the same number of bits decimals are by far the slowest because of course they're more precise so they take more time to compute in this performance test for numpy I'm using int 64 which is a fixed size integer as opposed to Python's variable size integers and you see that it's actually a bit faster than Python's built-in in integers so now that we've seen this what type should you use to represent monetary values well you shouldn't use floats even though they're really fast because they're not very precise and when you're dealing with money not being precise is not really good an alternative approach to using floats is to use decimals to represent monetary amounts like I said before with decimals you can indicate what your desired Precision is and it's really easy to do this so I'm going to import from decimal d decimal type but since I also want to indicate the Precision I'm also going to import get context which allows us to set the Precision so if I simply print decimal 1.1 plus decimal 2.2 let's run this then this is what we're going to get so this is still not very precise but what I can do is I can now set the Precision by using the get context function and let me start by setting a Precision of two because apparently this is what GitHub copilot wants me to do so then you see we'll get this so it does rounding so that we end up exactly with 3.3 if you want a higher Precision you can also put a higher number here now we're getting Precision up to 10 numbers or we can do Precision up to 50. for example then this is what we're going to get so depending on what you need you can set precision as you prefer but there are also two issues with using decimals for monetary amounts one is of course that decimal computations are pretty slow compared to floats and even integers and that means that if you have system where you need to process a ton of transactions and you really need to think about performance then using decimals is not suitable to you another reason why decimals are potentially problematic is that they are really a python specific thing so if you want to store them in I don't know a database for example then you need to convert them to another format and that means you might still actually lose Precision that you thought you had when you were using decimals now of course if you're mainly using it for internal computations you don't care about the performance and decimals are still a great type what you should know about these limitations so in short this means that the architecture of the system that you're working in is going to influence whether you should use a decimal type or Not by the way I'm working on a new course that I'm going to launch this year that teaches you everything about software architecture if you want to learn more about that if you want to be part of the first group of people to participate and of course go to iron note codes slash Architects to learn more so like I said decimals are not ideal if you want highly performance code or if you need to store them in a database where you don't access to the python specific decimal type how do you solve that well one way to solve it is actually use integer values computations with integers are relatively fast not as fast as floats but still quite fast and they're also quite memory efficient provided you're not Scrooge McDuck next to that they're also widely supported databases Json Etc all support integer values so how do you then represent a monetary amount like three dollars and 65 cents well what you actually do with integers is that you store the monetary value in the smallest currency unit possible and in dollars or Euros that's sense so three dollars and 65 cents would be stored as the number 365. and this is actually quite common for example stripe one of the largest payment providers in the world does this and uses integers everywhere here I have a very simple example that shows this so I start with a balance of 10 000 so that's if we're assuming this is in US dollar we have a hundred dollars ten thousand dollar cents then I withdraw 42 dollars and 37 cents and finally I deposit 10 cents so I compute the results very simple computation and then I'm printing the dollar balance and I'm using a helper function here that divides the amount by 100 and shows it with two decimals so that we get the correct dollar units and then when I run this then obviously this is our balance that we got after this simple computation so he also immediately see a disadvantage of working with integers for monetary values which is that it can be unintuitive that you have to represent things in sense and if you make a mistake for example you forget to multiply by a hundred or divide by 100 depending on what you need to do that could be an expensive mistake or one way to make this a bit easier is not by using integers directly but by using a class that represents a monetary amount and here's an example of how you could set that up so I have a money class data class that has an amount in sense so I am actually using integers in this case and then I also include a currency symbol because well that might be useful and then I have a class method called means that creates money out of thin air and that gets either a decimal or a floating point value so you could actually read this from a database for example and then it's going to return a an instance of class money and why am I using a class method here not initializer well in this case this allows me to create a money object from decimals or floats but I can still use the data classes generated initializer method to also create it from sense depending on what I need and then I've created a couple of helpful donor methods to be able to deal with money for example here is one where I convert money to a string value and there I'm actually dividing the Cents by 100 I print the currency symbol in front of it and then I print the amount with two decimals I also added some helpful methods like adding and subtraction you can add more if you'd like but basically this checks hey if you pass a money object then I'm simply going to add the amounts and if I do subtraction and I'm going to subtract the amounts I'm not really taking care of currency conversions here you could basically build out this class to add lots of features to it but for the example I kept it pretty simple so now I create hundred US Dollars using the mint class method and then I'm defining a withdrawal amount and a deposit amount so these are the exact amounts that we also had before then I can perform these arithmetic operations which call these donor methods and then I can simply display the results as follows and of course if I want to do that with a different currency like Euros for example I can also do that so if I run this then we get of course this result so this is one way to circumvent some of the issues of dealing with integers because when we're using money here in this main function I don't have to worry about that internally it's going to use integer values so what do you think do you think using integers for monetary values is confusing do you prefer to use decimals let me know in the comments one thing you might consider since I also talked about that briefly in the video is that you could use numpy data types to represent monetary amounts instead of any of the built-in types that python offers but when you think about it not by is not really that much faster than Python's built-in types I mean it's slightly faster but not that much and also numpy has fixed size types so we have 64-bit integers which means that if you are screwed to McDuck you're going to run into problems and here you have an example that shows this so I updated the money class to use the numpy 64-bit fixed size integer types instead of the Python and I didn't change anything else in the class so then let me run this so of course this runs perfectly fine but of course if I try to enter a large amount I actually have to type the amount then you see we're going to get an overflow error because the integer is to learn charge and since we are representing the monetary amounts in sense this happens even sooner than you would expect now instead of integers you might think hey maybe we can use the numpy floats because numpy has a 128 and even a 256 bit float type but those are not supported on all platforms at least on my Mac they're not supported it's a 64-bit system and it simply doesn't work I don't know about Windows and Linux that might actually work but that's something you have to take into account so unless you have a very specific need where you're sure that you're going to need numpy types then I don't think they're really suitable to represent monetary mounts in Python so conclusion in any case don't use floats to represent monetary amounts use decimals or use integers and here's the trade-off if you want the direct representation with flexible precision and built-in rounding use the decimal type however if you need fast performance or low memory usage and wide compatibility and you can deal with conversion issues use integers instead I hope this video was useful another Rabbit Hole to dive into is date and time if you want to learn more about that watch this video next thanks for watching and take care