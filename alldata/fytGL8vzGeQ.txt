this week on developer voices we're looking at the future as we often do but not the future of programming per se we're going to talk about how some very wellestablished ideas in programming are being used to accelerate the bleeding edge of chemistry my guest this week is Professor Christian schafmeister and he's been working on a new implementation of common lisp to speed up the design of nanotechnology bits of this at times sound like science fiction but it's very concrete the plan is next year they're going to be building enzym sized machines that are being designed right now in a Jupiter notebook in a repple in lisp you have to ask why lisp in this day and age and we're going to get into that lisp still has a few features that more recent languages would struggle to emulate and might do well to emulate to get there we're going to have to go back and learn some of the most interesting chemistry I've heard about since school so we better get cracking I'm your host Chris Jenkins this is developer voices and today's voice is Christian [Music] schafmeister I'm joined today by Professor Christian Chef Meister how you doing Christian great doing great glad to have you here you are our first Professor oh which uh which feels very very formal normally uh we have a lot of people on this show who are whove picked up a lot of knowledge along the way whereas you're steeped in a particular field which isn't our usual wheelhouse it's chemistry yeah and this is so we're going to talk about the language you've been building but we really have to start with why you needed a language CU this is the closest I think we've got to science fiction on this show yeah so um I've been developing um something for the last you know 30 years uh where I want to be able to build machines on a molecular scale so um I have gone deep into organic chemistry and I now teach organic chemistry and um we've been developing these molecules that are uh programmable that are made out of building blocks that are uh like rings and when we snap them together it's kind of like Lego you can make molecules with different shapes and they're complex and so I I have been developing software since I was 12 I was one of the kids who kind of hung out a radio shock and learned how to program in basic on a trs8 and um I knew that I wanted to use software to design these molecules and that it would be very complex and so I've been working towards both of those things in parallel uh over the last like 30 years this is this is very cool with a different set chips set that's where I was basically starting off in Radio Shack we have a similar background sure but um but so but we're not talking like Nano we are talking nanot technology but these aren't Nanobots these are different kinds of chemical machines we are talking about nanotechnology the things that we build are on the nanometer scale but this is absolutely from the bottom up we build things from molecules uh and build them up and we know where every atom is in in space um and I'm actually a Fineman awarde I think it was in 2005 you'd have to look that up but yeah I have the Fineman prize and uh yeah I've been funded for nanot technology in the past this is cool this is like so this is machines at the level of like taking inspiration from enzymes that kind of thing yeah that that's really where we're kind of focused because enzymes are the key technology that I believe human beings need to develop uh those are big molecules that can make other molecules molecules that can make feed stocks for industry and Fuel and take garbage and turn it into useful things and detoxify you know uh pollutants uh all of that can be done by enzymes we have a whole bunch of them that nature gives us but they were evolved for the purposes of living things uh there are so many chemical reactions that if we could create enzymes for them we could solve every material problem that human beings have for all time to come it's it's a fundamental technology that we need to develop you really see this as uh like completely changing the world absolutely it's if we could make molecules that could build other MO molecules then every problem every physical material problem we have we could solve somewhere between shrinking chemistry professors down to the Nano scale and that would make us simpler I don't know about that but the the um the essence is like an enzyme is a molecule that's large it's got a pocket and it organizes groups inside of it so it acts like a little like a little breadboard like a little circuit another molecule will pop into that pocket and there's a push and pull of electrons it's like a tiny it is the smallest electronic circuit and it works for just a you know a few um Pico seconds and a new product emerges and then another one goes in and that gets repeated over and over again without the enzyme being modified at all so it is it's it's the essence of life and we can't do that in a rational sense right now at all as well as Nature has done Nature has uh millions of these enzymes that it's evolved over uh you know countless millions of years um that can accelerate many many reactions and is this I'm just trying to understand for the background right is this you you're going to custom make an enzyme that takes some raw materials and builds a particular flurry of a molecule is it then that you'll have is there a larger structure beyond that are you going to fill a vial with some enzymes that take raw components and put them at level one and gradually the next enzyme in the chain builds up something more complex until you've got something on the physical scale recognizable as an as a thing yeah you've got it um systems of these could build complex molecules they can fix you know here's a here's a crazy example um one of the theories of Aging is that uh basically sugar glucose crosslinks proteins outside of our cells in what's called The extracellular Matrix and stiffens up the tissue I mean um that's known that actually happens and um the the crossin is called glucosa pan and if we could make a specific little enzyme that could go in there and cleave those cross links you might be able to cure a lot of diseases of Aging um I I don't know if it turn back the clock but it's one current hypothesis for how aging happens that that basically glucose cross-linking proteins it's called the malid reaction it's the basis of cooking and uh that's that's what's basically happened to us over 60 70 80 years right so if you can make an enzyme that could cleave those cross links specifically without doing anything else you might be able to treat a lot of diseases of aging and what's the timeline on this because so we can make these enzymes on a small scale right now is that right we can't design good ones and it's difficult to make big molecules that can wrap around smaller that can create pockets and wrap around smaller molecules it's really difficult to do that but we if we had the recipe we'd know we could physically manufacture them yeah one recipe would be based on proteins and there's a lot of people like writing software to design proteins like Alpha fold you've heard of that um uh Rosetta is a software package that comes out of the University of Washington David Baker's group um that has been developed over the last 30 years to design proteins proteins can do this kind of stuff uh they are difficult to design with i i the my life's work is to come up with a more engineerable building block set so proteins are sort of like bead necklaces or charm bracelets they have uh they're long string they have uh little charms on them and the charms some of them are really greasy some of them love water and and nature has put them together in a particular order so they fold up into a into a into like a ball with a little pockets on them and that's how they uh that's how they create the pockets that can do the work that folding process is a grand challenge of science predicting how proteins fold now uh uh the Rosetta and a lot of other people who have worked on using software to rack the insides of proteins have been tremendously successful but creating the intricate inside of a enzyme is really difficult to get it exactly right because you have to control where groups are within you know a tenth of an anomet uh Alpha fold has been a huge uh breakthrough in using deep learning to predict the folds of proteins that we don't know the three-dimensional shapes of I've got a different approach I thought let's build building blocks that are just easier to design with in the first place so instead of making a charm bracelet a bead necklace let's make little ladder uh like rungs of ladders and then snap them together through two connections at a time so you make a bunch of rings that are fused together you make things that snap together more like Lego than linking uh you know beads on the neck neckace right and then they're easier to design with and then write software to design them so your idea is that you're going to have like a a tray full of different building blocks and then figure out how to assemble them to make interesting enzymes and this is where we're getting into is it pronounced can do which is a great acronym for computerated design Nano I forgotten the o computerated Nan structure design and optimization right so we we're really on the level of CAD software for molecules yeah yeah I started I've I've written this like four times and I started out writing a cad graphical user interface sort of software but every time I got something my students came up with chemistry that it couldn't handle and it required a redesign and then I settled on I'm I'm just going to write a language and build a user interface on top of that all right now here's where we get into language design so at what point at what point did you say this is going I mean tell what point did you say I'm not going to be able to do it with the existing software that's out there I need to build something custom I think I was writing it in small talk at that time and I'd had I had a really nice user interface uh and my group figured out how to put what we call functional groups sort of side chains off of each building block and the way I was building the molecules just wasn't going to work with that and so I just scrapped it and started it over again um I spent a lot of time writing most like chemistry requires performance you're always doing things things that on on lots of atoms that requires writing Loops that do intricate things and you needed to be very fast so most of my stuff is written in uh was written in C++ and then I would hook that into other languages uh for the longest time I was using python but the interop between Python and C++ and managing lifetimes of objects became very Troublesome so I came up with another way and that's what current can do and the common list clasp that it's built on uh that's where that came from this is an unusual route particularly these days I think to go from um to go from small talk to Common list what year are we talking when you did this uh probably about 2005 2006 that still counts as relatively recent in the grand scheme of things why common lisp so I was looking around at the the time for a language that would allow exploratory programming uh I knew I needed um automatic memory management I needed performance that was the key thing performance and um I was I had this core of chemistry code that was written in C++ it's about quarter of a million uh lines of code at that point and um I was had it all hooked into python was running into a lot of trouble this is back in the python you know before Python 3 um and was running into a lot of time trouble maintaining that and a friend of mine had was at Nasa and he worked a lot with common lisp and said you should check out this language um I was using XML a lot for serializing data at the time so I started getting into this idea of you know nested uh scope uh in the language and um I started implementing a Lis in my C++ and found that it worked very well with the chemistry ideas that I was trying to implement so I moved on from there I don't want to monopolize the conversation so I'm going to pause no it's your job to monopolize the conversation but so what is it about lisp that lends itself to chemistry though I can't quite see that so it's really easy to express uh graphs and uh trees and linear sequences in lisp with the parentheses um I don't know it just flowed really well so I had all the C++ code I was writing a lisp interpreter and started to write imple basically implementing my own lisp and I didn't go very far and I realized it was crazy to try and Implement my own language uh because I've I developed in a lot of languages I know how difficult that is that is to get that right so I was I just looked at you know what kind of lisp implementations were out there and there's a scheme there's common list you know emac is based on lisp yeah there's a couple of them out there uh but I wanted one that was kind of full featured battle tested have been used to implement large programming systems and you know like common lisp is used in the um Google flights the engine behind that is all implemented common lisp and so I thought you know schemes got this specification that's like 25 Pages common lisp has a specification that's like four inches thick I'll go with the 4 inch thick specification not the decision I would have made just on those metrics I I I I do have a tendency of always taking the Hard Road on on things um but you don't become a professor if you don't like reading right I I guess yeah yeah uh so I there are several implementations of common lisp and one of them is implemented in C uh this is called uh embedded common lisp or ecl um much of that is written in common lisp itself it's self-hosting and it has a lot of C Core to to do the you know to do the lower level stuff right so I just took their it's a that's a um a GPL uh software package it's got a GPL license on it so or an lgpl license so I took the common list code from ecl and just started writing my lisp interpreter so that it would execute that and I just kept going and executing more and more of it and my lisp turned into a common lisp implementation oh I see okay I also have good C++ inner operation so I was doing a lot of C++ template programming and I implemented something like boost python uh to integrate C++ and the lisp and then I integrated the llvm uh compiler Library um exposed that to the lisp and then I started writing the back end to generate llvm using the llvm C++ API and that's how it all grew why why that step I can see why you need C++ access why go into the llvm part performance just performance with LM I can get native code compilation and without that I would always have an interpreter right so you kind of cannibal not cannibalized but um stood on the shoulders of an existing common Lis implementation yes but we the developer of ecl um uh Daniel um is um you know we hang out on IRC and we fix bugs in each other's uh systems because we share a lot of codebase um it's a very uh it's been great uh working with that community and and the larger common list Community as well so what circumstances do you think this is the right choice I mean if someone else was looking at if someone else is in your position with a large C++ code base when would taking your path be a sensible one um well I I would hook it into clasp I think it's it's the it's a great tool for exposing C++ plus code in a highlevel language that has dynamic memory and a bunch of other features um I've hooked in uh DNA sequencing analysis libraries like uh secan and it's uh it's very easy to inter integrate C++ code with clasp and that gives you access to all the common list libraries I would have thought that I mean anytime I think programming in the Science World I think of python are you are you losing something by moving away from python in this yeah you know Common LP if you take python code and you take all the functions and you just take the parenthesis for the function call you know Fu open parenthesis arguments closed parenthesis take the name of the function move it into the after the first parenthesis remove the commas and that's basically lisp you you know it's it's not that big a change then you have all these uh functions that give you you know string handling file handling all sorts of stuff like that uh and you you you have a full language there I mean it's really not that different from working in Python uh it's just that it compiles to native code and it's common list was developed in it's a standard language so has a standard that was developed back in the 80s and um it's a forever language like the code that I wrote 10 years ago in lisp I'm using now and libraries that I use some of them have been written over you know de the last couple of decades and they there's a large Library base of common list that works because the language doesn't need to constantly change there's a standard and and everyone writes to the standard there's multiple implementations so everyone writes code that works on a large number of standards and it's a very there's a there's a philosophy of writing things properly uh rather than writing them just so that they work or they work now yeah yeah I um I gather a lot of software in the Science World suffers from that problem understanda because most science people in the science world aren't primarily programmers right they're not and there's a tendency to write stuff that does what you need to get the paper out and then it wrs then it it writes and dies but I I got to ask you that question again because you take okay so there's an argument that you take any programming language and strip the syntax out and you end up with lisp because lisp is the programming language with almost no syntax but python isn't just the syntax and the core Library functions it's this whole ecosystem science packages particularly mathematics are you missing that in your common list world you know some absolutely um there is a lot of momentum behind it but if I you know if I started writing this in Python I would be really bogg down right now with you know you can't write Loops in Python and expect them to run quickly and when you write n like we I work with a lot of three-dimensional uh data you know like I've got a molecule it's three-dimensional XYZ coordinates and I need to put water molecules around it so I have to do a loop across X I have to do a loop and wrapped in a loop across y wrapped in a loop across Z I've got like three nested loops and then inside of that I've got it doing something really complicated like figureing out if a water molecule is overlapping any atoms in my molecule yeah if you write that in Python it's going to take an hour to run in common lisp with a little bit of C++ assistance it happens in a fraction of a second um I can't I can't give up performance time time is the most valuable thing to me so I'll invest a lot of time in developing the software if it runs quickly when I need it to and I'm now running things on large clusters distributed computing across large clusters that um would take years of uh time if when it's run on a single CPU yeah I I can say that like python it's more than fast enough for the average web server but when you're folding proteins in 3D space yeah I can see that every nanc counts I I've been around I've programmed like since I was 12 so more than 40 years and um you know all the python that I wrote back in the in the 90s is gone dead you know when they changed to Python 3 three I didn't upgrade all those uh libraries and it's now gone so all of that was kind of taken away from me I don't want that to happen again so I'm only developing now in in Forever languages languages that are going to be around for till till you know 20 30 40 50 100 years from now it's one of the few languages where I could predict the syntax won't change much between now and then yeah and and I I have the rare experience of writing software that's been used for more than 30 years before I started graduate school I wrote a program called leap which is kind of the front end for Amber which is the one of the large academic molecular Dynamics packages right it simulates the Motions of proteins in DNA in research and it comes out of the University of California in San Francisco so I was given the job before I started school to uh write a front end for it so it make it easy for researchers to load in their proteins and set up the calculations to run on this on this uh at the time it was written in Fortran Fortran software um and now it's got the fastest GPU implementation but my software leap is still being used today probably some percentage significant percentage of the world's biomolecular simulations go through leap every day and have for the last 30 years that thing was written in C and they've tried to replace it uh like the amber Community has tried to replace it I think twice and have not succeeded because it does an essential difficult job really well the downside is it hasn't been improved very much in 30 years um because it's difficult for people to get into the Way It Was Written well this so that raises a question of collaboration you're writing this software in common lisp is again to an audience that's probably if they know programming at all probably knows python I'm guessing team of technically astute chemists how are you how are you finding the the user experience and how are you making it usable for people we have um there's really powerful tooling based on uh common lisp uh tooling software uh let me re rephrase that so there's a software package in common list called slime which works runs in emac yep and lets you connect into a running common lisp instance and develop code it's got an interactive debugger it's got Auto completion um it has everything you want it's a really beautiful program pramming environment you know sort of integrated development environment that's all text based working in emac so we fully support slime I use it every day I've got it open right now uh it's it's one of the most uh wonderful interactive exploratory programming experiences I think you'll find now I haven't used a lot of modern idees for C++ or python so maybe I'm talking out of my hat there but it is a really fluid programming experience so we have that we've also developed a Jupiter uh kernel based in that that runs a clasp or can do that and um so it's got widgets for doing uh displaying molecules and graphs and things like that okay so you can open a Jupiter notebook and type in some common lisp and see your molecule and that kind of yep exactly my usual development environment is to have I've got can do running that um can do running I've got a Jupiter notebook instance talking to it and I've also got slime running in emac also talking to it I'm developing code in slime I'm seeing the effects the output in the Jupiter lab environment and that's how I get my work done do you know if that plays out the way I'm seeing in my head I think a lot of modern idees and more modern languages would struggle to match that if you've got the mixture of the interactive programming experience and the live visualization there aren't many languages that do that well ass that's a good point I I really hadn't considered it um I'm I I was really inspired by the um sorry what is that new Apple language that um Swift yeah Swift so when they first demoed Swift they had this sort of interactive programming you know environment I I love that demo I'm really inspired by you know the small talk interactive programming environment uh slime is really great I I just I I want something where I can be talking to the programming environment add functions change everything about it I want to be able to change class I need to be able to change class definition functions uh add you know generic functions that will um add new functionality I want to do all that stuff interactively and that's what I have with this system yeah yeah I I think to that I can say I think lisp is the only language where I've genuinely felt like I'm having a conversation with the computer you know that that Dynamic interactive experience yeah that's that's an interesting uh way to put it I hadn't really considered it but yeah I would agree it is it is really I really enjoy programming in it um that's cool I I have to this is a very nerdy question but I'm allowed to ask those I have to ask so you're looking at doing um an interactive lisp with C for the fast bits of bindings did you ever consider just doing an emac lisp when I when I was first getting into list I was a little confused about what was what and um I thought that that would be an option but it's it doesn't have the native compilation it's a reference implementation of a language and so I decided no I'm going with a standard fair enough okay in that case let's talk about the um this perform performance Bridge so I'm assuming you've got C++ where it needs to be really really fast and you've I'm assuming you're as far as possible you're in list Bland for the convenience interactivity high level preferred way of programming tell me about the bridge and when you know it's time to put something on this side or that side of the bridge yeah now I usually start I don't know I've got a really at this point I've got an intuitive sense of of when I really need speed and when I can get away with that um we've I do all the sort of low-level C++ work in implementing the common lisp so I do a lot of C++ development a lot of C++ template programming and I think I'm pretty good at it now um we implemented llvm as the back end so that we can generate native code and that code runs pretty well but I still can't Implement something in common list and have it run as efficiently as it would if I implemented in C++ because common lisp does try and make everything safe and everything's wrapped in our you know most of the objects are wrapped in wrappers so that slows things down we've now implemented a bite code uh compiler in clasp to to sort of deal with the slow compilation of LM um which is a great Library by the way I'm my train of thought is just derailed could you reiterate the question so there's there's like you've got lisp in in programmer space where it's nice and C in um computer space where it's fast right which parts of that go on which side of the line profile profiling profiling profiling so because we generate llvm we can compile everything to llvm down to native code and it all turns into object files and you know basic Unix elf mock sort of um stuff so we can profile the common lisp against the C++ perfectly using perf or using drace on the Mac and uh we generate flame charts and I can see where time is being spent in the code so it's profiling right and how much work was it to get that working a lot because it's really fussy uh especially the jitted code um the the just in time compiled stuff that you know we're generating all the time to get the names accessible for the profiling tools um had to futz around with a lot they they basically they had this solve the same problem for JavaScript on on the browsers so we use those mechanisms once I learned about them um but yeah we can profile everything on an even uh level and then uh depending on where time is being spent I will move stuff into C++ if I need to okay it's manual but can you do that all while your same process is is running yeah so you can take a function that's running too slowly and interactively update it with a C++ definition oh or interactively compile it to C++ on demand or no no changing the C++ code means uh rebuild of the system okay that takes about five minutes and then restart everything and reload everything um yeah okay so this is another reason to keep certain things in list space for the interactive reloading without restarting thing yeah which really puts me in mind of Crash band cot do you remember that video game yeah it very inspirational yeah yeah that was a good sales pitch for lisp back in the day yeah so I I do most of my development in in lisp and it's only when profiling shows me that I've got a problem that I move it into C++ okay or rejigger it to get things into C++ okay then maybe we should talk a bit more about what's good in list space so what are the poost to Children features of list macros are you using the macro system much uh some uh you have to use that carefully it's a powerful pointy tool um but yeah uh it it uh lets you sort of write your own flavors language um yeah we we do use it it the macrosystem is is really the basis of lisp all the stuff that makes it really powerful uses the macro system so in that sense we're using it all the time um but writing my own macros that's pretty I don't do that that often okay um what about the raita system uh that um it's another powerful tool I I have a recent uh use case for that um we have all of our arrays we have specialized arrays so for floats and doubles and integers uh where they're just representing in compact um data in memory okay when I I need to serialize large complex data structures to dis and then load them back in for running calculations we could talk about you know the save lisp and die thing um but the saving these large vectors uh I've I'm using the lisp print and reader to dump these complex data structures to dis and then load them back in and that is fairly slow it's it's like pickle or it's like using Json but uh you can have internal references in the data structure so you can build up circular graphs yes yeah yes and that's an absolute necessity for what we have because molecules are graphs yeah like it or not it's cyclical yeah yep yep and so it handles all that uh really well but writing out the arrays was taking a lot of time so I uh what I did is I just uh turned this 8bit data into six bit data that's human readable you you know just using six bit characters and I write out this stream of characters to represent you know the compact array and I wrote a reader macro that when it detects the reader macro characters just reads in that six-bit data and turns it into a uh 8bit uh data structure and memory and took my load times for these things from 10 minutes down to you know 30 seconds nice which must come into play when you're um writing C++ and having to reboot the world right so do you have a a do you have a perfect between session thing can you when you're working with you end up with this kind of working memory of where you're at can you flush that entire thing reliably to dis reboot and bring it back and be exactly where you were yes yeah so one of the really remarkable features of lisp is this idea of save lisp and die where you just checkpoint all them you you you do all your work you get a um your memory all set up to you load all your files you get everything set up to do something and then you say okay save all this memory and then later on start up the the common list system loading that memory and be right back where you left off yeah so I implemented that feature in clasp and I can load 100 megabytes of of complex data structures to do a complex design calculation and then save the thing to disk and then start that up again in less than four seconds that's a rare feature these days right because most programming languages you can't checkpoint the state of the program yeah how much work was it to implement that um you have to have a really good understanding of how the memory is laid out uh and you know how with how our garbage collection works so we support a precise garbage collection so I know where every pointer is in memory and so it's just a matter of keeping track of all that stuff writing it all into a block of memory dumping that to dis then loading that back into memory and then feeding it back to the garbage collector which will put it wherever it wants to in memory and then fixing up all those internal pointers and that uh the the memory survives that round trip okay um it's pretty complicated and fussy but it's working and um yeah what else can I say about it is it reliable it's yeah it's it's working perfectly um if you know if one pointer was out of place it would crash the system within moments I have a memory test tool that will exhaustively check that every pointer is pointing to a valid object and that gives me a lot of confidence that everything's fine what what what we can't carry across that are like it's got to shut down all threads all but the main thread and it has to close all file handles but um that's not as big a problem as you'd think why not because I would think um well for the stuff that I need to do it's not I can I can generate a memory image that we start up the Jupiter lab environment where we load all the packages that we need for Jupiter lab to run and then start a Jupiter lab and it it you know first time to plot is less than two seconds okay okay fair enough um that makes me think you mentioned the word threads and I can't quite see I can see how you've got a requirement for parallel processing and threading how does that fit into a hybrid lisp C++ model how does that fit so we have uh common lisp has a standard it's also got a several libraries that have become deao standards like Bordeaux threads is a the deao standard for creating threads taking them down communicating setting up you know locks between them and we use that to do multi-threaded programming built on top of that are convenience libraries like L parallels where you can just do a parallel map you know Common list has list list um lists and list comprehension so I can map over a list a list um classic tongue twister list and list yeah L parallels you parallel map over a list so I can just give it a list of work and it will allocate that to multiple threads and I don't have to think about it I that's what I do again the advantage of working mostly in a higher level language yeah yeah and when I'm doing that I'm doing these design calculations I've got a 28 core machine and it's using 26 of them flat out I I I get like 80 90% utilization of all the CPUs when I'm doing this design calculations that must be speeding up the the high level chemistry task a hell of a lot tremendously nice nice okay so zooming back out then where is this tool going to take the research uh we we are starting to design molecules now to be Therapeutics and C catalysts um we're doing that now um that's where we needed to go so we're we're we're essentially there it has taken a long time and I really just got the high level design calculations working in the last couple of months okay and so does that put you in a place where I mean the people using this are they saying to themselves I think this would be a great model I think this would be a great End Zone to build I think it will have these pieces are they working like a Lego designer or are they Monte caring a number of things and testing which one works or the people who are using this are basically me right now okay okay and what are we doing let me talk to them okay what we're doing is Catal a lot of catalysts have Metals at their heart like metal atoms like rodium and Palladium and platinum and so you say okay I got a plaum atom and I want to have groups that attach to it hold it in place and leave a space near it that another molecule can come in and get you know interact with that metal touch it uh so you say I need a group here I need a group here and here and here and then you say okay find me a scaffold that can hold those groups in place and the scaffold is built out of our building blocks and so the software goes and tries lots of different scaffolds Monte Carlo search through design space and tries to find the ones that can hold the groups in the right constellation is this into the Realms of things like I don't know genetic algorithms and that kind of stuff you can use those as search algorithms I'm using Monte Carlo it's the simplest most powerful elegant algorithm to do this you have a scoring function you generate possibilities and you just crank on them as on as many CPUs as you can get your hands on and possibly to finish off it's like it's very hard to predict the future it's very hard to predict time scales but at what point will we see a clasp designed molecule being made in a lab I'm hoping in the next um year in the next year not yeah not hoping I'm doing it in the next year okay so the other thing is um I've I've got I'm funded by the Department of Defense and I've got a company that's developing this technology and we've developed the way to synthesize these molecules we've made thousands of them in the last three years um uh so we can make these molecules very quickly and easily takes a day to make any like reasonably sized molecules it takes like one or two days to make them and we're doing this on robots the problem now is which ones do we make at my company we're making millions we're putting them together into millions of different configurations essentially at random and then throwing them at the wall to see what sticks right the software those are our hands we can make those things the software is meant to be our eyes so so that we could see and predict what to make so I'm bringing that online now right okay so the search space is potentially so vast that's the problem we're solving vast I mean we have in theory we have thousands of building blocks in practice right now we have 40 you put four of those building blocks together in a sequence that's a very small thing but it could be a drug so then you've got 40 to the yeah 40 to the^ four different shapes that you can make of just that small configuration okay you can either try and make some subset of them and throw them at the wall and see what sticks or you can try and design them in software that's what can do is force to design them right I don't know how well it's going to work it's an experiment yeah well uh you're you're in the research business someone else can uh commercialize it and eventually what will we have fields of sha Meister wheat or trying to imagine the future that you're heading towards the the the first one is new Therapeutics right you know medicines treat disease new Diagnostics to recognize emerging biological threats uh catalysts that can accelerate reactions and create turn cheap starting materials into valuable products I have to ask then if if you've got something like this biological machine that manufactures drugs or manufactures useful things out of raw materials if we see it I mean I'm just trying to think like like War zones for instance Aid um outbreaks of viruses will these things be able to manufacture things in the field if we find them um this this is kind of long-term science fiction stuff I well we're stretching out to the end of the podcast so give me some this is potentially yes we can rapidly build these molecules and if we can rapidly design them then yes you could build things in the field there's a lot of Machinery that goes into this it's not the first thing I'm going after the what we're I'm really focused on is the basic capability can we design a molecule that does what we want when we want to make new Therapeutics new diag molecules that can wrap around proteins and act as Diagnostics or accelerate reactions or create like channels that can purify single molecules out of mixtures like could we pull lithium out of seawater or uranium out of seawater you could imagine membranes that could just selectively pass uranium and keep every all the sodium and lithium and potassium in seawat out and then you could um pull Metals out of seawater and it would be a lot less environmentally damaging than mining yeah yeah plus presumably like dealing with pollution as well exactly I mean when we can build things on the in the the b in the molecular scale like that with intent with rational design we can solve a lot of our problems that that's where I'm working that's I'm working towards yeah I can totally see the potential and I'm quite pleased that there's lisps somewhere in that future yeah it's it's a fun programming environment to develop this stuff in well I hope it goes well yeah Christian thanks very much for telling us all about it Chris thank you for taking the time in cheers thank you Christian now you'll have only noticed this if you've been watching this episode on YouTube but throughout that conversation Christian was drinking coffee out of a lab measuring Beaker which is brilliant very on brand for a chemist if Nano machines turn out to be the future of lisp remember you heard it here first so please take a moment to like And subscribe share with a friend rate post it to the social all those good things I appreciate the feedback and the support it's also worth saying that this particular episode only happened because Christian got in touch with me and said I've got an interesting programming topic that you might like so if you have an interesting programming topic that I might like my contact details are in the show notes as always with that I will leave you for now I've been your host Chris Jenkins this has been developer voices with Christian schafmeister thanks for listening