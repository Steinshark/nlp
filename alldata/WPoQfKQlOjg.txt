fundamentally the question is this you've got a message that you want to send and it's either yes or no or sometimes in signaling they call it acknowledge and not acknowledge i can knock yes and no it's all very well but they might get damaged they might get corrupted coding theorists in the very simplest case did realize that in order to be able to correct an error just a one bit error you needed to repeat it three times on computer file here we have talked about this stuff in more detail i want to try and keep this as accessible as possible to people who are just coming at this for the first time and to try and explain what it is about these three bit codes that makes life so much easier and the answer my friends lies in putting them diametrically opposite corners of a cube what you're saying is if you send three zeros that's fine if you send three ones they don't get corrupted that's fine just look how far away they are from each other it doesn't matter how you get from there to there or backwards you have to go one two three so that's technically called the distance between these two code words so there's two buzz phrases straight away code words and distance between them if you on either side of these accurate code words you write in what you might get if one of the bits gets corrupted and flipped you now have a situation where if you receive zero one zero the answer is sometimes called majority logic the overwhelming decision of this point is that it's got two zeros and one one so therefore if you're going to correct it it's far better to correct it to three zeros going down one edge than to try and go all the way around the cube and correct it to that we're using a total of three bits like one one one three bits but the actual message we're trying to get across is yes or no ack or knack zero or one so of those three bits the only bit that counts as a message is concerned is just one of those bits however in the course of keeping these code words far apart we have agreed they are distance three from one another in terms of a walk you do around the cube along the edges so here we are total number of bits number of those bits that are devoted to the real message only one how many journeys around sides of the cube would you have to take to get from one code word into another so it's a three 1 3 code 313 is the simplest full hamming code and it is perfect what do i mean by saying it is perfect every single corner all eight of them serves a purpose a corner is either a code word the actual thing you're trying to get through and hope it doesn't get damaged or if it's not a code word it's a correction vector it's a corner of the cube that's adjacent which gives you the clue that if you get that received you go to the nearest code word along a cube edge so every single corner is concerned with either the proper message or how to correct it nothing goes to waste three one three where do you think the next one of these perfect ones would occur that occupy all the corners not on a cube this time have to be on a hypercube so hypercube is going to have what another four another well it could be four it could be a four dimensional hypercube of five dimensionals i think i feel like it's gonna be a round number let's go for six six one something close it's not i will reveal the answer and then we'll try and justify it later on that's the simplest popper hamming code next full hamming code is not at six it's at seven and in this notation is this prime number related then no uh it's not actually prime number related but you will see a pattern emerging this right hand thing of three is always there even if you're on a hypercube you keep your code words three edges apart and what happens with more bits in use is you can afford more bits to hold the message whereas before we only had a one bit message two possibilities here we've got a four bit message which equates to 16 possibilities 16 possible code words 2 to the power 4 all wrapped up in a 7-bit message now your final clue the next one after this 15 11 3. there is a pattern emerging here folks particularly on that leading digit 3 7 15. always one less than a power of two that's a necessary condition together with distance three between code words for these to be proper full hamming codes and what i'm saying to you is 743 is also perfect let's try and reason why it's perfect by waving our hands around a lot okay it goes like this you've got four code words they're on a seven-dimensional hypercube if it's a seven-dimensional hypercube out of every code word corner there are try and imagine it seven edges going out to correction points for it plus the corner itself so simplest one is eight right you've got eight possible things the either the thing itself or its correction points every code word counts eight in terms of corners of the hypercube but how many of these code words can you have two to the power four is sixteen and everyone takes up eight corners sixteen times eight all right he's 128.28 yeah i do agree so you need 128 corners just by reasoning from a cube right up to a seven dimensional hypercube you can say you would occupy 128 corners but consider seven bit codes which is what we're talking about in this hyperspace what's two to the power seven 128 bingo so you've got 128 corners and they are exactly used up that is what a perfect code is all about it's about using up the corners on your hypercube to the absolute maximum it's so eco-friendly you know absolutely nothing goes to waste the big problem with these hamming codes is that they only correct one error that is the stopper in the end that they're just not suitable for the kinds of situations that occur in real life or at least out in noisy wi-fi setups or out in interplanetary space very comparable really in terms of background noise bursts of horrible you know activity going on there that ruin your code you need something rather more robust than a code that can detect only one error but nevertheless there's a thing to learn about first and the ability to entirely cover certain hypercubes with the codes and the way to correct them they're very nice i'm very fond of perfect codes does this mean that other codes in between these are unusable no for those in the know we've done one already we used richard hamming's methodology to develop it but we didn't admit to its shortcomings right