this is the number four and this is some code that I've written to send that number four between a client and a server sounds pretty simple right well actually in this code there is a bug that not everyone may see you see the number four is an integer type in this example which means that it takes anywhere from four to eight bytes of memory to store the number four a commonly overlooked problem for a lot of new programmers is the idea of endian-ness which means in what order are these bytes stored in the case of a little endian system the least significant byte will be stored first which in the case of our number four the number four is put into memory first in the case of a big endian system the most significant bite is stored first which means the zero will be stored first so you may be asking wait how does this create a bug in our code well consider the example here of my client server software what if we sent the number four from a server that was little endian to a client that was big Indian because of the order that the systems expect the bytes to come in this will create some weird bugs where the number four will be interpreted in a different way between each system let's go check that bug out okay so we're going to walk through our code and kind of describe where that bug is if you're new to C not a big deal this code looks kind of complicated but there's actually not that much going on what we do here in the server is we have our socket we create the socket and then we bind that socket to a port we listen for clients and when we accept a client we then send them our numbers here's kind of like where the core code of the program is right we have a number four in memory we send the number we tell the user we're going to send it and then we send the my number variable and we send four bytes okay so pretty straightforward and then in our client software exact same thing we create a socket we connect to that server and then we receive from the server the mine number variable my number four let me print that number right so what we can do here is we can actually run the server wait for a connection and then in the terminal here we're going to run the client we're going to say reading a number my number is 4. so the reason why this works and why there is not a bug in this case is because both systems are little endians if we actually go into our server here and we cat proc CPU info you will see that we are running an Intel processor an Intel Core this is my processor for my computer pretty cool but Intel is a little Indian architecture which means that it expects the least significant byte to come across first so an issue will arise if we change one of the systems to another endedness or a big ending architecture so what I've actually done here is I've compiled my client software to be used with mips mips if you don't already know is a big ending architecture so I can take this and produce the mips client binary and that mips client is going to run in Kimu as a big ending system and that'll create a couple issues with our program here right if I go back and I run our server awaiting a connection remember the server is going to send our client the number four in little ndn architecture in little ending order which is going to be weird for mips so if I run the mips client it reads the number and then it reads this large number that is not the number that we sent it but the reason that happened is because we mixed little endian in big endian so let's go into the code and fix that the way that we have to do this is we have to do what's called pack the number into Network order so Network order is largely accepted to be the big ending order which means that for to make this number correct we need to convert it into the network order before we send it the way we're going to do that is we're going to say that my number is equal to host to network long of my number so by doing this we will prepare it to be sent in the network order and then what we can do in our client software is we receive the number off of the buffer and then we say that my number is equal to network to host long of my number if you don't understand what those lines do don't worry about it we're going to talk about it right now so what this does it takes a long size value and it converts it from the host endian-ness to the network endedness order so in this case on the Intel side it'll take my number and convert it from Little to big or network endings on the client side what this does is it says take a long type and then convert it from the network order to the host order so now we have two programs that regardless of what endedness they are they convert all of their data to network order send it and then deconvert it so let's watch that happen real quick so we're gonna go ahead and we're going to GCC compile server again real quick couple warnings don't worry about that and then we're gonna mix convert and recompile all of our stuff so if we run the server here on the mips client we get the number four backed correctly so By Doing Network order as opposed to host order we can actually ignore the differences in end in this that a program may have anyway guys as usual thanks for watching I hope you learned something if you did hit that sub button and then also go watch this video on how negative numbers work in binary if there's no negative sign in binary how does that happen go click go