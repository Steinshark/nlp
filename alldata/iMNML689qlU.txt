I will speak about modules and how you can use them today on multiple platforms I will give you a short recap about uh the current state of what you need to know about um modules this is not a full introduction if you're expecting an introduction into modules this is not a talk here here I've started talking about modules in 2019 if you want to know all the details about different aspects of modules look at my previous talks from 2019 2020 2021 and this is what you probably should know to understand everything what I will be talking about then I will talk about compilers and the current state of implement mentations about modularization about build systems module dependencies and how you can handle them and I will give you a short demo as you can see I do stuff for quite a long time if you want to take a picture of this QR code here this is where you can find the slides beginning from possibly tomorrow and also all of the demo code that I will be showing just a quick question Who of you has heard about modules beside the title here good who of you have actually done something with modules okay we can improve who of you have modules in production wow more than I expected now we are free people this is good and all of the rest start using it okay just to make sure that we are all all on the same page I give you a short reculation about what modules are about and this is proba the shortest introduction to modules that we will ever see this is a traditional code here we on the right we have a library with a library interface header and also with an implementation file and on the left we have a translation unit of your code also a translation file and as we all know there's a barrier between translation units every translation unit is in dep dependent of all others so this means the interface is becomes incorporated into each translation unit which means because of the point why you're actually including interface of a library into a translation unit the meaning of the text that you have been writing into your header may change and this may also cause subtle odr violations that you're probably not even aware about so what does the compiler do if it compiles a translation unit it starts out with a known compilation State at the beginning no declarations couple of macros a couple of compiler options and during the compilation of the translation unit the compiler will possibly know more macros in particular lot of more declarations and at a point where the library interface header is included the compilation state is no longer the same as it has been in the beginning and this can change your the meaning of your code and you probably don't know it it's not only the macros it can be more things that can affect the semantic meaning of your interface well at the end of the compilation the compiler writes out the object file we all know that but everything else is decard discarded if we go to modules one important thing changes the interface is no longer a header that is textually included into other translation unit it becomes a translation unit on its own and this has an important change in the behavior the library interface unit becomes compiled so now it is also separated and isolated from all other translation units this sounds weird because now how to transport the Declarations from interface to other translation units well there's a new channel now and this new channel is called BMI build module interface this is an additional artifact that becomes included into the implementation of your library and also to all users that want to import the interface of a library the difference is within the module itself the implement mentation files of a module see everything that's contained in the interface translation unit but the users outside of a module see only parts of it and this is done by explicit export statements so the architect of a library decides what becomes available on the outside of a module for the compiler there's not that much difference here but there's important difference and the important difference is the translation unit is a the the module interface is a translation unit on its own so it starts out with a known compiler State you totally know what the semantics of your interface are and at the end we don't get only one build artifact we get to both the object file and also the BMI file with all the contents of the um declarations and definitions that the compiler has seen during the compilation of the interface unit and it also usually at least contains information about the initial compilation state so now we have actually means to check for compatibility between the compilation of an interface in a library and the usage of an interface this is a pretty dense picture here but we need to know to tell and learn about some important things in modules in the top half of this slide here we have the primary module interface unit this is what I've been speaking about before and then the bottom we have the module implementation unit and both of these translation units of a module have a name hence the name this is a named module you can refer to other modules by using the names and this is the only way to refer to modules then we see this greenish part on the slides that the scen part belongs to both the mod interface and both to the implementation and these sections of the translation units uh comprise the soc called module perview module perview means everything that is in this greenish sections of the code belong to the module and only to the module and then there's also this brownish section the pieces here these are the sections in the translation units that belong to the so-called Global module in the beginning you said you're not using modules you actually do since 40 years possibly since the ex Inception of C++ everything that you have written so far belongs to the global module this is a module that has no name and as you can see every module transl unit can also have parts that belong to This Global module the thing from the past this is where all your existing code lives and everything what you want to use in your module is part of this Legacy world of traditional compilation and this applies for example to the standard Library the standard Library belongs to the global module and also all of the libraries and the Cod you have written in the past everything belongs also to the global module and if you want to use these parts in your modules themselves you have to place the interfaces in here the global module is a module without name so what does it mean to export things I've said before everything the compiler sees in the translation in the um Library interface becomes incorporated into the BMI but only the parts that we actually Mark as an export like here is actually available to the users here I have a function definition called frop and it's declaration the the only thing that changes using the export keyword is that the name FR becomes visible to the users of a module this is the only change that the keyboard does in the implementation you also have a module declaration with the same name as in the module interface unit and this is the key take away from all what modules are about there is one important thing that you need to know about the module purview the module perview is the means that you get an important feature of modules and this is name isolation what does it mean we have two modules here module one top left module two top right both of them have a function definition called Fu with the same signature in the same namespace and you usually would assume these function declarations refer to the same entity the same function Fu because these two function declarations are in the perview of their respective modules these are now two different functions called who so if you um write a library you no longer have to think about where do you place my internal stuff you no longer need need uh unnecessary name spaces and you don't have to fear that um you come up with a name that possibly is already existing in your program each of these two functions who are different entities so if you import both of these modules and use functions from the interface that refer to the respective functions F in the implementation each call of the functions bar and bus here in this example refer to their respective independent uh F implementations and the Linker can also tell them apart the reason is that everything in the module perview is attached to the respective module there are in so instead of just calling this a Fu this is a Fu function attached to module one and also a function Fu attached to module two these are two different entities and you get two different symbols for the linger this is one of the key features of modules then there's another thing modules are not just a single entity with one interface translation unit and implementation units actually named modules can be composed from Parts in fact we have five different um options to choose from to compose a module and besides the module composition you can also have a thing that I've not been speaking about yet and this is the header unit a header unit seems pretty simple you just take an existing header give it to the compiler with a certain flag and the compiler would compile your header up to translation phase 7 into just like as it is a translation unit and and you get an object in a BMI file but there are key differences here everything in named modules all these translation units have a module perview and so they belong to the respective module header units don't everything in a header unit belongs to the global module so you need to be care careful with select your names in the name modules you can possibly have sections of the global module but the header unit is completely part of the global module and another important difference between named modules and header units is the capability of exporting macros header units do they behave in this regard just like can include but named modules have no way of exporting macros if you have Library interfaces that use macros you can't do that with modules you need to find different solutions and this ability or disability inability of exporting macros gives named modules full isolation they can't be affected by other code and they don't affect other code whereas header units can so this is a short introduction into modules I don't go into any details you can see or can look at the talk from 2019 2020 and 21 and these three talks will give you everything you need to know about about the stuff that I've been talking so far now it becomes more interesting let's speak about the implementation status of compilers how are we today and where are we I will give you some information about the features that the different compilers support how complete the implementations are and the hot topic of file extensions and the maddening part about compiler flexs that each compiler requires and this is not my opinion this is the opinion of the implementers this is what we tell about their compilers and how they document it and this is the current situation if if you have seen one of my prior talks it had a similar table in there but now you will notice over the course of the past two years the table is mostly green wonderful who would have expected that besides bugs in the implementations msvc is feature complete for quite some time now it doesn't mean it doesn't have bugs quite a lot of them the same is through with clang and GCC the problem is both clang and GCC only still have partial implementation of some key features but besides that um you can actually do interesting stuff of both of these compilers all compilers have conver verged on the same model how name attachment works this is good you don't have to do different things for different compilers the major different lies difference lies in the current implementation state of a modularized standard library msvc has one clang lip C++ also has one but it's still in an experimental state I'm looking look forward to see more about this in the near future possibly clang 18 if I'm right well here we have the lip up C++ leading developer or one of them at least I'm really looking forward to see what we get in the next version of clang and Jesus he didn't even try to attempt a module mod modularize standard Library implementation the next thing that I've been already alluding to a little bit this is how to make sure that you can use existing BMI files in your code if you import a BMI file the interface of a library you need to make sure sure that you have matching compiler Flags so that you don't run into subtle odr violation this is what modules are all about msvc doesn't have that many compiler flags that need to match up it's only these here these four here and even then you can decide oh for example I don't care that much about rtti and can just say hm I don't care this is possible with msvc clang on the other hand has an implementation of modules that is mostly built on top of pre-compiled headers and therefore it requires a lot of matching compiler Flags so that a BMI is actually usable and if you have an mismatch in compiler options clang will refuse this particular BMI to import into your own translation unit GCC there is no documentation about this kind of stuff so I unfortunately have no option to tell you more about that next the Hot Topic of file naming there are strong opinions in the community some people say modules are broken from the very beginning because every implementor has chosen a different preferred file extension yeah to some extent this is right this is unfortunate but it affect you only if you compile manually on the command line if you use the preferred options here like cppm CPP or IX you can actually compile complete programs from the command line in one go this is possible but every compiler needs a different invocation a different file extension in general this doesn't affect you in any way you use a build system this is what you do you don't do it manually if you want to learn possibly then manual compilation is a thing I wouldn't do that and you need special compiler Flags to say okay this particular translation unit is a module translation unit or is a header unit but usually you don't do that by yourself it is done by the build system okay this is where module implementations are today let's get practical let's take an existing Library apply all the knowledge that we've learned so far and make it a module my example here is the so-called Arc pars Library later on in the demo I will use this particular module and let's try what we have to do to actually make this traditional header only single file module uh Library into a uh module and this library is just one name space have a couple of implementation details and a few entities but a part of the actual interface of the whole Library so this should be easy right does anybody see a problem I hope not so if you're an aspiring module developer you need to to do two things you need to mark it as a module translation unit you give it a name and the second thing is you need to mark your interface as exported let's do that here's the modu Declaration with the name and here's the export we export a whole group and this is the stuff that you want to export easy let's compile in alphabetic order let's start with clang this is the most recent clang requires a couple of compiler options don't even try to remember them the build system should do it for you but this is how you would do it from the command line or like it I did it from the command line let's try to compile the interface oh no bad doesn't compile it tells us something about the algorithm head I was using the lip C++ uh standard Library here hm we have more compilers let's try TCC the latest one a different set of compiler options same result it doesn't compile yet again about the algorithm Library I think the plot thickens last compiler msvc also the latest one different set of compiler options and it compiles it creates the BMI IFC file and it creates an object but it has an opinion about this particular code this sounds a little bit fishy what's going on here the include of the algorithm header seems erroneous H it gives actually a hint what to do you should probably put the algorithm header elsewhere ah this Global module fragment that's the solution let's introduce a global model fragment and this is the place as we've learned before where to we place all the existing Library interfaces that come from the implementation or from your code all of that needs to come go into the global module fragment and please don't forget one all of them should be there don't put them into the module perview okay let's try again once again clang GCC and msvc uh nice try clang does what it is has is supposed to do mspc as well and GCC has an opinion this compilation is probably worth a segmentation fa okay one down two to go as shown before the module interface has two different interfaces one that is looking into the module this is where the implementation files reside and it has a different interface that's looking towards the outside of a module if you compile a module in particular one with more translation units than only one interface during the compilation of the module you already exercise the internal interface you're pretty sure everything is where if the compilation succeeds but you need to explicitly test the interface to the outside if you fail to do that yeah Will Pro you will probably have problems later on okay I have a very short very lucking test case here it doesn't use anything from the standard Library let's try to compile that with clang msvc and of course GCC is out and as we can see it works yeah with on caveat here msvc requires you to use a particular include from the standard library and this is actually correct I've shown earlier the module has a perview and this is where everything belongs to that is part of the module we also learned we have a global module fragment where for example the standard Library includes live the global module fragment is a part of the global module and the global module is a different module so the standard actually requires you to throw everything out of the global module fragment that is not referenced from the module contents itself this is uh I call it um gmf declaration pruning and definition pruning clang hasn't implemented it yet so it puts everything that sees it sees from the global module fragment into the BMI so you get quite bloated bmis in the current implementation this will change in the future this sounds a little bit uh difficult for users but what i s that library to the rescue you don't care at all if you use that okay this was the easy part the more difficult part is that I have avoided so far in the not exported parts of the Aras Library there are entities in here which don't have namespace qualification and this means two things the first one all of these names in here are subject to ADL argument dep dependent lookup this slows down your compilation not only in modules in all of your code by the way and it can cause look of failures in case of modules these are entities that are not exported and you instantiate a template from a module in your code and the body of the template wants to refer to entities that are not exported which means the names are not available for lookup as I've said before the lookup will fail if you qualify all the names name lookup would happen in the first phase of the compilation during the compilation of the module interface so you don't have this problem and there's a different problem in here so-called translation unit local entities soful it means you have static variables or static functions at namespace COPE in your code and you refer to these particular namespace uh aesthetic local functions or name variables through other functions that are possibly inline inline or um inlined in this in the trans u in templates and this means they have no symbols and if you compile it in the uh in your code and want to refer to them the Linker would refuse to there are no symbols at all this is called an exposure and this is actually something that makes your program ill formed so you should no longer use any Statics or Anonymous name spaces in your module code please avoid that and actually in your current situation of traditional compiling this is also called out by the standard as deprecated you should avoid it as much as you possibly can don't do that and you have an easier time to go to the modules SP let's switch from the smallest module to the largest one in the demo code I use the AO Library this is a huge library has a lot of files and if you want to modularize that we don't can you cannot do it in the intrusive way as I've done it with Aras there a different way how to modularize the library that I called is Trinity of of modules the global module fragment the perw and the private module fragment in the global module fragment here I place everything that comes from the platform or the outside of the library then I place everything in the perview and Export it from there that are the interface of the AO Library possibly even more and then in the private module fragment that is not visible or reachable from anywhere outside I place all the implementation files of the AO Library this is just one file that I have to compile and get the whole of the library I get two artifacts the interface and the complete implementation okay this was about modular modularizing existing libraries let's talk about build systems build systems should be aware of modules the oldest one is build two H I wouldn't recommend it anymore but a couple of years ago it was the only one then of course the most interesting for probably all of you is cake it has actually acquired support for named modules at least since the beginning of the year but it has no support for header units and this is uh a little bit set and it requires quite recent versions of these three compilers here then we have MS build okay this is part oficial Studio visuals uh Microsoft has a good implementation of modules so it has a perfect implementation of of a build system it's boring it does everything what you expect from it and then there is a new one called xake you might have heard about it it's quite popular in Asia and it claims to have decent support for modules I haven't played with it yet you can do it by yourself at best benefit is probably it claims to have a nicer syntax than cake speaking of cake uh the support for module started in version 3.25 and it has been experimental until 3.27 and uh like bit supported only clang and msvc and 3 to 28 with full support for modules it will also support GCC when it comes out next year it heavily depends on dependency scanning this is uh what I've probably been alluding to uh earlier you don't want to do all this dependency stuff by hand because every BMI is a dependency on the build of another translation unit as you probably have seen and noticed you don't want to do that by hand you want to do that that you can upload everything to the build system and you need I ninja or the MS build as an something that executes actually the build graph so what is needed to make modules module translation units and build them with cake what you have to do is you need to indicate the nature of every translation unit this is what you already know you have a Target sources statement and you place all the non-modular translation units in here but you also need now a file set this is a new feature that says okay this is a set of translation unit source files that are named modules and create bmis and you have the same for header units but unfortunately this is yet to be implemented so you can't use header units yet but this is the what the syntax will be and you don't have to forget you need a recent version of CAC with the right policy in there if you have the opportunity to use CAC 3. 28 everything is easy you can use it also with uh earlier versions of cake you need a b little bit more code you can look it up in my my uh demo sources as said cmake depends on dependency scanning and module dependency Discovery so you need uh to have a compiler that has a dependency scanner in its implement ations all of them have right now these compilers need to report a dependency that they have discovered CAC will generate module Maps out of these reports and a module map this something that we will see in the next few minutes and you need a build node processor like ninja and Ms build these are the things that you need to do and you need a supported version of cake of course that's a lot you need to know about build system in particular cake sounds a little bit scary but please this is just unfamiliar it will come quite naturally if you're more into using modules so please don't feel scared by this guy from 100 years ago let's move on to module dependencies what does it mean this is another module from the demo code here this is one that uh is coming from the stdl library I know don't know how many of you are aware of this Library this is a C library and I've added a C++ module interface on top of it and because this is a C library with lot of macros in the interface I had to implement the module a little bit more complicated now we have not only the module interface in the top left in the input in in the interface we also have additional module partitions this are one of the types that I've been showing before one of the partitions is is on the bottom left and one is in the middle and this is where the magic happens and with the help of a little bit X macro Wizardry I can get rid of all of the macros that are coming from thec headers and turn them into proper language entities that you can export from a module so you no longer need macros but this means we have an internal structure of module translation units not only one but three in this case so what does module dependency scanning do in this particular example I use clang and ask it to create dependency report for this particular modal partition here this was the one from the bottom left and clang will then report okay this translation unit provides a ma with the logical name stdl partition Global mod macros this is an interface and the source code is here and to compile it you also need another module partitioner in this particular case called sdl Partition with macros this is what all the compilers will return if you asking to do a dependency scanning and the reporting the results of it this is from clang msvc is just the same small differences but all the interesting part are are identical and what CAC will then do during the compilation it takes all of these reports and create so-called module Maps sounds pretentious it's nothing but feeding the correct compiler flexs where to place the output where the where the BMI should go where to find referenced bmis from other modules on the top with clang on the bottom with msvc is just the same but but different syntax and this is what a module map is all about you don't want to do that by hand and this is the important part use a build system to just forget about all of that this is what's going on behind the scenes if you are make user you need to know about all of that okay now we know everything about modules how to modularize Old code what need to avoid to not run into pitfall how to use the build system with modules let's do a short demo that is not just a promise but this is reality and the demo code is the same as I have been using it last year who of new of you have seen any of my talks last year the keynote from here or possibly the keynote from cppcon good but there a lot of people who haven't seen it yet so um this demo code does is a small application it consists of two parts one is the the client part and one is the server part these two parts speak over a network connection and as soon as the client connects to the server the server will look into a certain directory that is given on the command line to look for animated Chi files in that directory and it would then decode this Chi file into video frames and sends each individual video frame through the network connection to the client the client would pick it up and display it on a GUI this is what this application is doing about and it does it endlessly as long as the client is connected if you want to know more about this demo application watch the P note from last year this main translation unit here is the only one that is not modular it uses only modules the modularized standard Library the a module that have been as have you seen before it has a couple of more modules that are coming from the implementation of this application and then a few lines to orchestrate all of the services that come from the modules in the application this means this application has a certain module structure some of them of these modules come from the Implement implementation of the of the demo code itself eight named modules and these are deliberately made so that you have every translation unit type that you have seen in the table before so you can look it up and see how these different translation unit types can be applied to in in practice I have an header that has formerly been a header unit but because CMAC doesn't support header units unfortunately now it's a header again and it uses third party modules as dependencies ACO arath lip a and stdl we have seen three of them before and it uses the modularized standard Library we know lip C++ has not a modular standard Library yet lip C++ is not yet published so I had to do my own implementation of modularized standard library with some additions on top of it this is what I'm using here in this demo code so let's get real let me start up Linux come on here we are I've already preconfigured this whole apption it takes a long time unfortunately on Linux for reasons clean it so we do a full build what it actually builds is all of these modules that we've seen in the previous picture standard Library the four external libraries everything within the demo application itself and now we're done everything is compiled did anybody of you notice any delay because of compiling the standard Library I hope not and okay it build did build let's try it okay last year you've seen it on windows with the Microsoft compiler this here you see the same running on Linux built with clang and ellip C ellip stood C++ standard Library as a module think this is quite encouraging so what is my conclusion from all of that even if you don't want to use modules yet I highly recommend to use the modularized standard Library you didn't notice any build delay but using the modular stand modularized standard Library gives you huge benefits in the code on the above you see three methods to provide all API of this mod of the standard Library you can use an umbrella header like all stood HPP here and tex included like you always did you can use this umbrella head and compile it into a header unit and import it or you can use the standard Library as a named module and also imported all of three options are available to you you can e also use them all together and this is supposed to work the standard guarantees so if you only include the umbrella Header by itself texture inclusion how long does it take only to bring in all of the API without any further compilation on my test system it takes a little bit more than two seconds to actually just provide the API if I import it as a header unit I measured 15 milliseconds and if I import a proper named module I can't measure it it's impossible no matter what I did it was every time less than one milliseconds I think this is quite a feature and this matches up with what I've been showing two years ago in a different talk I did it with the fmt library in 2021 as you can see had only textual inclusion can slow down your compilation quite a lot whereas just importing all of the interface in particular of the fmt library it's unmeasurable just the same as of the standard Library so use the modularized standard Library if anything else is too much for your current situation but I highly encourage it and looking at everything that I've shown before what's my opinion on that well it's like this I think they have come a long way with module implementations now you can do it on multiple platforms with multiple compilers and this actually works modular regular implementation box but besides that you can actually do interesting things with that and if you want to use modules in the future this is probably about the time where you can start experimenting and um getting your own experiences and how you how it fits to you and your particular situation in the company where you're working at or I started using it in production 2 years ago so I think you can do interesting stuff here you can find more resources about modules about the code that I've shown before here's the QR code once again where you can get all of that including the slides and you have a little bit of contact information if you want to ask me questions beyond the end of this conference here and that I'm done and if you have any questions feel free to come up to the microphones hey come on guys are you scared I hope not well not from you but from mods maybe um so if I have a large application code base and I want to move towards modules would you think it makes sense to make an intermediate step with header units um it depends on your build system cake okay now now the question is answer well waiting for cake with head come on CAC with header units oh well waiting or is it a long wait do you think um you notice I'm a member of the tooling study group in the committee we are discussing this stuff quite a lot if you really want to use header units uh you probably go with Ms build if you need to use cake you probably have to wait for H my expectation is a year had the unit seem simple that are actually the most complicated thing in the world of modules most people underestimate what it takes to use header units and it was advertised as the intermediate step as you were saying it in your question but actually it's a dead end in my opinion I wouldn't use header units unless I'm really forced to maybe you have macros in your interfaces then there's probably no no other choice but then you have to wait for a build system that actually support it maybe XM is a solution for you okay thank you welcome hello um I would be interested if there are any implications on uh shimming so if I preload my custom binary to override some routines um it and if I have uh implementation in a certain module would I need to have shims that reflect uh some sort of uh routine or function names then in the resulting assembly code excuse me I didn't really understand everything because of yeah so so if I um want to overwrite um routines um by using a shim and pre-loading a binary um are there any name space or name implications when I use modules um in general modules don't change anything of that per se modules are about the interfaces implementations don't change at all you have to make uh translation units of the implementation parts of a module just to contain the name but besides that it's just the same you can use DLS you can gims you can use anything you like as long as you don't run into OD violations you're good okay thank you and everything else is unchanged great presentation thank you um when would you guess realistically pessimistically um GCC and um clang would catch up with Microsoft um good question it's very difficult to answer this question like we learned in the keynote in the beginning predictions of the future are difficult so what's my opinion on that well we see implementation bugs and deficiencies and implementations both of clang and both of GCC I think clang is on a very good trajectory speaking with the clang developers I would assume clang 18 is a huge improvement over CL 17 just like 17 was Improvement Beyond 16 but it's a matter of priorization what's more important for the implementers and the people actually uh behind the financing of the uh work on clang on GCC well I think at least I hope GCC for will be the very first one that's actually usable for some light usage of modules I think GCC is at a situation where msvc has been two to three years ago and msbc has good fun Jesus he doesn't draw your conclusions from that so I see if you want to use modules in a in a good way without too many hles and too many bugs Beyond windows I would highly recommend go with clang and I think beginning next year we can expect clang 18 first quarter first quarter so this is probably a good way to do more serious work with clang in the world of modules that's my opinion on that thank you so I was told I can't tell you anymore but you will find me on the rest of the day in new conference and ask questions form opinions thank you for your attendance and your patience