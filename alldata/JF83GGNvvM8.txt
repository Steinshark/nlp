welcome to my talk about clean test my modern testing framework so since this is my first conference appearance uh maybe a few words about myself I'm Philip um I actually did a PhD in mathematics and worked on algorithms that optimize the physical layout of computer chips and after that I joined the Bell deep L is a interesting European startup that develops neural networks to help people work with language and we have a fast growing user base which brings both challenging algorithmic and Technical problems and some of these we solve with C plus plus Services of our own that benefit from the latest tooling that latest tooling and stupid standards that is out there so if any of this sounds interesting to you with many open engineering positions several of which are in C plus teams and yeah you can take a look at our page or talk to me but back to my talk so clean test is the testing framework that I wish existed a couple of years ago and here's my attempt to bring what I wish a testing framework offers so it's standard written in standard C plus plus and does not use any macros um it provides it is so nowadays uh if you execute tests sequentially you essentially waste resources both your time and your machines time um and this is why clean test executes tests in parallel and uh supports simultaneous failures of assertions it is not header only because that would mean that every user is going to recompile the framework in every translation unit but instead it's almost as easy to integrate it's a cmake library that does not have external dependencies and it has all the expected convenience functionality for usci pipelines for instance it can export the unit reports of the of your test runs and it can deal in with invalid unicode and it's released on the Boost license so available on the right you see the first example um and you might already notice that you don't need to bring your own main function you can of course bring your own main function but as in this case you don't have to um and what I want to point out so since this is just a standard C plus plus you can even without um continuing to listen to this talk uh take this demo and discover clean test on your own so for instance expect is a function and you can take your favorite IDE and start to poke around in this example see read the documentation and get an understanding how the framework works and how you are supposed to be using it but nevertheless I won't of course want to take the opportunity and explain the three basic concepts that you already see here which are Concepts which are suits tests and expectations so first so this QR code leads to the presentation PDF in case you want to click have clickable links so um this slide is here for a second so you can take a copy if you want um but of course it's the the PF will not go away um so let's let me start with with the test suit a test suit is something that is um a callable object that is executed automatically upon Program start so when you execute your test binary these suits are invoked and they are of course they are just some callable object and you can do whatever you want in that but you're supposed to be setting up tests inside suits and the reason the primary reason why it's handy to set up tests inside suits is that suits set up the right naming scheme for instance in this case we have a talk suit and this torque prefix will be used by all the tests that will be defined inside this talk suit and of course suits Nest you can take a couple of suits and start to build a tree of tests a test case on the other hand is something that is executed later so notice not all tests will be executed all the time some you can enable and disable some of them and some will just be skipped and yeah and a test case is something that is supposed to be Standalone and you need to be careful that you don't I don't know capture that have a dangling reference in the capture for instance but that is that these are standard problems with C plus and I would just want to point to the special assignment that I have to use in line seven so this is necessary on namespace scope so there's no way around that um but otherwise I always use the syntax that I prefer most which is with these user defined literals and the assignment in case you don't like this you can of course stick to ordinary Constructors and objects which I do in the second example and you can either assign into a test or suit or you can use the respective callable object as a secondary Constructor parameter and a test does not only have a name which is basically just a string but it also has it can be tagged and these tags so in this case I tag a the third test case and these tags can then be used as additional credit criteria to enable or disable tests and so now this let's let's look how this let's see how this looks if you run it on the left you see how you how this test binary works if you just run it without extra parameters first see that the test cases are indeed executed in parallel so you see that's a bunch so every basically we start three test cases before any of them succeed so before any of those is done of course then now I want to emphasize that this is not like a possible output of course it's non-deterministic but um it is so the process of building this PDF actually includes compiling the demos and capturing the real output I got yesterday evening and so this in particularly means that all the demos that you will see today really compile um and yeah and this is the the output that I got on the right you see that what you can also do with this test binary you can use dash dash list which instead of executing the tests uh prints this nice Unicode tree of what's inside of this executable and there you see the three test cases some of which are tagged and then you can start for instance to write a filter that and selects parts of the branch parts of the branches of this tree that you are maybe interested in and after that you omit the dash list and execute your selection in addition there are many other runtime parameters that you can play around with but you can of course discover these on your own using help and that brings me to the third and uh probably most important concept of clean test which are expectations and so for this um as you already saw we have the expect function and it is um yeah for for instance in line seven so this is the first expectation that is succeeding so on the corresponding console I'll put on the right you don't see an error and on line eight we have the first failure and you see that we correctly capture the line number and report that something is wrong there but what's certainly unsatisfying is that um we just print the value false what we would have liked to see would be um that on the command line we see where the spot is actually coming from why the expectation is violated and what which values correspond to this violation and so the sad truth is there is no way to get this without macros on this level because essentially whatever we pass and to expect is already converted to a Bool and so expect has no way of finding out where this value of false is coming from for expect it's simply a bull with false um but of course there are solutions for that and they require a little assistance of the user and the essential idea is that we will not be passing the Boolean value to expect but instead we will pass an object that is basically the expression tree so the tree of how your expression looks like and to start building this tree you usually start by another API of clean test which is called lift and lift um wraps perhaps a given argument into a thin wrapper you will see details in a second and the wrapped objects then have overloaded operators to start to build this kind of expression tree and how you look how that can look like you see for instance on line 9 where of course all these assertions are failing because we want to see the failure message and on the right you see that it is in indeed working that we can lift the pointer and compare it to the null pointer and get like the the real addresses that have been compared on the command line and for convenience again there are many user different literals again that work on scalar or string types that you can use to lift these values and so the seven underscore I in line 10 is a lifted integer of value 7. okay and yeah so this is probably the core and core feature of clean test and therefore I want to spend some time how to explain how this is really working in detail and after that I'll come back to a bunch of higher level features of clean tests that that are also built in and so this whole idea to pass an expression tree along is um of course not new um I I didn't know the name and but of course I didn't certainly not think that I would be inventing it but it's called expression templates and it's apparently already known for more than two decades which at least surprised me um and uh yeah so let's so now we'll go through a first um demo implementation of course it's not the real implementation um but it's um uh roughly um uh accurate um and we'll we'll see uh how did how that works so I want to explain the example that you just seen so how lifting and equality comparison works so let's start with a clause a clause is the result of lifting something so that means a clause is the Clause is this the thin wrapper that I just announced and since it's wrapping something we have a template argument and the Constructor just forwards into the cached value so to say and then a clause provides three um three functions as a as an API and all expression objects that clean test will be dealing with have the same API and so let's go through through each and each one of those so the first one is value value means get me the value of evaluating the tree that is below you so in that case it's very trivial because we have we a clause is a cached value and so the value is simply this object then we have a conversion operator to Bool which is necessary for using Clauses and other expressions in static asserts the implementation is always the same um like in this line 22. and the third one is the output operator the output operator is supposed to print not what the value is but instead how the value has been computed so for this first example of the Clause this is the same that's why line 27 simply prints the value but you will see more interesting examples in a minute and then we have the expression Concept in line 32 which identifies all of the expression objects that clean tests that come from clean test as being those which derive from tag and then with that we can go through the implementation of lift so lift gets anything and then does it case Extinction either the given object is already some expression then we simply forward we are the identity function and otherwise we wrap the given argument in a clause so pretty simple um let's look at a more interesting example equality comparison it works pretty similar so now we have an equal object the equal object will be the return type of an equality comparison of two expressions that's why it has two template parameters both of which again are already Expressions so then the Constructor simply forwards into both left and right hand side and then we have to go through the three level API again which in this case is a bit more interesting the value is the equality comparison of course of both left and right hand side but since the left and right hand sides are themselves Expressions we have to ask for the value in order to compare for to get the right objects to compare that's line 57. operator Bool is standard as always and then the output operator now is a bit more interesting because in the now we don't print the value anymore but instead we print the both left and right hand side that has contributed to the evaluation and again so the left and right hand side are expressions and so line 66 and 67 again use the output operators of those expression of the objects and with that we can overload the quality operator we take a left and a right hand side and then for convenience we just lift both of them um because we know if this is already an expression the lift is doing the right thing and then we just uh build an equal object around it with which with the deduction guide above that's the right does the right thing um notice that so in this example I omitted the necessary concept requirements for this operator so you on on the one hand you should check that at least one of left and right hand side actually is an expression because otherwise this operator should not take part in overload resolution and the second thing is that you should also check that the underlying values of left and right hand side are in fact equality comparable because otherwise this is not going to work anyways and so clean test does this but I'll omitted this for this mockup implementation so um the the last remaining ingredient is a demo of expect of course so the real expect clean test does some bookkeeping um which I entirely skipped uh so this is but it's um sufficient to understand um the the core aspects of expect we take something and then we print whether this expectation was met or not so we need to convert it to Bool and we just print some tag for it and also we print T which um if in case T is some expression has a chance of printing the expression tree and so this works pretty well line in 95 demonstrates that it even works at compile time and line 96 shows that it also works uh to print this simple equality comparison of seven and eight um so at that point you might wonder or have the the a sense that ATA lines 88 and 89 could be considered a code smell because we might be calling the values multiple times of T and so you are correct with that it's actually a real problem and in a second you will see why we come back to that um yeah and before I I want to let's say introduce this tree notation so the um this is basically the expression tree um and the it is rooted at the equality operator The Orange Box and it has two children the Clauses the yellow boxes of the lifted values seven and eight okay so that's pretty trivial but we come back to this notation later and there it will be helpful um okay so this is a quality comparison so um of course in when you write expectations you don't only want a equality compare values and therefore clean tests overloads not only a quality comparison but 22 operators in total so these are unary operators arithmetic operators bitways operators comparison operators and even special operators like comma and Andor um first I personally personally prefer the textural version of not and and orb so don't get confused so it's equivalent to of course the exclamation mark double am percent and double bar um second is all these of course C plus plus even has more operators than these but um those are the ones that usually operate on constant arguments and so that's why I only overload those because um otherwise it's probably very confusing whether the printed value would be the one that was taken before the applying the operation or after so in either case you're probably confuse half of your users which um so therefore I just don't do it so and um yes so then among all these operators the implementation for and and or is the hardest one to get right and that's why I also want to present that one so we will start with the first attempt how you could implement it and see how far we can get so this is the attempt in essence it's pretty much the same as equal that you've seen two slides ago it's or is a binary operation that takes two expressions The Constructor of just four words and now it's basically it's a copy of the equal object with two modifications the first modification is in line 103 where of course instead of applying equality comparison we apply the or off left and right hand side value and the other difference is in line 113 where we switch out the equality comparison string for the or string so pretty simple and we can use it and so the with an aura you can do the for instance you can use an ORF to get these pointer checks that you are used to and this standard pointer checks are follow along the lines that you want either one the pointer to be null or you want the pointer to hold some value in this case 42 okay um and the corresponding expression tree is shown on the bottom and so maybe unsurprising to some of you this crashes and now it is it's maybe not super intricate that it is crashing but still it's interesting to understand why actually it's crashing and so um let's let's understand that so or as an operator that is special because it is supposed to have short circuiting semantics meaning that after evaluating the left hand side there is a sequence point and you decide whether you even consider the right hand side at all so usually on an or you in case you do this type of check and you come with a null pointer then you don't evaluate the right hand side whatever is written there but this short circuiting does not apply to overloaded operator ores which is due to the fact that basically an overloaded ore is a function that takes two arguments and if you want to call that function you need to bring both arguments so there's no way of skipping evaluating the right hand side argument of an overloaded ore okay but still how do we actually crash so it's We Do Not Crash in line 103 because line 103 applies an or to the to after getting the respective values so in this case the values are pools so the or in line 103 is in fact short circuiting so and it is correctly only evaluating the left hand side and skipping evaluating the right hand side but of course line 113 does indeed crash because we are unconditionally evaluating the right hand side or upon printing it in an attempt to print it I should rather say okay so um so that means we should um we should probably fix this print there are two options how we could fix it one is we just re-evaluate the left hand side to see whether we are supposed to print the right hand side right hand side sorry but um that could be costly I mean there are examples that you can come up with where it's even impossible to re-evaluate the part of the tree that you had before and so that's not the way we are going instead we will add caching so let's attempt to add caching so first for that we need a template Alias this template Alias is um yeah sure and printing it should not evaluate it um yeah of course yeah but um you want to um yeah I mean you you usually when you print the stars or the Stars probably a bit special because it's not too useful to Simply print the address and say yeah the value can be obtained by or could have been obtained by printing whatever is inside this address but usually you also include what what is lying there and that's what I already also do here because otherwise it's less useful so yeah but that's true that's a true remark but you should not try to print it if it's a null point or should you yeah of course you can also add a check there but I mean um you are not supposed to be going down this path anyways sorrow yeah okay um it's okay let's let's try to fix it by adding this caching layer um so it could look like this we start by introducing a value template Alias which determines the type that is returned by the value of call on some given expression and with that we have this caching or that replaces the former ore it has again a left and right hand side expression and in addition a cached left hand side value and optionally also a cache right hand side value and then we in the Constructor we after forwarding left and right hand side we cache the value of the left hand side and then depending on whether it is true or not or truish or not we either skip evaluating the right hand side or we do evaluate it and then again line 114 um in the value call is pretty similar to the thing that we saw before notice that we don't need to check whether the right hand side is available because in the Constructor we ensure that it is available when we need it essentially and then in the output operator we add this conditional print that either prints the right hand side or prints an unknown string to indicate that we did not pursue this expression Tree in that direction okay and so that fixes this example so in that case we correctly let's say print that we did not con consider to evaluate the right hand side branch of Dior the problem is all you'll probably have guessed it is that there is another example so the problem is that so this is a different example now the corresponding trees are on the right and on the right and the oars have line numbers in the bottom and they correspond to the line numbers in the code and so I'll go through the second example so that is again an expression that is rooted at an or and it has two children one of them being the not P check that you've seen before and the other one is again an or which checks that PD references to not a non-zero value or or false which doesn't matter so the thing here is that again evaluating the left hand side branch of this or in line 193 is again crashing because it involves dereferencing the nut printer and so but that that is precisely what we implemented one slide ago in this caching or implementation so um or in other words so in case our or is part of an unevaluated tree of the expression a branch of the expression sorry um we should not even consider evaluating its left branch okay so we need to fix that what we can do is we can try to use mutable data members to also wrap the left hand side value in an optional and only initialize it upon the first value call um problem though is that it these mutable data members are not available um and but I decided so either I can find a way to get this working so then I will Implement all these 22 operators and everything else that is missing or I will probably abandon this project and in the end of course I solved it and I'll show you how and it is comes pretty much down to the fundamental theorem of software engineering and so we will be adding another level of indirection and so now we will have two layers one is the expression layer which is constructed eagerly that builds the expression tree and the other layer is a sort of evaluation tree if you want and that is only constructed lazily where it's actually relevant and so let's see how that looks like um so this is the final implementation um and um yeah that that that will actually work so now we have the or expression which again has two operands and but does not cache any values and we notice that we now change the API so an or now simply has an evaluation function which returns an evaluation object of this or that is constructed from this or and you will see on the next slide how such an evaluation object looks like and other than that this or expression only provides the conversion to Bull for uh static asserts again and and there you already already see that in evaluation A variation um happens to bring now this value API that you've seen before okay and now let's look how this evaluation object looks like the evaluation object cap has a again is a has two template parameters notice that the template parameters now are not the Expressions anymore but they are the evaluations of the respective left and right hand side expressions and then we have a left hand side evaluation a right hand side evaluation which is wrapped in an optional and also a cached value and then let's go through the Constructor it accepts some expression which is an or so it's the order that you've seen before and then we after initializing the left hand side evaluation in line 145 we conditionally um also initialize the right hand side evaluation if it is necessary so in case value is false-ish and then we also cache the value of the entire or okay so that makes the implementation of the value API very simple because it's line 161 we simply have used the cache value and upon printing we have all the details that we need we either print the left hand side we always print the left hand side evaluation and then depending on whether we have the right hand side we also include it okay so um and this really fixes also the third example that I provided and to visualize it on the right you see now the corresponding expression trees and with their respective evaluation trees these are now the blue trees and there you can see how that would be constructed in on these examples and now you see that we really support the case where neither of the or branches in line 193 are evaluated because uh yeah we we skip entirely constructing this evaluation object okay um so now let's uh okay of course so we changed the API of of the or expression object and basically split it into the expression and the evaluation and of course that needs to be carried over to every other operator of the 22 that I announced and mo that is of course done and most of the bowler plate is hidden behind a crtp base but still it's work that needs to be done and um yeah of course that I I should have mentioned that you see the expect function again which also needs to be adapted so we need to query the evaluation once and then both convert this object to Bool and um printed okay and so now let's um let's go back and ask ourselves so what does this mean for a user of clean test so one is if you want to have this sort of perfect expression introspection then you need to make sure that every operator of your expectation is applied to at least one expression of clean test so usually that means apply lift somewhere but you should not be scared too much in case you do this incorrectly the worst thing thing that could happen is that the command line output is not perfect but still you will capture errors reliably and you maybe fix the output later the other thing is that all this all the the entire idea sort of steps at function calls so take for instance line 16 so you can check that if p is either 0 or we dereference it and if this dereference operation for instance is done inside a function or on as a parameter to a function then this works on the standard or so to say line 18 so you are expected you expect that this is working but of course it is not working if the left hand side is a lifted object or a an expression of clean test and the or in line 18 is the overloaded or because then again you don't have this short circuiting guarantee by default and so this would evaluate the right hand side and of course crash so there are two alternatives to get that one is you can either you can spell out this conditional check more explicitly like I did in 20 to line 22 22. the other alternative is that you can also lift the function invocation which is another case that the implementation of lift actually provides so you can get you can to lift you can bring a callable object and then this the return thing is a lazy function call meaning that clean test will use the given callable object when it's necessary and otherwise it the object will not be invoked at all and so in this case we can fix it by wrapping this use the reference p in a Lambda and get lifted okay [Music] um okay so this this is about the Machinery behind um expect and so now I want to get back to more high level convenience features of that clean test is um also bring the first one is you can add debug output okay that can be pretty handy for instance in case you want to you have additional data that is useful for debugging and you want to include it in case of an error and again you see on the right how that would look like the other thing is um so usually if you have a test case with an expectation and the expectation is failing then the execution of the test case continues even after the failure but of course you remember that the test case was a failure instead you can also Mark you can get stricter Expectations by marking them as asserted in that case when you hit an a failure in an asserted expectation then this will abandon the entire test case so in particular then it is the potentially dangerous quote that follows after it will be skipped and quite the opposite is that you can also Mark expectations as being flaky meaning that the failure will be recorded but it will not cause a failure of the corresponding test case so the execution goes on and the test case will be considered a pass even though we you saw an error on a flaky expectation and both of them both flaky and asserted expectations can also be introduced conditionally you can also check for exceptions with the throws API you can either check for any exception being thrown or for an exception of a certain type in that case we want in the example case we only want to see whether the given object can be invoked without an ex exception and that of course can simply be done by negating it so the re what throws is returning is essentially a pool that nicely prints to the command line and you can also check for harder types of failures you can check for aborts or aborts in debug mode which is handy in case you are using a cert the only caveat is that this is not supported on windows currently um the other thing that you might be might want to use in expectations is comparison of numbers and so in particular of course floating Point numbers so let's say you'll have two doubles let's say line 19 and 22 two results of adding doubles and of course this is a deliberately chosen example so that is mathematically both numbers are the same but if you compare the doubles then you get a failure line 22 or console and you see it on the console lines three and four on the bottom and what you usually do with doubles is you don't check for equality but instead you check for closeness and so uh cleantesses bring this is close API which takes two arguments and then in that case identifies those X and Y as being close what you so is close is just a shorthand and uh the what it is a shorthand for you can see in the resulting from the failure in line 24 um I artificially um changed the right hand side of this expression significantly and as you can see is close is on Console line six and seven is close is uh Computing the both the absolute and relative distance of these values and comparing it to some default tolerance which is um by default are the Epsilon values of the respective value T that is part used in this expression and so um the absolute and relative distance are Computing using a norm more specifically are the clean test utils Norm which is a customization Point object that is that first is const expert and returning T in cases where stood Norm which got introduced with complex is only returning double so that's one difference the other is that it's extensible by either ADL or member functions of your custom types that you might be working on and uh yeah but but of course so is close is just a convenient shorthand that is uh likely useful in many cases but in case you need something different then of course you can spell this out yourself you can that's what I do in line 27 you can come and take the exact same expression that was in 20 failed in 24 and compare it to some tolerance where we artificially increase the absolute tolerance and then this uh expression expectation is met again okay um okay at that point you might uh you might be wondering okay so this sounds pretty pretty nice but I happen to be stuck with some other testing framework and it appears to be very tedious to go basically through every line of my test code and start to apply this lifting logic and I can offer some help so I also have an accompanying project which is clean test migration um it's it's implemented in Python it's uh just started as a I thought it was a quick and easy way to get those migration scripts turned out it was actually quite some work and uh way more complicated than I anticipated so this these converters are not uh are not a compiler and therefore they are only a heuristic that um is tuned and works well in practice um on the bottom you see how that works for a sample boost test case translation unit and so what these migration tools do is they take your expectations they really build this expression tree and then decide which of the nodes need to be lifted in a way that on the one hand brings per this sort of perfect expression introspection and on the other hand um needs to require us to lift as few nodes as possible and yeah you can and then of course you need to in addition you need to switch out a bunch of micro calls um with the respective clean test construct and in that example it works flawlessly so I should point out that this macro switch is I currently only implemented for Boost because that was the most pressing concern for me at that time but of course it can be extended to other uh other Frameworks and you should not expect that this um these tools like work perfectly in all cases for instance macro based Frameworks differ significantly um to clean tests for obvious reasons and for instance it's um both testing Frameworks have different um allow for instance helper functions in different places and so it might be that the converted result needs some manual adaptations for it to make it compile but but still it it is should be extremely helpful to migrate away all the the tedious parts of this kind of refactoring if you want to be start using clean test yeah and with that um I want to come back to um two even higher level features of clean tests so the first one is uh concurrency so um maybe one step back so why is it that basically every unit testing framework that is out there is executing tests sequentially the probably the primary reason for that is um that it makes the correlation very easy that if you see some failure that you always know which test case just failed because I mean you just execute at most one so if any test case is supposed to fail it's that one that is different for clean test so clean test is executing multiple test cases at the same time and needs to need some explicit link of an ex failing potentially expect failing expectation to the corresponding test case and this is handled explicitly by a so-called Observer class so first takeaway should be that you don't need to worry about these observers if your test is single threaded and so you've all the test cases that I've shown so far were single thread and so you didn't need to bother to handle any observers and that works the reason why it's working is that when clean test starts to execute a test case it populates a thread local variable with the right Observer and this Observer is picked to get picked up again by expect by default so if you don't pass it explicitly expect this using the thread local one and but of course there are scenarios where this is not sufficient and then you can start to um yeah to to bring the observer in explicitly so on the right you see an example how that can look like um first the way to get the right Observer is by accepting and uh extra Observer reference argument in your test case 922 um notice that an observer is intentionally only forward declared so you cannot do anything with an observer other than pass it to other apis of clean test and then let's go through some examples line 23 is picking up the default Observer so that is fine in this sort of main thread line 24 is also okay that's how you bring the an explicit of Observer to an expectation and then but let's see how what happens if we do something in another thread so async is a function that just takes calls something in a different thread and waits for the result and so in that case line 26 we have to use the right Observer explicitly to expect something otherwise line 27 so this will produce a warning on the bottom notice that the warning will be printed regardless of the evaluation results so even if the result the expectation is met you still get the warning but of course you only get the warning for code that you are executing and so line 26 basically is a one possible fix for this case the other is that you can explicitly repopulate the thread local variable by a scoped object which is called Observation setup so that in line 30 we built this scoped object and as long as it is alive we can use expect as before so given depending on your circumstances um it might be beneficial to set this object up once and then have a bunch of expect calls after it and at that point I really want to emphasize that all this concurrent considerations really make sense um because expect in indeed is thread safe otherwise all that would not make any sense and so you can have multiple threads um executing the same expectations on the same line even and all of the possible failures will be recorded reliably and also reported correctly to the command line okay and uh this is the final feature that I want to touch on data-driven tests so I personally quite like data driven tests because I find that these are a very um convenient way of ensuring some invariants of my code by simply executing a function on different inputs okay a data driven test is a test case so that um operates on a bunch of value data samples and the way to get this sample is by accepting an additional parameter for this data sample so for instance line 23 the int constant n and you can test the data in two ways either you use an extra Constructor parameter in line 23. or you can also use the more fancy pipe notation in line 28 you pipe the data into a test you can either this correctly prolongs the lifetime of temporary data samples in case it is necessary [Music] um in case it's necessary and I should also emphasize that it does not only work for homogeneous data meaning data of the same type but only different values but it also works for data that is inhomogeneous so maybe a tuple of different types so you see an example for a vector in line 22 and also a tuple example in 27. um notice that of course for these um yeah you need to make sure how you work with references so this data is marked as static so it has its lifetime is sufficiently long otherwise that could be problematic because in 23 we invoke The Constructor on an L value reference and in case you really want to do that on temporary data then you should probably consider moving the data into the test Constructor and yeah on this is um how you set up these data driven tests and um on the right you see how this executes you see that some of the samples in some of the samples we pass and in some we fail and notice also that the test case name includes the printed data sample in case that is possible so otherwise we just use a counter okay um so that is um all the features that I intended to elaborate so let me wrap up so clean test I I presented clean test which is my modern versatile and yet very simple to use testing framework it supports short circuiting in expression introspection without requiring macros in addition it also brings a bunch of productivity features that you expect from a modern testing framework and it's built for a world where tests are both executed in parallel and also simultaneously fail um yeah this project is of course not never done so the my primary goal for the um let's say a couple of weeks next couple of weeks is um getting a 1.0 release which I'm I think I'm pretty close to I would like some uh to have some more documentation online um but everything that I um presented today um I think is pretty ironed out and and works reliably but of course I I have a a bunch of extensions in mind that um I might be implementing in the future if uh if users are are interested in and there yeah um you you can uh I provided references where you can read all the code that I presented today and of course um how you can reach out to me I value any any feedback be it even just a a star on GitHub and yeah with that um thanks for your attention and I think I have a couple of minutes left for questions [Applause] hey good talk good testing framework also good intentions um one question did you consider test matches so it's a different style of expressing your matches right now all the you print on the console is then zero is seven or it's not seven so it's obvious that it's failing but when you have more complex data types you have one site that is evaluated to a complex physics simulation or whatever and then the other side is your test data where you compare to it and depending on who writes the test the left side is the expected value or the right side is the expected value and it's quite inconvenient if you don't have one test failing but several and you are confused and have to look up each test what's going on there so if they have test matches and you have very clear expression in the code which side is evaluated and which side is your test data compared to okay I did not consider that [Music] um yeah so is is there more difference there is there what's the difference in addition to disambiguate maybe what's left and what's the meaning of the left and right hand side so we probably have some it's some function that asserts some condition then right the basically this expression system works well if you have equal comparison because then it's very clear what is not matching and what's not working on if you have like less than or greater than then it becomes not really that obvious and the test matchers basically say uh you don't want to limit yourself to a bull operators you just say for example I have a string and this string has to contain a substring yeah so and then that's the matter exactly okay and the old the other thing is that you can write a framework where the users can write new matches for their own data types okay okay okay yeah but um that is possible so I mean I did not um consider to write um let's call it bring more matches from for instance for this string example but of course you can users can could do that so you can have some function that the only thing that you have to do is comply with this evaluation API and it's pretty pretty much the same you can come with your own contains function that gets two strings maybe and then maybe the the input and the required substring that you want somewhere and uh yeah then you'll this returns an object but probably that only captures these values by reference and upon evaluation that's the real check and then prints um to the can you can also then of course control how that is printed to the command line and include whatever is suitable to your contact stuff of course that's that's possible but um I um so this is not like available currently by default yeah thank you very much I really like it that it doesn't take any macros this leads to immediate use in modules but my question is more about compile time testing how far does your testing framework go in the realm of um doing testing as much as possible at compile time I'm shifting as much as that I can in my code actually to do the testing at compile time so that it don't have to be done at runtime I've not seen very much about how much is a constable friendly how much is const expert yeah so can you please expand a little bit on that yeah sure so um I'd say that like most of this expression so I'm thinking hard to find places where I know that it's not available at compile time and I I don't see any currently so most of that stuff at least probably all of it is available at compile time but um so you could argue that um the the use is limited because of course you don't have this nice at compile time you cannot argue that you want nicer console output um so you just yeah okay but but so that is not available so I mean my primary primary um intention to make all that available at constant export time is to sort of justify that this overhead of building these expression keys and so so on is in some sense limited because in static asserts the compiler in the end sees through all of that correctly and um so that I got um of course if you use it it's just in a static assert then um you also get just get yeah this expectation is not met and you'll need to find out why um and um yeah if you want to have a better introspection um at compile time so yeah that's probably uh something what that would be very nice to have but um that's that would be a future extension for me I know uh one question Tech test fixtures so if you have a suite and you want to have comments that up until down code how do you implement that so test fixtures are tricky because um so at least I cannot see currently a way where you get that um without the in the in the let's say the the way you are currently used to with macro based Frameworks um and yeah so um I I don't see a way to conveniently write it and so currently it would mean that you're just in the first line construct your picture fixture that your tests need of course then you need to prefix every method that you're using that is provided by the fixture with the respective variable name but apart from that that's the con the most convenient way of getting the fixtures and that's also the way for instance the migration tools are converting fixtures of boost tests to clean test and then of course this will not compile so this is another example where the migration tools are not perfect and but what you need to do should be very obvious if you if you see end up in this situation but if you have an idea how to how to get it without Marcus then I'm of course uh happy to discuss details yeah okay yeah thank you [Applause]