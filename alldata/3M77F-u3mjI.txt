my name is andreas fertig i work as a independent trainer and consultant for c plus plus and occasionally i also give talks like today and today is very special because i'm also the creator of c plus plus insides and that's the topic of today c plus plus insights how stuff works c plus plus 20 and more because we now have c plus plus 20 i just read a tweet that um llvms lipstick ellip c plus plus now has full concept support so now we are really getting to full c plus plus 20 compiler and library very similar but before i start talking about c plus plus uh let me talk a little bit about my name more precise my last name my last name is fatigue um it's an adjective in german and you can translate it in english with finnish ready complete or completed being an adjective isn't that easy because an adjective in german is spelled with the lower first letter while my name is of course spelled with the capital first letter so i have a constant disagreement with my spell checker who is right or who isn't then this leads to trouble sometimes there is a vertex with a capital f where it shouldn't be and other times i write my own name as a small capital f so things like that happen um the name itself it's it's great i really like it one of my friends um long time very very long time back came up with the idea if what would be you if my last name would be trademarked and of course if i would be the owner of this trademark so i would get let's say one cent per mentioning of verdig and because it's a frequent word in german um i probably would be very rich and yeah would be a nice world at least for me and i can give away money and spend it on people who need it more than me but i'm not there um i even well had 30 years with my own name until i learned that i mispronounce it i say fatigue if i do not watch really carefully i say fatigue and turns out um this is more the dialect tongue speaking here because in proper german it's called fatigue sound at the end usually nobody complains everybody gets it but it's a little sad that such a typical german word which also is my last name i'm unable to pronounce correctly so that being said i'm also the same person who will now tell you some things about c plus which is not in my name so i hope i do better justice to c plus plus than to my own last name so what's c plus plus insides um c plus plus insides shows you what's going on with your c plus plus code so on the corner bottom the right half of the slide you can see a very small screenshot we will see live demos later so but essentially it's inspired by matt godwall's compilexpro you put in your source code on the left and you get out your source code on the right i still think it's a brilliant idea i'm worth millions of dollars of course getting c plus plus code from c plus plus code hey there is a market for that right the difference is the output is enriched with all the things the compiler does for us to make our code compile and we will see a couple of these examples so this helps you to make invisible things visible i like the language as it is so the implicit things which are there are usually very good to make it easier for me to write code because i have to write less code but of course sometimes even i wonder what's going on there and i found that c plus plus insights is a very nice resource to peek behind the scenes and either get reminded why things as they are or learn why they are working as they are doing the tool is free it's it's open source on github you cannot over there and clone your own version um you can compile a command line version so you can run it in your build process i don't know anyone who does this it's probably too much output anyway but you can run it on your command line you can also set up your own instance so you don't have to put your company source code in the public version of c plus plus insights what i am for is to create valid code my imagination is really wonderful so um having me make up code that is the transformation of uc plus plus code that's probably a thing that could be too much misleading so i cried try to create valid code and i do this by testing the result from the c plus plus insights transformation with either clang or gcc or recently even msvc and compile this again to see whether at least it compiles i could do a bit of a better job in even ensuring that result is the same but i'm not there yet and this compiling helps um for certain cases to catch bugs and so on so just a broad overview about the tool so let's let's dive a little bit into the moderation this here is an example this is well you can say even c code there's no not so much um c plus plus in it but let's say it's c plus plus code what's going on there so the quick question i usually ask the audience is what is the obvious output of the printf i mean let's work through it i have two variables in my function use a and b a set 1 b set to 6 500 530 000 so of course if we are asking with this max function which tries to figure out which of the two values is to create a one guess who wins b of course b is way greater than a correct well the next question would be how many implicit conversions are there so what's happening behind the scenes why is this thing working and this is where c plus plus insides comes in so ask yourself for a moment how many implicit conversions do you see how many are there so this c plus plus inside is live now as i said you put in your source code on the left and you get the transformation out on the right so if i transform this and it takes a while because my laptop is busy with screen sharing but at some point it should do it so all right this is what c plus plus insights shows you there are a couple of implicit conversions going on four to be correct in this view so we have one here which casts my b which is in fact an unsigned short to it short to be able to call max because max expects two shorts it's nice from the language that it does that for us but sometimes it would probably be better if it wouldn't compile because um it creates trouble so inside of max i do have two other costs they cast my a and b variables up to integers so they do an integer promotion why because the standard says that we can only compare integers or greater but not short or chars with each other well all right so far and then we get another implicit conversion from the result of max because max here returns a short but our printf function takes ins because they are put on the stack so four implicit costs and if i manage to run this example now in compile export then we will see that in fact in this case one is so much larger than 6500 530 at least if we manage to get bolt running here i didn't prepare this part but you can think about questions and you can think about what to resolve this darn all right simple the only thing i didn't prepare in advance and of course that one fails we'll see what else fails all right let's not spend too much time on that so the answer is that my print of call here will tell us that one in fact is greater than 6500 thousand 530 simply because all these implicit conversions because my unsigned short when it gets promoted to short or converted to a signed short to be precise then this number becomes a very small negative number which is then greater than one if you like to see what's totally going on here you can turn on this option show all implicit costs i usually have that one off for classes because it's simply too much traffic and that transformation happens then we can see way more costs so one is of course an integer it's not a short so there's an implicit conversion converting my integer too short and 6500 530 of course is once again an integer and not a short so it gets converted to an unsigned short so there are a couple of things happening to our source code which we know which we learned over the time or um which we are not aware of and c spot insights helps us um making these things visible the plus plus insights is a clang based tool it uses the very terrific ast of clang which makes things so much easier for me because parsing c plus plus is a total nightmare so it uses clang is ast so that way it's it's way more than a preprocessor okay it's it's not just such a simple reg x thing no it's it's it has a full um c plus plus parser front end um beneath it and it uses the output from that i used the official builds of clang usually the the latest version but i'm a little bit behind because i'm waiting for for the next um revision coming up from clang hopefully the next days or weeks so um it's not using current so you may notice that not all of the latest features are available especially if you're looking in the new c plus 20 stuff the reason for that is really simple i like to have a way to find bugs and issues and if you're reporting an issue for example with an unstable current release of clang then i may have a harder time tracking down what the real issue is and maybe it disappears because it was inside clang it was fixed then because it uses the clang asts if you're looking at it what a compiler does we can roughly separate it in the back end and in the front end so the front end parses your source code and creates the ast and then hands that to the back end and the back end this optimizations and the actual transformation to a binary so it produces some assembly or um even beneath the binary output the front-end does very little optimizations at least in the case of clangs as far as i know so it does some things like constant falling so if it comes across um three plus four then of course it sets in seven for that but all other optimizations they happen later in the back end so passing dash o something to c plus plus insights has absolutely no effect that's the reason why on the website you will not find such option because the optimizations the real optimizations they happen later and okay one side note not all statements are currently matched i recently stumbled over a recovery statement which clang injects if you forget to see me call on something like this but this probably not a statement you're looking for but if you find something that's that's currently unsupported feel free to tell me i tried to implement everything that's usually used but maybe i overlooked something there are a few limitations i like to mention at this point and one of them or the biggest one of them is templates creating code for templates that actually compiles and is in some definition at least correct is very hard and to make this a bit easier for me i decided to have this insights use template if death here and if i do this transformation and i should have opened this in highlights before so let's see i can make this time so let's start with this this is the sample from the slides and never do the transformation here and we are waiting a little bit it's the payment i have to do for this virtual thing so then we can see of course what c plus plus insights does here because my function func is instantiated with the demo type from the class demo then i get an instantiation for func with demo so looks like a specialization for this this is how the compiler stands out the specialization or instantiation to be precise for templates for us for this primary template func here so this is the result and if i take this and punch it into compiler explorer and be fair and enable my starting define here then we will see oh it doesn't compile anymore and what the compiler says is that demo isn't declared at this point so the code will compile once and move the definition of demo before blood specialization or instantiation and this is why i have this this define here to prevent a couple of compilation arrows because it's very hard to know where to place this specialization currently i took the easy approach and i always put it directly beneath the primary template i can do put it on beneath this demo class here in the simple case but in reality things are more complicated so this is where i'm stick right now and if you have a great idea for a patch then feel free um to tell me otherwise now you know why it is um if the template guard is here this just helps me to make it easier so i said clang ast c plus plus insights is ast based so what's an ast that's an ast and question would be what does this ast do and a fair answer would be i don't know because this ast is so much shortened i cannot tell you if i create this ast on my local machine then it generates a whole bunch of pages of output and at the very bottom line you see what it's really doing it's the most popular program it's a hello world program saying hello c plus plus here in the last line of the output so this is essentially the code behind it nothing more on my machine it creates approximately 190 000 lines of output this piece of code okay this is all the stuff the compiler does for us it includes headers it instantiates templates even if we are not directly using them and the ast itself may be a little bit bloated here because it carries a lot of information but this is the information the compiler has to maintain it at some point at least so there's a lot of work going on behind the scenes and at the top you see a few from c plus plus insides all i'm doing is taking this ast and converting it back to c plus plus code and in a lot of cases this is easy and in some it isn't this is another example um where i can use c plus plus insights so let's say i have this class template called cooled template it has two data members m size and m a data and it has two constructors one that takes a const t star data and a size t and the other one is once again templated method template or template constructor constructor template and it takes a reference to array of size n now below in line number 18 i instantiate the class or yeah initialize a class of type cool template jar and name it ct and then initialize it with buffer buffer is just a char array of size 5. which of the two constructors is picked line number seven on line number ten here answer is probably relatively easy depending on your knowledge about c plus plus and sides but all right on c plus plus but let's see what what c plus plus and sides can do here it's it's not a primary use of c plus plus insides i discover this um when i did work on something else so this is the code from the slides and if i do the transformation with remove this for later let's do this again so if i do the transformation then we can see two things so first of all we see here our primary template definition once again it's the same that we created and here below we see like with the function template before the instantiation of a class template okay or specialization depending on how you like to see it okay it's no big secret of course all t's are replaced with jar the important part is now the code here i create a cool template of type jar with buffer and the question was which of the two constructors is called and c plus plus insides in this easy case can give you the answer because it's the one that gets instantiated okay here this one has an instantiation it's the one taking a char array the other one the one here goes without an implementation in this class template instantiation if i add this other object of cool template jar here then we can see that now both constructors have an implementation or specialization implementation in this class template specialization so this is how you can figure out which constructor gets called if you can break down your your example enough then c plus plus insights can help you see through here i once had a case where we really did this with production code and it helped us figuring out um what's going wrong because we knew that something wrong but we didn't know what exactly and after um yeah getting it down and putting it into z plus plus insides we finally saw oh yeah that's um that's the wrong constructor being called here so it can be helpful in such cases when i started developing c plus plus insights i stumbled over things like this yeah it's a function here which has a default parameter and line number one into x equals 23. i think that's not necessarily new to you and then of course we can call it in line number five and simply saying funk parents and that's it but how does this work i never actually really cared because it worked so it's fair to say i don't care and c plus insights gives us the answer and that answer is pretty simple the compiler simply puts in 23 in every location where we call this function without passing a parameter so the function declaration at the top or the right that looks very much like we would write it without the default parameter so the default parameter simply gets removed from the function when the compiler parses it and only the value of the default parameter gets inserted in all the places where it needs to so sometimes things are really simple at least if you're not a compiler developer and have to care about this but you can simply use it and see how it's working let's switch to something else default member initializers in c plus 11 and later so you have this class here called init it has three data members in line seven to nine i we and s i gets initialized with zero v with two comma three and my stood string with hello all three are in class or default member initializers and then if you look at the default constructor and line number three to five then you can see that i gets initialized to nine there and now it's an end um but so it doesn't really matter but sometimes in my classes i get a question do we now have two initializations so how is this default member initializer or in-class member initializer working because if it's not an end if it's something more expensive like this like the stood string or missed a vector which gets gets initialized two times then this feature may not be what i'm looking for because it's simply too expensive and here once again c plus plus insides and help ut see through um what's happening here is basically syntactic sugar from the compiler as before with the default parameter the in-class member initializers as we see them in line number 10 to 12. the compiler just takes them out so these members are like regular members before c plus plus 11 and it puts their values in all the places where we need them in our constructors where they need to be initialized so we see this on the right in line number 9 to 11 i have my variable i my variable v and s and if you're looking at them then we first see i is initialized to 9 only once there is no zero it's simply the nine because if we are specifying a value in the constructor that one wins over the one as the default initializer then my vector v here it gets initialized with two three and four exactly what we asked for and my slide string of course gets initialized with hello sorry for all the noise you're seeing here this is what's behind the stood string but that's not part of the talk today so this is syntactic sugar we are looking at so the compiler simply moves things around for us and after that movement things look like they did in c plus 98 and once i add a second constructor here let's say i have one that takes an end and i simply do nothing and i do the transformation then of course i get the benefit of the in-class member initializers and this constructor uses the default values that i provided for all the members below so this one now here has the i equals 0 because i didn't specify an override for i here and all the others have the same so the value we are getting out of this is we have no uninitialized data members anymore because they get initialized we may not be happy with the value well that's a different question um but it's the value we said it's the default what can c plus plus insides show you other it can help you with the following do you know or do you remember what constructs were meant in c plus 11 for a member function assume you have the code like presented here i have a struct i call it cpp11 and it has one member function with the name with the name fun it simply returns true here because i don't want to put any logic in here it returns bool and it's a constant experiment of course of course so is there anything special is there anything going on that we may not expect this is the transformation of c plus plus insides and if you look at it close enough then you will see that there is a const there there's an inline keyword here as well because constexpr methods are implicitly inline but it's const this is very interesting because this member function here is not marked as const but it gets marked as const once we add constexpr to it and the compiler in this case clang here already gives me an answer to that it tells me that in c plus 11 all non-static contextual functions are implicitly marked const but once i switch to standard say to c plus plus 14 that goes away and this is a breaking change because in c plus plus 11 they're very implicitly constant experiment in c plus plus 14 they are not and the reason for this is very simple because you may like to have different functions which do very rubbish things here but now we can provide a const overload for my member function in c plus plus 11 this wasn't possible so this was why this breaking change was applied despite it was breaking let's talk a little bit about lambdas now shall we more specific captures of lambdas assume i have this class test here and it has an end member in line number two called a i'm very easy with the names today and then there is a constructor taking one argument once again an integer named x and here in line number five a gets initialized with x and then in line number seven in the body of the constructor i create a lambda l one and this gives me the result of a plus two so whatever a got the initializer is add two to it and give it back to me and this is initialized or the lambda is capturing by copy now in line number nine i use a printf and i invoke the lambda to print out its value and then because i can in line number 11 i increment a by one and just because i'm curious i'm printing out the result of l1 once again so all l1 does is it adds 2 to a but it's capturing by copy and line number 7 so way before i increment it once again and the question is what's the output of this program 3 two one the output is four and five so it was called in line number nineteen initially risk two so test was constructed with the value 2. so of course 2 plus 2 is 4. everybody knows that so my lambda should return 4 in all cases but it doesn't after i incremented a i see the effect now it's no longer four it's five but i copied a into the laminar correct so that's at least what the syntax says but that's not true what i'm doing here is i'm capturing this pointer and this is where c plus plus insides comes in but this is the code from the slide here i'm capturing by copy my lambda i'm adding 2 plus a and here's the transformation so first of all this is our lambda okay a lambda internally is modeled as a struct or class the name here is something i have to make up because the compiler doesn't have a name another name for lambdas is anonymous function so they don't have name and the class type is made up by the compiler so the compiler doesn't need to border about giving it a name but for my goal to make compiling code i have to do this now what's special here a lambda has a call operator this once again is something we can write ourselves and in this collaborator we find the contents of our lambda so this is our return a plus 2 here with one exception here is such a dash dash or underline on the line this and this comes from here and the reason is that because i use this inside of a class my lambda and i say that it should copy all the captures i in fact copied this pointer i'm capturing the this pointer of my class test here so this is why my lambda has a data member test pointer and i have to name it somehow so this name is also made up by myself and not by the compiler so this is a reference to the disc or yeah it's pointing to this pointer of test and other than that my lambda of course has a constructor which is technically not totally correct because the compiler can play nice tricks here and saves us the constructor in reality so this is what's happening here if i capture by copy and this often not what we really want despite that we want to capture by copy so what we can do is we can change it we can say that we capture stardis this is a c 17 feature and the start is you can read is that we like to capture a d referenced version of this so practically we like to copy the contents of this and if you're looking at this then we can see that the compiler now captures or passes stardust to the constructor of our lambda and the lambda internally no longer stores a pointer but now it stores this object or test object and the rest is the same but that way if we are going back to the slides because i prepared the output there that way our result now is 2 times 4 because incrementing a in line number 11 has no longer an effect on that because i'm no longer capturing this pointer as a pointer i'm now capturing the object itself this helps you around this issue which you may come across but what does this mean for the size of your lambda so i worked for a long time in embedded and i did care and still do care about the resulting size or the size of an object in my code because the either ram or rom was very limited so say i have a variation of my class test it's still there like before it starts with one data member and a but it now has another data member in b and my constructor is still the same takes an integer and i got rid of all the printfs here i'm simply capturing in the body of the constructor a lambda calling it l2 and it captures starters and it does the same as before it returns a plus two so obviously all i want or all i'm interested in in this lander is a if i now look at this in c plus plus insides then we see what we saw before this is the transformation of my start is and here i'm still capturing the whole class by copy the object by copy this is what i asked for here but before it captured only a or it copied a because the class only had one data member a but now it has two so in other speak the memory consumption doubled okay it's just an integer but it doubled this is not really what you want to do in a lot of places here in your code if you're capturing and only interested in one variable because you you're the thing you're capturing may be bigger so the class because it may have some string in it some vector which allocates a lot of memory so the thing you can do in um plus now is you can use init captures they come in i guess with 3 plus plus 14. and the center axis is interesting i can hear this point say a equals a and by that what the lambda captures now is a variable named a and because this is not really good to know what's going on i rename this to b which you can do as well oh no i have b above so let's name the c a clear indication what's going on so here once again we see the body of the call operator and that one now says c plus 2 because the same i've written here this is my init capture here and now we can see that the data member of my lambda is named c and it gets initialized with an integer with this a so with a from the class test and that way you can reduce or control the consumption the memory consumption of your lambda by being specific if you are inside a class then be aware that it captures this pointer by default but you can restrict it and say that you want to have only this single data member or other data members as well captured as opposed to capturing it either as a pointer which is often not a good or kept capturing the entire class which comes with other drawbacks because you now increase your memory consumption so lambda is an interesting thing with c plus plus 14 they get improved got improved a little bit we got generic lambdas there this is the autosynthetics you're seeing here and what i'm doing here is i have a lambda which then gets assigned to a variable named max so inside of this lambda i'm trying to figure out which of the two parameters is greater than the other so x or epsilon and that one is returned there is a stood max function in your standard library and you should refer to that i'm just trying to trying to make a point here and um not saying that you should implement it yourself so this is with generic lambda this is great because it gives me the flexibility to say okay this is what this thing does and i am open to use it with any type this allows me in line number seven for example to call max with 2 comma 3. this is great it also allows me to call in line number 8 max with 2 comma 3.0 oh for me this is not so great this is not what i want because remember from the beginning implicit conversions i'm mixing types here that sync compiles but what does it return is it the right type it returns and even if it is how many conversions do i get in between and is there a loss of precision somewhere so this is nothing i want to compile and let's peek behind the scenes what's going on here first but this is the transformation of my code we once again see here this is my lambda this is the call operator of the lambda but this time we are looking at a method template okay it's it's no longer a simple call operator it's a method template the compiler creates a method template out of this for us and it gives it two class or type parameters which you can see the name also comes from the compiler so it's just generated because we cannot name the type here we said it's auto these are my two parameters x and epsilon and this the body and now here we can see this method operator gets instantiated once with two integers and the second one below here with an in a double because this is the second case that i don't want and now we can see here oh yeah there's a static cast so we are promoting everything to double and then we're returning a double well maybe this is what you want it's certainly not what i want not automatically at least this is the implicit conversion i don't like so what can we do at least if we agree that this shouldn't compile you may disagree with that that's fine there are cases where it's okay if it works this is c plus plus 20. in c plus plus 20 we got another improvement of templates oh sorry flanders called lambdas with the template head of templated lambdas and you can see it in line number three on the slide what they bring us is the angled brackets after the capture list before the parameter list of the lambda we can in ankle brackets now write our type name or our non-time non-type template parameters there so between these anchor brackets we can do the regular things we can do for functions or function templates to be precise sorry so and if you look at this in c plus plus insights then we can see oh there's no real difference here our call operator is still a method template the only difference is that this time we named this parameter and we said it's a type name so type name t and that allowed us to refer to this t for x and for epsilon and that way both parameters now need to have the same type and because there are no implicit conversions when it comes to templates in this case this code piece will now no longer compile so clank tells me there is no candidate because it has conflicts when deducing the types for t into versus double so this case no longer compiles which is exactly what i want this is great because members with a template head allow me the flexibility here to still say i'm open to any type but please make a and x and epsilon be of the same type this is the key here and this is what lambdas with the template had give us in c plus plus 20. what else do we have well range base 4 statements this is an example where range base for statement does something different than you like it to do we have a struct keeper here and it stores or it contains a data member called data it's a stood vector of int and initialized with 2 3 and 4. and then there is some kind of access function called items which returns a reference to this data member i try to keep it on a slide so in usual code assume that the data would be private and all the items would be accessible so far that's okay then i have a function called get which returns a keyboard object and because the slide code this simply returns a new object of keeper that's also right and then below in main in line number 14 i have a range base for loop now and what the intention of this rainbow range base for loop at least is is it creates a new variable auto it's a reference called item and this should get initialized for every item in my keeper object and then i print it out so i have here column get dot items so i first create a keeper object with get and then on that i call items to get a reference to the stored vector and then i can iterate over all the elements and i see them you see out to print them out if you look at what's happening there in c plus plus and sides we can see the following so you once again see a little bit of the standard library going on here this is the gcc yeah that's the gc implementation so lit lip stood c plus plus this iterator pair here so but we have this range base followed here let's start there a range base for loop boils down to regular for loop now the compiler creates a new scope for us it opens a scope and it creates three variables range begin and end compiler here in this case clang and gave it a postfix of one here that doesn't matter and then range gets initialized with the result of get.items and this is stood vector so it's the same type but this is a reference okay and it's not a const reference that's the problem here because get returns as a temporary object because it returns object at this point it's a temporary object and then we are calling dot items on this temporary object which would be fine but now we are binding this result to a non-const reference and by that the result here doesn't get lifetime extension that means range is now used to call range begin and range end on it so the begin in the end of the vector and then inside of the for loop here this is the the internals of the range base for loop now it's a regular for loop here i have an operator equals that compares with a beginner and r equal and here i have a call to operator plus plus to increment the iterator after each loop iteration and now here i'm creating my requested variable item which is a reference and here you can see the call to begin dot operator star to the referee reference the iterator and then it's printed out but after this line here my temporary is gone and once we hit the semicolon the temporary gets destroyed so everything we do with that range one after it that's just undefined behavior you may be lucky and it works i'm not sure if it's really luck then um because it shouldn't work but because it's still on the stack sometimes it may work what's up i'm not considering this luck but it may help you chasing that bug is really not fun what can we do we can use c plus plus 20. the code is roughly the same except if you're looking at the for loop a range-based volume in c plus plus 20 we have range base 4 statements with initializers this allowing us to write the same as for regular for loop we can provide an initializer and after that have our usual iteration statement so here on line number 14 you see the initializer there i say i create a new variable called items and i initialize it with the result of get and now in line number 15 i'm iterating over the res result of items dot items poorly chosen name i admit that but now i don't have a temporary no longer because um items in line number 14. that now is the thing that captures it correctly and if i do the transformation here then we can see the secrets behind this action it's also not quite surprising or um not so difficult it's just once again syntactic sugar c plus plus in size just takes a moment sorry my request failed what's that so i hope you write down all your questions because at least i give you the time for that it's wrong now but now come on yes all right what this does is inside this scope the compiler crates for us for a range base for loop it simply puts the variable declaration we are requesting in front of that as the first line and after that the same thing as before continues we have our range variable which now calls items.items unless they add little i'm not sure if trick is the right word for it but with that approach you avoid iterating over and no longer existing temporary and by that using ub now nicola yositis tries to fix this in a much better way by extending the lifetime of this statement without having to to play the tricks with the in with the initializer here that would be nice maybe we are getting this for 23 but so far watch out for this this can cause some real real nasty problems and of course what you can also do is it's not a use case um you can now declare just a primary use case variable it's on a very narrow scope in a range based for loop so if we need a variable in the range base for loop only there like here with my index variable then we can declare it now in the initializer part of a range-based follow so it's not necessarily just to avoid this temporary situation we can also make use of it for otherwise working code by narrowing the scope down which is also beneficial well you're talking about c plus plus 20. we have spaceships in c plus plus 20 now you probably heard of that we have the spaceship with a three-way comparison operator and the promise of this operator is we have to write our comparisons only once so only one comparison function in the name of operator spaceship and the compiler gonna generates all the other methods for us and that's really great you have an example here below how does this look i have a struct spaceship which has a single data member x and it has there in line number four and five the spaceship operator and zipposwist20 is really great i can say here is to tweak ordering which is a new type from the compare header which is also new but i could also say auto and then i can default this spaceship operator okay i don't have necessarily to provide the implementation of this operator it's like a default constructor which we can default since c plus 14. and in line number 10 and 11 i'm creating two spaceships the enterprise and the millennium falcon because i couldn't decide which one is the better one i assigned two to both of them and then in line number 13 i'm comparing whether enterprise is less or equal to millennium falcon okay this line 13 requires a tremendous amount of code pre ec plus plus 20. so let's look um what's happening here so above we can see a couple of other things so i haven't declared this operator const expert but a compiler chose to do it because it sees that it can't be so this is another effect we are getting here from the spaceship operator if you default it the compiler marks it constexpr and for all those who care it marks it also no except so these are things c plus insights shows you we see also second operator which we didn't type or request this operator equals so if the class is as simple as this if we are requesting the spaceship operator you also get the equality operator now below here in line number 16 we see the comparison and now we can see that the compiler invokes operator less than or equal on the result of enterprise dot operator spaceship millennium falcon so it calls the spaceship operator of my enterprise class a pair object that passes in the millianam falcon and now it uses operator less than or equal to compare the result from here to run from the standard library so it's a special type from the standard library which we shouldn't care about and the value here as far as i know is implementation specific maybe that's why it's named unspec zero here but this is how it works the compiler uses the global less than or equal operator and compares the result of spaceship to a known value because spaceship practically depending on how you're seeing it returns 1 0 and -1 so we implemented something like this in the past this is spaceship this is what people often talk about when it comes to the spaceship operator there's more before we got the equality operator for free what if we simply provide it we can do this we can then provide our own implementation which does the same thing as the compiler would have done and in line number 13 instead of comparing for greater than or equal i'm now comparing for equality is my enterprise equal to two and those of you who dealt a lot with comparisons in the past before c plus plus 20 may know how much code it means to make this work because this version is typically the easy one you can refer to this operator in the class but if we flip or switch the two variables if we say two equals enterprise then we are in friends land typically then we declare friend operator taking two taking two parameters a spaceship and an end and the same operator once again the other way around which takes it into the spaceship to make both versions work that's what we talk about when we say consistent comparisons because we like to be able to flip sides and the comparisons should still work so what does this work and this is an interesting additional feature um we get in c plus plus 20. notice that i provided only the usually simple case the member function operator and in this case of course the compiler says it calls operator equals with two on my enterprise object now if i flip this around what's happening there this is the interesting question now watch out carefully for the difference um we are taking a bit of time here well the transformation is done do you see a difference i guess not because there is none the statement is the same and this is due to a new ability of the compiler in c plus 20 called operator rewrites the compiler is able to switch the operands for us so we do no longer have to provide two equality operators here of friend version because the compiler is able to transform the statement behalf on the left into the one of the right because it looks up finds this one equality operator and then in its lookup table it finds out this is one way to go and it's the only one so it simply flips the arguments and make this code work this spares a tremendous amount of code if you're writing classes with comparison operators so what can c plus plus insights do for you and the answer is i don't know but i can share my experience with you you've seen the tool in action maybe you knew it before so the most valuable thing and i was inspired by it by matt compiler explorer by that is see making things visible um this is so valuable so things you may know in c plus but you just don't expect to be there or you are not aware of and in some moment c plus plus insights can help you see them again and make you aware that they are happening there this is very very helpful in several classes i taught using c plus plus insights as well as matt what calls compile explorer of course they tend to be way more interactive than classes i told before i use c plus plus insights attendees tend to start asking product questions about the features so they're really trying to to apply it and to work with it and applying certain other constructs so you didn't start wondering how this this works and how this turns out it's not always usually um down to the to the last bite or to the last nanosecond something will end up it's the decomposition um and how things work in general and and to apply them so i think they they tend to to learn more or at least they get a really good understanding of what they just learned and we saw it with the c plus plus 11 example c plus plus insights can help you to see the little differences and sometimes it can help you to settle different opinions by visualizing what the compiler does it's only clang you know there's no gcc version of it so you can only see what clang does or would do and you may still disagree and say that's not standard conform but it helped in a couple of occasions to say okay this is what the compiler does um here you can see it where once again it is seeing and like our ides um whatever they may be i showed you that c plus plus insights can visualize template instantiations and seeing them once again often helps but i showed you the example the absence of something that can also be valuable if you know that only this constructor gets instantiated or this method template but not the other one or you see a bizarre for your expectations at least a combination of types instead there is a certain function template then this made a clue to why is the code not doing what i expected to do or what i wanted to do so these are my insights of what c plus plus insights can do for you feel free to share yours if you already have some so the project you can support it new features fixes even in the documentation are very welcome you can head over to github and download or clone the repo there and try to send me a pr of the latest coolest feature if you have a little bit of money to spare then you can support me on patreon like you also can support meeting c plus plus there and if you like to get something you can bear back for your money then you can try the spreadshirt jump off c plus plus insights and it's always of course all the time okay to simply send me an email and say thank you i still get these occasionally and at this point i like to thank all the people who write me these letters or emails i appreciate the time you take and i will keep up with the project and bring it forward and at this point um i told you about my name in the beginning do you remember this i recently had for a training advertisement come up with a with a short url and my whole name andreas fertig.info which is my regular domain name that's awfully long especially if you have to put your also awfully long class name behind it your advertising so i came up with a new domain for things like that and now we can use fatigue dot to subscribe isn't that cool to subscribe to my newsletter ready to subscribe ready was already picked and it's not my name so frederick frederick.to subscribe you cannot over there subscribe for newsletter get a concept cheat sheet and stay in touch with my latest news which i will share with you more about the domain so at this point um all i have to say is i'm looking forward to your questions and i hope you had fun i am vertic thank you