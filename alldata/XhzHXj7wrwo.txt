Hello and welcome. I'm James Murphy. In this video, we're tackling a hard interview question: The Infamous Skyline Problem. I'll explain my C++ solution which beat 98.24% of other submissions in speed and 100% in memory. In case you've never looked at a beautiful city view and thought: I wonder what mathematical function describes this skyline. Don't worry. The more practical view of the problem is finding the pointwise max of a bunch of piecewise functions. But thinking about it like buildings is just easier to visualize. We're given a bunch of buildings represented by their left, right and height. And we're supposed to produce the skyline formed by those buildings which are represented by x, y points. That description is a bit dense. So, let's look at it visually. First, we have the buildings defined by their left and right x coordinates and their height. Their outline together with the implicit ground at height zero forms a skyline. Because the buildings are perfectly level and two-dimensional, the skyline itself is piecewise rectangular described by its corners. Since the rectangles are perfectly level, we don't need all the corners to describe the skyline. Since whenever there is a change in height, the x-coordinate doesn't change. That means, we can fully specify the skyline using just the points where the height changed which is what the problem statement for this problem expects. So, we take in the buildings as a list of left, right, height coordinates And we output the skyline defined by those points where the height changes Okay, let's get to the code. The first thing I want to point out is this horrible decision that leetcode has made. According to leetcode, buildings and points are represented by standard vectors of ints. Even though both of these things have fixed sizes where structs like these or at the very least arrays would be the fastest choice we're forced to use a vector. I'll use these using declarations for now. But at the end, I'll show you how we can go way faster if we just use fixed size types. I'll start off defining these getters for the building and point attributes. Don't risk using the wrong index by accident. These are all going to be optimized away anyway. Again, if buildings and points were just structs, we wouldn't need any of these functions. Okay, let's get to computing the actual skyline. First, let's make a vector of points to hold the skyline to return. We're going to reserve two times as many points as there are buildings because a building can contribute at most two points to the skyline. The algorithm I'm going to describe is a single pass algorithm which means that we're just going to look at each building once. And by the end of it, we'll have the entire skyline. The idea is as follows. We loop through the buildings one by one. When we read in a building, the goal of that iteration is to compute all the points of the skyline up to and including the left endpoint of the current building. As you can see in the animation, sometimes that means adding a point at the current building. Sometimes it means filling in points from right edges of previous buildings. And sometimes no new points are added. First, let's focus on how do we tell if we need to add a point for the current building's left endpoint. Well, we only add a new point to the skyline if the tallest building so far changes. So, in particular, we need to be keeping track of what's the tallest building so far.  We'll use a priority queue that compares buildings by their heights in order to keep track of which building is the tallest that we haven't accounted for yet. Here's how you define a custom compare function. And here's the priority queue that we're using. We're just using a standard vector as the underlying container for the queue. We're also doing a little trick here in order to reserve space for the priority queue. We create the vector that we want to use as the underlying storage for the priority queue   and reserve the number of elements that we want. In this case, we reserve enough space for the total number of buildings. Since, at most, all of the buildings can be active. One of the constructors of the priority queue then allows you to steal that data.   We chose a priority queue because we want constant time lookup of the tallest thing. And it only costs us logn time to insert and remove. Okay, back to the loop. Whenever we see a new building, we go ahead and push it on to our active list. Then we go ahead and try to update the skyline with the current x value and whatever the new tallest height is. Getting the maximum height is pretty straightforward. Just look at the top thing on the priority queue or 0 if the queue is empty. Here's where we're using that the skyline is zero in the absence of any buildings. Updating the skyline just involves pushing the x, y coordinate onto the back of the vector. Of course, we only add a point to the skyline if it changes the height. So, if we try to push something that has the same height as whatever is on the back of the skyline already, we just do nothing. If all the buildings had unique left endpoints, then this would actually be fine. But it is possible that the two buildings both have the same left endpoint. If multiple buildings all have the same left endpoint, I'm still going to add just one point to the skyline. For that reason, I just push all of the buildings that have the same left endpoint in the same iteration of the loop. So, this works for finding the skyline points that are left endpoints at the beginning of buildings. But what about ones that are defined by the right endpoints of buildings? When we go to the next iteration of the loop, it's possible that we missed many right endpoints. Whenever our current x exceeds the right endpoint of the tallest building, that means that the tallest building is about to drop off. And that's a candidate for when we need to add a new skyline point. The logic for this one is a little bit complicated. So, let's put it in its own function. So, here's the function. The purpose of this function is to handle the case when the tallest active building is about to drop off. I know it's just a few lines. But there's a lot of thought that goes into making sure that they do the correct thing. The idea is simple. Just pop off whatever the tallest thing is and then try to add a new skyline point at whatever the new tallest thing is. The subtle issue here is that, for speed, we don't want to go through the entire priority queue and get rid of all of the things that should be deactivated. That means that whenever we pop something off the queue, the next tallest thing might be something that should have been removed a long time ago. We keep popping things off the top until we see something whose right endpoint is strictly further than the tallest building that we started with. Any tallest building whose right endpoint is left of our original tallest building's right endpoint, cannot be part of the skyline. It was either a shorter building that had the same right endpoint or it was something that should have been removed from a previous iteration that we didn't remove in order to avoid traversing the entire priority queue. That's why we're removing a bunch of things but only update the skyline once. That also explains the name of the function. We keep popping off the tallest thing until the right endpoint that we find is past the current tallest right endpoint. Returning back to the main loop. We keep popping off the tallest building and stale buildings updating the skyline until we find that the tallest thing remaining has a right endpoint further than our current x or until nothing active is left. This takes care of everything up until the end. But there's a little bit more work to do after we get to the end of the buildings. We basically just pretend that there's a building at infinity. And then pop off all of the remaining active buildings. Then of course don't forget to return the skyline. I wrote a bunch of tests. And I'm timing both how long it takes in total. And how long it takes just to run the actual get skyline function. Running it a bunch of times, we see that it passes all of my tests and does decent in terms of timing. But I think we can do better than that. I looked back at the code and once we put something into the active queue, we never actually use anything except for its height and its right endpoint. We never use the left endpoint. Additionally, since this active queue is something that's internal to our algorithm, we can choose a better data type than a vector. Here, we define a fixed size struct that's just the right and the height of the building.   And we give it an explicit constructor to convert a building into just the right and height. Then we change our compare function and our priority queue to take in these fixed size structures instead of vectors. This allows us to get rid of two of our getters. Then everywhere that we used getRight or getHeight, we change to dot write or dot height. Also, instead of pushing building objects onto our active queue, we're now pushing these fixed size structs onto the active queue. Making this change took the total test time about 5 milliseconds down both in the total test time and time spent in the getSkyline function. Okay, remember the comment that I made at the beginning where I said that using a vector events here was a mistake? Watch what happens just by switching to fixed size arrays. Making no other changes, our times are now down to 6 milliseconds and 1 millisecond. We went from 40 and 15 down to about 6 and 1 doing nothing but changing to fixed size arrays. And this I think is one of the biggest problems with leetcode. This was supposed to be a competition for how fast you can make this algorithm go. But by telling you that a building and a point are supposed to be vectors of ints, they've already slowed your program down by a factor of 5. This just goes to show that designing a good interface and choosing your problem statement as carefully and as correctly as possible can really make a difference. If you do something, like, choose an inappropriate type for your function or return type, you can end up really slowing down the execution of your function. and then you also end up slowing down other things that now have to pass data around, reformat data into vectors in order to call the function. Anyway, I hope you enjoyed this solution. If you did, don't forget to subscribe. As always, thank you to my patrons and donors. I really appreciate your support. If you especially like the video, please consider becoming a patron. Thanks and see you next time.