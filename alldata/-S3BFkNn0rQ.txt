as software developers we like to automate things at least I do because I'm pretty lazy writing software tests is a lot of work so in this video I'm going to cover a technique called Model based testing or stateful testing that you might like if you're just as lazy as I am though model-based testing or stateful testing is not suitable for all your projects if you can use it it's extremely powerful this video by the way is a collaboration with Zach Hatfield dots who is the main developer of the hypothesis package that's really useful for testing so really enjoyed working with Zach on this video and I hope you'll enjoy the example as well writing test actually really helps you understand how your code Works in a variety of situations if you want to become better at judging your own code as well as someone else's code I have a free workshop for you on code diagnosis you can get access to the workshop by going to ion.com diagnosis it contains lots of practical tips of how to do code reviews quickly but still being very effective and I also look at a few existing libraries and review the code of those libraries you probably used in those libraries right now in your own code base so iron.codes slash diagnosis to get access for free the link is also in description of this video now let's dive into the example here's the example that I'm going to use today it's a line item class a line item as a description a price and a quantity and as a total property that multiplies the two and we have an order class which has a customer which has a string there's a bunch of line items in a list default that's empty and there's a couple of convenience methods like adding a line item removing a line item or updating the quantity of a line item and then it keeps track of a cached value to compute the total price of the order and it updates that whenever you take so action so when you add one it's going to add the total of that line item to the cache if you remove it it's going to remove from the cache and when you update the quantity it first subtracts the total updates the quantity and then adds the total again now this update line out quantity in terms of design is maybe not entirely how you would want to set it up because that's probably something you'd want to do in the line item itself and not in the order but for the example I just wanted to keep things simple so I'm doing it like this and it introduces some complexity which is useful for writing tests so how do you write tests for this well you probably have to start thinking about all the different cases so we're going to create an order add some line items updates on quantities remove line items again Etc here I have an example of let's say a starting point of doing that so I'm using buy test here I have a test order function that creates an order adds a couple of line items and then I'm going to assert that the total is 44. I have another one where I'm simply test testing the line item itself I'm testing removing a line item and I'm testing updating the quantity and now when I run by test it's going to run this test for me and all of these tests pass now the problem is that there's actually lots of different cases here that we have to think about in this case we just checked adding a couple of line items removing them and updating quantity but we probably want to do all sorts of combinations of those things like first adding then removing another one updating the quantity checking that all the totals still match up so that's quite a few cases to think about and ideally we don't want to do all of that manual test writing work so this is where model based testing also called stateful testing comes in it's a testing mechanism that relies on models to design and potentially also run software tests you can approach this really formally it's not what I'm going to do today I'm just going to show you a practical application of this so how does model based testing fit in and how does it compare to other types of tests well let's start with the most basic form of testing which is writing a unit test what the unit test does is that you define some fixed set of data fixer of values then you run an exact sequence of actions and you check whether the outcome matches what you expect this is exactly what we're doing in this test order file so for example I have here test line item I have some data that I predefined like a line item here with a price of one and the quantity of two and I just checked that the total equals two that's a very simple unit test so we test one input with an exact sequence of actions if you use a hypothesis you can take this a step further by introducing property-based testing and that means that you're going to test a whole range of automatically generated inputs According to some constraints and also test that exact sequence of actions for example here I have an example of that same line item test but I'm generating two integer values using the integers strategy from hypothesis I'm creating the line item with that generated price and quantity and then I'm asserting that the total equals the price times the quantity and then when I run Pi test that's also going to run that property based test it's simply going to check the property that the total always is the price times the quantity this is a pretty trivial example but it shows the key difference between unit tests one input fixed sequence of actions and property based tests many inputs and still one sequence fixed sequence of actions model based testing allow you to test many inputs like property based test but also many different sequences of actions and this is especially useful if you have many different actions that can be combined in various ways this is exactly the issue we have with the order adding removing line items updating quantities all kinds of different combinations that we want to test and this is exactly where model based testing can really help if use hypothesis what happens with model based testing is that you let hypothesis choose which method to call next and that's all built in so how does does actually work well you start by listing all the possible actions for example creating a line item adding a line item to an order removing a line item from an order updating the quantity of a line item and other actions that you might want to add to the system as well next to all these different actions you should add sanity checks that validate that some property holds true for example you could compute from time to time that the total of the order still is the same as the total of all of the line items what you then do is that you put all those actions and Sanity checks into a class the actions are called rules and the sanity checks are called invariance when you run a model based test hypothesis is going to repeatedly choose an action to run and then execute that method and then it's going to run all the sanity checks methods and check that those invariants are still valid so together these rules and invariants for form a state machine next to these rules and invariants you can also Define preconditions that must hold before the rule can actually be applied for example you can only add a line item to an order after it has been created or under the precondition that the order is empty there are no line items in it we can verify that the total is zero by the way if you're enjoying this video so far give the like it helps others on YouTube find this content as well so let's start by writing a couple of model based tests I've already done some Preparatory work here so I've added a couple of imports that we're going to need and I've created a simple classical order test that inherits from the rule-based state machine so this is going to be the state machine that the model based testing is going to use and then finally I'm getting the test case out of the order test class so that I can then use it with pi test so the first thing that I'm going to do is we're going to create some objects that we're going to need in our test one thing that we're going to need is an order that we can test so I'm going to store that as an instance variable so this is an order and it's an order for John Doe we all know him right and then we have the line items and initially that's just the empty list so I'm going to leave it like this and then what we also need is we need to keep track of line items that we're creating so I'm going to add here another variable called line items and this is a list of line items like so and initially that's going to be the empty list so that's our starting point and now we can start adding the actions to our rule-based state machine so one action is create line item and this is going to create a line item and store it in the self dot line items list and what is that going to need well it will need a description which is a string it's going to need a price integer and it's going to need a quantity which is also an integer and this is not going to return anything because we simply store it in the list like so so the only thing that this does is self-top line items dot append and then we create a new line item with the description the price and the quantity so at the moment this is just a method in a class we need to indicate a hypothesis that this is actually a rule that it can apply so for that we use the rule decorator and we simply provide it with the strategies of how to create the description price and quantity inputs in order to apply this rule so description that's going to be a text strategy so this is just going to Generate random text for us we have price which is going to be an integer and we have quantity which is also going to be an integer and hypothesis has many of these different data generating strategies you can also do all kinds of combinations of those it's a very powerful so this is a very simple rule to create a line item next we can create a rule that adds a line item to an order and what we need to do now is draw a line item from this list of line items that we have here and the way that we do that is by a rule that gets a data strategy and then here the parameter is also a data this is a search strategy this also doesn't return anything like so and now we can use the data strategy to draw an item so I have my line item and I do data dot draw and then I'm going to use sampled from strategy that's going to get self Dot line items so this is our line item and then we can add it to the order so there we go so now we have two rules one to create line items and one to add line items to the order let's also add a sanity check that's another Rule and the sanity check is that let's call that total agrees also doesn't return anything and here we're going to assert that the sum of line item total four each line item in self.order dot line items is the same as self. order Dot total which is the total price property so there we go when we're on this you'll see we're going to get an error you see hypothesis here tries to sample from a length 0 sequence and how does that happen well it initializes the state machine but then immediately it tries to add a line item to an order so we forgot something which is that this one add line item to order actually needs a precondition which is that we can only add line items into an order if we created line items before so for that we can use a precondition decorator and that gets a function so we can use Lambda for that and it's going to get self the object and the precondition is that the length of self dots line items is larger than zero so it has to create a line atom before it can add one to the order let's try this again now we get another error and that's actually a problem in that I should have done here and add line item call let's try this one more time there we see now the stateful test pass so let's now build out this test Suite A bit we've added line items to the order let's also create a rule for removing line items from the order remove line item from order also here we're going to need the data strategy to draw a line item from the order class it also returns none then I'm going to copy this line but we're not going to sample from self.line item we're going to sample from self.order don't mind nothing because we want to remove a line item and that's already in the order so this is our line item and then we're going to do self.order dot remove line item line item like so also here we need a rule and a precondition I'm just going to copy this but here of course we have to make sure that self taught order.line items is not empty because we can't remove a line item from the order if it doesn't contain any line items so now we have remove line item from order I can run my test again and we see this still passes now let's add another rule for example we might try to remove a line item from the order that's not in the order and that of course should raise an error so remove line item from order races error and again we're going to need the data search strategy it's going to return on I'm going to draw a line item from the self-taught line items and then I'm going to check that by test dot erasers and let's say we assume that this raises a value error and then we do self.order dot remove line item d line item so here we have again precondition and Rule like so and in this case we want the precondition to be that order doesn't contain any line items and that we already created a line item so line items should have length larger than zero let's run the test again there we go and now we see we get an error and hypothesis gives us the sequence of actions that it took in order to reproduce the error so what did it do well it create the state machine it then created a line item with a price and quantity of one and then it tried to remove that line item from the order but actually what happens is that it didn't raise a value error at all so we got some assertion error that the total no longer agrees and we also see that if you look at the order class removing the line item doesn't raise any error if a line item is not in the list so what we're going to do here is if line item not him self-talk line items we're going to raise a value error line item not n order like so let's run the test again and now we see that the test passes once more let's add one more rule here for example we may want to test that updating the quantity of a line item also works correctly so I'm going to add another rule and also here we're going to need the data strategy like so and I'm going to update the quantity so I'm also going to need a quantity integer which I'm going to generate using the integers strategy and then our method is called update line item quantity like so self and we're going again to provide the data quantity integer it's going to return on also here of course we might want to add a precondition that the length of self.autotline items is larger than zero like so and then we're going to draw the line item from the order object and we're going to self-order.update line item quantity line item and the new quantity is going to be the generated value save this and let's see what happens now by test there we go boom we get another error so what's happening here let's take a look at what hypothesis came up with so you see that it created your test rule-based State machine then it created a line item and then it added that line item to the order but then it added the same line item another time to the order and then it tries to update the quantity and indeed this is a bug in the code which of course I introduced on purpose but it's still there so update the line art quantity simply subtracts the total of the line item from the cache updates the quantity and then adds it again so this assumes that there is exactly one occurrence of the line item in the order and hypothesis figured out that if you added multiple times the same item then updating the quantity is going to break things so that means our caching solution is actually inadequate so what can we do well we can kind of make caching a bit simpler for example by introducing a methods called update total cache and that's simply going to compute this and post in it we're going to call this update total cache like so and now instead of doing it like this we can simply call the update total cache method [Applause] like so and we're going to do the same thing right here let's try this again I test and now again the test passes what you can also do is add more of these invariants more of these sanity checks so now we simply have a total degrees but I could make a special case for example with a precondition where the number of line items in the order equals zero so if that's the precondition then we can have a rule let's call that total degrees zero like so and here we're going to assert that self talk order dot total equals zero it's a simple special case that we can explicitly include in our test and then when we run this again hypothesis is also going to add this sanity check I think model based testing stateful testing is a really nice addition to your testing toolkit it will be particularly helpful when you have cases where there's lots of possible combinations of actions and you don't want to write those tests manually there's a few interesting things happening around hypothesis one is that one of the earlier adopters of the pep 754 exception group feature which was added to Python 3.11 and they're using it to collect errors from various different tests so that's pretty useful the second thing is that hypothesis also integrates nicely with a tool called hypo fuss and that's actually developed by Zac as well it's a tool that basically runs on on your code and that checks what happens if you provide it with all types of malformed inputs for example we have a function that expects an integer so you're going to test what happens when you provide it with a string or a list hypothesis also works with Crosshair and this is a tool that analyzes your code and if you use type annotations like I'm always doing then you can formulate next to that certain post conditions and a Crosshair is going to check that the post conditions hold using hypothesis on the hood both High profiles and Crosshair are tools that are intended to run for a longer time on your code so it's very different from let's say running a small set of unit tests it's really something that you should probably wrong almost continuously on your call to continuously detect bugs for you and the nice thing is that if those tools find bugs they're going to add it to the database and then the next time you run the test it's going to try those things again to make sure they actually fix those bugs finally I want to thank Zach the main contributor to hypothesis for helping me out with preparing this video if you want to learn more about hypothesis main features I did a video about that recently you can watch that next by clicking here thanks for watching and see you next week