well then uh welcome um I hope that I will be on the expectations um before I go to the next slide let me just introduce you a bit uh this picture uh this Munich uh this is where I'm coming from this is where I've been living in the last eight years uh this Tower is where my boss is sitting uh this building here is where you can go and visit uh fancy cars uh free entrance uh here you have the museum here you can pay and visit some other cars old cars and here is where we are um building some some cars that are built in Munich okay let's start with uh about me first um you can find me in GitHub and Twitter or x uh not on masteron yet um I've been working in C++ since 2011 um and I've been in safety critical System since I moved to BMW um and basically it's like uh yeah since since then it's it's the only time that I've been doing safety critical systems I Didn't Do It Outside BMW and nowadays I represent BMW at the MRA C++ working group and also at the C++ committee meetings since let's say covid uh that was not as a good way to start that was quite hard but going there okay uh first disclaimer about me um I'm not a functional safety expert uh just don't take anything for granted that I say regarding functional safety I'm not a static analysis expert I don't want to go down that path I'm also not a mrra expert I do my best I participate in the working group when a rule doesn't make sense I try to improve it I'm there but I joined recently and I I don't consider myself an expert on that okay then why I'm here basically like I'm I'm a lead a technical lead of a software development team and we have to deal with functional safety we have to deal with static analysis we have to deal with misra every single day and I think that this gave me a perspective that a functional safety expert doesn't have or an static analysis expert doesn't have or a Mis expert doesn't have it's it's like on the everyday job and basically today it's a bit about that like it's from a software developer to a software developer and I just want to show you my my point of view but don't take anything for granted before you yeah check your experts uh and also just as a member of misra working group that's always like important I'm not representing MRA here like everything that I say it's my opinion my word okay um now we know about me I would like to know a bit about you how many of you use a static analysis tools good I like it okay how many of you know about misra okay quite a lot good how many of you have to deal with m I see less than before some are lucky they know and they don't have to deal with it okay um now let let's go about to the talk um and I would like to to introduce this this talk just starting from the title and grab the different parts because one thing that that is missing is kind of fundamentals and for me this talk is about like fundamentals uh I hope that I will not disappoint anyone I don't want to go deeper into misra I don't want to go into specific rules that's not what is the talk about it's more about building some intuition on exactly what the title is saying how to deal with a static analysis findings with misra and let's start with the static analysis um yeah okay what I have to say I mean I think we can skip it a bit faster uh but let's let's let's remember a bit um to talk about what static analysis I I found this quote I like it quite a lot uh computer programs can be checked for errors statically or and dynamically and then we have a static analysis looks for a structural and semantic fals in programs Dynamic analysis affirms proper operation and helps identify errors and here would come my first question when do you think that this quote is from here approximately 60s 7s 80s '90s 2000 2010 2020 1800 I don't know it's it's from 78 uh probably you can find something like before I guess I don't know uh but I think that we have a hype of a static analysis I think now we have a lot of good tools uh but sometimes I have the feeling that it's just a feeling I don't know if it's true or not that than some people thinks that it's kind of like recent or like it's not but this is old um this is very old or at least I find it very old sorry if someone was born before 78 um okay basically the anastatic analysis the the the main point is like it's without executing the program and and here if we take it like with the strict War we can have some control flow we can have data flow analysis we could have code reviews if we grab it in the sense hey it's an analysis that we do without executing the program we can have manual code inspections and so on on the other side we have Dynamic analysis that would be you really have to run something and we have unit test thre sanitizers other sanitizers and Define behavior sanitizers memor Leak Detectors you name it uh fuzzing you have a lot of ways to detect issues and basically these issues we can separate them I would say like also in two blocks like what it is more automatic what is is manual um like a code review would be something super manual or for example some of these UI acceptance test that you really have a user repeating the same clicks every day uh that also would be uh manual and what I uh what we will focus uh today is in this part the part is automatic static analysis okay now let's let's go to the the the second part the second part is findings and this is something that my experience in my team or in the project that I am is that we missed something there we missed some fundamentals let's start with the basics what is a finding uh this is uh I think I didn't put the reference I think this from the Cambridge uh dictionary a piece of information that is discovered during an official examination of a problem situation or object piece of information that's what we get we do some kind of Discovery um and basically it's like during some like some process something that we do it produce the discovery we examine something we have some finder examiner you name it and then you produce the finder let's go a little bit more concrete we have code in general in our case what we want to check is code we put it through some tool or reviewer on the automatic will be a tool and this will end up producing a finding now what the finding should contain and this is something that you can think it from the two ways I mean I'm not sure how many of you here are tool vendors and how many are developers but just consider one important thing is where like a finding is not really valuable if you don't tell me where it's happening I just can compile my code and my compiler can be nice enough to tell me hey you have a Define behavior yeah but if you don't tell me where that's that's just useless information like I can really don't do anything tell me the line of code tell me the variable the function you have some findings sometimes that are not associated to a line it could be like hey your function should not be more than 50 lines long or so whatever yeah but which function just indicate it please be nice and and the file like you can have different functions with like the same function name in different files maybe different name of space variable if you just indicate the line sometimes I mean I think we know it from some compiler errors that basically you have a long line and you need to figure out which part of the line is relevant What description of the problem I think that that here we are also like good like we have a lot of tools that they provide that but tell me what is going on don't tell me there's an issue here tell me what is the issue what are you trying to tell me up to here I think that this most of the time is there why for me like when when when we have to deal with the static analysis like I like to know why like this this helps also this helps you as a developer to improve when you can know why this is a problem or why this reported or why this could be a potential problem this helps you to to learn this is how I learn python this is how I learn C++ and I think it's very valuable and also helps the developer to understand oh that's not the oh this is a stupid rule or something but it's like no I'm telling you why and you can have two reasons of the why one is why it's a problem tell me why it's a problem but you can have the other one why it's even being reported why are you telling me that hey maybe because we adhere to some guidelines and that guidelines talk about implicit cast and then that's why I'm reporting the implicit cast because of that guideline this is something that it's it it can be valuable to understand how this is like do you have an automatic fix is it available could you suggest me how to do it give me options this a a way to give guidance to provide some guidance another thing that is useful would be like references sometimes you can you can just not fit everything in one single line in one single error but you can provide references that the developer can check or not but you have it there if you want I don't know maybe you even have a YouTube video link whatever check for it and contact this is something that we also found this probably it's harder with open source tools but especially when you have the setup in your organization who can I ask for that like not everyone here probably like most of us we are kind of C++ experts uh we will not start asking from 0 to 10 but but more or less experts but most of the developers are not like super experts and they might want to discuss it with someone it's good to provide some kind of contact that in your organization you have a way to say hey to who I contact and the second part is like how I report false positive maybe I believe that this is a false positive I want to be able to report it now let's go on the direction on the on the findings we said we have a code we have a tool or a reviewer and now basically comes the question is the issue reported yes or no if yes that's what is producing as a finding and now this finding we can say is this correct or not and that's if it's yes that's what we would call call it true positive if we say no then that's a false positive and now BAS it's like if the issue is not reported and this is something that then it's like it's a no finding now here you can still ask yourself is this a finding yes and this would be a false negative and if it's not a finding that would be a true negative and very basic I know but let's build on that what do we with dra positive here you have multiple outcomes that's not just one simple outcome you can figure the issue that's the the most trivial one you could just suppress it you could say like but why it's fine like yes this I know this might be maybe it's a potential issue maybe it's not an issue and maybe you can justify why for these cases that would not be a problem maybe you have a a rule that lead to that uh finding you have a misra rule that was written in the '90s that you have to follow you think it doesn't make a sense maybe you can just go there and try to change the rule and say hey this is not the problem let's change CH the rule this is something that that you can do for the false positive you can report the false positive to the tool to the reviewer saying hey this I think it's a false positive you might be surprised on the outcome maybe you think it's a false positive but from the discussion you figure out it's not a false positive you can just suppress the issue apart from doing that just suppress it explain why why it's a false positive you should try to give some argument there and this is the last one that that I see a lot of times miss you could create a test like to detect the false positive you want to know when the false positive is fixed you don't want to end up having code in your code base like yes suppress false positive suppress false positive when you plan to do the cleanup when do you know that the false positive has been fixed uh do you go over the code base from time to time and remove them all and check again that would be a bit annoying it's better if you can select if know when this is fixed and now let's go for the the false negative the false negative I don't know how many of you really consider false negative this is something that I think as a tool Bender you you consider it more more but as a developer it's something like I don't have an issue on my code like then it's everything is fine but for me sometimes it happened it's like yeah you review a bu like I don't know you are investigating a bu and then you figure out I don't know maybe this variable it's initialized or you realize that you have a a race condition or something and then it's like wait a second like the last year I was setting up threats and aters UV sanitizers I have my Clank tidy I follow all the MRA and this was not reported this is something that it's good to think about this is the way that that bring us for forward and especially for safety critical systems at some point this will be important you need to be able to justify that your tools are checking for what you are saying that they are checking this would be part probably of a tool qualification this is something that most of the time you will not be involved uh but this is valuable feedback because it may be that the two qualification kit or it misses some use cases that you know or maybe you just misunderstood the rule what do we do in this case check if this is an issue according to the rules maybe you believe that it's an issue but we have no check for that I saw like hey people are using Westcon I mean what the  this should be an issue oh no we didn't agree that we should Ison check your rules uh you might have to adapt the rules rule or the guideline if we say hey this is an issue but maybe I don't have a rule let's adjust the the the guidelines in order to issue that as a as a problem you can report that as a false negative uh I'm not sure like if if some of you told Benders if you ever receive that but it's like that would be like I think it's it's really valuable uh but I assume that they receive much much less false negative than um than false positive uh uh reports and the same like create a test that that detects when this this false negative is fixed uh I think that this is also valuable to say hey now I can really rely on this fix because all these cases that were not covered now they are covered and maybe you can just if you had two tools or something then I mean you know when you are improving your quality and the last one is the true negative nothing much to say I think like it was not found it's not an issue I mean if you can have another idea of what you should do uh yes sorry for the false negative isn't there more low hanging fruit that you have not configured your tool correctly that there is an option in the tool and you should enable and check for exactly the issue you have true true that that could be uh I I consider like about adapting the rules but it's true like it could be that more than adapting the rules you should adopt the the tool configuration that's that's a good point yeah uh I think even it it could uh going that path I think you can also consider with the false positive Sometimes some rules maybe you need to to specify hey which version of the language I'm using or stuff like that apart from the rules uh this could be uh probably I should I should add the the to configuration in in the different places and yeah basically the the true negative like nothing to do everything is fine okay now we had the first part now let's let's uh uh go to misra um okay misra funny enough uh it's it's like I'm not sure how many knows what what that means but basically it's motor industry software reliability Association I don't think it makes more sense anymore um this is historical this comes from the early 90s um when they were developing guidelines for for for road vehicles like you didn't have that that was kind of like uh the reason uh nowadays it Prov I mean it started mainly like with C uh nowadays provides guidelines for for safe and Security application C and also C++ also the other guidelines that I will not uh uh discuss now like modeling Frameworks and stuff like that and the three Publications or even the the two that I will want to focus today are these three like first one is like uh mythra rules for C that by the way there's the 2023 version since July maybe something like that uh that basically it's for C11 and c18 the misra C++ 2008 yes it's called 2008 and was done in 2008 and it uh makes you use C++ 03 uh 20 years old right now um and basically you have the misra compliance um 2020 I would be interested how many of you know about the mrra compliance document 2020 not not too many that's that's okay then that maybe then that's that's good that's good um for this one yeah we will we'll talk about that um here you can find more about misra um as I said it's like I'm an individual I'm not here to come to announce like oh we have new MRA guidelines sorry for the disappointment now you can just open the door and leave I will not prevent you from that let's let's discuss a bit why mistra um I give you a second to think if you want why you want to follow MRA basically like um uh I'm not sure like here like I mean uh there were a lot of hands for misra but how many of you are like in in fields that is not like automotive industry and you follow misra that is not okay quite some hands yeah because basically like in in automotive industry we have uh this ISO uh 26262 very easy to remember um that basally it's like for functional safety on road vehicles this kind of a specialized standard from a more generic one and basically like there are different versions or similar standards like for nuclear power plants I think that's one for Aviation uh for medical devices uh maybe some other uh just focusing a bit on different fields and in yeah in the company we have to follow 26262 this is fun this for functional safety and this standard has some some interesting paragraph here that basically it's like kind of forcing us to use something criteria for suitable modeling designer programming languages C 5.4.2 that are not sufficiently addressed by the language itself shall be covered by the corresponding guidelines or by the development environment considering the topics listed in table one this would be the paragraph like this like the the this ISO is splited in separate Parts uh one part one that's introductory the rest that I find them boring and I don't care so much and the part six that is like for the software development I mean if you are a software developer the one that you are interested it's the six mainly and there you have this this paragraph that is the one that kind of like forces us or like tells us yes you should use guidelines C++ doesn't address all the problems that you could have and what do we have here here in this table enforcement of flow complexity I mean if you have less complexity usually you have less bucks that's proven uh use of language subsets uh we all know that some things they should not be used um and enforcement of a strong typing better better typing system usually it leads also to less bugs kind of defensive implementation techniques well trusted design principles um and ambiguous graphical representation use of a style guides um use of naming conventions and concurrency aspects whatever concurrency aspects means uh let's say that we should take about concurrency yes we have problems there okay and now basically like okay we saw misra we see the iso 26262 and the thing is that misra was created before the Dao 26262 it was uh the one that I know of is like from 2018 the 26262 I think that there was another version from 2011 I think but I think that 11 was the first one I'm not yeah okay I I see someone noding okay and but basically we said like MRA comes from the '90s and people start using that then it's like what what do you keep using you keep using mistra or you provide me something better okay someone tried to provide something better um because people didn't want to to develop with misra anymore I'm not sure how many of the you that that uh that are here that not are not an automotive you follow the autosar guidelines that would be interesting autosar it's like autosar is a Consortium of different companies and basically it's to develop a platform um for automotive it's it's let's say you have the software like the high level software that you might have like I don't know trajectory planning object recognition whatsoever and in the bottom you have the operating system but in the middle you have a platform and this is what autosar defines the thing is that in autosar you have classic autosar that's mainly C adaptive autosar C++ and adaptive autosar like I mean if you say someone like yeah you need to program in C++ of 3 please no um there are a lot of good things from 11 just we can discuss if 11 or 14 but not pre-1 and they came up with some guidelines uh a lot of them come from misra some are adapted some are like just directly linking to misra and this is what we are using and this is what a lot of people are are using um in reality you end up checking for both for outar and misra the interesting part is that also like yeah I guess okay I'm not sure what I will claim now uh just take it as my opinion but I guess that people from autosar were like in a hurry it's like hey these people from misra they they need ages uh to do that we want to do something we create some guidelines they created some guidelines but you don't want to have two different groups oh uh by the way we have the core guidelines the C++ core guidelines of course they are not for safety critical system we have the Mis guidelines and now they appeared outar guidelines thanks God uh they decide okay autosar already has some statements you can check the the latest version that says this guidelines will get replaced by the new mythra whenever that happens um we already have some information uh there was some some public uh review of misra uh we receed a lot of feedback that was really nice uh and the new Mis is based on C++ 17 that's also good it at least like it move us forward then it's like there should be no excuse to not use 17 um apart from probably using a compiler that doesn't support 17 uh but at least you can push your compiler that hey you have some uh rules here uh and that's a reason why to use also misra if you want to know more about misra what is coming uh there are two talks uh both are are uh people uh participating actively misra one from Peter sulot uh one from L uh Julie and yeah you you can take a look if you are interested in new misra I can only say one thing stay tuned it's it's really now it's soon um okay but now I want to talk about how the misra document is is structur the thing is that okay a lot of you said that you work with mistra but you can deal with with misra in two ways one is like you read the tools that are coming from your tooling or you grab the misra document and you read it how many of you have access to the misra document and can read like the full misra document and not just the rules not a lot and that's interesting why because in the misal rule there are there is much more than just there is much more than just rules um this is the the index of the misra document from 2008 the 23 will be similar uh but basically you can see here like background Vision scope using misra C++ introduction to the rules uh rules references and some appendix and you have only one section that is rules and then this this section has some subsections why I'm saying that uh I mean if you are just finding your issues finding the rules you fix them and you don't wonder like too much that's perfectly fine but if at some point you think hey this is stupid this doesn't make any sense it's impossible to have all the issues it's impossible to have it 100% safe or whatever I recommend a lot that you try to go to whoever in your organization please I want to really read the rest because there are some very interesting Parts there that give you a little bit what is the intention probably just don't to start reading now just wait a bit get the new one and then just read it but even in the part of uh the Expressions basically like uh there is some weird mapping uh basically you see 6.5.1 is not there but has its reason some mappings with the standard uh it took me some time to figure out but basically it's like it has some kind of mapping with the stand uh that's that's why uh the the jumping numbers I'm not sure if it's explained I just got to know uh recently but basally it's like each section has a group of rules but also the sections have some introduction and these introductions they are I would say like quite quite good uh and they give in my opinion much much a better overview and much more understanding than just the rule themselves and that's one thing that I want here to raise awareness that this exist now let's go more to the rules what what the rules what a miser rule contains and this is a bit of a mix between or a join between 823 okay uh let's let's but this I think that all the sections will be there in 23 rule itself what is like do don't do that or yeah like kind of like one headline um okay I see that here the the one by one didn't work uh rule category like is it the rule mandatory is it required or advisory this like different levels to say how bad or like how much how strict you should be theability this is something that that is coming uh I think it was not there in the 28 2008 um but this it's like from the people that wrote the rule you already make an statement saying I believe this is decidable or I believe that this is UND decidable this in this way it puts kind of everyone on the same page also the scope this rule is like single translation unit or you need to have the whole system I mean don't violate the one definition rule I mean you cannot do it on a translation unit that doesn't work you have references to the standard like every rule or most of the rules I have references to the standard they have an amplification uh sometimes it's like uh we'll we'll see later uh what it is but basically it's like you have one headline and then basically sometimes this headline implies a lot of things and then in the amplification you least uh don't do that that and that or yeah it's kind of to have short version and long version of the rule and this is also important because some people just might read only the rule but there's an amplification to read that's the rationale that part is the one that I love the most if you want to learn a language because you can learn why someone decided to put this rule what is the reason for that and if you at some point want to challenge and you want to say I think this rule is  well go there go to the rational and if you want then then start Challen challenging the rational or but but grab the rational because without that you can you can really not challenge anything an example an example I find it extremely useful some rules are super easy to understand that's the sentence done some rules they might be written for mainly tool vendors and it's hard for a human normal developer to understand but then you have an example yes sometimes the example might contradict please if that's the if that's the case just just report an issue uh but the example I think I find them super useful to really get an overview and basically you have references to other rules and this is also specially important because you can say oh yeah okay this I fix it and then you fix it and then you are violating another rule that's something extremely annoying uh but it's like that when you have a set of I don't know 100 rules or something it might get relatively easy that when you try to fix one rule then you violate another rule okay this for what what misra rules but now I want to talk about the Compliance Document and I think that this is probably the interesting part for what I saw that here people are not aware of that I was also not aware of that uh I'm not sure where is the communication channel that fa on that maybe it's because only the F experts read that part but I still think it's super important for the developers at least one part as we said uh MRA has different Publications uh C C++ and this Compliance Document the Compliance Document is the one that I want to focus uh right now and basically there are two parts like the the the Compliance Document is like it's about achieving compliance with misra coding guidelines at some point you want to say I'm compliant according to misra and that document is the one that guides you this is the part that probably it's more relevant for whoever is in the safety team in your organization that needs to do all the bureaucracy saying yes yes yes we we are compliant because we follow uh but we'll see that there are parts that are relevant for us and the important part is that this document is for free in the page like you just can go there there's a PDF you download it right away no login or anything just just go there download it and it's short 20 Pages it's it's short easy to read I mean you can read it like yeah in in half an hour maybe and what do we have here this the the the content uh introduction software development process fundamentals the the part that I want to focus here is the deviations now if we just remember what we talked about before false false positive false negative all of this you might sometimes say or even the true positive I inde this is more for the true positive where you say this is an issue but I have good reasons or something like that this where this part uh comes into place um and this is where it explains how you can justify a deviation and now here I just want to try to build some intuition I just don't want that you take my word like my words like one by one it's about just intuition uh and then later you can just double check with your safety experts and the document but I think the first step is to get an idea okay justifying the devation this is something that appears there that that's one of the the parts and says some of the cases where the ad deviation must not be permitted and that is something that as a developer I find it super useful especially when you review it like the BH needs to be rebed also but when should I accept if you come to me with hey this is fine should I accept it no this give some guidelines simply to satisfy convenience of the developer we all have seen rules like yeah I don't have more than 20 lines in this function yeah but now I have to refactor this will take me like some days uh yeah it's just too much work no that's not a good reason to the be it sorry that's here you can just think what it means convenience of the developer but you get the idea when a reasonable alternative coding a strategy would make the need for a violation unnecessary we had a clear example here we use one tool that I will not mention the name that for some reason that I can imagine could not different could not understand um Easton It could only understand West every time that you had Ison in your code was triggering a false positive and there we had two options we are stubborn and we stay with its cones and we suppress it um I'm an eon Defender uh I don't see any reason why we should not use Ison or we just say you know what we go to Westcon and I'm the one I'm the bad guy that had to say hey I mean according to this Accord I mean what it makes more sense is we stay on Westcon honestly like the cases where East cons or west cons makes really a difference when you read it we don't have so many and here was clear we had a clear alternative that was we moved to Westcon and then suppressions are not needed this how I interpret as a reasonable altering coding strategy you can just grab examples again this is not very precise but it's the idea what is important without considering consequences that's important like all rules are like done in a way but also like sometimes misra will not contain a rule just because you know that if you follow that rule then you don't have to consider that but in the moment that you start violating rules let's assume for a moment that there would be a rule saying don't use exception well I mean like if you decide to violate that and you would decide to use exceptions well that might have some consequences maybe you have to consider some some other rules to adding or yeah just consider the the consequences a process that's also something that that it requires here you need to have a process it cannot be that yeah uh you know what I mean and also like without the con consent of a designated technical Authority it you have one Junior I mean all all really like all respect with with Juniors but let's say like I mean like I'm Junior on some topics I'm senior on other right I mean like we are all Juniors and seniors at the same time but doesn't make sense that someone that it's a junior on a topic then like oh yes I devate and then another Junior on the same topic it also approved that we should end up having some kind of technical Authority and these are the things that uh yeah they they appear onto the document and basically we should follow Again full information just go there the document is 30 something Pages if you cut the appendixes and stuff like that uh it's around 20 something pages okay let's go in an example of a my rule um yeah I'm not allowed to copy paste I just put it like roughly we have a rule do not AB ruply terminate the program um and now here like what does it mean okay we have an amplification and this amplification could be something like do not collab ort exit or terminate implicitly or explicitly now maybe someone can answer why this is not like why this is something that you would like to forbid like as a guideline then you can discuss if you want to the V8 or not but yeah sometimes it's hard to determine that something has stopped working if you're in in the environment especially that could be a reason is the reason that misra chose who knows well we have the rational basically the rational is that in some cases like stack and winding is not happening in other cases it's implementation defined for example in abort if I remember right in abort it's not happening in St terminate it's implementation defined and that's something that yeah well I mean if you had some resources taken maybe you end up leaving some file open will your operating system do the cleanup these are things that that you should consider and that's the rational and that's good to know why the rule is there especially because when you debate this just a bit of a simplification of a rule that exist uh if you want to know the exact definition just just check it onto the onto the document it's more to get the idea okay now let's I think we are we're quite good on time let's let's check an example this code let's assume like you have this code and basically it's like you have a tool and the tools tells you like in this line S determinate it's a finding is it correct I mean I would say yes I mean it's quite quite hard that say it's not correct right I mean like the rule was about that it saying is correct but is it something something that we want to have I mean if you look at how it looks like that this is kind of a contract style you know like I have some preconditions I decide maybe that my function I don't want to divide by zero to integers and I want to just catch that in case that happens and I will do an terminate maybe it's like it's it's fine like in my project is fine okay then let's let's suppress it we have some some ways to suppress it in a tool that it's you just write IGN or finding okay I write this and then I go home perfect is it fine I mean like I mean this this is not fine right I mean like yes I mean ignore finding and what yeah I mean you should say something right I mean if you if you if you have a a common you should put something I've seen this in code honestly I've seen this in code what does it mean that it's fine I mean why please tell me I mean some elaboration that that's of course not not fine uh did you decide on your own like did did you check with someone yeah let's Sol it yeah we agreed it's fine okay at least now you know that two people decided that this is fine and they decide to accept it perfect um yeah but again like I mean honestly like I know it's a bit annoying but we are developing safety critical system I mean if if for you it's not important then maybe just you should consider if you really should follow uh safety critical system rules I mean at some point like maybe you don't want to apply Mithra to some UI and if you do it it has some consequences I mean yeah just just think about it this could be probably something better the project agreed to address precondition violations with the call to terminate in and here we put some reference you can read why it's not a problem if the stock is not involved I just don't want to say if this is really right or wrong but at least if I see something like that then it's like okay now I can I can start con seeing if I approve it honestly the other ones for me just simple I don't even have to think anything here like request changes I mean it's just it's just simple uh in reality like I mean but but if you see here they this like okay you again it's about building intuition you explain a bit what what you consider part of the rationale you put some maybe some link to not clutter too much with information um you can find an like in this document you can find an example how should look like a deviation it's much more complete you have much more text but you can get some some idea here the important part is idea now we have another one we saw false positive false negative let's let's find this part of piece of code I've seen these kind of things you have this code and it's like hey I'm triggering your finding on the first line and I'm triggering your finding on the second line is this correct is this a false positive let's let's start with the first line is this is this a false positive yes yes I see a yes yes someone that says no someone that says maybe yes maybe not it depends okay and for the second one like is it a false positive okay what if I would tell you that that before there's some code like this one like if like some I mean this you put this on top of the this I mean if that would be the case like the first line is not really false positive right I mean like it's like that is fatal in in reality is calling an SD terminate it's like that that line is really terminating um that's why this is something that it's it's it might become a problem in the in the moment that you have some tools that produce too many false positive the developers start hurrying on saying like oh this is a false positive but when you check false positive you really need to double check like there are a lot of things that can happen and that's what I just wanted to illustrate here thanks God this didn't happen this is not something that I took as an example from code but it goes along these lines like there are things that you assume that oh yes it had the word terminate they did the r x to find all the calls to terminate and that's why it triggered but maybe the was smarter than you thought so and this is something that it would help you also like when you report the false positive that someone maybe would would double check yeah basically then you could just suppress it but of course like if you put then suppress false positive then in the first one that that would just be wrong okay that's what I wanted to tell uh today um but basically like now let's let's check what what what I would like that you take from this talk as you saw it's not about the rules don't fix things without thinking and and this I think it's like it's a favor for you like every time that you have to find a you have a finding don't take it like ah yeah now I have to fix findings no just take it as opportunities for learning this is really amazing like oh yes you can say to your management yeah I need to fix this finding it's really hard and then you start reading the rationale you can check the standard why this is problem just don't fix without thinking don't suppress the finding without thinking we saw an example you can have similar examples keep in mind that false negative exist uh this is something that you can do like when you are reviewing code if you see something that you say hey this I I think it's wrong but it's like hey did you had some tool triggering that you have all the checks passing and you still think that it's wrong maybe consider this this will help a lot to improve your your development environment and also like fixing or suppressing is not the two choices that you have you can report false positive you can adapt guidelines you can actively contribute to guidelines really like in the misra working group there are people that they were super annoyed of the old misal rules and some of them instead of just complaining shouting and saying misra sucks they just went there they join and they put a lot of time and effort to make that better and that's the only way and of course it's not easy like we might spend I don't know like for some rules we can spend hours and hours and hours and you just counted there are 100 rules but you have more options at fix and suppress and this is something that you should keep in mind don't don't stay like this narrow-minded that would be the talk thanks to everyone for listening and I hope that you enjoyed and if you have any further questions please there's one hand there thanks um is there a distinction between suppressing and uh deviation yeah when I say suppressing in general it can be a deviation because if you do a deviation you don't want that it appears anymore in the report right I mean usually like if that is fine you will add some kind of like suppressing Mark that you say uh this is fine and it's like a deviation because you can suppress because it's a false positive or because it's a it's you want to deviate from the rule that's that would be the difference yeah so um so to rephrase my question the uh deviation would be the terminology for only for false positives h no sorry for True exactly for the true positive where you say yes for whatever is I mean you have in the document goes a bit more in in detail because you have sometimes like this definitely an issue or this is a potential issue imagine that this is an issue depending on your input but somehow you can prove that the input will will not be in in that range or something like that and then in that case you need to say this is fine and you want to suppress it and how you suppress it through a deviation but sometimes you want to suppress the warning because that's a false positive and then you suppress it to a in a different way that is not a deviation I would not have a way to or a word to say how you suppress it uh for a false positive okay got it yeah thanks for the talk welcome I can only uh emphasize what you said about the suppression comments that uh there should not only be a second opinion on that but also a let's say capable second opinion and uh just as a funny story a colleague of mine at uh even uh trained an artificial intelligence model to read all the suppression statements whether they at least sort of make sense or whether it's just total to shut the tool up I I have pending to do a a regx because some of them like this type of it's okay uh even sometimes people copy paste them and that's even making it better because then it's easier to search for them uh I mean at some point you try to go by steps right like I mean you cannot go from from Zero to Hero you try to get something and then get better but we had cases like yeah people that believe in an expert I mean probably most of you you know like U in6 plus u 16 what value give you uh if you can think about that uh yeah some people say no no there's no conversions going on or whatsoever like yeah I mean and then they read the St it's like this cannot be true it's like yes sir it's true that's why we have a rule uh right uh just one comment from my side also as a difference to autoa what is bugging is actually the copyright so we have like uh findings say you violated a rule but we cannot tell you you cannot like populate examples which are good or so it's just not allowed yes I cannot say anything else on that I I find it I mean for me personally I don't like that it's uh I mean honestly like the misra guidelines to why they don't cost so much I mean I think like one copy of the PDF cost like1 15s or something like that it's not really expensive but usually like if then you are in an organization uh even like I I don't know depends on the organization sometimes it's it's hard but yeah I mean that's that's a yeah I agree I mean with autoa we can just you know put them on internal web page or even deliver with a tool everything fine developer has a finding clicks here okay cool I know what to do but M no you cannot tell you what you did wrong I yeah I agree so um speaking specifically about the um manual uh review process or code review yeah so you had all these like suggestions for like okay what why where how links references uh whatever like adding all these steps like as guidelines for manual code review don't you think that the like developers are doing the code reviews like will will either like do a worse job just cuz it's going to be like um it's going to take more effort to go through a code review or uh yeah just maybe say okay this is a finding but it's minor so I don't even want to report it because it's going have to go through all these I have to open a Zer ticket I have to uh U yeah you understand I hope yeah I mean I mean I like your thinking because that's exactly how how I I I wanted to structure the talk because the first part you can apply to almost any findings um and and yes I I mean I agree with you that it's like that's why for me I would never enforce that like you can give that information some people might not have thought about this information that you can provide or that is valuable but I would never I I really hate enforcing things because usually like usually things go wrong like people find find ways to go out and for code reviews my experience how usually works is like you have someone starting you know the level of that person or like how much have been in the project you put some effort and basically depends on what that person makes with your comments you decide what you do in the next review because at some point when you have been explaining very detailed and a lot of information and you see that that person is not learning then maybe I will just not put effort one thing that I did for some cases you you end up seeing a pattern there there are some things that people end up doing wrong and for me one way that I speed up reviews but still keeping quality is like I have a kind of a preet of answers even sometimes I can add a comments saying hey this is like a copy paste that you know but some a lot of times this is really useful and even for the person that is writing that and sometimes I can answer no this is about something else okay sorry like I mix up that right but but this I think it's a way to to improve that but I would never enforce yes you need to provide all of that I mean no one will want to review code okay thank you um so there was I mentioned I'm curious are there any known efforts to have tools uh that are capable of actually fixing Mr warnings in automated way anyone here imp uh I mean I I don't no I mean like in some it's like probably you don't want that some tool automatically deletes the the SE terminate line right uh because I mean probably you wanted to do something there the the auto fix like I put it there because it's something that it's like you should consider but it's always dangerous I've seen Auto fix with Clank tidy that someone says yeah you apply the autofix and I find it super useful the autofix but then for me you need to really pay a lot of attention on the review and an howo fix without proper review I find it harming more than helping because then you don't have the issue being trigger anymore and no one check if the fix was really a fix or like yes I I see it like with data types oh you have an implicit cast yeah I make it explicit yeah but maybe you are losing data you just make it explicit and you lost the opportunity someone to see it uh just to comment on that uh if you have some whatever aib based assistant to maybe ideally get automatically rid of the warning in this safety critical contest uh context you would have to Tool qualify that Ai and good luck with that yeah hello thank you also for the talk I have one question regarding not only uh quality check off uh in static code analy tools um do you also working together with another department maybe regarding security issues and um because my current understanding is that with misra you can only detect um yeah quality issues but not directly security issues let me see if I find uh and secure the the thing is that I mean I'm not sure like for what I understood like uh I think M at the beginning didn't really consider so much the secure part at some point they did a conscious decision and they also referred to some of the set rules uh but it also uh targets that so we have one question from the internet how often do you get findings that suggest safety over performance and brings runtime overheads yeah that's a good question I mean I don't have numbers um but also most of the time like I mean I might have had some claims of someone telling me that but most of the time it's like I I don't see proof also of the performance overhead because yeah it can be like yeah an instruction more here but it's like what is instruction given overall and honestly in safety critical systems at some point it's like yeah sorry I mean it's it's performance is not the priority of course you want to have it but it's not the priority like yeah thanks again for the talk um think we done