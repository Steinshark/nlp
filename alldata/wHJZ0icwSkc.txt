wouldn't it be nice if our software just worked you know if it just did what it was supposed to do some days that seems like a distant dream but we can hope we have to hope we have to stretch ourselves for the day when software is reliable how are we going to get there I'm told that the answer to this is test driven development and I do like that technique and I use it and plenty has been said about how great it is so let me risk excommunication and tell you my problem with test driven development you do end up with an awful lot of test code and because that code is just code of course it comes with a maintenance overhead of its own and it has reliability and readability problems of its own and on one of my more dark and cynical days it seems like our code wasn't working so we just doubled the amount of code and in my heart of hearts I don't know it just seems like we're doing things the hard way like that's almost too much work and my job as a programmer is to be lazy in the smart way I see that many unit tests and I just want to automate the problem away well that's the promise of property testing write a bit of code that describes the shape of your software and it will go away and create 10,000 unit tests to see if you're right if it actually does work that way and this week we're going to look at property testing what it is how it works and we're also going to address my biggest disappointment so far with property testing which is that it only seems to work in theory it's great for textbook examples I'm sold on the principle but I've struggled to make it work on my more gnarly real world code well enter stage left riding a white horse Oscar Wickstrom who has some sneaky techniques for making property testing practical stuff he's been using to test things like databases system migrations video editors and even the really messy world of user interfaces and this discussion has me genuinely looking at my test Suites in a new light and wanting to try to do things differently and I really hope it does the same for you so let's get started I'm your host Chris Jenkins this is developer voices and today's voice is Oscar [Music] Wickstrom [Music] I'm joined today by Oscar Wickstrom how you doing Oscar very good thank you how about you I'm very well I'm I'm intrigued by the musical instruments sitting behind you I wonder if we should have a jam session instead of a podcast yeah maybe so uh this is a shed in in many respects I guess your drum shed that's a nice thing to have drum shed programming shed office in a so when your code isn't working you can just bang the drums and get your frustration out yeah it's after every meeting I just flip around and we all need that but but by some measure your code should be working more often than most right done my drumming yeah Gauntlet thrown down yeah because uh you're going to talk about we're going to talk about property testing in this one because you have we'll get into a definition of what it is but I think you've taken this as far as anyone I know in the practical sense there are lots of theoretical people working on it and people building more Frameworks for property testing but you've been using an anger in a really interesting way before we get into that I think we should get everyone on the same page and you can give me your personal definition of what property testing is yeah yeah good and I haven't prepped any like that'll keep it honest rather than marketing yeah okay so I when I try to explain this I usually start with what people are comfortable with normally and what's the sort of the State of Affairs and uh most people have been doing some kind of unit testing or example base testing if you want to call that yeah um so I try to start there and with example based testing you you sort of um you have something you want to you want to test and then you come up with at a high level inputs and outputs and it might seem a little weird to think about it as input input and output but um if you have a you know a function it's pretty clear how it's an input and output that you're testing but you might be testing some kind of database storage thing and the output is more like the effect of storing something in a database for instance yeah um but you have these at a high level you have these input and output pairs uh for each of your tests you say like okay if I do this then I should have this result that's the input and output so I say my create user function if I call it with oscar. Wickstrom google.com I ought to be able to select a row out of the database afterwards yeah exactly so outcome is sort of output in that um okay and then you come up with a bunch of these and you write tests for them and uh you might have a bunch of these and uh feel like okay uh it's getting a bit repetitive and I have a lot of duplication here and then you can refactor and you can massage like move things around and and um improve that situation and there is this technique called um datadriven tests or um sort of tabular tests or whatever you want to call it where you have just one function doing this assertion or whatever and then you supply a table where each row is a bunch of inputs and the output so sort ofation I've done that without naming it that okay yeah I'm not sure if that's the like proper name but it has a lot lot of different names um but you can um you can then just add more rows and it's easier to add more tests in that sense yeah uh still so you have you have sort of fixed some of the maintainability problems of having a thousand copy copy pasted tests um but you have have a different problem still which is you have to come up with these inputs and outputs and uh humans aren't that good with coming up with all the interesting edge cases and uh combinatorics of uh of what to test yeah I wonder how many bits of code out there take an email address and they've never tested it with Unicode characters yeah that kind of thing and so on yeah so yeah strings are one good one good example of these where you have sort of a domain of strings that are valid and yeah it can get tricky pretty quickly and you have to if you have different um different inputs that have some kind of relation to each other it sort of explodes quickly and um so yeah that problem is uh you don't solve that very well with this tabular testing thing and and that's where property testing comes in because there's like the next step here if we could keep that function but instead generate this whole table generate all the input and output Pairs and express uh our test as a function still but but then it becomes tricky because well you can't this this relation between input and output has so far only been in your head right it's yeah something that you have some kind of intuition about some idea and like yeah of course this input goes along with this output that makes sense but you haven't really pinned down formally why do they belong together uh so you're saying like if I have a function that's supposed to pull the domain name out of an email address if it's Oscar at gmail I can say that and I can say the output should be Gmail but I haven't really defined what it means to pull the domain out of an email address right why is just Gmail right yeah yeah when it's something else yeah and then you can maybe so if you do that and you can generate these inputs email addresses for instance and you want to say okay I have a function that pulls out the domain name um then you have to uh in order to be able to test if you can just generate the inputs you have to come up with a way of formalizing the relation to the output so you have to think of what's the general rule on how do I go from input to Output in a in a proper way yeah because your unit tests kind of hinting at a pattern you now want to make more explicit yeah yeah exactly so unit test or example based tests are small pieces of like narrative small stories about how things uh how things work but you have to generalize that so going from these small examples stories of sort of evidence of what's going on observations almost um you have to raise that and into a general um generalize that relation basically between input and output so for your example you might U let's see if I can come up with something on the spot but if you say like okay if I want to extract um the domain name out of an email address uh if I then could uh also extract say the the part before the ads I don't know what it's called but you know the the username sort of part of it yeah um and then piece together those two results and then I should end up with what I started with maybe yeah yeah and that test is General you can feed it whatever whatever email address you want and and it will do this sort of test your function that extracts the domain but also do something else P together and check that the the output is the same as the input maybe so then you have you have thought about your test differently in order to be able to test on any input this is what I like about the idea of property testing that the way we're doing the testing is somehow made of slightly different stuff than the code that's under test it always feels like unit tests are made of exactly the same material as the code yeah and that's that's always felt somehow wrong to me yeah it's it's easy to end up there like your tests are one to one reflecting the implementation right yeah I'm sure many have seen that but um and property testing is you can end up in that situation if you do property testing with sort of the I don't want to say wrong type of property but certain type of properties don't fit certain type of U systems or functions under test then you can end up in same kind of situation but if you do find a nice pattern for writing a property for a certain thing you want to test you're sort of forced to not do that right yeah yeah I'm um I'm kind of reminded of discussion we had with Simon pton Jones a few weeks ago where it's like there's an algorithm that computes square roots and it's very easy Once you found a square root to test if it actually right but the way you're testing if it's correct is very different from the way you're calculating it yeah it's easy to go in One Direction but not the other yeah and so when you're going in both directions it's kind of almost adversarial in a positive way yeah yeah exactly yeah and that brings kind of up the my third point on what property testing does in in a different way than example based test where my colleague said this to me like it's it's nice in the sense that you when you have written a function you have probably all already thought about your the things you want to cover the things you can imagine could go wrong or should be successful and so on yeah and this forces you to express it in a totally different way which as you say it becomes sort of adversarial it's thinking differently and coming up with different paths or different examples that could break your assumptions that you had when you wrote it so it's it's hard to do that mind shift just going back and forth between being your own friend and being your enemy back and forth yeah so what is it about property test that makes that easier do you think well it's it's really hard to in in most cases then as as I was going into before it's hard to uh actually do a property test and describe the implementation I think because it's it's so different in some it's hard to describe but it's you have to think differently about how you test it when you don't know for instance don't know the output you only know the input what should the output be I don't know I I can't say something concrete about the input because I don't know what it is I have to find this General generalization and and that sort of forces you to uh think differently and that in combination with inputs being generated not by you your brain but by some other semi stochastic thing um that tends to uncover things you haven't thought about right so you're saying I write a property test that takes let's stick with email address I'm going to get a huge number of randomly generated email addresses and because that input is so varied I kind of have to treat it in an abstract way yeah I can't think of it as a concrete thing so I have to think about the whole testing problem differently yeah yeah that makes sense so the big problem with this always is you go to a you go to a conference talk on property testing and they give you lots of examples on lists and maybe a couple of on email addresses and it kind of I've run up against this it kind of feels like it's only really going to work for obviously mathematical stuff or obviously abstract stuff yeah this is why I wanted to get you in because you've done this with a lot more hairy code so take me through to how to how can I write better and more general property tests yeah so you're describing me Circa 2016 I think I was at a conference talk and someone gave a great talk and all all that but I was like in denial and I was like nah that's not going to work for my stuff it's too much too academic too theoretical and um okay so yeah I started there and then I I think I softened to the idea by um we had this rewrite kind of project where we had where we shared the database between two implementations and okay uh for a while during the the sort of rewrite or rewrite or um was sort of slicing a part of the system in rewriting and uh and we can compare those systems uh how they acted on the same input with where the input was actually the database and so I I I wasn't actually looking to learn property based testing but I was doing this and I sort of backtracked from there I was like this is sort of a variation on property testing in a sense um so the property was sort of these two systems should be uh in sync or they should should gave the give the same output for for the same input basically yeah and that is a common way of expressing a property test if you have some system that is uh very complicated in a not not in its functionality not in this in its Essence but in a sort of non-functional way maybe has a lot of performance optimizations and stuff then you can write another version which is really simple uh just in memory super naive whatever and then you can run them side by side and see that they produce the same output anyway yeah um I'm derailing um so uh that was sort of my my where I started I think and then um for in a totally different project I was doing a screencast editor application and uh oh yeah yeah that you wrote right yeah so I I was doing my own screencasts around High School programming and um I thought it might be a good idea to also do a an editor for doing screencast editing so recording first and then pulling all the stuff in there and um having my own workflow and so on that was a fun project that sounds like a lot of fun but really going the hard way yeah sort of a Sidetrack yeah but that was also an experiment sort of driven uh from this angle of of learning property based testing because I I quickly realized that it's it was getting complicated because I had this partly I had um undo redo and a lot of operations that could be undone and redone they were all uh implemented sort of as a in a in a functional way so you had a big state and you had some operation that produce a new State uh the architecture was was nice but it was hard to verify that everything worked as it should because it was I shouldn't go into too much details but I had this kind of tre structure of all the clips and all the audio and video and paes in between and so on everything was small segments of of different types and then I had sort of um first I had uh Vim bindings to navigate this thing and also um something what's it a call from emac uh I have this um lisp editing thing I forgotten the name oh um par edit yeah yeah structural editing yes so you can sort of shift entire Expressions sideways or upwards split them and and and ungroup them and so on oh so you're swapping chunks of video like their s Expressions yeah nice it's very geeky yeah it was uh strange uh and uh all these operations could be undone and redone and it was really hard to test all these operations loads of edge cases so are you saying you've got you've got this big tree structure I'm just this seems like a classic thing that I would find very hard to property test because I don't I don't want to rewrite video files a thousand times an autogenerated test and I don't really want to generate a lot I don't want to really hand write large meaty um starting states exactly so how did you teach me how to solve that those problems I I'll try to remember because I wrote this this became a series of blog posts and then later I rewrote it sort of as a a short book which is called um I think property based testing in a screencast editor very down to earth um and um okay so what if I recall correctly the the properties were some of the interesting ones were sort of using this undo redo as a way of discovering other problems okay so uh I had all these operations but I didn't test them explicitly like oh how should move up in the tree structure work or whatever operation um but I could generate just random operations uh a sequence of them and it was a bit more complicated because um you can only know what operations are valid once you're in a certain state so it was more back and forth like generate one operation apply it get a new state and then see what can be the next uh valid operation and generate one of those and you step forward like that for a certain length Okay so you're almost treating it like a state machine where each new state you ask which the transition States yeah what what are the the valid transitions from here and then you can generate from that list of of possible Transitions and do that for a while and you end up with a a trace basically uh of State operation State operation State and so on yeah so I did that and then I undid or like unly applied the same number of undo operations for all of them right then end up where I started okay so but to to answer your other question like how did I you don't want to write these big sort of timeline um starting states to test against because it's a sort of Maintenance problem and and boring so with property based testing you you normally have like you write small generators there are a bunch of built-in generators for all the regular types the the built-in types and so on but then you can um you can build your own generators that sort of piece together other generators so I could Define a generator for this whole timeline and that in turn used um generators for like audio and video clips and so on and they weren't actually real audio and video clips I had some kind of generic type parameter somewhere I don't remember exactly but uh so they weren't actually generating files on disk it was just in memory structure so what is it generating a gigabytes worth of binary Randomness or what no that part it didn't actually hold any video data it was just a structure okay I create an empty clip with some metadata yeah right because the operation didn't touch the actual videos I can ignore that part and and just parameterize that with unit or something okay yeah and um okay and then uh this undo redo I had some other properties on on that in that sort of style so like do a bunch of things undo all them all of them and then redo all of them then you should end up at the furthest end before you start at undoing that makes sense and then yeah you might think like okay you're only testing undo and redo that was G to be my next question yeah but which is useful but because of how I implemented undo redo so each operation had its inverse as a separate implementation right so if you could uh let's say if you had a clip which was um or or it was called sequence and it had a bunch of like audio parts in in a sequence if you could split that at a certain point you could also join it together and that was sort of the inverse of splitting was joining okay um and by doing this whole undo redo thing in in random ways all these uh inverse operations were also executed and they had to agree in order to produce the same so I had um uh loads of small um like off by one errors and stuff like that oh yeah yeah I can believe that and those were uncovered by doing these sequences um I could probably find most of it by just doing uh the the inverse round trip kind of property um but uh it like doing it together with Andrew redu sort of did the whole thing in this catastrophic mess that uncovered a lot of bucks so um it was a nice experience it took like two weeks to just fix all the B didn't take so long to write the properties but I was just scratching my head for like two weeks trying to figure out the bugs and uh getting getting all that that's the interesting thing when it turns up bugs you didn't expect to see yeah right and I I I had experienced bugs while using the screencast tool I knew that there was some something going on I couldn't really pin it down I was like what what what happened there uh did I what did I do like it's hard to should I like record my screen on my keyboard to to be able to reproduce and um yeah that was really cool and um to find them that way uh so I I just did like bug fixes and and following the tests for basically two weeks and when I came out the other end and I started a screencast editor everything just worked was just me perect that's nice that's nice if you would to spent those two weeks the hard way right spread out over the next year yeah just bug reports or whatever pain and trying to figure out what was going on so um that was one part I I did property tests for other things I had um I could bring that up as well it's a I think a nice example I had this the workflow was based on just was recording uh screencast video and in between sort of scenes I was just silent because I was so I did part of the screencast and then was silent and didn't touch the keyboard and uh was just thinking like okay what's the next part maybe looking at a little script or something yeah yeah um and then when I imported this into my editor I wanted everything to be chopped up by those silent Parts because I don't want them yeah makes sense so I had this um sort of processing part that um uh it it um analyzed the video and audio and found out like here's a pause and let's just clip uh or like trim it down to the end of the audio and trim the other part to the start of the next audio and so on like so if it's completely silent for 5 seconds assume it's a pause and find the ends of that silence yeah yeah yeah makes sense so um that was sort of the scene classifier I wanted to test this with a property test as well and um I couldn't really figure out because your example there with the square roots and uh that is a good good analogy because I had the same problem like if I generate an input what should be what should be the output for this classifier well that's the problem right that's that's what the classifier does and I couldn't really figure out like how how should I express this without just writing another classifier again in the test yeah I mean I would instinctively say well at least I can write a test that says the output should be no longer than the input yeah that's and that's a good start like there are loads of this incomplete or sort of naive properties that do find actual bugs as well they might not be that like cover uh all of it and and be very precise but these sort of constraints are really powerful and I do recommend just doing that for a good while if you can't come up with something else that's just better than nothing because it's you might uh find unexpected things with just those basic sort of invariance or constraints okay okay I feel better about my test that seems kind of obvious yeah but is this what did you do is there something more sophisticated I can do than that test yeah um so what I did was after um I think a lot of being out on my bike and just thinking I I realized maybe I can generate the output instead and go backwards so that was sort of the the Mind twist that happened because I can generate the output which should be a list of scenes basically classified and done I could go backwards and say um if if I have these scenes I can um transform them into something that moves in video or audio that is sort of noisy or something and then uh in between I can put just uh same frame all over again oh okay or audio that just blank or something like that uh and then piece together that into an actual you know actual video or actual audio then run the classifier on that input which I've so I I I generate uh scenes which are just like basically from two Tim stamp that says here's some video going on and then another scene saying like Okay 10 seconds later there's some video going on which is also a scene so on and there's silence between which is 5 seconds or something uh I can take that map that into actual input it's the same thing as you said with the square it's easier to go in the other direction yeah uh and then I ran the classifier on that got some stuff out and I can just see that the scenes uh align okay I've not heard of that technique before so normal property testing you get randomly generated inputs you're saying get randomly generated outputs reconstruct the inputs the easy way yeah and then check your software reconstructs the outputs the hard way yeah that's oh that's a Jedi mind trick I like that yeah yeah it's a it's a nice one yeah um so on this topic I should maybe you can put a link somewhere or something there's this F for Fun and Profit website um which has a lot of f content of course but uh there was also this series on property based testing and there is one part which is um I forget the exact name but it's something like proper uh patterns for property tests or something like that okay has a bunch of these uh common templates on how to think about stuff you have the round trip property which is very nice if you have two functions that are sort of inverse as I said before like if you have a a render function and a parse function for instance yeah you can take whatever you start with uh apply the render function get a string then apply the pars function to the string and get back your original input to go one one like if you were writing a refactoring tool that wanted an item potent no change practor yeah well that that is actually a different kind of input uh or a different kind of pattern which is sort of an item potency property which is if you apply the same operation twice you should or apply the operation once you get a result then apply the operation once again you have the same result and you just keep keeping there but the round Tre properties sort of you have to have two functions that are mirrored oh yeah I see what you're saying so I was thinking a refactoring tool that passes the source code does nothing and then prints it back out okay yeah that you're saying could also have the test where it's like apply this refactoring five times in a row and it shouldn't take place more than once yeah sort of a fix Point refractor yeah fix points can tell you're a has school program you got fix points into the conversation reveal that's the tail uh yeah and um there are a bunch of others um I can just come up with them right now but um I think this sort of it's called something like um hard to prove but easy to verify which is your example with the square roots right and um then there is the really kind of big brain things and there is one technique called metamorphic testing which I haven't actually used it much at least I I've experimented with but not really found uh where I needed it yet Just for kicks can you explain it yeah okay then all right so metamorphic testing is sort of if you have an input and you apply your system of under test and you get an output um if you could slightly modify that input in some way so kind of let's say make it larger in a sense smaller or different in some way that you can know um then you can apply the the function or the system on that input and you get an output and if you compare those two outputs then you know that the output should be let's say smaller or bigger or something should have the same relation if you can express a relation or transformation between one input and another then you should you can say that the output should also have a sort of matching uh relation so the canonical example there would be if you have a search engine it's really trick to test that with properties like what should it give back right yeah yeah tricky uh but if you can if you do search you get some results and you do a research a new search with I don't know a date filter on it which wasn't there before slightly more constrained search then you should get a result which is a subset if you can observe the the entire result of course but the the output then should be a subset of the other output which was a bigger search yeah and then you don't really care what the input is and you don't really care what the system's doing as long as the relationship between the changing input I feel like I'm differentiating a graph in high school maths now yeah it's it's the rate of change in curve a the same as the rate of change in curve B yeah exactly you don't care in this case you don't care about either input or output basically you just know that well you you have some way of modifying input and and seeing that the output sort of behaves as you would expect uh but otherwise you don't you don't know much about either of them since I'm getting here is if you want to use property testing well you need to be sneaky yeah you have to think differently at least it's uh it's a a shift of mindset in many ways um but that's good again as we said it's like thinking you write this is one of the reasons why testers work as a separate Department you write some code and there's someone thinking about it in a completely different way to you putting it under test it would be so much faster and more efficient and sometimes less embarrassing if we could be that completely different person thinking in a completely different way and testing our code yeah right yeah and I think this helps um to get us more into that situation where we can test it not as we would think when when we implement it yeah yeah do you think so I'm thinking about your um screencast editor you have set this up so that it seems to be largely pure functions you're not doing writing stuff to dis right is is that a necessary part of this technique do you have to try and find a way to extract the the side effects of writing to a database writing to disk before you can do this well right it's very very good question because I'm I'm sort of still in pure function land right yeah and and that is nice if you can keep your architecture and your system under test uh in that space and and your test can be faster and it's just nicer to work with but it doesn't always work right so um as you said the screencast thing was I didn't actually run the full UI I just ran a model of the UI or this the the representation of the UI and um didn't actually have real video in memory or on dis or anywhere for properties so yeah it was sort of still P purely functional um but you can uh absolutely do property tests with side effects um but it it there is there are some some things you have to think about you have to keep it isolated for instance uh so each test has to be isolated from the next and um I do this at work a lot actually we we use there's this thing called test containers oh yeah which is uh is available for a lot of different languages but you can say like for this test I want a postgress uh Docker container running and it you can make it so that you always have a fresh database basically for each test isn't the tricky thing there though like property testing you're often generating 10,000 test cases yeah spin out 10,000 postes no exactly so but you can work around some of these things with like having transactions that you always roll back each test yeah yeah makes it a bit faster than running new Docker containers all the time uh but still you won't be able to run I don't know a thousand tests below a second won't be possible maybe there are other tweaks you can do but maybe we run like a 100 tests but over time because this isn't uh deterministic over time you test more and more different cases which is both good and bad so you I can see why it's good why is it bad I it's perhaps not bad but it could be frustrating when a test fails after two months now we discovered that edge case that we didn't think about yeah because you've been chipping away prob 100 test cases at a time yeah yeah and that particular time in CI when someone did something completely unrelated uh my property test uh you know failed this is why I think it's it's kind of essential right in property tests that you get this seed that gives you your receipt so you can replay you can make it deterministic yeah yeah you get a magic number that says play exactly the same set of random tests yeah so so that is useful when it happens is a you can at least reproduce it locally yeah but the person I don't know doing the pr might not be too pleased but someone some other test you know hav't Touch system yeah this just start failing now you've got unlucky to catch the bug that Dave wrote two months ago yeah that could happen so that that is perhaps the downside but um it does absolutely work with side effects as well but you have to be a bit more uh I don't know careful or think about how you should set these tests up and um what more yeah and then there's the whole UI bit because yes I didn't run the full UI in the screencast editor it was a gtk UI but that was also nagging me like oh does the gtk stuff work I don't know the the heavy lifting stuff underneath tends to work because I have all these tests but do all the buttons uh connect properly to everything and so on yeah cuz you know that real unit testing Department the first thing you're going to do is mash the click button all over your UI and try and crash it right yeah and I have like zero test coverage of that code so that's great and um yeah that that was nagging me a bit as well like I want to test the whole thing like end to endend Black boxy kind of testing uh which led me after a few detours into what later became this product called quickr which is an excellent name Oscar Wickstrom quickr love it yes I was forced to take this name for for the project and I but I do take responsibility of course it's an open goal you might as well Kick It In yeah and okay so this um this project um is about doing this sort of endtoend property style testing but on stateful systems or I more specifically which is what we did okay so um I had can I just stop you and ask why not selenium because that's most people's answer to this selenium or something like it yeah so mostly for the same reasons as any example based testing is limiting like you have to come up with examples you have to think of and especially with like selenium or whatever um scenario kind of testing that that you automate um there are a bunch of problems but one is that you like when you have the sort of stateful system where you do sequences of actions the combinatorics of that just blows up very quickly and it's it's very tricky to come up with enough sequences that are interesting to to catch like a lot of bad behavior and box and um so that is one part and um it's also kind of to maintain because experienced that yeah you have timing issues which have gotten better now with other Frameworks I think with like Cyprus and there there are a bunch of them and they have more like utilities to wait for stuff and not have like fixed sleeps all over the place um you do have the problems with being sort of very very uh tightly tied to the structure of the web app for instance instead uh which to be fair you still have some of that in quickr but not as much you don't have the so much of the timing problems you don't have so much of the coupling to the to the structure of the web page and so on so what you do in quickr instead and which is like I I didn't want to write so many selenium tests um is that you you sort of write property but but it's a bit different because um I had this idea like I want to use um a type of logic which is called linear temporal logic right so I feel the rabbit hole is just opened before us yeah so if if you've heard about t plus this is sort of the foundation common foundation so you have um the sort of the logic that you know the the propositional logic with and or implies all that yeah uh but then you extend that with some operators that deal with time so you can say something like you know X and next Y which means that X must be true in this state and in the next state why must be true can you give me a concrete example for a web page yeah um so maybe if I click a button let's say so I say that okay the button is visible and in that's like X right button is visible and in the next date if I have clicked I could do like if the action is Click then that implies that in the next state I don't know message should be shown something like that but uh maybe uh another more interesting one would be um there is an operator called Always which says that so the sub expression should always be true in all states so I could say something like there is always either a login or a log out button on every page yeah yeah should always show I don't know a link to a support email or I don't know something could be sort of you can start thinking about it sort of as kind of business rules or you know requirements for your page yeah uh or it could be there's an operator called eventually you can say in the future sometime this must happen eventually so give me a concrete example okay so if you click a button which launches I don't know HTP request you might see a little spinner going on and then you wants to eventually get some result back some data shown or maybe an error message okay I've WR some code this morning actually that eventually should show a chart yeah so yeah okay every async thing yeah in UI that would be one example and by using this logic with these temporal operators you can express these requirements and you can if you do this in a certain style you can express sort of your web app as a state machine which fits some web apps and U you can say like um basically your your um your specification says that this web app always goes from one state to the next in a valid way that's the state machine kind of definition and then you say okay what does it mean to go from one state to the next in a valid way well you sort of um you just list all your valid Transitions and you combine them with or and this is a very sort of TLA plus way of describing a state machine so if I have you saying if I I mean I would expect web page to there's always a signin button and then I do some stuff and hit submit and then I get to my account page and that should and then will the software then go and try and find ways to get to the account page without me doing that uh it wouldn't be uh so directed it would be so when you have the spec you can just run quickr basically and it it basically just does random things but um random possible things so in a web page that that's the sort of the neat trick because you can inspect the web page and see what buttons are available right now which are disabled or enabled which links are there what can I do basically so yeah that sort of reflecting capacity is already in the browser by by talking to the browser and then F room goes around and does random things you can constrain that as well but um you can be very open and then it checks while it runs does the behavior of the web app agree with your specification so this is like your video editor where you say okay I'm now in this state what are the possible transitions out of this state which in P of web page of buttons and then you're just clicking random buttons going along random timelines and trying to find and checking that it doesn't break any of the rules as you go yeah yeah okay yeah yeah exactly so the nice thing is that you don't have to list all the valid transitions because the web page already sort of embodies the the valid transitions yeah yeah it's advertising its own State machine from a certain point of view yeah yeah it's the um it's the um what do you call it like hyper media aspect of web apps it sort of encodes its own State machine in the output of the HTML yeah I I mean I've thought of web pages as being like State machines but I've never thought of them advertising their transition states to you of course they do yeah yeah that's neat or or you could build them not doing that but that would be kind of bad like if you have a lot of loads of buttons you can click and then it's like no that was a wrong button that's not a valid transition yeah yeah we just give you all the buttons in the entire system and then complain when you hit the wrong ones yeah I bet you there's one website out there that does it just through bad design probably some time reporting thing yeah but but that's really of the principle of of quick so you write this spec and you say what what is correct behavior and you can be very detailed or you can be very loose and and Abstract you can just say like I only care about this login log out button that's all do other things go around the website do whatever you want I just care about this login button being correct for instance or you could be very like complete and say these are exactly the transitions that are valid and this should be the result after each transition and so on yeah yeah I'm thinking I think I've got this right there isn't there a law in Germany that says You must have an impress like contact details page on every web on every page well U I'm not a lawyer so no no but we can imagine a rule like that with the government says this must appear on every page and you would just write the rule for that yeah and that's that's it and then it just goes around doing random stuff and checking that your little contact thing is there and just to be clear is it checking I can set up multiple properties and it will test them all as part of the same Journey yeah so if I've got a thousand properties I want to check it doesn't do it doesn't multiply the execution time by a thousand no you compose different logical Expressions into one spec okay so this is always a tricky question to ask in a podcast but we have to try what's that actually look like when you write it what's the what's the coding language ask you to say yeah so there are two parts to these Quick St specs um one is this um it's called The Proposition which is sort of the what is correct the expression that describes the correctness um which has all these um the the the temporal operators and all that you also have in those expressions you can uh you can write selectors which are like CSS selectors you can get access to an element in the Dom and then you can um pull out like attributes properties Styles stuff like that from those elements so that you can say like okay this element on the page this should have a text content that is Fubar and it the color is red or something like that or it has an attribute which is X uh so you can express all these um kind of assertions or uh logical truth statements about uh elements in Dom and you well you just compose all that up into this proposition the other part is that you can declare actions which are so um out of the box quickr has a knowledge on a page what are sort of valid actions but um kind of but uh you can also say like okay don't click all the buttons uh click buttons uh click buttons in this part of the page only when this condition is true in the current state so you can constrain it and say you can also chain stuff to say like if I did this before then do this afterwards you can sort of direct it in certain ways okay but most of that is if you have a web page that very clearly encodes what is desirable sort of behavior Next Step uh you don't have to say much you can just say click anything do anything but if you want to be more detailed you can be be that and it ends up looking very much like code or yeah I've maintained selenium tests and it always felt a bit like I was poking around inside the back end of a UI That was supposed to record things yeah but does this look like more of a programming experience declaring properties kind of yeah uh it's so quickr started out with the first version it was actually a pure script DSL okay um so and it was a lot weirder than you might think because I actually built my own P script interpreter I just used P script to parse P script as a sort of frontend language and and wrote this um pure script interpreter in husk for it you don't like to do things easy way it's it was a kind of a good fit uh but bit tricky as well but the nice thing there was at least in principle you could use P script libraries so I I ported so P script has these um kind of stubs or native parts that uh you have to write in the the runtime language so JS and the normal usage of of JavaScript so those I had to implement for certain libraries but you could use like weird monads stuff or whatever you wanted to do uh common P script libraries in your specs so that was nice because I got a lot of things for free like string manipulation and stuff like that just kind of worked out of the box but then we rewrote quickr in a in a different version which in which we there were some limitations to the pure script edsl thing right so uh we decided to write a a custom language for it okay so so there is quick Strom the language as well as quick Strom the tool yeah yeah and that is it has some shortcuts and it does some trade-offs to be able to analyze um sort of analyze the language or the the spec uh for certain things so we know statically like all the attributes uh you ask on ask for or all the properties all the Styles all that stuff that you ask for on certain selectors we all we can analyze that statically and and optimize the queries basically okay yeah so we needed that for a certain reason and uh couldn't really figure out how to do this pure script so and just syntactically it's a bit nicer but it's sort of like a functional language in a sense it's just one big Boolean expression but yeah okay so you write these small specs and uh so we have one where I work and it's like 90 lines I think and we have barely touched it in a few years so uh it's it's pretty nice but um of course like it's not the documentation is lacking and uh no editor support I have some basic editor support So Works in emac and intell but uh yeah okay depending on who you are that either covers all the ones you want or none them that's editor Wars for you so what's the license for this it is bd3 okay so there's an open source tool I can just download and use yeah when I started it I had some ideas of doing sort of a business side of it and have like a dual license thing U but then it took another Direction so U that is the the current state yeah sounds like our gain yeah do you ever try have you ever tried running out another people's sites found bugs with it because presumably it's doing a lot of testing you ever attempted to do that yeah so when we did this second version of quick Strom um when I say we it's me and uh Liam OK Conor which uh he's an academic and uh we uh we found each other on Twitter uh talking about what was it fstar and uh proving certain theorems around temporal logic and stuff like that and and uh we realized like okay this quickr thing is a nice academic project if we want we sort of working on that together and this new language that we did and U sort of the infrastructure of it and the model of it all that turned into a paper ah what's paper called I'll put a link in the show notes uh it's called like quick Strom testing uh what is it called testing with linear temporal logic something like that though that sounds like a properly academic title yeah in there somewhere and then you go to the web page it says quick Strom for not tearing your hair out over selenium exactly as you adverti to two completely different sectors marketing language does not have a place in in Academia um so I got to be a sort of a got into the academic realm the the the backd drawer in a sense um I haven't done much better funding that way from what I hear maybe but that was really fun and we did uh a case study or a sort of evaluation uh in that paper where we there's this old project called to- do MVC yeah where they it's been around for many years hundreds of different implementations of it as people prove their ideas yeah yeah so well just short it's uh to-do list lists in in like a 100 different front end Frameworks and languages ah so I thought like that should be a pretty cool testing ground for our yeah so we wrote One spec for all of them and and just tested all of them and that spec was really really detailed it was like if you have if you're in this state this is a valid transition it says like if you change the filter from viewing all to do items to completed items only the completed ones should be visible in the next St and so on lot of uh and I didn't even know to do MVC has this edit mode you can double click items and you turns into an input and you can edit them and so on um and we just tested ran loads of test on these um these apps and we found that like more than half of them were broken in some way oh so that was that's nice yeah I mean it's not nice it's it's initially terrible news but in the long term it's nice yeah and I mean some of them were broken in like it doesn't even load anymore because someone had brought a server down or something but most of them could actually be run uh and they had all kinds of strange we had we had this table of I don't know 12 13 14 different types of problems they had and some of them were really like uh kind of complex like if you did this had this filter on started editing pressed Escape then change a filter then it broke something like that I I don't recall all the details but um to be able to generate something like that without having to specify as an example that set of steps that's nice yeah yeah and do you do you get this property that most um property testing things have I shouldn't double use the meaning of the word property do you get this receipt do you get this token that says and if you want to reproduce these steps that crashed this app rerun the test Suite with this magic number we don't with quick strum um we don't have that seed can we have that in version three I mean we could add that but there's actually no guarantee that you can reproduce it um and you could end up in that situation with any property based testing framework really if you have non determinism but there might be sort of timing aspects for Stuff so that even if we apply the same actions in the same sequence um I see do I at least get like a report of what sequence of steps led to that point yeah you get there's this there's a textual one in the console but there is a more usable one which is an HTML page it spits out where you see State action State and you can sort of next next next and you can go through this trace and see what happened you see the state of all the elements that you have uh queried and so on so you can inspect what went wrong okay and it always it always ends the test once it's found a problem so it doesn't always run like a 100 steps when the spec fails whenever that happens um it ends there so you know sort of in the end of the trace there is something going on probably okay and how does it know when to um when to stop if it doesn't find a problem you just say run for 5 minutes so yeah you can you can specify these sort of we call them subscripts but you can say like if you have an always alwayss operator somewhere you can say like always at least for a 100 steps okay so you can sort of specify some time constraints or like if you have an eventually you can say like okay wait for at least 10 steps before you give up right okay and then there's there interesting aspect of uh um with eventually if if you have a condition that you expect to to eventually hold and it doesn't it might not mean that it would never hold it just means that you gave up too soon perhaps so the result of the test are uh definitely true or false or maybe true or false it's a bit tricky so if you say that eventually the spinner should turn into a result and it doesn't and the test give gives up uh then it says well maybe that that was false yeah yeah like eventually Spotify should show that this podcast has a million subscribers but I might have to wait for the test to run a bit right yeah fa enough yeah I think that probably gives me all the information I need then to at least go and test my code that should eventually show a chart that' be a good little property to start with right could do that for Qui room I think yeah okay I'm going to give it a spin yeah Oscar thank you very much for taking us through it yeah thank you for having me here that was uh very fun to I I had to reminise about uh some stuff that I forgotten but some details but it's uh very nice to bring up yeah we are all both the programmers we are today and the history of the things we've programmed in the Years Gone by right yeah yeah absolutely cheers catch you again thanks bye thank you Oscar and I have to say Oscar's my kind of geek he's got a bit of Academia he's got a bit of business and the thing connecting the two is just someone that wants to build and Tinker with stuff and learn the world needs more people like him so yeah in fact I think the world needs more people like us we're all that kind of person aren't we I think we are around here by the time we've reached the end of the podcast I think we're all like that so if you want to feed those parts of your your soul head to the show notes where you'll find links to papers tools sites software all the ideas we just discussed that will give you something to chew on for the coming week while you're down by the show notes please take a note of the like share rate subscribe buttons I was looking recently of course I look at the analytics I was surprised to see how many people share this podcast so thank you to those who have done that's a heck of an endorsement when send something to a friend and say hey look at this thank you I appreciate that we'll be back next week with another episode of course I'm actually playing catchup a bit because I just spent the week in Montreal at a really excellent Tech conference K Fu would recommend there'll be another one in 2025 so take a look full of ideas from that lots of potential guests but lots to catch up on so I better get on with it until next week I've been your host Chris Jenkin this has been developer voices with Oscar Wickstrom thanks for [Music] listening