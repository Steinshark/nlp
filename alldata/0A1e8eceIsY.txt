so today I thought it'd be a good time to revisit the subject of how computer memory works if you remember from a few previous computer files several years ago we looked at how we could store information a single bit of information in an electronic circuit so we took the classic nor gate we took two of them in fact vaguely an or gate and we wired them up so the output of one fed back to the input of the other and vice versa and they only had two inputs in that could be used to reset or set the output and we had two outputs that were the opposite of each other and this circuit if you built it you can go watch the previous episode would be either be set to be one if this pin was taken one and you would remember that it been set or you could reset it if this bit was taken to be one which point it would then go to be false or zero until you changed it and that circuit would remember a single bit of information and then we saw how we could build that up and use multiple of them to store lots of information we gave each one an address and then we arranged them in and a grid and we split that address up to refer to the row and column so we could access each individual bit now that stores single bits and we can have multiple ones that we can address individually by giving it a binary address and if we wanted to store multiple bits all we do is have multiple ones then want to store each bit and run them in parallel so we'll concentrate on using a single [ __ ] but if we look at a normal memory chip as a sim from long ago but is actually one two three four five six seven eight different chips on here that are used to store each of the individual bits that make up the bike we can build this circuit it stores a single bit of information but we're using four transistors minimum to store each bit which seems a lot and is there a way we can store it using less now this type of memory is what's called static RAM because once you've store the bit it'll remember that until the power turned off as we said before we can arrange these into a grid and so let's say we're gonna use store for bits I story one bit that's doing another that's doing another that's doing another and then we can address them from the row so this would be Rosie Rose you'd be wrong this would be column zero this would be pollen one and then we can refer to each individual cell on there and we could expand that out we could go up to four by four and so on and now we can refer to any of the 16 things by giving it address those 0 0 0 1 1 1 0 0 1 1 0 1 2 1 1 1 1 over here but as we said we need to use 4 transistors for each of these cells and that's going to sort of set however much silicon we've got that's going to be the limit of how much RAM we can get on there unless we can get the size of this down so is there a way we can build a memory circuit which uses less than four transistors the answer is yes but it comes with a problem the advantage of building static memory like we saw before is as soon as it's turned on and set it remembers that until you turn the power off if you want to reduce the number of transistors used we have to compromise that and say ok we're going to let the memory forget we're going to build a memory circuit that inherently is built to forget that the information is stored and this is what we use inside all computers these days the memory that you're building will forget what is stored after about 64 milliseconds now how does that work well the way we do that is by using not just a transistor but a transistor and a capacitor so we build each memory cell rather than from four to six transistors we build them from one transistor and one capacitor now why does that work what I've got here wired up is an LED resistor just to stop it exploding or the coolant getting too great for it to be more accurate and a switch so I can turn it on and off and so the circuit is relatively straightforward we've got a power source I have a switch I have an LED giving off light and I have a resistor probably 330 ohms that classic thing when I close that switch that light comes on but let's also modify that circuits line you said that we've got a capacitor in there what we're going to do is we're going to wire it up so we've got 0 volts now return down here we've got +5 here and we're going to put the capacitor in parallel with the LEDs or so in our switch and we're gonna have the LED and the resistor but alongside that we'll have the capacitor as well so that's why that up and we should see a difference so when I turn it on now when I press the switch a light comes on when I let go it goes off for those interested at home I'm using a 470 micro farad capacitor here so we put that in the circuit and now when I press the button the light comes on but when I let go it gradually dies down click it and the light dies down though what's going on here well the capacitor is a component that stores charge so as I close this switch current flows down through the LED but it also flows into the capacitor and it stores the charge of charge accumulates between these two plates so the current flows down here at the lights the LED when I close the switch but it also flows down starts to charge the top plate of the capacitor so that when I let go of the switch the charge can then flow around this to form a circuit but the charge is a new small amount and it as we see it decays over time and it starts to run out but that capacitor actually stores whether it's at 5 volts or at zero volts if we don't charge it then it's a zero volts or it's at 5 volts and you store that for a short period of time in that canoed of time is dependent on the type of capacity if I change this for a 47 micro farad capacitor make sure I get it the right way around otherwise there might be an explosion the same thing is happening as the slow motion shows changing the capacitance of the capacitor changes the amount of time that the information is stored for a larger capacitor stores it for a longer period of time but we've got a problem we've got a circuit here which can store information for a short period of time and the capacitors typically used in dynamic Ram circuits in the computer the recommendation is that it'll last for about sixty four milliseconds or a bit longer but that's no good we want our computer to remember things so how do we get around it well let's look at the circuit again as I press it we can see it's decaying and if I wanted to store that I could say that's obviously our now again and I'll press it again and I'll press it again and every time I press it it starts the decay process from full brightness again and as long as I can refreshing what's stored in there and keep pressing the button then it stays on and it stays on and it stays on and that's exactly what the computer does every 64 milliseconds it looks at that bit of information that's stored on there works out whether it's a zero or one that's been stored and stores it again and then 64 milliseconds later it looks at it and stores it again and on and on and on and on and so on so we've got a circuit now that can store a bit information for a short period of time but we need to refresh it otherwise we lose the information in there actually this is not that much different from the first computer core memories that we use way back when when when you've read the information you destroyed it so you have to store it back in again so it has precedent but we can use this as the basis of a thing because we can build a capacitor in a single transistor in much less space when I say they can ship than we use for transistors to do it we store it in exactly the same arrangement and rather than having a physical switch like I had there we use a transistor as a switch so each of our cells will become a capacitor which is connected to ground and we have a transistor and then we can put them into a grid arrangement as we had before and again we can address them as zero zero zero one one zero one one for the row and zero zero zero one one zero one one for the column but we have another problem with the static Ram chips that we had before they store five volts or zero volts with a capacitor as we saw it's decaying as it's going on so rather than just having the values coming straight out the capacitor you need to have some extra circuits here which are called the sense amplifiers which take the value from the bit and convert it to being a zero or one at zero or 5 volts or whatever system the computers using so we can't just take the value directly like we could before we need an extra bit of circuitry in there to amplify it to the right levels and the way these are arranged is that you select a particular row of the dynamic Ram circuit let's say we want to select row zero one and the sense amplifiers are then switched to be connected to that and whatever values are stored in there let's say we've got one zero one zero and then sort of read from there and they're produced out as the output at the end and this leads to an interesting property because whenever we select a value from memory in dynamic Ram we have to copy this through the sense amplifiers and then it's buffered using effectively some sort of static Ram type stuff after that which means that it takes longer to select a new row than to switch between a different column so once we've selected a row so be very quick to switch from reading on this row column 0 0 to column 0 1 but we'd have to reload the things if we wanted to go and read from row 0 0 column 0 0 so if we can speed things up slightly by reading across the row each time and actually if you use a CPU cache you can preload your cache lines by using that but what we can also do is once we've read this in we can sort of feed the values back in to refresh our circuit and this is called dynamic Ram refresh and you need to build that in if you're going to use dynamic Ram on your computer which is what most computers do these days you need to build that in to your actual system and these various ways you can do it you could do it literally in software the original Sun one micro workstation actually had code that refreshed the dynamic Ram every 64 milliseconds it was an interrupt it was fired and it just went through reading the values from each of those locations which caused the RAM chips to update it problem with that is if your program crashes then you can't debug it because your whole memory gets wiped so these days is actually usually built into hardware and actually what will happen is after a certain amount of time 64 milliseconds the hardware will go through and refresh each of the rows of the dynamic Ram in turn to refresh each of the memories the data that's stored there now actually in reality you probably won't do it all in one go you'd stop it regularly and do a row at a time and go through then you'd start again each of the way through and there's lots of support built into various chips to do this it's an interesting thing about this though when we built static RAM the data is stored until the power goes off as soon as the power goes off then the value is stored we're using capacitors here and so it's an interesting side effect in that perhaps can share it with this I haven't wired this up but I'm gonna turn my light on and charge it and rather than letting go the switch I am going to pull the power supply out and even though there's no power into the circuit because that capacitor is built at charge as I remove it then it still stores a bit of data and this actually happens in your dynamic RAM chips if you pull the power where as static Ram would forget everything the dynamic Ram chips store the data for a short period of time and interestingly while the dynamic RAM chips manufacturers say you need to refresh it after six before 64 milliseconds is up in reality it can sometimes be a bit longer I've seen computers where this has managed to stay for over 10 seconds after the powerful machines and actually one of the security risks for computers that the capacitance change is dependent on temperature so if you get hold with someone's computer and make it very very cold and reboot it in a particular way you've a good chance of being able to recover data that was in their memory so we can start off by putting a NAND gate in here connected to that so now we have when a in contains 0 we're gonna do is try and find the peak ok these these values so actually we're starting off in focus here and we've got a value of about 5 million