what's up everyone james murphy here from 
mcoding.io where i offer live online courses   in python today we're going to be talking about 
how to find primes using the sieve of eratosthenes so before we can write the sieve of eratosthenes 
first we have to understand what the algorithm is   here's the main idea you start with a big array 
let's say we want all the numbers that are prime   less than 100 then we'd make an array of length 
100 full of booleans the booleans are going to   tell us whether the number is prime or 
not initially everything is set to true   and then we're going to go through and 
successfully mark composite numbers false   so first we start at 2 that's prime then we take 
all of the multiples of 2 bigger than 2 of course   and mark them as false because they're composite 
then look through our array and the next thing   that's still marked true has to be prime that's 3. 
do the same thing for 3 mark all of the multiples   of 3 that are bigger than 3 as false then look at 
the array again and you'll see that 5 is the next   smallest thing so let me show you a little graphic 
from wikipedia that shows the algorithm in action   okay so as you can see right now it's going 
through marking out all the multiples of two   then it finds three as the next prime number it 
marks out all of those and then it finds five   and then it marks out all the multiples of five 
and then it finds seven then marks out all the   multiples of seven and so on and so forth so the 
idea is go to each number that's marked true and   mark out all of its multiples as false then as you 
go through the things that are still marked true   as you go in order up from two you'll find that 
all of those things that are still marked true   are primes okay so now we understand the general 
idea of how the algorithm works let's get into how   to actually implement it in python so i've already 
written here just the definition of the function   we're going to be calling it primes less than it 
takes an integer where i want all of the primes   that are strictly less than that integer and i 
wanted to return a list of integers the primes   so first off let's get rid of some trivial 
cases if n is less than or equal to two then   well there are no primes less than two 
so let's just return the empty list otherwise let's make an array which 
tells us whether a number is prime   so we're going to have booleans in the 
array that are all initially set to true   and i want the length of the array to 
be n so 1 for each number in our range then of course i will initially set 0 and 1 to be 
false so is prime of 0 is false and is prime of 1   is also false because 0 and 1 are not primes next 
we go through and start marking out composite   numbers so we'll go for i in range of 2 to n now 
actually we don't need to go all the way up to n   because if you have a composite number 
then it has at least two factors   and one of those two factors at least one of 
them needs to be less than the square root of n   so we don't need to check all the way up to n we 
only need to check up to the square root of n so   let me actually change this i'll go ahead and use 
the built-in i square root function so from math   import i square root to get the smallest or sorry 
the largest integer less than the square root of n so this will allow us to not have to   go all the way up to n but only up to square root 
of n so that's going to be much more efficient   so i'll go through all the numbers from 2 up 
to the integer square root of my number and   then i'll check to see if i have a prime so if is 
prime of i and if so then i need to mark out all   of the multiples of that number that are bigger 
than that number so i'll say for x in range now   another optimization that i can do here 
is i can actually start at the square   of i and the reason for this is 
again if i had a factor that was   less than i then it should have already 
been marked out by the the previous iteration of the loop so in fact 
all i need to do is start out with   the multiples of i that are bigger than or 
equal to i squared so we'll start at i squared   and go to n is the biggest and if i started 
i squared which is multiple of i and i jump   by i each time then that's going to give me all 
those multiples so just to remember the order of   the arguments here the first one in range is the 
starting value the second is the stopping value   not including that value and then the 
third is the amount to jump by at each step   so i'll go through these and then 
mark everything in here as not prime then that's basically it i just need to now 
return the ones that are still marked prime   at the end of it so i'll just say return 
i for i in range of n if is prime of i   and if i didn't make any typos that should 
be it so there you have it 2 3 5 7 11 13   17 19 and so on that looks good to me 
so there you have it that's how you can   find all the primes less than a certain 
number using the sieve of eratosthenes