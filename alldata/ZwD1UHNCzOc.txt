hi everyone in this episode we're going to be importing our character into the unity game engine and we'll also start programming the basics of our character controller all right so with a new Unity project open I'm going to head over to where I have the character blend file stored and just drag and drop this into the project window and it'll take a moment to import and we can then go onto the rig settings here and we will change the animation type from generic to humanoid which will give us access to unity's inverse kinematics features which we'll play around with a little bit later on in the series uh for now we'll just hit apply and we can then press configure to see this all set up and hopefully your little guy is all green which means that all the bones were correctly set up in blender uh one thing that's a bit weird is the characters pose over here what we should do is just double click on our character to open the blend file and we can just close the animation and then here in the scene just select all of the bones in pose mode and press alt R alt G to get him back to his uh standard T pose and then we can save and in unity we can then just come down here and just tell it to reset the pose and it's now in the T pose all right let's say we're done and yes we want to apply wait a moment and then let's head over to the animations tab and we want to go through all of these and just say Loop time so that they will Loop when they're finished playing so do that for the walk as well and then press apply okay let's grab our character and just drag him into the scene and we're going to want to create an animator controller for him so right click in the project window create and and where is that over here create a new animator controller and I'll just call that animator and then we'll select the character in the scene and just drag the animated uh controller into the controller slot here now because we animated our character walking and running on the spot we're not going to be using root motion but I would like to quickly talk about root motion for those of you not familiar with it so the idea is to actually animate the root bone of the character for example in a walk animation the character would be animated to move forwards this St was then used to move the character around in the game instead of the traditional uh approach of controlling movement from a script the big advantage of this is that you can properly time movement to the animations eliminating visual problems like foot sliding so working with root motion allows one to create more natural looking movements but what you lose is the ease and precision of controlling the character's movement from script this can often lead to the play movement feeling less responsive to input which obviously detracts from the game play I certainly don't mean to deter you from ever using root motion one can get great results with it uh but for this series we're going to be sticking with script based movement okay all of that was just a really long way of saying that we're going to be turning this toggle off let's then double click on the animator to bring up the animator window I'm going to middle Mouse drag this is properly in view so we want to create a blend tree so that uh we can blend between idle walking and running based on the character speed so we're going to right click here say create state from New blend tree all right and if we go into our parameters we can see it's added in a blend float uh let's rename this to something like speed percent and then let's double click on our blend tree here you can see it's got uh a list of of motions which is currently empty we can press the plus button and just add in three motion fields and then let's fold out the character model here so that we can see the animations we'll drag the idol animation into the first slot then the walk into the second and the run into the third now I'd like to be able to see the scene view I'm just going to dock the game window down here and then drag the animator out into a separate window just like so uh let's press play and we're going to need to make sure that we select the character so that uh the animator for the character is active and then we can play with the speed percent value uh currently the animations are looking a little bit weird uh you can see the character isn't uh moving up and down and it's a little bit jerky what we need to do is go on the character here and just uh go into any one of these animations let's go into the motion field and just set the root motion node to be root transform if we then hit apply that will update for all of the animations and if we try this out now we can see that the animation looks uh correct and we can drag this up to one to get them running and bring it back down to zero to return to the idle animation of course this speed percent parameter is going to be controlled from our player controller script which we'll create in just a moment I first want to make a ground plane though for the character to stand on uh we can just use a regular plane but I'm going to import unity's prototyping package so we can get the nice grid floor so just assets import package prototyping and uh I don't want any of this crossplatform input or utility stuff just the prototyping one so let's import that that wait a moment and when that pops up in our assets we can go over to the prefabs and I'm going to look for the floor that's awfully small it's not the one I'm looking for maybe this one no the third one that's the one all right let's just reset its position all right that's very nice um I'm going to want to make my game window a little bit bigger so I'm going to dock the animator over here and just bring the game window back all right like so and let's right click here and just create a new C script I'm going to call this the player controller okay let's double click to open this and in the update method going to start off by creating a vector 2 for the keyboard input so Vector 2 input is equal to a new Vector 2 and we're going to get the horizontal input so input. get axis rule horizontal and then for the y- AIS that will be our vertical input so input. get AIS raw vertical let's now take our input vector and turn it into a Direction so we can say Vector 2 input Direction is equal to input do normalized from this we can figure out our characters rotation using trigonometry so imagine this line is our input direction we of course know its vertical and horizontal components and we're trying to find the angle it forms which we can call Theta if youve studied Tri all you know that tan Theta is equal to opposite over adjacent so Theta is simply AR tan of YX this assumes that we start with 0° over here and increase anticlockwise in unity however if our character is facing forwards then it has a rotation of zero facing right it has a rotation of 90° and so on so let's call R the rotation of our character in unity if you look at the two circles it's clear that we need R to be 90 minus Theta in order for our character to face the correct way we can simplify this a tiny bit by saying R is equal to Mar tan of X over y all right let's go ahead and set our character's Rotation by saying transform. Oiler angles is equal to Vector 3. up since we want to rotate around the Y AIS multiplied by what we just calculated so math f. aan of input Direction dox divided by input Direction doy now of course if input Direction doy is zero we're going to get division by zero errors so instead of having to worry about that ourselves we can use the handy math f. 8and 2 method which allows us to pass in the two values separately and it will worry about all of that stuff for us so we can just say input Direction dox comma input Direction doy instead now this arctan method is going to return the angle in radians and we want it in degrees so we're going to just multiply this by the conversion factor which is math F do radians 2° all right if we save that now and go into Unity we'll need to quickly add the player controller script to the character object and then we can test this out by pressing either the arrow keys or WD and we can see the character rotates around uh one thing that you will notice is that if you release uh all of the keys the character will snap back to facing forwards so what we'll want to do is only calculate the rotation if the input direction is not 0 0 so in other words if input direction is not equal to Vector 2.0 then calculate the rotation next we can make the character actually move in the direction he's facing so let's create two public variables up here a public float walk speed I'll set this to two and a public float run speed maybe set that to six so let's say you have to hold down the shift key to run so we can say Bo Running is equal to input. get key key code. left shift and then we can say float speed is equal to and this is going to depend on whether we're running or not so let's open parenthesis es and say running and then question mark to say if we are running then speed is going to be equal to run speed otherwise so colon speed is going to be equal to walk speed now of course if we aren't holding any Keys down then the speed should be zero so let's enclose all of this in parentheses and multiply it by input direction do magnitude so if there's no input the magnitude will be zero uh in which case the speed will be zero otherwise the input directions magnitude will be one uh which won't change the speed all right so now to actually move the character let's say transform. translate we want to move in the direction the character is facing so transform. forward multiplied by the speed we calculated multiplied by time. Delta time and we want to uh move the character in World space so we're going to say comma space. world all right let's save this and try it out so press play and we can move around and if we hold on shift then we move faster okay let us now uh control the speed percent value in the animator so that uh the character actually walks or runs depending on the speed so back in the script we can create a float uh let's call it animation speed percent all right so if we're running then this is going to be equal to 1 otherwise it's going to be equal to 0.5 and just like we did with the uh speed over here we're going to multiply this by input Direction Meg magnitude all right now we need to get a reference to the animator component so let's say animator animator and then I'm just going to remove these comments quickly in the start method we can say animator is equal to get component of type animator all right and then we simply say animator do set float we need to give it the name of the float which is speed percent make sure you spell it exactly the same here as you do in the uh animator window and then we pass in the value which is our animation speed percent variable okay let's try this out so here we're walking if we stop we go back to the idle animation and if we hold shift we run and we can go into the animator here and actually watch the Speed percent value change as we do this all right so we've got the basics of our character controller working now but what would be nice is if uh everything wasn't so abrupt if there was some smoothing uh both to the rotation and to the uh speed adjustment so let's start by smoothing out our rotation so instead of directly setting oil angles to the rotation value we're going to treat this as a Target rotation and will'll be smoothing Oiler angles towards it over time so let's cut that out and create a float called Target rotation set that equal to that and then we'll set transform. oer angles equal to Vector 3. up multiplied by our smoothing function which is math f. smooth damp angle we want to pass in the current angle which is transform. Oiler angles doy we want to pass in the target Target angle which is just our Target rotation variable and then we need two more variables which we can create quickly first of all we need a float called something like uh turn smooth time I'll set this equal to 0.2 by default so this is just approximately the number of seconds that it will take for the smooth Dum method to go from the current value to the Target value all right then we also need a float called something like uh turn smooth velocity now this variable we don't ever modify ourselves we just sort of feed it to the smooth damp method and it makes use of it in its calculations so when we're passing in turn smooth velocity we need to start with the keyword ref uh which just allows the smooth damp method to actually modify its value so ref turns smooth velocity and then we pass in our turn smooth time okay let's save this and test it out so we should see now that the Turning happens much more smoothly and uh if we increase turn smooth time so say I turn that up to 1 second then the Turning should happen uh more slowly like so all right but I'm going to set that back to point two let's now do the same thing for the speed so uh I'm going to rename speed to Target speed and then up at the top here let's create public float uh speed smooth time I'll set that equal to 0.1 and then we also need a float speed smooth velocity and also going to require a float current speed all right so then we can say just below Target speed current speed is equal to math f. smooth demp we pass in the current speed value then our Target speed followed by ref uh speed smooth velocity and then the speed smooth time and then we'll just multiply by current speed over here now we can also smooth out the animation speed percent and uh we don't need to create any more variables for this because the animator will actually do that for us we can just say comma and you can see it uh has options for a damp time so we'll just pass in the speed smooth time there as well and we also just need to supply the Delta time value so time do Delta time all right let's save that and we can try this out now everything should feel much smoother no more abruptness all right so that is actually everything for this episode so until next time cheers