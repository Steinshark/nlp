python 3.10's match statement is not a switch case statement this is probably the biggest misconception about the match statement and about any new feature in python 3.10 yeah python finally got its own switch case finally i can the purpose of the match statement is not to be a glorified switch case yes you could use the match statement in a way that sort of looks like a switch case but do you really think they would add this whole new feature to the language so that you could write match case like this instead of the equivalent less indented and shorter code using if lf and else don't get me wrong there are plenty of wonky features in python but adding in a longer way to do an if statement is not one of them but you might say wait i know a language that does have a switch case statement and in that language let's just use c for example there's an actual performance benefit to using a switch statement instead of checking cases one by one the numerical value of the x determines an immediate jump to the correct clause while python could technically implement this behavior in the special case that all the cases are compile time integral constants it's unlikely that a performance optimization like that would be added into python anytime soon for now and for the foreseeable future it really is just a bunch of if else checks if you really had a lot of cases and you didn't want to spend the time doing if else checks and you wanted to be able to put in an int and just immediately jump to the correct code you can do something like that using this kind of pattern make a function for each of the code bodies that you want to use then use a dictionary mapping each int to the code you want it to run then instead of using a match or using a bunch of if checks in your function just look up the value you want in the dictionary which gives you the code that you should call and then call that as a function morally speaking this dictionary is acting like the jump table that would be used to make the c code fast it provides you a constant time lookup of the code to run next and it prevents you from having to do a bunch of if checks the catch of course is that unless you have a huge number of cases this is probably going to be slower a real jump table would just use a linear function of the key to tell you how many bytes ahead in memory to jump immediately to find the next instruction this is of course not at all what a python dictionary does there's hashing involved and all kinds of other stuff which is needlessly slowing the program down so you're probably not ever going to actually want to do this but if you do think you have enough cases where you would actually want to do this make sure to measure first doing this absolutely destroys the readability of your code so please don't do this unless you've actually measured your code and seen a significant performance improvement so if the match statement just translates to a bunch of if else checks under the hood and it doesn't have any performance benefits like a switch statement then what's it good for well look no further than the actual name of the feature structural pattern matching i think the biggest use case for the match statement is matching inside a tree-like structure most notably i'm talking about abstract syntax trees and concrete syntax trees abstract and concrete syntax trees break up code in this case python code into a tree-like structure the tree is a recursive data structure where each node in the tree breaks down a part of the code into a primitive of the language here's the abstract syntax tree for this code we have a module whose body is a sequence of assignments the first assignment assigns the name a to the constant value hello the second assignment assigns the name b to the constant value subscribe a concrete syntax tree does basically the same thing except it also keeps track of enough information to be able to reconstruct the original source it keeps track of what kind of parentheses you used what kind of white space you used and it even keeps track of comments in a previous video i already talked about how you can use the built-in ast library to create custom code rules for your code base but the rules were very simple and didn't depend on any of the formatting of your code in this video we'll see how we can use libcst which is a concrete syntax tree library in conjunction with the match statement in order to match a more realistically complex situation have you seen this popular example floating around is true true true equal to true true true the answer is true true false the reason is because it's being parsed like this it sees a tuple of true true and the boolean expression does true equal to the tuple of true true true so true true and false of course if you put parentheses like this then you'll get the answer you were probably expecting okay let's use the match statement in order to detect this scenario let's start by creating a visitor class inheriting from cst visitor if we override one of the visit underscore methods then the library will call this method for every node of that type that it finds so in this case it'll call this function for every tuple that it finds in the cst in this example code there are two tuples there's the whole expression which remember evaluated to true true false and there's this tuple we parse the code to get a root object and then ask that object to visit using our visitor as expected we get two calls to the visit tuple function let's also print out the dump of the cst so we know what we're trying to match against even though this was just from a single line of code the cst for this is actually quite large so we do have to kind of know what we're looking for at this stage we're just looking at the structure of how the tuple and the comparison interact so let's turn off these extra options so here's kind of the pattern that we're looking for we have a tuple the tuple has some number of elements and the last element in the tuple is a comparison whose comparison target is comparing against another tuple we're trying to match that tree-like structure using the match statement so we're looking for a tuple whose elements are a sequence we don't care what the first elements are but there's at least one and the last element has a value which is a comparison and it's just a single comparison not a multiple comparison where the operator is equals and it is comparing against another tuple zooming out here's what we got so far okay it's definitely not pretty but it is very very similar to the actual cst printout that we looked at before i didn't necessarily know what all of these attributes like elements and comparisons were i just copied them from the cst printout and if we go ahead and run it on our example then indeed we see that it matches on the other hand if we put in the parentheses then we see that it does not match but technically we haven't used anything about the concrete syntax yet everything here is part of the abstract syntax tree so why am i using a concrete syntax tree well what if someone did this no matter how silly it seems to me to try to do something like this if someone put explicit parens around this then that probably is what they intended so in that case i would not want to match and i would not want to throw an error but these outside parens are redundant an abstract syntax tree would not see them at all so if i use the built-in ast module i couldn't tell whether or not they used parens that's why i'm using the cst let's go back to the dump to see where those parents show up well here they are and if i scroll up to see what that corresponds to it looks like it's an attribute of this comparison node so let's go back up to our match statement and add in the additional complexity we only want to match this structure if the left paren and right paren fields are empty meaning they did not put explicit parens now when we run the code on all three examples we get the right answer each time if they left it in this ambiguous state they get an error but if they put brands here or here then there's no error let's take a step back now and look at the complexity that we've created no one is denying it this code is complex we need to see a tuple with some number of elements and the last element needs to be a comparison and the comparison needs to have a comparison target that uses equals and is comparing to another tuple and there needs to be no other parentheses that is undeniably a complex thing that we're trying to match against however this is pretty close to essential complexity you pretty much can't describe all the cases that you do and don't want to match against without involving this much complexity the real test for whether this is acceptable is to compare against what the code would have had to look like if we use the alternative if checks well here is the equivalent set of if checks i need a tuple that has at least two elements the last of which is a comparison that does not have left or right parentheses that's a single comparison not a multi-comparison comparing for equality against another tuple i don't know about you but i find this code much harder to write and much much harder to read it would be so easy to get the order of these arguments wrong or make a typo on the length or make a typo on the index or to get confused about whether or not i actually need these parentheses here and so on and so on this code is definitely shorter than the other one but i think this one is much clearer and that is the purpose of the match statement the match statement is for matching against the structure of an object there are no indices to mess up you just need to show python what the structure that you're looking for looks like thank you for watching i hope you have a little bit better understanding of structural pattern matching in python now please let me know what you think in the comments do you think that this match code is more readable than the if checks even if it is more readable do you think it was worth adding a whole new feature to the language thank you to my patrons and donors for supporting me if you like my content please consider subscribing and if you especially like my content please consider becoming a patron have questions about the new features in python 310 join my discord slap that like button an odd number of times and i will see you next time