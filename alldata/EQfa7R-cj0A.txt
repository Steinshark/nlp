I vastly misunderstood the single responsibility principle okay okay I think this sounds exciting so have a lot of other people my understandings of its Accords with much writing I have seen about the principle on the web and Elsewhere for example Michael feathers what a great name my name is Michael feathers working effectively with Legacy code every class should have a single responsibility it should have a single purpose in the system and there should be only one reason to change it I don't get the last part I'm trying to like understand what this means oh D okay uh sure sure I can always tell when someone has functional programming brain rot is when they can't even fathom anything but functional programming I just want to understand this last part I don't quite get it we'll see BR mon uh I came to question that understanding today when I read part's article on the criteria to be used in decomposing systems into modules his top Criterion is decision hiding everywhere you make a choice about the system implementation you put that choice in into a module with an interface that doesn't expose the choice made if you combine that principle with my incorrect SRP one reason to change per module you get absurd situation that each module may contain only one change point in other words each bit of software architecture information must exist in a separate module so I went back to my understanding of SRP single responsibility principle by the way SRP and I found that it was flawed and that the person who coined the phrase single responsibility principle Robert Martin that's like everybody's current current version of Robert Martin right now is even said as much he said it long ago but years after the incorrect interpretation had got its shoes on and run twice around the world when you write a software module you want to make sure that when changes are requested those changes can only originate from a single person or rather a single tightly coupled group of people representing a single narrowly defined business function I'd have to think about that maybe I'm not sure if that's true I think that's true in the offline application World maybe but I'm not sure if that's actually true if you wanted to change a way devices could be scheduled you could go to the singular device team to do it but that device team may need to reach out to some sort of different team that does the actual physical managing of devices they have to make some changes then you have to make some changes and there's a series of changes that may have to flow through the entire system each with their own responsibility a single like do you know what I mean like when changes are requested it may end up affecting many other people I mean I understand what is being said here but there's Downstream and Upstream effects of everything anyways let's keep on going so the principle is that modules behavior is the responsibility of a single actor it's O kind of okay okay okay okay okay so it's not the module has a single reason to change but that the single entity will request the changes this is much easier to resolve alongside a part's vision of modularity this isn't some new deep Revelation or hidden Insight by the way that post by Martin is referenced on the Wikipedia entry for SRP which states that true well the as given definition of the principle the fact that I and so many others can hold completely different view for so long in the face of such obvious contradictory evidence tells us something about the knowledge transfers and software engineering that we probably ought to attend to you know the genuine problem with everything that's being stated here I actually I don't think this is bollocks I think there's actually I think there's one really solid Insight in this article a succinct Chinese meal yes I agree with that this is like we just read a fortune cookie sort of about this but there's actually one really really awesome Insight that I think people are struggling with it is this last sentence right here let's let's let's jump in on this one I see this happened all the time you see it with performance make it work make it pretty make it fast or something like that there's like some three-step thing people people do and that's supposed to give them license to just write shitty code I think it's terrible advice because if you want to make something fast often you have to restructure everything about your program you should design it to be fast to begin with there's this problem that you see all over the place with engineering which is that you go into with that mentality you don't make One Singular awful decision you make seven ,000 awful decisions that are all slowly added together copies here copies there keep on going keep on going everything's it just like everything's for free you just do what you got to do to get things done and you just keep on going keep on going let's not use map set guys right like maps and sets are really easy one maps and sets are a very simple obvious explanation for why they're good and bad right it's it's very shocking and people use them incorrectly all the time thinking they're getting speed they don't even have like an idea yet and so it's it's just like designing something to consider performance and consider what you're building which means that you have to understand fast versus slow to begin with and then from there try to make things faster as such see get a working copy then refin see I just disagree with that I just simply disagree with that entire take I think that that works if you're building a throwaway tool and you don't care go for it but if you're building something that's meant to like become the foundation of something you optimize do you agree with a Theo's framing of line of prime no I don't I I don't I don't agree with it I think we have fundamentally different approaches to uh software and that's fine like I I don't think we have to have the same approach and here's the deal remember someone built a roller coaster in Excel so whether Theo thinks the lines's here or I think the lines there maybe the line of prime we we do agree on but I think the line starts immediately but someone still builds a roller coaster in Excel so no matter what you think you can accomplish no matter what stupid Technologies you choose you can still do it if you try hard enough like you can do it oh you decided to use Visual Basic you could still probably build a successful website remember levels. II their database for years was Google Sheets they scaled to millions of users with sheets okay so I'm just say I'm just saying you could like you could choose any technology and become vastly successful so it's not about that I just like to approach it in a certain way I also build a certain set of tools I work in a certain way not everybody works in the same thing I work in so we have a different line of prime if you will using Theo's term and so Theo Works in a certain thing so he builds he has his own kind of vision of what that looks like I work on different things I tend to build tools and infrastructure and research stuff so I have to think about stuff vastly different because if I make one bad decision it cost me 7 Seconds over and over and over and over and over and over and over again I don't use typescript for a back end okay so this statement right here his line of prime arguments when to use typescript versus when I don't think you should use typescript on a back end I think you should use go go and HDMX would do it would literally make you go 10 times faster that's my personal opinion but that's because I'd rather use go in HTM X again you don't have to subscribe to that but I want to go back to this thing right here which is this is a very abute observation which comes down to this and I want you to really focus on this one thing there's something about knowledge transfer in the software engineering that we probably ought to attend to I'm going to give a hot take on this I don't think we can tend to it here's the reason why is that no matter how hard we try no matter how much I write about good programming techniques no matter how much I do anything at the end of the day until you have shot yourself in the foot a thousand times you're not going to be good you're not going to be an expert no matter how many times you've heard these right things to do to do the right thing in the moment for your specific problem requires experience years of it over and over again so when someone says single responsibility principle and you have this idea in your head and you build it a certain way and at some point you realize how bad it was it's because you just needed enough time to get to this point to realize what single responsibility means best in every situation cuz you just don't understand why and that's okay but that's just how life works unfortunately software engineering is this really weird place where good ideas can land you can think about them you can accept them but to apply them is virtually impossible does that make sense I think that makes sense I just think about this a lot I think about this a lot dogmatism is the root of all uh evil and soft Arts see I think that everyone can be dogmatic about the things they want I I I honestly don't care cuz again you can make a roller coaster in Excel it's just I don't want to work with your crappy Dogma I don't want to work on sites that use typescript as a back end I really try to avoid it Theo probably equates typescript devs equal trash Dev Russ go devs equals Prime see I just I I just disagree with this here we're going to be done with this we're going to be done with this video hey the name is the primagen