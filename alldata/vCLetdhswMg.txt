Hello and welcome. I'm James Murphy. In this video, we're talking about which dataclass solution is best for your situation. I already have a whole video explaining what dataclasses are. But for those of you that haven't seen that video yet, here's the gist. Throughout the process of writing code, you often create classes that are basically just containers for pieces of data that you've collected. It's a good thing to make these containers because they can really help people understand the meaning of your code. Take a look at this simple init function. All I want to do is store an int of float in a string. But here, you can see that n, f and s are repeated three times for each of them. This is already more repetition than I'd like. And it's only going to get worse if I want to add things like a hash function or a compare function to this class. Dataclasses help me get rid of all that boilerplate. Here's the same class. Notice that there's nothing repeated in the definition of the class. I only have n, f, s and their type hints once. But this built-in dataclass decorator isn't the only solution that offers similar functionality. We're going to look at the different features that each solution has. And then also compare how fast they are and how much memory they use. If you're looking for the classic no frills dependency free solution for most cases, then just stick with the built-in dataclass. In my last video, the only reservation that I had about using the built-in dataclass decorator was that it didn't support slots. Well, I'm using Python 3.10. So, now it's just this easy in order to use slots instead of an instance dictionary. The first really good alternative to dataclass is attrs. Sometimes attrs is a little bit more verbose than dataclasses. But it also comes with a little bit more functionality. In addition to supporting everything that dataclasses support including slots, attrs also supports variable conversions, data validation and default factories specifically for mutable arguments. Here I specify a converter which is just int. So, anything you pass in, it'll pass into int before storing it. There are a bunch of built-in validators like checking if something is an instance of the right type at runtime. And you can specify default arguments and default factories for mutable things. Even though you see me using dataclasses in most of my videos, I actually use attrs more in real life. attrs just has that little bit of extra flexibility that can make a big difference in a real project. The next three alternatives are just based off of tuples. Whenever I talk about dataclasses, I always get people asking: Why can't I just store this information in a tuple? Well, of course you can, if you want your object to be treated like a tuple all the time. Tuples are printed in a sensible way by default. And they're really fast and they're really memory efficient. If you just want to store three pieces of data, then a tuple is a good choice. If you want to make your code just a little bit more readable so you don't have to access everything by index, you can use a namedtuple. A namedtuple from the collections library is a tuple. It's a tuple that gives names to each of its elements. And that means that in addition to accessing things by index, you can also access them by name. This is a huge win for readability. But this syntax for creating the class is a little bit cumbersome not easy to read. And there's also no types mentioned here. If you want the exact same thing as a namedtuple but also with static type information available, then you should use NamedTuple from the typing library. This NamedTuple is a thin wrapper around the other one. It's still a tuple and it still behaves exactly the same as the other one. The benefit though is that this way of defining the class is much easier to read and it also leaves a space for the type hints. If you care about static typing at all, then you should always prefer this NamedTuple over the other one. The main drawbacks to using any of these dataclasses that are based off of tuples is that they are based off of tuples. Tuples are immutable. So, you can't change any of the elements after a tuple is created. You'd have to make a copy of the tuple with a different value in one of the slots. That means, you basically have to pay the cost of an instance creation every time you want to change something. The other main reservation you should have about using these tuples is type safety. You're not going to get any kind of error if you try to mix this kind of tuple and a raw untyped tuple even if you do operations that semantically might not make sense like using plus or less than. This is somewhat mitigated if you're actually doing static type checking. But you should still be aware. I might as well include dict in here because this is what a lot of beginners do. There's no type safety or even type information at all. And accessing things by string is really really error prone. I know it's really convenient to write something like this especially for testing or the first time that you're looking at a problem. But in my experience, using a dictionary this way is too error prone for my level of comfort. If this structure of having an n, f and s is something that's going to be used many times throughout your application and not just confined to a single function, then you should really be using a class. A very slight upgrade in readability from a dictionary is to use a SimpleNamespace. SimpleNamespace is just like object except it allows you to set attributes on it at runtime, whereas object doesn't Its use is primarily to avoid this anti-pattern where you just create a class for the sake of creating an empty class that you can put attributes on. And by popular demand, the last choice that we'll be looking at is pydantic. Now originally, I wasn't even going to talk about this. But in my dataclasses video, I got a ton of comments about pydantic. pydantic is a very opinionated library built for doing a specific task: Parsing By default, pydantic will try to convert things into these types when you construct this object or set an attribute. And it will check those types at runtime. One of the common problems that you get when you're parsing data is that the data you're reading might not be valid or it might not be in the right format. So, converting things at runtime and checking types and checking conversions at runtime makes a lot of sense for the specific task of parsing. However, doing all of this at runtime is a huge waste of resources, both time and memory, if parsing is not your goal. If this data structure of an int, float and a string is something that's internal to my application and my application is primarily responsible for creating these data structures and modifying them and doing whatever with them, then it would be a huge waste of resources to do runtime checking. It would be better and probably even easier to do static type checking and to catch any type errors before the program even runs. So, in my mind, I don't really see pydantic models as an alternative to dataclasses. They serve a very different and specific purpose. If you are doing parsing, like potentially parsing json from a web api, then pydantic is a great choice. It's very good at what it does. It's just not a general purpose thing. And we're going to see that performance hit in the graphs that are coming up. Okay, time to take a step back and look at the overall picture. First up, speed. How long does it take to create an instance, how long does it take to access an attribute on the instance and how long does it take to set an attribute? These are the creation times for each of the different classes in nanoseconds. So, these are all very small. However, you can see pydantic is losing by a lot because it's doing this runtime checking. That's a huge price to pay. So, let's go ahead and zoom in on all the rest of the things. There's a little bit of variability. But there's two pretty clear winners. Obviously, the built-in tuple and built-in dictionary get preferential treatment in the language. Tuple and dict are written primarily in C. Everything else has to go through Python. That means tuple gets to sit nicely around 30 nanoseconds. And everything else is taking about 300. If you care about this difference in performance, then you might need to be writing a C extension or just using C directly. So, if you're programming in Python, I'd say that all of these should be good choices as long as each one has the features that you're looking for. Alright, let's look at getattr and setattr. The first thing you should notice is that the getattr and setattr times are much less than the instance creation times. But that doesn't mean that you shouldn't worry about them. We often get and set attributes of a single object many many times. So, these little times can add up. Here's the picture for getting attributes. Basically, everything takes the same amount of time except SimpleNameSpace and pydantic. It's a similar story for setting attributes. Let's go ahead and zoom in so that pydantic isn't dominating everything. Here, everything that's mutable, of course, is taking about the same amount of time. You can still choose to use an immutable thing even if you want to make changes to the objects. Just remember that if you do that, then whenever you want to make a change, then you actually pay the creation cost not the setattr cost. That's because you basically have to create a new object that has to change data in it. So, unless the changes that you're making are extremely infrequent or if you're using a raw tuple whose creation time is just that low, then you should probably just prefer to use something that's mutable in the first place. On to memory usage. Everything is in bytes and lower is better. Everything that used less than 200 bytes is something that is tuple or slots based. Everything that took more than 200 bytes used an instance dictionary. If you're programming in Python, you're probably not too memory constrained. But if you're really creating a lot of objects, sometimes it can be useful to save a factor of two. This is a big place where attrs and data classes shine. You can choose to use slots if you want to conserve that extra memory or you can choose to have the convenience of an instance dictionary. Finally, here's the feature matrix to help you decide which one is right for you. In my opinion, the best overall choice is attrs. The most convenient choice is dataclass. And the best choice for record like data is the capital NamedTuple. Of course, if your task is specifically parsing, then use pydantic. That's all I've got. Thank you for watching.