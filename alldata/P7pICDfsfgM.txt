go 1.22 fixing some for loops and go this is kind of exciting go 1.21 includes a preview uh let's see of a change of for Loop scoping we plan to ship and go one two two removing one of the most common go mistakes so this is awesome this is great if you've written any amount of go code you've probably made this mistake of keeping a reference to a loop variable variable past the end of its iteration at which point it takes on a new value that you didn't want for example consider this program there we go four V value ranges print this who hasn't done this one this also like if you ever did let I in uh uh JavaScript same same experience wait for all go routines uh the three let's see the three created go routines are all printed the same variable V so they usually print c c instead of printing a b and c and some ordering okay this is cool so you can now just do this although concurrency is often involved it does not need to be this example is the same problem but with no go routines for I okay we do a little simple one uh append prints function print oh there you go yeah there you go this exact same thing exact same thing in JavaScript people would create and immediately invoked function that takes in the argument and all sorts of crazy stuff this kind of mistake has caused production problems and many companies including publicly documented issue at let uh at let's encrypt as an encryption company getting caught by a for Loop I'm not gonna lie to you it greatly makes me feel less confident uh this is actually a really this this happens in a bunch of languages right it just can't happen in Rust right let's not yeah this is a skill issue in that instance The Accidental capture of a loop variable was spread across multiple functions and much more difficult to notice nice uh converts the mapping of a domain to auth2 models into a protobuf authorization map okay so what do we got here we get a response we get the authorizations we go over the range make a copy of K because it'll be reassigned in each Loop all right um there we go OS PB we do a little bit of that pass in the value return error if nil append this okay a reference to K copy bam the uh let's see the author of this code clearly understood the uh General problem because he made a copy of K but it turns out the model to auth PB used pointers in the field of V when constructing yep yep classic didn't didn't V copy only gave him the K copy you can't dude you can't give the K copy without the V copy yeah I didn't see that one okay not not skill issue anymore to be honest again this is a tricky one I see this this was a tricky one okay yes you also need to make a copy of heat tools we uh have been written to identify these mistakes but it's hard to analyze whether a reference to a variable outlived its iteration or not absolutely it's it's very very hard these tools must choose between false negatives and false positives the loop closure analyzer used by go vet and go please opts for false negatives only reporting when it's sure there is a problem but missing others other Checkers opt for false positives uh accusing correct code of being incorrect we rarely analyze the analysis of commits adding x equals x lines in open source go code expecting to find bug fixes instead we found many unnecessary lines being added suggesting instead that popular Checkers have significant false positive rates but developers add the lines anyways to keep the checkers happy yeah see I don't like that yeah this is a great this is a great change by the way and go let's just avoid the whole effing problem one pair of examples we found was particularly Illuminating this uh this diff was one program and another program was this oof uh let's see one of these two diffs is a bug fix the other is unnecessary change you can't tell which is which unless you know more about the types and functions involved yeah see that's the thing is I don't know monitor seems probably correct but maybe this also isn't I don't know what this stop channel is I don't even know how Informer I don't know anything right here right I don't even know uh have you used go routines I know go routines I'm just curious which one causes a bug and which one doesn't you can't tell the fix and go one two two we plan to change for Loops to make these variables have a per iteration scope instead of per Loop scope uh this will change let's see this change will fix the examples above so they will also no longer uh buggy go let's see so that they are no longer buggy go programs it will end the production problems caused by such a mistake and it will remove the need for imprecise tools that prompt users to make unnecessary changes to their code this is a great change by the way this is a great change to ensure backwards compatibility with existing code that was my next question which is goes like goes really all about backwards compatibility the new semantics will only apply in packages containing a module declared uh go 1.22 or later in their go mod files this per module decision provides developer control of gradual updates to their semantics throughout their code base it also is possible to use Go slash build lines to control the decisions per file okay okay okay okay that's pretty cool old code will continue to mean exactly what it means today uh the fix only applies to new and updated code this will give developers control over when the semantics change to a particular package as consequences of our forward compatibility work yeah I mean you have to do forward compatibility stuff sometimes it's not great uh basically rushed editions yeah yeah you got it uh let's see go one two one will not attempt to compile code that declares go one two two or later will that make sense we will include a special case with the same effect uh in the point releases of go one two 128 and 119 13 so that go 122 is released uh one go one two two is released the code written depending on the new semantics will never be compiled with the old semantics unless people are using a very old version of unsupported go okay you can go preview the fix you can do a little go experiment Loop VAR okay fixing a buggy test although we had no production problems to prepare for that switch we did uh have to correct many buggy tests that we're not testing what they thought they were testing like this oh that's funny they had their own test breaking think about think about how that has to feel when you make a change to be like okay this is correct go code all right me the go compiler writer who's an expert at go let me just oh we have a bunch of test breaking laughs like if even the expert of experts at go can't write it correctly it's a good feature can we all agree that's probably a good feature at this point probably a good feature Tessa wrong is the worst test wrong are actually the worst they're actually the worst yeah that's actually really funny oh man oh man test all even buggy that is so funny that is just so dang funny ah love it I love go so much I actually do like go quite a bit uh let's help those losers I loved I love go quite a bit so I'm happy with all good changes positive changes a hundred percent uh uh code coverage on point dude I know this is exactly why uh code coverage is just such a stupid term is because you can just make bad ones try it out hmx plus go yesterday it's glorious it is it's legitimately glorious hey I like go go 1.22 is getting better we're starting to get all these great generic functions of types where you can just do Min and Max and all these things on any numbers and things are just starting to work so goes actually becoming like a really good modern language and I'm getting very very very excited for its future love to see this love to see some of the fixes coming in down the pipe let's go a Jen