how's it going guys in this video I want to give you a few pointers on how to optimize your code in Python and that practically means the things you should consider when you are optimizing your code in Python now a lot of people say that if you're trying to optimize your code in Python then you just shouldn't be using python but that's like saying if you're trying to improve the speed of your bike if you are a cyclist then you shouldn't be using a bike you should just use a car there's a reason we're using python so there's nothing wrong with trying to improve the speed of the tool that we're using while we're using it sometimes adding some oil to the chain or pumping the tires more can make your bike perform a bit faster for essentially no extra cost and the same goes for python why wouldn't we want to get the best out of the tool that we have to use anyway but the first thing you should consider before you try to optimize any of your code is how often you're going to run that script if you're going to run it once a year then optimizing it might not make any sense at all because if you have to wait 1 minute per year that's perfectly fine but now let's change the example to a script that you might run 20 times a day if you find a way to optimize your code so it even saves you 1 second you're saving 20 seconds per day that's 7,300 seconds per year which is approximately 2 hours per year and imagine you have 1,000 users that use your app every day now that's 2,000 hours of time you saved everyone all because your block of code is now 1 second faster so you really need to keep into consideration how much that optimization scales again if it's for yourself and you run the script once a year optimizing might indeed be a waste of time but if there are a lot of users using your app even if your app loads 1 second faster or runs 1 second faster that's a drastic change on a larger scale anyway with all that being said let's jump into some of the Practical tips that you should keep into account when you are trying to optimize your code because with python being a highlevel language it's very easy to get biased results so for this example I'm going to compare the speed of a list comprehension to the speed of a for Loop so here we create a list comprehension which is of type integer and we add 10 numbers to it using this range iterator and we're going to do something similar using this for Loop where we create a list and we append to that list the same 10 numbers from that iterator so at the end of the day they give us the exact same result with different approach approaches and to time these two Snippets we're going to import from time it import repeat and I much prefer to use repeat over time it because it actually gives us the ability to easily repeat our tests a given amount of times which is great for consistency anyway below these two Snippets of code we're going to try to get the time for how long it took to execute each one of these 1 million times and we're going to repeat this test five times for each one one of these Snippets of code now repeat is going to give us back a list of float which gives us the best times from this test and we want to get the minimum from that because that will give us the best possible time or in other words what our computers actually capable of doing back to us as a result and then below that I'm going to print both of the results formatted nicely to three decimal places using formatted strings now when we run this to actually compare the list comprehension to the for Loop you'll see that the list comprehension will perform a bit better and that was a fairly simple Benchmark but again there's a lot of things you can do wrong here for example if we were to just use the time it function instead of using repeat we can say this is going to be a lot of work but this is what I get paid for time it we're going to keep the number at 1 million and we're going to remove repeat so it's still going to give us a float back but we're only performing the test once and I'm going to copy and paste that for the for Loop now let's run that once again and you're going to see that the results are a bit different this time the list comprehension didn't really give us that boost or that speed boost the list comprehension wasn't really that much faster and if we run it again it might be faster or it might be even slower and that's something interesting that can vary from computer to computer and for my computer which is a MacBook M1 I believe this is due to the fact that I did not warm up the code because before python gets to its Peak Performance it needs to warm up The Interpreter or it needs to load a lot of things which means that once it runs the first test it's not really at the working speed when we use the repeat function we minimize that risk because we're repeating that test five times which means it will be able to get to that working speed to actually give us some accurate results and to show you this I'm just going to copy and paste this right above and we're just going to call this warmup it's not going to do anything it's just going to perform a test before it performs the other two tests and when we run this you'll see that the list comprehension is going to be more accurate now because we were able to warm up our interpreter or warm up Python and if we run it again it's going to be more consistent and sometimes the order in which you perform this can change the results as well so when you're doing benchmarks it's very important you keep everything into account not to mention that it also varies from python version to python version if I change this to python 3.9 the difference between a list comprehension and a f Loop can be much bigger here it's around 25% while in Python 3.12 it was more like maybe 10% but let's change it back to what we had from earlier with repeat because I prefer that much more I mean it might take ages but it works much more consistently now something else you might want to keep into account is that if you're performing any tests without the Tim it module you're going to want to disable the garbage collector for more precise results for example here we can import garbage collector and you can just type in garbage. disable and it's as simple as that to disable the garbage collector by default the timeit module should disable the garbage collector but when I manually disable it as well I do get different results so I'm a bit confused or a bit fuzzy about that when it comes to timing when it comes to the time it module right now I'm back in Python 3.12 so when I run this code you'll see that we'll get1 168 for the list comprehension if I disable the garbage collector but if I don't disable it before that it's going to be something more around 1.75 and this is a consistent difference so if any of you know anything more about that when it comes to the time it module please leave it in the comment section down below because from the documentation time it is supposed to disable that garbage collector so I don't really understand why disabling it even earlier boosts the speed of the code anyways I do want to reference an article which I found in incredibly useful to performing or to actually doing benchmarks and that's an article by Jason Brown Lee this is an incredibly insightful article that actually explains a lot on the best practices for python benchmarking and I absolutely recommend you look into this before you actually start trying to perform some benchmarks because I'm not going to lie when I first started programming in Python I would do something such as import time then I would say start time type float ALS time. performance counter I would put some code inside here and then I put end time which will also be a perform a performance counter and then of course you would print the final time which will be the total which is end time minus the start time and I would think this is a perfectly acceptable way of performing a test but again there's so much wrong with this approach the first one being that we do not warm up the code so we can get we can have a lot of bias second we're not repeating this test any amount of times so we're also suceptible to that bias where we might get a good result depending on the mood of our computer and while it might seem like a good idea at first because it's quite simple it just isn't reliable but anyway do let me know in the comment section down below what you think about optimizing python code whether you have any tips and tricks whether you have any articles you want to refer to that are quite insightful I would love to hear about that in the comment section down below but otherwise with all that being said as always thanks for watching and I'll see you in the next video