hi everyone for those of you interested in this flat shaded style we're going to be taking a quick look at implementing an option for that today so as you likely know the lighting of a mesh is calculated based on the normals of the vertices in that mesh so in order for a triangle to have the same lighting everywhere on its surface in other words for to be flat shaded all three of its vertices must have normals that point in the same direction this isn't possible though if a vertex is shared by multiple triangles since then that vertices normal is going to be a blend between the direction that those triangles face so what we need to do is make sure that each triangle has three unique vertices not shared with any other triangle so instead of having just four vertices making up these two triangles 0 1 2 & 3 which remember would be stored in our triangles array as something like 0 1 2 2 1 3 we'd now have six vertices making up these two triangles 0 1 2 3 4 5 and these would be stored in our triangles very simply as 0 1 2 3 4 5 to do this let's head over to the mesh generator script and come down to the mesh data class and somewhere near the bottom here to create a void method called flat shading in here will then have a vector3 array which we'll call our flat shaded vertices and we can set this equal to a new vector3 array with a length of triangles dot length we're then going to iterate through all of those so for in AI starting at 0 I less than triangles dot length we can say flat shaded vertices eye is equal to the vertex from the vertices array with the index referred to by our current triangle so triangles I now we obviously want the triangles array to be updated too refer to the index of the flat shaded vertex so we just say triangles I is equal to I since that's the index of the new flat shaded vertex and then we just would want to do the same thing for the UVs so a vector to array flat shaded UV s is equal to a new vector to array once again with the lengths of triangles dot length and we're just good want to do the same thing that we did with our vertices here so we say flat shaded you v's I is equal to UVs with an index of triangles I make sure you do that of course before we assign a new value to the triangles array once we've done that we'll want the flat shaded vertices and the flat shaded you v's to actually become the vertices and triangles that we use in our mesh so we can say vertices is equal to the flat shaded vertices and likewise UVs is equal to the flat shaded UVs now we're obviously interested to know if we want to use the flat shading for this mesh so I propose that when we create a new mesh data object we have to pass in a boo saying use flat shading and then we can have a rule over here you use flat shading and we can just assign that in the constructor here this dot use flat shading is equal to the use of flat shading value that's been passed in and then what I mean to do is instead of having this baked normals be public the same should be made private and we're instead going to have a public method called something like finalized and in here we'll say if you use flat shading then we are going to call the flat shading method otherwise we're going to bake the normals and the reason we're not breaking the normals if we're using flat shading is that the entire purpose of the baked normals thing if you recall was to get the normals to be consistent when sharing across the edges of mesh chunks but when we're using flat shading that's no longer an issue so we can just use the less expensive built-in recalculate normals when reason flat shading so when we get to actually creating the mesh will say if use flat shading then we can simply say a mesh to recalculate normals otherwise we're going to use our X normals all right then let's just remember to come up here and instead of calling baked normals we are going to finalize the mesh data and we're also going to want to take a bool use flat shading in this generate terrain mesh method and we will pass that value into the mesh data constructor here just like so and now we can save that and let's head over to the map generated class so one thing we have to worry about here is our map chunk size so if we were using flat shading then we're going to be generating a lot of extra vertices and remember unity has got about a 65,000 vertex cap on a single mesh so we can't use such a high value otherwise we are going to exceed that cap so we need to pick something lower and if you remember all those episodes ago when we chose this number 239 it was because the number 240 is divisible by all the even numbers up to 12 which helps out a great deal with our level of detail system now the best substitute I could find that isn't going to generate too many vertices is 96 sadly that's not divisible by 10 but it is divisible by all the other even numbers up to 12 so let's use that remember we want one less than that value here so 95 and then let's just create a public pool as well you can call this use flat shading and then we'll want to pass the value of that into the generator a mesh method so we've got one reference to that over here and then down in the mesh data thread we've got another one let's just passed the value in there as well so let's go into unity and let's turn on use flat shading you can see we've got this smaller map size and it is nice and flat shaded it's also a quickly press play see what this looks like with a whole bunch of chunks generated you can see it all still lines up correctly and it looks pretty nice the one thing is with our level of detail as I mentioned it isn't divisible by 10 which means that we can use all of these except for a value of 5 I will get errors for that remember we are multiplying this value by 2 so a level of detail of 5 means that it's skipping 10 vertices at a time now we maybe want to set this up so that if we're not using flat shading we use the full 239 sized map chunk so let's just go into the map generator and instead of having this constant int we can maybe make a little accessor just a public static int called map chunk size which is good to have a get and then if we are using flat shading then we will return or is it 95 otherwise we will return 239 now of course this is static which means we can't access this instance variable saying exactly which instance of the map generation were referring to so let's go ahead and make a static map generator reference here called instance and all we'll do is if the instance is equal to null then we can say instance equals find objective type in the scene map generator and then we just say instance don't use flat shading all right so now if we go into the map generator use flat shading if we turn that off then it will use 239 is the value all right that's everything for now so until next time chels