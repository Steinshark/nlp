all right let's check out the I changed my mind about this language with lowle learning because this is actually really exciting and hey guess what at the end of this video we're going to actually get low-l learning in here and we're going to have a quick discussion on this so this is going to be a double whammy today a double whammy cuz lowle learning if you don't know Ed as some people call him kind of the man okay it's kind of the man here we go about Zig originally when I started the coding it about a year ago I wasn't sure if it actually had a meaningful place in the developer ecos oh my goodness I feel so Justified already we're like 2 minutes in I I even made videos about this I don't think zigg has a good place yet and I still stand by that opinion because it's like during during like two years ago the hype was all rust right it was all rust it was all exciting everybody wanted rust and it was all about safety and all these kind of things and you know I I largely agreed with that I thought that okay if I'm going to program some sort of new low-level systems level language I might as well actually have something that is fast but also really dang safe and I'm not going to shoot myself in the foot and I want like one really expressive type system so it's like well zig's not as safe as rust but then but then on the other side it's just like okay but it's easier than rust but then you're like well if I wanted something easier I could just use go so where does ZIG sit what's the purpose of Zig and the more I got to learn about Zig and kind of let it stew in my back brain comp time plus the ability to have options and plus air so it does do results it does do air it does do options and results and that there's like a couple different situations in which you can still do a nilp pointer but for the most part it's more like go and it's more like C than anything else and so I was just like I felt like Zig had no purpose and now I'm like Zig might actually be the real de facto one and I do mean that that I think zigg is significantly more interesting in embedded work than rust or C I think Zig would be significantly more interesting as a web server than rust go it's like a huge it's a huge argument I think go and Zig is a much more compelling argument to have than rust and go I actually think that rust the more I learn about Zig I think Linux I even think the Linux Colonel made a mistake having rust going into it I think zigg should have been the one that goes into it I really do think zigg is actually the most interesting language out there right now I really do uh it just seems so super cool it does I think it is just so super cool I can't even believe I cannot believe how cool it is and I've just been stewing on these and reading a little bit here and there I you know obviously I haven't done a lot of it I've just read about it and and played I I did I think I did a couple days of Advent of code last year in it and it was just so cool system and as I've been using it and being asked more and more questions about it I think I've come to a better conclusion in this video we're going to talk about what zigg Ling is where it lives in the developer ecosystem and my thoughts on the syntax and the features of the language now if you're this is good this is a good lineup cuz I have a lot of thoughts on these things by the way I feel like people have the worst measurement of what is good and bad syntax people come in constantly and they're like goang has the worst syntax goang doesn't even have syntax like what are you talking about it's there's like five characters that are non just English letters it's just pretty much asky it's just a bunch of keywords it's wild it's it's wild the only thing that people can say they're so mad at Co and equals like I think colon equals is the only thing that people are mad at hey I don't like implicit returns right I don't like the last thing inside of a function being the thing that returns oh an expression based languages well guess what my parser it looks it looks for keywords okay okay my dyslexic ass brain looks for keywords and so it's very easy for that so col and equals is not a problem because there's two instead of one it's very easy it's very very simple okay whereas no return is hard for me I have to like look for look for extra stuff I don't know seems hard anyways uh but we all don't like Syntax for different reasons but I'm very curious about that one okay has shitty syntax can't you invent your own syntax in H if you're new here hi I'm L Al learning I make videos about software security programming and cyber security in general so if you like that stuff or just want to hang out with me hit that sub button I really appreciate it now a lot of new programmers ask me uh what language should I learn should I learn C or C unsafe or should I learn rust or rust too hard or should I learn Zig and I think for a long time I had a good answer about C and rust but I didn't really know how to answer when it came to Zig zigg had this weird aura about it where I wasn't sure what problem it solved but I think I'm going to be able to answer answer that for you today if you consider the ecosystem of systems by the way that is like such a common question which is rust or should I learn rust or and it's always some set of things uh that people are always weighing against and it's kind of wild like I mean if you want to learn rust you should just learn rust and stop rust oring it right I just think it's kind of crazy to always just living your life on an ore like always trying to find the most optimal thing to learn and all this kind of stuff like it's better just to learn something learning something is better than trying to figure out the best thing to learn ever and I think a lot of people they end up trying to just learn the best possible Thing versus just learning something and then they end up spending months trying to learn the best thing and they swap really really quickly and they can never quite do it because there's always something new and so they just never actually learn the thing it's like the most common thing I see flip you might be able to keep this in it's like one of the most common thing I see is that people constantly try to just live the most optimized life and you you probably just you don't need to do that you know I always say this you know it's better than the best workout ever the one you're going to do tomorrow if you can just keep on having something you're going to do again that's better than the thing you'll do once then do it again then do it again then do it again and then maybe maybe you'll be kind of excited to to improve and if you're excited to improve okay you know excited exciting programming you have the SE language and you have rust now those are the two main ones that stick out in my head when it comes to systems level languages and we're not going to talk about C++ by the way now there is go go is another compiled language that is very very good and getting more and more speed but go is a garbage collected language and some systems some platforms and some projects require that you don't use garbage collection for one reason or another garbage collection is inherently non-deterministic so a lot of the times people will just choose to not use a garbage collected language now you're left with it's fair it's fair factual um but go is garbage collected not garbage uh go is a great language uh most people they just simply need a tool for automation or a tool to aggregate a bunch of results together and do something and you can do you can do quite a bit with go you can just do quite a bit and so I'm not too I'm not too worried about it yeah this whole like you can disable the garbage collector is very interesting I'm curious about that if you disable the uh garbage collector how do you how do you what can you do with memory I'm not really sure I don't know it seems interesting the basic two you have C and rust now each of them have their pros and their cons their shortcomings and their power right C on the one hand is the OG language it's been around since like 1972 or whatever and it's it's one of the best languages that exists in terms of the power that it gives the programmer I mean the entire world to include every embedded device that exists your router your fridge your microwave is probably written in C and that he is right people forget how good C is I mean the time the the time and place C was created but not only that it can perfectly Express almost every single computer science problem and so it's not only a great just like language that people have used for many years but it's also a really great representation of just computer science itself it's like the manifestation of all the algorithms and data structures and everything it's it's quite it's quite it's quite a great language C is a grape language it is a grape language uh coffee machine is in C probably there's probably just a really small amount it might it might be in something else uh but it's it's small the hot take I don't think that's a hot take I think that most Concepts in computer science boil down to being very well expressed in C it's because C is an incredibly powerful language the the programmer is able to do literally whatever they want as long as it's within the scope of like what the OS the kernel allows it's able to be done in C now that is what I'm considering on like the far left of the spectrum right you have like powerful but do whatever you want to give it like chaotic evil language right on the other hand you have rust now rust is designed with many of the failures of C in mind C for example is not a memory safe language you can exit outside of the bounds of an array you can do arbitrary use after freeze and it's on the developer to catch them at compile time or the program to enforce that you can't do those things at runtime but you can very easily write code that just allows you to do whatever you want and have it go out into the ether and become a security vulnerability that eventually gets hacked by hackers but if you consider the new program by the way that is skill issues right there you know don't don't get caught by skill issues it's that easy uh C is great but then C++ C++ you know I think C++ gets a bit of a bad rap uh you can do quite a bit with C++ that's not bad I think the thing is is that C++ like a lot of languages they offer a whole bunch you know I mean to be to be real have you ever used some Rust that when you look at the code that it prod like that the person produced you look at it and go this is just crazy code this is this code is absolutely crazy and you get completely confused by um like by what is h like I mean when you look at really high performance rust it's pretty wild out there and if anybody tells you that uh that rust is way easier to maintain you know I'm not 100% convinced about it I mean I I've worked in some pretty awful C++ Co bases I spent two days trying to figure out a logging thing and I couldn't figure it out I tried like my i i l I tried my hardest couldn't figure it out could not do it the macros were too intense a clang D couldn't keep up with all of it and it just fell apart so I I know what bad I know what bad C++ looks like is high perf rust as insane as high perf C++ I feel like rust is 100% harder in the high per situations I feel like it's much harder High perf rust is slower and harder I don't know if it's slower slower is kind of a I don't know that but hard is very hard who's trying to get into the space who wants to learn a language that is for systems programming but doesn't want to do Russ cuz Russ is too hard but doesn't want to do c because C is unsafe where do they go this is where I think Zig fits in very very well now what you're looking at here is a project I've been working on on interesting that's like that's actually for me that's not a selling point I though that is a selling point that's not my first selling point this was kind of an interesting approach to kind of going about this as a language first or this as the reason first okay I can C curious curious on Twitch I've been basically trying to reproduce the xxd binary if you don't know what xxd is it's a basic hex right you can specify the size of the columns and the size of the groups and what you do is you pump in arbitrary data into there and it hex dumps it right pretty straightforward I use this project as a way to learn new languages cuz the project itself is very simple but it forces you to learn a few things about the language you have to do like basic Loops memory views into binary data how to open files you have to use the parts of the API that may be like non-standard and then also like it's just a cool tool to have I think it's I think it's pretty neat so anyway what I'm do I've never built xxd that could be neat that kind of seems like a neat project that sounds like a neat one to do stuff like you can see a lot of cool stuff in Zig like I do love their TR Syntax for those that don't know uh I I will say it's both good and bad having I don't know I don't know what the term is for you know not postfixed I'm not sure if it's prefixed if that's the term for it but to have try first and then your statement is really nice it's really easy to read what's going on but the postfix question in Rust is really really convenient for chaining is that an exception try it's not a try so when you see the word try or catch it's not what you would consider it um you like if you think of try if you think of try try is unwrap and rust try is not unwrap unwrap and rust it's not at all unwrap and rust see this little bang void this bang void what that means is that this function can return nothing or an error and so try fstat will Ford up that eror it will return it try is equivalent to the question mark operator this is a result object that comes out of this function so bang void is a result object where the type is void so it actually has a result object so Zig has a result uh object which I think is pretty cool I see Alex and no free what is this well uh I do see I do see an Alec right here and then I see a free right here so this defer is a free so you get defer which I also think is really nice this allocator doesn't do something and then it just dumps the hex that's probably fine right you know try is a bubble up the air yeah and catch is kind interesting because if you open the path and you can't open it you can then do something on not being able to handle the air which is also kind of like a super cool concept I actually really like this concept where you can do something and then handle if it doesn't work out rust air handling is just the best uh I don't know if that's true this is super cool this is equally in my opinion this is there's some things about this that is actually cooler than rusts right the try not as good for chaining not a big fan of that uh but most of the time if you're chaining a bunch of airs together I have a lot of questions you know like that's that's pretty difficult whereas this catch I think is super cool like this is super super cool catching it seems like a more elegant uh version of go air handling it's a it it has the it has the result objects that you always want from rust but it has a much more like kind of  feel and so this is kind of what I want no chaining you can't really chain as easily it's true it's harder to chain it's just harder to chain a I haven't done Elixir air handling so I don't know the combination of try catch with a unions is very nice in my opinion I I agree with that it's very very cool it's very very cool so people that don't know this this is very cool uh it's the middle ground between go and try catch well no it's not there's no TR catch it's not TR catch it's not throwing errors right it's not throwing errors Zig errors are only enums you cannot attach payloads to errs I'm not sure what that means a payload to an error I don't know what that means you can chain things uh that all return errors uh types uh I don't know if you can do that anyway doing in this project is reproduc you could by like surrounding it by parentheses but that's not really chaining Tri catch was good and we should use TR catch I do not think I mean I think this is where Uncle Bob and I will permanently disagree I do not think Tri catch is a good Paradigm I think Tri catch is terrible I think TR catch is 100% bad 100% of the time no matter what anyhow good luck for those that didn't see that that was that was really good this is most people's rust air handling rust has great air handling also anyhow just just anyhow all the time anyhow bail anyhow bail anyhow air anyhow this anyhow that anyhow anyhow anyhow anyhow anyhow anyhow anyhow XX how do you even create an air and rust nobody knows nobody has any idea it's it's unheard of D and this is the current status of it and I'm calling it zcd so pretty neat in doing this project I learned a few things about the language that I want to talk about that I really really cat is the main feature that kind of separates zigg from C so if you written C recently right C Used to Be basically it was so sorry someone just said something very offensive in the chat Dy box imple error I mean this guy I mean this man's out here this first off it's incorrect it would be box dine error okay it would be a result of e box dine error okay now that my friends is an evil statement this is an evil statement this is also how I did my first first rust error handling that's how I did my first one try catch as useful in certain situations when you uh know certain exceptions will happen yeah you know it's even easier if you know when certain exceptions will happen you um you can also use erors as values cuz the only difference between this and what you're saying is that sors as values you know where they all happen with exceptions you only know the ones you know you know what I mean and just like you only know you only know the ones you know let's go back a little bit just a cool tool to have I think it's I think it's pretty neat so anyway what I'm doing in this project is reproducing xxd and this is the current status of it and uh I'm calling it zcd so pretty neat in doing this project I learned a few things about the language that I want to talk about that I really really enjoy the first is the main feature that kind of separates Zig from C so if you have written C recently right C Used to Be basically it was literally an abstraction for assembly instead of writing assembly you would write the C would just turn into assembly that' be there' be they say that when when the Heap introduced when the Heap was introduced programs became hard you like no extra things added there was no allocators that were created you had to write all that stuff yourself as C got older as C matured we now have like the gy library that does a lot of stuff for us we use print F we use scan F and all of that stuff that when you use it I like to call it gpsy g Lipsy way too much I like to call it gpsy okay feeling a little gpsy tonight gets buffered in the Heap so Zig is trying to prevent these things that they call ghost allocations where when you run code in Zig all the allocations will be ones that you ask it to do it will not do any allocations for you and because of that they've given you very explicit access to these things called allocators so you can write your own memory allocators that allocate memory in the way that you would like it to be allocated you could write your own kind of Heap you could write a basic stack allocator you can basically do whatever you want which is really really cool another other thing is this defer macro right when you're doing allocations every allocation when you do an Alec must be met with a corresponding free right if you don't do that you have a memory leak and your your program is buggy uh this defer keyword allows us to do the associated free for that piece of memory and it makes them close together in code so when I'm doing a code audit I can look at it and I can be like okay cool I have my Alec here where do I free this variable I literally like on the next line I do it the defer keyword allows this piece of code to be Rand when the function scope is about to go out so when i r when I run defer this actually effectively puts this line of code at the bottom of the code but it puts it up here so I can mentally associate that this is tied to this which I like so you have to write an allocator for every object no you write you there's general purpose allocators there specific type of allocators there's a whole slew of different allocators but uh you can even use a gpsy uh C allocator all that kind of stuff but the the the the big the big butt in this one is that and it's something I really like which is all objects created on the Heap are known at programming time to me that's really important because that's one thing that you have to learn about rust which is you have to know which ones are on the Heap and which ones are on the stack so when you do in Rust when you do a string is that on the Heap or on the stack when you do an RC is that Heap or stack right like you learn all these things and it's not hard to learn but you have to you still have to know these things you have to walk through it and learn each one of these things one at a time which is very interesting you know so that means if you do a a a ref an RC ref cell string which would make no sense by the way but let's just pretend you did an RC ref cell string you'd have to kind of you know you'd have to you'd have to you'd have to know where like how many heaps are you on you know so it does make you have to think about things a little bit whereas uh whereas with Zig you know all the things that are allocated which I think is really important I do like that I like I actually really do like that Paradigm I think it's a it's nice I think rust makes it feel nice the problem with rust is that it makes you feel like you're programming a high level language but you're not you're programming a low-level language and I think that that's a that mentality is a bit of a foot gun for those that are uh uninitiated like a lot the next big thing that I was a really big fan of is the errors as values feature of Zig now if you've written any rust you have the result type the okay type the error type right where the result is a en that allows you to basically return either an okay which is good value or an error which is bad value and then handle the output via pattern matching Zig is a very verbose language where you are required to not only use all the variables that you uh you you name but also you're required to handle all the errors that you get right so effectively this open file function has this return type what this return type actually means is pretty interesting and I I love the notation of this on the right of this exclamation point you have the return type when it's a good value so the correct return type is this if there is a return error to be returned this is the error type right so that's equivalent to result standard FS file comma standard FS file open error like this is this is this is you can think of it effectively the same and so what we're able to do is we're able to run the open file function and effectively think of it like we go left or we go right in the case of we go left the open file good value the standard FS file is put into F easy that's awesome if you go to the right we're able to check to see okay we've caught that we're in a file open error error and that type has different subtypes and we're able to print them out via basic pattern matching I think it's really cool I think it's a way for you to be forced to handle every error case of your program which in languages like C for example like a lot of the times you don't even have to check the return value you can just say like open and then if it's good it's good but if not it can crash like it doesn't like no one cares uh so I like this a lot it's true you just like what's your air no what's what's the a know like I do I air a know was a problem okay can we all agree that air know was a problem open sets up shoot right so no more okay value so uh really you don't think so I dud okay so at one point Arno was probably really great I'm sure of it but you know what's way better is not having Global wears my error okay you know what I prefer local wears my error okay you know I'm not in here I'm just not in it you know what I mean I'm not in it hey thanks first time chatter for your CBD heals autism and psychosis and epileps I appreciate your very insightful firsttime chatting that sounds fantastic do you have a product I can purchase is this a CBD commercial I used to have autism until I took CB you know we have to give some uh Java some credit to arrive at this uh throws do we I don't I don't well I mean yes we can give Java the credit I just don't want it I just don't want any throwing that's why I like this this is I love this this is good you have to handle your errors handle your errors baby this is good CBD is actually a a new Js framework oh CBD JS it's it's it's like THC JS just more legal and this last part I think is really you don't get as much spaghetti code interesting you know zigg is not explicitly a memory safe language like you can do the traditional thing where in one function you create an object and then you return a reference to that object and then when the stack goes out of scope you have a reference to a dangling pointer right like that that kind of thing is allowed in Zig but what I do like about Zig is that it gives you things that SM that's good I I mean in some sense to me that's good I do like the fact that if you're using using a systems level language you should have I I do think there is something to be said about systems level controls in system level languages a SME I do think I think there is something very foot gun's good well no what I mean is that you can do what you need to do I don't think I mean obviously that is bad like it I would love it if it prevents it there's probably some sort of warning like I mean even C has a warning right like hey um dog you're returning a reference to a stack allocated VAR like you sure you want to do this you know like I I don't think this is a good idea I don't think this is a good idea right I like that shared mutable data is important yeah I I actually do agree with this what I do like about Zig is that it gives you things that smell or like taste like memory safety uh that prevent a lot of very simple bugs like for example I have the dump hex function which is doing the basic you know print out the data as as hex and what I'm doing is right now I create a chunk and the chunk is always the same size right right now the chunk size this is super cool by the way I don't know what I don't know what is but this is super cool I've never found one this is super cool what you're about to see I think this two and I have a little bit of an edge case where basically I'm able to index outside of a chunk where the value is undefined if the size of the file is odd right so if I have a file that is 51 bytes on that last iteration I've only read in one bite of data and I can iterate into the second bite so basically I have a very basic out of bounds uh right access now in a language like C this would just be okay we'd just be all right with this happening there'd be really no I me there's a way to check it we could we can make sure that we do the math and and do the calculations to determine if we're outside of the array bounds but in Zig when I run this code there is a runtime Panic it can see despite not being explicitly memory safe that I am indexing one the value one so I have line of one into a slice that is length one right and so instead of giving me some weird seg faults where it's doing an array access that the OS can see it's going to throw an error at this level and you know this is a much safer way to crash right then you know potentially going outside of the array bounds I like like C would let you do now what I'm not saying is that you shouldn't learn C what I'm not saying is that you shouldn't learn rust you should learn C you should learn rust and you should learn Zig like I think everyone should learn all the things I think learning is the way that you become I like that I like that quite a bit better not only developer but a better person in general now that being said if you have limited time I think obviously you should be picking one and choice you make just depends on what you want to do if you want to be a systems level programmer You know despite the movement towards rust things are still written in C and if you want to get a little bit and the nice part is that Zig really compiles well with C A lot of people are actually building their build tools for C in Zig just because it's so good it's like so dang good it's like Zig is so good at this that that area that the new the next no more make files no more cake just use Zig bit of a taste of what I think the future of coding looks like and what sa software looks like try Zig and try rust I do have courses at low lev. Academy go check that out link description below if you want to follow along with me on my journey and figuring out my thoughts my additional thoughts on Zig go follow me on Twitch I stream there like once a week if you like this video do me a favor hit like hit subscribe and then go check out this video we'll see you next time guys I appreciate it liked boom let's go um okay there's one thing he didn't cover so I I kind of like I kind of want to take like almost an inverse take on some of the things he said um some things that I really like about Zig Zig also has the like optionals right uh I think long as yeah there we go so you can actually say like hey this thing could be null and for you to be able to have it you could actually like this so you get you get syntax available for options but it's not as heavy-handed as rust and it's also able you can also do like an if statement right so uh let's see if they have a capture group there you go here's a great example you can do an optional of five and then if B then you capture out the internal value and to me this is you know I know there's like if let some x equals your option that this just feels less heavy-handed it feels pretty nice like I I think that a lot of things with Zig is is like almost rust it's like you're almost to rust but it's a little bit L it's a little bit less and it makes really nice oh I forgot the let if if I forgot the if let yeah if you forget the let you will spend spend like a minute going what the what the hell is this air what have I done right syntactic sugar that makes sense this is really there's there's like a lot of really nice little features of Zig that make it super compelling and it's something that I it's why I really want to to to look more into it and then another thing that is just I think is just genuinely Superior is comp time is like super super duper in interesting it's just really bizarre like right here running a Fibonacci Sequence at comp a compile time right so when we compile it runs this and you get you get that you get the value out X at compile time is the result of this Fibonacci Sequence comp time is super super interesting because comp time you can also Define types let's see if they have any example of this uh I would just like to see this there you go a vector a vector is now going to have some like cool things inside of it so you can actually create your own Vector right I want a vector of size three this is now a a compile time look at that you have a compile time with how manye El are inside your vector and the type like to to me that's like that's super cool so it's like it's almost rust macros but you don't have to have a doctorate in sin instead you can have comp time which is just writing Zig you're just writing Zig so you get to write Zig without all of the macro nonsense right because if you really want to get good at at rust and you really want to understand a a doctorate in no not that kind of sin not sin n uh s Sy YN syntax it's like their crate for being able to do procedural macros procedural macros are like pretty tough right it's it's it's it's it's procedural macros are definitely like your level three learning of rust you you you first have to start off like learning syntax borrow Checker and all that level two is like you have to go learn async and lifetimes and then level three is like proc macros and proc macros are really really difficult um yeah I've never play I I haven't done any deep with Zig yet uh but this is just super compelling cuz it's like I want to be able to write generic structures in a way that makes a lot of sense to me and that seems pretty cool this seems pretty dang cool because it's it's it's just Zig you just write Zig to execute a compile time to produce Zig yeah once you by the way also when you turn level three uh uh uh rust station you also have to dye your hair blue it's one of the requirements I hate to tell you this it's just one of the requirements okay so now for the second half which I said I'm going to bring on low-l learning and we're going to chat for a moment I'm calling him right now sorry it's just part of it I I'm sorry it's it's can I just shave my head instead no you can't shave your head you cannot shave your head it's not it's not allowed in the rust in the rust area you have to keep your hair no matter what its balding state is okay so if you're if you're if you're going deep in the back and your Homer ssing like you got a Homer Simpson you know that's it did low-l learning just like dip right now I should have his phone number and I just call him and be like hey hey get out of here I called it the Mr Clean so C++ doesn't exist C++ doesn't exist C++ okay flip you got to take this intermediate part out but C++ I will say that with the introduction of unique pointers you can write nicer code in C++ hey hey what's up this is incorrect hold on a minute I know I can't see you yeah I got the uh OBS virtual cam going on go like that boom and oh nice no video in a good time today I don't know why it's not working yeah are we going to going to cooperate hey there it is did you just say are we going to cooperate the computer yeah Oh I thought you're saying like me and you I was like called collaborate oh nobody calls it co cooperate dude I can barely read English Okay so even if I said that I apologize okay I I believe I beat you on the barely read English dude I haven't finished a book in over actually finished a book before that it was a couple years so I'm like kind of illiterate functionally functionally speaking you're kind of illiterate mhm that's okay hold on I'm trying to um okay I'm G to show this hopefully there's nothing there you go I actually have this already preset out there you go look on dude hey hey how's it going all right so you just got we just got done watching that video which I liked a lot of it there's a lot of stuff that was really cool about it um I think you know what do you think is the primary reason for learning Zig I know you kind of said it but I I don't know if I I really feel the thing you said or maybe you try to like make it too tight what what do you think is the primary purpose of learning Zig yeah I mean so you have to understand it from from my perspective right I am a security researcher and I'm trying to get to a world where people just naturally write safer code and a lot of the time you have this thing where the argument is oh it's a skill issue like people who just get better uh will write better C and you know I think that's true to a certain extent but it ignores like the human factors aspect of programming where like new people are GNA come in they're going to not know how to code and they're going to write production code that goes out so how do we create a language that just naturally allows for safer code and the quick answer is rust obviously right but I think rust has a lot of systemic issues or like like parts of the language that make it very difficult for a new programmer to get into um whereas Zig I feel like has the same like Flavor of of rust and like goes languages uh where it is safer but because of the lack of a borrow Checker and a little more freedom that you get versus rust it's just easier to get into so in terms of like choosing like the best first language I think for me Zig is more and more uh getting there in my head I still think you should learn c um but in terms of like production code I think Zig has a special place or should in the future I do I do want to double tap a little bit on that rust statement you made you said that effectively that rust is really hard to get into as a beginner I the thing about my my general take of the rust learning curve is that it starts out hard it gets easy and then it re gets harder not easier it actually gets significantly harder the moment you start jumping into async and you start jumping into any application that's of some certain level now there's people that just build like rust web ends and all they are are just like taking a you know you use axom or actic and you write a basic like crud end point and it actually works really well in Rust because all of that abstraction and difficulty has been hidden away you don't even really realize you're on some sort of like you don't even know what thread you're running on or anything it just it just works and you're just like oh this was pretty easy but I feel like the moment you try to write those things it's excessively difficult and generics can get really really really hard working with trait objects and generics is like it it is non-trivial and people think it's trivial and then it goes to a third level and then a fourth level and I feel like the difficulty of rust is a lifelong learning process and for me that's kind of like a big issue is that if you're not if you're developing something that's simple I feel like rust can be pretty fun and easy and you'll be successful in fact I would argue that you would be even more successful basic kind of like churn in your product and you're not you're still not developing something hard it's just like a lot of churn I still think rust is a pretty good language to choose sure but if you have to do the things yourself I'm just I I just don't buy that rust is a I think rust suffers from the same skill issues that c does if you just got better at rust it you'd be better it' be easier it's just skill issues and it's just like is it yeah is it skill issues I think at the end of the day I think you need to put in hard work regardless right I think like every language like you're going to encounter some amount of of uh of inertia where like you are not going to get better until you push through this wall um but I think in Rust it's the wall enables language functionality and in C the skill issue is security you can publish pre skill issue code and see it's much harder to publish pre- skill issue rust if that makes sense um that's fair yeah I mean it's easy to create like a memory leak I actually created a memory leak and and broke but but even in Rust I think like you can create memory leaks in Rust but you can't create memory disclosure leaks in Rust right like the idea of like leaking the Heap to a user that shouldn't have that Heap data is very difficult and then on the topic of I agree with you in terms of rust right Le I got I did some Rust code on Twitch um I built like an HTTP server is very simple and I'm like oh rust like actually isn't that bad like you just you know you create some structs you create some traits you write some functions for those traits and you're good to go uh but then I went on further and I tried to do embedded rust using uh Artic it's an OS that's like a framework for the STM chipset in Rust and of edit it yeah it immediately gets like exponentially harder where it's like suddenly you're dealing with lifetimes and trying to take peripherals from a chip and then you want to give other parts of that peripheral to a different function and you can't pass those around very well so like I agree like it's it's deceivingly easy at the beginning and then it very quickly ramps up and it's like oh if I want to do real code with this like it's going to get a lot harder again you could put the timing and get better at rust so I do I do agree that the skill isso this on both ends but I think if you want to get to code that's like you can you can publish it um rust has a little bit steeper of a curve than c yeah uh what so so with that and you said Zig is easier do you think the same skill issues I mean can you even make those arguments with zigg like hey you know oh for you to be able to build a high performance HTTP server I feel like that would be excessively difficult like what axom has done in Rust would take me a year of just doing it full-time to be able to probably get to that point yes so full disclosure I didn't use any of the libraries in Rust I just I like raw dog like take TCP socket parse HTTP 1.1 headers send the data right so like very Bic nurses ju what what's that registered nurses what what is that what slrn slrn okay I was like what we talking about right now I know my God a bunch of a bunch of registered nurses in my packets yeah dude uh and it was it was pretty simple right then the minute you get anything more complicated it's it's tough um and what that did is it gave you access to like learning the network API learning how to parse like do basic string iterator stuff like that yeah because the entire protocol is registered nurses right um and I think in Zig it would be similarly simple and I think simpler because he wouldn't have a lot of the borrowing issues now granted in in that scenario there's not like a bar a lot of borrowing that can happen that can go wrong right you literally pass around a single request structure to multiple functions de encapsulate it re encapsulate their response and go from there um and I think zig would just be a little more straightforward CU it feels more like C less like rust where rust has kind of like you know that there are weird edge cases you're going to run into I didn't get that sensation when I coded in Zig that being said though Zig is um much more verbose of a language where like you have to use all your variables you have to handle every error type you know what I mean whereas like you could go right C don't have that issue and I think even rust is more permissive than go than Zig is in terms of like the the variable use policies yeah you get a warning I believe instead of a uh eror you get a hey unused variable warning and then you can just you can just prefix it with an underscore yeah right but that's the thing like that's why I like Zig so much is it forces you to think through your air handling schemes from the get-go like it does not let you get away with I mean that's not true you can do the the try statement in Zig just like you have the dot on wrap in Rust right so I mean like you can AR the same though those aren't the same aren't they pretty similar no nothing is similar unwrap panics if if if it's an error try returns no try Returns the error up one level one level try is more equivalent try is much more equivalent to the question mark oh I see okay you're running everything in main so it makes sense that it like the end if if you were to put it one function uh uh inside you would actually get more like uh the question mark operator it just lifts the air one one level interesting no that's a good point okay yeah catch is so cool too because you have because Russ doesn't have syntax for catch right you have to like match you have to do something right and so it's actually pretty it's pretty interesting and also like catch unreachable is is the equivalent of unwrap you're effectively saying like this is in like it's an infallible operation you cannot you cannot can get here if you do you yeah and that's why like the error typing system right like you have effectively you have the return type that says like go left go right and then the left is a good case right's a bad case that's where all the the catch pattern matching happens so yeah like like you're saying it allows you to give kind of two paths in your code to go down one the good path one the bad path whereas rust you have this weird kind of mixing of the two based on the way that the matching statement Works um so yeah they do have some convenient functions they have like and thens and maps and all that stuff it's that and okay a lot of people just will just dot okay because that just makes it uh you don't have to handle the air at all it turns into an option and you can just ignore options yeah just forget forget that option forget about it we didn't see that it's all good forget about it yeah so it's interesting have you done much uh async Zig mm no I have not done muchen done nor async rust so that's kind of my next thing is to explore the async uh async Frameworks in particular I'm going to start doing Embassy in uh in Russ because that's the async framework for embedded so I figure you know jump into the deep end see see what that feels like yeah yeah yeah yeah okay okay because once you go async you go Arc mutex all day baby and that's where I heard kind of rust decomposes right it's like once you have the arc mut Texas it's like okay are we still in rust or are we doing some other weird meta language right yeah well it's very interesting because you one thing that I I really like about not rust is that you can have a mutex like say on an object and you can lock and unlock it where you kind of wish to lock it and unlock it right you get the choice of saying hey this is a controlled mutation under this mutex whereas with rust you just you just that cannot be an option you have to put more or less items underneath a mutex or you have to protect a singular property or you have to lift all the properties you want to access out into some sort of rewrite uh m text which I find to be very um it can be very cumbersome whereas counter it is counterintuitive and I feel like it's it just is a giant performance foot gun where it's like you can actually for the most part just be like I know exactly what I do and don't want to mutate you know in parallel on this object so for the most part I can just like rip through everything and then these couple ones are all controlled by one mutex but it's like you have to like uplift things and the struct it's it's just more trixy that's kind of my My Philosophy and I think it stems from the fact that I'm like a huge control freak right so like I feel like Zig gives me the control that I want and I have like the very explicit knowledge of what is going on and that's their whole memory model right is like they're trying to avoid the world of GBC ghost allocations like every allocation that happens in the program is an allocation that you wrote and same thing with the mutexes and the like everything that is done is because you decided to do it explicitly whereas in Russ I think a lot of those features even in a compiled systems language gets kind of lifted like the mutex example um which I'm not the biggest fan of and again my whole philosophy on learning is like you have to know what is going on under the hood and when you create those kind of abstractions it kind of I think it adds too much fairy dust that takes away from learning process in my opinion so C can you do someone's asking about ghost allocations can you give like a brief uh what is what what is a ghost allocation how does it happen can you give a yeah I mean so C is the you know when it was designed it was built to be an abstraction from assembly right you have to do everything you know explicitly like when you make a variable allocation that just creates an assembly blob right to make room on the stack um a ghost allocation is a thing in GBC where you know the GBC runtime is creating memory allocations without your permission in the background right like if you do a scanf call for example right the scanf call just reads in memory to a buffer and returns that into the buffer that you pointed to um but the memory that it's used to actually buffer it before it outputs it is allocated in gipc right so it's an allocation that happened that you didn't ask for um and that happens all over the place in libc and is used to uh you know like there are ways you can exploit that from a security standpoint like a lot of Heap exploits have to do with abusing memory that is allocated for you in the GBC runtime um whereas Zig it doesn't do any of that like to make an allocation if if memory is allocated in Zig it's because you told it to there's no other memory getting allocated which I think is a cool feature because you can kind of predict more reasonably what your function is going to do what your code is going to do okay okay uh one one more question uh when it comes to learning and all this do you think that rust you know I'm not going to say the word masquerading but uh you know like saying hey we are a systems level language do you think the fact that you don't ever really think about allocations as kind of your initial pass do you think that hurts learning the system levels thought process meaning that when I create a string I don't think necessarily this thing is now pointing to the Heap I mean I know you should understand these things and how the difference between you know a stir and a string versus like an RC or a ref cell like all these things like what do you think about that cuz that's like it's like the polar opposite of Zig Zig is like every allocation you know you've made whereas Russ it's like every allocation we're not going to tell you because we're going to also drop it for you yeah I mean I don't think it hurts the learning process in in the short term I think like abstractions are valuable because otherwise I would just say good code in assembly right you know what I mean like oh if abstractions are bad just go learn how to like build silicon to build a computer um subtractions are good but I think if you if you want to truly understand it's important to go back like the circle back and go learn like the difference between a stir and a string like how slices are actually working under the hood how that affects borrowing and all that stuff so does it hurt learning no um but is it hurtful to ignore those abstractions I think yes in the long run very cool very cool uh any last thoughts on Zig any last things you want to yeah it's cool man it's a good language um I'm having fun with it trying to learn it myself uh I think the only major issue right now and I read a lot of this on Reddit is the uh documentation like it's not great there I mean there are docs right there's like you can go read the the the standard Library docs but in terms of like examples that show you me like implementation it's kind of in a weird spot right now that being said it's it's pre 1.0 so it's in it's still in a very early like Alpha is stage I give them a lot of credit for that um but no man it's it's really really cool and I think it's going to have a really unique position kind of in between C and rust that'll help people learn systems programming without relying on c as like their first language so yeah man that's about it all right I like it I like it well hey thanks for being on here I like the video people should subscribe to you anything else any other Shilling you would like to do any other Shilling oh I I will shill away my guy yeah I mean so hey if you don't know who I am I do uh videos about security and software security and programming in General on YouTube I stream on Twitch and if you want to learn C I have a site called Low level. Academy I teach C there it's a good time come come learn C with me over there um boom boom that's it but yeah man I appreciate you having me on thanks for watching the video and uh let's uh let's do more stuff yeah I do want to do I I want to do more stuff cool oh also I bought some coffee I'm I'm looking forward to it I'm going to roast it but yeah it's this is our this is our very first batch uh I I think we're we're looking to switch uh we're looking to switch some roaster and kind of think about other ways of doing things so we we we got we got a lot of work left to do on that because it's all non-trivial so oh yeah dud the fact you guys are even shipping physical products I'm impressed with because like most online sales are like oh drop ship like pay money and then I call Alibaba and they send you a thing you guys are like literally pouring the coffee into the bags like it's a you got a real operation going on over there it's solid dude we're trying to understand things at a fundamental level and then going from there and and trying to you know make it into something but we'll see we'll see how it works cool I'm excited to try it bye-bye later brother all right there we go that was awesome I like low-level learning he's great he's great guy uh Hey the name the name is low-level fan oh aen lowl fanen lowlevel fanen F Fen