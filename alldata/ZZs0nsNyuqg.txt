one of the best ways I found to write Simple and Clean code is by being precise I don't mean it should be a pain in the neck for your fellow teammates I only accept code when the number of lines is exactly a Fibonacci number you should totally do that by the way just to annoy people anyway I'm going to show you three mistakes I see developers commonly make because they're not precise enough and also show you the consequences of those mistakes because if you're not precise you write more code than necessary and on top of that your code is going to be more complex than needed and if that's a pattern that happens throughout the bigger code base well you're in trouble so let's dive straight in before it's too late what I mean by being precise is that you're mindful of what kind of data your function or method works with and what kind of things it returns so the first mistake that I see developers quite often make is that they ask for way more data than they need and I have an example here that shows this so I have a geolocation class that contains some address information and the latitude and longitude and also have a location data class that contains some message data dates priorities and a list of geolocations and then there's a function here called generate breadcrumbs that generates URL paths and that gets location and then it has a main URL and then it's going to create these URLs and return the breadcrumbs which is a dictionary and then I have a main function where I create a location I provide location to generate breadcrumbs and that's basically it I want to run this then well this is what we get we get some dictionary of breadcrumbs basically that are being generated from the location objects now the thing is if you look at the generate breadcrumbs function it gets a location and it returns a dictionary but if you see what actually needs it doesn't really need the entire location object it actually just needs a single geolocation because that's what it's using to generate the breadcrumbs so this is a clear example of a function that asks for too much information more information that it actually needs that's what I saying by Joe Armstrong who is the creator of the erlang language which is you wanted a banana but what you got was a gorilla holding a banana and the entire jungle I think that's a nice way of understanding what this actually means the consequence of doing that is that now generate breadcrumbs is actually way more coupled because it's coupled to the location so that means that we can only generate breadcrumbs from locations so if you have a geolocation a single geolocation you you can't use this function even though it's on only uses a single geolocation so it makes your code harder to reuse another consequence is that because we have to dig deep into the location object is that we now need to know implementation details of the location class you see we are accessing geolocation and then the first elements in this particular list and what you're seeing here is actually a violation of the law of the meter or the principle of least knowledge which basically states that each unit should have only limited knowledge of the things that it's using in this case generate backgrounds needs to know too much about the location class and this is typically the kind of thing you would detect in a code review by the way if you want to become better at doing code reviews you should check out my workshop on code diagnosis you can get this by going to iron.code diagnosis it's totally free it's about half an hour and take you through a couple of practical examples of real production code showing you how to diagnose code and detect problems faster so iron.coaster's diagnosis to get access to the workshop I've also put the link in description of the video so how do we solve this problem well we need to be more specific about what generate breadcrumbs actually needs and that's actually only a geolocation so we could change this code to just take a geolocation and that's going to be off type geolocation and now we don't have to do this check anymore because we already got this object as an argument so I can dnent this code and now I can actually remove all of this code and make it way simpler because we're simply going to access the information from the geolocation specifically so I can just delete this there we go so you also see that the code node actually becomes a lot simpler and that's really nice and now the main function the only thing we need to do here is actually access the geolocation that we want to generate the breadcrumbs for and now if I run this code again obviously we're going to get exactly the same results but now the code is much cleaner and what's nice is because generate breadcrumbs now get simply a geolocation we can now also provide it with other geolocations so let's say there is a second geolocation here and I'm just using um gets up co-pilot to generate a second geolocation apparently it really likes Toronto so I'm okay with that so now what I can do is simply change the number here and then when I run this I'm going to get the other geolocation so this makes our code way more flexible simply by being more precise the second mistake that I see many developers make is that you're not specific enough in terms of the type of data you can handle as an argument in a function or you return as a result and here I have an example of that so I have a class Yuri which has a scheme Authority path doesn't really matter what this all contains there's a string donor method as well and then I have a function two Yuri that takes a string or an ins or bytes and then returns a UE or a Boolean value if it's a string or an INT then it's going to turn that into a bytes if it's less than two characters it's going to return false because that's not enough information to generate a Yuri from and then it's going to return the urea object based on encoded version of this string integer or bytes that you provided to the methods so then I have a main function where you can enter some data it's going to call the function to Yuri and then it's going to depending on result print URI or print invalid data so let's run this and now I'm just going to enter some data so let's say I'm going to enter iron code and then it's going to generate this particular Yuri but let's say if I do a single character I'm going to get the error invalid data so it might seem nice that too Yuri actually accepts strings or integers or bytes because that means we can call it with all kinds of different types of values and you can handle it without a problem but the issue is that this also complicates the function because now we have this extra if else statement at the beginning to do all these conversions and not only that it means we also have to write tests for that and there's another problem which is that because we allow all these different types we also have to write documentation for that and maybe somebody might actually miss interpret the thing that we're trying to pass for example maybe somebody thinks that oh I can pass an integer perhaps that's the length of the urea or something like that while it's actually the data and another problem is that if you ever need to refactor the code you also need to make sure that all of these different cases still work and you might introduce bugs during the refactoring process because of the flexibility that this function has what is typically a better way to do it is to be more strict more precise about the kind of thing you accept as an argument so for example we could change to Yuri to Simply accept only bytes like so and now I can delete these lines because I really don't need to do that anymore until Yuri now becomes way simpler now of course the problem is that here I'm calling to Yuri With Yuri data so now I need to do the conversion here which means that I have to do a little bit of work here to convert it to the right format that's no particularly problem but one way to solve this to sort of have your cake and eat it too is to have convenience methods that do allow you to provide specific other times for example I could add a two Yuri from int and the two Yuri from string that takes a value of a particular type so still being specific still being precise but that converts it into byte so that two Yuri can actually use it and then in my main function I simply call to Yuri from string and now when I run this version again we get working code and what's nice now is that we have a simple function to Yuri and we have a couple of convenience functions so we still get to write a simple code in our main function and our functions that we use are simple and precise now the same goes for return types so in this case to Yuri returns a Yuri object or build in this case depending on the length of s and because of that we need to handle that in the main function and everywhere we use these functions so that's not ideal either and even worse this code is probably going to be almost duplicated everywhere since we have to handle it mostly in the same way all over the place here I have a slightly modified version of the code where two Yuri simply returns a Yuri object and if the length of s is less than 2 then it's going to raise a Yuri to short error an alternative would be to actually allow shorter length data and simply handle it here but I've added this here as an example to show you the difference and this Yuri to short error that's a custom defined exception that I have here and I've used a little trick which I sometimes do because I do like to pass data to my exception so that I can use that later there's also a string version of that that contains also some information about the type of error but that means if I catch the error I've actually access to the object and the data in that exception object so I can use that in various ways so this raises a Yuri to short error and because it used the exception mechanism and it only returns one single type of thing in my main function I can actually simplify things even more because well assuming that I don't want to handle this exception I don't have to deal with it at all and my main function now is just three lines of code so when I run this and then I type let's say this which is two shorts so then I'm going to get my two short error the third mistake that I see a lot of developers make is that are being too specific about the type of thing that a function accepts so you can be not specific enough but you can also be too specific and here I have an example to show that so I have a simple function counts that takes a list of words and returns a list of integers and then what I'm simply doing is it's very basic function it comes the length of each word in the list and then returns a list of integers with all of the lengths and then I have a main function I have a couple of words then I count those words and then I print the results so when I run this then this is what we're going to get 5 6 and 6. now the issue is if you add type annotations like this which by the way I highly recommend that you do because your code is much easier to read then you have to be careful to not artificially limit yourself for example here we defined the words arguments as a list of strings but when you look at how words is being used the only way it's being used is that it's being iterated over in this for Loop and because we Define it here as a list we now can supply a tuple or a set and there's no reason to not being able to supply that because we're only iterating over the thing so instead of using a list we could also make this a bit more generic and say that well we actually accept an iterable because we're only iterating over the thing so now instead of using a list I could change words to a tuple for example like so and now the code would actually still work without any problems because I made sure the type annotation is actually appropriate for what the function needs you can even take this a step further for example this is an iterable of strings but actually if you look at it we don't really care that these things are strings because the only thing we need is we need something that we can determine the length of so I could also change the string type to sized because that's simply the type annotation for the type that has the lam donor method which is what the Len function calls so now this still works but it gives us even more flexibility for example I could create a list of lists and then we have this and now I can count list of lists and this also works just fine because of course these lists have the length attribute so by being careful about providing the right type annotations we can actually allow for a lot more flexibility in your functions which is nice by the way I didn't change at all the return type and that's actually for a very particular reason which is that for return types as opposed to arguments you actually need to be very specific because we need to know what kind of thing a function actually returns as you can see result there's a list of integers and we simply impact the length to it and then we return that value so we know exactly what kind of thing the count function is returning so we should be explicit about that so we're being as generic as possible in terms of the types of the arguments so that it's appropriate so that we're not artificially limiting ourselves but we're also being very specific about the thing it actually returns so that when you get the result you know exactly what you have and then you can call the right methods on it so now we know result is the list and then we can do list specific things with it but of course list is still on iterable so we can also do interval specific things with it so that's funny like the arguments the more generic we go here the more flexibility it gives us and actually the more specific we are with the return types also the more flexibility we get because then we know exactly what we're getting and how to use it so the way it works for parameters versus return types is opposite now the question is how far do you really want to go with this I mean it's nice that you can do this but it's also maybe a bit of extra work so what I often do is that I actually start with pretty specific types especially for functions you know simple things that I use internally I don't really mind that much about the types not being perfect on own spot and exactly appropriate for what the function is actually doing but if you expose the function as part of library and other people are going to use it then it's typically better to spend a bit of extra time to think about hey what does this function actually need in terms of arguments can I change the type so that it's more generic and sometimes that might actually result in a design change for example you might decide to change the name of the function based on changes and types for example let's say initially you said this was a list of strings and and you might have named the function like this count string length but then you realized oh actually it can be an iterable of size so then I'm simply going to call it count because that's more appropriate for what the function is actually doing so thinking about typings actually also helps you improve your naming and make your code a bit easier to reuse I'm curious how much attention do you pay to create write the correct type annotations do you use things like iterable and size do you think it's worth it to do it or do you think we should stick to simple types like list strings and dictionaries let me know in the comments finally there's a few other more General things you can do to keep your code Simple and Clean so the first is to pick appropriate data structures and algorithms some data structures are simply more suited to a particular type of operation than others so if you pick the right one it's going to help make your code a bit simpler also you typically want to avoid premature optimization so you may be tempted to write code that has Optimal Performance and does all sorts of tricks to make sure it's as fast as possible and of course it's nice to have fast code but while you're coding that's not typically the thing you should focus on because often you'll still be refactoring after that and there's many cases where performance is actually not that important so don't focus on that too much because it's very easy to hamper readability and having readable code is way more important in my opinion another thing you can do to keep your code simple is to make sure that you are using external libraries as much as possible this simplifies your code because you don't have to write that stuff yourself that's already in the library and second often the library already went through a couple of iterations to improve things make things better faster easier to use so you don't have to go through that process yourself I found personally there were huge benefits to being extremely lazy and relying on external libraries as much as possible and the final tip is to make sure you regularly refactor and simplify your code so whenever you're writing code you're working on your code just spend a few minutes and tweak a couple of things here and there simplify a couple of things when you see something that can be improved this is what Robert Martin calls the Boy Scout principle so leave things in a better place than when you started working on it but really the best way to start writing simpler and cleaner code is to just practice a lot with it and look at other examples online a good place to start is by watching my latest code roast where I do a full refactor of piece of code and apply all the techniques and tips that I talk about today click right here to watch that video next thanks for watching and take care