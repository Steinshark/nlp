hey everyone welcome back I'm James Murphy and this is M coding today we're going to be talking about a code smell that I recently encountered the smell I'm talking about is Lambda inside a loop so first off what's a code smell well a code smell is kind of like other smells in real life if you smell something really smelly that doesn't necessarily mean that it's bad but you might want to look into it there can be really smelly things that turn out to be just fine I'm looking at you cheese but most of the time if something smells really strongly there's a problem basically what I'm saying is that if you see a Lambda inside a loop then you might want to take another look because this is usually not what you want but before we move on give me just 30 seconds to talk about my favorite sponsor of all time myself that's right I'm sponsoring my own video this video is sponsored by m coding which is my consulting company we do Consulting Contracting training and interview prep whether you're a programmer an engineer whatever you are if you have a software project at your company that you think deserves some outside eyes please do Reach Out emcoding dot IO thanks for listening let's get back to the video so without further delay let's dive into this example this example is from a real code base of course the code has been drastically simplified to fit on one-ish screen for you and it's been changed significantly to protect the guilty parties it's me I'm the guilty party so here's the basic setup we have some work that needs to be done meaning functions that need to be called some of them might take a long time to complete but the catches were in a GUI application so the real example this comes from a GUI application we can't just call these functions on the main thread because that's where the GUI runs if one of these functions takes a long time to complete then our application is frozen until it completes so instead we'll run things in a thread pool using a thread pool executor we Loop through all of our work and submit each function that needs to be called as a task to the executor the functions will eventually get called on a separate thread and we'll use done callbacks in order to keep track of which ones have completed in this demo code I'm actually creating the threadpool executor right here and then when the with block ends it will actually wait for all the tasks to complete in the real GUI application the executor was a pre-existing object and we also don't wait for all the tasks to finish at the end of the function instead we just do this interloop basically submitting more functions into the executor and adding the Callback in particular the real version of this function is not a blocking call but it still has the same problem with Lambda in a loop so here's how we actually call the function down in Maine we're creating our list of work each piece of work is just made up of some unique ID and then the callable that I'm supposed to call in this demo our work is just printing out ABCD but of course in a real use case these could be complex calculations or doing whatever you want as with some of the worst kinds of Errors when we run the code everything appears to be working just fine well bacd those definitely ran out of order but that's not really a problem we were submitting these things to run on multiple different threads the fact that they completed out of order should be expected and from our callback we see that completed was printed four times so they all seem to be called just fine the problem actually shows itself when we run this again trying to print out the actual task ID instead of just the word completed apparently task C completed twice but task B never completed I guess you just double shipped one customer's order and lost another customer's order well no because our tasks actually printed out ABCD we can see that each of ABCD ran exactly once so here it's pretty clear that the problem is in this printing of the task completed and not with the execution of the tasks themselves but in the more realistic scenario where the tasks are not printing out their own names and these task completed messages in the logs are all you have to go off of then this might make for a very alarming log so back to the dispatch code what exactly is the problem with this function and in particular with the Lambda the problem is that I used a Lambda in a loop and because of the way that lambdas work the task ID that the Lambda uses is not the value of task ID when the Lambda was created instead the value that the Lambda uses for task ID is whatever the value happens to be in the current local variables of this function meaning when the future finishes and the Callback runs it's going to use the value of the last submitted task ID not the task ID for this task we can see the most extreme version of this by sleeping a little bit longer to ensure that all the tasks are submitted before the first one finishes in that case they'll all be using the same value of task ID the last one and that's what we see it looks like task D was completed four times when in actuality the actual work shows that each task ran once I do have another video explaining how these weird variable lookups work but in this video let's just focus on how do we fix it luckily it's a pretty easy fix 99.9 of the time when you have Lambda in a loop what you really wanted was Funk tools partial the first argument is the function that you want to call and then you can pass in any subsequent arguments or keyword arguments that you want to pre-fill for that function add done callback expects a function that accepts just one argument a future so for this function we just need to pre-fill the task IDE and then leave the future argument not filled the important distinction here that makes func tools partial work where the Lambda did not is it functional's partial actually stores this value the task ID somewhere inside of itself whereas the Lambda was trying to look up the value in this outer scope each functional is partial stores a different task ID the current one whereas the lambdas we're all trying to look up the same task ID which is this local variable now when we run it we see what we'd hope each task is logged as completed exactly once but of course there are always exceptions although this use case of a Lambda in a loop was bad it's not always bad there's only certain situations where this is a problem the thing that made this a problem in this case is that we're using this variable task ID which is not a global variable and it's not an argument of the function it's a variable that needs to be looked up in this outer scope if you weren't using any such variable then it's just not a problem it also wouldn't be a problem if you were just immediately invoking the Lambda in which case you are using the most current value of task ID but doing something like this is pretty rare that's more of a C plus plus thing if you know what I mean and I guess I should come clean yes this is not just a Lambda problem if you defined a local function it has all the exact same problems in my experience though when I see this mistake in real code it always seems to be a Lambda not a local function it's almost like people sometimes just use Lambda because it's less typing and less thinking rather than because it's the most appropriate choice for the situation you know I've even heard some very experienced programmers say that they think all usages of Lambda are a code smell I'm not so sure about that but maybe I'll get there and my last tip for you is that like many common problems in Python a good linter can stop this before it ever happens let's run pilint on this example I mean pretty aggressive for warning on every module function or method that doesn't have a doc string okay but you can turn that off right but as you can see here is the no Lambda in a loop of course they're not biased against lambdas in particular this cell variable is the more General terminology that encapsulates both lambdas and function definitions yeah cell variable is more accurate but no Lambda Loop is way catchier right that's something that you can tell a co-worker in one line no Lambda and a loop once again I'm James Murphy from M coding thank you for watching and as always thank you to my patrons and donors for supporting the channel I really appreciate the support if you like my content please do subscribe and if you really enjoy it consider becoming a patron on patreon thanks and I'll see you in the next one