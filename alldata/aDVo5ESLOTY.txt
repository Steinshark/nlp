what happens when an arm processor starts if the device has an unrecoverable fault how does it know what to do if the board receives a timer or a cystic interrupt what code does it run we'll be talking about this and more today on low level learning what is up guys welcome back topic today's video is the interrupt vector table if you're new to the channel i've been working on a custom rtos on twitch link in the description below the rtos is designed to work on the stm32 blue pill which is based off of the arm cortex m3 processor this project has led me to some pretty interesting discoveries about how the cortex m3 works specifically regarding the interrupt vector table and there's an interesting twist at the end of the video so make sure you stick around the inner vector table is like it sounds a table of vectors for the processor to execute when it encounters an interrupt well what does that mean the interrupt vector table is literally just an array of pointers that point to code that gets ran when specific events on the board happen the purpose of each vector is predetermined by the developers of the cortex m3 spec and is explained in the cortex m3 developer guide which i'll put a link to right here and also in the description below by default the location of the ivt is the location zero on the board this location can be changed by updating the vtor register or vector table offset register to give the board a new location to look for its set of vectors so looking at this chart here for example the reset vector is the pointer to code that the board will execute when the cortex m3 is powered on so when you compile the program to be flashed to the blue pill for example the output binary contains a reset vector pointing to code that initializes the board and then eventually calls your code or for another example the memory management fault handler is code that the board will execute when it makes a memory access error okay so now that we have the idea laid out let me show you guys how to code up a simple arm cortex m3 interrupt vector table using the bare metal arm gcc build chain all right so to make this interrupt vector table work we have to do a few things step one we are in our vector.s file right now this is the assembly code that will contain the code that contains both our interrupt vector table and our main routine so step one we have to tell the assembler we're in the vectors section by saying we're in the vector section that'll tell the linker where to put the rest of the section below it at the right location on the board so it knows where the reset vector lives next we'll say that this is the sp vector right so if you look at the chart here that'll pull it from the developer's manual the first entry in the ivt is going to be the default value of sp and we'll make that the word zero this should be a proper address in ram i'm just not going to solve that problem right now so next is going to be the reset vector right again we're using the document from the developer manual to figure that out but the next one is reset so this will contain the address of the function that our board goes to when it resets we're going to go to the address of main right you know the function we want to call when the board turns on so now that we've gotten done with all of our vectors and again you can go down the whole list and do your you know your non-mask will interrupt your hard fault your bus fault and go down the list and do them i'm just not going to solve that right now because it doesn't really matter um next so this is the section for vectors this lives at one location the location is address zero on the cortex m3 uh here on line eight we're making a new section for text text is the code that actually gets ran on our board and that lives at a different location in memory what we're gonna do is we're gonna put it into thumb mode because the cortex m3 does run in a thumb state check out the video linked here for the idea of what thumb does um and after we set it up to be thumb mode we're gonna define our function right function main and for now we're just going to infinitely loop back to main i just want to show you guys the idea here right and then so because we are in thumb mode one thing we need to check out actually if i were to compile this you know we get an error don't worry about that that's just a little warning that we didn't define the start symbol it's not a big deal if we object dump this you see we get a few things right so our code lives at hex address 8000 and our vector table is correct our vector table lives at address zero and the reset vector is also eight thousand now that's actually problematic because this is a thumb mode address notice the two bytes for instructions and not the four but this is not a thumb mode address so to actually fix that and make it so that our our vector table doesn't crash as well we need to increase main to one so by now making it eight thousand and one we'll do that real quick and i'll show you guys by making it eight thousand and one that tells the reset vector that the vector is going to be a thumb address and that's actually a requirement in the cortex m3 manual that all ivt entries for the core m3 are set to thumb addresses the exception being obviously the stack pointer because the stack pointer is not code right it's it's data so that's all well and good but one problem with this is that this project doesn't scale very well you're kind of manually hand jamming every aspect of the vector table um i wouldn't suggest doing this if you're doing a big project and actually for my rtos i'm not doing it this way at all i'm actually using the lib open cortex m3 library that has some pretty cool tricks to make the interrupt vector table happen almost seamlessly so you can kind of see here in vector.h they create a structure to actually represent the table itself you know the top being that sp value we're talking about and eventually your reset vector your nmi etc and they have some pretty cool pragmas that actually set it up so they globally define that structure in their linker table and then if you don't set these symbols so like if you don't have a function called nmi if you don't have a function called heart fault handler they set it to a either null or blocking handler which are these two functions here that either do nothing like let the processor go back into a regular state or in the case that you have a hard fault that happens for example you just infinitely loop right so what that allows you to do actually is it allows you to just declare functions called systick handler or hard fault handler that could automatically put into the interrupt vector table so actually pretty cool so for example here in my rtos i have to run a scheduler every set amount of time to allow the rtos to change what task is running i do that by creating a systick that runs at a thousand times a second the cystic handler is created by you know enabling the systick but then all i have to do is define that systick handler function and that overwrites the weak pragma of the null handler with my function that i have right here and then inside of that cistic handler i do the code that actually executes the scheduler and changes out the task it's not complete yet that'll probably happen on stream this sunday well guys that's all i have for you today i hope you enjoyed that video pretty short but i wanted to give you an idea of what the ivt did and how it could help you and your future arm embedded endeavor so if you liked that video do me a favor hit like hit subscribe and we'll see you guys in the next video take care [Music]