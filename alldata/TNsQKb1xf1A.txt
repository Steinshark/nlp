how turbo repo is porting from go to rust or strategy for making updates and maintaining stability while we migrate languages okay we've read something earlier this year that was about how they they ported turbo and now they're doing this whole turbo repo business so let's see this all right we could we should recognize some of these people here let's go in a previous blog post with the one we've already read right uh we talked about why we are reporting uh turbo remember it was like rust makes developers happy when you have happy developers they tend to work better blah blah blah blah the high performance build system of uh JavaScript and typescript from go to rust now we're going to talk about how it's pretty exciting let's see the how let's see the Nitty Gritty today our reporting effort is in full swing moving more and more code to rust but when we were starting out we had to make sure that porting was feasible for us to accomplish a migration from one language to another is no small task and there's a lot of research to do up front uh to ensure that the end goal is attainable yes here's uh how we started the process validating our current porting strategy and made the call to Port turbo repo rust I think that anything that involves a bunch of system calls I go on the fence of whether you should stick with rust or or or stick with go or go to rust honestly I think there's a lot of value and go in this and I don't think you're I don't think go and rust you're gonna experience a huge slowdown or difference in fact I think writing in Rust you might even find yourself slowing down because you're just not good at writing it right I am very curious which is better right uh Port versus full rewrite when we are planning our migration we briefly considered a full ground up rewrite but talking the idea through we realized it wouldn't fit our goals as well as an incremental Port would what is an incremental Port incremental porting moves code piece by piece running new and old code together at the same time Roman writing pretty much uh the goal for the chunk of code uh being moved is to keep the behavior exactly the same as before it was ported yep you're just going piece by piece there's like a the first block is the hardest block because it has to do like the core work and then you slowly start unraveling that you know what I mean in our case this means we need to have our go code and rust code interoper inter-operating with each other we want to do simple translation explicitly avoiding making improvements or changing functionality while we're swapping out the languages for uh the slice of code that way we can do an intensive testing against both sets of code and complete the migration as quickly as possible why we didn't do a full rewrite full rewrites are very tempting they are so tempting and they seem like the best time plan every single time they are more simple to write and ship as you don't need to worry about the before and after code working together you also get a clean slate to write new and improved version without the warts and Technical debt of the previous iteration however full rewrites also come with some serious downsides agreed completely agreed this is a great little this is a great chart honestly is that this is what your code did look like this is what it looks like now and you fundamentally changed pieces so it's like really hard to go one-to-one on how it's going to operate and everything first a full rewrite tends to require a complete halt to shipping new features otherwise you run the risk of chasing a moving Target as the old code base grows while you catch up with your new code full rewrite also does not guarantee a better user experience often a rewrite ends up less than seamless and it's as it's not feasible for the new version to match the old one feature for feature Edge case for Edge case the surface area of the rewrite grows there's more room for error and as the users can end up frustrated with the breaking changes and missing features good reason not to do full rewrites I'm always very skeptical of full rewrites full rewrites are almost always a mistake almost a full rewrites also require building an entirely new code base which is a large quantity of the unused code in our experience unused code even when verified with tests can be a breeding ground for bugs we wanted to make sure that any new rust code was properly exercised as we moved through the porting effort this is good uh just delete all the old project remember the mistakes you didn't go and rewrite and rust we choose to Port therefore we decided to Port turbo repo to rust instead of doing a full rewrite the reporting didn't uh necessitate some trade-offs so we had to introduce a significant amount of complexity into our code base so that we could interrupt between go and rust this complexity meant slower developer velocity to start with but we look forward to workflow improvements going forward particularly when our porting effort has finished more importantly we know we could continue shipping features to Turbo repo users while porting All Things Considered we determined that this was a reasonable compromise and a path we would take perfect I think this is really good honestly I think this is a really good reason to do that starting the port uh rewrite uh rust and go please yeah just switch it up just rewrite it just rewrite it already I we've already heard this song all right we choose to start by writing a small new turbo repo feature in Rust this way we could add new functionality from the roadmap for our users integrating rust into the build process and interacting with the existing Guild code as little as possible to reduce our initial complexity once we laid the groundwork we knew that we could slowly Port more and more code to rust over time Global turbo we decided to have our first rust feature be Global turbo a feature that allows users to install turbo repo as globally available command on their machine okay a global installation of Turbo will look for a locally installed turbo program in the rep in the suppository executed if it exists or otherwise fall back to a global turbo binary that way you could easily run Turbo from anywhere in your uh suppository and keep and also keep a specific version of Turbo pinned to your package Json this is great that's uh this is a perfect way to do things beautiful beautiful uh let's see see apps web turbo app info uh turbo no local local found run run run run run beautiful this feature is implemented through what we called the rust shim a bit of rust code that wraps the existing go code the goad portion is compiled via seago as a c-static library and then linked to the rust binary luckily Global turbo only requires a few features from the rest of Turbo repos code such as a reading configuration and navigating the file system okay why not turbo in Turbo Pascal though it would have been the best uh this is where it gets uh uh [ __ ] okay okay okay CLI parsing as we implemented Global turbo we realized we needed to parse a few command line arguments like current working directory the argument for setting Turbo's current working directory well clap come on get clapped kid after global turbo it uh it made sense to continue by porting the rest of the CLI argument parser to rust to parse arguments we used clap let's go clap claps the best Russ equivalent to the npm package of an npm package it's just so good though clap lets you define a data type with the arguments annotate a little bit of it and automatically create a parser let's go with the pieces in place we had to work on sending the args from rust entry points to the go code for better or worse C is the standard foreign function interface uh ffi let's see so we had the UC communicate between rust and go what do you mean do you see you have the right C for this you couldn't just directly call if you're doing a static link Library I thought you're doing like a c build of the go I'm confused do they actually write C do they have like a bit of C in in betwixt go is in cabi compatible I don't know is it I thought it was because rust is C ABI compatible there's like a little flag repercy or something like that that you can put on the top rust seago see the great equalizer makes everybody cry in segmentation fault uh we wanted to avoid having too many types in C as we weren't confident that we could write cross-platform C types that played well with both rust and go instead we decided to serialize our arguments to just on and send them to go as a string even though just on serialization does have some overhead we knew these argument structs would uh only be a few 100 bytes in size so the performance would be minimal yeah that's fine I'm surprised you know when I hear this I'm actually surprised they didn't uh just run the go program as a sub module and then allow standard in and just like right to standard in like do some basic IPC or something like that uh on this on Rust side we used another Cornerstone of crate of the rust ecosystem which allows you to by the way that's properly High I didn't know if you know that but to say Saturday correctly you have to say it like that anyone that tries to give you some other way they're lying to you okay Saturday and Jay diesel would have solved this because Tom's a genius let's just face it when which lets you serialize and deserialize data in various formats using some minimal annotation for the go side we were already we were already using in the code base so it was easy to receive suggests on string and just serialize into a ghost struct well plus go supports the chasson at a first-class Citizen though heterogeneous lists are a bit odd ship it something I said pull the plug that usually means to kill it so that didn't make any sense by the way sorry for this like this light part I'm reworking the lights that's why I look a little green right now with these two features ported we were are we are ready to ship our first hybrid go release however before we could release we need to make sure the go rust binary worked in all the various contacts that turbo repos use like different operating systems and Linux distros that we supported as we tested our code we started noticing some issues on a couple platforms Windows difficulties you know the easiest way to get around windows difficulties is just don't support Windows honestly boom first try classic Windows issues ebn ebn every time I swear it is just the worst on Windows there are two main tool chains Microsoft's visual C plus plus msvc and minimalist gnu for Windows mingui uh go only uses mingui but we we're using Russ with msvc oh gosh this caused some runtime issues but luckily the solution was simple we moved rust tool chain to uh mingui next up we had some issues with pass Windows has a couple concepts of past including what's called a universal naming convention young path really that's funny it has a Windows has a couple Concepts one of them is called Universal naming convention is that not working or something for everybody is it not quite Universal as promised when you ask Windows to uh canonicalize a path resolving all Sim links and normalized components in the past it gives you a UNC path however despite its name UNC paths are not supported everywhere classic Windows W oh my goodness this is just like Windows to a t what's that that's a gwid where's it supported on Windows nobody else uses it everyone uses uuid we do Global unique identifiers around here what's that Universal naming conventions who uses it Windows does universally available in Windows sometimes not even Windows itself oh yes not even Windows uses it this caused a few bugs where we provided a UNC path to get an invalid path here the solution was to use helpful rushcraft called dunce that lets you canonicalize a path and get non-unk path back handling the intricacies of this problem for us let's go Alpine Linux the second set of challenges came with alpine Linux the one where you hate your life at versel we use Alpine a common operating system for cloud computing to create lightweight containers for building your projects yeah it's fun until you have to use it uh Alpine though does not come with a G lib C the de facto implementation of the C standard Library this is a problem because many binaries assume glib a glitzy is installed and don't package it themselves there are some libraries that pave over this issue by using packages like uh G compat or lib C6 compat but they didn't end up working for us because the version of glibsy that rust requires was too modern uh for our supported targets when we tried to run the binary we'd get errors that required glibsy Classic this is like such a classic as a result we just had to compile turbo repo as a fully static binary this meant we packaged our own C standard Library implementation using muscle uh you can't a statically link uh glibsy due to licensing issue beautiful licensing isn't licensing just the best isn't just licensing just the best like to me if this is a thing that's available it just seems like your licensing sucks uh this seems to work just fine for both rust and go is it because glpsy is like uh under the license that requires you to also do the same licensing for your project isn't that like the required well not all open source is open source you know what I mean some open source is like a cancer and it spreads wild and fast whereas others aren't like that right and so this one is more like a virus type acting where it's like you do if you use me then you must be the same the same version of Library we use right and so it spreads it's like rxjs it spreads spreads to the whole code base this seems to work just fine for both rust and go Russ lets you set the C standard library in the Target okay uh versus this and go does not use a c standard Library by default however when we ran the statically linked live binary it would return a segmentation fault got him even worse would be inspect it with the debugger we find a corrupted stack and even worse the seg fault appeared to be coming from go runtime itself this makes me so sad to hear all right after searching we tracked down to a seven-year-old GitHub issue which explained that go cannot be compiled as a c-static library with muscle uh this post a significant challenge as Alpine Linux is essentially essential platform for Turbo repo and its users we had to go back to the drawing board and figure out how we could ship our go rust combination eventually after a ton of deliberation we came up with a solution we'd compile our go code and our rust code as two separate binaries the rust code would call the go code and pass the ARG serialized to Jason via the CLI I feel like did I not say did I not did I not say a little IPC did I not say a little in and out give it the old in and out it called it uh it's not terrible it's actually not a bad idea okay I know this may seem hard but honestly when you're doing when you're doing Roman writing like this where you're kind of writing two different environments just make it simple do the thing because you know that one part of this is gonna go away forever you know what I mean we knew that the args were small enough that they could be passed by a CLI without too much of the performance hit and because we were using a serialization format the code changes were extremely small all we had to do was change how rust was sending the jeze on string to go with that we are able to get our first hybrid uh go rust release out the door the first version of Turbo was shipped to you using these compilation strategies version one seven zero what we learned uh though this F let's see though this effort we or through this effort we learned a lot about moving from one language to another let's take note of what we found serialization is useful for ffi our first takeaway is that serialization formats are very useful for interoperability by serializing the Json a format with robust support in both go and Russ we were able to minimize our ffi surface area and avoid having a whole uh class of cross-platform issues so one thing I would have done differently than they did is I would not have used Json I would have used something like protobufs and the reason why I would have used protobufs is that protobufs would have provided a universal um serialization format and deserializer serializer and so you kind of get one place to Define your types and then your types are defined for both programs you don't have any of this like moving Target type nonsense I I like you know what I mean that's just something that I I fully I'm like fully on board with is always if you have two different platforms you're using use a common type definition you know what I mean the moving Target issue yeah exactly cross-language bugs uh when we had to switch from single linked binary to two binaries we were able to do so with relative ease because of our ffi surface area was so small okay um I I would say that I just I I don't know if I agree with this because I haven't done enough ffi to have a strong opinion about it but it seems like you were doomed before you started and I think you had some odd ffi stuff because you were dipping into C to call from rust to go I feel like something was wrong there just just like in general I'm not really sure what was happening but I just the engineers at Purcell are very very smart so I'm just gonna assume whatever was the reasoning it was it was the correct reason right uh protobufs worked fine between rest and go exactly uh the trade-off here is that is that serialization and deserialization is slow you can only depend on this technique if either you know your serial serialized payloads will be small or you don't care about the performance hit to your use case yeah um porting takes preparation the second takeaway is that incremental porting is feasible but requires a lot of careful testing and strategizing agreed uh we ran into quite a few tricky bugs and we caught these issues through a lot of automated and manual testing right here okay check out their testing testing is also extremely important for nailing down the behavior of your code whether it's an exact Edge case of CLI parsing or the order in which configuration is loaded these exact details are not so crucial when you're writing your first implementation but they're absolutely Paramount to avoid breaking changes during port or rewrite you should aim to write tests before you start reporting your code so you have a known specifications to work against okay so I would say this is the one time where I would agree with like tests before code and the reason why I say that is because you already have a working version right you've already figured it out and so to me this makes more sense but I would no actually I disagree with it now that I'm arguing this to myself out loud I can already feel myself disagreeing with this already which is that the reason why I don't agree with this is that when you're rewriting in a different language your structure and how you're doing it is so much different and what you don't want to do is mirror your current code base into a new language you want to write it with the idioms the canonicalization of that language not the language you're using and so if you don't if you don't if you try to write your test beforehand you may go in with the go knowledge of doing things versus going in with the rust knowledge so I I feel like I wouldn't I feel like you're you should have a set of uh of what's it called you should effectively have a set of integration end-to-end tests that you can prove work and then your tests are already written for this new this new one right so it's already existing um that's my personal feeling right you wouldn't want to input you wouldn't want to test against the uh the units level more like the end to end level if you don't embrace the language features why the hell are you using rewriting anyways exactly so it's not really tdd at that point all right cross compatibility is difficult the third takeaway is that cross-platform cross language release engineering is extremely challenging this is why I think a lot of people default to interpreted languages every platform language and compile that's also why people love go they love go because it just seems to work everywhere it's one of the most this is why go is just such a popular language is that it just works everywhere nicely every platform language and compiler has their own quirks that makes interoperability difficult and more things you have working together the more opportunities you have for new complications porting is worth it for us finally while porting from go to rust has been challenging it has been proven correct choice for us strategically even with our porting effort going on we've been able to ship new features handle bugs in our existing functionality and help keeping our users or and keep helping our users while we migrate it requires some extraordinary tricky debugging careful planning and rarest testing but we believe that it's been worth it try Porta turbo repo try turbo repo whoa turbo repo saved this many hours of time for the product engineers and CI machines at for sale nice that's a lot of hours that's a lot that's a lot of hours even if it only equates to five seconds per build fine like when you have a build that goes from three seconds to 10 seconds like there is this point in time that's like the I just accidentally went on Twitter time you know what I mean there's the I accidentally went on Twitter time and that happens at around like what 15 seconds right so I totally am like I'm totally on board for the faster it gets oh Anthony she was here to answer articles about this oh Anthony I didn't realize you're here um I'm Gonna Keep spamming it well awesome I like to hear that it's 10 seconds for a user to switch tests yeah you got to be very careful well hey Anthony I didn't even really uh stay tuned for the next article rewriting turbo repo and CSS now that's the article we want Anthony that's the article um this is great Mastodon oh gosh no this is not even a part of it I needed another Mastodon server because apparently having interviewed at the NSA 13 years ago when I was an undergraduate means I'm banned from programming languages server fediverse are you okay people use massdot Twitter's just read by a bunch of power hungry billionaires Mastodon also it's just like okay what kind of bargain are you getting it why why I love Reddit mods if I could have anything in my life it would be Reddit mods running my social media site like that's what I've always wanted in life you should read the image you can no longer use your account and your profile and other data are no longer accessible you can still log in to request a backup of your data until the data is fully removed in about 30 days we will retain some basic data to prevent you from evading this uh suspension uh don't work for the NSA do not work for the [ __ ] NSA do not interview for the NSA do not entertain the possibility of working for the NSA I thought you were cool double exclamation point I saw you on PL Twitter and thought you were a neat person why would you work for the effing NSA again why would you want a Reddit mod controlling your social media site just letting you know why would you want that every time I think Twitter couldn't get any worse I literally read this and go oh yeah Twitter's pretty pretty freaking awesome