I want simple not just easy now if you do not know who this is we are talking about a bit of a a zig core what is it he's one of the core maintainers of Zig uh I know he does a lot I know he does a lot of streaming he does a lot of uh we'll link all of his details down below I I know he's community community manager of something right but I think he also contributes to documentation just all sorts of things you've surely read plenty about how simple is good but what's wrong with easy oh I love this take ooh I love this simple too complex is the dimension that describes how irregular and interconnected a system is simple systems can be broken down into smaller pieces that are understandable in isolation if you make changes to one of those pieces you don't have to fear unexpected ramifications in parts that are not directly connected to what you're operating on ah I see you've never programmed JavaScript JavaScript I love it we don't use typescript around here uh complex systems are the exact opposite you need to keep in mind a lot of things that and tread carefully okay okay easy to hard you know I would actually make some argument that in some sense rust can be complex by this definition in the sense that how you design a singular component can have great impact on the rest of your system and as you make changes to that you do kind of have to outcrop all of it you know what I mean you do have to kind of go through and and you'll have these large wave of impacts based on it it's kind of it's interesting Rush drama we will do Rust drama here in one second though you're not getting baited the next article is the rust drama easy to heart is a dimension of how much energy and time it takes to successfully execute something easy things generally require less preparation can be done reliably even by inexperienced individuals by definition hard stuff requires more effort and not everybody gets it right all the time okay good I like this I kind of like that already I like the idea of separating these two things as two different lines right I have always said simple is not easy I love to I love to see this all right it goes without saying that complex things tend to be hard while simple things tend to be easy but that's not always the case software engineering can shift this balance almost uh uh alchemical chemically acclamically although not always for the best I can't say that word okay my tongue doesn't pronounce those symbols well uh building abstractions every time you build an abstraction you encapsulate a given amount of complexity making it easier to use when you print to a terminal you're probably doing it in a single line of code that's an abstraction over a whole lot of subsystems you might not even know about it's easier to print that way but the complexity is still there hidden behind a single function call love this definition this is great so what's the point of abstracting well in the previous example abstracting did not decrease the complexity it draw it did draw a box around a subsystem if you remember simple systems are made up of smaller boxes so abstraction is a step towards composing bigger systems without increasing complexity too much it's also good that it made things easier if it took 100 lines of code to print something to a terminal we would be years behind compared to where we are today just because of all the economic implications yeah that's fair especially as printf debuggers printf debuggers wouldn't even exist in this case that's me I'm that guy uh this is why we don't write everything in assembly it's easier more economical to write in a higher level languages and function calls and for loops and other control flow structures prove to be good abstractions over Machine level operations that's right go-to statements with fancy names are fantastic change my mind your printed you're that guy too you're not that guy pal you're not I can tell right away with your vs code open I can see it with your gigabytes of RAM going on you're not that guy you're not a printfer okay I can tell right away you walk into Starbucks holding the Phil's Coffee you're not that guy you're just not that guy keep in mind none of these things further uh further simplifies assembly code but they do actively prevent it from exploding in terms of complexity as it would easily do without small boxes such as functions uh you might as well kill yourself right now web web development with assembly Bob Johnson with his therapist you know one thing that's missing is whenever you make one of these box Arts make sure that you don't say O'Reilly you got to go oh really like oh really is like that it's the key this joke uh lost some of its punch in the wake of webassembly [Laughter] there you go oh really you gotta go with oh really not all abstraction manages complexity this is a fact of life this is why I say never abstract first you got to know what the abstraction is before you do it abstraction is sometimes introduced just to make things easier an example would be when you're uh when you are introducing a new interface with the sole goal of making it easier to swap in and out a replacement for a component it will take you less effort to make that specific change fewer references to update but the Box you just drew is a second layer around a pre-existing block the concrete class yes this is a great way to put it for example about a database class and an i database interface that interface is only useful for swapping in a new database if it were any way of abstracting what the class does it would have had a different name to begin with this is actually a really good point which is something that I think about a lot which is this right here when do you interface something out typically you interface something out because you want to change it but how often do people interface something out without ever changing it right like you it's a forever I have this here because I want it here and therefore it's there even for unit testing a lot of times you do that and you don't even unit test it right you don't even unit test the damn thing you just simply abstract it out of pure habit I've been I've been doing this Renaissance in my life where I actually am doing like no abstraction ever until I'm like upset at myself right and once I'm upset at what I've written then I abstract on this one piece and lately I've been finding that I've been writing better code though the initial pass is more shitty and it stays shittier longer like I'm kind of embarrassed to show show it to people I'm like but I I find that I've been liking it a lot more right I've been writing bigger functions and just kind of like trying to find where things are at in a more exploratory way uh that interface is only useful for swapping in a new database if it were a way of abstracting what the class does it would have had a different name to begin with easier is better than hard all else being equal there is no reason to prefer hard over easy stealing a quote from an from economics the the field of study we have an infinite amount of things we could learn or build an Ever limited amount of time and energy to do it the cheaper we can do it for the more we can have and the benefits compound over time it's a bit of a trivial statement but I want to make clear before diving into the real issues so I'm not gonna lie to you I've been trying to learn ocamel and I've also been using chat Jeopardy to really help me through it Chad Jeopardy led me very far astray this morning just completely made up and it took me a very long time to figure out that it was making stuff up those sounding really correct but I've really I've really enjoyed the process overall of using the AIS to help me uh I don't know I have a new appreciation for it at the same time I'm very upset gpt4 Jeopardy 4. I don't use that 3.5  I go I go full Jeopardy four okay Jeopardy foreplay uh the rules of abstraction as I mentioned before introducing abstraction has two main effects lowers the difficulty by hiding some of the details fewer lines to write fewer things to keep in mind and think about or even right to know uh or even to write out no identifies a cohesive subsystem and draws a box around it the Box becomes then a tool that can be reused to build the bigger systems while keeping complexity down okay the second Point complexity management is not trivial it's easier to lower difficulty rather than the constrain complexity and that's often what happens when web development is blind to this concept easy software that encapsulates more complexity than it should dude this is such a unique statement I can't tell you how often I will try to encapsulate something or just say you're rendering some stuff and then you encapsulate it and it's really simple on the simple path and it's really hard on the non-trivial path gpd4 20 dollar yeah Jeopardy four but really I like I I realize this this happens constantly where I think that's a good rule of thumb that if you encapsulate something to make the easy path easy you're doing it wrong easy complexity easy complexity shows up in many places causing all kinds of problems we even have a friendly name for this uh for some incarnations of easy complexity bloat saying something that is bloated is sometimes taken as a generic complaint against a misunderstood technology and certainly the term gets abused but it's nevertheless a legitimate way of describing something that falls into management complexity in a misguided effort to make things easy using bloated tools the Universal Property of bloated tools is being resource hungry and needlessly slow [Laughter] in the beginning it seems almost innocuous But as time goes on you will find that some significant percentage of humans and system times get wasted on waiting for them to perform even trivial operations when something breaks or behaves strangely there is no way of knowing what exactly went wrong and why developers that over rely on this type of tool get progressively caught in a form of lock-in where the tool removes them from the details of what they are doing the tool does it for me making them more productive but in but at an unfair price the locket is not just in terms of Technology when you when you only approximately know one way of doing things you will also be limited in the range of things you can do because every small deviation from the tools sanctioned way will become a serious obstacle this is such an amazing this is an incredible statement Christoph I have I have a huge respect for you for even just like such properly wording this in such a way that I think makes a lot of sense I really like this it's it's I say this pretty frequently but this is one of my reasons why I have a huge hesitation around this whole serverless movement is that uh is that these new people are jumping in they have no idea how anything works at any level they're using react server components doing all this Tailwind like they they have no clue of the actual Foundation at all and I'm not saying that I'm not saying that's even a bad way to start how much knowledge do you need of the foundation before you start that's that's a it's like a turtle's argument right at what point do you stop turtleing um but I also see the downsides which is if you do that and you don't jump back out of it at some point you have to keep on trying to bring your turtle level down every now and then you know what I mean yeah no Foundation like we all you every time you learn something at some point you have to lie to yourself a little bit right to understand something fair you need to lie to yourself some amount like last night when I was learning oh camel with modules that have functions that produce modules that take in modules write these functors as you guys keep calling them uh you know like for me it's like a log having a baby like Leota says and so it's like right now I just lying to myself it's just a thing that exists I don't even know like I know all those words individually but when you put them together I don't know what it means and I'm okay not knowing what it means the self-preserving structure of these problems is nothing short of amazing maybe in the beginning the developer tried to investigate root causes and in different ways of doing things but failure after failure it's reasonable of them although ultimately wrong to conclude that this approach is just a waste of time at that point some uh some decide that the right solution is to double down on learning how to cope with the tools quirks and intricacies which will result in even more wasted time once a new shining tool comes along hmm it's an interesting statement I mean these are all very interesting like again I'm going to go back to this oh camera this morning I was writing a tool a CLI tool and uh I was using using a Unix sub process to launch and it was like somehow my standard out was being redirected to just that sub process and I couldn't print anything and I asked Chad Jeopardy why it wasn't working and Chad Jeopardy gave me all these answers and I kept trying them and they were all uniformly wrong and finally I just said the thing swallowing my output how do I prevent Unix sub processes from swallowing my output and it was like oh like this and I was like like the problem is is I knew what was wrong to begin with but I wanted to understand how AI do things and it led me on like a half an hour path of trying thing after thing that was just wrong which is very surprising because you know like if you don't have that foundational knowledge you wouldn't be able to look at it and just say yeah duh it's right there like I know what the problem is yeah I I the link will be in the video for sure I see everybody wants that so bad file descriptor hell file descriptor hell here's this one it's kristoff.it blog simple not just uh simple not easy not just easy uh all of the forces in play uh at software engineering this is one of the strongest forms of natural selection choosing slow and unreliable tools will make you slow and unreliable developer with a limited and quickly deprecating skill set it's harsh I know but true choosing better tools won't make you necessarily a good developer but when you can understand what you're doing troubleshoot problems and in general be able to iterate quickly then you'll have real opportunity for improvement I love this this is why I often say I don't care that you use vs code but just take time trying something else just go bare metal for a little bit or not even bare metal go kneel them enjoy Neil Vim for like a month why do people customize what is the purpose of it why do they always say they feel faster afterwards well because they change how they look at things they rely on different tools they rely on doing things differently and then you can still take all of that back you can take it all back to vs code but just like just the the sheer Act of doing something vastly different is incredible I actually do want to use Ed for a day just to try it just to like really jump in and try Ed for a day uh I'm purposely avoiding naming names but I'd like to give positive shout out to JavaScript okay we all equate JS with bloat but in my opinion what happens there is mostly the natural result of a healthy ecosystem where many different although sometimes half-baked abstractions compete against each other this still has a negative effect of making it harder to make sense of things and causes some developers to experience burnout but the number of broken developers as per description above that the JS ecosystem creates is not proportional to the perception of its bloatiness okay I think the biggest number let's see I think the biggest number of that type of developers comes from different ecosystems where bloat is the result of hostile design dude is this like a shot at rust this is a shot at rust ain't that you tell you telling me that's not a direct shot at rust that is a shot at rust for sure in conclusion using bloated tool chains will have negative effects or C plus plus what does it do uh uh using uh bloated tool chains will have negative effects on your both your productivity and personal growth slowness alone is a problem but when combined with unreliability it becomes devastating think about the next time you see somebody open their IDE and wait for it to load make a change and then have to wait before the red line underline causes their change to disappear plus the occasional crash the reliable environment is a fundamental prerequisite for building competence the second most important prerequisite is feedback loop that allows you to quickly gauge the result of your actions the tighter dude I swear this was a direct attack against Russ because I literally do this all the time I open up neovim I wait for the rust thing to like load which takes like an hour and then finally when it does load I have to do colon e to like go go LSP the second most important request is feedback loop that allows you to quickly gauge the result of your actions the tighter that feedback loop the better and when it takes a minute to build a project and run A Fistful of tests the loop is definitely not as tight as it should be using bloated Frameworks will prevent you from understanding the details of what you're doing and cause your software to inherit bad traits such as slowness and unreliability uh further spreading the effects of easy complexity new approaches will inevitably come and if you never built an appreciation for different trade-offs all change will seem useless and arbitrary the economic of complexity if you search the word if you search word versus law text in Google Images you'll find a few pictures similar yeah I like this effort and time consumption this this should probably be a lot higher and then it should be like a straight line agree I agree with this I I like I fully do agree with this this take uh this picture is trying to convey that Microsoft Word is easier to use than law text and the document size increases you'll quickly get to a point where it actually becomes easier to use latex despite the inverse being true initially complexity makes things hard and Microsoft Word fails at containing it causing difficulty to Skyrocket this is why you can't ignore complexity it does not matter how easy you try to make things complexity is almost radioactive source of difficulty in terms of value over time if your daily job involves working on big and complex documents learning latex is going to pay off immensely compared to sticking with word more importantly learning the idea of giving semantic structure to documents is going to pay off more than learning uh than learning that one Arcane procedure required to drag and drop pictures without messing up the layout inward once you begin appreciating the relationship between structure and semantic meaning you won't feel bad when something new comes along and starts replacing law text because the fundamental principles will transfer to the new tool while the image replacement incantation for word is probably going to stop working in the subsequent release leaving you with nothing I leave it tell where did Microsoft Word hurt you in the images image layout hurt me very bad dude I actually fully agree with that every single time I have to I have to put a stupid image in that program I swear it is the worst experience in the universe I leave it for you to decide how let's see if and how that picture translates into tool chains Frameworks and even software you write yourself but there is an old saying that I think is still as valid as ever I don't remember the precise quote but it is something along the lines of the value of a maker is reflected in the quality of their tools thanks for reading my first blog post that is a great first blog post I love everything you have to say here I think this isn't just I think this is great go check out the links I will link this blog post go check out the links go give them the follows and all those kind of things and for those that are live today here you go right now uh doesn't make zig any better oh wow that was quality I want to read it again it was actually really good I thought it was really genuinely good uh I'm not sure I agree with the last quote uh I'm not sure if I do or don't agree with it but I like the notion right the notion okay how I read this thing is that there's there's two axes here there's the strive for quality and the strive for time and they they do kind of cross each other right in the sense that you kind of have to pick which sides you want to be on because you can make things more and more quality or you can make things you know faster and faster and you kind of have to decide which one you wish to go with another thing is that there's this idea that if you if you make a tool small enough you don't have to make a lot of those trade-offs you know what I mean the quote is from The Witcher interesting the prime line I agree with the statement uh it was indeed his first blog post give me back my son you know what I mean the name is we're about to do Rust drama and you are missing you're missing the moment rust rust has done up again the greatest Engineers of all time again