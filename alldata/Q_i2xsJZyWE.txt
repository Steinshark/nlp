today we're going to be covering something incredibly insane and this is even more crazy than wearing a pair of sunglasses over another pair of sunglasses okay I think that left a mark on my nose anyway we're going to be talking about infix operators in Python and in general you can't really create your own infix operators and that's what I thought until now I just discovered that infix operators are actually a thing in Python you can actually create them with some of the ugliest syntax imagin and I'm actually making this video thanks to the recommendation or the suggestion from Celestial owl 8865 they brought this to my attention so now I'm happy to share this with you guys cuz I actually experimented a bit and I think this syntax looks amazing first I want to demonstrate what it's going to look like because maybe you don't even care about this but the way it's going to work is that you're going to be able to Define your own operator so you can use some sort of variable name and this operator is going to be of type infix which is userdefined I created it myself and I put it in a module called special anyway here we're going to create an infix instance and that's going to take a Lambda which takes two arguments A and B because of course something needs to come before the infix operator and something needs to come after it so we can perform that operation for this one we're just going to multiply a by B so we created our own multiplication operator so to speak now to actually use this we're going to print the result of let's say 10 and we're going to use the pipeline and inside here we're going to pass in M which is our infix operator then we're going to pass in two so we're multiplying 10 by two and as soon as we run this we're going to get 20 as an output because that's the behavior that we defined for our infix operator and you can even get more creative than that you can say for example instead of M we're going to call this contains and we're going to change this code up a bit so instead of saying a * B we're going going to check that b is in a super simple we created a membership test here so now what we can do is get some sort of list or some sort of iterable that supports membership checks such as a string and we can check that this string contains the letter I and if we run that we will get back true because I is inside the string as you can see it's located at the index of three if we put something that doesn't exist such as an uppercase X it's going to return false so once again we defined our own infix operator with our own custom functionality now very briefly you probably already know this but for those of you that don't I'm just going to go over a bit of the theory of what an infix operator is so an infix operator is practically the operator that comes between two variables if you have a prefix operator it's going to come before it and if you have a postfix operator it's going to come after after it now that was probably the most rushed explanation I've ever given if you're more curious about infix prefix and postfix search it on Google because now it's time we actually learn how to create these infix operators in Python so I'm going to remove all of this and we're going to create everything inside this file so right now we're just going to pass in pass for the main function and I'm going to remove the import because we don't need to really import anything to create an infix class but what I will import is from typing because you know how much I love typing the self type the cable type and the any type then we can create a class called infix and the very first thing we should do is create an initializer and inside this initializer we want to take a function which will be of type cable and this will return none because it's just an initializer then we will assign the self do function to the function that we pass in or the other way around so that takes care of the set up for our infix function because initially we pass in a Lambda and then we need to use that Lambda somehow with the pipelines and to actually achieve this Behavior we're going to have to use a couple of Thunder methods the first one being the roar Dunder method and I wrote that backwards but of course that takes self and we also wanted to take other of type any and that will return to us an infix instance so here we'll type in self which you can use as of python 3.11 then we're going to return infix and inside here we need to add a Lambda and here we need to pass in some sort of variable because the variable is going to be called with the function and calling this function will call both other and the variable and I know it's already incredibly confusing and that's why I'm going to add this print statement which will help me explain it better as soon as we run the program so here we're going to type in Roar and I'm just going to pass in other this will make sense as soon as we run the program I used it myself to try to understand what this mess was because initially I was reading this from this website on code. activate.com and they had this python recipe for creating infix operators but the catch is that this was written in Python 2 I mean it's over 18 years old so I did my best to translate it in modern python or at least I thought this was python 2 because if you look at the print statements down here they're missing parenthesis and that doesn't work in Python 3 but anyway anyway I took the example from this website and I used it and I revised it so it could be a bit easier to understand but we also need to implement the or Dunder method and that's also going to return any because it can be any type if we pass in an integer it's going to return whatever we do with that integer for the second one we're still going to copy this print statement and do the exact same thing except we're going to call this one or then we're going to return self with the function and the other and that's the entire implementation for creating these infix operators and you might notice that for the original recipe they will have some extra methods such as RL shift and rshift and Co that just gives you some extra flexibility with some other symbols that you can use such as these bitwise operators if you want those you're going to have to follow the recipe but I'm showing you the most simple implementation which uses the pipelines anyway with this being put into place let's create our first infix operator and this one's going to be called P cuz I want to create a print infix operator and the way it will work is that we will create an instance of infix which will take a Lambda with the first variable and the second variable and what we're going to do here is print A and B then what we can do immediately under is type in something such as hello pipeline P pipeline world and to explain how this works I'm just going to Simply run main because it's going to give us some information but now you can also see the dunder methods being called in a specific order and the way it works is that first the raw Dunder method gets called when we are comparing hello and P this performs that operation and that returns to a self which is the infix instance so then we can compare P2 World which then calls the orand method and whatever we decide to do that it's going to perform that operation so we actually split this into two different oper ations in theory and these print statements were really the easiest way I could describe this because one happens before the other when we are performing this operation now you can insert whatever kind of code you want inside here as long as you have a function that takes two arguments so if you want to multiply these two you can easily type in something such as a * B that will work just fine and we can just type in MO then all we have to do is change this to multiply although this example is pretty bad so I'm going to print 10 pipeline multiply pipeline let's say five this time and as soon as we run this as you can see it's going to first work with the first Dunder method then the second Dunder method and then it's going to perform that operation but obviously you do not need these two print statements for this to work you can just remove them like that and the next time you run this script you'll get 50 back now you might be asking is this useful at all in Python and I wouldn't be able to tell you that just having to create this class for me was already kind of going out of the way to achieve nothing I just thought it was super cool because I've never seen this kind of syntax in Python before so I would absolutely love to hear what you guys think about this in the comment section down below and if you know about any other crazy tricks and tips that you can use in Python if you leave it in the comment section down below I would love to explore it I absolutely geek over these kind of things when it comes to python this one definitely was more like an Easter egg but again I would really like to hear what you think about it in the comment section down below and yeah that about wraps up everything I wanted to cover so as always thanks for watching and I'll see you in the next video