[Music] hello everyone welcome back to this little Series where we're gradually exploring some basics of how computers work today we're going to be taking a little look at seven segment displays to help us visualize some stuff in our project so I have things wired up here so that we can flip these tiny switches to light up this decimal point and each of these seven individual segments as well then of course as we're all familiar with we can power up different combinations of these segments to display any of the 10 decimal digits this is going to be really helpful over in our simulation where last time we just finished creating a 4-bit register capable of storing every whole number from negative eight all the way to positive 7. now for a super quick refresher on negative numbers in binary let's say we have the value 1 1 0 1. we know that the weight of each bit goes up to n powers of two so this is the ones place this is the two's Place fourth place and eighth place so to convert from binary to our more familiar decimal number system we just do H times 1 plus 4 times 1 plus 2 times 0 plus 1 times 1 equals 13. to support negative numbers though we can use the two's complement representation which simply assigns this most significant bit a negative weight so this becomes negative eight over here meaning instead of 13 we end up with negative three all right so back to our little register here it would be very nice if we could see what value is currently being stored in there to help with this I have added a simple chip library to the simulator where we can now find a seven segment display instead of the usual decimal point though I thought it'd be more helpful to us if this one had a negative sign over here which I guess makes it more of an 8 segment display but anyway the problem we face now is that as we've seen the inputs to this control each segment individually but what we'd really like is to be able to just give it a 4-bit number and have it automatically light up the correct segments for us to build that behavior we are going to first need a truth table we can start by listing out all the possible 4-bit inputs and let's also note down the decimal values that we want to display for each of those then we just need to figure out which segments need to be lit up in each case so to show a zero for example we can see that all the segments apart from G and the negative sign should be on so we can write that out over here we can then do the same thing for one and for two and so on this looks a bit intimidating though so before we try to build it out of logic gates we should first simplify it as much as possible let's worry about one segment at a time so with the sign segment for example is extremely easy it just correlates exactly with the most significant pitch in our inverch let's move on then to segment a which looks a bit scarier but an important thing she realize is that we can choose to think about either just the ones or just the zeros and in this case there's far fewer zeros being output so let's focus on those all we need to do now is design some logic that results in zero only when given one of these four input cases so starting off with the first case we first need some logic operation that will give us a zero only if these three bits are all zero an or operation will do that so let's quickly write this out in Boolean algebra form where the plus sign represents all operations then to finish off this case we can see that the least significant vitier must be one so we can simply use a not operation to invert that bit shown with this little bar on the top and then or it with the rest of them repeating this process for the other three input cases we end up with these four expressions so now if we're given any input value let's say 1 1 0 0 for example then without consulting the truth table we can figure out what the output should be by evaluating all of these let's do this first one quickly so we substitute in the input values and then we can see this 0 is inverted so let's flip that to a one and of course one or one or zero or one gives us one if we do the same thing for the second expression we get one again and then for the third expression we have zero or zero or zero or zero is zero this time and finally the last expression comes out as one now what does this all mean well if we sneakily peek at our truth table we can see that the inputs we were given in this example match this input case here which means the output should be zero no surprise then that the expression designed specifically for that case resulted in zero whereas the others all came out as once from this we can realize that so long as one of the Expressions works out to zero then the overall output for this particular input should be zero so that means that we now need some logic operation that will give us zero if any of these Expressions evaluate to zero and for that the and operation will do the trick so let's combine our four Expressions by ending them together which is represented as multiplication since multiplying anything by zero also gives zero we now have this big equation for our output and we can try to simplify it using the rules of Boolean algebra for instance just like regular algebra we can take out common factors and we can spot a nice pair of those over here and here meaning we can re-ranked all of this like so from that we end up with this rather pointless statement a or not a which is just always going to be one no matter watch and so we can replace it with a one but of course ending anything with one just like multiplying anything with one has no effect on the original thing and so that can actually just be removed entirely there are a bunch of helpful rules like this for example if you're doing an or operation on a bunch of inverted variables that's the same thing as taking the non-inverted variables ending them together and then inverting the result in other words an end operation I don't think that's making much difference here though so I'll leave it how it was and let's now try building this logic in the simulation for convenience though I'm going to start out by making a three input or gauge simply by chaining two or Gates together and then we can use that along with our regular old two input or gate to make a four input or gauge with that out of the way I need to bring up our equation here and let's start by setting up inverted versions of all of the inputs then following the equation we'll need three or Gates set up like this and into the first one goes the inputs a b c and not d into the second one because not b c and d and finally into the last one we just have all the inverted inputs we now just need to end the results together and I forgot to make a three input and gate so we can just construct one here okay time to see if this actually does what it's supposed to do we'll need to use our imaginations here to fill in the blanks but for a zero segment a should be on so that's good then for a one it should be off which you can see that it is and for two and three it should be on again but it should turn back off for four so fast so good I'll continue testing this in the background but it looks like our algebra has worked out and so we could of course repeat this whole process for all the segments to get a fully working display there is also something called a Kano map which is essentially a visual way of doing the same Boolean algebra simplification and it can definitely make the process a lot less painful for today though I just wanted to get a sense of how we could figure something like this out by ourselves but what I'd actually like to experiment with now is some computer-assisted design so I've spent several hours writing this very crude little program where we can input a truth table tell it what Gates it's allowed to use and then ask it to find a solution for us I haven't fully tested it yet though so let's start with something simple like an exclusive or operation where the output is only on when just a single input is on then I'm going to provide most of these Gates here especially the exclusive voltage that'd be a bit too easy and let's see what it comes up with it has immediately printed out a solution over here and to make sure it's not bluffing let's build that quickly in the simulation foreign four nand gates with the inputs wired up to the first three like this and the output of the first nand gate going to the next two and their outputs going to the last one which gives us our final output alright so with both inputs off the output is off then with just one input on the output is on and finally with both inputs on the output tens off so that's perfect let's head back to the silver program then and try pasting in our giant truth table for the seven segment display I'll allow it to use all these different logic gates this time and let's see how it goes this might take a while [Music] [Music] all right the program has finally finished running so I'm going to just follow its instructions to build this thing it's illegal by the way apart from finding a valid solution of course was to try use as few logic gates as possible it ended up with 19 in total here which is definitely a lot fewer than anything I'd have been able to figure out because simplifying the logic for each output individually is fairly straightforward but trying to figure out all the places where you can reuse some of the logic from one output in the calculations for another output can get ridiculously difficult but while using fewer logic gates is nice of course there are many other factors to consider if you're making something in the real world for example we've talked before about how each gate introduces a tiny delay and so the more of them that are chained together in a sequence the longer that overall delay will be so a better design might actually use many extra Gates but prioritize having things run more in parallel anyway Let's test if this thing actually does what it's supposed to do it is showing a zero currently which is a promising static list so I'll then turn this info on over here and now it's showing a one all right next comes to then three and then four looking good let's then test five six and seven and it should then flip over into the negative numbers starting with negative eight then negative seven next six and negative one so it seems to work we should probably save it then and let's just call it something like digit display while I was wiring this all together I started wondering what kind of design a different solver might come up with and so just for fun I'd like to quickly try this free one I stumbled across called logic Friday we can import our truth table in here and then ask it to map that to logic gates I'll then choose some settings quickly and let's see if this also needs over an hour to solve the problem no not even a second it does seem to be using a few extra Gates though so I'm not sure if there's some other constraints it's following or why that is which I still found it interesting to see what it came up with anyway let's head over to reality for a moment because I always enjoy playing around a bit with real world components as well this little chip takes in a 4-bit input and like what we've been doing it decodes that for the purpose of driving a seven segment display if we take a look at this data sheet we can see that it supports the digits 0 through 9 and for the remaining spots it looks like it wasn't designed to do anything in particular then we've also been given this logic diagram in case we want to get a very rough idea of what's going on inside so up in the corner we can see the 4-bit input and then there are some extra inputs like this Ripple blanking which we'll see later is helpful when chaining multiple displays together which we can see over here that the outputs for the segments are just handled independently by a handful of gates each which looks a lot more like when we're trying to solve the problem ourselves then the convoluted mess my program came up with anyway I've been wiring things up so that we can try it out quickly we'll just need to slush our components in foreign [Music] we do now have a zero on display but it's not showing up very well on the camera so I'll plunge us into darkness and that's a lot easier to see all right let me fight with these fiddly little switches to try input a one and a three and a seven I won't test all the combinations but let's take a look at H and 9 as well okay so I thought it was nice to see this real life version in action but let's hop back inside the simulation now to start making some use of our virtual one I'm going to go over to the chip library and open up the 4-bit register we built last episode and we can then just add in our little display here to show what value the register is currently storing so I'll finish wiring this up quickly and then let's try it out by entering some data over here we'll then need to turn on the store signal and nothing happens yet because remember we built this to be synchronized with the clock signal so only when that switches from low to high will the value actually be stored and we can see it showing up on the display now all right so this is perfect for visualizing the data inside of our minuscule 4-bit registers and originally my plan was to stop here because we're going to be playing around at the 4-bit level for a little while still but in the future we're definitely going to want to upgrade to 8 Bits at the very least so I think we might as well actually get our display ready for that eventual upgrade now in that case not being able to display the digit 9 is a bit of a problem so back to the drawing board I guess I'm going to make a new seven segment truth table this time with the outputs just mapped to the digit 0 through 9 and then after that the rest of the spots are marked with x's meaning don't care so just like that real world chip we saw a moment ago in fact we could even just copy its design but I'm curious to see what my Loop program comes up with if we leave it to ponder this problem for a while in case anyone's interested in how the solver works by the way it's super simple it just makes loads of completely random designs and then selects the best ones from those and make small tweaks to them such as adding or removing a random logic Gator connection then that just repeats over and over in a kind of evolutionary approach I'm not sure if this is a good technique for this problem my implementation at least is certainly horrendously slow but it seemed like the easiest thing to get up and running all right I finally finished wiring this all up so let's go test it quickly here we have one two and three working well then here's four five six and seven and finally let's check H and nine very nice something I found kind of interesting is that almost all of the don't cast dates for this wound up actually being better digits I suppose it makes sense since the logic is so condensed but I was still surprised to see it anyway I'm going to actually delete the display from here and instead add 7 output pins which we can just connect up quickly then let's save this and call it our seven segment driver or something along those lines and then going into our old digit display chip I'm going to ruthlessly delete everything in here and replace it with this new version we made all right so now that we have all 10 digits at our fingertips let's take a look at this 8-bit input that I've set up over here which can represent the numbers from 0 to 255. or if we're using two's complement then from 127 down to negative 128. but let's forget about negative numbers for a moment and say we have the input one one zero zero zero zero one one for example which is 195 in decimal the challenge we face now is somehow displaying that number across three of our digit displays here essentially we need to take that input binary value and break it down into three 4-bit values representing the individual decimal digits 1 9 and 5. this representation is called binary coded decimal by the way and to figure out how we're going to do this conversion let's start by looking at a single BCD value this as you might expect represents the decimal digit 0 and let's just count upwards so this represents the digit 1 2 3 4 5 6 7 8 9 and after that we have a problem because there is no digit 10 of course but our 4-bit binary number can go all the way up to 15. foreign so what we want to do is somehow Force this binary number to run out of space or overflow at the same time that we run out of decimal digits to do that we could simply add six once we reached 10 because 10 plus 6 gives us 16 and with Just 4 bits that overflows to zero in that case of course we'll want a second vcd value over here to record the full number so combined these represent 16 but more importantly to us here taken individually they represent the digits 1 and 0 which we'd read as 10. let's look at another example quickly this time we have one one zero one which is 13 in decimal so again not a digit as we figured out a moment ago though we can fix this simply by adding six that overflows this PCD so we'll need another one to store the full number and we're not being told to display the digits one and three which of course we'd read as 13. this idea of adding six is the key to a clever little algorithm called double double which is going to allow us to actually do this computation for however many digits we need so let's say our inputs are one zero one one this time which is 11 in decimal with any 4-bit input we will need at most two vcd values to store the result so let's set those up over here already we then want to move the input bits into those bcds so let's begin by just taking all the bits we have and Shifting the Mover one place to the left so we now have a value of 1 in here let's then do another left shift which doubles this value to 2. we can then do yet another shift which doubles the value again except this time a 1 also got shifted in from the input so in total we now have five in here now once we reach a value of 5 or more we know that the next left shift is going to at least double that and give us an invalid vcd value meaning we'd have to then use our trick of adding 6 to fix it alternatively before we double everything with the left shift we could just add half of six which will of course amount to the same thing in the end but it's a bit easier to implement just because we won't have to worry about things overflowing right away and having to then carry one to the next PCD so adding three here gives us H or one zero zero zero in binary now only one of the original input bits is remaining here at this point so we're going to do a final left shift and the algorithm is now complete giving us the correct digits one and one to make up 11. so that's the double devil algorithm double referring to the left shift and double referring to how we sometimes have to interfere by adding three all right I think we're finally ready to try tackling this 8-bit example we started out with so we have one one zero zero zero zero one one as our input which we know is 195 in decimal any 8-bit number is going to have at least three decimal digits so let's set up three vcd values over here then we can do our first left shift and a second one and a third one we'll need to stop for a moment now though because we have a six over here and remember if it's 5 or greater then we need to add three so let's do that we can then shift everything over to the left again and there are no problems here so let's shift once more and once more still we now have H tin here so plus three again and then shift it all over here's something new though we now have values greater than four in two places at once but we can just handle them individually plus three over here and plus three over here there's only one of our original input bits remaining so this is going to be the final left shift and there we have our answer 195. pretty cool we now just need to implement this with logic gates I've started out by writing a double truth table over here so you can see the entries up to four are unchanged in the output but then from five to nine the outputs have all had three added to them and finally we don't care about the remaining States since we always avoid those with our preemptive doubling now we could build this Behavior using the 4-bit addo we created a while back along with some extra logic but I decided to Outsource the thinking again to my solver program which I'm not going to make a habit of in future videos which for today I've been enjoying seeing what it comes up with and we have enough other stuff to worry about let's quickly verify that this actually works though so the output should be the same as the input for 0 1 2 3 and 4 then 5 should give us H 6 should give us nine seven should be ten eight should be eleven and finally nine should be 12. it looks good to me so I'll go save this quickly and let's just name it double okay with that made we can start implementing the algorithm so we have an 8-bit input here and we need to Output the ones place digit the tens place digit and the hundreds place digit to figure this out I'm going to bring up our visualization but instead of actual ones and zeros for the inputs I have given them names because we want to try to figure out a general solution now we can safely do three left shifts at the starch but after that this value here might be greater than four so we'll need to bring in a double chip to deal with it and I'll wire up the inputs a b and c then to help us keep track of things I'm going to give this chip a label maybe just the letter T for example and so its outputs are then t0 T1 T2 and T3 and whatever values those are that's what we're now going to have in here we can then left shift again and now these are the inputs we'll need to feed into the next devil chip so hopefully it's making sense already how we can just keep track of what goes where and as long as we're careful about it it should be pretty smooth sailing all right I'll call this chip over here you and we can update the visualization with its output values everything then shifts to the left and we can grab another devil chip and connect up U2 U1 u0 and E let's then follow the alphabet and call this chip V and again update the visualization with its outputs now after this next left shift we could potentially have a value greater than 4 in the tens place as well so we're going to need to use two devil chips this time and I'll go ahead and wire those off quickly all right let's name these two w and X then update the visualization as always and we can see we'll need another two devil chips to handle things so I'll fast forward through some more wiring and then let's call these last two chips Y and Z and for the final time update the visualization we can now simply look at where everything has ended up and follow that to connect the final outputs [Music] okay let's see if this works I'll try putting in that one one zero zero zero zero one one from earlier which should be 195 and taking a look at the outputs we do have a one in the hundreds place and nine in the tenths place and a five in the ones place so it looks like we've managed to successfully hardwire the double-devil algorithm into our little chip here let's now use this new chip to control these three displays we have so I'll wire up these inputs quickly and then we can connect the outputs up to those digit displays [Music] all right let's test our favorite number one one zero zero zero zero one one and there we find we have 195 proudly on display I am finding all this bright red a bit overwhelming though so I'll maybe change the color of our wires to Green instead so we're very nearly done at this point but there are some small details that I'd still like to work out for example if we turn off this input up here we now have the number 67 but there's this leading zero which is a bit pointless and distracting and ideally that would just be blank or say we're showing the value 3 then both of these displays should be blank so let's open up our digit display and add a new input pin here called Ripple blanking when this is on the display should turn off rather than show a zero so we can test if the input is zero using our four input or gate to First tell us if any of these inputs are one and if that's not the case then we know they're all zero let's then end that with the blanking signal meaning that when this pin here is outputting one the display should be off I think it makes more sense if we invert that though so that one means on and zero means off we can then intercept these signals going to the seven segment display and just add in a bunch of and Gates so that we can turn them all off whenever we want I'll just quickly finish wiring these up again and if we now turn the blanking signal on then we can see that the display switches off that should only be the case when the input is zero though so let's test if we put a 4 here for example then the display does light up anyway okay but say we do have a zero and the display turns off we'll then want to inform the next display in the sequence that it should also turn off if it's showing a zero which is the Ripple patch of Ripple blinking so we'll just need to add an output pin here so that the signal can continue on its Journey returning now to our three displays here I'll add in an input to enable this flanking functionality which we can wire up to the first display and then that should Ripple over to the next display then if we had more than three displays this would continue riffling along but we always want the last display to be on so I'll just leave this disconnected it let's then enable the Ripple blinking and now we have just a single zero lighting up which looks a lot cleaner I think then if we display say 15 for example we can see the second display comes on and if we go up into the hundreds then all three displays will be on all that I want to add now is support for negative numbers which shouldn't be too much work we mainly just need to make a chip for negating an 8-bit number in other words making a positive number negative or a negative number positive we figured out back in the first episode that this requires two steps first flipping all of the bits and then adding one flipping the bits can obviously be done with not Gates but if we use exclusive or Gates instead then we can easily have an enable signal to control whether we actually want to perform the negation or not finally to add one to the result we can just Cobble something together quickly using two forward adders and we should use the enable signal as the carrion because we only want to add one if it is enabled this is pretty much the exact same thing we did to handle subtraction when we are creating our simple ALU anyway let's try this out quickly so for example this here is the value negative one in two's complement and with the enable turned off we just get the same thing at the output but if we now enable this then negating negative 1 gives us positive one at the output this is going to be helpful because we don't have any way of telling the double double chip we built to interpret a number using two's complement so for this input it would always just display 255. if we wanted to display this invert as negative one though then somewhere counterintuitively we'd need to negate it so that it gets interpreted as positive one and then we can just slap a negative sign on that so back here with our three displays I'll add an input to control whether we want to use two's complement or not so if that's on and this is a negative number then we'll want to grab our new negation chip and enable it then I'll quickly connect this all up again [Music] and now let's try one one one one one one one one one as our input which shows out the S 255 of course but then if we turn on to this complements here now it's showing as a one so that's perfect we're just missing the negative sign to address that let's make one last edit to our digit display and add in an input for lighting up that negative sign we definitely wanted to respect the Ripple blanking signal though so we can just use another and gate to deal with that then of course if the negative sign is supposed to be on but it gets disabled to choose that blanking signal which we can test for quickly over here like this then we wanted to show on the next display instead and we can just use the same Ripple concept again to make that work back over here then let's grab this signal which tells us if we're dealing with a negative number and feed that into the negative sign input of this digit display nothing's showing up because this display is blank of course but it can pass the message along to the next one and it can do the same and in the end we'll get our negative one so just to test and review what we have here we can switch between unsigned and tooth complement representations we can disable Ripple blanking which looks terrible let's not do that and of course we can display all of these 8-bit numbers thanks to the double devil algorithm and also thanks to that chip we made earlier of course that actually drives the seven segment display based on the given binary coded decimal I know this has been a very long journey to just display some numbers which obviously could have been done with a line or two of code but I really enjoyed learning about and experimenting with all this stuff so I hope you found it interesting as well in any case behind the scenes I've quickly gone and added a 4-bit version of all of this to our 4-bit register which again will upgrade to 8 Bits And probably more in the future but for now if we store for example 1111 in there we can see the number 15 being displayed and I hacked in a tiny toggle here so if we want to interpret this as a sine value using the choice complement representation we can do that very easily hopefully this ability to visualize the data we're working with is going to make our lives a lot easier as we continue tinkering and trying to eventually build a little computer inside the simulation that's all for now though so until next time cheers [Music] [Music] foreign [Music]