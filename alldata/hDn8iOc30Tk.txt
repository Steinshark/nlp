I thought just for a bit of a change of pace we could look at one of the classic algorithms right uh binary search um binary search is something you learn about perhaps slightly earlier in your career maybe as you know an undergraduate or maybe even you know in school um but it's super important and I think also really interesting because it illustrates some of the things you need to think about as a software developer about how to make things faster and how to use things appropriately so that's what we're going to look at today all right so let's imagine we have some boxes right so it's like Deal or No Deal uh sort of like that but that vag is going to break down pretty quickly so I'm going to draw some boxes I could have pre-drawn these but where would be the fun in that now you don't know what numbers are in these boxes it could be any number on Earth any number on Earth is that thing any number but we do know they're in order so the lowest number is here and the highest number is over here let's say they're introduced just for the sake of me not giving myself a headache right now I want you to find out if the number 17 is in one of these boxes that's the thing you need to do this is what binary search is for but just searching in general right so maybe you've got a database with a bunch of IDs and you need to look up a specific person's ID or you need to find out anyone who's born on a certain date right looking through data to find something is very very common this is just one way of doing it so that's the rules right the boxes are ordered M how do we find this as quickly as possible the naive approach will be we start on the left right let's just just open this box let's not do anything clever open the first box the first box is two so it's not so we've failed badly but we are at least slightly closer to the goal because now we only have this many boxes to open so let's think about that how much easier have we made this problem uh well it was what was it eight boxes you've made yeah whatever seven boxes now right we made it one box easier one it's not trivial right so if we the best case from now is 17's here we open the box 17 job done right the worst case is we look through all of these boxes one at a time and said 17 isn't in there right or it's right at the end or something like this I'd think I'd divide and conquer I'd go yeah I think you should divide and conquer right so if we know them in order we can start looking a bit like you would look through a phone book right you'd open a phone book you don't open a phone book on the first page and start come on I mean I know that their surname begins with zed but I've started so I'm going to finish this right so let's open up a box around here right in the middle I've chosen an even number of boxes but so let's just sort of do this one and and now okay so we open this up and it's not 17 let's say it's 16 which is awkward but sure okay so now what have we learned how much easier have we made this problem well we know now that given this is in order that 17 cannot appear here and here right let's presume we haven't opened two it can't appear here either it has to be in one of these or not in the in the set of boxes at all so how much easier is our problem you've Haled it I've halved our problem yeah but problem is double as easy you know in some in some sense um so now let's fall back to our rubber we'll just open this one and then this one and this one and this one or we can repeat this process that would be much better 17 you would assume it is going to be the next one less is another 16 that's true actually 16 is a terrible terrible example for that reason let's make that 10 right fixed fixed um delete all that bit of video right this is 10 so we don't know now no the point the point is we're trying to make a general algorithm right we don't know what this number is all we know is 17 was bigger than it so now we're in this half yeah so we jump halfway so let's say this one right and we say okay is this bigger or smaller than 17 well it's 104 so we now need to go to this half right but it's and we're harving every time we're harving our problem every time and we look in here is it 17 and no let's say it's 16 oh 16's come back and so no 17 isn't in this set of boxes now you know you might be thinking I should have done this ahead of time and then you know come my example better um but the point is that we can make this much much easier by divide and conquering right if we know these are in order which to be fair is a big a big ask sometimes depending on the data we can zero in on our um on our Target number as quickly as possible so how much easier is this well what was the running time for the linear search which is just going like this right well it's going to take exactly how long the number of boxes is right or you know we might get lucky halfway we might not but you know in the worst case it's going to need all of the boxes to be searched and we're not going to find the number we're after so we call that o of n right so that's saying but roughly speaking the amount of time a linear search will take is directly related to how many items we have right now this is not very many items but if you've got gigabytes worth of data that's a lot of searching to do so how much easier is this when we're doing binary search so we're dividing by two and we're dividing by two again and then we're dividing by two again well actually it's O log to base 2 of N and what that's basically saying is that as n increases our problem doesn't increase at the same rate right if n doubles our problem only gets one harder so suppose we have a billion numbers right and it's this hard if we have two billion numbers we just have one extra step because we have to do that first divide to get down to a billion numbers right so it's so much more efficient and it scales so much better scaling really I think in these kind of algorithms is what's important it doesn't matter how long this takes for two numbers right because you just look at them it's it's it's not a huge deal but when you've got billions or or or you know even more of numbers that you've got to look through being able to do an algorithm like this is going to be much much better right um so how would we program something like this well what we need to know is we need to be able to basically be able to calculate the midpoint of where we are right and so the first time that's EAS easy cuz it's just the length of this array divided by two right but actually we want to be able to generalize this a little bit so it' be helpful if we have a couple of variables that um that determine where we are so let me draw out some more boxes and we'll we'll do it fresh speed this bit up okay they got less good as they went through any we need to think about how we're going to implement binary search right we're looking for some number let's say it's X in this list and we don't want to open the first one and then the second one that's linear search we want to divide and conquer we want to go halfway now the first iteration would be quite easy we just take the length of this list divided by two but actually we want a more General solution depending on which bit of this problem we're solving and how many iterations we've run already so let's define a couple of variables let's say the left is the leftmost Box we're considering and the right is the rightmost Box we're considering and we initialize them at being the first element and the last element of of our list or our array so then we can calculate the midpoint the first one we're going to look in as m is equal to l+ R / two and then that might be depending on 1 2 3 4 5 6 7 8 9 10 11 12 13 it's actually I think it's this one no it's not it's it's halfway between these two if L plus r does that mean l as in the number one one plus yeah or zero depending on whether your indexing is uh is it depends see what I mean yeah yeah so um so but we we you know in we don't want to arrive halfway between two elements so we'll just do the floor function here so we'll round down to the nearest integer or discard all the extra bits and so we're going to end up I think here right I'm not actually counting now I'm just going to guess so this is M now we open this box or we look in the array or we read the database entry or whatever it is we're doing and we find out that X is not equal to M so we haven't finished and we find out that X is bigger which means that X must be in this region here if it's in this list at all we also now know that this is not this it's not these it's not these and it's not this one and we also know it's not this one because we just looked and we haven't had to look at any of those so we' saved a huge amount of time so the next iteration what we need to do is we need to move our left hand side over to here so that we're now looking in this region so I'm going to change color controversial uh and I'm going to say okay L is now not there excuse me L is there n no we've already looked at that one we don't need to do that so then R is stays where it is right and then we create a new m so we do m is equal to l plus r / 2 and that ends up here so let's do our new M and we look in this one and we say Okay X is actually smaller than this so what we've done there is we've discarded this one this one this one and this one so we can now move new color fancy right uh L stays there R moves to here right and we do L plus r / two which is actually going to mean that m is the same one here right like this I should have done that above um and so we look in this one and if M matches then again we're finished if not we're going to have to go this way and so on and what will happen eventually is you'll you'll do this for however many items you have and eventually L andr will swap places because you'll move one of them this way or something like this if L is greater than r or something like that then you're finished right and you haven't found it now hopefully you do find it but it depends on it depends on the problem um so you know hopefully you can see this is much much faster than um than doing a linear search and actually it's not very difficult to implement because you've just got L you've got the array you've got R and M that's pretty much oh and X that's it right there's only a few variables there's actually only a few lines of code so let's write that up in Python and see how it goes all right so let's look at this I've just I've Just Whipped up this algorithm it's very very straightforward we have a function called binary search that's a success as far as I can tell it takes a list which I've called LST and an a which is our variable we're searching for right so I've changed the name of the variable just to confuse matters we set our left to be zero because in Python zero is the first element of an array and we set the right to be the length of the array minus one which is the last element of the array and then we have our Loop so we basically say okay while L is smaller than or equal to r or less than or equal to R we're going to repeat we're going to calculate our new M which is L + r / 2 and here I've used the double slash to do an integer division so basically will automatically discard any fractional component then we say okay is a greater than the element of M in which case we set the left hand side to be M plus one or we say okay is a less than the element of M in which case we set the right hand side to be n minus one or have we found the right number in which case just return true right I'm not actually returning the number from the list I'm just returning true or false right and that's the entire um the entire function if we get to the end and there are and and L andr swap places we just return false because the number wasn't in the array right so let's have a got let see how much faster this is so I'm going to run python here so I'm going to python minus I bin. Pi which is my function well how big is the array you're looking at then well I'm looking at an array that is not so big that my computer dies that was what I was really aiming for so I've chosen the array 2 billion no sorry no I think 100 million I think 100 million is Right 2 billion might be pushing my laptop a bit far because there's a lot of overhead um you know in the variables and things like it just seems to be taking up quite a lot of ram um I'm not overly overly confident uh I minus I uh Bin do PI right so we run this and now it's loaded up my function so I can say uh binary search and it will show me I've got a function there so I can look at it so now let's create a new list um and a big one so what I'm going to do I'm going to import numpy because that's a good way of generating large list of numbers so import numpy it's a new list LST is equal to numpy do random. Rand int So Random integer right let's not do decimals um and how big do we want how many random do we want and how what's the maximum value they can take well let's make them two they're somewhere between Z and 2 billion right in terms of the numbers and let's say size is equal to 10 million right so 10 million so that'll be an array of 10 million items that might be any number between yeah zero and two billion two billion yeah so there'll be a little bit of repetition but not a lot right and will that come out sorted um no no so um let's let's let's let's push it out a bit let's make it 100 million right one more okay then I'm going to copy this to a list right there may be a better way of doing this I I don't know what it is um this could take just just take a little minute it won't take as long to do this as it will to to sort it right where we might actually go and get a coffee first so now we're going to say LST is equal to sorted LST right and then we're going to just just relax for a little bit cuz we've got we've got some time to wait now actually this is quite an interesting point part of the interesting thing about binary search is that we we're assuming the data is already sorted now sometimes that will not be the case and sometimes sorting it is the real problem bit you see and so actually I think one of the really interesting things about things like binary search is you didn't shouldn't just use it all the time you use it when you're doing more lookups than you are sorting right so if you you know maybe you sort your data at the beginning of the day for some reason and then you just do lots and lots of lookups throughout the day makes a lot of sense to do something like this right whereas if you only ever want to look up one value you might as well just find it and and not why you see what I mean so I think actually it's rather than just learning all these algorithms I think it's just interesting as if you're going to be a software developer to think about when just to be aware of when you should be using certain algorithms whether it's appropriate yeah because you know there's a lot of people are you know can you program this kind of tree from scratch well probably not actually I've forgotten how to do it but what I can tell is that you know when I'm using a hash set or a a list I know roughly which algorithm would be the most appropriate in terms of efficiency for a specific task and I think that's a really helpful bit of knowledge to have because if you just use the default one you'll often find it's quite slow as we're about to find out we're still sorting the list by the way to be fair this is a lot of numbers how much RAM am I using oh it could be worse it's only 5 gig um but I couldn't mult that would be that would suggest I couldn't multiply my data sets size by another 10 although okay sorted that's good right so if we type Len of list right it's 100 million right there's a lot of zeros here I'm trying to it's 100 million we can for example select the millionth element to the millionth and 10th element right so we could say uh list index from a million to to there right so that's the all all the numbers in this array from a million to a million 10 position um and one of them is uh 17 there 17's not there would you believe um now um there will be a little bit of repetition in this array because some of the random numbers would have turned out the same but we're not going to worry about that today so if we want to find out whether a numbers in this array all we need to do in Python is use the in keyword right so I could say is 17 in LST and we sit here for a bit while it looks through every single number and it's not going to be in there false right now why did that take so long right because you know 17 is going to appear right near the beginning right well it's because python doesn't know that this is a sorted list right there's no reason for python to know so it has to use a generic algorithm like a linear search to solve this problem right so if 17 had been in it would have returned very very quickly because it would have hit it right at the beginning but it didn't right so if I look at if I search for this number that I can already see is in the Le so if I say 1 99 72 627 in List It returns almost immediately because it just goes a million in finds it stops right so sometimes you get lucky with this sometimes you don't but if you're just using the in keyword and your list is very very long you're actually just doing a really inefficient linear search right so this is one of those times where you might think okay maybe this is a time when I need to find a slightly better algorithm to do this so let's use our binary search and see if we can find some stuff in here so for example binary search so now you're going to use that script that you've written yeah so I'm I'm using the function I'm I'm writing I'm going to pass it the list I'm going to pass it 17 and it immediately returns false because it's just gone like this doing a b search it's taken um log to base two of 10 million right steps right which is 23 right so 23 steps and it got there yeah log to base two of of 10 million is roughly 20 22 23 steps so it would have got there I mean if you found the number on the first go it might take fewer than that but on you know in the worst case it's 23 steps whereas the worst case for finding 17 in this list of a linear search is 10 m uh million steps right sorry 100 million steps right 10 times worse so it's really bad so you know this is a really really powerful argument that gets used all the time and and you know extensions of this where you have binary trees and you're searching through binary trees is a similar principle and the idea is that you've structured your data in such a way like we've sorted it here that you can zero in on your target much much more quickly and so it's really really useful what what I can't understand about this is is why is there a green pen all over my hand like have you got like a video of me just Penning my own hand cuz that's every time I finish a computer file I've drawn all over myself and I don't understand when the video I've done this but anyway it's it's that's a a smaller side