yes we've done a lot of stuff about error correction in the past but it's been in a fairly crude way you might remember we did a cube with two good codes on and some correction points around it and all that it was fine we had like majority voting you know the the the correct things you could have received either three zeros or three ones so you get not one one what do you do well majority voting says it must be the three ones option but in doing that we didn't take account of where the ones were in the code there was no waiting as to whether the ones were on the left or the tail end on the right i mean 101 would have been just the same you see two ones and one zero and a lot of what we're going to talk about today is very simply this is if you look at your bit pattern as being having mathematical structure underneath it and being powers of two or that the positioning of the things in the pattern matters that's what we're going to find is the way to developing more powerful codes and one very good way actually to show that and you we've all seen these is to use an example that's not based on modulo of 2 it's based on dividing by 11 international standard book numbers 11 is a prime number and believe me by looking at those digits in the isbn number but weighting them according to their position it means that if one of them gets clobbered preferably not more than one then you can say i can work out what it must have been not by majority voting but by saying ah it's damaged and i know but it's at position six counting from the left that's the secret this is a system based on the prime number eleven now prime numbers as we know are completely magic because every time you divide something into them um it won't divide because profit numbers don't have factors so you divide three into 11 and you get three threes and nine remainder two you divide fives into eleven you get two fives at ten remainder 1 so by dividing every number less than 11 into 11 you generate all the possible remainders don't you you might have a remainder of naught if it really is 11 you might have a remainder of one two three four so everything from naught to ten is a possible remainder of trying to divide things into eleven mathematicians like to formalize everything and give wonderful names and once you've learned about them of course you can show off uh fearfully in the pub until put in your place by a proper mathematician and say that you know what a field is well i'm going to be talking about integers but including zero at the bottom end all the positive numbers zero one two three dot dot dot dot dot potentially going on forever right what can we do with those integers can we add them yes can we subtract them can we take one from the other yes can we multiply that's not too much of a problem and of course in the infinite set of integers you can do all of these things but the one thing you can't do it reliably is divide because if you do 5 divided by 3 it's not an integer so divide is a problem because very often you send yourself on a magical mystery tour outside the field of integers and you end up with a real number so what you can say then is that if you want to play around with these things you really do need to be able to do all four but you'd like to be able to do all four things but still stay within integer numbers how can you rule out getting things like three-fifths or one-sevenths and stuff like that how can you focus in on those integer divisions and make them always yield to something back in the original set and this comes out quite happily so long as you're using primes with modular arithmetic so okay then let's take not the infinite set of primes plus zero j let's just do it because rspn works like this eleven modulo eleven suppose we say we want to add seven plus six modulo eleven in other words it's 13 mod 11 and the rule is when you say modulo 11 it means you divide 11 into it take the remainder 13 modulo 11 is of course two so it turns out that for prime numbers like 11 where you can generate every remainder from naught up to 10 it's dead easy to do certainly did easy to do add subtract because you just got like clocks you like going around the circle except it's an 11 position plot not a 12 position clock and uh everything's absolutely hunky-dory it works just fine for add and subtract and even multiply but okay then how does how can you divide how can you divide and does it work and the answer is yes you can make it work but only if it's a prime number you're using as your base of everything and so what we know and this is relevant to understanding ibm isbns believe me what you need to be able to do is to say i want to be able for any two integers that i'm looking at in here to do a divided by b and i want a meaningful answer and i wanted an answer to come out in the range not to 10. how can i arrange to do that well the answer is to say that a divided by b is the same as a and i'm going to use dot for multiply okay now would you agree with that a divided by b is the same thing as a multiplied by one over b okay so when you multiply out it's a over b so what the problem comes down to then is can you find the inverse of any number well what does that mean well yes you can let's take some number x in the range 1 to 11 actually the range 1 to 10 because it's just the remainders that you can get if you see what i mean for every one of these things i want to find a meaningful inverse so that when x and one over x are multiplied together they will make one modulo with this eleventh thing well if you've got the number one it is its own inverse that's dead easy okay but you've got two how would you do one over two well the answer is looking back at this thing where it's a times one over b we're not trying to find that we're saying what for the given a what what can we multiply it by such that when we work it out modulo 11 it will yield a remainder of 2. think about it if i put in six here i'm gonna multiply and then divide by eleven six times two twelve divide by eleven it's gonna be one remainder that's what you want yeah you want a remainder of what we got a remainder of one out of two by multiplying it by six to make it twelve then dividing by eleven as a remainder of one but that's the definition of the inverse right we're trying to find one over b and by definition b times one over b is going to come to be one these are all the possible remainders that you have in modular 11 arithmetic if you say well i've got two but what's the something to multiply two by so it's that when i divide by eleven in the end it comes out to be to be one six times two twelve divided by eleven goes once remainder one it's the main one what about three how would we turn three into being twelve how would you turn three into being twelve what do you multiply yep so do you agree that if you multiply three by four you get 12 divided by eleven it's gonna remain a one we're inverting things you see the remaining one how do you turn four into twelve three three well of course you see this property straight away if three inverses four then four universes three ah now come on five what how can you turn five into twelve you can't so you've gotta go higher yes right so you'd go to what you've got to make it be one more than a multiple of eleven um 25 30 35 35 45. no and then but was that too far uh if i got to 45 that's a remainder of one wasn't it it would indeed so how many fives are there in forty five nine sean you're an undiscovered mass genius mate look at that that's it nine five forty five works because if you divide by eleven four elevenths and forty four remain a one so remainder one you want to know that you've inverted it correctly next one how do you make six work well we're inverting two yeah yes exactly you've done if two becomes six six becomes two seven fourteen twenty 21 28 35. this one's quite a tough one keep going 49 56 56 56 8 7 8 56 but if you divide that by the 11 it goes five eleven fifty five remainder one so the answer there is seven goes to eight which means eight goes to seven and then nine is what about nine five right yes nine has got to be five because five was nine and 10 that's its own inverse because 10's into 11 it goes once remainder 1. what you're saying is that there is a way to find the inverse of something so therefore you can do division within a finite field and it will work so long as it's a prime so at the moment because i'm just trying to tie this back into the computer science angle would this be connected to making sure your program can actually do what it's been asked to do it's connected to being able to using this kind of structures to muck about with the codes that you allocate to something and depending on the nature of the remainders and are the remainders correct then you can do error correction if if the remainder of something or whether you've done doesn't come to be zero something's gone wrong and this is all part and possible i think the easiest way now in is to say does this are you really need this for isbns yes you do first thing to remember about isbns is the publishers who use them put arbitrary hyphens in for their own purposes you don't need to bother about the hyphens as far as the maths is concerned now what i'm going to do here is instead of doing one that works straight away i'm going to put one here where i'm just using x to mean i can't read that digit it's been printed badly they've put a tick mark there that can't be right oh no they put a square black blob in there i don't know what the heck it's just got damaged can we put the damage right and like i say don't worry at all about the hyphens i think naught means it's english language and then every publisher has a two-digit code of the and all that kind of stuff so here it is but the way that this works and it is an example of using an underlying structure this does not mean i mean how many things do we have here 10 11 digits i mean it's not 20 billion or anything like that reading left to right it doesn't it's not powers of 10 it's based on you go from the left and you basically say this has a weight of one two three four five six five has a weight of seven eight nine ten okay so what we now do is we say there's a zero with a weight of one one times zero plus a two with a weight of two plus naught with a weight of three plus one with a weight of four plus one where the weight of five plus x with a weight of six x the digit we don't know plus seven times five plus eight times zero plus nine times two plus ten times seven due to earlier pre-calculation i can tell you that when you add all that up and you take the answer modulo 11 you will end up with six x plus four and we know that if an international standard book number is correct then you do this weighted addition you take it modular 11 and the answer will be zero if it hasn't been damaged well this has been damaged we don't know what x is so we can say straight away 6x plus 4 must equal 0 to make it right modulo 11. so what you have to say then is 6x equals minus 4. so x equals minus 4 over 6 or modulo 11. so what does minus 4 mean well you look about what you have to do with that to make it work modulo 11 it's 7. okay so this is the same as 7 times six to the minus one now don't you dare tell me you don't need to be able to invert integers even to do an isbn remember we did all that inversion table thing and if i can look back onto my previous sheet 1 over 6 is 2. modulo 11 7 times 2 14. divide by 11. well it gives you the three does three so x equals 3. going back to that original equation there 6x times 4 so that would be 18 plus 4 which is 22 which is basically 11 yes yes divided by it's 2 goes twice remainder 0. yeah thanks for that that's the way to check it out it does come to 22 which is exactly divisible by 11. the remainder is zero end of story is now correct so here was a wonderful example really although it came later than other developments of how just putting some structure on the digits and saying oh it's not just that it's x it's in position you know position number six counting from one from the left and by giving a different weighting to the integers according to where they are in the left or right sequence even at the very least it will tell you if an error has occurred if you've just interchanged two digits which is a classic thing to get wrong if you swap over two digits then the weights become wrong compared to what it should be and it won't have a remember zero anymore this situation we're doing here it will detect an error but it can't correct it unless you know where the problem place is that you're not sure about well we do know where the problem places that we're not sure about it's at the sixth position counted from the left and we knew we'd have been clobbered so you can correct so long as you know that which position it is has been clobbered technically this is known in the coding theory trade as in eurasia what it means is the proper value has been clobbered basically we can wrap up now and say well more or less we're well on the way to finding the answer you can put structures on modulo certain prime numbers and you can do the most amazing recovery tricks and it's all down to prime numbers but then you say well this were this stuff about being able to divide being able to invert things does that only work with finite fields that are prime numbers not quite there is a let out clause which is wonderful which makes life heaven for coding theories and in need for computer scientists it comes something like this it's saying prime numbers certainly work will always work can you do any better an undiscovered genius in 1820 long before babbage was even do the analytical engine was looking at all this stuff saying could i met could i find a meaningful inverse for something that's not a prime but is almost like a prime and after much work this guy very sad he got himself shot in the duel pistols at dawn ever east galwa and what he said was i can make this work and find you an inverse not just for primes but for anything that's a power of a prime i'm not going to call that an ordinary field i wouldn't call it a galway field so just think what's the smallest possible real prime and no not real genuine plant two in the old days really old days one would have thought well two's prime but that's all you can do you can't do anything else with it because it's always said no any power of two i can make it imagine two cubed two to four to the fifth any positive integer power of two and computer scientists not yet born if they've been there in 1820 would have said oh right so i can use a whole bite i can use two to the eighth yeah and and you'll find me an inverse and and all that yes yes yes yes yes and of course real mathematics say boring boring you know computer science is obsessing about powers of two but it is magic because it doesn't matter whether you're taking hex nibbles two to the power four whether you're taking bytes was commonly want to do you can have your byte as being your unit of currency and instead of it not working because it's an even number you can make it work using galois techniques because it's a power of two so that really is the baseline knowledge you need because read solomon codes and everything they're done in computers they involve powers of two two to the eighth is 256. it can be made to work but at the expense of an enormous amount of modular arithmetic to do inverses on everything from naught to 255 using galwa techniques you end up with great tables instead of just saying modulo q where q is a power galois said i am now letting you have p to the power h of course the prime on its own is a special case that's p to the power one yeah so no p to the power h which is any integer power wonderful but like i say the expense that comes in with this is huge huge huge amounts of modular arithmetic being done on very large numbers but we have computers do we care with this paradise opened up to us now galway is saying i can make any power of two work and i can give you a multiplicative inverse which is what you want to make all your calculations work correctly in this closed space and you say well even for two to the eighth equals 256 and we're using about yes yes that works fine there's a lot of it this way to read solomon codes for cdma correction it also leads to qr codes which just stuck on everything now they use methods involving this sort of manipulation like a scuff on a qr code can you recover it from it a bigger scuff on a cd yeah i think we need to look at a cd are you going to get one other car yeah i think that's a good idea what right hey ho this is gonna sort out oh dear i wonder what age group are gonna love this the very best of little feet