what's your favorite language I don't have a favorite language I'm too old for that I think at this point in my life if I were to start a startup I would say go is my favorite language now let me clarify why I think go ultimately is better than rust uh for being productive and making software where I I think that there's two different places where rust and go shine I think where rust really shines and it really does a better job than go is when you have a defined structure input either synchronous or asynchronous calls all flowing in and you can do a series of pretty much pure functions like really treat it like a functional transform really great iterator support like Best in Class string handling and parsing everything this is where rust shines and then out the other side right this is where I think it shines but all of these things are extremely when I say Pier I mean like you you really don't have state in your application it's all held in any state you have you can just make it straight up static in a one cell or something like that do you do you see what I'm saying and so it's like very very very very simple now where I think go shines it's gonna be it's gonna be a little bit hard to understand this one um I think it shines for everything else you need some Global State not a problem you you don't want Global State not a problem they both do the things right which is one no inheritance no inheritance not allowed right not allowed We're not gonna allow that okay this is great you know they both have a very sim a similar feel with traits versus interfaces right they're very very similar it's just that the thing I don't like the one thing I'd knock against go if I had one thing that I I could change about go it's that they need an option type honestly they need an option type and then of course the corresponding result type right that's pretty much all my big gripes against go is option type and I want uh syntax to handle errors right like I want the very simple case of try function and that's that pattern matching I don't even think that is that is that amazing honestly I think pattern matching is really really good if you have the right utilities for it I don't think it'd be amazing and go honestly I just don't think it'd be amazing and go I don't think you'd get something out of it it would make it go dramatically better because it's not really for go I think pattern matching works much much better in Rust than it wouldn't go uh for rust on the other hand I'm like 50 50 on the borrow Checker there's a lot of great things with the borrow Checker but there's also a huge amount of pain in the asses with the borrow Checker and so I'm like 50 50 on it uh there's like obviously there's like little tricks and rules you have to learn about go like interfaces are always pointers uh you know you get the idea it's not a big deal they're all pretty simple to kind of get over just like any language has its set of rules you just have to learn so anyone that complains about those kind of things they're just being weak right they're just being stupid and weak borrow Checker just copy it exactly I find that if you're doing this you'll you'll see just a lot of clones uh because of that now here I'm gonna give you a downside rust type system I think is inferior to O camel so with o camel and their new lifetimes that they're that they're uh that they're putting in oh camel doesn't tie lifetimes two types and I think that this is the way whereas rust a lifetime is a part of the type and that is completely broken and why I mean that's completely broken is that anytime you go and do something you you know you built this program it's getting big you're enjoying the program you've made some good stuff but now you have a part that's a bit performance sensitive and you're like wow you know we if we increase this we dramatically improve our overall program's performance this will be great so you just toss on a little tick a what happens oh boy everything Eerie thing's just about to get a ticket from function calls to other definitions to call like it just your whole program gets destroyed by a ticket and so how do I feel about rust I think it's okay I think there's really great things for rust and I still will write all my basic command line utilities I also think LSPs are fantastic to write and rust I really think it's the right abstraction for a lot of things but it's not a peer abstraction always so there you go that's why I would write Go versus rust like I think a server is just simpler and go it will always be simpler and go you create a database connection you don't need to like line up your entire server you don't need to use wet like app data you don't need to do anything you can just have a database connection you could interface that thing out so you never have to do it if you want to test you can test with some non some non-database thing and just have a simple interface simple mock you build whatever you want to do like everything about the language is really designed and developed very well for just handling some simple operations along with defer also the rust Foundation is just due to garbage am I the I think I could be the but generally this is what I want and so just a quick explanation about one thing why do I want options I hate nil I think that Nils should be handled at the compiler level I think Nils should be like hey halt there hot hot Satan did you know this could be possibly nil you should have to handle it uh which also means I think Maps should have always been a zero value of an empty map I do not see why you would ever want a map that's not zero valued I think it's completely I think it's a completeness in the language it's just a source of easy bugs get the hell out of there and syntax to handle errors I think that one's obvious right now you have not equals uh or not equals nil I think we could get rid of that right unless if you want specific handling just like rust Russ has the question mark but also you have the whole match Foo and then you have the Earth thing right like you do have you you do have to manage stuff it's fine uh have you seen the iterator proposal for go no I haven't but that sounds exciting uh rust lifetimes color your types like async functions color your functions this is a really good way to put it this is an incredibly good way to put it I love I love how you're saying this which is now rust has a problem because not only does it have colored functions it has colored types I think that that is really really clever way of saying it uh I love that yes and all safety is its biggest is is truly its biggest mistake because it's garbage collected I would have much rather seen something like uh like because you know pointer receivers they work right um the you already know the pointers there but receiving a pointer to something receiving an interface to something shouldn't contain the risk of it being null it should simply uh say I agree that nil values are probably my least favorite thing about go but there is a weird sort of argument for it in that uh it's very familiar to see programmers yeah uh and there is perhaps mistaken assumption that every fresh developer will know at least see I would say well I mean that's the thing is that I would argue the difference which is if something can be nil you should have specific compile color checking for it and you could just never make the mistake so it's not even about loving hating or knowing see it's just that you cannot oopsie Daisy that one operation just take it out because it's such a simple thing to goof up right that's my whole thing about it and I and and I'm hoping generics as they make generics better and better I'm hoping that it makes it into the language right and that you could actually have a option level interface something that just enforces some checks and I'd be very happy and here's the deal options with garbage collection can we all agree with that super simple handling super simple handling right uh nil turns every type into a hidden some type oh interesting yeah you can say that uh I think it's just uh with pointers it's just a pointer dog it's just a zero why is it simple because it's beautiful I thought you hated garbage collection I do and don't hate garbage collection I hate languages that make tons of garbage right so that's why I like that's why I get so frustrated with JavaScript JavaScript makes a ton of garbage all the time I know let's see but your utterly subjective data point uh with a sample size of one is not only invalid but it also is completely impossible to quantify yes but the ghost syntax is absolute garbage it's really not ghost syntax is not garbage ghost syntax is clearly not garbage there's nothing garbage about it it is one of the simplest easy to understand syntaxes of all time in fact it may actually be better than JavaScript syntax at this point because of how simple it is anybody can learn it right it is like that simple ghost syntax is great the thing is you should measure syntax on a semantic meaning per symbol right it's it's it's very small whereas rust is it's very high right there's a lot more things you have to process you know what I mean there's a lot more things going on just some thoughts on mine okay there you go that's why I think I would use go over rust if I was starting a project uh it's very very simple I think it just for the most part it does what I need now now recently I did just build the htmx LSP which is almost feature complete at this point and there's like a small bug and then it's literally featured complete and we got to get it into Mason and all these other places to do that but with that said the LSP written in Rust was the right choice it just simply was the right choice all the tools are there there's good string handling and tree sitter is natively bound and easy to use in Rust it was just the right choice for the time I think that that was truly the way to do it is that rust was the better choice so if I'm going to build an LSP I'll choose the right tool if I'm going to build a web server I'm going to choose probably the right tool which is likely go over rust now there's some arguments why you could use rust overgo for certain web services I'm on your team but I'm going to say this that most semi-experienced rust developers will write a server that performs worse than a go server written by a newbie because I think it's extremely hard to write very well performing rust right it takes a very few people can write really good rust so it's just something to think about and so that's kind of how I think about it is that is 99 good enough for net for most Services yes if you have a very intense data handling service an adapter to a database whatever yeah maybe you should rust it and you need to get really really good you need to hire that one guy that slightly levitates while he walks yeah you could even like pre-screen your candidates hey what color is your hair ah non-traditional well come on in there rust expert you've been sufficiently scarred by rust that you dye your hair colors come on in that's what I think happens I think that's why they dye their hair colors is that once you've done enough rust it's so emotionally damaging that you actually start dyeing your hair different colors that's how I think it happens I don't have a one I'm not one 100 yes but I think I think there's something there yeah your ass going to be canceled again good because this is now a YouTube video the name is the private gym