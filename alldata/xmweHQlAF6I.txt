uh okay so uh as as mentioned uh today i'm gonna talk about exceptions and i hope uh you find this stuff interesting uh but let me start with introducing myself so my name is inba levi i'm a c plus enthusiast i'm also an embedded software engineer at solaredge and i'm working on smart home devices i'm one of the organizers of core cpp conference and user group uh as anz mentioned a member of work group 21 and one of the founders of the israeli national body so we we just voted on simplest 20 that's uh i think it's a great start and i've studied physics i also love math so if anyone wants to talk with me about math later you're almost welcome so let's start with motivation um so exceptions are uh are a mechanism that is widely used uh on c plus plus in general but you might be surprised to find out that uh quite a lot of the of the developers uh don't use the exceptions mechanism nicodem fully uh you can see here a survey from ezo that suggests that around 54 more than half of the developers don't use exceptions freely in their code and this is a survey that i did might have seen it on twitter via the core cpp account that you can see here that also uh quite a lot of of developers are working on uh on embedded systems or performance sensitive systems and so i'm sure that if i would have asked you you you would say that uh similar percentages are are working on exceptions so so i think it's very interesting so as i mentioned many industries uh and they don't they don't really use exceptions mechanism as uh as fully as as we would hope and their handling mechanism uh you might be surprised but it's it's also been addressed quite recently uh by the direction group which is a group of of the people in the committee that are mostly uh they're trying to address the core topics of simplest plus and they they have addressed their uh handling mechanism uh via contracts which is also uh a way to i it's uh it's relate it relates to preconditions but it's also a way to to address uh problem errors in the code and and to and to deal with with the decision-making result from it uh another thing sorry another thing that was also published quite recently was a paper by herb sadder and i'm sure you all heard heard of it uh zero overhead deterministic exceptions throwing values and uh in the last uh uh meeting uh in the last word group 21 meeting that took place and took uh place in uh february uh we also saw a very interesting paper uh the exception uh sorry low cost deterministic exceptions for embedded systems so it was also discussed quite uh widely so to conclude i accept i expected the error handling mechanism is going to be addressed widely in the near future in simplest standard so the outline for my talk is we're going to start with history and domain we're gonna look at exceptions overhead uh we will overview the design then we're gonna go over some alternatives uh both both proposed and things that are uh you know potentially uh might be uh potential in the future and then we're gonna see uh some some some uh directions for the future for you if you wanna if you wanna be involved if you wanna if you take interest in this topic and i hope you're i really hope that you'll find this um inspiring so uh i just wanna i just wanna have a few disclaimers uh this is not a talk about best practices of exception usage uh there is a very good talk by uh klaus uh that i think yeah it wasn't cpp uh uh cp con 2020 so if you're interested in how to best use exceptions in your code you're most welcome to watch uh that talk and it's also another talk about uh a library uh the the code here is uh poc and concurrency i haven't addressed concurrency uh since at least in my industry it's less it's less relevant um but but i'm sure that's also a very interesting topic you could expand on and i'm also addressing some of historical references but i wasn't there so um take this uh as as it is so let's briefly go over the history and i'm not going to go uh into too many details but uh on the history of exceptions but i do want to have some uh point some points so in the beginning we had c then came c with classes and then came c plus plus but actually then came c plus plus with exceptions because exceptions were dealt with very early in the design of the language so um just to go back a few years we had two main ways to deal with with errors so the first one was error codes just like we do on c and currently also doing on simplesplash in some in some cases and the second way to deal with errors was uh by using global it could have been erno it could have been some user-defined global these are just you know general design guidelines but we had those two main ways to deal with errors and just notice that here for the return value we have to propagate the return value throughout the calls so if bar was calling foo here then we have to take this all the way up to to the main and by using global we could basically skip so so the functions that weren't interested in the result didn't have to to address this didn't have to uh use this mechanism so i i want to quote uh from design and evolution i think it's a great book so in the original design of c plus plus exceptions were considered but postponed because there were uh there weren't time to do a thorough job of exploring the design and implementation issues and because of the fear of the complexity that might add to the implementation to an implementation so it's true that uh exceptions are not a simple topic and i think it's it's very interesting that even in those years and remember this was really in the beginning of of the design of the language the problems already came up also uh in particular it was understood that poor design could cause runtime overhead and significant increase in importing times so as i mentioned they were considered very early and on the first standard of c plus plus uh you you can already see that there was a section addressing exception so the following inceptions were made regarding the exceptions usage so exceptions are used primarily for air handling and they're also rare and comparing to regular functions and and regular logics they as i said they occur infrequently and their language level concept so uh again uh this is a firm i haven't mentioned that but this is from the first paper that was trying to to to design the first exception handling mechanism which eventually led to the version that we had in the first standard so let's uh briefly look at the exceptions overhead and again this is not a talk uh suggesting or trying to address whether to add or not to add exceptions in your code this is of course your decision but we're basically i'm trying to focus on the overhead that is created by them and how can we minimize that so um first of all just to mention uh the main difference between c and c plus plus is the cleanup progress so basically c plus plus uh by having constructions in the structures uh adding the cleanup progress to the language and by using a long jump and said jump that is can be widely used in c um it is a topic to be to be discussed on but uh it's it's usable then we basically if if we would have used that and simple source would basically break the contract between the user and the language i also want to just clarify two terms that we're going to wisely use so there's a happy path which is the default scenario with no exceptions or error and the sad path and here in this talk i've mainly explored the said path uh just as a side note msbc actually supports a different behavior in uh said job in long jump etc but that would be uh something uh something that is unique to their implementation it's not something that is settled between different implementations so i've created a mini benchmark for exceptions versus error code and again i'm only focusing on the set path and you can see here that i'm returning uh three i'm foreign three types of exceptions versus returning three types three different error codes and you can see that uh the size of the sorry the size of the error code uh so this is the throwing three exceptions and this is a return value and you can see it's rather rather close on on on hosted devices but on embedded systems uh for i've used in this example on arm you can see that makes a great difference and another thing that you can see here is the difference on runtime which is uh by no doubt uh is trump like a significant uh significant difference between those uh two two ways and as i mentioned the clear observation is i mean you could do this benchmark on your systems and and you know if it's this this example is is with linux os but you could use it also uh try to do a sort of things in your systems but i'm pretty confident that you're gonna get a similar results or at least the uh the the major uh general notion of uh so i'm sure we're clear on having uh the fact that exceptions are slower uh than the return values and also uh as i mentioned it depends on your on your system you might find a bigger bigger difference so uh there's two main implementations uh for exception mechanism now we're gonna go deeper into how are they implemented so the first one is table based so gcc and clang uh they both use this method and i focused on this because it's uh creating better results on happy path now again i haven't addressed in this talk to happy path uh benchmarking but i think it's uh it makes more sense to to have this assumption because we want to have we want to have the regular code run as as you as you hope with better performance and the the code that that fails the the error handling uh to be slower but it's of course uh up to your system i i just felt a more um suitable and also aligned with the assumptions that we've seen in the in the history part the other option is the frame based and it's used by msvc and this this one gives a better setback results so table blast implementation have the additional overhead or headings to the program so first of all we have to have our tti uh to in order to identify the exception type that is thrown and another thing is the exception handlers have to be defined and again on gcc implementations they're something that's called landing pads so you have to uh basically you have to add a function a callback to handle the exceptions and it catching function uh contains additional information uh so so you have to be able to tell which of your functions is is uh catch can catch this type of exception so this is additional additional information that is kept regarding the functions so i've added here the general um uh just you'll be able to see the amount of code so basically the functionality is split into two like main libraries so you have lib gcc which contains the functionality of stock unwinding um and the libs c and again this is on gcc and it contains the functionality of exception handling so uh again you can see here the amount of code and uh the mechanism is quite complex so the stages of exception raising so first of all we allocate the exception by calling allocate exception function then we throw then we move to the lookup phase which is the phase in which we're uh looking for the for the function that can handle our our exception and at last if we in case we found this function we move to the cleanup phase which is the phase which calls all the uh all the cleanup [Music] functionality per frame so in case of a failure uh so so the exceptions uh can be allocated with um unlimited uh size but in case you can't allocate the exception because your system is low on on memory then you have some kind of an emergency buffer and it's also limited to up to four exceptions and there's additional conditions that regards to multi-threaded environment but again i said i won't be focusing on on it here but in general you could you could end up with problem activating this mechanism as we probably all know one of the problems of exceptions is the fact that they're undeterministic so we basically uh don't have a higher bar to limiting the overhead for the mechanism so the stages of exception raising so as i mentioned we would start with the luca phase and we trigger stark unwinding with the flag of unwind where's exception uh sorry with the flag of uh search phase for the function unwind raise exceptions and in case we fail we call to stood terminate and in case we succeed we get um the um we get the handler found and then we start the cleanup phase so the cleaver phase is basically going the same routine with cleanup face and the cleaning we start with uh calling the personality routine that i've i think i've mentioned before it's uh similar to it's the it's the part that actually handles the exception and we once we finished uh cleaning the the specific function we continue with unwind resume when you reach the stack frame which the with the proper catch we're uh calling uh begin catch and this is actually the thing that's supposed to treat the exception and then we can we call the end catch and uh in case we fail for some reason to to deal with the exception we might terminate and uh if we if we haven't also if we also haven't found the proper the purple implementation we need to move the past and exception on we can also call rethrow and eventually uh we'll continue unwinding so i've did a small uh uh draw because i think this makes things clearer so as i mentioned let's quickly go over the progress so we have uh allocating the exception by the subroutine that in case this subroutine was the one that failed and then we in case we can't allocate we terminate terminate the [Music] program in case we succeed we continue then we throw and we start the lookup phase and we go over uh up the stack and look for the uh for the catch that actually handles our exception if we haven't found again we terminate if we have we go back to the first subroutine we go back to the beginning of the stack and then we start the cleanup phase and as i mentioned we look for the catch and we catch and in case we found the catch we resume the execution but after after that we uh we look for the finally block if it exists and if it doesn't we just resume execution so i'll just uh this is a small shorter version of my talks i i want to briefly go over the designs decisions that were made of but uh i i also want to address the general principle that i'm sure again we you're familiar with different different types of of errors needs to be handled differently in the program so on general the the the general direction of the comedian and you can see it in her paper as well is to have the uh to minimize the use of exceptions to the ones that actually are actually relevant so basically we don't want to throw uh logic errors and we don't want to throw um recoverable errors as exceptions we might want to consider dealing them as part of the logic or as part of the other ways to deal with failures in our program and the things that are should be focused on are error that invalidate the program or are that that exhaust resources so again these are all the assumptions that were made uh regarding the first mechanism i just want to focus on on the ones on red here that they're marked so the again this is from the basic design so we want to be able to catch a group of exceptions we want to be able to catch arbitrary amount of information and we exceptions used permanently for error handling so i i think we might want to consider to catch a single type of exception uh the amount can be limited to suit to our embedded systems and instead of having uh using this primarily will only be used for handling error handling so we'll avoid things like logic manipulating throughout the exception mechanism i mean it's clear but some languages might do it differently so there are some projects that actually use the try catch blocks to uh to um to handle the logics so i would assume we don't want to use it we don't want to do that on c plus plus so general review on on what i think we should do regarding this uh this mechanism so do the sub routine and the one that uh wraps it up and the program wraps both of them sometimes we have the os and we have the platform and these are true for old all types of embedded systems but today we have some sometimes additional things for example we can have uh the connection to the cloud so we basically could decide that in case of an error we're gonna send the information outside and we also have more commonly uh since uh resources have been increased we also have uh additional programs and we could also have additional platforms so i'm just gonna uh read this uh quote again from the design and evolution and i really agree with it uh no single unit of a system can recover from every error that might happen to it and every bit of violence that might be done to it from the outside in extreme cases power will fail or memory location location will change and uh its value with no apparent reason so we need to be able to identify which are the errors that we want to have in deal with in our program and which ones are things that beyond the scope so uh to move to the alternatives some technique is some techniques sorry of acception mechanism can improve your performance the exception mechanism performance in your code so you could basically use the current mechanism and optimize for example by minimizing the number of exceptions to different types of exceptions you could override function calls from libstud plus uh you could re-implement parts of lipstick c plus plus and these are of course uh going more advanced uh topics and events work but it all depends on your on the things that you need in your system and you can use alternative mechanisms such as msbc's structure exception handling mechanism so i basically focused on one and two so this is an example of code that is trying to minimize the number of different error types thrown and you can see here that uh so first of all throwing one type of exception compared to return so you can see here that the ratio is actually increased so this shows us that just by adding the exception mechanism we only get the penalty and it doesn't really matter if you use a single for a single type of exceptions or multiple types of exceptions this is the the thing that uh creates the the overhead and uh the size is again quite quite similar though you can see a bigger difference and you can see on arm again that the size difference is bigger and if we'll compare to to throwing different type of different types of exceptions then you can see uh this is quite close ratios and again so my own platform you can also test it in your platform so i'll generally say that from here we can learn that uh the the overhead is added just by adding the exception mechanism and that uh just limiting to uh minimize the num the different types of exceptions thrown is not significant though i would expect it in a big project of course this is just a code that was created specifically for the example so i would expect that on on different code bases might be different results so i would recommend you to to test it so the second thing i've i've tried was creating uh the overloads for the libstud c plus plus and in this case we can see here that there's functions uh throwing and you can see uh that uh the thorin function is drawing some kind of exception and we over we hide basically hiding the uh functions we saw before for allocate exceptions and throw all right and here you can see the size of the exception um i'll show it on the next slide but basically i've also used a predefined buffer for the exception instead of dynamic location so this is the allocate exception function and in case it fails to allocate its terminates otherwise it returns so i mean otherwise it returns the buffer of course it can be a every type of a fail we can we can basically decide what we what we define as a failure and here we can have uh we can see the throw function and it basically doesn't do much so i could have we could add here um right to file or report to server or any any other thing that suitable for your specific environment that you wanna that we wanna use and then we exit of course we could exit not with success but with other things and here as i mentioned you can see the size of the buffer is defined globally so it's not dynamic allocated dynamically allocated and you can see they call for constructor and fail and exit so comparing this uh thin firm version uh to throwing an exception a single exception i get the ratio that is very similar to what we saw for return values versus exceptions and that means that the thin fro is actually sorry the thin furrow is is is very close to the to the return value in in performing performance wise uh runtime performance wise of course the size is still uh something that is added since we still get the rtti and the and the london and landon functions and the functions that can uh identify what whether the the exception is belongs to them or not but but it's still i think it's still very significant uh findings so i i think it's interesting uh to get the performance again so similar to the one for the return and again this is not a production level code but this is trying to show we can actually customize the mechanism so here i just want to show my sort of my ideal throw so i would hope that in the future standard we're going to get some type of throw that we can customize and and uh uh pass some kind of a callback or functionality to it in order to determine do we want this to do we want this failure to to perform the unwinding etc and here in in this code you can basically see that the subroutine is uh passing the information to the program but we could also define this globally and in that case the program will definitely will basically define the the handling mechanism to the subroutines underneath it so uh let's focus on uh shortly on the few alternatives currently exist in the committee so the first one as i mentioned is the zero over deterministic exception foreign values herb is proposing a few different things here so first of all he's proposing uh that uh first of all he he identifies that we use uh exceptions too much or in different places that were originally addressed so uh again using exception for logic errors would probably give us very bad performance and we we don't need we don't need to use them to manage the flow and another thing that he mentions is that allocation failures or what i've previously addressed as exhausting the resources is a different type of exception that different type of error that we actually we we might want to use this mechanism for because this type of an error says that we can continue uh executing and and uh we also have some concrete proposals regarding the performance so he basically uh suggests and this is again this is a common this is relatively common uh nowadays at least there's a library called outcome also doing this specific uh this specific thing but i basically suggest to have some kind of a union that returned from from the function and this contains either success or the the values for for the success or the the error in case of a failure and a boolean that's just which one is it and i just want to emphasize here this is of course returned on the stack and this is not something that the the developer should implement this is a code that would be implemented from the compiler in this example and unlike unlike outcome for example and uh it also uh suggests that uh we could predefined um the the allocator to report the error or to do other things um and i think the notion of having the um the the error mechanism to be suitable for your own program is something that is uh widely uh addressed in the committee nowadays i would hope that uh we'll get a more custom customizable mechanism in the future so as i mentioned again comparing to what we saw previously here the program is basically defining to the different subways how to handle the errors and the other paper that i've mentioned low cost deterministic exceptions is also very interesting and very promising this is actually showing implementation for trying to implement some of the things that herb have mentioned in his paper and we get here replacing allocated exceptions on things that are returned on the stack or kept on the stack and there's also some globally allocated memory here to to deal with the to to handle to help the mechanism but it's not uh it's not it's a basically a limited size buffer and we can also we throw by using this uh buffer uh globally allocated buffer and and and again some of the some of the principles that were addressed in herb's paper are implemented here with and showing promising results so i want to conclude with saying that you can create your own intelligence you could signal to a different progress or report to the cloud or write a file and you could use pre-allocated space as i've shown just by overriding or hiding the function that is in charge of allocating an exception you could have um save the the minimal data that that need that is needed for example and and this is again this is an extreme uh idea for for certain cases probably only suitable for certain machines but but you could decide uh pre you could solder defined a table with numbers and and each number can identify a different error or even different location in your program you could just return this this single identifier if you if you think that's useful for your code so there's really different ways to address and to optimize this mechanism this current current uh version of mechanism but again i would hope that in the future the standard will address it and we'll have some better alternatives uh okay so um there again as i've said uh other other mentioning of things in the standard relates to the error handling mechanism and i don't want to go too much into details here because this one's a shorter version of the talk but i just want to mention that there's some very promising directions and bloomberg is addressing the generally generally uh how do we address errors on um on on debug mode or on on development stage versus the release code and there's also um people in the committee that addresses uh the the question of who determines theirs so do we wanna handle their in the same place that in which we got it or do we want to handle their up the stack and just to conclude uh i think we should uh separate the semantics from the implementation i think we should allow behavior suitable for uh for the performance sensitive applications so we we should allow more customers while uh customizable uh systems and the overhead already exists and we already have the current mechanism already have its overhead so by having uh more customizable parts of the of the system we might get even a better better uh results for for broader spectrum of users and and just to again to to uh to i want to repeat this notion that the earth handling mechanism was really um was really designed quite long ago and simples pass is about to is is turning 30. so we have um we have to con to consider the differences that were made in embedded systems in the past 30 years and um and we have to address this 50 of embedded uh developers that don't use the current mechanism and i think we should really consider the bigger picture i also added here the developer uh crust because i think that's more commonly these days we don't have uh someone that actually looks and errors or even even the logs we we have automated uh mechanisms that collect the data and and and we can have searches on these databases or whatever so it's also quite uh more common to have those types of error handling environments to conclude i invite you all to share your ideas with me regarding the ideal exception uh usage and i invite you all to uh to get this notions and to to to take them forward and to you know i think that um it would be very helpful for the committee and for the uh progress of c plus plus if many people as possible would try and address those uh issues those questions uh those hard problems and uh give their inputs and i suggest that we'll rebase the exception handling mechanism on our on our code uh on a current uh simple um sorry computing uh mechanism there currently exists and thank you these are all the links that i've mentioned and there's really a lot of very very interesting links here there's i just want to mention the proposal by ben craig two proposals by ben craig that uh do a more uh broader benchmark on on embedded systems and they're very interesting uh to to observe so i really recommend you to go and look for at them and i invite you all to send me your responses and your ideas regarding this thank you