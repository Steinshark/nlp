last time we were binary searching we were binary searching last time what we searching for this week we're still binary searching but we're going to binary search ever so slightly better than we did before that's the idea so it was pointed out into comments to me that under some you know languages and computational architectures there'd be a bug in the binary search code that I wrote now I mean I would I would like the record to show that there isn't a bug in my code obviously uh mostly because I programmed it in Python um and python has a slightly different way of dealing with numbers but let's look at this bug because actually this was quite a serous problem this existed in Java for example for about 9 years nearly nearly a decade this bug was there which would have thrown errors in a certain set set of circumstances where this binary search that you program that makes absolute sense doesn't actually do what you think it does under some circumstances it's an edge case that you haven't spotted right there are always going to be things like this so there's a much safer way to code it where you can get around this problem but this happens a lot with code you write your code you do a lot of tests everything works fine you just didn't test those exact set of circumstances that caused the bug to appear right so actually one of the phrases you see a lot is recreate the bug right which is what where when someone reports there's a bug to you if you can recreate it that's the first step in finding it so let's REM remind ourselves what we were up to we we had some boxes which I'm going to draw again but we're not going to spend too much time talking about binary search this time we're just going to talk about the way we calculate which box to open next so if you remember we have some variables in our binary search that represent where we are currently looking right so at the beginning we have our left point over on the at start of your array and the right point at the right hand side of your array and then later maybe you've decided it's only in this section so you have your midpoint somewhere over here right so let's suppose we have our left Point here and our right point up here what we need to do is calculate our midpoint and we do that so that we can decide work okay we're probably going to open this box box we open this box and decide which side then we need to look on or maybe we found our number so the formula we used for this was m is equal to l + r / 2 right and then what we did was we did the floor function which says the nearest integer below this now in Python this will always work because in python as far as I know in Python we don't have the same restrictions as we do in some other languages where numbers are a fixed size but as mentioned in the comments quite reasonably uh in the last video there are certain circumstances where this will fail right and that's because what we're doing is we're doing this very large intermediate sum between the left and the right and then dividing by two which basically means that temporarily our number gets very large and then it gets reduced back down into correct range so what this should do is give us an N value of l+ R / 2 which will be the average which is M right here but imagine your data is let's say one or two billion elements in length which doesn't happen to me very often but it does happen sometimes um and it would be much more common if you were working for a large organization that had a huge amount of data now let's imagine that each of these numbers is over about 1.2 billion or something like that so the theoretical maximum size of an array in Java is about um 2.1 billion elements roughly speaking that's the maximum size of of a signed integer and if we have if we're looking up at the top end of this array then our L and R values are going to be close to that value when we add them together they're going to overflow over the maximum integer size so if if L plus r is over this value of 2.1 billion you'll get what we call an integer overflow where your integer becomes so big but it wraps back around and you get a very very large minus number because of two complement perhaps the most easy one to understand is that yes if you add together two positive numbers that are too big they're going to come out looking like a negative number right now if you try and index your array at M where m is a hugely minus number you're going to get an error right and out of bounds exception and your um your code is going to crash so if you don't ever have that situation then this will never come up right and that doesn't mean necessarily that you should always just use this code but it's worth noting that you might have a set of circumstances where 1 billion is way out of the range that your program would ever produce in which case this is not really a big deal and this is probably why it didn't get spotted for many years because it just didn't come up very often right and then when it when it was eventually when it was eventually found it found there was textbooks that were wrong j was wrong huge implementations were wrong because there's not really anything wrong with this it just doesn't work because of the the restrictions on introduced so what would be a better way of doing it what we were originally doing was L + r / 2 so if you had um an L that was here like this and a and a bigger R because your R is over on the right hand side over here what you will be doing is putting this here adding together and taking the midpoint which would be somewhere sort of here right that's that's kind of the idea that's your average but yeah if you put that there it' probably run off the end runs off the end of the screen and we've got our overflow and then we're all way over here on the yeah exactly right so you know the paper works we should stick with it what we're going to do instead is we're going to do R minus L right R minus l so what would that be that would be the difference between R minus L here I could probably drawn it over here so then what you do is what half of that and then add it to the L exactly right so we divide this by two to get this bit here right and then we add the original L back again so this is r - L / 2 and then we add back L right I'm not sure if drawing it out like this worked but hopefully that makes so it's a slightly more complicated sum but hopefully it keeps us in bounds right yeah so what we've done is we it keeps us in bounds because we've never R is always bigger than l in our in our binary search or they might be the same in which case that's the last step but essentially R minus L is never going to be a negative number and it's never going to overflow over the end of a 32-bit integer right and that avoids this problem okay so I actually uh implemented this in Java and we can actually see it crash and then we can fix it right okay so I just recreated my python code in Java because I wanted to recreate the bug and in Python it has arbitrary size integers which means that basically when your integer becomes 33 bits it doesn't wrap around it's just 33 bits from then on right now that has a performance hit but it's not much for for normal use and uh so that's a good way to program in some ways but actually I quite like the restrictions sometimes and for example in things like cryptography it's very important that your data is always the exact size that they're expecting because otherwise the mathematics won't do the same thing at all right and so actually for encryption algorithms it's always very very strict about exactly how big your data is at any given time now so I've created binary search again so we can see the same algs we had before and here is our offending line so I'm going to say bad that's not that's a python comment not a Java comment excuse me right so this is bad right and it's bad because theoretically if we have very large indices left and right our midpoint will our intermediates on will overflow so I'm going to create an array of a len of length 1.2 billion which is long enough that we're going to overflow if we're near the end of it right because the left and right values added together will be larger than the biggest size of ingry we can handle someone pointed out in the comments very wisely that why not just create an array of consecutive numbers from one up to the length of the array well one to be really clever and smart about it sure or we can wait here for 10 minutes while we drink coffee because it's sorting algorithm takes ages fine I take your point so what I'm doing here is I'm creating an array of length 1.2 billion I'm then just going to make every element in the array its own Index right so essentially the first number will be not the next number will be one all the way up to 199 million no anyway uh yeah 1 billion 100 anyway so on so if we run this and you'll want to skip through the build process you'll find that there is no error right uh because there's nothing wrong with creating an array of this size so if I output binary search of let's say using our array and we're going to search for the number 17 which we know is in the array because uh 17 again I don't think there's any real actual significance of the number 17 um so if we run this what should happen is it prints out true because we can find a number and it does right good now so suppose we remove 17 from the the array so all I'm going to do is in front of this line I'm going to say array at 17 is going to be 16 right so what I'm doing there is just saying there's going to be two 16s in a row which is not ideal but it will be fine if there's no longer a 17 in the array this should return false cut to the bit where it says false false right so it's working so our binary search is working now what would have happened is someone implemented this based on some textbook it works fine they cons considered their job done for the day and they went home right and then 9 years later someone goes a second right so let's now look at what happens when we're not looking for 17 we're looking at a number right at the far other side of the array where the numbers get much bigger okay so what I'm going to do is I'm going to say okay do a binary search for the number 1 billion 190 million and let's say uh 17 oh yeah all right is that the right length of number we will soon find out so I'm going to run that and we'll see what happens right we've got an exception which is kind of funny enough what I wanted to happen so our index of minus a billion and something is out of bounds for this array which is obviously out of bounds because it doesn't allow negative indices so why is that happened well what happened was at some point we were looking at this far end of the array and L and R added up to be a number more than 1.2 billion so now let's fix our code and see if we can do a bit better so what we're going to do is we're going to take this line away good and we're going to say okay we're going to do L plus half a difference between them right which is still the same exact result but we haven't had to add them together so we can do right minus left / two okay like that and that should perform exactly the same it should find 17 it should not find 17 it should find this number but hopefully won't crash this time true it found it and if we take that number away we should get a false so if we say array of I'm going to copy it because I don't think I can type that a second time there we go something like that right this allows us to keep the them in consecutive order this should return false there we go so the binary search now works but it also works for any numbers in your array even if your array is up to the maximum size that Java allows right which is which is nice right now if you actually look at the Java source code you'll find that this this bug has been fixed as of about 2006 something like that so it was seen quite a while ago but this bug did exist for quite a long time shouldn't just use it all the time you use it when you're doing more lookups than you are sorting right so if you you know maybe you sort your data at the beginning of a day you may want to come up with a new one and say should this belong to group one or group two so before actually going there and then doing this synthesizer of them could I