at the moment we have a problem and I'm not just saying I have a problem or you have a problem we both have a problem in Python and that is that when we have to compare two floats it's usually impossible because python just doesn't know or actually our computers just don't know how to re-render the numbers as soon as we store them in memory every time they give it back there's maybe a billion nines or billion sevens trailing the decimal and this is absolutely awful so let's go ahead and see how we can fix that error in Python so just to make it clear that we're on the same page about the error we're going to go ahead and create two different variables one's going to be a float called a and that's going to be 0.1 and when we go ahead and say B which is also a float that's equal to 0.2 everything's working fine the computer understands what we're doing now when we go ahead and print a plus b format that and run it we're going to get this ridiculous output in the console as you can see we get 0.3 a million zeros and a four trailing and the worst part about this is that if we have a float that has the value of 0.3 and we go ahead and do an equality check so we check that a plus b is equal to C and we will put those in parentheses just to be extra safe you'll notice that we're going to get false back and this is ridiculous I mean we can clearly see that 0.1 plus 0.2 is 0.3 and if we go ahead and print out a plus b and c separately you're going to see that c is 0.3 and that a plus B has this long messed up number now why is this why does this happen and it really has to do with computers computers are extremely efficient or at least they like to think they are and when you store a floating number into your computer in general it's only going to try to reserve 24 bits because the binary representation for a floating number is completely infinite and that is really hard to store if you have this infinite representation it will take so much memory to install something that's infinite and I guess theoretically doesn't even make sense to store something that's infinitely so programmers came up with this idea to cut off a certain amount of digits from the binary representation to save that memory and make sure it's only 24 bits the problem is that as soon as you try to load these floats once again you're going to get these estimates and this is the computer trying its hardest to reload that float back into memory and as you can see we got this really weird number at the end because after doing all the calculations to try to convert that binary number back into our float it just can't for whatever reason get the accurate number back so this is something that has to do with all of our computers and now I've been talking a lot of course I didn't really speak about Solutions yet so let's go ahead and create a solution for this and the first way we're going to create the solution is with a user-defined function so instead of doing all this printing we're going to go ahead and create a function called compare floats because we just want to get the comparison of course it's going to take a of type float and it's going to take B of type floats now I know these are shadowed variables so I'm going to change this to First and this to seconds and this is going to be third so we do not Shadow those and we should also go ahead and provide a tolerance which will be of type are not equal to but of type floats and that's going to return to us a Boolean on whether it is equal or not now the first thing we need to do is go ahead and get the absolute and the absolute value which is going to be of type floats is going to equal the absolute of a minus B so it doesn't matter whether the number is positive or negative we're going to want to get a positive number back so we can see the difference and we will put that down one line because pep absolutely hates me at the moment and we will go ahead and print the values so we're going to format this string add an A in there and we're going to go ahead and format it again or I mean we're going to interpolate and we're going to say that that's equal to a minus B so we can see the values and we can see the outputs then we're going to return the absolute if it is less than the tolerance and I'll explain exactly what we're doing here because there is an inbuilt function for this but it's just good that you understand what's actually happening before you use functions that are just built in so now we have a function and some really naughty floating numbers so we're going to go ahead and try to compare them so here we're going to go ahead and print and we're going to compare the values of a plus b with or actually now I don't have that anymore so we're going to go first plus seconds to the value of third and at this point we can agree that 0.1 plus 0.2 is 0.3 and that's what we want to prove with our function but inside here we need to go ahead and provide it with a tolerance so the tolerance is going to be equal to 1 E minus 10. and I'm really really bad with scientific notation so I mean that's going to correspond to 10 decimal places and it's going to end up looking like this so this over here is the equivalent to this decimal but it just looks a bit better and people will think you're more professional if you use scientific notation although for readability I really would rather use this one over here so it's up to you but that's what it represents I'll leave it there and when we go ahead and run this we're going to get true back this time because even if this is 0.3000 whatever four minus 0.3 we're going to get this as the difference this is the absolute difference and you're going to notice scientific notation here so this is 5 to the minus 17 and we're only comparing for numbers that are within the range of 1 to the minus 10. so I mean to compare what we're comparing I'll put this hash down and put another hash so here I'm going to copy this and when we put that you'll notice that this over here is trying to represent a number that's going to look similar to something like this so this is extremely small and since this is such a small difference it's not even going to keep that into account and it's going to say Hey you are within the tolerance so that is absolutely fine so let's take that away and let me show you something else because this is an acceptable tolerance and you need to play around with the tolerance based on how accurate you want it to be because if you make the tolerance too small and you say this should only have a 0.1 tolerance and then we go back up here and change this to zero to five you'll notice we're going to get true because that is within the tolerance level this is a 0.1 tolerance and that is absolutely awful I mean you can tell that these floats are not even close to being the same but since the tolerance is so low it's saying anything within that range is going to be accepted as being a comparable float so generally you would want this to be as big as possible and we're going to keep that at 10 e minus 10 or actually one e minus 10. so that we get this extremely small tolerance and let's go ahead and change this back to three but if you make the tolerance far too small such as -20 we're still going to get false because now it's going to check for 20 zeros which means 4 is within 20 and it's going to say hey that is not zero and we're checking within that so that's going to be evaluated to false even if 0.3 and 0.3 are the same so you really need to play around with the tolerance depending on how accurate you want it to be in general I think 10 is fine even 6 should be fine I mean I don't know how many zeros you want to compare but we're going to keep it at 10 for this example and that is one really good way to compare floats now I know a lot of people really hate creating custom implementations and they do have an inbuilt function for this so let's go ahead and import that so here we're going to go ahead and import math and with math we can go ahead and print math dot is close we'll pass in first seconds and we also need to pass in the third number so first plus second is the first number you want to compare and third is the second number you want to compare and then we need to provide a tolerance and we're going to use relative tolerance for this which is exactly the same as the tolerance we just created and the tolerance should be something similar I mean if you do something such as 0.1 everything is going to be accepted so it's always going to return true if you do something such as one e minus 20 it's going to return false because as I mentioned that is far too specific it's looking for 20 decimal places of precision and those have to be exactly the same or else it's going to evaluate two faults so picking a number somewhere in between like 10 is going to return true because now we're just checking within 10 decimal places whether it is the same or not so it's going to say 0.3000 for 10 decimal places and since that is equal to 0.3 it's going to return true so this is another great way of doing it and I mean of course you can go ahead and try to play around with the round function but I think these were two of the best ways to make float comparisons in Python but of course I'm open to hearing any other ways of comparing floats please do leave it down in the comment section down below I'm always up for learning something new or for sharing something new with the community but with that being said that's actually all I wanted to cover in today's lesson and as always thanks for watching and I'll see you in the next video