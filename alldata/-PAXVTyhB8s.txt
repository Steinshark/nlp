hello everyone welcome to oo considered harmful i'm phil nash and i'm going to spend the next 60 minutes or so talking about all the ways that oh could be harmful to us or maybe not we'll see see how that goes um we're actually going to spend most of that time just getting all of our ducks in a row which is not really what this background image is for you can think of it maybe as more like a proxy for duck typing which we're probably not going to talk about much either anyway getting ahead of myself i actually want to get back to that title so 0 considered harmful sounds familiar we might consider that a bit of a meme these days the you know something considered harmful actually you know before we thought folded these things as memes they uh they still existed in fact they had their own name uh snow clones is when you have some sort of template phrase used as a title for a tall current article or something like that uh been around for a long time this particular one has actually probably been around for longer than than you think so before we started using a software development in the 60s which i'll talk about in a moment it's actually used at least as early as the 40s in journalism circles so actually you know only really crossed over into software development in in the 60s and it did that in the article you're thinking of which is of course go-to considered harmful i only had to put two letters in there that's quite nice actually technically that's not true it's a go-to statement considered harmful it's the the full title of the article which wasn't even an article as a letter to a magazine from edgar dykstra of course in 1968 he wrote to the uh the communications of the acm magazine and in yet another historical inaccuracy that wasn't even the title that he submitted it under he originally called it a case against the go-to statement and it was the editor nicholas worth that changed it to go to statement considered harmful because of that snow clone that was uh popular in in journalism circles at the time and i gave it a bit more impact these days we might say you know click bait didn't have clicks back in those days but uh you know still having a title that had some impact to drawing readers well you know certainly had that effect we remember it today in fact i'm pretty sure that most people watching this are familiar with this title but has everybody read it well i want to get you to tell me so if you are watching this live i am pasting a link into the uh remo chat now that's going to work for me there we go that should be there now it will take a few seconds for that to get to you because of the delay going around to youtube so i'm just going to waffle a little bit while that happens uh but this is just uh some interactive uh slides that i got here which i'm just gonna initiate now okay so that should give you time to to actually get the page so you can tell me if you have read that paper or not um so i'm going to ask in fact jens has already ahead of me and he's put that up for me thank you we're getting some results in i can see that as expected most people have not read it which is fine that's uh you know i before i did this talk or started preparing for it i'm not sure if i'd read it in full so it's a shame really because it's actually a really good paper so it's a letter to a magazine we consider it an article now there's some good stuff in it it's not just limited to the go-to statement so yeah six people say they've read it fully and i'm sure some of those are exaggerating uh well i'm gonna if you can take me back to the slides jens thank you because i have it here well this is half of it so the full thing is only about the twice as long as as you see on screen now you can read it in in one sitting i definitely recommend it but i just want to pull out a quote so he starts to build up his initial argument i just want to go to his second remark where he says my second remark is that our intellectual powers are rather geared to master static relations and that our powers to visualize processes evolving in time are relatively poorly developed interesting wording there and it's really bringing in the human element to this it's our powers of visualization that are relatively relatively poorly developed and actually goes on for that reason we should do as wise programmers or wherever limitations are utmost to shorten the conceptual gap between the static program and the dynamic process to make the correspondence between the program spread out in text space and the process spread out in time as trivial as possible now i think that's where it gets really interesting talking about this conceptual gap between the code that we write and try to understand and the relationships there statically and the actual dynamic process at runtime and how that unfolds because they're not going to be the same thing but we want to do as much as we can to to make them the same way they can be because that's going to make it much easier for us to understand follow and reason about it and really that's what this whole article is about it's about being able to reason about your code and then of course it goes on to make the case for why uh goto gets in the way of that makes it almost impossible to reason about lines of code and isolation what we now might call local reasoning because he kind of needed multiple entry points just completely screws our ability to reason about it without having to consider all of the code now that sounds familiar it's because it's not just when it comes to go to and execution through code that this principle comes up we're going to come back to this a bit later so do encourage you to read the whole thing at some point mostly it's pretty accessible there's just a bit in there about text indexes may not be immediately obvious but it's really just talking about how we we think about the execution pointer moving through the code and how we can reason about it but you know this is all old stuff now isn't it you know he's talking about this in the concepts of what became structured programming which we've now sort of absorbed into mainstream practices particularly oh so yeah we don't need to go back to this do we well i think kevin henny might disagree with you uh he seems to think that we have forgotten much of the art of structured programming and there's still valuable stuff back then in the 60s when we were first talking about it that maybe we're missing at least some of the nuances now that we could go back and look at some of the historical contexts but also you know some of these things are timeless some of these things will still help us to reason about our code and maybe we just don't really talk about it so much now so it's a great talk that he did last year surplus plus on c the forgotten art of structured programming maybe you've even seen it it's a good chance you have because the last time i checked about an hour ago actually on youtube had 160 000 views now if you've ever looked at view counts of c plus talks you'll know that's that's pretty good there's only a few that got up that high most of them by biana so this is a bit of an outlier i don't know exactly what's going on there but it's clearly a popular talk and that's good because it's a great talk kevin's talks are always really insightful and in fact i have a bit of a confession to make here when i was first preparing for for this talk uh well i knew going in that was going to be referring to you know one or two of kevlin's talks because thinking back i could trace back my thinking on certain things to something that i'd heard kevin say but the more more i looked into it the more i realized that no matter where i looked it seemed like kevlin got there before me it was a bit like that south park episode where no matter what they did they realized that the simpsons had already done it except in this case it was cleverly henny that would already done it but you know what that's a good thing because this talk is going to be quite high level fairly sort of philosophical we'll look at some of the nuts and bolts but mostly we're just going to be looking at the broad strokes we're not going to go very deep on on those things but we're going to talk about a lot of different subjects so the fact that i can point you to a number of talks by kevin henney it's a good thing you can go and uh fill up on on those but there's a few other talks and and books and articles and references that i'm going to link to a page containing at the end of this talk so don't worry about keeping track now i'll give you that link at the end uh let's carry on though because so far we are what's uh 10 minutes into the talk and i haven't actually talked about oh yeah so let's get there what is oo well again before we we talk too much about this uh i want to well i should start off by saying of course as we know always stands for object orientation but what is that and this is where i want to go to my next interactive slide i've just advanced that on so go back to that link if you've left it otherwise it will take you there you can actually put in words or maybe short phrases that you think are associated with object orientation that either define it or at least associated with it what do you think object orientation really is and again it's going to be 10 seconds or so before they start to come up i can see some coming up now messages that's an interesting first one to come up classes is probably more commonly the first thing people think of inheritance reusable yep now we're getting now we're getting there adam k that's interesting small talk that's some some good suggestions there so i did this at cppcon as well uh let's say obviously the big ones are about the same but lots of the little ones are very different how to combine these all at some point so if you're seeing that you can see that there's a lot of different things that people associate with object orientation but the big ones standing out there quite clearly inheritance encapsulation polymorphism i think most people agree they are sort of the bedrock of o.o but if you could uh take me back to my slides please you where did it all start what was the uh the the initial motivation for object orientation so i think most people would point back to simula as being the the first uh what we might call object-oriented language certainly some of the ideas may have come before that uh particularly um a lot of a lot of things around abstract data types we sound very familiar when you we talk about the object-oriented ways but simulator was the first language that we think of as being object-oriented but again you know like that uh dijkstra article most people know that but they don't know much beyond that that was true of me so i wanted to look into the history of it a bit it's quite interesting at first there are two main branches of the language they're almost like two different languages the original similar one which came out in um 1965 certainly the early 60s um and then there was uh the follow-up language similar 67 obviously came out in 1967. the reason that's interesting is because as i say they're very different languages and particularly their take on what we now call object orientation it's actually quite different so similar one the idea of an object is based around what came to be called a process so that's interesting straight away because we think of processes as very dynamic things um and these processes have basically three operations uh that the main run which is the the main entry point to to a function and then you can have suspend and resume and again this may sound familiar because this is basically what we would now think of as a co-routine factor co routines were around in the 60s as well another old idea that's coming back but this is what similar one had as objects objects were processes they were effectively co-routings so how does that make them objects well if you think of a co-routine in fact there's there's a really good talk by uh raina grimm that i think is going to be giving tomorrow about the evolution in the c plus plus context from basic functions to overloaded functions to lambdas via functional objects and eventually to co-routings and how each one is the generalization of the previous one so co routines are basically functions with state which is what lambdas are but they also have this ability to be suspended and resumed their processes back in similar one were a bit more basic um you couldn't run them concurrently for a start so you we suspended one process in order to uh start or resume another one uh but that's all fine but because they had their own state that state was effectively encapsulated in the process so processed at state and had a runtime execution and had a form of encapsulation because outside of that process you couldn't access the state within the the the process of co routine very much like co-routines now although now you can um give it access of course so then they came to do similar 67 now similar one was much more of a research project or at least it was um it was really good up to simulations hence the name but it was so successful they realized that they really needed to make it much more general and mainstream i said they took this idea of a process and they generalized that further to what they called a class announcing sounding more familiar again interesting that the class with the generalization of effectively the co routine not something not a way around that we used to thinking of them but they had all the familiar features okay subclasses you could have variables which we might call member variables now or fields procedures or member functions or methods and virtuals things that you could override in a subclass in a derived class or their way around so it had polymorphism interesting one thing it didn't have at least in the similar 67 variant was encapsulation now when i made this statement in my cppcon version in the the youtube comments somebody said actually similar 67 did have encapsulation had this hidden protected keyword um and i i was looking into it and i cannot find any mention of hidden protected for simula before i think similar 85 and some branches before that but 7 as far as i can tell did not have encapsulation in the form that we know it today other than what it inherited you bobbing the pun from similar one in the form of these processes which you still had the process was now a particular type of class and in fact it's really downplayed uh the process part of similar 67. it's all about the classes i think it's a bit of a shame because that idea sort of faded out for a while in mainstream circles and has only recently become very popular again so okay so we have classes we have inheritance we have polymorphism uh we don't quite have encapsulation but definitely recognizable object-oriented features in similar 67 and of course we have developed that further in in languages since then as we'll see in a moment let's have a look at a bit of code now i've never written a line of similar in in any form so i just got this example um off the internet somewhere so i can't vouch for it too much but it looks fairly understandable so we have dog class uh has a virtual bark procedure and then a derived class so i like the way that derived classes put the the base class name before the class keyword so we say it's a dog class chihuahua and then that overrides the uh the bark procedure there um syntax may be slightly different to what we're familiar with but i think it's all readily understandable and very familiar well we can easily see how that works if we've used any modern oo language so yeah interesting right back then is already looking very very familiar so i mentioned more recent languages actually going back before simula we had algol similar was actually a uh initially a strict superset of algol in fact similar one was originally just could be a post processing step much like the original c plus plus uh cb of classes was a um a front end for c uh similar was with algol so it's very much tied to the algol syntax but algo actually gave birth to a number of other languages in the the non-oho branch from the cpl through bcpl and b to c those other languages don't really get much of a mention these days other than as predecessors of c but that's where that language sort of baked and led to c and i think it was actually b or no bcpl that bjana was using at university when he first got the ideas for for doing c plus so those two branches effectively converged when when bianna created c plus plus now obviously this is a simplified view there's lots of other players but i think it's fair to say these are the the essential fundamental influences of c plus plus we have the most of the algol syntax via the c branch and then we have the oo features uh heavily derived from from simula and i think we've seen that in what we looked at but there were other derivations of similar or rather branches in the family tree a small talk went off in a different direction as did i fall now i've put those two up there because they they have some very strong ideas about o that are a bit different to c plus plus and we're going to look at those in a minute small talks particularly interesting because back in the early 80s when c plus plus was getting off the ground there was actually a lot of interest in languages that looked like c or extended c with oo features obviously c plus plus was the one that survives to today but also objective c came out of that same um melting pot of ideas and still survives to this day although it's obviously fading a little bit in lieu of swift but that comes from the small talk lane and in fact is uh well it's a strict superset of c with small talk features grafted on the top and almost i think it originally was basically uh macros on top much like c plus plus was and that's that's got some interesting consequences that we'll see in a moment so what i want to do is just stack up these these languages for these i've grouped into four there's five languages there let's put small talk and objective c together because i think for our purposes here they're essentially the same and just look at some of the oo features that they will have so first of all they all have in common classes inheritance in some form and polymorphism in some form devil's in the details and we're going to get to that so one of the details is that inheritance comes as single or multiple inheritance similar strictly single inheritance uh small talk and objective c are single inheritance for implementation but objective c does have multiple inheritance for protocols what we might call interfaces uh which is quite interesting um c plus plus of course has multiple inheritance as does eiffel eiffel is often considered to have much superior multiple inheritance to c plus plus a lot of the issues that we we tend to see in c plus plus multiple inheritance i give it a bad name and people say no don't use multiple inheritance has all these problems it turns out they're mostly the c plus plus problems uh eiffel doesn't have those problems to it to a large extent there may still be reasons to to avoid it there's also good reasons to to have it a language eiffel does a much better job of it although i've never actually written any eiffel either i'm just relaying what i've read so multiple inheritance there all right encapsulation so i said that similar other than similar one in that limited form and as i've since found out um similar i think it's 85 certainly later versions um the similar 67 didn't have encapsulation as we know all it rest do interesting because it's often considered to be one of the the more important features of oo encapsulation but similarly didn't have it another idea that is considered by many people to be really important points part of oh c plus doesn't have that's this idea that even classes are objects if we're going to be object oriented then classes should be objects too and that actually has some consequences in in those languages as we're going to see that in a moment as well in fact one of the consequences is that they their polymorphism is primarily implemented in terms of message passing let's have a look at what that actually means in practice because you may have heard of message passing uh you may or may not be familiar with how actually works so let's let's talk about that let's start by just reviewing virtual dispatch in c plus plus as we know it today effective just static dispatch to start with if you have a an object you want to call a method on it then you call a function and you the compiler will pass is hidden this pointer along with it and that's accessible with inside inside the method but that's transparent to you fairly simple straightforward and fairly performant that's static dispatch but when you introduce virtual dispatch there's an extra step of course so we now have to consult a v table so a table of pointers to virtual functions so you'll have one for each static um sorry dynamic instance of the object so that gets looked up first that gives you an extra indirection back to the method so you have an extra lookup and an extra indirection so there's obviously overhead there we're familiar with that sometimes we forget about it but it's always there but what about message passing then start with the same idea that we want to want to call the method method one in this case on an object what actually happens here in certainly a small talk and objective c is the object passes a message to the object that the message basically says i want to invoke method one optionally with these arguments but that's considered a message it goes to the object rather than straight to the method so the object then looks at what it wants to do with that message by default that's typically just going to be to call a function with the same name a method so it looks like it's working the same way but because it's going via the object rather than um a v table and a this pointer or there is a self pointer as well that means that the object gets to look in and that means it doesn't have to do things that way in fact the object can it can respond to messages it doesn't have methods for it can replace methods at runtime with different methods and it can even swap out whole implementations of whole objects at runtime depending on its own its own state let's just summarize some of those differences so message passing it's dynamic binding it's very late because the object gets a chance to decide what's where that's going to be routed to on every call has this property of method swizzling that's where you can actually change which method actually gets called so in javascript and ruby i think it's called monkey patching same idea um you can have these runtime delegation patterns so even on construction a good example in objective c is if you construct a string object the the initializer what we might think of as a constructor for for the string we'll look at the string itself and depending on properties of it like its length and whether it includes unicode characters it will choose a different implementation for the string at runtime that will then look exactly the same to you from the outside just as a different implementation so it's like a factory method built in to the language uh because you can change those methods of runtime it becomes very easy to mock it's perfect fit for a message passing language so these are all nice properties whereas virtual dispatch it may be more efficient in fact for years i think we've convinced ourselves that yeah we we're giving up on all of those benefits and message passing has because v table lookup it's an overhead but it's much more efficient you don't have to do these lookups which are usually string based and look up in a hash table but actually in practice in the the decades since uh certainly objective c got off the ground that message passing that there's a single uh function an objective sequel opt c send message which is responsible for this it's been so heavily optimized that certainly at one point about 10 years or so ago everyone was saying that message passing and objective c is about the same as virtual dispatch in c plus and obviously that depends on a lot of factors depends on what point of time you're talking about because compilers change cpus change the effect of caches and locality and all these things change it's difficult to put your finger down and say yes this is definitely more efficient but certainly times virtual dispatch has been more efficient that's probably why it was chosen originally in so many languages but really i mean we're not getting many other benefits maybe stronger type checking again to bring an objective c it's technically a dynamic language but it does do static type checking as well just gives you warnings instead of hard compiler errors and you can work around them but you should get most of the benefits of static type checking as well as the benefits of dynamic binding it's quite nice and apparently for very little overhead so all right virtual dispatch um may not be the best way to implement polymorphism certainly not the only way neither with message passing there's actually there's a whole family of approaches to polymorphism type erasure is another one that's getting quite popular um in c plus plus circles and it doesn't have first class language support but you can do it with libraries let's say dyno is that's been around for a few years so dynamic dynamics is another one i know uh eduardo madrid is working on his own implementation which uh he makes some quite big claims about particularly in terms of performance so that's gonna be one to watch um and and there are others of course it crops up in all sorts of areas like stood function has a form of a type erasure in it um stood any it's a very powerful technique can be very performant very flexible um but i said no no first class language support yet so you have to do a bit more work but some of the other benefits are non-intrusive and what i mean by that is with virtual dispatch and inheritance you bake into the type system that you want these objects to be treated polymorphically whereas they don't actually have to be properties of those types at all message passing doesn't have that problem neither does type erasure you can define your objects as is best for those objects and then you can get them to respond in uniform ways via other means and type erasure is one way to do that to say that there can be higher performance and particularly if they are tuned to today's compilers and cpus they can actually have more optimization opportunities actually show more of your intention to the compiler to to give it more to work with and i think my favorite feature is they are much more compatible with with value types i'll talk about a little that a little bit more in a moment um let's finish the list here uh concept mapping is another feature that type erasure can give you that we can't really get through um virtual dispatch um don't want to go too much into detail about what that is other than to say that it's a way of um adapting interfaces so as i say because you're not breaking the polymorphism into the types themselves the types interfaces may look a bit different even if they work more or less the same way so with concept mapping you can actually bridge those differences and give you a consistent way of calling something you can see why that would be necessary if you have looked at swift swift has something called protocols which it got from objective c and objective c protocols are really just interfaces in swift they've been taken further and they'll actually give you a chance at the interface level to add this extra code in that gives you this effectively concept mapping and you can actually add protocols to types after the type definition itself so you can say i've got this class here later on i want it to be able to conform to this protocol and these methods are going to be implemented this way it's a really powerful approach to object orientation which again is much less intrusive on the uh the types themselves so i don't know exactly how that's implemented under the hood so i'm not going to claim it's the same as type erasure uh i suspect there's some of that going on as well um and closure actually has the same um names feature uh protocols which are mostly the same but i think they have arrived at that independently i think it's mostly a coincidence that they are effectively the same all right i said there's other ways to do polymorphism another one that's becoming popular in c plus plus is what we call sam types at least that's the the computer science name for them uh we might think of it as things like stud variant uh still optional so anything any type which can hold um multiple other objects of multiple other types internally it's obviously an optional it's a type or nothing invariant it could be one of um any number of types and you know we see other forms of this creeping up as well but then you have to have ways to um deal with those objects that that the concept mapping idea if you like because you don't have uh virtual methods how can we call something on an object in a variant in a uniform way well we have stood visit in the language which works and i think that's about as much as we can say for it maybe it's it's a bit less code than writing out by hand um there's there's an article that many of you will have read again it's in the references a couple years old now um stud visit is everything that's wrong with c plus i don't agree with everything in the article but i think the central point stands that if stood visit is the best way that we have in the language to deal with some types then we've got a long way to go before some types are a a really first-class way of doing polymorphers in the c-plus plus i'll go further and say that actually we need variant itself in the language as well which is on the table that's been proposed um quite some time ago now but it's been paused for a few years hopefully i'll come back on the table what is going through a bit more faster pace is the pattern matching side of it so this is what would effectively replace stud visit um there's a lot more than stud visit and it's much cleaner um hopefully still targeting superplus plus 23 that was never guaranteed i think it slowed down even more in current uh conditions of the uh the working group but we're certainly working on it and this will give you the ability to effectively do type switches it's actually much more than that but imagine you could in a switch statement you could say a switch on the type of the variant and in each case you could you could not only pull out that particular type but you could even break down the um what's in inside the variant uh two to greater levels for example if the variant held another variant or a or a structure or something else you can actually pull out parts of that as well and maybe even match on values in there so you can have a different case for when an optional is empty or not empty so if you've not looked at pattern matching before i definitely recommend you look into that it's a really powerful language technique that is in many languages now including swift we've mentioned rust is another popular one most functional languages and c plus plus is hopefully going to get it in the next few years so do watch that that will really make some types a really powerful way of doing polymorphism in c plus plus now the main difference between some types and the other forms of polymorphism are that they are um a bounded set of types so with polymorphism uh so we've um inheritance and virtual dispatch it's very much an open set any class can implement a a non-final base class whereas with some types you have to specify the full set up front much like you would in an enum now most of the time that is actually what you want so it's a shame that we have this mismatch of an overly flexible form of polymorphism for dealing with a much narrower set of problems sometimes you do need the open set and it's useful to have more than one way of doing polymorphism as i say there are a number of types we're looking at a few here closure again has a concept called polymorphism a la carte so actually a feature of the language if you like is that it has multiple ways of doing polymorphism so that covers all bases you just pick the one that's right for the moment all first class supported hopefully we'll get there in class plus i mentioned also a language level variant hopefully will be coming at some point as well because i think varian is a bit heavy-handed for a lot of use cases so that's some types even um templates or these days concepts can be used as a form of polymorphism at compile time but nonetheless um much more um flexible actually than a virtual dispatch in a way more like message passing or perhaps type erasure quite interesting that we had that in the language uh well from the beginning really but only at compile time now what else well there's actually any um any other need for implementation inheritance other than to support virtual dispatch it's an interesting question i'm sure you can think of some niche uses but generally implementation inheritance is only there to support virtual dispatch so given that we have all these different ways of doing polymorphism do we actually need an implementation inheritance at all interesting question we'll come back to that but let's talk about encapsulation so we mentioned polymorphism implement uh inherited implementation inheritance what about encapsulation so remember that we said that all of those um oo languages that have a part to play in the history of c plus they will have some form of encapsulation except for similar 67 other than that limited form in the form of a process so clearly that's important well actually i want to go back to dijkstra's letter and that remark that we quoted i'm going to read it again and now think of this in terms of encapsulation so my second remark is our intellectual powers are rather geared to master static relations and our powers to visualize processes evolving in time relatively poorly developed it's interesting when you think of similar ones processes for that reason we should do our utmost to shorten the conceptual gap between the static program and the dynamic process to make the correspondence between the program spread out in text space and the process spread out in time as trivial as possible so he was talking about go-to's there but as i said when we looked at this the first time this generalizes can refer to lots of different things and certainly for me i've done if you have the same reaction the first thing i thought of when i read this was mutability mutability gives us a conceptual gap between the way our programs are written and the way they run because when you reason about any line of code when you think about the values of any of the variables and objects to reason about mutable values you have to consider all of the code or at least all of the code that that can touch whereas immutable values because they can never change you can apply that local reasoning so the conceptual gap between your static programmers is written and how it actually runs is as small as possible this applies great but we were talking about encapsulation how does that relate let's look at our first code example very simple one we're not really going to get into code too much but um i thought this would work better as a code example so imagine you have a really simple date class so okay we've got a year month and day model of them as integers i'm not claiming this is the best implementation of date that's not the point hopefully it's simply enough that we can illustrate what i do want to talk about which is encapsulation okay so we capture a year a month and date in the constructor um we don't just store those values though we actually can do some checking on now that there's a whole other topic here of where you do uh bounce checking and input validation so here i'm using a search because i'm going to assume that it's a logic error to construct an invalid date but it will at least tell you in in debug mode if you get it wrong if you want to do input validation you may throw an exception that's not the point of this talk i've done other talks on that what i really want to get at is that once you have constructed it it should now be a valid date if you filtered out invalid inputs once it is a valid date you would hope it would remain one but how do we enforce that well this is very one of the ways encapsulation comes in we make those members private and we only give access to them through accesses the the year month and day methods you see at the bottom so far so good we're familiar with this i'm sure we use this pattern um there has been an overuse in the past of setters as well as getters basically throwing away most of what we we get from that encapsulation that's getting better so let's assume we just have the getters here okay now we can more or less guarantee that once you have a valid date you will stay a valid date why because we can't change it but if we can't change it then why did we make those values non-const in the first place so oh should have been highlighting that here we go if we made those members public then obviously we could change them but we made them const well their only variant is maintained so why would we need the getters we could just make them public um bit of a typo there i should have removed the prefixes as well but that aside in many cases not all of them by any means but in many cases this is just a much simpler way of doing things very often again not all the time but very often the classes that we write that just hold data like this are just gonna be much better off just exposing that data the data is the first class part often that the reason that we do wrap them up in encapsulated interfaces is so that we can protect invariants that are only there if we allow mutability it's an interesting thought i'll leave you with that one i'm going to say too much more about it there is another aspect to this that obviously encapsulation is a good thing um may not always be as necessary as you think in all of the cases that you think but it's definitely useful some languages have taken the approach of giving you encapsulation at the module level module is another overloaded term think of it in our terms as being the translation unit so you might write a cpp file and you might say everything in the cpp file is private as far as the outside world is concerned but within the cpp file i can freely call any other part of it or access any other part of it and obviously that gets complicated with header files and so on and maybe with actual modules that might be a better way to express that same thought makes a lot of sense in a way it's actually the locality of the code that also expresses its accessibility if it is something in that maybe that's where the lines of encapsulation should be drawn but as i say it is a useful concept this idea of immutability simplifying things i've talked about it at much more length in another talk i've done functional c plus plus for fun and profit again it'll be in the uh the references um and a particular part of that talk i just got to mention briefly was talking about strings in fact i called it a fast and safe route counted string and it was relating an experience from a previous job where i wrote such a thing and the way i did it was to separate the immutable string which could be ref counted from a separate type which are called string builder which actually um encapsulates to use that word the the mutability there are cases when you want to be able to mutate strings particularly constructing them in the first place if they need to be built up out of parts and maybe even modified later but for most of your program um strings are not expected to change but if they are immutable understood string is you pay the cost of that so our attempts to make it reference counter to the past have hit problems because of that exactly because of that mutability you use this approach of separating those out into different types what actually happens as this slide shows is you get to very clearly control the lifetimes not just of the string overall but of the mutable inimitable parts of it you can clearly see in the code i've got a string builder here this is the mutable part however here i've just got a string it's immutable i can reason about it so that reasonability comes from knowing what the invariants are of your types if we use that that is one of our biggest tools for closing that conceptual gap between the the static code as written and read and its dynamic nature running as a process i think that's really valuable now the reason i bring this up in particular with strings is because we often treat strings i'd like to stream to treat strings as value types in c plus and in fact many languages they're not value types or at least they maintain their own memory and may or may not have reference semantics but they have extra complexities and that mutability is a big part of it can't be a value type if you can mutate part of a string if it's an immutable string i think it's fair to call it a value type that we can take this line of reasoning much further as uh juan payne did in his talk again c plus plus on c um this year squaring a circle valley oriented design in our object-oriented system talking about some of these same concepts but particularly with that focus on on value types again i'm only touching on this now but i think it's really important which is why i want to point you with that talk i think value types are really important tool for simplifying our code and minimizing that conceptual gap again but i want to get to my closing uh thoughts before we wrap up try to bring this all around can we actually have the best of both worlds of all the good things the good parts of o.o but also all of the uh the other things the um the value types the mutability type erasure all those other things we looked at it could be the best of all worlds so my talk title was oh considered harmful now we said that that was a snow clone a bit of a meme generally it doesn't really mean it's completely evil it means there are some good parts and there's some bad parts and maybe we um we get them all as a bundle we want to be able to look a bit more critically so i think that's what we're trying to do there are definitely some good parts to our own we want to throw those out the way i look at it is tend to split it between low level and high level at a low level in the small i usually prefer immutable value types like that string class i just talked about and many other topics we haven't had time to talk about today i've talked about some of my other talks um and others talk about them as well of course persistent data structures another functional concept to allow us to uh share um common state amongst otherwise immutable types magnetic operations don't necessarily have to understand what they are but being familiar with the operations themselves will actually allow us to get a lot of the benefits that we get from o.o in a more functional immutable world particularly uh chaining sequences of functions builders like the string builder it's a more general pattern of being able to separate like a construction phase from an immutable usage phase and often even going back into a construction phase again when you need to particularly with um uh movable types that can be a quite efficient way to do things and of course functionally composable algorithms like ranges that are getting c plus plus 20. all these things tied together they definitely have a very functional feel to them that's how i prefer to work at the low level because these are the tools that i feel give me the best chance of closing that conceptual gap between how the code is written and how it actually runs but at the high level i think this is definitely where the the oo concepts really shine particularly encapsulation again maybe at a larger uh a higher level than the we're often used to using it um maybe even going as far as what we might call active objects actors or co-writings they're all slightly different variations of the same thing really things that not only encapsulate state but encapsulate runtime as well if we had these sort of larger components with their own mutable state built out of essentially immutable low level components i found that to be the best recipe for code that you can understand but is also still useful that's my best of all worlds and with that i'm going to go and have a look to see certain questions um while i do that and leave that slide up because it has that link to my website where all the references i've talked about are so level of indirection.com you can also get to it from extra level of indirection.com just redirects here uh slash refs slash oo dash harmful.html i'll try and remember to place that in the uh in the chat um afterwards let's kind of look at questions so what do you think of the pimple idiom for encapsulation that's a really interesting question because the pimple idiom actually um gives you better encapsulation than just the private or protected keyword itself because private protected is about access whereas true encapsulation would also be about visibility and if everything is in your class declaration then you can see it there and your your code can even depend on it indirectly if you move it out of the accessible header file using the pimple idiom then you actually get better encapsulation as a result so what you need encapsulation that can be a good way to go now of course the theory is modules should give us all of those same benefits uh in a nicer package um still remains to be seen how true that's going to be but i'm still hopeful so i still think that the module is going to be the better unit of encapsulation but the pimple idiom may be a good stepping stone um yeah one thing i didn't mention actually was one of the problems with encapsulation in c plus plus is if you have a class with private implementation which has a reference to another instance of the same class it can actually see inside that class you can see it's private members can access the private members whereas uh the pimple idiom we you can still do it we'd have to go in extra level direction uh what do you think of go's approach to polymorphism uh that would be a really interesting question unfortunately i'm not familiar enough with go to uh to know exactly what the differences are so i'm gonna have to um talk to you afterwards about that one victor uh pimp palladium was originally called the cheshire cat idiom by john caroline sometime in the mid-1980s um thanks jonathan i think that's what we call more of a comment than a question um yeah yeah if you don't know the pimple idiom by the way and you're watching this talk you should probably look it up that's uh hopefully you shouldn't need to use it too much these days but it's really something you need to know