so okay good afternoon everyone and welcome to uh my talk about minimal logging I'm uh thankful for the organizers to let me open this B track here on meeting C++ 2023 with my presentation so my name is kunon and uh I'm from Belgium and I'm currently working for the Vila group and um this may be a name that is not too familiar to you but we're a textile machine manufacturer from Belgium which started as just a family company for weaving machines but now has grown to a very big company which has all kind of textile machines so that's why we uh call it like that so I'm leading a team uh working on embedded software there so to make sure that the operator can choose the carpet which he wants to make and uh if you're lucky or if we have done our work correctly this is an example of a weaving machine then you start off with like a almost almost 40,000 bobbins of yarn and then at the end with the jackard here on top that produce all the complex patterns you get end up with a a carpet and actually there's a fairly decent chance that the carpet we have our feet on now is actually produced on one of our machines so that is quite nice to uh to note um before that I worked at Nikon mology uh which is a company that makes measurement software uh and I like to mention it here because also some of the IDS that I will present uh originated there some more background perhaps I uh studied mathematical engineering and if I'm looking back I can see that my first contact with C++ was in uh 2003 where I did an implementation of the discrete fore transform but for understandable Reasons I'm not going to show that code here today now instead I want to focus on logging and then some of the adventures I had with that um so just to set things clear some examples of typical log statements uh our codebase uh uses cute so there you can have this kind of uh statement where you have a um that has some delay um where you have some Primitives like debug and warning and so on where you can uh stream some data too and the nice thing is that this automatically adds a new line at the end so your code is not riddled with new lines or STD end lines uh or whatever uh and also uh these streaming operators make it really convenient to use it with all the types that are uh present in cute uh it adds quotes to Strings it adds the spacing where necessary there's some decoration for the for the typical types and so on so it's really easy for a developer to write this um this these log statements there's also the possibility to log your or to categorize your logging so you can can Define different categories of logging and at startup you can even choose which ones are active and which ones aren't that's really useful because by default you can put most of them off and if you realize that there's an issue at a customer specifically on that machine you can turn on specific extra debugging logging or something similar also for the output there's a pleora of options to uh format this you can add the file the line the method of course the time St and so on so that's really really quite flexible and easy to use but even if you're not using uh cute or any other framework with the standard template Library you already have enough to do it so you can for example Define here a a log macro and use uh the same formatting options which you have uh or similar formatting options to also create a nice output to include the line function and so on you can use the pre-process cessor micros of course and also end up with an output that is fairly similar but with C++ 20 there's now the source location feature where you can write this without a macro and actually use this uh trick or this common pattern where you have a function which takes an additional optional argument which you default to uh uh SD Source location current which then once you do the logging at the bottom uh gets instantiated at that location um note that this is this requires compiler support because well I wouldn't know how to write this function and that's something you really need the compiler's help in to get this uh up and running so some examples of of uh log statements um actually when I was investigating some timing issue on the on the machine I noticed that if I added one extra log statement the entire Behavior changed so I had a some kind of timing issue and it went completely away when I added one more uh logging statement so that was really surprising to me at least um at that point in time so I went and and started investigating what is what is the what is the impact of of this logging so looking at just a generic case of logging and a Boolean an integer and a floating point I ended up with a measurement of um cute being this amount of time and uh sdo stream taking that amount of time so at first you might think okay cute is faster we should surely use cute for that but that's only the average uh we have to do some more uh statistics on that and if we look at the aror bounds then you can clearly see that the all although the io stream solution is a bit slower it is much more repeatable so it's uh using this method it will create a more predictable uh overhead to your uh log statements so that's the reason why you always need to do some statistics on on there to make sure that uh well you get something that is repeatable that's a lesson I learned from the Metrology side of course um I intentionally did not put any numbers here but to put it into uh context Let's uh look at what it takes to create the current time so that's an operation any log has to do to to be able to uh print out when this happened and then you see that this is quite a big difference so in an ideal case you would prefer to end up somewhere to the more to the left instead of uh the these quite large results so what is what else is at play here what else is causing this large uh discrepancy between uh these two measurements and well I I think there are three uh sources of overhead one being formatting so uh uh printing out or converting data types to Strings is really uh something that can take up some time and also um log files notoriously are uh very verbose um having thousands of machines in the fields at customer sites uh that all produce log files if you have to analyze an issue and go through tons of those lock fils it's really uh you notice how much um suboptimal things are loged things that are not necessary are repeated too many times so there's uh log files are quite um non ideal in that sense and also because so much is locked I think it puts additional strain on the memory system uh which can also um cause some of the slowdowns I might might even slow down your uh your software itself so adding some log statement into a hot Loop somewhere might really mess up your performance this is also confirmed uh by u a developers conference um presentation of 2016 where Apple uh some apple Engineers talked about this and uh proposed a different solution but so um I really want to reduce the amount of overheads and the actual spoiler here the blue bar is the performance of what I'm going to present here so that should be interesting I hope so minimal logging um I previous gave this I previously gave this stock in an users group meeting uh where I went into uh well use live coding to uh present the entire framework or well framework is a large name or a large term because the uh resulting code only is 200 lines so that's uh really feasible for a live coding but as I feel that I can present the IDS better with slides I'm not going to do this here but I want to uh uh give a hint of what I used to make this live coding really um uh well well that really helped me in the live coding and that was to ensure correctness I of course write unit tests so I have a set here of unit test on the top right uh of the things that I want really wanted to well that that the framework should be able to do at the end of the of the presentation and of course I want this to compile and run even if my implementation of the logger is just this so to do this I end up with some kind of boiler plate which if and we have to fill in something if a feature if this feature is available you do the first uh branch and if it's not available you just fail the test so in uh C Plus+ 20 there's a really nice way to write this you can say if con exper requires uh if the if this so the the provided logger has the trace method available you can do the trace and and verify the results if not then you just fail the test so um this is certainly not something new for C++ 20 this is a well-known pattern actually the auto already revealed that this is an an template so as I understand it uh the because the template is instantiated by your compiler it's not necessary that all the code inside of it uh actually um would compile in a standalone setting so that's the substitution failure is not an error pattern which is now quite a lot abbreviated because of the use of Auto and the Conex for requires so I thought that was a really nice pattern which I wanted to share with you as well so I'll leave this this out for the remainder of the presentation just not to clutter the slides too much but uh that was a trick I really used and helped me to end up with the right solution at the end of the presentation before but so logging um I really went down to the basics uh my father always told me you have to be a bit lazy not in the sense that you have to give all the work away to someone else but to be critical about what you're doing and look for opportunities to do l and achieve the same results so with that in mind I set out to to find what is the minimum we can log to to still get the same results and the same uh Fidelity of uh of log uh logging so the first is uh when so you needed some kind of time stamp you need uh to know where in the code something was locked and then finally also there's a what that was logged uh with additional parameters or uh uh arguments and states of that point in the um application so let's start off with the point in time so what we typic typically do is just print a time stamp but come to think of it and as Al also mentioned in the keynote this morning uh doing uh calculations with calendars and times and so on time zones and and so can be very uh difficult and therefore also costly so if with every line you're logging you're doing this calculation over and over again I think that's really a waste so uh starting off with c c Kronos Library you can do um I think something else which is uh interesting so we start off with the high resolution clock taking uh the well the highest uh accuracy we can get and let's say we record our time unit in NCS then relative to some apoc we can record the uh you the the the time that has elapsed since then then we put this inside a record which will be our basic unit of logging so every log statement will correspond to one record uh further on so um notice that there's no formatting here so we just query some kind of clock and then store the value uh there's no time zone issues there's no uh possibility for leap seconds and all the things that can happen with times and also we get much more data in a much more compact format so uh the thing on the left was already 24 byes with just millisecond resolution uh the solution here with the with the clock type is only 8 bytes and has nond resolution so that's really a difference in both formatting and also in verbosity you will be able to lock a lot more of these time stamps relative to uh printed out text format time stamps so how do we continue with uh our logger then it will be fairly uh straightforward we make a template with a trace function and this Trace function will just take this record with the current uh time and added to some kind of circular buffer this circular buffer is also nothing special it is basically a fixed capacity uh array which I mentioned here on the bottom um fixed allocation uh fixed capacity and Heap uh stack allocated sorry uh because we want to avoid any memory uh expenses uh it's allocated before your critical part which you want to instrument and which you want to uh measure uh so therefore uh having reallocations or anything which happen at a fairly unpredictable rate is really not beneficial for the um for the accuracy of the results there's also here uh the mention of the size so it's fixed and I chose it to be a power of two just to uh get rid of a modul operation which you would have to guarantee the circular part of the of the of the buffer and then we have an append method which is basically a copy of this record into the buffer so there's no formatting there it's just taking the binary data of the record and putting inside putting it inside of of the buffer with that we can have a look at our first unit test which uh basically instantiates this logger does a trace then sleep or anything else which would be relevant to measure in time and then you can add another trace and this is actually the online part of the of the or or this represents the online part of your program so the thing that you really want to optimize for efficiency and uh make sure that all all the sources of overhead are not uh disturbing that because this is a unit test it's all in the same uh same method but that's the the distinction we have to make between the online and the offline part so then we can uh collect this data from the logger and uh verify that there are two records in there and we can U do any calculations we want based on the time difference between the two log statements so that already gives us in almost most system an 8 byte integer uh the timing information which is a a good start the second part in the wear is uh a little more involved but we will go through it step by step and it it all started the first time I um uh opened a debugger put a break point and then the the the debugger stops and it tells you exactly you're now in this file at this line in uh this method and I thought wait I I didn't tell you I didn't tell that I didn't program any of that in uh in my source code so how does it know that um so it's already it it knows where you are it knows uh all the details so actually why would you add uh add another or use any means to add the function name into your program the debugger already knows it so even though we have uh in the source location in now or the the pre-processor macros why would you add additional strings to your program that that that was really something that was puzzling me also in general I think we should uh be cautious when logging strings um if you can convey the same information with just an integer or an enum or some other data type that is more compact than a string that's uh certainly something that could be preferred so how does the deburger knows it uh well that's because he he has access to the the to the the address the instruction pointer which is on 64 bits is of course 8 bytes and by using the debug information that is part of a a debug build by default you will be able to resolve this address back to the uh the to the name of the function the file and line so all this kind of information is is automatically encoded in the debug information so um what what should we do now should we just include debug information with all our builds or also the release builds certainly not so there we can follow the uh workflow that is typically used in U crash dump analysis so let's have a small interm medzo there um so in that scenario you have your normal program you attribute with a crash Handler which in case something goes wrong will do necessary things to collect information so on top of that also in our release builds we will add the debug information um which can be quite large and that's why we are not going to ship that uh seeing a factor 10 uh increase in program size or binary size is not uncommon so um that's really something we don't want to ship with our products um but there's also some more reasons because if you would share this information that's actually an an a risk for people that are have uh have other plans with your software because if you can locate a certain proprietary code or anything using the debug information that makes it really much more easy to reverse engineer your software also if you give away the location of uh some kind of software check or Security check that's also making it really straightforward for someone for an adversary to to know where to look to uh sabotage it so now instead we're going to keep this debug information uh within the company uh make an a good Archive of that because we will really need it later so if at a customer a crash happens uh it's not always easy to reproduce it so it's invaluable to have a crash dump uh most of the time which production machines they will just reboot the machine uh uh and start producing again because well it's a production environment you need to uh create a product so it's really invaluable to have crash dumps so uh what we do is the crash Handler will write a file which contains all the necessary information to to analyze what happened at this crash so and then combining this with the symbol archive we can translate the the addresses which are just which are don't mention anything in the crash D itself uh and can be translated back to a full call stack with function names and so on something developer really uh needs of course needs to uh evaluate what what went wrong so I think there's a lot to learn here and uh we can certainly use some of the things in our uh loging framework so we'll keep most of it and uh as mentioned before the debugger knows all this information because it's based on the instruction pointer so what if instead of logging file uh function line and so on instead we just write instruction pointers that is the that was the idea I set out uh to work on this and uh uh I try to make this work so these instruction points are quite small so uh yeah and these afterwards if you uh receive the log file from the customer you can again use the symbol archive and the symbol information to translate it back into files lines and so on so this Lo minimal log as I have called it uh is very efficient in and in terms of space it's not a repeated string over and over again uh it's it's just a minimal information I think that's why this presentation is called minimal logging and it also avoids some of the risks that are typically uh present if you use normal text plain text logging and they are also similar to what we had with uh with the debug information there's an intellectual risk if you give away too much of the details of your software in a log file someone with enough time and enough uh knowledge can try to reverse engineer and see what is going on there so that's really something you want to avoid and also if you have would have have would have a developer which writes a really useful uh debugging line uh stating very clearly what is wrong and and what the results should be this might also give away some of the of the details uh which you don't want so by keeping all this information based on symbols which remain inside of your company you can really uh protect against that so with these instruction pointers alone there's not much you can do unless you start looking at the Assembly of course so uh this seems to seems to be promising let's have a look what we can do to retrieve this instruction pointer and uh what type are we going to give that well that's it's just another pointer uh so we can use the unsigned int pointer type for that which is the which clearly which uh is useful because because it matches your uh platform so 32bit or 64-bit it doesn't matter it will be the correct type so this makes it easy to write and then to get the instruction pointer actually that's a register in your CPU it's used all the time by the CPU so it's uh readily available and it can be accessed quite quickly uh so it requires some inline assembly uh which is dependent on the architecture you're working on but uh all in all it might look scary but it's just copying the data from an a regist register that is already accessed quite frequently uh into a variable and then returning this um compare this to um retrieving some string which is uh located in a totally different part of your binary it's it's a a different or a difference in in magnitude I think there's only one problem here with uh this uh approach and that is if you do it that way uh you will get an instruction pointer which is inside the instruction pointer function of course so that's not too helpful if you want to determine where this function was called so there starts our dance with the compiler to convince uh it to uh do the correct inlining and so on so if we attributed with an always in line in production code we will be guaranteed or uh uh it's very likely that this will be inlined and that we will get an instruction pointer at the location where this uh method is called uh this might seem a bit odd but uh you can compare it to the uh to Source location current where your compiler also already had to do uh some tricks to make sure that this is evaluated at the at the correct side because it's it's doing something in a method and it has to know where it was called so that's already something um special as well um a a first try I in in the first try I used uh the um compiler extension or the compiler method built in return address but that is not the the thing we want because that tells you where the code will return to after the function and not where it came from so in that sense in some cases you would end up with a wrong uh wrong uh address so how do we add this instruction pointer uh we can we can just take our record and add it in there it's very uh fairly easy to do that and then our Trace method just gets extended to not only query the current time but also take uh the instruction pointer at that point and of course here we again have the same issue if we do it like that we will always get the instruction pointer in the trace method which is not ideal so we have to do another request to the compiler to inline it so with that you can see that the second unit test already succeeded or passed and uh let's have a look at that test so we instantiate again a logger we call this Trace method and there ends our online part um afterwards we can collect the data again and verify that it is nothing more than just uh the size of our time representation and the size of our instruction pointer so in most cases this will just be 16 bytes and with that feeding it into our model uh which is aware of the symbol archive uh we can actually query or check that the records in there are valid and that the function name resolves to uh the name of the test function in this case so even with this limited amount of data using the symbols we can retrieve all the necessary information this also includes of course the the line and the number uh uh yeah the line and the function no the line and the file uh which is also of course uh can be derived by the instruction pointer so that's our second unit test let's have a look at the third one where we have uh an example of a simple nested case where we have a first function that does a trace then calls a second function which itself also uh uh adds the trace point and then we return and do the second Trace in the first function so the data that will come out of this is again just three times some represent representation of time and instruction pointer and if we look at the results if we would uh resolve it again in the same same fashion as before we get not the correct results and that is again another case where we have to convince the uh compiler not to inline all the things because well the code on left is so easy that if you turn on any optimizations it will just inline everything and yeah then your test is uh no longer uh interesting or doesn't work anymore so with that we already know where we have uh loged anything uh of course just knowing the location is a good start but we want to add some state some more information so and with that we can um move on to the third part the what and for that we can just extend the record to include uh additional arguments so while we have a record and a trace function we can easily create a templated uh record which has an additional um uh argument T here and make an overload of the trace function which will uh also accept an argument and then in the same fashion we will just construct the record and uh dump it to our circular buffer um um as I mentioned before uh you can't use this with any type of course if you pass it a string it will just log the the pointer which points to the string it will not uh copy the contents of course so that's a limitation but I think uh as mentioned before we should think twice before logging strings another clear advantage of this is uh that this is binary data so if you log a double uh to this uh in this way you will get the full double Precision there's no data loss there uh a while ago I did some tests and printed out uh the results with insufficient accuracy then I had to redo the entire test just after changing the format to include more digits in my end results so that was really embarrassing so that's something that can also be avoided here by just using the binary data and then you could actually do the formatting offline uh separate from the logging and independent of that so but now we get uh a data stream in our logger which is which can vary depending on the arguments that are logged so what is still missing is a way to identify the type of uh argument that was logged and there are several ways you could uh go about this uh you could use this some kind of uh name mangling scheme or some kind of uh structure which encodes this this information but I think I found a quite Nifty way of doing this and to get there we have to realize that actually this Trace method consists of two parts uh that's being the instruction getting the instruction pointer that's why we inline them this method and the remainder which just adds the record to the to the circular buffer so because this gets in lined there's no mention of of of the trace function so we lose all the information of the template that was present here so instead we can uh split it up in two parts so we have a outer Trace function which just uh does the instruction pointer bit and gets in lined so that it's it's really the call side of this Trace function and then we can add a second part uh a trace inner method uh which is not in lined and uh uh where we do the remainder of course this alone doesn't change anything but what we can do now and that's the one of the main tricks here is we can call this instruction pointer method again because once we get into this bottom function this Trace inner um we still know the the the type information of the template that was PA there so uh if we uh will be resolving this in second instruction pointer we will be able to see okay this uh was a trace call which was called with a Boolean this was called with an integer with a wait an an unsigned integer that's still wrong that's another surprise I came across uh during this adventure and um for that we have to realize that this uh this circular buffer append is is nothing more than just copying data so if we look at this Boolean that will be a record T which has uh one byte uh for the argument and the integer and unsigned integer will actually be both uh the same eight bytes uh for this data type so our clever compiler uh just saw unsigned in or unsigned in or int it doesn't matter for me the implementation and the remainder of what is done in this this aent method is uh uh irrelevant I will just reuse that so that's why we get twice uh resolve this uh to trace inner int instead of uh an unsigned so to counter that we're back to our dance with a compiler we have to ask it politely to not reuse the implementation of this function uh this really uh increased my um uh out for the compiler because I didn't expect the compiler to do that so by adding this used statement we now get we correctly resolve the the third one to be a trace call which was uh done with an unsigned integer so and that's actually the the hardest part of this uh talk um with that we actually uh fix all but one of our unit tests the last one is about multiple arguments so what we can do there is is of course the variadic template ex extension and extend our record t with something that looks like a a tupple and uh add some S's and some dots in the correct places uh to end up with a vartic template which can take an arbitrary amount of uh arguments the remainder of the codes code is the same uh we still use a second instruction pointer to encode the the data or the types of the data that uh were locked uh and all in all it's just uh pushing this data into the circular buffer it's really interesting to see the the resulting assembly uh if you look at this uh after the compiler optimized it because all these thing all these abstractions with the records and the topple and so on this all gets uh abstracted away or optimized away and it's really nice code it's taking the clock copying it taking some instruction pointers and copying it there's in in no case this record T is actually instantiated as such so also from a memory point of view it's really efficient so with that we can actually already summarize what I've called minimal logging so we've split logging up into two parts being the online part where we want to have a very performant logging framework which does not include any of the formatting overhead is very uh condensed so you can pack a lot of information into uh a single log file and it's also really memory efficient and an offline part where we can do all the the more expensive parts of the of the processing so we did this by uh creating a circular buffer which in it in itself just contains an integer representing the time an unsigned integer representing the location where the trace call was done and then also uh um a second instruction pointer in the function that in this Trace inner function which we will need later this is Then followed by one or more arguments which are just in binary data after your circular after the other data so once you're out of your uh performance critical uh part of the code you you could write this circular buffer to file and uh do an offline analysis with that so in there you can decode this data again to include actual time stamps in the time zones and the all the information and detail you want you can use the symbol information to retrieve the file line and function uh using the symbol information we can also uh get back the the types of the arguments that were passed to the trace function and with that we can decode the optional arguments so this actually already gives us all the information to write again a full text log but I think it's uh we should move on from purely text based logging to something else because once you have this in in a model you can present it in a much more uh more advanced way to in in some kind of viewer where you can do filtering where you can do change the formatting and so on so there's a lot of opportunities there to um work with the log files in a in a much easier way than then having to decode uh text based log files and with that we're uh through the slides so if there's any questions uh I I'll happily try to answer them um there's some bonus material if we would have if we have time that I can go through but uh I'll first open it for questions uh so the question is how do you evolve viewer and like how do you deal with old logs I understand that you have a set of types you support the cing which are like primitive types you never extend them with your like custom structures or something like this because I understand so when you get this like function pointer to the actual implementation you like take a function string and from there you get template parameter of a type that is actually decoded and then you do the string rendering or so that like my point is like how do you evolve this so let's say you add new structure to log and then it was not uh present in previous format or like vice versa like how does it how does it happen uh from the online part it doesn't change anything but indeed if you add custom types to your logging you will have to implement it also in the what I called here the log model to be be able to decode and and and do the interpretation of that data indeed so and second thing did you like look at the like uh projects like SPD log which are like doing the you know logging outside of hot path through well they use also like shared memory like just memory queue uh but do it uh in a second like in a logger thread just of loading it from a hot pass from the yes I I've saw that uh but I really wanted to focus on this instruction pointer and see with uh what was the fewest amount of information we could lock to still be able to retrieve all the details soon and the last the last question so couldn't you like use the variant and use one bite to encode type instead of function pointer of eight bytes for the you know just take the type index from a list uh to encode it which argument is supplied stuff like this that's also an possibility but I wanted to have something which is was really independent of the number of arguments ah right yeah and that's why I I right it's it's it's indeed eight bytes for to determine if it's an integer or bull is perhaps a lot but it extends quite nicely if you have more aggreement or more types but uh good question thank you yes thanks for the talk um first question do we have published a library somewhere where not yet no I plan on doing that but uh there's some uh other things at home that uh with a recent daughter but yeah that's surely a plan so if you're interested in that please drop me a line and I will uh uh notify you when this is available in GitHub or anything yeah okay second question is going a bit deeper if you use the instruction pointer are you not getting trouble with address randomization so if your binary is loaded by the operating system it will get a random address and I would guess the instruction pointer will only give you the random address which is not enough to decipher the Deb information I guess Yes actually you need to load you need in indeed need to know the load address of your binaries so you also have to I didn't mention this here because this goes perhaps in too much detail but you also need to know the relative address to where you were loaded this is the same if you would want to support shared libraries and so on for each of the binaries you need to know the load address because also the symbol information is always relative to the load address so that's that's some additional information of course you need but uh as this is mostly bookkeeping I uh try to minimize this in the this talk but indeed that's surely the case thank you thank you for the talk it's very clever I notice when you call the get instruction pointer a second time to indirectly get with kinds of arguments with you're logging have you experimented with instead passing in the address of the trace in a member function that you are calling I have not that's a good idea that's something I could try yeah thank you um yeah hi uh thanks for your talk was very informative um you showed the timings in the beginning and I was wondering have you considered consider the effects of logging to file versus logging to standard out versus maybe just logging to some UI widget in there or do you know how much of it would affect there that's a good question and that's the reason I didn't put any numbers on that slide uh I just wanted to give some hand waving uh idea of the the the scale of things and uh the amount of time that is taken by uh some of the loging but indeed uh writing to a file or writing to a a standard out might give different results but that's something uh and the second point that I had was you were now trying to remove as you put on your slide trying to remove all the verbosity from your logs you might have in an application like industrial Machining you want to show some kind of lock information also to a user on screen or in a in a command line output I don't know object XY is broken please replace or whatever um would you split this then off into a separate logging mechanism or how would this interfere or not interfere with this because I guess yes for debug logs this makes a whole lot of sense but for user logs you want to keep the verbosity to kind of tell them what what's there yes this is really intended for logging which only is relevant for Developers so if you want you still need to provide sufficient feedback of course for your operators so that they don't uh that they know still know what is going on because U that's indeed then I would uh split it up in user logging and developer logging and and handle these separately so uh even though the user logging might then be slightly slower or uh it it might still give sufficient feedback yeah indeed okay thanks thank you hi so I had a question regarding the inline and no inline uh attributes that we used so if I understood it correctly if I understand it correctly the compiler can just like choose to ignore those as well and do UNL lining when it shouldn't and don't not do un lining when we ask it to so do you have any strategies to at least like detect that or how to handle that because we might not notice it when we are compiling the code and much later when we see the logs it might become a bit like yeah that's that's a very good point indeed the it's you it's you ask the compiler politely to do this but it's sure not not guaranteed uh that's why I have unit test because I run them with the same compiler in the same environment as uh uh my production code would be and there I didn't detect any of these things but uh so then you'll have to write unit test for this for every function you are trying to use it for right because it might the unit test might work for this function the one you wrote in the unit test but in the real world the production code that part might be in lined or not inlined right yeah that's that's true but then again if you're logging in something that gets inlined perhaps yeah yeah indeed that's that's that's a fair point it's something it would be nice if if we could detect that or uh at least get a warning if the compiler didn't inline it even though we asked that's and yeah on the same note like so we are telling the compiler to not inline something which might affect performance as well right yes okay but then we have to kind of be just aware I asked it not to in line uh in the in the unit test just to get a with the with the nested functions just to get a simple example yeah you wouldn't do this in production code because in production code then you'll have to use no in line everywhere right wherever you want to measure this because otherwise if it inline that function then your instructor pointer would be just pointing to a different function yes inde so essentially every line like everything you need in your code now will need to be no in line right unoptimized unoptimized essentially which is yeah yeah that's not ideal indeed okay that's a good point I should think about how we can yeah okay thank you thank you yeah actually my question was very similar so I did something uh similar before also and in my experience the aggressive inlining makes a problem there so from what I understood is you just lock the information there is a Bool and it's like true and it's crucial to find the code place mhm to make sense out of it right yeah and so when the compiler is inlining actually this function which is logging then you will get it just somewhere else so yeah you multiple things on the same line so the the the optimization basically spoils it a bit so as he said you would have to make it only sensible in an unoptimized build and that's not production yeah that's something in a in a in a bigger context I didn't think about yet or have have no sufficient experience it yet so that's a yeah okay thank you maybe there's still time to add show some of my bonus slides um there's one nice advantage of having a um of of doing this uh logging this way is uh well we if we have to look back at the crash dum uh workflow uh because the crash dump already contains your stack um to be able to uh reproduce the call stack by walking the stack frames it actually also contains the the lock up to that crash so from your crash dump you can with some tricks retrieve the circular buffer which was used to store the logging information so with that you could end up with the exact uh uh logging which is present up to that point so that's a nice thing also what I thought about for future extensions is uh working with literals because if your program is full of uh logging fixed strings there's no point in doing that it's just wasting space so if there would be a way to detect these literals you could actually not log them and then have tooling which uh in the offline phase just reads them uh and uh add as the literals again so that way you can save in the log size by not logging the things which are just clearly present in the code and uh don't need to be um logged the third slide I I still have here is about uh shared librar so that was the question before uh symbols are always relative to the load address so you can uh that's also something that you have to take into into account and you can just uh use the the the the the load address to figure out these things uh and that's the same way as crash Dums do it they just store the load address for each of the binaries so it can be determined okay this instruction pointer is in this range so it belongs to this binary um and then the last thing I'm going to mention is that uh this also this logging way of logging also gives you information about the version of your software um uh this can be done in the same way again as crash Dums uh there you also store some kind of built ID of your binaries so because this is used for storing your symbols and uh matching those you can uh also again find out which version of your software uh was used for the logging now it's sometimes difficult to find out especially if machines are running for a very long time to find which version was this again uh so that's also an advantage because the symbols have to match the the the log file you can that way also uh determine which version this was so that's based on this uh built ID which is built in okay with that I'd like to thank you for coming to my talk and I hope you have a great conference thank you