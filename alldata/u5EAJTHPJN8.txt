and welcome to this talk about design patterns facts and misconceptions so not everybody knows who i am so allow me to quickly introduce myself my name is claus and i'm actually doing c plus trainings for a living i know it does not sound like a very exciting job but i kind of like it it's interesting you meet a lot of new people also it's online nowadays and also you see a lot of code learn from code discuss code and i feel this is pretty interesting it's not apparently enough c plus just for me i'm also writing c plus first on our own so i'm an author of the blaze bluster's math library and i'm actually organizing a competing user group now of course it's a friendly user group that one in munich now for tonight i'm talking about software design and design patterns and this is something that i've now started a while ago i was arguing that there is not enough talks about software design and as is for instance something i also mentioned in an interview a cpp chat interview a couple of weeks ago so both me and tony von erich were invited by phil nash and john kulp to talk about the solid principles this was actually a really fun discussion and we exchanged a lot of experiences about software design at the end of this episode i raised the question why actually don't we talk about software design perhaps not anymore perhaps we never have and interestingly both tony and john confirmed my suspicion both of them say because it's the hard thing because there is no definitive answers it's easy to talk about features to explain something that will always work but to talk about soft design that is really hard there's no true answer there's always answers like it depends and i believe this is why we don't talk about this although i feel this is really interesting and also really important this is the fundamental things for our code this is what helps us to maintain it for decades so i believe he should talk more about it and this is now exactly what i want to do tonight so let's talk about software design and design patterns which however is as i said the hard part so right in the beginning to make it clear the disclaimer of course as soon as we are talking about something there's no definitive answers there's a lot of subjective impressions and opinions and i definitely will raise a couple of opinions on my own and it's actually absolutely okay if you have a different opinion actually i feel this is just fine this is what i would like to learn about because i believe then i might have missed something interesting and so there is no definitive answers it depends but perhaps that is the reason why it's also fun and really interesting i know i have actually quite i have hours to talk about when we talk about design patterns and i have definitely also always to talk about misconceptions about design patterns and software design in general now i had to select a couple of things for a 60-minute talk and so i selected something that i feel is simple enough but also interesting enough to talk about and so i start with an example stood make unique simply because in the past couple of years i've heard so many statements about make unique that i actually feel it's necessary to actually talk about these so i've heard that make unique improves exception safety okay i've heard that the make unique function fulfills the single responsibility principle and i've also heard the statement that make unique is a factory function now i want to talk about these statements before then of course digging a little deeper and also talk about other things and the first statement is something that i believe you don't have to say a lot about because indeed this is absolutely true make unique improves exception safety in the sense that it's like an atomic operation you immediately create a unique pointer the resource is immediately coupled to that it's one operation only perfect so this is definitely true i don't really have to say a lot about this anymore the second one however is by far more interesting so the claim is that make unique because it is like an atomic operation and improves exception safety fulfills this single responsibility principle well if you go to wikipedia read about the single responsibility principle this is what it actually has to say the single responsibility principle is a computer programming principle that states that every module class or function in a computer program should have responsibility over a single part of the program's functionality and it should encapsulate that part all of the module class or function services should be nearly aligned with that responsibility this is what a lot of people know but interestingly what people make out of that is that everything should do just one thing this is by the way also why a lot of people criticize this principle because it's so vague it doesn't really have any meaning it's like you understand it but don't know what to do the problem is this is exactly not what it is talking about actually it is talking about something different which i basically summarized just as a hint in a pointer to talk at cpb con the single responsibility principle advice is to separate concerns to isolate and simplify change and that actually already has to do with software design when we design software we are actually interested in changing things easily or also extending things easily that is the goal of software design at least one of the important goals and i know if you can again go to wikipedia look at software design try to get impression what it does it's kind of hard because this page sums up so many different aspects of software design it's really tough to really understand what it's about so i try now to simplify it i give you my opinion on what software design is and hopefully kind of a simple statement software design is the art of managing inter dependencies between software components it aims at minimizing technical dependencies and introduces the necessary abstractions and possibly compromises there's a couple of pretty important words in there from my point of view it's an art it's not a science it's not something where you definitely always have an answer it's the best you can do sometimes therefore also compromises sometimes there is just not the possible solution and you probably have to choose something that fits it best right now where you might not know all about it but most importantly i believe that software design is the art of managing dependencies and abstractions this is at the core of software design this is what we actually want to do in order to be able to change things easily and extend things easily which now brings us back to make unique so that's the stood make unique function and if you're not actually thinking about this in terms of software design then you do find that it's not really abstracting anything it has nothing to do with dependencies or either mecanique will always give you t whatever this t is and it will always allocate by means of new always so there's indeed no abstraction at all because there's no abstraction at all it definitely has nothing to do with software design nothing at all and so it also has nothing to do with any kind of design principle that gives you advice to isolate concerns there's nothing about this function it would help me to detangle entities in my software so i definitely like not do not like the idea that this fulfills the single responsibility principle it's just a function however perhaps to make the circle to design let's consider the following let's say that actually because this is good advice we use make unique throughout our code so it's a large piece of code we have let's say thousands of make unique calls scattered throughout the entire code and we're actually pretty proud about this because of course it does a good job but it probably encapsulates creating a t but now imagine that you actually realize that new does not really give you everything you want your process is now running very very long you use make unique quite a lot of times and you can actually measure that the fragmentation in your memory is growing and at some point there may be a crash because there might not be enough memory left so you now decide that you don't want to use new anymore you would like to use anything different so there is actually frameworks like tbb that provide you some allocation scheme that works better in terms of fragmentation how do you do that how do you switch from new to any other kind of allocation and you might realize this is actually a pretty tough job actually software design is supposed to make things easy to change but now that i've spread make unique all over my code actually it's kind of hard to change i have to change all these places where i use make unique so what about if you actually wrap it in a function like this one say create create take some arguments just like make unique internally does nothing but call make unique and return something but actually does not return a unit pointer visibly obviously it returns something so now if you use make this this create function then you actually don't know really what you get you'll probably just use an auto you know it's a pointer okay everything's fine but you just get something now if you decide that actually you don't want to use new anymore you can change the code in one and exactly one place you'd adapt create you don't use make unique anymore but you might now return a unique pointer that has a different deleter and suddenly you've designed something you've abstracted from new you've created inserted some kind of abstraction it allows you to change your code in one and exactly one place so just to be sure or to be clear it's not against make unique but really it has nothing to do with software design it has nothing it gives me not not anything in terms of dependencies managing dependencies and abstractions all right so i just don't think this is true at all it has nothing to do with that which brings us to the next statement make unique is a factory function that one is actually a very difficult term a very very overloaded term that for instance is used in core guidelines now i picked one the c50 use a factory function if you need virtual behavior during initialization so just quickly to briefly to point out what the advice is if you call a constructor in that constructor you should not call a virtual function it might not do the right thing the object is not properly initialized yet so what you should do is you should write some kind of wrapper that first of all creates the object potentially by make unique then you call a virtual init function and then you return so that call here that is happening after the object is fully constructed and this entire setup that you have a function that is what the core guidelines call factory function and well the make unique is a factory function just as well right well again i'm using wikipedia for help a little bit so factory object oriented programming that is the article this describes something about design patterns true there's a link to the factory method design pattern but this is not generally idea of a factory interestingly they actually make a very very clear distinction in this terminology paragraph so some sources rapidly the concept as the factory pattern well that is considered the concept itself a programming idiom the general concept of the factory is often confused with a specific factory method design pattern so indeed the term factory is something that we use for a lot of things sometimes we just mean it creates something sometimes we mean it actually wraps the construction of something it's a heavily overloaded term indeed now let's explain what actually is a design pattern and where in the in the realm of software development this is placed so i would argue in the center is software design software design is managing dependencies between things but usually the smaller things so this is also something that we usually can change a little easier and this is where design patterns come into play solutions how we can detangle software entities by different way in different ways by means of different strategies and of course this is where a couple of well-known design patterns come in visitor strategy observer all design patterns that you find in this pretty well known book in 1994 design patterns book which we because of the four authors just refer to as the gang of four book so the goth patterns above design there's architecture architecture is about the big things connection between bigger things like modules perhaps entire larger components and usually that is the stuff that is much much harder to change much harder because it's the big decisions that everything else builds on in this case usually we talk about architectural patterns so client server architecture microservices you might have heard about the model view controller and different ones there's books that talk about these too but they also sometimes talk about the small things so it's kind of a novel app so martin fowler's book and also this one they actually give architectural but also a couple of design patterns now below design is the implementation details the details that we need to properly implement the design so how do we implement one of these design patterns how exactly by means of features and there is implement implementation patterns also all the things that we see again and again that repeat therefore patterns but that are just concerned about well implementation details but there's one more thing perhaps this is also a little confusing those idioms and idioms sometimes actually are in the realm of design and sometimes they're in the realm of implementation details so for instance you might have heard about the nvi the non-virtual interface idiom which actually is design because it has to deal with what to do with dependencies tearing things apart detangling things and it is based on the idea of the template method design pattern described in this golf book you might have also heard about the pimple idiom which is the simplest of all cases of possible cases of the bridge design pattern also something that manages dependencies or reduces dependencies but there's many many idioms that are actually in the realm of implementation details like for instance the temporary swab idiom this is pretty a clever thing for for instance a copy assignment operator but it's not detangling anything the right idiom it's about automating destruction it's not detangling enable if something that you see again and again which of course however is more about implementation details or perhaps my opinion factory functions now just as a side note the right idiom i now place this in the realm of implementation details perhaps you have a different idea a different understanding for this is perhaps you're more along wikipedia again software design patterns the page that lists a lot of these patterns and if you go to the creational patterns actually what do we find resource acquisition is initialization ri so it is described as a design pattern as i said before i feel this is strange perhaps it is true for other languages but for c plus plus this has nothing to do with dependencies it has nothing to do with abstraction it is automation i would not list it here as a design pattern i would list this as an implementation pattern but also there's more singleton or also multiton multitanya um i don't feel this is design patterns and especially with singleton you actually might agree because you realize this is not detangling it is entangling it creates dependencies just to give one more example there's also one more golf pattern that i feel is just an implementation detail not really about design that is memento which is one so there's only two of 23 design patterns in a golf book that do not use inheritance and that is one of them in other words there's a lot to discuss there's a lot to think about apparently there is a lot of different ideas different impressions which however raises the question then what exactly is the design pattern well i had to pick the one from the gengar 4 book which of course has to do with factory the factory method design pattern now from my point of view this is indeed a design pattern so i assume that you're not all totally familiar with the idea so very quick there is some creator it creates some kind of products both of these are base classes and can be implemented in form of concrete products and concrete creators now why is this a design pattern and other things or not because in this particular case i can actually separate concerns in terms of an architectural dependency i can assign some things to some high level something that is not changing something that is considered to be stable and i can also assign the implementation details to something that i consider to be the low level it's volatile malleable things are changing much more often i cannot rely on these details so much and so of course in a high level i don't want to deal with all these details i want an abstraction of that and i get this in this particular case which is kind of classic guff by means of a base class it really deals with dependencies it deals with abstraction and that's even an inversion of dependencies simply because i actually have a clear structure from low type of height dependency from low level to high level that is an architecture that is what i expect to see in design everything else is not really designed so to make it clear the purpose of a design pattern is to introduce a fitting abstraction for a well-known problem and along with this abstraction comes a name the name of the design pattern conveys the intent of the abstraction and so a design pattern actually the name of the design is really important this is what enables you to talk about your intent i am using a factory method here actually because i want to okay now people actually should already know what you're trying to do sure you want to abstract from creation and from products that is conveyed by the name alone and this did make unique it's not really something that provides an abstraction so i write this as an implementation pattern not a design pattern it repeats again and again but it's only in the level of implementation details so to summarize yeah make unique is in the terminology that you're using a factory function but it's unfortunate that this term is so heavily overloaded can mean so many things so just to be clear making is a factory function yes but it is not a design pattern factory method design pattern that is a design pattern but that comes with a lot of abstraction okay but i believe it's enough no more hitting on make unique i think you've taken a point let's take it take a look at a couple of other misconceptions misconceptions that i heard a couple of times in the last month like design patterns are limited to runtime polymorphism and then obviously also design patterns are limited to object-oriented programming design patterns are language specific idioms in particular something that i hear a lot about the golf patterns and design patterns can be recognized by their structure i would like to talk about all of these but not by giving multiple examples but perhaps one example is actually sufficient perhaps let's say two i pick out two design patterns and take a look at these and the first design pattern again a game of four design pattern because they are usually more well known one design but yes all right i have now picked the classic command design pattern which on the right hand side creates some kind of abstraction so you get some base class called command and you can of course now implement this in various ways at some point you have an invoker that just knows about this abstraction and this invoker may eventually execute the command and a concrete command now creates some kind of feedback something happens some action okay now the mouse point is back in the middle okay this seems to be the the logitech thing i apologize so it seems to be part of the of this clicker here now that design pattern comes with inheritance and of course if you see that all of these are about a dynamic polymorphism and object-oriented programming so this is kind of to be assumed but i can actually show you also examples from the standard library we can actually use the command design pattern for static polymorphism if we provide some operation as a template parameter and then pass it to some function why do you find this in the standard library yes in the algorithms for instance for each you pass of course a range of say numbers but then you also pass an action please do that to all the elements i would argue this is the command design pattern again it's the same intent i want to do the same thing so it appears in templates it's not object-oriented it's generic or perhaps even functional programming so apparently this actually is available in different forms too i have a second example a so-called strategy design pattern which is also quite easy to to summarize give some context on the left hand side with some functionality that of course now carries implementation details now these details may actually cause coupling sometimes heavy coupling and for that reason you would like to extract all of the logic here somewhere else to loosen the coupling and also to of course provide flexibility if possible even run time flexibility now what i introduce now on the right hand side is a strategy that strategy can be implemented in various forms the king of four just calls them concrete strategy a and b and now this context just gets a point of strategy for that i've already extracted the implementation details also this design pattern comes obviously with inheritance also this design pattern actually has to do with runtime polymorphism but also here i can actually show you examples from the standard library we could for instance provide a template parameter pass it and again use this in form of an algorithm like accumulate stood accumulate say gets a num couple of numbers i start with 0 and i'm gonna provide some action that needs to be done wait a second didn't i just say this is the command design pattern okay so that definitely is perhaps worth to talk about briefly because it depends as all the answers in um software design apparently start if you take a look at these two structurally they are virtually identical i don't see a difference between these two except for the names but structurally no difference and also if i see these algorithms for each or accumulate and then take a look at this template argument that is the action there's no difference so what exactly then is command and what exactly is strategy really interesting question which unfortunately is not easily answered by the gang of four book itself because all it has to say about command is encapsulate request as an object thereby letting you parameterize clients with different requests cure log operations and support undo operations that's the short form of course there's an entire chapter about this and the strategy design pattern define a family of algorithms encapsulate each one and make them interchangeable strategy lets the algorithm vary independently from clients that use it now from that description you would tend to say well then everything is strategy because it mentions algorithms it's not that easy i believe there's actually a nice thing that can do you can of course use your favorite search engine and type in command versus strategy pattern i actually find quite a number of pretty interesting explanations and i'm gonna picked one that i believe actually hits the nail this is what i believe is is pretty accurate typically the command pattern is used to make an object out of what needs to be done the strategy pattern on the other hand is used to specify how something should be done now i totally agree this is kind of a very subtle difference but actually this is what these what the difference between the two is it's not the structure it's the intent so specify what should be done and you have a command pattern specify how something should be done you actually have a strategy and the same thing the same intent also applies to these algorithms what should i do with each element in forage well this is a command and how should i accumulate the elements in accumulate well i believe this is a strategy so the takeaway is the intent of the command design pattern is to specify what should be done and the intent of the strategy design pattern is to specify how something should be done but most importantly remember that the difference between design patterns is not the structure it's the intent it's what you want to do it's what you want to convey as a message i'm trying to achieve that goal the intent all of these 23 golf design patterns have some intent and that is the one thing that you really need to remember and so also hopefully in these examples you realize design patterns are neither limited to object-oriented programming no dynamic polymorphism they can be used for functional generic programming just as well and static polymorphism of course too they're universally applicable because the intent is always present you always want to solve a particular problem now just as a last perhaps idea consider to include the name of the sign pattern into the class name to help convey the intent that actually would have been a nice move but of course the stl and the golf book appeared kind of in the same year so in 1994 the book appeared and in 1994 the stl was voted into the standard library but it would have been nice if instead of naming for for each this junior function and for accumulate instead of naming it binary reparation we could have perhaps named this unary command and binary strategy perhaps this would have clarified a couple of things i don't know it's a guess definitely it would have made a direct relation to some kind of design pattern so i don't think that design patterns are limited to either paradigm to any uh dynamic or static polymorphism i believe they're pretty universally applicable however there's a couple of more further misconceptions about design patterns something that also i find a little troubling sometimes and that is the design patterns are outdated nobody needs them anymore and the design patterns have become completely obsolete we don't need to design anymore sometimes this truly is a little troubling and so now i try to prove that it's exactly the opposite they are just as important as they ever have been and i'm trying to actually do this in form of a live coding session yeah live coding now this is of course the part where everything will fail where everything will not work anymore and definitely for me it's the hardest part but perhaps it's a little fun too however let's agree on one thing it's not about the implementation details i will skip so many details i will focus entirely on design decisions and that actually may be the thing to take away from this little thing and now our task is to actually provide an abstraction for callables in the following example so i have some function f that takes some call like i'll call this fn short for function of course and i would like to actually abstract from this because the implementation details should no longer be in the header file i want to have a runtime abstraction all right so that is the task and now of course some of you have a very simple answer that doesn't count yet let's do something on the about this on our own not because we want because we need because we want to the first idea is to provide an abstraction quite simple so let's introduce a func base this is not a beautiful name but it definitely is a base class virtual func base func base equal default of everything that i get unlike this lambda here in the application would actually derive from that lit thing oh it would be so easy but of course lambda will not inherit from that base class which means i just create the right class on my own i call this class yes and you destruct no difference funk impul i know again clever name but this funk impulse definitely is a funk bass that little fella is supposed to store whatever i pass well it could be a lambda it could be a function object or perhaps just a function pointer but it stores some function thing but in order to make this work that little fella here needs to be a template i have now created an abstraction believe it or not and actually i have used the design pattern here i've just created a design pattern based on or have used the design pattern and this is called external polymorphism it's fine pattern and yes this is not one of the gang of four this is actually something that was released tonight published in 1996. it's a little younger two years younger but it's a little different if you now believe this is an adapter very close indeed but the adapter design pattern has to do with an existing hierarchy i'm now introducing a new one so it's that design pattern now of course i do have an abstraction i could now finally say that this is a func base going to reference i don't care at this point i could actually move all of this into the source file detangling dependencies i no longer depend on on a lot of things i kind of hide implementation details cool of course you now have to adapt a couple of things like how do i call it well sure um you cannot really use it call it at this point but for that reason we now introduce a virtual function what i call invoke why not at this point i'm do a little hand waving distract you from the fact that we i now introduce a couple of types that are not known maybe we'll get them soon enough so this invoke returns an r some return type and also gets a bunch of arguments called arcs function can be const why not at least one important implementation detail and to be a virtual function that fella now of course needs to be implemented in the driving class which something's important i make final and i implement this as return fn off arcs yeah i know i can move forward etc i don't care about these details now i'm actually able to probably invoke the thing down here invoke cool very nice now the only thing is of course that i have to adapt my main function where i pass the lambda because the lambda is not inheriting from that thing of course that doesn't work anymore so it's the easy thing say make unique so we try to create some kind of pointer that holds that of course and that is given the lambda and i get of course some good unique unique gender of funk bass something like that could call it fn whatever um okay and i could be reference fn at this point not so important more important is that point here which type do you actually have to pass here so funky impul okay true but of what that is tough and very unnice i would like to automate this i would like to deduce the type for that i could use a function true but i could perhaps wrap this entire stuff anyway because i actually do not really like the idea to carry a point around so let's do the following we just wrap this properly struct callable okay now this i make a class there's some public stuff come on public and some private stuff i feel like these trucks here this is look like private stuff so i keep it here in private section and also i probably now can use a unique pointer right here a unique pointer to a func base so the thing that i tried in the main function is not properly encapsulated at this point and i give it a name some of you might already have an idea you're correct i call this a pimple yes i've just used another design pattern this is first of all the pimple idiom yes of course but that is the simplest form of the bridge design pattern trying to hide some implementation details and most fascinatingly now the implementation details are generated by the compiler okay i have a pimple which i now need of course to initialize in my constructor into some constructor callable that one takes a say um well anything so i call this fn this function get this constructor a template this takes anything it even takes lambdas it reduces the type and that function now knows full well what i need my pimple meaning my unique pointer let me scroll down here so my pimple is now initialized by make unique off import fn i simply pass my fn here i've now created something that takes some fn something initializes the according class in that constructor and still have an abstraction a runtime abstraction to be sure pretty cool pretty nice the next thing however in order to make it useful for my may function is that of course i need to be able to call it right now there is there's nothing that i can do with it i can just create it but obviously the next step is function call operator that one now returns again my r again a little hand waving and also takes a couple of arguments some things well how do we implement this function call operator well i have everything in place already i can simply return whatever pimple invoke returns of course i'm yes i know forward a couple of arguments cool because now i already have the right opportunity to introduce all of these unknown types template type nmr type name dot dot args we are actually homing in on something really interesting this thing is now something that i can already use so like here in this at this point i would have a callable off say so this is sprinting some number so i return void and i take an int and of course the same thing appears here callable void wait comma int and here at this point i can actually i should not get rid of my lambda i can actually make this work in this way callable and i pass my callable not bad in just a few lines of code picking a couple of design patterns i've created runtime abstraction that actually turns out to be quite quite nice and useful now of course there's a couple of critics out there that basically point out no it's not complete yet and i totally agree it's nice it's short but if i use we use it in the way uh down as i indicated on there actually we need to copy it and right now that thing is not really copyable so perhaps it's time to actually think about the special member functions i believe since you're experts this is this is something that you know that call so of course the first thing we think about is the destructor which is default i have a unique powder that one that thing will take care of all the rest i don't need to delete anything on my own great the next thing it's kind of simple as you know is move callable let's give it a name we don't even need to because we can default it uniq pointer is doing all that work for me i can move forward i can move construct it perfectly and last but not least the move assignment operator is actually also working perfectly indeed the only two functions that give me a little trouble and a little headache is the copy operations so in other words a copy constructor and of course the copy assignment operator these two are a little mean because a unique pointer cannot be copied and indeed if i now want to copy construct a callable what should i copy all i have is a pointer to base well i think it's time again for a design pattern and yes if you want to create a copy from some abstract thing sounds like a base there is just the right design pattern to do that and that is correct prototype design pattern again one of these gang of four design patterns that allows you to copy anything so this thing in the c plus 11 way returns a unique pointer to a func base force is now implemented in the deriving class sure it has to it's a virtual function so i've make this final just because it's the right thing to do especially in this context and i implement this clone function that downloads exactly what needs to be copied as return stood make unique of funkimpo and how's myself use a copy constructor by means of this design pattern i'm now actually able to copy very very easily my pimple is initialized i other not pimple so i use the pimple of the other thing and i call clone please give me a copy it will work and since we're here we now also very very easily implement the copy 7 operator well no not by design pattern but by means of an idiom a temporary swap idiom now what do we do we create a temporary callable let's call it temp it's temporary by means of this other thing we'll call the copy constructor which does all the cloning etc and once you've done that actually we are in a very nice position to simply swap the pimples the unit pointers you can return i believe that's it now sure i might have formatted it a little unfortunately but this is like 40 45 lines of code but i've created a very very convenient abstraction now we're not quite done yet i totally agree first of all because probably most of you know what i've just done yeah sure if i now rename that suddenly it may make a little more sense let's call this function oh yes in just 45 lines we've implemented a very very simple form of function this fn and this fn2 in just 45 lines i've implemented a very very rudimentary form of std function that's just perhaps one tiny detail that is not really working out well but this is again an implementation detail still i like to fix tape because standard function takes a single argument kind of looks like that template type mfn class function that is the signature of stood function it doesn't take many arguments is i'm very very close in actually making this work let's use this as a specialization and voila actually done the job now i totally agree that this may have been a little fast a little fast indeed but the major takeaway is the following i've implemented in let's say 50 lines of code a simple form of standard function but not by just moving along and plowing away using my own details but by just using design patterns three of them and one idiom so four things that are commonly known that by using the right names and a couple of comments are actually known to other people as well and yes what i've just implemented is type erasure i have implemented the same thing that you might have seen in the talk probably the most famous talk about this inheritance is the base class of evil and probably this is what jean-pierre might have felt if he implemented that he did nude life but he was also plowing through the implantation really really quick so this is the talk that usually people attribute to inventing type erasure not quite not quite if you do some research actually there is something else there is a paper from 2000 called valid conversions written by kevin henney and to my best knowledge this is the very first time that this technique was actually used and he implements stood any not thus to any but a very simple form but still student and he bases his implementation on the aforementioned external polymorphism paper so clelen schmidt and harrison have come up with this idea and again the paper starts with intent a design pattern is about an intent creating something i'm going to show how this intent can be implemented in old c plus plus so type erasure one side remark that i just do because um indeed um i have heard also a lot here there's a very nice website that i can recommend more c plus plus idioms and of course they also talk about type erasure unfortunately they talk about it as variant boost any stood any seriously unfortunate seriously unfortunate even in in other cases i actually had to counter argue that this is very very bad stood variant is fundamentally different from a design perspective if you use a variant you want to extend operations not types if you use type erasure on the other hand you want to add types not operations and so if you truly want names to convey meaning and message we actually should be sure what we are talking about so perhaps just as a side remark but please consider to use type ratio if you actually mean the type erasure that i've just implemented that allows me to add different types lambdas function objects whatever i can't can only call it though i cannot add operations that is a java variant very very very different in terms of design indeed so the major takeaways though i'll use type eraser if your intent is to abstract for many possible types assuming a fixed set of operations then definitely design patterns are not outdated they're not obsolete either we use them even in our most recent designs like type erration they're everywhere so design patterns everywhere learn to recognize them and use according names to communicate your intent and this is now the point where i truly say well i shamelessly um highlight a couple of upcoming training classes i know this is pretty bad but still this is kind of what i live from the first thing that i can recommend if you want to learn more about design patterns if you want to recognize them in many ways in many situations and also if you want to learn how to use them then there's a one day workshop next monday at the adc plus plus modern c plus was design patterns it's probably in german but um you still can learn a lot about different design patterns and it's one day only though something similar is happening at um cpp on c i'll again give a short course workshop on modern c plus plus design patterns also here you will learn about design patterns in general how to use them how to recognize them but also what the mean also what is type ratio in comparison to variant that will be a major topic and jen's already mentioned that the three-day version if you really want to learn a lot and if you also want to discuss things like singletons factories decorators of service and the like then this is the place to be the workshop to be in so a three-day workshop on modern c plus was design patterns at um beginning of june three days that's a lot but definitely you will take away a lot of information okay that's the end of the advertisement my summary design patterns are about dependencies and abstractions that is what they are that is the major point you want to detangle yourself to entities they're about intent you have something to do the name now makes this possible you communicate your intent they're definitely not limited to object-oriented programming i know the golf book is strict about object during programming but all these intents can be transformed into solutions that work for other things as well and also so that along with it it's not limited to dynamic polymorphism static polymorphism just works as well i do not think that they are outdated or obsolete i believe they're everywhere even today in our most recent designs okay with it i'm i'm done thank you much for attention hopefully this was something that makes you now consider to think about it and perhaps also to contribute your own ideas your own opinions about design patterns soft design in general and perhaps a couple of solutions about the heart problems things like singleton okay thank you very much