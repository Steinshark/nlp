Hello everyone, welcome to Bevy Basics, Game start learning Bevy, I'd like to give you some this course. I'm a former Googler and a my wife and I made the decision to leave big tech call our own. Since then, we have been working developed entirely using Bevy. While the game is we feel like we've learned a lot and want to The goal of this series is to give you practical game development skills. This but you'll get the most out of it if Rust Programming Language. There's no need and none is assumed. In terms of code references, in the description, so that you can go browse the With that said, I really hope you enjoy the videos to come. In today's video, we're going to give you an introduction to Bevy, explaining what game development in Rust. Next, we'll talk about from traditional object-oriented programming, we'll dive into the internals of Bevy ECS. We'll see how Bev's app struct ties all those things So, what exactly is Bevy? Described by its data-driven game engine built in Rust. Rust While Rust has a reputation for a steep learning It reduces the amount of friction you encounter concentrate on coding. Furthermore, despite its entire categories of bugs and issues, resulting in Bevy is built on a strong ECS foundation. Bevy or ECS for short, a design pattern aimed at This is one way where Bevy stands out. While Unreal that have built ECS frameworks on top designed with ECS as its foundational Bevy is very quickly rising in Bevy has amassed 25,000 GitHub stars, showcasing it has over 800,000 downloads Discord community of 14,000 users. Bevy is and proving that it is on a path to becoming Now, let's get into the basics of ECS, or Entity compare to the more common object-oriented you might have a class for a spaceship with together. An update position method might by accessing the class's fields. In contrast, into different parts. There's three things: are just unique IDs or references that they connect all the components together to make are just pure data structures, like the position then, are just functions that operate on So in ECS, our spaceship would be an entity, and that that entity consists of. A system would and velocity components. In this case, we can see updates the position based on the velocity. data is stored in components, and behavior is between the update position function and the Instead, the spaceship is just an entity that has In object-oriented programming, the update spaceship class. In other words, the behavior the class. To reiterate, ECS stands out for and potential for parallel execution to game ECS allows you to write systems that operate on easier to manage. This separation of concerns more maintainable, but also gives you the ability in ECS can run in parallel as long as they resulting in a significant boost in performance, Now that you understand the basics let's talk specifically about Bevy ECS and its in-memory database. Rows are entities; columns are world is the name of the data structure all the entities and components in your world data structure is very uncommon in Bevy. which are abstractions that allow So let's learn more about how you can spawn a safe, efficient, and deferred way to modify despawning, and adding components to entities. components, enabling data retrieval and mutation for example, is as simple as calling all the components that you want that entity to You define the type signature in your system of we have a query with two components, velocity and a form of dependency injection to automatically In other words, this means you don't have to make direct calls to these functions. Instead, systems and providing them with the appropriate Before we move on, let's better understand for interacting with entities and components. the components and not the underlying entity unless two systems both query the same is mutable. In other words, if you have multiple systems that want to read position parallel. Commands, on the other hand, require applied in parallel. When you call methods if you call commands.spawn in one of your systems, Commands are automatically executed by Bevy when systems have run and Bevy's schedule can execute In summary, queries and commands are with the Bevy ECS storage layer, or world, systems to run in parallel while reading or systems to run in parallel by deferring the exclusive world access. As you can see, When developing games in Bevy, you will use You might be wondering how we actually execute we haven't talked about what goes in the main The App struct ties together all the elements of holds your game's data, the schedule, and the list of systems and the order in which they the application's event loop. Each frame, it internal systems and the systems that you've in the order configured. The runner function run on your App after adding the default plugins. just think of a plugin as a grouping settings. The default plugins add the default I know that was a lot of really dense information. hands-on coding. I encourage you to code along going to create a new Rust project using cargo directory, do cargo add Bevy to include Bevy as a recommend you do is go into your Cargo.toml file optimizations. This will make certain operations a Let's start coding. We're going to start by we might need to build a simple application in and bring in the default plugins. Default plugins window to be rendered. At this point, if we were appear and the application would run until it anything to the screen. Instead, our goal is to use queries and commands to interact with the ECS Next, we're going to define two components: Position and Velocity. Drawing inspiration using derive(Component), Rust generates the allowing integration with Bevy's ECS. This process simple, and defines the trait to focus on defining the data and not worrying In Bevy, components are highly versatile and and zero-sized marker types. Next, we'll define to your system's function parameters to obtain a enables modifications to the world, ensuring safe deferring the execution of those commands spawn creates an entity, adding it to entity is defined by its components, Velocity. We use a tuple to group these the entity upon spawning. By doing this, and its components can be accessed and Now that we've defined the spawn_spaceship system to the startup schedule. In other that we've created with Bevy so that it can know we're making it run at the very beginning of Bevy automatically runs the system, While this automatic parameter passing might feel and more organized architecture for our Bevy update_position, which will take a query. a read-only reference to Velocity and a type parameter in the query type defines the take references or mutable references to the For accessing multiple components, you simply that tuple as a type to the query. In the queue to our startup system, Bevy is going to update_position function. In the function both components for every entity in the query. entity with the corresponding components Then, for each of these components, we simply velocity y to the position y. In order to update entity, we need to make sure position is mutable, when we iterate over it in the query, because Next, we'd like to be able to add a simple way previous system. In order to do this, we'll the entities and their components. In this case, can still query the same entities using only type. We're going to iterate over all entities and and position values by using Bevy's built-in info will allow us to see what's happening as the game Finally, we'll add the update_position schedule. The update schedule runs once all the core game logic. Bevy is going to call loop. We now have a working application that manage the game loop yourself. Just by and calling run, Bevy does that for you. Before wrapping up, let's take a quick look you can see, Bevy is automatically executing info macro calls being output into the console. print_position system, and each frame logs the And that concludes our very first session. more topics I want to cover in this series. I'm full-time for the past six months. Topics will using bundles and plugins, to understanding and learn about system ordering, run conditions, and we'll explore Bevy's 3D capabilities, that incorporate the topics we've learned This is the first YouTube series that I've for me. I'm not the best public speaker. I'm along with the journey and join us to make a great so please drop a comment. Let me know the or anything I can change to make this more different backgrounds and different levels of do to make this series more accessible to you, I hope you all have a great day,