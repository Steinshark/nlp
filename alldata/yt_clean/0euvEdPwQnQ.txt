[MUSIC PLAYING] DAVID J. MALAN: All right, this is CS50. And this is week 5. And among our goals for today are to but to focus all the more on by way of data structures. So data structures, again, is this way But more specifically use your computer's memory in to actually solve But we're going to see different types of data structures. And we'll make the distinction like high-level descriptions and the lower-level implementation So in particular, we'll talk first today So an abstract data type But it offers certain properties, And it's actually up to implement the underlying So, for instance, there's actually common in computing known as a queue. And from the real world, most of us otherwise known in the US typically In fact, I have here Could I get three volunteers to OK, I saw your hand first. How about your hand second? And in the blue. OK, come on down, just you three. Come on over. And if you want to queue Come on down. Thank you. As we begin, do you want to NAFTALI HOROWITZ: Hi. My name is Naftali Horowitz. I'm a first year studying And I sleep at Hurlbut Hall. DAVID J. MALAN: All right, next. CATHERINE: Hi, everyone, I'm planning on studying engineering. I'm not sure mechanical or And I'm currently in Kennedy. DAVID J. MALAN: Nice. Nice to meet. ISABELLA: Hi, everyone. I'm Isabella. I'm in Strauss. And I plan on majoring DAVID J. MALAN: Wonderful. Well, welcome to all three of you. And I think this will be I have here these three bags of cookies. You formed nicely this So if you'd like to come up first And right that way, that's all Your cookies as well. Right this way. And your cookies. Right this way. Wonderfully well done. Thank you to our volunteers. The point is actually sincere, though, And as easy as it was queues actually manifest is germane to a lot of problem solving Specifically, queues offer this out. And indeed as our as they queued up on stage, 1, 2, handed them their cookies. And daresay it's a very It's very fair. First come, first served of describing FIFO, first in, first out. Now, structures like these that make sense. And in the context of queues, we as enqueueing and dequeueing So when our first three And as I handed them they dequeued and exited Now, how could you go about implementing Well, we can actually implement But perhaps the most obvious is to And we could use a data structure like this, whereby we specify the For instance, we might store a total We might define our structure as simply an array. And if a person is a data type you could imagine each of our And we've stored them one after by way of this actual array. But we do need to keep track inside of namely, we need to keep like the size, like how many people are Because if we have a I'd like to if I only Then I can do some quick that I could have fit another But it's finite. Of course, if we had 50 volunteers all as we could actually handle. So there is this upper bound But there's yet other ways for storing And there's this other abstract And stacks are actually even though it's not you would want when For instance, could we OK, I saw a hand here, Come on down. We'll have the orchestra All right, come on over. And if you wouldn't mind, come on over. We'll do introductions first. This will be almost as easy as the last And let me just stack you So if you could go there. And if you could come over here. And if you could come over here, So you were first. So you're first in the stack. SPEAKER: Hi. I'm [INAUDIBLE]. I have no idea what I'm studying. And I live in Strauss. DAVID J. MALAN: Wonderful. And next? SPEAKER: Hi. I'm [? Tanai. ?] I'm And I live in Canada. CLARA: Hi. I'm Clara. I want to study applied math. And I'm in Wigglesworth. DAVID J. MALAN: Wonderful. Welcome, to all three of you. And if I may, let me just advance a The catch is that what's known as LIFO, so is sort of the opposite So in fact you were last in line. So here we have your cookies. Thank you so much. And if you'd like to exit that Thank you so much. We'd you to exit this way. And even though you were give you any cookies because So, yeah, OK, point's made. We'll give you the cookies. All right, so thank you to But LIFO, suffice to say, guarantees as a queue or And imagine just lining up in any Ideally, you want the people running to that line so that FIFO is preserved whereas there are contexts in which In fact, if you think about typically you're viewing Because when you get new It actually ends up in the top. And if you're like me, odds are I mean, probably the ones came in last, most recently be to the detriment of people who Because once they sort of fall frankly, unless you click next, you But stacks are indeed And Google and Microsoft call that, in general, we users want The last information might Now, just in terms of that are analogous to but with this property of LIFO So when our first volunteer I pushed him onto the stack Second person was pushed. Third person was pushed. And then when it was time we popped them, so to speak, one after property. But here's where things are of implementation details. A stack could be implemented almost to a queue because what do you need? You need an array of people, type for past classes. We have to keep track of how so that even if we have we know at least that we can Now, there's still going to be a details because not pictured here is and pops or enqueues and dequeues. So whatever loops you're using, odds are that's where those properties FIFO versus LIFO, you're going in this direction instead of this But at the end of the are just abstract data that we can implement them in among them here thus far on the screen. But that array is going Because if you only what happens if 51 people You just don't have room for them enough room for the people themselves. We have enough memory. So it seems a little shortsighted can fit in our data structures. So with that said, a friend of ours, kindly put together a And allow me to introduce you to If we could dim the [VIDEO PLAYBACK] [MUSIC PLAYING] - Once upon a time, there When it came to making friends, So Jack went to talk to the He went up to Lou and Lou saw that his friend Well, Lou began, just Don't you have any clothes Yes, said Jack. I sure do. Come to my house and So they went off to Jack's. And Jack showed Lou the box and his pants and his socks. Lou said, I see you have Why don't you wear some Jack said, well, when I I wash them and put Then comes the next I go to the box and get Lou quickly realized He kept clothes, CDs, When he reached for he chose the top book or underwear. Then when he was done, he Back it would go on top of the stack. I know the solution, You need to learn to Lou took Jack's clothes And when he had emptied Then he said now, Jack, at the end of when you put them away. Then tomorrow morning shine, get your clothes from the Don't you see, said Lou? It will be so nice. You'll wear everything once And with everything in queues Jack started to feel quite to Lou and his wonderful queue. [END PLAYBACK] DAVID J. MALAN: So the same-- wonderful, thanks to Shannon-- so you might have noticed so we could make a similar gag about looks. Even though I might own a it doesn't really work if you're popping cleaning it, replenishing the blacks even get popped themselves. But we're going to focus today which for us are really different ways of designing data even differ. But we're going to start that invariably we'd be develop more and more real smaller programs as in class. And arrays, recall, are what? What's the key of an array with respect and storing things in it? Yeah? AUDIENCE: It stores DAVID J. MALAN: Perfect. So it stores the data And as we've seen thus far, when you typically do it You specify a number in those like capacity, like I just did. And that fixates just how much data We did see last week, start to use malloc to allocate But even that, when gives you back a specific So you're similarly deciding can store in an array. So let's consider what kinds of So here's an array of size three. And suppose for the already put three numbers Suppose now we want to add a Well, where does it go? Intuitively and pictorially, you'd But remember the context we we talked about computers' memories. There's lots of stuff going on. And if you only ask the room for three integers, who knows not to mention everywhere So if we zoom out for instance, we But we can't if in that greater context So for instance, suppose that elsewhere I've already created a string like backslash 0. Just by bad luck, that could be Why? Well, if I ask the operating then I ask the operating it's pretty reasonable for the computer because it's not going to anticipate for four numbers eventually Now, as for all of that's just meant to here the notion of garbage values. There's clearly other I don't know what it is. And I don't care what it is. But I do care that I can't just I want in the computer's memory unless Now, if all of those are is to say that who cares what they from previous runs of the there's clearly plenty of I could put the number four here or here But why would I not want to there is a garbage value currently? Yeah? AUDIENCE: Because you want it to DAVID J. MALAN: Exactly, I want 2, 3 because, again, arrays must Now, that's not a deal breaker put maybe the entire array? Well, there's room up There's room down here for four numbers. So that's fine. And that could be a If you've run out of space well maybe I just abstract and I just move my array to a different But there is going to be a downside. Even though this is a solution, copy the 1, the 2, the 3-- and And, heck, I can then let go and give it back to the operating This is successful. But why intuitively to be our solution of creating a copying the old into the new, Good, yeah, I think I had one more step. Suppose I want to add a That's a lot of work. And, in fact, what's the expensive part Yeah? AUDIENCE: It takes a lot of time. DAVID J. MALAN: It takes a lot of time. But specifically, what's taking Yeah, in the back? AUDIENCE: You're using twice as much. DAVID J. MALAN: OK, I'm using twice as much memory, because even though I don't eventually and then shrink back down, which seems But what specifically is Yeah, in the middle. AUDIENCE: You're iterating through DAVID J. MALAN: Yeah, You're iterating over the array to copy So it's probably like to copy the array and technically But that's still big O of n. So it's the copying, the moving that's certainly correct. But maybe it's not the best design. Wouldn't it be better if we Well, let's consider what this might and what the implications then might be. Let me switch over here to VS Code. Let me propose to open up a And let's create this list of and see when and where we actually So let me include standard be able to print things out for command line arguments here. Let me give myself an array for consistency with And now let me go make it look like in memory So list bracket 0 is going List bracket 1 is going And list bracket 2 equals number three. So even though the array I'm using more familiar Now, suppose I want to Let's just do something So for int i equals 0, i Inside of this loop, I'm going out iteratively, as you note, So very simple program. It's not the best design because I'm hard coding the 3. But the point is just to of demonstrating how this code works. Good, you got it in So wait. Thank you. All right. Maybe round of applause. Thank you. [APPLAUSE] All right. All right, so this is going to get So let me add the semicolon. Let me recompile this list. Seems to compile OK. And if I do ./list, I should So the code works. There's no memory constraints trying to actually add some values. But let me consider how I could go everything from the old frankly, just to see how annoying So you're about to see And it will be helpful to try to wrap even though if you going to look like a crazy amount But that's the point. We're going to get to a where all of what we're about to So hang in there for now. So let me go ahead and do this. If I want to create a version of this for instance, how can I go about doing Well, I cannot use an array in this brackets because that makes list, I can't free it. Remember free you can So you can't give it back and then But I can use this trick if I know there is this function is to give me memory, I list to be a pointer so to speak that And I could ask malloc for a chunk per se, three integers for good measure. So technically that's three times Now, for our purposes today, But I'm trying to do this very on an old computer or maybe a future might very well change. That's why I'm using size of int. It will tell me always the So to use malloc-- not going to catch me on this one-- Standard? AUDIENCE: Standard lib.h. DAVID J. MALAN: Standard lib.h. So I'm going to go ahead and gives me access to malloc. And what I'm going to additionally do whereby in extreme cases malloc of an actual chunk of memory. What else can malloc Yeah? AUDIENCE: Null. DAVID J. MALAN: Null, which represents technically address 0. But you're never supposed So it's a special sentinel value Do not proceed. So it's going to add But it is good practice. So if list at this point there's no more work to be done here. I've got to abort the demo altogether. So I'm going to return to say we're done with this exercise. It's not going to be germane for class. We can surely find room for whenever using malloc. Now, this code here does not need a chunk of memory of get away with still using and treating this chunk of And this is a bit subtle. But recall from last time, we talked whereby the computer can do some on the actual addresses to get And that's what the computer Because it says list bracket just going to put the number of that chunk of memory. And because this is a modern computer, But I don't want to put the number Because I'm using square knows that this chunk of as a chunk of addresses of integers, So what the computer is going to do It's going to put this number 2 at And it's going to put this size of int, which gives me 8. So in other words, you about how big that chunk of memory is if to the size. For our purposes today, don't The bigger takeaway is that when you can certainly an array using week 2 notation, dots and stars and all of that. But this isn't quite me stipulate that for at this point in time here on line suppose I realize just for oh, I should have allocated space Now, obviously, if I were I should just go fix the code But let's just pretend that somewhere in your program you and free up the old in order to from old to new memory. So how could I do that? Well, let me go ahead and temporarily And I'm going to literally which is a common convention, tmp. I'm going to set that equal that I actually do now want. So I'm to say four times So technically it'll give me 16 but And what that's doing for trying to find me space that might very well But I can, therefore, reuse them. So once I've done this, And I could check if then actually I should exit But there's a subtlety here. And you don't need to dwell But there is technically Why based on week 4, last week, to immediately return 1 and abort AUDIENCE: I think when you allocate DAVID J. MALAN: OK, so sometimes there might be garbage But that is to say that those 16 have Oscar the grouch's But tmp itself will literally And malloc will always return to you Or it will return null. So this line is actually OK. What I don't love is that AUDIENCE: I think [INAUDIBLE]. DAVID J. MALAN: Yes, so It's not quite right to just Why? Because up here, remember, we used malloc presumably successfully. Because if we got all the way down So we kept going. But that means we've allocated three So frankly, if you compile this it's going to identify a memory leak we did not free the original memory. So this is where frankly C does get as the programmers have to So what I really want to do here, I want to free the original list. So I give back those bytes Now, as an aside, technically when is going to be given back But practicing what I'm preaching now later. Because if you don't free up And that's when our to start to slow down and use But let's avoid discussion Let's just assume that of this program, whereby I have enough space. So the next step after allocating these iteratively copy the old So this is actually I'm going to go ahead. And for int i gets 0, i is like I was printing last time. I'm going to go ahead and equal to the i-th location And that's it. I'm just copying into the temporary But that still leaves me with or, sorry, this fourth location, But if I'm going to do that even though this isn't really a I'm going to just manually go into tmp bracket 3 and set that So that's all. The whole point here is to mimic in But now there's one more step. What was the next step after copying What do I want to do? Now, I can safely free the list. Now I want to go ahead and or at least hand it back So here is where I can free the but actually deliberately free don't need those 12 bytes anymore. But now if I want to really point at this new chunk of memory, list equals temp. So this is a little weird. But recall that list So even though list technically contains it's no longer valid So, yes, it's still technically there. But it's effectively garbage values now. So I'm certainly free-- no pun intended. I'm certainly allowed to And I want list to now point So sort of metaphorically, pointing at a chunk of memory there, So I'm just updating the All right, now that I think I can just use I could change the 3 to a 4 At the very bottom of this I should probably now at And for good measure, let But now I think I have a to be clear is not how you would because you would not decide you want to allocate But we could probably some of this code into production solve some actual problems dynamically. So let me cross my fingers, make list. So far so good, ./list. And I should see 1, 2, 3, 4. So long story short, it's a lot of work to the second. So ideally, we would not do Ideally, what could we do instead? Well, maybe we should from the get go in order to So how might I do that? Well, instead of having allocated an of size 4, why don't I just proactively allocate an array of size and then just keep track of That would be correct. It would solve the problem of not so quickly. But what remains as an issue? AUDIENCE: You're using a lot of memory. DAVID J. MALAN: I'm using Especially if this program's only why are you wasting 100 times more And there's an another corner even though this solves the problem. AUDIENCE: If you add another DAVID J. MALAN: Exactly, still run into the exact want to put 301 numbers in I'm still going to have to and reallocate all of that space. And, honestly, now per year concern 3,000 times is certainly to start to add up if we're doing it So maybe there's a better way And indeed there is if we start to that we can start to use to design Arrays are a data structure, arguably. They're super simple. They're contiguous chunks of memory. But we could use memory a little more that we have pointers, which be to wrap your mind around sometimes. They really just let us point And so we can start to stitch things So the only syntax we'll really need in memory and build more are these things, struct, which allows And we did this with persons. And we played with And we saw it already The dot operator, we But recall that whenever you can go inside of it And we did that for a person, when we were implementing The star was new last week. And it can mean different You use it when declaring a pointer. But you also use it when But just so you've seen tends to be a little annoying, a little You might remember one example put star something. And then I used a dot operator to go Long story short, we'll can combine simultaneous into something that actually that vaguely looks like a foam finger to another. So we'll see that actually in some code. So where can we take this? Well, let's implement the first of very canonical in computing And let's see if we can maybe do this. How about Scully, could we get you So our friend Scully-- there's some cookies in this for you. So Scully has come prepared to represent chunks of memory because of what's involved in actually contiguous and might be over in the computer's memory. So, for instance, if I want one at a time for a could you go ahead and And in this balloon I'll store for So we have a balloon here. We rehearsed this before. And these balloons are actually really So thank you. So here we have a chunk of memory. And I could certainly for instance here we go. I could certainly go ahead for instance, the number one. But in the world of an array, it And actually, frankly, why I could just use these numbers, 1, 2, 3. But the problem doesn't that when we want to put a fourth Well, again, just to might allocate space for four. But if this is my array of This is the point. We can't just put it next to the 3. Maybe there's room for the 4 over here. But we have to somehow connect So, in fact, let's act that out. So if I instead use this balloon from wherever it is, can like another chunk of memory for me? And here is where I'll now have a the number computers a little slow. So in here, the second balloon I'll AUDIENCE: Oh my gosh. DAVID J. MALAN: There we go. OK, good. Second chunk of memory, Now, I can certainly-- Thank you. I can certainly now store the But it's not necessarily contiguous. This chunk came from over here as This chunk obviously is And if you don't mind this is breaking the metaphor of an And even though I as the human can that's the equivalent of copying What if we're a little And if Scully found space for let's just leave this balloon here. And if she found space for let's leave that balloon there. But we do somehow have to And here is where to-- I'll try to do this on the fly. Maybe I could do something like this. I can take this balloon here. And I can actually tie a want to connect one to the other, we And so here now I have a linked list There's a whole bunch of memory may very well have garbage values. But I've somehow now And maybe just as a final flourish, to represent more space-- for that balloon over there. Nice. This one is a Yale chunk of memory. So now I'll need one And if I actually connect let me go ahead and tie this off here. Now I can go ahead If you never see this demonstration it's because this did not go very well. Here now we have the number the number two roughly where we OK, so maybe we'll fix Now, we'll have the But the whole point is that we can certainly use the put things wherever we want, wherever connect the dots, so to speak and can to the next to the next, thereby But, of course, we're using But at the end of the So how could we encode one chunk might you think? What's the trick? Yeah? AUDIENCE: Pointers. DAVID J. MALAN: Using pointers. That's why we introduced Because as simple as an as it is to write literally just a pointer, a foam finger And so these pointers being implemented now in So we'll have to debrief later and But thank you to Scully OK, we have plenty of-- OK, fair's fair. There we go. Thank you Scully. So let's now actually translate this and then get to the point where we can So here's that same canvas of memory. And if in this canvas want to implement this idea of the let's stop tying our hands in to be contiguous back to back and So, for instance, suppose I want just as I first asked of Scully. Suppose it ends up over The important thing that that number one, wherever it ends And for the sake of suppose the number one just So 0x, 1 2, 3 is where Scully was Then we asked for malloc Suppose that it ends up over So that's maybe roughly here when Scully Lastly, we allocate the number 3. Maybe it ends up at which was again per Scully's third Now, this picture alone to an implementation of the string, unless we allow ourselves a new luxury. Instead of just storing the number I think what I'm going to have to to store what? The pointers as you proposed. So here's a trade off start to see more and more if you want of time and avoid stupid to another again and again and again. If you want to save time, you're And there's going to be this And it's up to you to decide So if you allow yourself not enough but twice as much memory for the one for each, what could we now do? Well, if this node-- and this is a computing term. Node is just a generic term describing in this case. If I've given you this would make sense to store here if Yeah? AUDIENCE: Maybe the address DAVID J. MALAN: Good, maybe the So the next element technically So at this location, I'm going What then logically should 0x, 7, 8, 9. And then here's a little non-obvious-- So we can't afford to because a garbage value is a value. And we don't want Oscar to effectively lest we go there. So what would be a good special value So null, so not null, which we used which we keep using now for pointers, which I could just write for which is the same thing as null. So here then, even though we've changed this is just my computer's memory-- I'm using more memory now to effectively to the next chunk. So easy, just to note that But now we don't have to worry about around, which maybe over big data sets could very well be So any questions first on this notion No, all right, well, too that rarely do we actually care So this is one node, two And inside of each of these nodes we care about and then a pointer. And now this is actually an that you might see increasingly which we obviously care And then we could actually more generally as metadata. It's actual data because it's helping place to another. But metadata is distinct from care about the metadata. That's an implementation detail. But it does help me So this is more of a high-level concept. So what, though, is a linked list? It turns out the store linked list And I'm going to draw it only because if I declare now a variable maybe called list is effectively how I could I use one node per value. And I use one extra pointer to And, in fact, here again is where where any of these addresses are. It suffices to know that, yes, So I could just abstract this away. And this is how I might a linked list, a cleaner whereby I was here. This was Scully's first balloon, These arrows now just represent So with that said, how can we go about Well, here's where we can call into play and even a couple of weeks ago when we So here for instance is how we defined of a person? Why? Well, C doesn't come But we concluded it was useful to with their number and maybe So we typedef'd a structure We learned last week that But that doesn't change what And we call this struct a person. Well, here's what we revealed last time, It's just a char star. Let's keep going in If I want to define not a person something I'll call today for my numbers and my just need two values, which isn't relevant today but so I can store the 1, the 2, And this is a little less obvious. But conceptually, what inside of any of these nodes? Yeah? So indeed a pointer. A pointer to what, though? AUDIENCE: Another node. DAVID J. MALAN: A And here's where the But how do I define there to be a Well, you might be inclined to say the name of the property or the the struct. Star means it's a pointer. What is it a pointer to? Clearly a node. But here's where C can bite you. The word node does not exist until C goes top to bottom, left to right. So you literally can't use the word node The simple fix for this is to actually of defining a structure. You can actually do this. And we didn't bother because it didn't solve a problem. But if you actually make your and say, give me a definition for a you can actually do this. This is an annoying when it comes to But, essentially, we're that because C code is if you give this structure now you can refer to it here. But you know what? It's annoying to write struct node, in your code. So this last line now And it shortens struct So long story short, for any time you implement some But it's fundamentally just containing now a to the next as opposed to So let me go ahead and how we might actually implement and putting a number on it, and putting a number on it and then and again. So we'll do this step so you can see the syntax that Then we'll actually pull up and make a demonstrative program. So here, for instance, is via which I can give myself list that is a pointer that will So metaphorically, it's I know we've gotten some complaints We'll use the Harvard one to But if I only do this a variable called list that that's going to leave a garbage value. So this is like pointing because it's previously some value. Who knows what it is. But we can solve that how? What would be a good initial So null. At least if it's null, we then know This is literally 0x0, a.k.a. null. And I'm just going to leave So this would be the right way to begin There's nothing there. But at least now that foam finger is not some garbage value. So this is how the world might How do I go about allocating Well, it's just ideas from last week. Once the word node exists I can just use malloc to I don't have to do the math myself. I don't care how big a node is. Just let it do the math for me. Then that's going to return presumably big enough for that big rectangle. And I'm going to store that for now that itself is a pointer to a node. So this might look But this is just like before when or I allocated space and set it equal to a pointer to recently. All right, so this gives This gives me a pointer called n. So it's similarly just a single And it similarly gives me somewhere in the computer's for the number that's going to go and a pointer to the next value. So these lines of code collectively, This half creates this in memory. And the assignment here, does the equivalent of that. I don't care what the address It's as though n is now pointing But this isn't very useful. If I want to store the number 1 Well, I could do this, borrowing So *n presumes that n is a pointer. *n means go there, go to The dot operator means if go inside of it to the number field. And we did this a couple of when we implemented an address book. So star n is go there. And the dot operator means The one on the right hand means set whatever is there It turns out this is the alluded to being a little bit cryptic or type. Here, though, is where instead use this line of code, which This means n is still a pointer. The arrow literally with a hyphen and It's the exact same thing as with the dot. This just simplifies it to look So this would be the most How now do I update the next field? Well, I think I'm going to n go there but go into the next Why null? If the whole point here was to allocate you don't want to leave because that value will be to some random location. All right, that's a lot. And, again, we're doing by step just to paint the But any questions on any of these steps? Each picture translates All right, so if you're comfy what can I proceed to now do? Well, let me propose that what I is set list itself equal to n. Because if the whole goal is and list represents equals n is essentially saying And pictorially what that means to the same exact place. Why? Because this is the list This is maybe my global variable in my computer's memory. This was just a temporary pointer so and go to its locations and So, eventually, this is probably And this then is a This is what happened when I wrote the number 1 on it, and All right, if I want to go ahead we'll do this a little more quickly. But it's the same kind of code for now. Here's how I allocate Here's how I can And I'll re-delcare it here just to make So the left hand side of the The right hand side of the Where could it be? I mean, I put it here. It could have been there. It could have been anywhere else. But malloc gets to decide that for us. n equals this, just sets that temporary I should clean this up. How do I now put the Well, I start at n. I go there. I go to the number field, And I set it equal to 2. Now, it's a little non-obvious So I'm going to be a And rather than put these numbers like ascending order going to plop it at the Why? Because it's actually a little simpler. Each time I allocate a new so to speak, to the even though it's going to end up So, notice, at this got list pointing to the I've got n pointing And, ultimately, I want to and I did with the strings. This is just temporary. So I want to connect these things. Here's how I could do it wrong. If I proceed now and update, rather, to null-- sorry, let's at least here's how I could proceed Let me go ahead and update, So if I update list to point the list at this new node. But what has just happened? What did I do wrong? Yeah? AUDIENCE: Nothing's pointing to 1. DAVID J. MALAN: So And even though you and I obviously in the computer's memory, If you have no variable remembering for all intents and So what I've essentially done is this. When I update that pointer to point this was a much nicer idea in But it's not really working. But this is effectively what we've tried so to speak, the number 1. And that too is a technical If no one is pointing at it if I have indeed orphaned a a memory leak. And Valgrind would And Valgrind would, So what would be the better approach? Let me rewind. Instead of updating that address rewind to where we were a pointing at the original, n is still And what should I do instead? Well, what should I do is maybe this. Let's go to the next So follow the arrow. Go to the next field. And what should I put here instead? Why don't I put the memory How can I get that? Well, that's actually this. So if list is pointing I can just copy that address which has the effect of doing I've updated the next field that the original list And now for the sake get rid of my temporary node called n. And what you'll see, set list equal to n we can just treat the whole linked list How do we do this? Again, we won't belabor But suppose I want to I have to do the exact same thing. But I have to update this next before I update list itself. Long story short, order of operations And if I want to stitch these I would encourage you to when it comes time to think about what it is that we're So let me go ahead and do this. I'm going to go over to VS Code here. I'm going to delete the And perhaps now we can transition and actually do something So I'm going to go ahead, as before, #include standard io.h. Let's go ahead and include And let's go ahead and So typedef a struct called node. And inside of this node, let's to store the 1, the 2, the 3, the 4. And then let's create a struct node star is going to point to the I'm going to shorten the name of And then in main, let's We'll bring back our so that I can actually implement lets me construct a that I just passed at the command line. I don't want to bother with getInt So let's just use argc and argv. But with argv, recall string now as of So that's the exact same thing as we've arguments. So what do I want to do? My goal in life with to create and code this linked list So how can I do this? Let me go back into VS Code. Let me declare a linked list called So there's nothing there just yet. How now can I go about By taking numbers from the command line. So let's do this. For int i equals 1, i is less than and do this. I'm going to go ahead, and just let me print out where Let me go ahead and print out %s i. So I'm not doing But let's just demonstrate Let me go ahead and make list, ./list. And let me put the numbers 1, 2 Enter. There, we just have I'm just jumping through how I'm getting those values. But notice the values in argv char star. So if I actually want to convert how can I do this? I want to set the number But argv bracket i is a string. How can I convert a string Yeah? AUDIENCE: Atoi. DAVID J. MALAN: Atoi, so ASCII So if I do atoi, I can actually And now I can actually print this Now, that's not going to change if I print it out again. But it does, in fact, give But let's not bother printing it. Let's instead put this number and into a linked list. So let me go ahead and Let me set it equal to asking malloc for the size of one node. Ideally that will give that can fit this number and a pointer. Just for good measure, I'm going to then actually this isn't going to work. So we should probably So I'm just going to because there's a few steps involved. So free memory thus far. And then we can go ahead, All right, if now I don't have an but it's a valid I can follow that pointer and set it equal to the actual number. So this is a little that I've got number on the But they're different. at a chunk of memory big n arrow number means go and go to the top half of the to be whatever the human typed in here to an actual integer. All right, what next do I do? n arrow next should probably be And how now do I actually add this Well, I could just do list equals n. And that would update a la the to point at this new node. But we said before that Why? Because if list is already we can't just blow pointing at because we'll have It's not relevant at the in the first iteration of this loop. But we don't want to So what do I first want to do? Before I actually point the I'm going to instead say, go to and actually set that equal to list. So strictly speaking, I don't actually I can initialize the next field of this So what I'm going to do here is, equal to null, if I want to insert this already exist, I can simply say set the list currently is. And now in this last line I can So after this, let's just go ahead and though the syntax for this is going How do I go about So print whole list. Well, there's a couple But if you imagine a to a world in which we now have a here's where we might be at some We've inserted the 1. Then we inserted the 2. Then we inserted the 3. But because we're prepending everything, So how could I go about printing this? Well, ideally, I could do this. If a computer can only look I can grab my foam finger and point at and print it out, point And then because this is null, I'm But how can I translate Well, I could implement that in the following way. I could give myself a pointer often as ptr, specify that that's indeed a and initialize that pointer So this is the code equivalent of, if declaring a pointer variable and itself is storing first. And, now, that's akin to doing this. If I now go back into my Well, so long as that null-- that is, so long as that let me go ahead and print out using And then let's print out pointing at in ptr arrow number. So whatever I'm pointing at, go there After that, what do I I'm going to set pointer So what does this mean? If I go back to my to actually walk through this ensures that this foam finger, is pointing at the first Once I've printed it out with equals pointer next, which So ptr now points at the 2. I then print that out and set That's like following this arrow and instead. At that point, the next step is So for all intents and And that's why we can actually because while pointer is not null, it's Now, let me go into my terminal window. Let me go ahead and make I didn't make any mistakes because Seems to have compiled OK. When I run ./list of 1, 2, 3-- theoretically, this code is build up an entire But what's it going to What do you think it's going to print? Yeah? It could print out null if What else? AUDIENCE: 3, 2, 1. DAVID J. MALAN: Or it And frankly, that's what I'm hoping for. So even though I've because I'm prepending to the beginning beginning of the list indeed, we're going to see 3, 2, 1. Now, that's fine. That's correct. But it's not necessarily So how could we actually go Otherwise, because, in fact, what's the running time insert? How many steps are required right if you want to go ahead there's actually a reason I took this In big O notation, how much does it Think about it this way. Does it matter how in the linked list, whether it's If you're prepending, it that chain is, you're at the beginning, at the Now, how many steps is this? I don't know exactly. I'd have to count the lines of code. But it's some small number. It's like two steps, three steps. How many lines of code is it? It's very few to prepend, prepend. So I would dare say that the running is actually constant time. It's big O of 1. And that's super fast because it Boom, boom, boom, you've But there's a flip side. What's the running time of looking for something in Well, if it looks like it take you to find that the human might ask you for? How many steps will it take to So big O of n-- because in the worst might be all the way at the end. And even though you and I, and we can obviously see where the 1 is by starting at the 2. How do you get to the 2? You got to start at the 3. How do you get to the 3? You've got to start at the And so whereas in the world of chunk of memory, just like we had and you could jump to the middle and the middle of the middle. That was all predicated Why? Because if you know where know where the last locker from the other, divide get the index or the location And you can do that again and again. I cannot do any such math here. The middle of this linked But it doesn't matter what the It doesn't matter what is in memory because they could be So you can subtract one and that's going to put because these chunks of memory are They're every which way. So this is to say, what can we not use on linked lists? So binary search. So that very algorithm was all predicated on contiguous The problem with an is that you paint And you have to in advance And if you round up, If you round down, you're wasting time. So you're screwed either way. A linked list avoids those problems. It's more of a dynamic data And frankly, if we code it We could remove these And so we're not necessarily but we are on searching this thing. We're back to Big O of n when it comes to it being log n, which So the upside of prepending is that we have constant because we just continually into the very beginning of the list. Of course, a side effect might end up in completely because I first inserted 1. But then I prepended 2. And then I prepended 3. Well, we could perhaps take a and append the nodes So, for instance, if I start off with I can insert 2. And I can insert 3. And, in this case, I actually are in fact in sorted order. Now, to be fair, that's not guaranteed. But let's at least would look like if we were to take nodes instead of prepending. Well, rather than write let me open up a premade version of to explain what's going on. Some of this code is But allow me to scroll down we'll see the actual logic in question. So, first, on line 35 here, we're Because if there's no list to prepend or append. We're just going to go variable to point to this new node n. But if the list isn't empty, and well, then what we're going We're going to iterate over And I'm going to do so with a or ptr for short, that's initialized finger pointing at that I'm going to on every iteration to point to the next node, to the with that foam finger. But on each iteration, I'm that the pointer variable is not null. Because if it is null, that means I'm that is, the list has ended. But if inside of that loop I notice that I actually know logically that without going past it. So at that point, if my goal I'm going to go ahead and which is currently null, but set it effectively appending that So, for instance, if we started with a is updated 2's next field to be equal Meanwhile, the node containing because it is now the Now, what are the implications for Well, we are now appending means we're no longer gaining Because any time we prepend it, it We just had to update a couple of beginning of the list. And it doesn't actually matter is getting because the list when we're prepending. But when we're appending, by definition finding the end of the list, And so our running is no longer big O of It's now big O of n because if just to find the end of it we need to actually find where But even so, we've gotten that we inserted 1 then 2 then 3. That's just because of Suppose that we don't in advance They might be large numbers, small But they might not But if we want to maintain this I think our logic's actually So let me actually go ahead and open up this one too made in advance. And in this version of my I've gone about changing the logic just now handle this additional case because order, if I wanted them I have to consider a Maybe there's no list whatsoever. So let's actually look for that. Let me scroll down in this final And, actually, that case here on If there's no list there, and well, let's just update it But things get more interesting when Because if the goal is to maintain does this new node, go before the beginning of the in the middle somewhere of the list? So let's break that down. If we find that the new node's number well, then it belongs at because it's smaller than any So what I'm going to go ahead and do to point at the current linked list. And then I'm going to update to equal the address of this new node. The effect then is, no matter how long number is smaller than I want to just splice So that's actually pretty of pointer updates. But the other scenario belong at the very It's somewhere else in the list. And that itself is two scenarios. Maybe it's in the middle of the list. Maybe it's at the very end of the list. So let's consider those Let me scroll down here. And in my else clause, it's Why? Because on line 51, in this case, as before. But this time I'm trying to determine or somewhere in the middle. So I'm not just looking I'm actually comparing the value, against what is currently in the list. So, for instance, if logically all the way to the end the next field in the pointer well, then logically I didn't find So let me go ahead and update to equal the address of this new node. And then like before, let's I somehow mathematically got all because there is that null pointer. So it must be the case logically here But this is the juicier, But it's what ensures that we if the new node belongs So down here on line 62, I'm If the new node's number is less than is to say, if my foam but the number I'm trying to insert is and implicitly the same as or greater well, then I'm going to I'm going to update the to be equal to whatever the current so that I can then update that pointer's And then I can break out in the middle of this list but to the left and the right to So, collectively, what Well, if we start out with and maybe we insert the number But suppose that we insert next the this code now ensures inserted at the beginning of the list. If we then insert the number 4, well, So it logically is going to And, lastly, in this example, if we out of order, this code can ensure because it's going to end So here too in terms of running It's not quite as bad in to the end of the list, as was the case when we But it is going to be in big O here, if we've got n nodes in the it might indeed be such a big number All right, that was a lot. Let's go ahead and take a And we'll be back in 10. All right, we are back. And to recap, the problems we've solved arrays were problematic And that can get us into trouble. Or it causes us to waste even though we might not ever use it. So we introduce the linked lists by being more dynamic and as we need on demand step by step. But, of course, we're spending We might gain performance if we at But we lose time again if we So it's not clear, even hearing these upsides and But maybe there's a way to by trying to capture the upsides is kept in sorted order that allows but still gives us the dynamism to And thus we're born trees. So what we're about to explore are and linked lists and see if we can maybe and create more interesting, that are even not just but are maybe two dimensional and have So a tree in the real to grow up from the ground like this. But it tends to branch out. And branches branch. And that might already in your in the road or And let me propose that the world calls binary search trees. And so bi is back in that we can somehow if maybe we think about So here's an array of size 7. And I chose that deliberately There's a middle of middle and so forth, So when the world of arrays-- this was actually pretty can do binary search and middle of And that gave us But its only size 7. And we concluded that it's going to copy this into a slightly and so forth. And thus were born linked list. But with linked lists, we Why? Because we have to always get, for instance, to the middle or to But what if we start to think a little So just for the sake of discussion, let array. Let me highlight the and then the middle of the middle. So there's implicit structure here. There's a pattern of sorts. And, in fact, just to let me not treat this as one dimension and give myself a bit of vertical space. So it's the exact same array. But allow me to just though the middle elements way up here. The middle of the middles And the middle of the really are at the bottom of this tree. And that word is deliberate. We actually borrowed vernacular where the leaf nodes or leaves And the root node is So for the sake of discussion, draw trees like this, instead of this. But it's the exact same idea. They just tend to grow down in if you drew those So what's interesting here? Well, at the moment, we've because this memory is absolutely not This number is here, It's all over the place. But we do have pointers even if these numbers are we can stitch them together like Now, it's not sufficient just for each node or one pointer. But what if we actually give each like the number 4, the let's give them each a number and and a right child so to speak. So we could do this. And I'm going to abstract away now. They're not even rectangles anymore. They're really long rectangles. Or they're upside down Ts But I'm just going to abstract away And it's an implementation detail But the arrows suggest that each of You don't have to use them. The leaf nodes have nothing to point to. So those can all be null probably. But each of these nodes Now, what's the implication of this? This is what we call because, one and first and But it also is a data structure whereby notice what is true. If you pick any node in this everything to the left of it, its Everything to the right of it, And that's true elsewhere. Look at the six. Everything to the left is smaller. Everything to the right is So in some sense, this is because you can say the same because each of these subtrees Or, conversely, this big of 1, 2 subtrees plus one more node. So think back to our [INAUDIBLE] Well, what's a pyramid of height 4? Well, just a pyramid of What's a tree of height 3? Well, it's two subtrees of height one new root node to connect them. So this already is a recursive How do we translate this into code? Well, we won't sludge through so much But let me propose that we as being similar in spirit to what we to have a number and a next pointer. But, now, let's actually and redefine a node as still having And I'll call them though we could call I could call it next and previous. But really left and right would seem of a given node like this. So this in C is how we a node in a binary search tree. And so let's consider pictorially of searching for something. If this here is the tree and it definition where everything to the is bigger, well, how many have n nodes in a tree like this? Well, it's not going to take don't have to look through every node. And, in fact, just like on the left hand side, so to speak. So that's just an artist's rendition. Just as a linked list have to traverse the whole thing, a always starts in memory So this is always where you deletion, searching. So by that logic, in the worst how many steps would it seem to take? It's not big O of n. So it's actually back to bi O of log n. Why? Because, actually, if there's roughly eight nodes in here. And log base 2 of 8 is actually 3. And so 1, 2, 3 is the So in the worst case that it's only going to take me like just two steps to get to to decide is a number there or not. I certainly can ignore Why? Because I'm searching for the number 7. Just like the phone book from week 0, If I'm looking for 7, wasting any time looking at this of the picture on the screen. And so I can focus on And, boom, I'm done. So we sort have binary search back. We have the metaphor of the lockers to mitigate the reality that our But that's fine. We can follow these arrows. We can use these pointers instead to So any questions now on trees or which I dare say are the best of both And it's log n running time. And all of the upsides of the dynamism can grow and shrink and Any questions on this? All right, well, the code too lends And here's where recursion applies but also the code itself. So just for the sake of We'll just look at it on screen here. Suppose you're implementing a function is to search a tree and I found the number you're looking for. Well, here's the number I'm looking for. It's one of the arguments. And the first argument more importantly itself a pointer to And that's all the information and go left, go right, How? Well, let me do this. As always, we'll have a base Because if there's no makes no sense to even I'm just going to return false. If you hand me null, there's But suppose that you don't hand me null. And suppose that the is less than the number in the tree at Well, what do I want to do? I effectively want to go left. I want to search the left subtree. How do I do that? I'm going to return the recursive function passing in a slightly but the same number. And this is where Look at the relative simplicity of this. If search exists, which it But we'll get there. If you want to search half So go to the root of the tree. Follow the left child pointer and It's just a smaller tree What if, though, it's a bigger number? So what if the number bigger than the number Well, then just search And now, logically, what's So I can express that as if the equals the number in the tree, then I'm going to go And you might remember even this conditional is not necessary. I just did it to be explicit. We can tighten it up as And that's it. And this is where, is maybe a little more accessible, a There's relatively little logic here. But what's important is that these dividing and conquering Why? Because it's solving the same But it's doing it on just half of the And because we have this if you get all the way and you try to go down the left child but those pointers are you didn't find it because you if anything had been in fact equal. So that then is recursive code for is, again, just to connect last time of actually doing and revisiting some of But I'm kind of lying to you here. Yes, this is a binary search tree. But it's not always as pretty as this. It's certainly not But it doesn't actually have to be In fact, suppose that we into an empty list starting with 2. I can plop the 2 right there. That's the current root of this tree. Suppose, though, that I how about 1? Well, it stands to reason that And so now this is the tree of size 2. Now, I insert the number, say, 3. It, of course, can go there. So that makes perfect sense. And I just got lucky. Because I inserted these I very cleanly got a balanced tree But what if you have a more You're not lucky. And the worst possible of the order in which the into this data structure. What if the human inserts 1 first? OK, well, it goes as But here's where things What if the human then inserts 2? OK, it goes there. What if the human then inserts 3? Well, according to our It looks like part of a tree But what is it really if It looks really just like a linked list. And there really is no second dimension. I've drawn it this way. But this for all intents and Why? Because there's no halving. There's no actual Now, this is fixable. How could you fix this? It's still the same numbers 1, 2, 3. And it does adhere to the Every number to the right is greater. Every number to the right is greater. Every number to the left But it certainly doesn't Could you fix this tree balanced so it's not but is still technically log of n? What should be the root? AUDIENCE: You just reverse DAVID J. MALAN: So I could And so sort of and I just swing everything then, indeed, this could 1 could be hanging off of it over as is. So long story short, when it comes they don't necessarily So even though theoretically, yes, it's not if you get a perverse just happen to be, for instance, it is fixable. And, in fact, in higher level specifically on algorithms you'll be introduced, if you you can tweak the code for insertion to make these fixes along the way. And it's going to cost you a when they get out of whack. But if you do it every at least you can And you'll learn about different But for our purposes get that property even if keep it balanced along the way. Now, what about other combinations We can really start to mash these things Dictionaries are another similar in spirit to stacks and in different ways. A dictionary is a data structure And those are technical The analog in the human world that you'd have in a classroom, and definitions, more generally So that's all a dictionary is. It associates keys with values. So, for instance, you like two columns in a you put the key, on the Or, specifically, you put the word thereafter. And that's roughly how the printed So dictionaries associate words keys with values. But it's an abstract data implement this in a bunch of ways. We could use maybe two arrays, one array for the definitions. And you just hope that they line up. Bracket i in this one maps But an array is not going to give You might run out of space adds new words to the English language. You might not want to be using an array. You might want to use a linked list. But, again, linked lists And that's not good for If you have to check every getting something that's a little So let's consider how maybe Apple, implementing contacts. Because even though I implied in it's an array-- it's a big list of all fixed size-- they probably better be using some you could never add more You'd max out. And they'd say you have to As an aside, this is sort of Once you have 5,000 friends on Once you have some number on LinkedIn, That's not necessarily But it is the same chosen some finite size for memory. So how might we consider implementing for your address book can store the names of but also their phone numbers Well, ultimately, we want to be and lead to their number. So the keys and values here will be names are the keys But the values themselves could also address and all of that. But we'll keep it simple, So here's how you might on a chalkboard, two columns or But how could we actually Because, ideally, we don't want it We don't want to have to look and family and colleagues to with Z, for instance, or anything else. It would be nice to have something But with binary search again, we But now we have to use two there's a lot of trade offs here. But let's see how else we Because wouldn't it be nice-- and we've if we instead aspire to this The best algorithm out there is like constant time, is it doesn't matter if you have a million, a billion friends-- it doesn't matter how big n take you the same amount of time. It is independent of n. And that's why it's sort of the So can we get to this aspiration? Well, a couple of building blocks. There's this notion in And hashing is a technique, in math or in code that actually them to a finite number of outputs. So if you think back to high you can take an infinite domain But it reduces them, a hash function, So, for instance, it's no accident that now, each of which has a We got for visibility's sake These are the super, And in this box are a bunch of And, typically, if you or you wanted to these you go about sorting them Odds are if you're like me, you'd and maybe pull out all of the pull out all of the clubs, or And that term is actually technical. Here are four buckets And, for instance, if the first you know what? Just to make my life easier, I'm going Or here we have 4. Here we have 5. Here we have 6. Here we have queen. And notice that I'm putting these Why? Because, ultimately, then I'm going size, a 13 size problem, 13, 13, 13. And, frankly, it's just going to algorithmically, to then sort each rather than deal with four suits So if you've ever in life made piles-- like this, you are hashing. I'm taking some number of And I'm mapping it to a finite So hashing, again, just takes to output values in this way. So beyond that what we can now do with a little more germane to storing and colleagues in dictionaries. A hash function is just I as the human was just implementing But technically a hash a math function or a or soon Python or other languages be it a physical card or a name and outputs some value. And we can use hashing as what we'll call hash tables. And that's what that dictionary was. If you think about how I drew it's like a table of information, So what is a hash table? The simplest way to think is an amalgam, a combination of We borrowed some ideas of to give us trees in two dimensions. What if we stick with this idea but now use an array initially? So we get the speed benefits of arrays We can do simple arithmetic and jump to or the first or the last very easily. And then you know what? Let's use the horizontal to give us linked lists as needed. So, for instance, if the goal at hand phone or my Mac or PC, let me propose with an array of size 26. Of course, it's 0 index. So it's really location 0 through 25. And for the sake of discussion, let A. Location 25 represents z. And then everything else in between. Why? We know from C that we can convert from letters to numbers So in constant time, we can find we can find location Z. Why? Because we're using an All right, well, suppose about these more as letters of rather than numbers. So it's equivalent to And suppose now I want to start to my address book. How might this look? Well, if the first one Mario's name starts with an M. OK, M goes there. So I'm going to put Mario at After that, I add a second person, Well, L comes just to reason that it goes Meanwhile, if I go and add she's going to go there a few with P. Meanwhile, here's a whole that happen to have unique And there's room for everyone, through Z with some But you can perhaps see When and where might a problem arise AUDIENCE: When you add [INAUDIBLE]. DAVID J. MALAN: Yeah, else who's name collides with just because by accident, they have a So, for instance, there's Lakitu here Here is Link who collides But I've drawn a solution I could if I was Kronion just and put Lakitu in or remove and But that's stupid if you can only have That's just bad design. But what if we now in the off chance with the same letter, well, link them together, no pun So my vertical here is an array. And this is just an artist's rendition. There's no actual notion of up, down, But this is my array always of size 26. And each of the elements in this But it's a pointer to a linked list. And if there's nothing there, But, otherwise, it's a valid address And you know what? If we have multiple names we can just string these nodes together So a hash table then as implemented And that allows us to, because look how fast we inserted But it still covers the can have the same first letters. Some of these names will collide. So collisions are an expected whereby two values from some domain And, frankly, you'll see this here too. So these buckets are They're definitely big But you could imagine a world where if I'm going to run out of space. And then my data structure But we're not going to because the linked lists, as we've as much as they want. In the world of Nintendo there's And these aren't even So that's then a hash table. So with a hash table in Did we achieve that Holy Well, for some of these names if I back Yoshi and Zelda, boom, constant Some of them, though, not quite constant time because I And then I have to So, technically, then what's the Sometimes you'll get lucky. But sometimes you won't. Consider the worst case. Big O is often used to So what would be the worst A little louder. So NY. AUDIENCE: Because you DAVID J. MALAN: Correct. And so to summarize all of your friends could have names that And then it doesn't matter with an array of linked lists. For all intents and purposes, start with the same letter, Much like with a tree, if you don't is a linked list. So technically speaking, yes, even if you're good about-- even if you have-- in the worst case, hash Why? Because it can devolve where you just have lots and lots of But there's got to be a way to fix this. How could we chip away at the Could I decrease the length so that with much higher Well, maybe the problem is that I mean, four buckets here, 26 here. Maybe the problem is So what if I instead just and it's too big to fit on the screen-- but what if I instead have a dollar and Lac, Lad, do, dot, Now, when I hash these Lakitu is going to end here, link at their own location here, And so now I don't have linked lists. I really just have an array of names. So now I'm actually Why? Because so long as every letter of I can get that in constant time. And we did that as far back as week one. And so I can figure out is of each of these at 1, 2, 3 characters or the total which is just 3 in this case. So this feels like a solution. Even though I haven't it feels like we've solved the problem. But what's the downside or trade AUDIENCE: Memory. DAVID J. MALAN: Sorry? AUDIENCE: Memory. DAVID J. MALAN: Memory. So not pictured here is the above and everything below. This just exploded in terms of the Why? Because if I'm taking into but the first, the second, and 26 times 26 times 26. And even though there's going that just don't exist-- I can't think of a Nintendo character you still need that bucket. Why? Because, otherwise, you You can't just arbitrarily If you want to be able looks at first, second, third letter out where to go, whether it's 0 to 25 being the number of buckets there-- so there's a trade off there. You're wasting a huge amount of memory But that would then So in that sense, if we have the function ensures we do actually obtain that that takes one or maybe three steps Now, to make this clear, how do we Well, here again is the struct we and a person had a name and a number. Here, for a hash table, we might do We might now have a node in a hash person's phone number, and a in that chain if needed. Hopefully this is going to be null But we need it just in case We've seen in our pictures the names, We didn't see the numbers. But that's what's inside of But that node would give us what we Meanwhile what is the hash table itself, Well, it's really just a variable. We could call it table And each of the locations in here, at least in the simple, small So it's null if there's a valid address of the first So this then is a hash table. And each of those nodes, to be So what's the takeaway Ideally, with a good hash of inputs where you're not presented all of the friends whose names ideally what the hash function The input is going to be someone's name. The algorithm in the middle is And the output is the so-called So, for instance, in the case when we had just 26 buckets total, would be Mario. That hash function at the first letter, M in that case, I did the same thing. But in my head, whenever I pulled out I figured out, OK, that's location 0 out Here we're doing it And so someone like Luigi meanwhile These numbers would though, if we're looking at 1, So with that said, if we were to a hash function? I did it physically by Here is how we might using C. I could have a function called char star, a name of which like the first word in their name. We want this function ideally in this case of 26 buckets And how do we achieve that? Well, if we use our old friend ctype, from a couple of weeks back, we could capitalize it, which is going to on up for the 26 English letters. And if I subtract 65, single quotes because it's a char-- that's going to mathematically give me There's a potential bug. If I pass in punctuation or bad things will happen. So I should probably have but this is the simplest could implement a hash at the first letter of their name. Probably not ideal because I can think the same first letter of their name. Whether this is better or worse than letters, it's going to depend on and how much time you Let me tweak this though a little bit. It's conventional in that if you're passing in a string and you have no intention of letting you should probably declare the And that will tell don't let the human that actual word in this function. It's just not their place to do so. And we can actually do something else. In a hash function because you're using as a location in an array, it had or positive. And so, technically, if you can specify that the int that's being it's 0 on up through It is not a negative value. So this is slightly better where we didn't have All right, so what does this You don't get to necessarily on the names of your friends. Presumably, Apple and chose their hash function independent So ideally, they want to pick a hash big O of 1. But practically unless you get really lucky with the really it's big O of n running time. Why? Because in the worst possible scenario, But in practice, ideally-- and this is a little have a uniform distribution of have names starting with and and then dot, dot, dot Z. That would be Technically then, your for searching it or would technically be big k is the number of buckets, a constant. So it's technically big Now, again, per our discussion of big O You get rid of constant factors. So, yes, it's 26 times faster. The chains are 126 the length. But asymptotically in terms of big And here's where now we from what is theoretically right In reality, in the real world, if you and others, 26 times faster is even though a mathematician might But it's not. The real world wall the number of seconds passing is a much better running So here too we're getting to the to become a little more sophisticated. It's not quite as simple It depends on what But ideally and literally if somehow function, big O of 1 would would really be the And what you'll generally is that you don't use hash as just look at the first letter. And, honestly, they won't and the second and the third letter. They'll use some even fancier on the probability of collisions so But most of the time a really good hash will be darn close to constant time, dictionaries one of the most universally Now, with that said, we have time for And this is not a typo. This one's called and try. And a try is short for retrieval, which But you say try. But that's the etymology of try. And a try is of the of all of these things, whereby So a hash table is an A try is a tree of arrays. So at some point computer mashing together all of and let's see what comes out of it. But a try is actually And what you're about to see is a big O of one time, constant time. But there is a downside. So in a try, every node is an array. And every location in represents a letter of the alphabet. But you could generalize In this case, if we have a is technically a big And if you want to insert names or words is this. You hash again and again for every letter in your word. So what do I mean by that? If we've got 26 elements be representing A. This And initially these are all null by But suppose I want to insert a Toad for instance. T-O-A-D is the name. So how would I do that? I would first find the location for And if this is T, what would I then do? I would change the null to actually Another array. And then I would go and hash on the second letter of And then I would set a in my tree, which would be represented Then I would find the And I would create finally a fourth the fourth letter of Toad's name. But because Toad's name I already have four nodes here, though we could probably I need to somehow indicate So it's not null per se, this actually structure. But I did this deliberately might be Toadette in the Nintendo World. And Toadette, of of Toad, that is, it's longer So Toadette could continue. And I could have another node for another node for the second T, But I somehow have to mark that So even though they the fact that there's two green boxes in this dictionary as a key as And technically speaking, too-- it's not just a pointer. It's probably Toad and address and the actual value of this too is in fact a dictionary. A dictionary is just an abstract data just like I claimed a And how you implement it can differ. You could implement it with a hash as we just did, or you can implement a And let me add one more name a valid name from the universe. T-O-M just means that, OK, that name Now, what is the implication in this way, which is implicitly. I'm effectively storing Toad and without actually storing T or O or I'm just implicitly by actually using valid pointers And so what's the Well, encode it might look like this. Every node in a try is now redefined and I'll call it children just to and that in each of these nodes there for instance, a.k.a. So what does this mean? Well, if there's actually that's equivalent to If you actually see plus that means there's a green box Or Toadette's number is down here. Or Tom's is over there. But if this is null, that just means or the E, which are not So that's all these nodes actually are. And if we think back now to what this is in fact a data structure that Why? Well, all we need to keep track of this called try that's a pointer to the of the try. And when it comes to now thinking what is it? Well, if you've got n friends or if there's n keys how many steps does it Well, whether I have three names, Toad, in that data structure, how many steps T-O-A-D. How many steps for Toadette? T-O-A-D-E-T-T-E. Eight steps. How about for Tom? 1 2, 3. And, frankly, I'm sure there's probably a limit on the number name. Maybe it's 20 characters total There's some fixed value. It's not unbounded. There's not an infinite in any Nintendo character's name. So there's some constant value. Call it k. So no matter whose name it's going to take But k is a constant. And we always said that big O of So for all intents and purposes, even here, searching a try, inserting is constant time. Because if you have a billion it's going to take up But it does not affect how many steps it That depends only on the which effectively is a constant value. But there is a downside here. And it's a big one. In practice, I daresay most would actually use to implement dictionaries, What's the downside of this here And this is just a representative All the space it takes up-- I mean, even for these three names, look So they're null to be sure. But there's 25 unused spaces here, 24 unused spaces here. And what's not pictured is if this thing's just going to blow up with even though there's not going with like Laa or Lba or Lbb. There's going to be so many where it's just going to So it takes up a huge amount of space. But it does give us constant time. And that then is this here trade off. So I would encourage you here and so much of today's code will soon be reduced in line of code, two lines of code. Because Python and the have implemented all of this week's ideas for us, we'll be able to operate And just think about what and how we want to do so algorithmically And data structures in Has anyone recognized this Anyone? What are we looking at? AUDIENCE: Is that Sweetgreen? DAVID J. MALAN: So this is And this is actually a dictionary Why? Well, if you buy a very they put it on the shelf for you if in advance. And if I, for instance, it would probably go If Carter were to order a salad, And so they hash the salads to a particular location on the shelf. Why is that a good thing? Well, if it were just one long it would be big O of n and for Carter and Julia to find theirs. Because they've got 26 It's one step for any of Except, again, in to might this system devolve at like What could go wrong? AUDIENCE: A lot of people with order a salad. DAVID J. MALAN: Yeah, a lot of of their names might order a salad. So there's lots of like D, D, D. OK, well, maybe we overflow to E. It overflows to. F What if it overflows? Then we go to G. And it list or really multiple arrays that I've even been to Sweetgreen And sometimes the staff just don't They just put what's closest to them. So you have to search But you'll start to see now that you've that data structures are everywhere And among the goals of CS50 now are to So that's a wrap. We'll see you next time. [MUSIC PLAYING]