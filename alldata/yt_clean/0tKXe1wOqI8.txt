&gt;&gt; In this episode of On.NET show, I'm going to have Jeff from talk about some of the core features [MUSIC] &gt;&gt; In this episode I'm joined by Jeff from He's going to talk to us So Jeff, why don't you little bit about who you are and &gt;&gt; Sure. So I have been I've wrote a bunch of books and Now, I'm a software architect helping to architect these SDKs consistency with any language &gt;&gt; In a previous episode, we had some other folks on and they talked to us a little bit about, why do we have these new SDKs and what are some of the This particular one, we're going So my understanding is that like cross-cutting features that span across these different these different services that some common patterns and techniques that we might want to &gt;&gt; Yes. &gt;&gt; Yeah, okay. &gt;&gt; Yes, so I begin. So in some previous we noticed that there are some core Cloud-native that you really want every When you're using one you are building a your client is talking to So we created this thing called an HTTP pipeline which is extensible. The way that it works, I'll So in most of our SDKs, you'll be creating some client, like a blob client, or or event hub Client, or so on. On those clients, there's Those methods ultimately end up That's going to go to It's HTTP client but this Then the HTTP client is going the particular Azure service communicate with and that's Then we're going to do send it back as the Well, we want to have some certain behaviors that That is, these behaviors are the same method regardless of So we've created this thing called the definition of it is it's and we have a bunch of policies that are pluggable into the pipeline. For example, one of the and this is in that the whole implementation of the pipelines is in the One of the policies we have So when the HTTP request object is moving down through the pipeline, this goes and adds a header to the HTTP request with a unique client request ID so Then it would move to another like the authentication one. Now, I know in the previous episode, Adrian and Alex talked about our credentials and our authentication In the next episode, Scott's going to present So he'll talk about But we have lots of authentication and how that affects the HTTP requests as the pipeline is impacted Then we have a logging policy, where we can log the outgoing requests has occurred and then we can see the So we can see how long it Then distributed the previous episode was also where you can wire in you can go and send it some other storage system. So the request travels these policies and then ultimately When the service replies, it gives back an HTTP response backward through the pipeline going through these So it would hit the So now the distributed has completed and it and it can go and hit logging and to log that the Some of these policies don't like authentication or and then the response would eventually make it up to Now, we have a few other policies One is called a &quot;Buffer Response&quot;. This is used for HTTP responses that's usually JSON or XML. Unlike blobs which is binary data. The buffer response policy from the service and so that when we get to the top of the pipeline we can de-serialize that into model objects that we then Another policy that we complicated of all the policies So if while making a request then the retry policy would catch that exception and then can actually issue the the HTTP request message back through the policies So another way of saying it is, everything between will execute once per try and everything between the retry will execute So we have some optimizations Also, for this buffer response. When we're reading the it's possible that the If that dies, then an error happens that error will be caught Again, I can reissue the request So what we're trying to do with this mechanism is make it so a very reliable and robust to failure even without you having to you just get it for free by Now, I mentioned at the top left of the slide that this is an By that, I mean that you can actually create and you can plug them We have two places where We have a place called whatever policy you some base class and you can insert it here and then it will execute We have another place them in which is Any policy you plug into this location will So it's a super-powerful mechanism. It's actually quite simple in its implementation and makes your application very &gt;&gt; That's interesting. So as this animation you have here. This reminds me a lot of where I have the ability to plug into a pipeline and where I I can expect messages coming I could do logging, and caching, and tracing, on all of &gt;&gt; Yes. &gt;&gt; Is that similar middleware? &gt;&gt; Yes, this is a very This is for outgoing and &gt;&gt; Got it. &gt;&gt; Messages coming into the service. This is outgoing from a client. &gt;&gt; Got you. &gt;&gt; Yes, quite similar. &gt;&gt; Okay. Also, like you have a lot of built-in features here that I can, like I just don't &gt;&gt; Yes. &gt;&gt; When we talk about being able to handle things like and having into retries or authentication and I really just want to focus whatever code I'm necessarily some of these &gt;&gt; Yes. &gt;&gt; So it's good for me that I'm totally fine with Microsoft &gt;&gt; Yes, and over the some of them have offered like retries and some But now we provide them for all these SDKs that a very consistent way with a clean architecture that allows customers to &gt;&gt; Okay, awesome. So then my own custom policy if I wanted to and plugins somewhere &gt;&gt; Yes, and in fact, I have a &gt;&gt; Show us that. &gt;&gt; Okay. So here in Visual Studio, I have some C Sharp code where I can show you how to That's just taking the policies But I will also demonstrate about which is inserting So first, I want to start down here. Usually, where customers our client libraries is that In this example, I'm creating a blob service client and I'm passing it into it a URI and I'm passing These credentials will end up that authentication policy You can also pass in over here to go and Now, the options are optional. So you don't have to pass them, and a lot of times customers don't, in which case when you underneath the covers it That's all with like default retries and so on. But I do want to show here So here in &quot;Main&quot;, I'm going to new up a blob Then I'm going to go and So there's a retry section in there. I can go and set the Here I'm setting it to 10. The maximum delay for each retry and there's various I do encourage you to and look at them, and Then here, I'm turning the logging on because it defaults to So now once I've created this options object and I can then pass that to But before I do that, to demonstrate what on the &quot;Options&quot; I can also To this method, I pass into a some policy object and I have This class called it derives off a base class which Then I override this virtual This method will be called as your HTTP request goes You get to execute some code upfront. Here I'm just going to call made it to here and you'll see Then I call &quot;ProcessNextAsync&quot;, that's a method I had heard from the base class and I pass the message down and the pipeline onto the Then, when the HTTP response returns, the code after this will execute. Again, I'm just going to do can see the response So you can see how really simple it is to go and define just to override the one method whatever you want it forward it on to the next &gt;&gt; Cool. &gt;&gt; So now when I call this add policy method I'm newing and then I have to tell I want this to go in or the Per-Retry section Here I'm saying Per-Call, so it will execute only pose to Per-Retry which &gt;&gt; So let's talk about that. &gt;&gt; Sure. &gt;&gt; Part for a little bit. &gt;&gt; Okay. &gt;&gt; So I can just you showed us a little while ago. So we know that retry it happens at a certain point &gt;&gt; Yes. &gt;&gt; So essentially what this I want this to happen. So right now what we're looking &gt;&gt; Yes. &gt;&gt; Like it's going to &gt;&gt; So I added it here in So it will happen here Or I could have added it in which case it would &gt;&gt; But those are the two very specific extensibility &gt;&gt; That's right. &gt;&gt; It could either be one of or it could be, again, post-authentication in &gt;&gt; That is correct. &gt;&gt; Okay. &gt;&gt; Now, you can call the so you can add multiple policies or multiple policies in &gt;&gt; Sure. So I another question too. &gt;&gt; Yeah. &gt;&gt; Again, just thinking about how at most middleware Do I have the ability to circumvents Can I shortcut the messages and say, hey, I don't want you to continue. &gt;&gt; You can always insert a policy, and just not forward it on to and then you can just return. So that would be a useful thing a policy for example and pretend that the service you could easily insert one out of every 10 requests &gt;&gt; Sure. &gt;&gt; Then you could build robust against those problems. &gt;&gt; That might also be an interesting scenario when &gt;&gt; Absolutely, yes. &gt;&gt; A mock response for and so instead of going and doing retries and often I could start mockups and responses and say in my integration tests, or my unit test, or whatever the case is, I could have some deterministic responses &gt;&gt; Yes, definitely true. Other examples are things a circuit breaker policy in there for those people who or client-side caching mechanism. So you might look locally and return it rather than So there's numerous ideas of why the extensibility can &gt;&gt;Great, sounds good. &gt;&gt; All right. So now that and I've set up some of the values, and I've added my own custom policy, I'll now new up the Client So now this Client-object has the URI and the pipeline and now I will go and make a call to do something but every call to do something with the Client goes through the pipeline. So when I hit F10 to execute this, you'll see that in the console that our custom policy it was an HTTP GET request, and you could look at other like headers and query Then when the response came and this is all live, Then we see that we've got an HTTP 200 back and it was the what we got the 200 back from. &gt;&gt; Yeah. &gt;&gt; Another thing I'd like very cool if you ask me, is that if you have a Client and then you call a method on it to go and create a child Client from it, if you were to create So here I'm going to create for a Blob that's in and this is the name When you do this, the new create will actually inherit the So all the retries and all and everything is now on this new Client object the Blob To demonstrate that, I will go to the container and tell and when I hit F10 on that you'll see that my custom you can see the delete and we got a 202 back &gt;&gt; That's interesting. So can I have a customized pipeline from a child as well, or is it &gt;&gt; You can, but then you have to create the Child Client &gt;&gt; Okay. &gt;&gt; Don't create it from a parent. &gt;&gt; Got it, got it. &gt;&gt; Whenever you create a Client, you always get to and then you're configuring or specific pipeline for that Client. If you create a Client from another Client then it &gt;&gt; Yeah, that makes sense. Got you, and then you're saying like you were saying &gt;&gt; That's Correct. &gt;&gt; So we're talking about storage &gt;&gt; Yes. &gt;&gt; Key vault, or The programming pattern &gt;&gt; Yeah, it would be pretty much, so since this is an Azure Core, the.NET version of Azure Core works identically across all of our SDK, or Client libraries for.NET. So we hope that people will start and then once you learned it from one SDK you can apply that learning and even if you switch the concepts were still there, and they work in a very similar way. &gt;&gt; Sure. &gt;&gt; Just idiomatic to that language. &gt;&gt; This makes me think about comments I hear from a lot how can I mock out Azure services? So it feels this SDK is a good &gt;&gt; Yes. &gt;&gt; Because when you our services have no local version. &gt;&gt; That's true. &gt;&gt; No local version, no but it sounds like now this is a or community, or some other mocking mechanisms, so that now that we could work we would work with it offline, and eventually when we or reconnect to the major the ability to just use the SDKs the same way we &gt;&gt; Yeah, definitely that's true. Aside from the emulation the pipeline makes it easy to maybe redirect to a local IP &gt;&gt; Awesome. So I have one last &gt;&gt; Go ahead. &gt;&gt; So I'm looking at and it's just reminiscent of so many other things So we already have HTTP Client, when they have delegating handlers, and all these types of things. Why didn't we just use that? Why do we need a new &gt;&gt; So I would say the the delegating handlers are so if you wanted to we would have to create and the best practices for .NET, is that there's one HTTP Client and then you're just re-sharing So that's why we did not use delegating handlers underneath we built this on top of that. &gt;&gt; Got it. &gt;&gt; It's more efficient really, we're using resources &gt;&gt; So you'd go ahead and and that's just one concern I don't really have to &gt;&gt; Yes. &gt;&gt; Cool, that sounds good. All right. So again, just like before I want to make sure that anybody we're going to have some of these and make sure we direct them or the right blog posts and samples, so that everybody could go &gt;&gt; Yes. &gt;&gt; Again, these SDKs, these libraries are available today. All right, so you can download them for.NET specifically, but if you look into &gt;&gt; Other languages &gt;&gt; You can do that too. &gt;&gt; Yes. &gt;&gt; Awesome. Thank you, Jeff. &gt;&gt; I'm glad to help. &gt;&gt; Thank you all for watching. I try it on SDKs for Azure, and then let us know what you think. Leave a comment down below, make sure you share and like Thank you for watching [MUSIC]