ROB PIKE: Hi, everyone. Wow. Voice is always so big. Thanks for coming. I'm going to be talking today My name is Rob Pike, and I work First of all, let me give When Go came out in November of immediately fascinated by the concurrency, and wanted them and goof around. But also, a lot of people had And there's a question concurrency's even in the language. What exactly do I mean What is the origin And what is it all useful for? And today I'm going to talk I'm mostly going to talk about But I need to give you So if you look around in the is a lot of independently You see people in the audience tweeting while I'm talking There's people outside, All those things are independent will, inside the world. And if you think about writing want to simulate or interact single sequential execution is And so concurrency is really a your program to deal with And what I mean by concurrency, composition of independently And I want to stress that structuring software. It's a way of thinking about how can interact with the real real world or behave as an agent and be a good actor in Concurrency is really Although a lot of people got when Go first launched, a lot parallel language. It's not really a parallel It's a concurrent one. And one to realize the if you have a concurrent piece that uses the concurrency concurrent language, but you processor, then it's certainly because it's not executing But it can still have concurrent And even on a single processor, useful way to model the Now I actually give a talk at Heroku conference, which you can about in great detail about what concurrency and parallelism. I don't want to spend too But I want to stress that I'm here, not parallelism. And just to stress this, software construction. And the reason it's valuable is real world, you have to figure to do that. And concurrency and features other languages, are They're easy to use. They're easy to reason about-- which is really important, an expert to use them. You can use the concurrency understanding all of the and threads and condition stuff that people often think program parallel or concurrent It's just not true. You can work at a much higher for yourself. And in fact, a lot of people concurrent programs who've programming before, and they quite easy to do. Now to many people, as I said, concurrency stuff seems kind It's not actually totally In fact, there's a very long and programming languages that listed some of them here. The most important one is actually recommend every world should read, is by Tony &quot;Communicating Sequential fundamental paper. All the real ideas And all these other languages paper to construct real Probably the most original was this thing called Occam, language for the transputer. It came out in the early '80s. You've mostly probably And there's another branch that languages like Newsqueak There's also Concurrent ML, done actually a lovely language. It's a functional language, It's kind of amazing, but it's depth that some programmers But it is a beautiful Go is on the branch of the And the thing that distinguishes of these others is that it has first-class value. In the original Hoare CSP, you process by name, and that's still works today. But in Go, instead you don't You talk to a channel, and the some other thing that could be sending to it. And one way to understand that original CSP idea is a little name, whereas in Go, the channel writing to a file descriptor. And the level of indirection kind of important to a lot But I want to stress that better than the other. They're actually formally You can write one form in But Go definitely is So enough of this sort of Let's actually show some code. Now one of the problems with programming is that the ideas never seen them before. And people tend to write demonstrate them. And I don't want to do that. So instead, I'm going to make really boring things. So these are going to be really they're going to use concurrency a little less interesting. And this gives it a focus on the boring elements that concurrent. So here's a particularly All it does is print very second, la la la. Now I'd like to stress, is that every time I hit the run HTMI5 presentation-- it compiles the binary out of this window talking with a web And it's all done in Go. By doing it this way, you get running, and you also trust that really what I'm showing you. It's really important for the things come in. So let's make this program a in a random sleeping interval so deterministically, so there's a OK. Pretty boring program, right? You still with me? All right. Now let's run this thing. So it's pretty easy. Here's the whole program except the top, and there's the whole thing, and la la la. OK. Extremely boring. Good. Now boring things are things So let's ignore that. To do that, we run the boring I&quot;ll talk a little bit more But for now, just think of a to launching a shell command of the line. It says, run this function I don't care about it. I'm just going to keep So let's run this. Something went wrong. That's not actually a bug. This is actually what Go does. What happened down here is goroutine, and then main we didn't have to wait. But the way it Go is defined, actually exits. And so this is sort of a deliberate. When main returns, the But it also confuses So I put it in the very So when you run the program, it the program returns So let's make that a little something after we launch So here we launch it, and now out, wait for a while, So now you can see that, in boring function and the main Right? Very, very simple. So what are these goroutines? Well, it's an independently You can think of, when you run for the function to complete, The goroutine says, run the wait for the answer Just go and execute So this is the sort of So in Go, concurrency is the executing goroutines. It's got its own stack. And the stack actually grows So unlike some threading say how big the stack is, it's You don't have to say how It will be made as big as it grows, the system will stack growth for you. And they start out very small. So it's very cheap and practical even tens of thousands of And I'll show you an example, way more than that. And we've even seen large jobs millions of them. So they're very, very They're not threads. However, for the point of view not misleading to think of a cheap thread. Because that's really, in What happens in the runtime is onto threads that are created sure no goroutine ever blocks. So you just launch the to think about it. And that's kind of the point. Now our example that we ran goroutine, printed a bit, was actually a cheat. Because the goroutines were they were not communicating or in any way. I just started this guy, this one kept running, which isn't And so to do a proper concurrent to be able to communicate goroutines inside it. And to do that, there is a And as I mentioned earlier, fundamental concept in Go. And they're first-class values, interesting. And we'll use them to do But the basics are very The first block there shows initialize a channel. So var c chan int says declare type channel of integer. And channels are types, so the have a static type, in integer, default integer. And then to create a channel, initialize it by saying And in Go syntax, you typically So those two lines above are := make chan int. And you tend to see that kind When you want to send a value left-pointing arrow operator. And so this sends the value And then to receive it, you side of the c, and now the channel, so that's a So if one goroutine says c goroutine says, receive from That sends this 1 into the into the variable. And the way to think about the arrow points in the direction sending data. So here, the 1 is pointing Here the arrow's pointing out of it to the value. So let's use the channel Let's make this program we have So here's our main function. And now, this time in a loop, say some value, and here is that which we made up here. And then in the boring function, forever, sending a printed So if we run this, you can see for five times, it says that. So this is honest, right? This main and the boring executing, but they're in the strong sense. So there's a point about what's is, obviously when you read from wait for there to be It's a blocking operation. But also when you it's a blocking operation. When you send a value on a until somebody's ready And so as a result, if the two this one's sending, and this they're doing, when they finally the send and receive are a lockstep position. Those two goroutines are at the send on this side and the So it's also a synchronization and receive operation. And channels thus synchronize in a single operation. And that's a pretty Now for those experts in the channels in Go-- which exist-- channel with a buffer. And buffered channels have the synchronize when you send, value in the buffer So they have different And they're kind of subtle. They're very useful for certain don't need them. And we're not going to use them today, because I don't want by explaining them. But the thing about buffered like mailboxes in Erlang, so mentioning. OK so given this idea of synchronization that Go's approach to concurrent software as, don't communicate Share memory by communicating. In other words, you don't have put locks and mutexes and to protect it from Instead, you actually use the and forth between the goroutines concurrent program So based on those principles, what I call, concurrency quotes because I don't want you like object-oriented patterns. They're just very simple, interesting things. So the first and probably most is what I call a generator, returns a channel. So all of these examples for the to be variants of the things I going to do them in So in this case, what we do is and we give it a return value. We say that this boring function channel of string, and this return value is a channel that because the main function is received value. So in this case, in the main function, and it returns And then this is the We just receive and print the And in the boring function, forever, with the goroutine actually launch the goroutine boring function itself. You can see here, This is a function literal. So this is the loop that we had inside an anonymous function a Go keyword at the top. And so this starts the back to the caller the channel that process that's running, And so from the outside, this whose invocation returns a actually starts a computation So let's run that. This will behave exactly the much nicer pattern for And in fact, this is very much We could use multiple instances function, give them different services, each of which So here's a simple example where boring function twice, and then value from Joe and And it's exactly the same boring We're just using it in So you can see, you get a 0 from and Ann, a 2 from Joe Now inside here, we're reading a value from Anne. And because of the channels, the two guys are printing the values out, but Because if Ann is ready to send done that yet, Ann will still be the value to main. Well, that's a little annoying talkative than Joe and doesn't So we can get around that by multiplexer. And to do that-- here's this fan-in function-- we actually stitch the two guys function and construct a single can receive from both of them. And the way to think of it is Here's Joe, and here's Ann, And then the fan-in function and values from Ann and just output of the fan-in function. Right? And to do that, again, it's The fan-in function is that returns a channel. It takes two channels as input, as its return value. And what we do is, again, make But internally, we launch two copying the output from input1 one copying the data from So when we call fanIn of boring remember, they return They become the arguments to the we launch two more goroutines And so we run this guy. Ann and Joe are now completely And you can see, when it runs, necessarily sequential order. Because there's Joe gives three there, before Ann had anything OK? So that decouples the execution So even though it's all independently execute. So what if, for some reason, we We wanted to have them be synchronous. Well to do that, remember I first-class values in Go. That means that we can pass And so we can send inside a used for the answer To do this, what we do is we that includes the message that include inside there another wait channel. And that's like a signaler. And the guy will block on the says, OK, I want you So let's see how that works. So here's our main loop-- again, just five times We receive a message from the this is, again, the fan-in other side of this. Receive another one and print Now notice that this is They have channels inside them going to be used to So inside the boring functions, wait-for-it channel, and then a signal to advance. So when we run it now, you can because even though the timing here, with message1 wait and independently executing guys channels for the signal Now that's all fairly simple We can make it a little more part of concurrency in Go, which And the select statement is a like a switch, that lets you program based on what proceed at any moment. And in fact, the select key part of why concurrency is the language, rather than It's hard to control structures that depend on libraries. It's much easier this way. So here's how a select It looks kind of complicated. There's a lot of text But it's really pretty simple. A select statement looks It's got a bunch of cases. And each case, instead of actually a communication. So you can see, there's receive, and a send. And what happens in this select come to the top of the select, channels that could be used for cases, and then it blocks them is ready to run. And once one is available to the whole select goes on. So it's much like a regular blocks until a communication And there's a default that you If there's no default, then the until the channel can proceed. If there is a default, what proceed right away, then just And this gives you way to do We're not going to depend on make sure you knew So it's really pretty simple. The only other sort of wrinkle channels are available When that happens, the select pseudo-randomly. So you can't depend on the communications will proceed. Those of you who know Dijkstra's will recognize the It's very much like the guarded Dijkstra's commands. So here's our fan-in function. Same functionality, but now So here's our old guy. This is exactly the function And here's the new one using If I go back and forth, you can original guy started two channel to be copied The new guy starts a single got that generator pattern. But instead of two copy loops, selects which of the two is appropriately. So this has exactly the same except that we're only launching the fan-in function. Same idea, different Now we can use selects of interesting things. One of the most important is communication. So if you're talking to somebody chances are you don't want to around to saying something. So in this case, we can simulate function in the library And here, this select statement get a message from Joe, or a hasn't said anything, just get out of here. So time.After is a function that returns a channel that will specified interval. So in this case, either we get by, and we don't get a message, So if we run it, you can see, And then he takes too long to OK? I think it always does this. I think I forgot to seed it. It's always saying All right. But you see the idea. We just keep going around this Now you can do that We might decide, instead of each message is at most one total time elapsed. And to do that, we can use the directly by just saving it using it inside the So in this case, this loop, this after five seconds. So it doesn't matter how many After five seconds, Boom. OK? So that times out The difference, here, is we're Here, we're timing out the Now another thing you can do using a timeout, you could say, OK, I'm done. Stop now. So here's our inner loop again, inner loop. There's the send But we actually have a second And what we do there is in the quit channel. In this case, it doesn't I just picked bool. And then after we've printed as has to say, we signal I'm done. And so at that point, this case guy's not communicating and So again, this is the same But now after only two decide that's enough. We tell him to quit. And so the quit case executes returns, and the boring Now there's a problem with Because in here, in this case, done, he needs to do something So he gets the message to stop, cleanup functions to do. Remember that when main returns whole thing shuts down. Maybe he's got to remove something like that. We want to make sure that he's exit, and so we need to do a communication. And it's very easy to do that. We just turn around and say, you're done. And so in this case, we say message on the quit statement, you, OK, I'm done. And this gives synchronization sure that they're both where So in this case, you see we tell quit fires. We do whatever cleanup Then we respond. But now we're telling him that it's safe for him to exit. And this is a round-trip Now speaking of round-trips, we having a ridiculously long talking to another one. So think of it like this. You've got a whole bunch of Chinese Whispers game, although Whispers with megaphones make it a little weird. But you see the idea, here. This guy's sends a message forwards it, forwards And the last guy receives the Now I want to stress that This is just going all the way answer here. And to make it interesting-- this is the gopher here-- what he does is receive sorry, receive from the is where it's going. Coming in from the right. Sending to the left. So you receive on the right. And then we make it a channel going to add 1. And the reason for that is, that of steps, so the distortion in we add 1 to the value. And I'm not going to details of this code. This is actually sort of subtle, explain it all. But all it does is basically channels to send the And then everybody's first thing to be sent. And so we launch the value into then wait for it to come out So it goes, vvvvt, around And for the sake of fun, I'm Now remember that I'm going to and then run it. And it takes that long to do communication. [APPLAUSE] ROB PIKE: Those are OK. Now this is obviously it's an honest one. Because I really am creating all the full communication and So you can think of goroutines lightweight things. They're even smaller OK. But so far, everything we've And I want to stress that Go system software. And I want to talk now about construct the kind of software Now we did this at Google, and build a Google search engine. Sort of. It's still going to be a toy. I can't develop a Google search about a half an hour, and But we can start. So think about what a If you're going to the Google you get a bunch of And some might be web pages, could be song clips, or weather There's a bunch of independently ends that are looking at that results that are interesting. And there might also be some running, too. And so in parallel, you want out to the back ends and then and deliver them. How do we actually Well, let's fake Let's construct a thing called fakeSearch is going to do is return whatever the fake answer is very uninteresting. It says, here's your result. But the point is that there's And it's actually a function. So notice here, this search is and returns a result. So that's sort of a type actually does. And we construct these functions and a video service. OK? Very simple. All they do is pause for a And they're set to wait for So let's test it out. So here-- this time I'm going to seed the so the values are always And we start the timer, get the and then print out OK? So if I run this guy, you can Now remember, each of these guys 100 milliseconds. So we could see up to, like, There's 160. There's 94, that was 213, that was a slow one. So these are actually, you OK. Now let's make it an actual real of the values back, right? So here, we actually have this query and queries all of the the results together and returns results, which is-- think of it as just an So here we run this guy, and three things, taking gather all of the data. OK. Trivia, right? The problem is that if you running one guy, waiting for running another one, waiting for running a third one, waiting for Well, you know where Why don't we launch those So now for each of the back a goroutine to do the search, is the fan-in pattern-- get the data back on And then we can just print So they're going to come out of to get all three of them back. But they're running parallel, in this case. And so we don't have to wait So there, we see, That's pretty quick. 88 milliseconds. Now we're really only waiting slowest web search. 15 milliseconds. There you go. So that's pretty cool. And notice that this is a multiple back ends running. But we don't have any or condition variables. The model of Go's concurrency intricacy of setting up and Now sometimes, servers They can be really, So remember, we set these Once in a while, an individual milliseconds. And let's say we don't want to milliseconds for the We want to use the timeout So here's the fan-in pattern, whole conversation. We run this guy now, and That was pretty quick. 44 milliseconds. You see, these are They're typically 80 what they should be, because But if I run this there. We timed out because, in queries took too long. And so all we got back We didn't get the other two. And that's a kind We know that we're going to be within 80 milliseconds. However, timing out a communication is kind of annoying. What if the server really is It's kind of a shame to So now we add replication. So if we run three instances of one of them is likely before the timeout expires. If only one of them is having a all be efficient. So how do we structure that? Well, here's our familiar We actually write a function query and a set of replicas-- this is the Go notation for so we have a bunch of replicas to do, for a single search. Like, replicas of the web search image search. And we make the channel And then we launch the same return the first one See, all these guys are going we're only going to return the And so this will give us the back end guys. So here's a simple use of it, And that time we got replica Replica 2, Replica 1 in 24. So you can see, it's whichever There's five milliseconds. And with that little tool, now, piece, which is to stitch all So this is Google Search It's got everything in it. It has the fan-in function, it's end stuff, it's got a timeout And so we should, with very, all three of our web search milliseconds. So there's 40 milliseconds, You notice, they're There's no timeouts. 18, 39, 51. And this is obviously But you can see how we're using Go to build, really, a fairly replicated, robust thing. And that's kind of Because it's very simple There's still none of that sort barriers and nonsense that approaches are aware of. And there's no callback, so this using, like, node.js, or That program is fairly More important, the individual all just straightforward And we're composing their us the behavior of So to summarize what we just did very simple program that was failure-sensitive, at least And by using the concurrency stuff run quickly, concurrently, way, and with much And this is sort This was actually why features went into Go. It's because it makes it easy without worrying about safety It's just a very much more constructing what I loosely There's all kinds This is barely, barely touching there'll probably have to be a more rich examples using haven't shown you today. But there's lots of talks independent things about using some interesting problems. There's a Chatroulette toy, that has a fairly amazing little you should probably check out. A couple of years ago at I/O, I balancer which uses channels construct some pretty There's a legendary example Sieve, which is kind of It was the first truly beautiful think I ever saw. But it's completely dwarfed by who's my old boss at Bell Labs, power series library using a And it treats the coefficients a channel, sequential And using some very simple just showed you, it manages to mathematics that is very, very It's really rather beautiful. So there's the links if you Now having just said how to throw out a word This stuff is fun. It's really fun to write your play around with this stuff. And you should definitely try how they behave. But don't overdo it. These ideas in Go and, for languages I mentioned, are not like memory barriers to protect the innards of software. They're really sort of things that you use to take them together into larger They're big ideas. They're really tools for Remember, I said concurrency construction? These concurrent tools are construction. But sometimes, you don't If you need a reference counter, with a channel on a goroutine. It's fun to do that But I didn't show you that, that's a silly example. It's using much too heavyweight simple thing. So Go has these packages in atomic and-- what was the Sync and sync/atomic. And they contain these low-level reference counters when And sometimes it is So you have to balance the you're doing. Glue together the large things you, but sometimes if all you of times somebody hits your reference counter. So as always, you should use So in conclusion, goroutines concurrent features of Go. And they make it very, very easy concurrent software that solves that include things like having multiple outputs, independent replication, robustness. All those things that are sort programming landscape, Go to manage very, very well. And it's actually-- even if you're dealing with kind of fun to work with. So here's some links for you. I think that's the last slide. I'll just leave that one up so the question period. The Go home page, golang.org, resources, videos, the language documentation, of which there's lots of second-order documents and stuff like that. And then at the bottom and bottom here, there's this the Heroku conference earlier is not parallelism, which also are a little richer than some of today, because today concentrating on the basics. So with that, I'll stop and [APPLAUSE] ROB PIKE: Go to the microphones, the people at home AUDIENCE: So one question I I think, that competes with Go Haskell, which I And Haskell does feature some speculative parallel operators. I was wondering if those might ROB PIKE: Haskell is a It's a really lovely language. But it has a very, very And I think, to my mind, the for free with Haskell, but the is the lazy evaluation And I think it's an excellent I don't think it's a And in fact, Doug McIlroy took example and rewrote And it's a very beautiful understand at all. But it's very beautiful. So I'm not trying to make I'm really not, because it But I think that the key point features work in Go is that they a language, also works. And you can't just borrow a and stick it in yours and That art of choosing language is part of it. So this is not to say aren't really powerful. I just don't think they're And if it turns out that they should go in. But offhand, I don't think Yes. AUDIENCE: Can you comment on goroutines? Because it seems like you're Or are there mocks Or how would you ROB PIKE: So best-- it's hard to hear you. So best practices for testing AUDIENCE: Exactly. And for testing goroutines. ROB PIKE: Best practices. Write good tests. [AUDIENCE LAUGHS] ROB PIKE: Are you worried about AUDIENCE: Well, It seems like, as external services, you're integration testing. ROB PIKE: Well, one of the let me back up here. It's actually kind of a the language works. So let me find the example Where is it? Actually, I went back I could have used a Here we go. Look. Look at this guy here, The total interface to this Nowhere does this function here has behind it. It's just this function that's doing something. It could be an arbitrarily And once you realize that that capability to a service, you can simple thing. In fact, this might be a mock values at arbitrary intervals. So I mean, it's a perfectly tools I've shown you to do You don't need-- the whole idea of a channel what's behind it. And so that's mocking, You've got it. AUDIENCE: Right. Because it's a first-class-- ROB PIKE: It's a first-clas AUDIENCE: --that's your mock. ROB PIKE: Right. AUDIENCE: Thanks. ROB PIKE: Cool. Sorry. Let me get to the slide you There we go. OK. Yes. AUDIENCE: Hi. My question is somehow related you take concurrency as a For instance, in typed language, analysis of the types, runtime everything works right. Do you plan on doing something Signs in a way that-- OK. If you do this, you're going you keep doing this, you're are going to have a bottleneck these patterns. Do the Go compilers go through the concurrency properties ROB PIKE: I'm sorry. I'm having a really hard time speakers are pointing and I'm behind them. You're asking about the static typecheck that kind of thing? AUDIENCE: Go is great for but do you plan or do you do that concurrency, either ROB PIKE: OK. So you want to know verification of the thing? For that kind of thing, I think the way to go. There's a thread sanitizer I don't know if it's Is it out yet? Yeah, it is. It's from Google. And they have support for And so you can embed the the world inside your program, data races and stuff like From a communication point of thing that Gerard Holzmann did, is a really good way to model static checking. And a long time ago, Gerard statically verify pieces of communication and synchronization stuff using SPIN. And I've been thinking of asking him to support Go's read a Go program and generate a it statically. And I think that's actually but it hasn't been done. AUDIENCE: Thank you. ROB PIKE: Please speak so I can hear you. AUDIENCE: So I have I hope it's OK. You showed us a read from a select and inside a loop. Say I wanted to write How would I know from the other has fallen out of scope so as waiting for the read. ROB PIKE: You mean, so this guy, if the timeout what happens to him? AUDIENCE: Yeah, and what happens on the other side. ROB PIKE: It'll get AUDIENCE: So-- ROB PIKE: So if you want to richer example, and this is not complicated thing, you want to That's this example AUDIENCE: No, I actually want If I'm writing the time.After and then write to ROB PIKE: Right. AUDIENCE: But the write locks ROB PIKE: Right. AUDIENCE: So if it, instead of and the channel falls out of there, and then I will be ROB PIKE: Yep. It's actually-- there's more subtlety I mean, you shouldn't about it at this level. That's the short The time.After function uses slightly more sophisticated stuff I've shown you. If you really care about when then you have to write more of the stuff I've shown you. There is some stuff in the blocking going on behind also hidden from you. In the time available, I can't subtleties of that. That's probably a subject AUDIENCE: OK. But essentially, if I am locked gets garbage-collected, so no will be garbage-collected, ROB PIKE: In many cases, yes. It depends on the specific AUDIENCE: Second question is, of stacks that grow ROB PIKE: I'm sorry, AUDIENCE: The any number independently. ROB PIKE: Yep AUDIENCE: Are you allocating the How do you do that? ROB PIKE: They're allocated and They have a special allocator. They're not garbage-collected because we know more But they're allocated and AUDIENCE: Thanks. ROB PIKE: Sorry. I'm having trouble AUDIENCE: I was wondering structure that you had. You were saying that if multiple the same time, then you rather than evaluating Is there a way to write it higher-priority case if Or would you just have to ROB PIKE: You would nest them. AUDIENCE: You'd put the default ROB PIKE: Yeah. One of the many properties of things like priorities and stuff like that. There's enough power here to do have to write more code, as really complicated. So you can do prioritized stuff You basically nest You put the guys you care they're not ready, then you AUDIENCE: Gotcha. OK. ROB PIKE: This is somewhat question but a little So is there a way, if you create how many readers or writers AUDIENCE: Yeah. there's a to see how many values are in a buffered channel. For a non-buffered channel like the moment to find out writers there are. One of the reasons for that inherently unsafe. Because if you care how many then that's because you're going based on that. But that computation might be doing the computation, values could change. When you have this kind of thing because you know this proceeded, and there's If you say, can I proceed? OK, I'll get a value. You don't know that someone else stolen that value, and you AUDIENCE: Right. ROB PIKE: So it's actually important point there. AUDIENCE: The example I was your main method, you And then you attempt to read are no writers to Or the inverse, you attempt to there are no readers. ROB PIKE: Right. AUDIENCE: Do you just Or-- ROB PIKE: Yeah. AUDIENCE: Does it OK. So it doesn't determine-- ROB PIKE: You'll have to-- you writers, then the first guy to value, is how it works. And it's FIFO semantics. AUDIENCE: OK. Thank you. ROB PIKE: Yep. Any other questions? All right, at the back there's goodies to be handed Please don't mob the And thanks for coming. [APPLAUSE]