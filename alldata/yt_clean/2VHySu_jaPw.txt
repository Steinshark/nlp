If you have watched any Retro Game Mechanics little jingle that plays at the start of each This sound effect is from Super Mario Bros. If Mario spins his tail at the same time he and produce this extended version. The reason this happens can be explained in SMB3 queues up sound effects that are ready We may be able to find an underlying cause Super Mario Bros. 3 fittingly has 3 queues The first queue is for sound effects that These include the jump, bump, swim, kick, sounds. The second queue is for effects that use the This includes the coin, powerup out of a block, 1up, poof, an unused sound, losing Kuribo's The third queue is for effects that use the This includes the breaking brick, fire cannon, and Mario skidding sounds. Each queue uses two bytes to help with managing One byte is used to determine what sound effects The other byte is used to tell which sound Each sound effect in each queue is represented When a sound should be played, its corresponding If more than one sound is triggered in one When it comes to actually playing the sound, the least significant bit and working upwards. This means that sounds that are assigned lesser significant bits. After the sound is initialized, the whole track of what sound is playing. For example, in the first queue, the jump always play instead of the other sounds in Jump and throw a fireball at the same time, However, jumping on one frame, then throwing fireball sound to overwrite the jump sound. This happens because when the value is transferred sounds are halted. This method of assigning sounds to bits makes one sound is played on a single frame. If the sounds were assigned to entire bytes, and this would be dependent on which triggered The one downside to this method is that one for each bit. If they were assigned to bytes, 255 different (assuming 0 meant no sound). Unfortunately, the second queue has a problem. It has 11 different sound effects assigned The first 7 sound effects are assigned to bytes. Combining both systems made for some unintended Let's look at this in more detail. The coin, powerup reveal, vine reveal, cannon were assigned to bits 0 through 6 respectively. However, if the most significant bit was set, bit-wise. The poof sound was assigned to $80, the unused the tail wagging sound $B0. Now in general, this system worked fine. But, the priority system and having two sound of them is treated bit-wise and the other For example, what would happen if a coin sound same time? The poof sound is assigned to $80, and then bit. When both queued together, the entire byte Now the most significant bit is set, so this what sound to play. But $81 isn't assigned to any sound effect! This is the first flaw of the second sound Let's organize everything into a nice table. The values of this table will be which sound value is in the queue. We can fill in the 11 sound effects with their denotes that no sound will play. First let's look at when the most significant the top half of the table. We know the coin sound plays when the least So it will play any time this bit is set, It makes sense that half of the table fills priority out of all the sound effects. Then we move up to the 2nd bit, the 3rd, 4th, Okay, now the other half of the table, when We have these 4 sounds that are assigned specific in. It turns out that while the poof, unused, the tail wagging sound is given to any value Therefore, if the value is not $80, $90, or So the entire rest of the table fills with And it checks out! It's not too difficult to collect a coin on If he does, the tail wagging sound effect Theoretically, you can get this sound to play So, let's look at what happens when we queue at the same time. Tail wagging is assigned to $B0, then the a value of $F0 when combined. Hmm, this table is missing something. We have to discuss the second flaw of the It turns out the 1up sound is special. Maybe it came up late in development, but really important, and it needs to be prioritized It isn't uncommon that the extra life sound and many old arcade games even chopped out However, this feature is quite contradictory in place. Not just that, but the 1up is assigned to Now our pristine priority queuing system is a special case for the 1up sound. It's implemented a little wonky however. We have to delve a little deeper into the Earlier it was mentioned that two bytes were and one for the currently playing sound. When a sound is initialized, the value from the first is reset back to zero. Makes sense, whatever sound we initialized, Once the sound finishes playing, this byte But the interesting thing is when more than Like we already know, only the sound with play. So it will be initialized, and this byte will playing. The same method of determining which sound will continue to play. So normally the same sound will be found each It would never be the case that one sound would be assigned to continue playing. Or would it? The method used to prioritize the 1up sound playing byte, and not the initialization byte. For example, if a coin and a 1up were collected initialized due to its higher bit priority. But on the next frame and onwards, the 1up hardcoded 1up priority. You can even hear it a little when you collect The coin plays for a split second, then the There is one big issue with this disparity. Certain values are loaded into memory when If these values don't match up with the sound mess up. The 1up and coin sounds happen to play nice The major parameter that causes weird things how long the sound effect will play. The 1up and coin happen to be around the same them sound correct. Here are what each of the other sound effects the 1up sound effect. Let's look back at the table we made. We have to update every entry in the table 1up. They all play the 1up sound instead, but a which sound effect would have played without Aha! Now we can see that our point of interest, sound corresponding to the tail wagging sound. But if you think about it, the tail wag sound a long corrupted 1up sound if the corruption effect to another? There's one last piece of the puzzle, and effects. These 4 sound effects are stored in a different They are also stored in a different location effects for sound queue 3. Instead of using a counter to determine how address as an offset within the sound effect So in the case of this one corrupted 1up sound, by an offset into the tail wagging sound data The value of this offset can be relatively lengths. This is why the sound is so drawn out. The notes that are actually playing are actually they are stored next to each other in ROM. The two sounds convert the data into notes but they do use the same data. Side note here: the powerup sound actually because the length parameter supplied to it exists. Here is what it would sound like if it weren't At the start of the video I mentioned the less than 10 seconds. Let's look at the third and final flaw of We'll have to look directly at some assembly We'll start at the point in the code directly has been set in the queue, and the value should First, the Y index register is loaded with It's compared to $80, the value of the poof If it's equal, the corresponding sound data we jump a bit forward. The same comparison is made to $90 for the sound. Then, before preparing to initialize the tail playing right now. If there is, we cancel initialization, and This means the tail wagging sound will not However, if there is no sound playing, we wagging sound, and meet up with all the other At this point, Y still holds the queue value, The data offset is stored into its memory Then, look at this! The accumulator is ANDed with the value $B0. This is done in the accumulator since there the Y register. This AND operation is done to specifically cancelled out in case it was initialized along Since bits 0 through 3 are also masked out, could hold after this instruction--the 4 IDs Then this value is stored into the currently Wait, what? The Y index register is written to this address What was the point of the AND instruction And then directly afterward A and Y are both They were so close to preventing this glitched But for some reason this instruction is an for naught. So the 10 second explanation goes like this: Except it's really half priority queue, half Half of the sound effects conflict with one There was code to prevent it, but the wrong Thank you for watching! If you enjoyed the video, please consider and consider subscribing to the channel. I have everyone to thank, from every single that help support me and my work. It's thanks to everyone that I am able to With all the support I am able to justify So just the fact you are listening to this,