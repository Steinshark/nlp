( clacking puzzle noises ) Shalom! How is life, Ah, that's nice. Anyway, In today's video I am going to show Doom-style 3D engine from scratch. First, some important questions. Why in the classic PC game of Doom when you make a map, it requires of building a &quot;BSP&quot; before the map can be rendered in 3D, while in Duke Nukem 3D's BUILD, you can change the map Why in Duke Nukem 3D it is possible and even non-Euclidean geometry, First, let's brush up on some basic ( changes music to a calm theme ) Let's declare a wall, with two ends. The player also has an X and Y coordinate, Let's create some sample BASIC code Sorry about using such but I have found that BASIC still makes for an And let's face it: never programmed in BASIC, the meaning of this code The yellow line represents the wall, with a small line that indicates In order to make a first-person engine, into a first-person view. This concept should be familiar to about OpenGL programming. Instead, the whole world is moved, around the perfectly immobile camera. Here, we do exactly the same. We can see in the second window and the world moves around him. view. But this isn't 3D yet. The third important step we need to learn To perspective-project 3D coordinates into you take the X and Y coordinates That's as simple as it is. As you can see here, when the player moves away from it There is a slight problem though: partially behind the player, because of negative signs by the perspective calculations. into the program to address this specific Mathematically speaking, Frankly, I am not even sure if I am doing To clip the wall, where it intersects with Finding these intersections involves The vector cross product is like black magic. but somehow it ended up after I read a few Wikipedia articles. The wall only needs to be clipped i.e. one of its Z coordinates is negative. the wall is totally behind the player Now we can see that even when it is rendered properly. You can change the wireframe wall vertical lines in a loop. A meaningful scene should also have many walls, You can notice that ceiling is always everything and floor is always everything below the wall. floor blue. The only way this differs there's now five walls instead of one. This works perfectly convex. there are no dents in it. over all the edge points. Real world scenes, and indeed 3D game maps Here's what happens to a non-convex map. well, it doesn't work right. The engine appears to be drawing Well, that's easy to fix, Let's just reverse And yes, this did fix the error in this very but see, there is now another error, Figuring out how to prevent far-side walls is a problem that every 3D engine A related problem is that consists of thousands how to render only those walls and not spend time that are completely behind other walls? Unsurprisingly to solve both problems. ( fades out music ) let's study how Duke Nukem 3D but could in fact solve both at once, ( begin ambient action music ) This is the Duke Nukem 3D level editor, Let's create a sample map. But suppose we wanted to have than in another part? into two sections, called &quot;sectors&quot;. The ceiling and floor heights can be adjusted separately. This geometry is still all convex. anywhere in the map geometry. Suppose we create some obstacles, though. Now the map geometry contains you cannot see something anymore. However, each individual sector of the map Non-convex geometry is created by joining If you pay attention to you will see that two types of walls, or sector edges: Regular walls, And doorways, or portals, A wall that spans a window through which and finally a wall that spans In the editor you can see the difference more A white edge is one where there's nothing i.e. it's a wall that spans from floor to And a red edge is We call these red edges, &quot;portals&quot;. Now what happens than the floor of our sector? until it doesn't get rendered at all. The upper wall is rendered until we reach their ceiling. start rendering their sector immediately. For the purpose of this video, This map contains multiple sectors, staircases, rooms vertically and even non-euclidean geometry. Going back to my high-tech illustration board, ( paper shuffling noises ) I drew the map on paper, and having done that, I wrote those numbers into a text file. Now I am going to do as far as my videos are concerned. Not C++. But as I was designing the I thought to myself: After all, who love C, but are totally lost So today is your day: with none of those C++ gimmicks. So the first part of this program that I just showed to you, Because the file handling code I sped it up by 200%. in the remainder of this video. Actually, maybe it's just me Maybe I should just shut up and This is the part where I chose to write in C. Oh well. Here is the C version As you can see, several other useful functions. but it does, Now we are getting so please pay attention. Remember how I explained before using vertical lines? used to draw ceilings, walls, and floors, No other graphics functions The rendering will begin All edges of this sector will be processed: The edge is first translated and rotated then the signs of the resulting Z coordinates whether the edge is visible Once we have a visible edge, This transformation is accomplished From the perspective transformations, An X coordinate for the left side of the wall the wall, heights Oh, before that, that I explained at 2:52 in this video. Anyway, from those coordinates, of linear interpolation We will draw three vertical lines One from top of window to the ceiling height, One from the floor height to the bottom of indicating the floor. And one from the ceiling height to the floor indicating the wall. For now, we draw walls with different colors or when they are actual walls. Here's what it looks like! Portals are drawn red. On the right, you can see the map for reference. when the player crosses a sector edge. Now the next step is above and below the portal. so if you are confused as to what's happening, ( music becomes louder as the narrator pauses ) And this is how it changed The lower wall is drawn in magenta. And the window, or portal, is drawn in red. The only thing remaining is To do that, we need three things: First is some means to draw another sector. Here I used a circular buffer Second is the window size. where this sector can be drawn. this area is the entire screen. it is a smaller view: and a right edge (sx2). for each column on the screen. smaller the deeper you go in the view. And thirdly, you need... Wait, I guess you only need This clip shows in slow motion Aside from the familiar colors, You can see quite clearly drawing either a fully white wall, and a magenta lower wall. When all edges of the current sector have it picks one of the remaining red portals, This is the rendering at normal speed. Observe how things like tunnels under the or windows in walls, are supported without On the right, you can see a from-top illustration The current sector is indicated in red shading. Any part of a floor or a ceiling is indicated in green, violet or gray shading, beam. Now I cheated here a little, before it was even finished. For the sake of completeness, so you will not feel cheated. This function, MovePlayer, that the game always knows even as he moves around Calculating the intersection vital part of the algorithm: an edge between two sectors. If you are currently in college or in some other type of school, other advanced aspects of mathematics, calculating the intersection and the edge of the sector -- becomes crucial to your success. Now let me emphasize this: that you learn all these mathematical formulae, skill to identify the type of the answer you are In the case of this program: from a sector to another sector, you need a way to detect Even if you don't know how to determine you can use cool websites to find your answer, like I did. remember the mathematical formula, But if you cannot even identify it would be very difficult You could then try asking in the Internet, but chances of getting a good answer Here's another instance of and looked for answers in the Internet. against the wall, produces a vector that is parallel to the but has a length that depends movement and the wall's direction. This formula is called &quot;vector projection&quot;, This produces the &quot;sliding along the wall&quot; in all thirdperson games today. This simple hack here with the restriction that Now, suppose we want to add A very simple way to do that with a darker color i.e. Z coordinate is higher. ( begins sporty action music ) Compared to the previous version, even though it is still all Now, just for my own entertainment, texture mapping to the program. I also added lightmapping. I am however not feeling particularly presentable, If you are interested though, A link to a page containing all the is included in the video description, and precalculates lightmaps using raytracing. Now as usually happens in programming, Relatively small things can end up consuming There are some errors in this program, causing bugs from time to time. of adding such as health packs or enemies, way to do it. Thanks for watching! See you next time, bye.