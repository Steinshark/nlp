I want to start by going through how some of the things that you're used to, happening in React 19. I'm actually going to We're not going to do any server rendering or Vite application. Just to show you the Vite So, I've got a form and I've got I have a submit handler. So, I have some event and then I have a submit button. This probably React code for some time. The submit function browser from reloading. We prevent the default, update the items that are in this local React of seeded it with this initial state, and then I Let's start this up. Now, this is going to look with this before. I have a list of things, and right? Pretty simple. This is kind of the right? Everything is stored in useState locally, gone. It's not being persisted to a database right? We probably want to store some So, I wanted to just ground ourselves to start to transition between the different then how we can better take advantage of the we need to fetch some data at some point seeing here, so we're going to But let's start talking about some of these React this app today. I just wanted to show that for a I'm going to the root element, and I'm rendering and I'm just going to delete this file. We what I'm building under the hood here. It's our root element that we're rendering into, So now, we're rendering out this new App a little bit of a diff of kind of what we're right? But I've refactored my component into items--right now, it's just local state--and this 'add an item', we're going to come back So, the first change that I've made is I've prop. Now, if you've been watching my channel about actions before, in the context of Next.js. this same paradigm, the same way of building with So, in this Vite application--you know, I'm not a client action. And that means that, just like form before, when I look at this form action here, 'await item' function that I passed in, and it rather than having the Vite handler where I needed then I had to like get the actual value from the dig it to get the value based on the name. So, then I update setItems, so I update state again to Now again, same as before, still local state, got for free, one nice UX improvement, one UX improvement is that my form cleared out the wow, I didn't have to make a ref, and then reset it. I didn't have to do which is kind of nice. Um, the second thing, the to write. So I feel like this pattern is a lot I can just get the form data directly from here. But still, we're not actually persisting items from a database, and we're not saving that. I'm going to first demonstrate function that we're calling. but it's not actually doing anything. What if we So, I don't know if you heard my mouse click slow. We're simulating some network latency and this is what the user experience or if I have inconsistent network speeds, or that item to my database or to data storage. Okay, I'm going to go back to here, and we're made that I've kind of scaffolded up, but code changes here to talk through how this works. I just got rid of these. I can even get rid of is an empty array, but then I have a useEffect of here, I've got this function I'm calling and it calls getItems, and then it updates React Now, if you've been in the React ecosystem React hook libraries that help make this SWR, or so on and so forth. But you can always caveats to this approach and maybe some and, you know, we'll show what the UX looks like What is this? Okay, so I've got export a fetch request to some API somewhere. So, right I haven't done anything on the server, but to to have to do that somewhere. So, depending on how I'm building, maybe I can't have control over the fence to somewhere else. Maybe, um, in reality, and for a lot of people, they have the ability to So, get items, going back to here, we have in state. Okay, that all seems to make sense. And items. Um, we're going to ignore the optimistic So, the question is, going back to here, where is code to go fetch data from the database? Well, so locally, my client-only app, but I actually I'm going to start up Vercel Dev, which is just and you'll notice that I have a bunch of items there's a trade-off here because page. The client-side JavaScript is loading, waterfall to go fetch the data from our So, this API, items--where the heck does this thing one of the cool things with Vercel is you can and then deploy them to Vercel. And since I don't have any way to take advantage looks like. It's very simple, but it helps So, I have this single API; it when I make a GET request to it, I'm able to and then I can return them as JSON. I'm able to get the text value from the incoming then return a new response that we created some surfaced here, but it gives us the backstop for So, I've kind of got two different worlds over the network to the server world, inside of here, going back to this form just ignore the optimistic part for a second, but we give it the form data, and we Okay, await 'save item', and we pass in here is that now we're calling the 'save item' over the network to API items. It's a POST and So, let's give this a shot--hey, nice, so this actually works. When we're saving I see that it's persisted. Now, what happens showed before, and you want to show some instant new hook called useOptimistic that allows you to So, going back into here, let's start to break I pulled in this new useOptimistic hook, I can read the optimistic values, and then two, I can have a function that I can call to Now, we give it the list of items from the server, and then we have this reducer. We have given the new state, merge them together. I go up to here, and I'm able to immediately, the item, I'm immediately updating this state So, when I scroll down, I'm no longer reading I'm reading from optimistic items, and that gives 'sending', and if it's 'sending', we get to show we see the 'sending' directly after it, before And right now, you know, this is pretty fast. artificially slow this down even another second, let's put this on even just fast 3G, we'll say When I hit 'enter', we're going to see that we waiting for that network roundtrip to complete and You know, previously, React didn't really more efficiently with the server, and one of the essentially doing some work on your UI, waiting to the user immediately, is now a built-in part This is, of course, a to-do list, but you can that are all based on the same primitives, Um, at a really high level, that's useOptimistic. database, persist data, and some of the advantages you know, hoping that your network speeds are Vite application, and I want to show what it application--how we can get out of this world our server program and our client program, and I'm building in this kind of unified team building my back-end. I kind of So, let's do it. Alright, first things I'm going to add Next, and we're using we can continue to use that if we want, but top-level 'app' folder. It can be nested in Um, the entry point into a Next.js application, server rendering, so rather than having this thing you see, and then you load up the you get a return back some initial React what we're going to do is we're going to have So, the layout is going to be like the initial we got 'X' for 'default function rootLayout', And this is going to be HTML. We're and we're going to have a body tag. Cool. template from the server. And if you look here, language English. Next.js is going to set like the character set, the viewport, Well, the way you do that here and you have this metadata object, which I but sure, uh, we can call this 'Next.js app'. actual element that we're putting our app into. Next.js is going to set that up for us. So we the other thing is the actual script tag, and well for us and do some optimization there. So we So, we're two files down. Not bad. Okay, now let's fine. Then the page is the entry point into our and this is what component is going to get the pages router have file system-based routing. denote them with this 'page' special file name, So, export default function page. You know, you have these functions, and then that's fine. Let's go back over to here. of this. We're going to dump it in here. We We're just going to rename this to 'page'. So So, I'm going to delete this file. I'm going to and now I can get rid of 'source'. So, this We're starting to look better. Um, application is a server component, then you have the ability to fetch data on and use that to be able to influence the So, if you remember, one of the UX bugs, nits with then it loaded the client.js, and it had the returned back the list of to-dos, and then be great if I could use some kind of server to be able to fetch that data, So, that's what we're going to do here. You can to mark this as async. We want to fetch some data but I don't really want any of this useEffect that. I just want 'to items, await getItems', any React state here, so we'll just get rid of Okay, so this is like the most basic page, these along from the server to the client. So, you can think about this kind I have some data fetch, and then I forward this is all server-side right now, but this let's, let's refactor this to make this a little using a hook, useOptimistic, that requires using So, let me cut this, and we can go here. this 'ToDo.jsx'. I'm using--I'm not even using We're going to see how that works out for because I haven't been getting my TypeScript Okay, async function page, getItems, think we can save that. Before I go any and I want to talk about getItems because was going over the network, but I don't need go to my database because I'm in a server So, what if we took all of this, and we pasted it directly in here. So now, this GET, that seems fine. And we go, get the items from I don't even need to use response.json. Okay, that all seems fine. And then this, what I I'm going to get rid of that, and we're going to but 'save item' is going to take in some tweak this a little bit, but it's fine for now, Okay, now let's talk about this again. So, we have um, save this, even though I know it's busted, it doesn't. Maybe I need to rename it. Export and then you're going to have some function So, I'm, me just going to cut this, and what 'add item' here, but really, we needed to call call the action directly. Now, previously, and going into our separate API, but wouldn't programming model but just kind of stay in the server? And the answer is, we can. We can do We don't need getItems here. Don't need we still got our action; we've still maybe my auto. Okay, there we go. Auto-import's But going back here, when we called this that we need to scaffold an API so that it can a remote procedure call. We need to go this server function. So, the 'save item' So, much like a client action, where you can use we need a server action, and that's denoted in some ways, to this, we used the server for it's using useOptimistic. This is a hook that's so we need to tell our bundler that So right now, if we're not doing anything and it renders the ToDoList component, server component, unless we mark it to our 'Hey, this is actually used client'. useOptimistic and use any other client-side But you might be wondering, okay, so I had a page I went and fetched that data, I forwarded it, I to-do list, and this was some client-side but then on here, I--I needed to go the other way. item', and that's what the bundler and what the is you're able to import these server endpoints, you said useServer, so actually turn Now, this is like a little messed up here, so take in text; it takes in the form data, and yeah, actually, want that form data. item, insert I think, we can make even that better. we call these functions, their suffix is 'action'. Okay, we'll go back to here, call is something here that I want to mention, but I'm also doing a bunch of other stuff. I'm and I also have my database stuff, too. So, ideally, the way that I would write this You can use--and server-only is going to allow a server environment, and if you're trying up at the build step for you. So, just a little this code can only ever run on the server. to install React, uh, at RC, React DOM at RC. I Oh, and uh, pni, Next, at RC. So, Next.js 15 is which also syncs up with the React 19 release it looks like this is the specific version that we this, maybe this will be already But I've got those correct dependencies. Okay, what I want here is to be able to--well, nope. uh, no, it was a named--so, import SQL from um, file, which, it doesn't have to be, but it's which, this is not a server action. This is just So, I would personally, the way I would out and put it into here, so that it's a contains server actions. If you put useServer 'cuz I'm using it here, which is not a So now, instead, getItems, we're in--if I had should set up TypeScript while I'm here, too. But Okay, Lightning Fast recap of what we've done that. I can go in here. I can get rid of this. Vite here. I do next dev, next build, uh, next sure my deps are installed. I might need to change So, I think I've kind of got everything moved I've got rid of my useEffect, I've got rid of my Uh, let's see if this actually works. I don't know let me put normal network speeds Okay, so let's see. Initially, it looks like list of to-dos, and when I reload the page, I HTML that's being returned from my server also server component that's going and fetching items initial HTML. Client components, so this to-do so they're also included in this initial HTML. so that you can add more client interactivity. So this all looks fine, but does it but you might have noticed that something looked and then it disappeared, and then when I reloaded we went from this environment where there a client world and a server world--and environment that spans both the client and And what happened is, inside of here, I called but I didn't tell Next.js, or I didn't we've done some mutation, we've changed some data, what I would actually want and this is going to update the Next.js cache we're going to go ahead, and we're going So, how about now? And what I want to show that I now, you'll notice, there's one network roundtrip goes, it updates the database, revalidates the It's all-in-one atomic operation, and that's how I So, I got to do this kind of same pattern--it's on the client with actions, with useOptimistic, features that are really, really powerful, and Uh, watching the transition from the Vite was helpful. I think, for me, the biggest it helps me understand more the point of doing right thing for everyone or every application. but it also shows that React 19 is really Vite application only, like, you still get to some of these new hooks like useOptimistic,