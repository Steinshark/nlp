Welcome into today's video everyone. I'm Alex from Tailscale. Now when building out a home lab or deploying some physical hardware in a remote location, we have to think about how we're going to look after that stuff when it breaks. Relying on walking friends or relatives through remote troubleshooting over FaceTime, admit it, we've all done it, isn't a super fun experience for either party. Now wouldn't it be great if we could just be at the console of this remote machine? Well, PiKVM is a free and open source project which lets us do just that. And in today's video, we're going to cover the basics of the PiKVM project and also walk you through the process of installing Tailscale on your PiKVM device. In so doing, we'll make it accessible from anywhere on your tailnet using Tailscale's NAT traversal technology. As usual, there are chapter markers for you to find the bit of the video that you're looking for down below, as well as a bunch of links in the description too. But what is IPMI? Well, typically it's a remote management technology that's reserved for server-grade gear. Serious stuff, I promise. But PiKVM means you can actually now remotely manage pretty much any system with an HDMI port using nothing but a Raspberry Pi. This makes the pool of hardware available for such builds vastly bigger and more affordable. And a DIY PiKVM can be put together for as little as $100 USD. If you'd like to buy a pre-made package, you can find the latest PiKVM v4 starting at around $380 or so, linked in the description down below. This might seem a bit steep at first until you look at other commercial KVM offerings in this space. So in today's video, I'm going to walk you through the process of installing Tailscale on your PiKVM. And at the end, I'm going to talk you through how I use PiKVM with an 8-port physical hardware switch to use one Raspberry Pi to control eight physical servers. The PiKVM project runs on a Raspberry Pi, hence the name, I guess. And all you really need to make it work is an HDMI CSI bridge. So this takes an HDMI cable in one side and spits out over this ribbon cable into the camera connector on the motherboard of the Raspberry Pi, something that the PiKVM software can actually record and stream to you in a web browser. As well as the CSI bridge, you'll also need a USB power splitter. That's because the Raspberry Pi 4 only has one USB-C port. And the developers of PiKVM use this port not only to power the device, but also to get the on-the-go serial information, the USB serial information, from the remote host you're trying to connect to into the PiKVM software. So once you've got the hardware side of things configured, and I won't focus too much on that today because there's some great documentation over on the PiKVM side, you're presented with a web browser running some web software. You can actually go to a website and IP address and access this remote computer in a browser. You don't need to install any software on the client device, on my MacBook here for example. So I jump straight into the KVM tab, and I'm able to connect to a Windows host in another room, or I mean, ostensibly this could be anywhere in the world, but it just happens to be in this house on my tail net. And this is running Windows 11, and I actually use this box as my Blue Iris NVR software, and I can do this with any computer that outputs a 1080p HDMI signal. And you can see that I've got full video access here, I've got keyboard and mouse control, so I can go into Notepad++. Now, I can't copy and paste between these devices, but what I can do, along the top here there's a bunch of options. I can go into this text box here, and I can paste in a bunch of PiKVM-related text. And it's actually going to simulate 295 character presses, as if I was typing away furiously. So as you can see, it's just simulated 295 character presses for me. This could be really useful for things like serial numbers, that kind of thing. Now, because PiKVM isn't running in software on the remote system, this is running on a Raspberry Pi next to the remote system, we can do all sorts of fun things like reboot the system and go directly into the BIOS. This is where PiKVM really differs from any other kind of remote software. And you can see, I'm just going to jump straight into the BIOS here, I'm going to press the Escape key for the Startup menu, and then I'm going to press F10 to jump into the BIOS of the remote system. Just think about what's happening here. I am connected to a remote system through a Raspberry Pi over my tail net, and I'm logged into the BIOS of a remote system, and I have full keyboard and mouse control. It just blows my mind what's possible these days. You can see here I've got an i5-9500, CPU, 12 gigs of RAM, that kind of thing. I don't need to go in and change any of my device configuration in the BIOS. Thankfully this system just works and I don't need to go in and make any changes. So I'm going to reboot back now into the OS, and you'll see that I get the entire boot process from the Post screen right here, all the way through the boot cycle, so I could actually use this to install an operating system if I wanted to on this remote system, using this Drive function that's up here. So you can actually mount storage onto your remote system from your PiKVM as well. That's because the Pi is connected via USB to the remote host system, so you put a USB-C cable into the power port, and it's also acting as a data connection to the remote system as well, using an on-the-go cable. This allows you to attach remote storage to the remote node, so if I need to attach an ISO and boot into it to install software, for example, I can go ahead and do that. Now I'm going to click on Connect Drive to Server, and you'll see in just a second, I think, yeah, there we go, AutoPlay has opened up the ISO file on the remote Windows host for me. So I'm going to walk you through the process now of installing Tailscale on your PiKVM. Let's take a look at the documentation over here. So on pikvm.org, they actually have, over at docs.pikvm.org, a first steps page. This is really important if you have a completely fresh install of PiKVM, which is what I do. What we're going to do first of all is just update the OS. So we have a section down here called PiKVM updating the OS. So I happen to know the IP address on my local network of the freshly installed PiKVM is 10.42.7.115, and you'll notice that I have a self-signed TLS certificate, so I get the warning of doom at the beginning. Also, the admin admin default password that PiKVM ships with is insecure, to say the least. So we're going to go ahead and update the OS and change the password as well. So you can see here, completely fresh install. Going to jump into the terminal, the web terminal right here, and it will drop us into this shell that has kvmd-webterm as the user. Now we can't do much as this user by design, so we're going to drop to root using su - whatever you want to call it. I think it's another thing, some people call it sometimes. And this password, I can scarcely believe it, is root. So to log into the web interface is admin admin, and to get root access is root root. So we can go ahead and change that password right away by doing passwd and type in your new super secure password, and now the root password is updated on the PiKVM, so that's great. Next thing we want to do is actually go ahead and update the OS. So jumping back to the PiKVM documentation, we can see they've got this command here. PiKVM underneath is running Arch Linux, which those of you that know the Linux world will know that it's a very fast moving Linux distribution. So you would typically just run pacman -syu to do a full system update, but in my experience running PiKVM in my home lab, there have been a couple of occasions where things don't always go 100% smoothly doing that, so I would highly recommend sticking to the documented update path using this PiKVM update script that they have here. So let's jump back to our terminal and see if we have this available. No, we don't. So they give us another step to do here. So we need to enter read/write mode. PiKVM boots into a read-only mode, so in order to make changes to the file system, such as doing updates, installing packages, changing configuration files, we actually need to use the rw command to switch to read/write mode. It's all documented in the documentation on PiKVM just over here. The next thing to do is a pacman -syy, which forces all of the backend package repositories to do an update, like a refresh from what's upstream. So this is analogous on certainly Ubuntu type distributions to doing an apt update, whereas the upgrade is the command that actually does the upgrade. Pacman's got some other syntax. You could kind of chain these all together on Pacman if you wanted to with an syu like this, but yy just forces all of these repos to be updated. OK, now that's done, I'm going to do a pacman -s, which is what we use to actually install packages on Arch Linux, and then do a -pikvm-os-updater. This is going to install that upgrade helper script that I talked about a few moments ago. Once that's done - remember it's running from an SD card probably, so it's going to be a little bit slow - we're going to run the PiKVM update script, and it's going to go ahead and do its thing. So quite a few packages to update. You can see for yourself right here, 279 packages. So first of all, it's going to go ahead and pull down those packages, and then it will do the upgrade second. So I'll be right back when it's finished. And we're back. So the PiKVM has now rebooted, so I'm going to once again jump into the web terminal, and again become root by using the su -. Now we're going to actually install the tailscale package. Hooray! Again, we need to enter read/write mode, and we're going to do a pacman -sy to refresh the package repositories if needed. Then we're going to install the tailscale -pikvm package. There are some PiKVM-specific fixes in this package, mostly to do with how the read-only operating system is handled and a couple of systemd units, that kind of thing. I'll put a link in the description down below to the source code of this if you want to go and audit that for yourself. But to install it, it's just a case of a pacman -sy tailscale-pikvm. I'm going to go ahead and proceed with the installation. You can see it's going to install a couple of things - the tailscale-1.66.4 package as well as tailscale-pikvm, which is like a meta package provided by the PiKVM project. Once the tailscale package is installed, we need to go ahead and actually enable the tailscale daemon. So we do systemctl or systemctl or systemctl. Which are you? Let me know down in the comments. I'm always like a systemctl in my head, and now I say it out loud for I think one of the first times. I'm like, &quot;Huh, which ones are you? Let me know. I'd love to know.&quot; Systemctl enable tailscale-d --now. This is a pretty neat trick, actually. I only discovered this a few months ago. You can just enable a service by doing enable. All that does is it means the service will automatically start when the system boots. But if you do a --now, it will enable the service and also start it as well. So typically what I was doing in the past was doing an enable and then a separate command of start. But that's actually redundant. You can see I actually did the --now on the second iteration. So if we do a status of tailscale-d here, you can see the tailscale daemon is actually active and running in the background. Next, we need to do a tailscale-up. And I'm just going to add --ssh into here. This is totally optional, but I love tailscale-ssh. I don't have to worry about putting ssh keys on this box, and I can get to it from anywhere in my tailnet that my ACLs permit. So I'm going to just put that as part of the initial login procedure. And I'm already logged into my tailnet in this browser session, so I'm going to do a sign-in with Google, follow through with the tailandscales@gmail.com account I always use in these videos. And you can see that pikvm is now logged into this tailnet. God, it's so easy. Okay, cool, so I can now do tailscale-status and see all of the other nodes in my tailnet, including things in Amazon if I wanted to or this laptop, Baldrick, or my phone or whatever. I can now access this pikvm from any of those devices. So we can take this a step further. You remember at the beginning when I said that there's a self-signed TLS certificate, so you get the warning of doom when you're trying to access a self-signed TLS certificate. We can use tailscale-serve to actually automatically generate us a Let's Encrypt certificate for our tailscale DNS name. So what I'm going to do is just paste in a command I've got here, tailscale-serve --bg https + insecure and then localhost and then proxy that on port 443. And you can see that right away we can now access our pikvm on this domain name right here. The first time you click on this, it's going to take a few seconds, maybe 10 or 15 seconds or so. That's because in the background we're actually generating and doing that TLS certificate generation with Let's Encrypt via the ACME and LEGO APIs. And you can see here, there we go, my pikvm is now on my tailnet with a full-on TLS certificate. We can actually verify that if we jump into connection is secure, certificate is valid, boom. There we can see Let's Encrypt for the pikvm at Velociraptor. By the way, if you're not familiar with all of this DNS stuff, we can actually just jump over to the admin console and I'll just talk you through it real quick. Every single tailscale domain or account gets a name through the DNS option, the magic DNS option that's here. Now mine, I have already generated one that I like, a velociraptor-noodlefish, and you can see that matches the certificate that we just generated from Let's Encrypt. This name here, pikvm, this matches the node name in your tailnet. So if we jump back to the machines page of our tailnet and type in pikvm, we'll see here that this name here, actually, if you click on this dropdown, you can see the fully qualified domain name right here, pikvm.Velociraptor, whatever. Now if you wanted to change that to be pikvm1, pikvm2, whatever, if you've got multiple instances, you can do that right here. You can click on the three-dot menu on the right and then go into edit machine name and do pikvm. Uncheck this auto-generate box, of course. pikvm2, and it will say this machine will now be accessible here using magic DNS and pikvm will no longer point to this machine. You'll also have to refresh the tailscale serve stuff in the background, but hopefully that gives you an idea of some of the possibilities you can do with the magic DNS side of things. Now you just added a new node, probably an always-on node to your tailnet, so it's probably quite likely that you're going to want to do a couple of other things with this box too, things like a subnet router. So if you want to access other devices in this LAN without having to install tailscale on every single one, you could set this up as a subnet router. Same goes for setting pikvm up as an exit node too. You can do that in the terminal because it's just Linux underneath. Okay, it's Arch Linux, but it's still real Linux, I promise, by the way. So in order to set up an exit node, of course, we have some documentation on that and there'll be a link to that in the description down below. But it's really quite a straightforward process, just a couple of commands. We need to make sure we're in root mode, first of all, same as we did before, and then we need to enable packet forwarding. So how this works underneath is we take every incoming packet to the pikvm through the tailscale daemon or through the tailscale network, and we rewrite those packets as if they're coming out through this device. And in order to do that, we've got to add a couple of bits into the sysctl configuration. So I'm going to paste these two lines in here that allow both IPv4 and IPv6 packet forwarding, and then I'm going to do sysctl -p and just basically apply these changes right now instead of having to reboot. The last step is just using tailscale set. So this is the way that you would change the configuration of tailscale after it's installed. You can see all of the different options we've got available to us here. And then I'll just do a --advertise exit node. Now if we jump back to our tailscale machines page, we can see we've got an exit node button that's just appeared here waiting for approval. So if I click again on root settings and then check the box that says use as exit node, we'll see now that in my macOS client under exit nodes, I now have pikvm as an option for exit nodes as well. Now one last thing you might want to consider is because this is potentially going to be quite a critical piece of infrastructure for you, I don't know what you're connecting this pikvm to, you might want to consider disabling key expiry. By disabling key expiry, we don't end up rotating those wireguard keys that are underneath, you know, gluing everything together, making it all secure. So it's totally up to you and your threat profile and that kind of thing. But if this is a truly critical piece of infrastructure for you, I would probably encourage disabling key expiry and then going in and doing --when you are physically at the console, because this is probably going to be deployed remotely somewhere-- when you're physically at that building, just do a tailscale, log out, log in, and that will rotate the keys for you. Now there are some more advanced things you can do with pikvm. For example, in my basement, I've got about five or six servers down there that I all hook into a single pikvm. I have a network-based 8-port KVM switch that I cost about $250, I think. I'll put a link in the description down below to all of the details there. But TechnoTim put me onto this one, actually. It's the TESsmart, or Tessmart. There's one too few S's. Anyway, you can see here that I have a Proxmox virtual environment hooked into this specific pikvm instance running in the basement. But there's also a GPIO tab up here, and if I want to change to a different server, all I have to do is click on this button and it will, over the serial network connection configured in pikvm, switch the inputs of the remote KVM instance. There is an 8-port physical unit in the rack downstairs, and then the pikvm is a separate unit hooked into the back of that. You can see I can just switch between multiple nodes. I've got one running NixOS, I've got this one that's running Proxmox, my HL15's turned off right now, Zoidberg is running a bunch of my network services, OpenSense, for example, doing a bunch of other stuff for me as well, of course, providing me with internet. Using the TESmart 8-port HDMI switch, it does a little bit of extra configuration we've got to do inside pikvm. So we're going to jump back over to the web terminal, do su - so we can become root once more, and then I'm just going to show you this one file, kvmdoveride.yaml, and in this file, this defines everything that pikvm knows about the remote physical switch that it wants to switch the inputs of. So you can see, first of all, we're giving the names of these devices in a table here, also which LEDs and which buttons are mapped to which devices, and scroll all the way back up here, because there are eight switches plus a couple of others to reboot pikvm itself and restart the service. But you can see just at the top, this is how it's over GPIO, it's a network serial GPIO configuration, it's talking to the TESmart switch on the IP address 10.42.0.7, and that is how the switching is done. The pikvm project even has an entire page dedicated to these multi-port KVM over IP switches. The one that I'm using is on their compatibility matrix here, it is the TESmart 8-port one that's right here. Now, configuring this thing was a bit of a pain in the backside. I had to use a Windows VM and run some crusty old app to actually statically IP configure the switch to be what I needed it to be, all that kind of stuff. Once you get over that initial configuration, which took about 10 or 15 minutes, it's been no problem and it's been nice and stable for me for many months now. I would also point you to look down the bottom of this page, the limitations section, specifically, most importantly at least for me, was the HDMI back power situation. I did this with a 4-port version several months ago and I ran into some really weird issues with things back powering each other and switching and doing things they shouldn't do. So just pay attention to the compatibility matrix and you should be good to go. So, you get the idea that I can just have one box here, I've got one Pi KVM controlling up to 8 systems. That makes the initial price a little bit easier to swallow, doesn't it? So there we are, that's how we install Tailscale on a Pi KVM. As always, thank you so much for watching and don't forget to check the description down below for all the links of the things I just talked about, particularly that 8-port hardware KVM switch. Until next time, thank you so much for watching. I've been Alex from Tailscale. video.