Up to the HFPUG: alright. So I wanna thank everyone for being here today. This is the February meeting of the Houston Functional programming user group. And today we are really excited to welcome Wilbur. Who is HFPUG: He co-created the camera language and co-author. The reason steamer and from what little I know of him, is a very nice guy who is really interested in really bad need. HFPUG: So I'm gonna turn it over to you, will. We will record his talk in the first part of the QA. And then we will turn off the recording, and we'll continue our QA. HFPUG: So Will. It's all yours Will Byrd: alright. Thank you. And, by the way, since you're in Houston, if you haven't already maybe you could invite Dan Friedman, because I don't know if you know this. But Dan Friedman actually wrote the little lisper when he was in Houston Will Byrd: he was at. He was a faculty member at the Lbj School of Foreign Affairs, or whatever international affairs or something. And that's actually where the Will Byrd: what was that HFPUG: II did. You attended that you attended it. HFPUG: Yeah. Will Byrd: when Dan was seating it. HFPUG: Okay, well, that's it's a small world. So Will Byrd: yeah. And we have an Iu are here. So that's great. Will Byrd: That's Will Byrd: yeah. So anyway, I you know, if if you like this sort of thing, I definitely recommend inviting Dan. Will Byrd: So thank you for inviting me. I'm how did you Will Byrd: decide to invite me? Of all people? I'm just curious. I always, you know. Usually I get a big head, and it's like, Oh, my work is well known, and then they'll they'll usually say something like, well, we had a list of 3 possible speakers, and you're the only one we hadn't ever heard of. HFPUG: so we invited you. So that's that's usually what I hear right there. So I'm just curious. Not at all so. I certainly know your work. And I think I was asking people in the group like, who would you like to hear from? And I said. HFPUG: I'm an academic. I am unashamed, and I will ask HFPUG: basically anyone. And HFPUG: if they don't want to come, they just don't. So no, and and and no, but I think you were one of the first people that we invited for this year. HFPUG: Alright! Well, II appreciate it. Thank you. HFPUG: Yes, I'll be very talk about. HFPUG: have a long time for me, please. HFPUG: Oh, there are like timer wins. Oh, Jaden, hey? Yeah. Will Byrd: I gave a talk in Japan, was I gave a keynote at a conference, for all my papers have been rejected Will Byrd: and well, finally, I've made it right. And then, you know, I asked later, it's like, Oh, yeah. Why'd you invite me? Is like, Yeah, you're the only speaker we hadn't heard work we didn't know about. Well, you know. Hey, that's actually, that's actually a pretty good algorithm. Right? If you're gonna invite people to invite the people where you don't know about it. So Will Byrd: that's, you know, a a that's done a little bit the first first few times I heard that answer. But then it's like, actually, that's a great strategy. I think so. Will Byrd: Thank you. Will Byrd: Well, if you'd like us to tell you, we hadn't heard of you. Yeah, you know. I mean, okay, so here you go. Yeah. A funny, a funny thing happens, because originally, when I started working on Mini Cameron Will Byrd: and the relational programming stuff, even before there was a Mini camera when there was Cameron, and then we started working on the book. Eventually, when the the first edition of book came out in 2,005, you know, it was Friedman or no, it was Byrd Kessel, Yao Friedman. I think I forget that the order, I think that was it. And everyone's like Will Byrd: Dan and Oleg have a book, and that happened for like 10 years. And now it's oh, Will Bird, created Bennie Kander. It's like, no, you know, neither one's exactly true. But that's just kind of the way things happen. If you work on something a long time. Will Byrd: people sort of give you more credit than you deserve. At this point. There have been a lot of people who work on Will Byrd: on some variant of this work, and too more too many people for me to think individually. But Will Byrd: it's been about 20 years now since we've started working on Mckinley. Will Byrd: alright. Well, okay. So I saw that Will Byrd: this this goes. You have like a 2 h block and speakers go from 30 min to whatever you know. II have a bad habit like I'll talk the whole time, so I'll talk for 40 HI have talked for 40 h for on many, Cameron. So Will Byrd: you know, I think it's more like, what do you all want to do. I'm kind of in a chill mood. I'm happy to be interactive, and I can show you some things, and we can have some discussion, or I can give you a typical demo, or I could talk to you about why Mini Cameron sucks, and we need a new version, whatever you want. But Will Byrd: I guess part of it is, some people might not be familiar Will Byrd: with logic programming or relational programming logic programming. So I could start with just kind of. you know my my high level. Take on what those things are. But, on the other hand, maybe people HFPUG: you know are are somewhat familiar with that. So I definitely think, jumping in and speaking over Jared, that an introduction would be excellent. And then Will Byrd: well, you know, all languages suck right. It's it's sort of like in physics, you know, all models are wrong. Some models are useful. There's like the 2 classes of programming languages. Will Byrd: the ones that Will Byrd: you know, people complain about, and the ones no one uses. That type of thing. So Will Byrd: okay, well, sure, I'm happy to give you a demo. So II promise to talk on. Will Byrd: you know, sort of what comes next or next generation of language. and and I'll be honest that Will Byrd: you know I'm still in the ideation phase. So I could talk to you about why Mini canvan sucks, and so do all the other languages that are trying to do this. And you know how I can imagine language that might suck less. Will Byrd: but it'll still probably suck a lot. Will Byrd: But you know, maybe we can incrementally get towards a suck less language. Will Byrd: So I'm happy to talk about that after I give the intro. And I know there's a wide variety of of experience with Will Byrd: logic, constraint, logic, programming, Mini canron, so forth. So some people may have implemented many canon and some people, you know, maybe haven't heard of it before, so Will Byrd: that always makes it interesting. I'll I'll give a demo, and I'll talk about kind of the high level philosophy of what the style programming is like. So this is the functional. Will Byrd: You know, it's funny to me that in the functional community. Will Byrd: I'm I'm known for not doing functional programming. Basically, I mean, we we have a functional implementation of a constraint logic, language. But Will Byrd: you know, at at some point we took over about half of the scheme workshop half the scheme. Workshop papers were all many. Maybe it's time to have our own workshop, because it's kind of like, well, when everything's good, straight logic programming, is it really the scheme workshop at that point. Will Byrd: Alright. let us. Will Byrd: I do some screen sharing here. Will Byrd: Alright. Will Byrd: Okay. So here's my usual. So Will Byrd: Spiel, talking about what is what I call relational programming as opposed to functional programming. So Will Byrd: you know, I'll just give you. Will Byrd: Let's just do that. Will Byrd: Okay, what is relational Will Byrd: programming. And you know, you can sort of think constraint, logic programming if you're familiar with those terms. Will Byrd: And how does it differ? Will Byrd: Functional program? Okay? So Will Byrd: we all know and love functional programming. Maybe Will Byrd: And so functional programming is based on a great idea. Now, now, there's a lot of debate actually, on what functional programming is. If you ask Bob Harper what functional programming is, he'll say, scheme programs aren't even. But not only are that functional programs are not even programs. Will Byrd: Okay, they're like fragments of syntax. Okay. I reject Bob's worldview HFPUG: boom Will Byrd: and replace it with my own. Okay, so but in any case, if we think about what the idea of functional programming is. Will Byrd: The the part of the idea is that, say, we have a notion of like addition. Will Byrd: and we might say, in scheme, syntax or racket, syntax or lisp syntax. We want to add 3 and 4, and that expression on the left would evaluate Will Byrd: 2, 7, and we would say, plus is a procedure or a function. Let's say, let's say it's a function Will Byrd: that can take 2. Will Byrd: Let's say non negative integers. And some of them. And so the result of calling this function Will Byrd: is a value which is 7. Will Byrd: Okay? So so here we have the notion of a function. Will Byrd: And we also have the notion of input. Will Byrd: Umhm. And we have the notion of output. Will Byrd: Okay. Will Byrd: so this, this dichotomy or this difference between input and output is really critical. Will Byrd: And and we're just so used to it that I think most of the time we don't think about it. Will Byrd: But Will Byrd: I'll claim to be provocative that this is actually a really bad thing. That functional programming is really bad. We should all feel ashamed. We should feel bad for doing it for advocating it. It's really bad, because functions. You know, that's that's a very poor way of looking at the world. And what you really should think of is relations. So we should think that instead of this. Will Byrd: this false dichotomy between input and output instead, we should say, well, we actually have a triple. I'll call it plus. So that's just our convention. Mini Cameron. And we have a 3 place relation. Will Byrd: Okay? And there is no difference between inputs and outputs. That concept is gone all right. It's sort of like if you talk to the Small Talk people. Will Byrd: you know. Dan Dan Engels says that the idea of an operating system is a bad idea. There shouldn't be an operating system. An operating system is all the junk Will Byrd: that you can't put anywhere else. Okay, that in small talk they don't have an operating system. It's just objects in a virtual machine. Will Byrd: So in the same way, I will claim whether or not. I actually believe this. I will. I will. I will remain silent. But I'll claim that functions are bad. Functional programming is a bad idea. We need to move past it. Okay? So if we want to get to higher levels abstraction, we need to talk about relations. Okay? So why? Why are relations? Interesting relations are interesting because they're very flexible. Will Byrd: because, in addition to the notion of a relation we are going to think of in terms of like an algebra. Will Byrd: Okay? Will Byrd: And algebraic reasoning. Will Byrd: if there any hasskillers out there you know. Close your ears. Will Byrd: But but anyway, you know, so we're gonna talk about sort of like Will Byrd: middle school or high school algebra. Okay, we're not talking about like, you know, high school algebra. Maybe I think there's certainly a lot of algebraic Will Byrd: reasoning here. But the idea is that Will Byrd: we can have Will Byrd: unknowns represented as variables. Okay, so if we can say something Will Byrd: like with our 4 place relations? You know, plus so 3, 4, 7, we could replace. if we wanted to. Will Byrd: that third position, that third argument with a variable Will Byrd: that represents an unknown quantity. and then we can ask a query. and the system somehow. we'll figure out Will Byrd: that Z is equal to 7, Will Byrd: and so that will give us a solution in terms of Will Byrd: equations or dis equations, or constraints in general. So so now we can ask these sorts of questions and ask queries, you know, set up, set up constraints and relationships, and and Will Byrd: ask queries so. and we could just as easily Will Byrd: do something like, say, Hey, maybe we don't know what y is. Now tell me what y is, or, more interestingly. we could say something like we don't know what X and Y are together as a pair. Will Byrd: and tell me what those values are. And now you're saying things like, well, if x is 0, Will Byrd: you know y is 7, and you also can say that if X is one, you know, y is 2. Will Byrd: And in this case they're finally many if we restrict ourselves to Will Byrd: natural numbers. But if we relax this and said all the integers now there'd be infinitely many solutions. So so now we're in a space where we're talking about not just one answer and not just functions that have inputs mapping to outputs. But we have relations, and we have placeholders. And now we have a solver. And we can ask Will Byrd: queries and solve over Will Byrd: these sets of constraints that building up Will Byrd: and let the underlying computational system Will Byrd: do Will Byrd: sort of the handiwork and the dirty work of figuring out what those assignments are, and it's very similar to, you know, solve for x or solve for x and y in, say, a high school algebra problem. Will Byrd: So that is is the high level idea. Will Byrd: Okay, so we're trying to get additional flexibility. And so we have Will Byrd: additional abstraction in several ways. So first of all, we have remove the idea of input versus output. Will Byrd: that is, not necessary. It's not necessary idea. And you know, we we're more abstract by removing it instead, there's relationships. And you can, by the way, map this very directly to databases and database tables right like instead. Now, we can think of the table of XYZ. Values Will Byrd: that satisfy this relation, and the the table could be finite. The table could be infinite. If the table's infinite. Then we're going to have to generate the table lazily. Will Byrd: If it's finite, then we could write out all the table beforehand if we want. and now, when we're Will Byrd: building up a program that's represented by a bunch of constraints. Now you can think of that as doing. Join over these tables, which could all be infinite potentially. Will Byrd: And so you have to do a lazy part of the computation. Will Byrd: So it's an abstract in a way that we claim that functional programming isn't Will Byrd: and goes beyond functional programming in some ways. Will Byrd: And we now are playing these sort of algebra tricks. Will Byrd: And there's some other interesting properties. So I will try to make this a little more. Will Byrd: Concrete. So I'm not going to show you numbers. Will Byrd: because, okay, one of the good and bad things about Mini Canron. It's like, Oh, I wanna create a program synthesis system for turing complete language that supports recursion and symbolic. You know, list based manipulation. Will Byrd: No problem easy. Will Byrd: I wanna add 2 numbers. I wanna add 2 integers or 2 natural numbers like, Okay, sit down, calm down, and we're gonna have to have a have a have a talk. Okay? So that's one of the trade-offs right now with Mini Cameron. So I'm not gonna show you this because it turns out that this example, which was easy to explain, is actually quite tricky to implement Mini Cameron. Will Byrd: And I mean, we did have. We have ways to do it, but we have many ways to do it. So that's not necessarily good thing. Will Byrd: the sort of first chink in the armor. If you want to think of it that way. Will Byrd: Well, okay, so let's load up. Will Byrd: Okay? Will Byrd: And Will Byrd: the Hello world of functional programming is, of course. Will Byrd: what's HFPUG: what's the Hello world of functional programming? Do you know? HFPUG: Hello, world of functional programming? Will Byrd: If you really want to go wild, you can do Fibonacci. But usually factorial is like the Hello world. Okay? Will Byrd: So here the Hello world for constraint, logic, programming, or relational programming is a pen or king cat, or whatever. So in good old scheme. We can do things like, hey schemes get symbols and lists so we can append Will Byrd: the list A, BC to the list DE, and we get a BCDE, Will Byrd: okay, great. That is the functional version. We have concatenated these 2 lists to get Will Byrd: another list. So we have clear inputs. Okay? And we have a clear output. Alright. Will Byrd: Now, we're going to do the similar thing in Mini Cameron. And I'm going to define appendo. Do. Okay? Will Byrd: So let's do, how about Ls, and Ls, that's the concatenation of lns. and I'm not going to get into all the details of how many canon works. I mean, we can backtrack, and I can explain exactly how this works if you want. Will Byrd: I'm just trying to paint the big idea right now. So so excuse me, for Will Byrd: you know, just kind of sketching over this. But Will Byrd: I mean, I'll explain at a high level what's going on. So so basically, we're saying. Will Byrd: the appendo is a relation that we're representing in scheme, which is the host language. Will Byrd: for which many candidates extending Will Byrd: appendo is a 3 place relation. Will Byrd: It has Toulis, L. And S. And LS. The third argument is the concatenation of lns. Okay, I don't. I don't want to talk about in terms of inputs and outputs. I'm just talking about their positions. Will Byrd: Condi allows us to make a choice. So we're going to have 2 condi clauses. So there are 2 different choices. Will Byrd: either the if the first list is empty, then it turns out that the second and third lists are the same list is equal equals. That's a type of a quality based on operation called unification, or technically, first order, syntactic unification. There are many types of unification turns out Will Byrd: and Will Byrd: we can also introduce temporary logic variables to these variables that are like placeholder things where you can do algebra. Over these are what are called logic. Variables Will Byrd: so fresh allows me to introduce some logic variables. Will Byrd: and so I can say. L might be a cons of. say, A Will Byrd: and Will Byrd: d. That's the car in the cudder to steamers or lispers. And we'll say that Will Byrd: Ls. Will Byrd: and then we're gonna do a recursion. Will Byrd: Do recursive call to appendo on Will Byrd: S to rest. Okay? Will Byrd: So some of these elements, if you're familiar with functional programming, you should be aware of. Okay. So you probably know what lambda is. Right is a lambda. 2, 3 arguments. Will Byrd: This Condi is kind of like conned in lisp or scheme, which is Macarth Mccarthy's cond operator allows you to make a choice. So it's like, kind of like an if, okay, it's like a conditional. Will Byrd: The difference is in a relational setup. Will Byrd: We try all possible choices, not just the first one that has a special guard or a special test. Will Byrd: Okay? So all the all the choices could be tried and could produce answers. Will Byrd: Fresh has 2 purposes is going to introduce some of these Will Byrd: variables that we've looked at before. In the addition example, there is these like logic variables that we can do algebra over. Will Byrd: and then here we're we're both destructor destructuring L, saying, Hey, Al l's got to be a pair, and we're calling the head of the pair A and the tail of the Will Byrd: you know the the pair. D. Okay, that's one way to look at it, or L itself coming in could be one of these logic variables that we do algebra over, in which case, and it may not even have any structure, maybe it doesn't have any value associated with it. So this is a big change in this world. We are allowed to do operations on variables that we don't know anything about. Will Byrd: Okay, it's not not like we're gonna get an error Will Byrd: when we operate on these variables. It's just that when we perform operations involving those variables, we might give those variables, more structure, or even completely ground their values. Or we might find out whatever operations we're doing with those variables Will Byrd: is inconsistent. And then our entire computation can fail through inconsistency. So here we're saying L, Will Byrd: which is. Will Byrd: which could be a logic variable, representing that that you know, with structure we don't know. Well, it's gotta be a pair, and the pair. Will Byrd: you know, it's got to be a pair of A and d since A and D. Were just introduced at this point we know that they don't have any values associated with them. Will Byrd: But then, over time, like in the recursion, you know, D might get structured. Will Byrd: or because Ls might have structure and coming in the fact that we're associating A with Ls. Will Byrd: you know, maybe aegis structure. So Will Byrd: there's this whole game where we can accumulate information over time in different ways. And the point is, we don't care if L already has structure or not coming in Will Byrd: to a call to append. O, and we don't care if asked or Ls have structure. This program will work if they're fully ground and have concrete values for everything. Or if there's no information at all about Ls and Will Byrd: Ls, okay, so we're allowed to reason more abstractly. Will Byrd: Okay, so Will Byrd: that is a simple mini-canon relation Will Byrd: sort of the hello world of of constraint, logic, programming. And now we're going to do what's called a run. So like I said, many cameras embedded in a host. Language normally Will Byrd: scheme racket. Will Byrd: you know, could be in Haskell. It could be in closure, like core logic, or it could be, O camel like O canon whatever Will Byrd: could be Java. Will Byrd: So we are going to use this run interface operator to act as an intermediary between our host language, which is scheme in this case and mini camera, because scheme doesn't know about logic variables. Scheme doesn't know about. Will Byrd: you know, Condi, or fresh, or any of those things. Will Byrd: Obviously. there's some magic behind the scenes which I'll I'll show you a little of Will Byrd: but we need somehow a way to talk to to scheme so we can write our regular scheme code, and we can also write our regular admin can ring code. They kind of exist in 2 different worlds, but they they can send. You know, they can interact in a way. Okay. So here Will Byrd: the run. we say, we want one answer back, if if it exists. and Q is what we call our query variable. So whatever the value associated with queue, that's what we're gonna see at the end Will Byrd: of the computations. Will Byrd: And now we can call Pando. We could do a similar, you know, like we do something like our first example. But now I can. I can put Q or Query variable in that third position Will Byrd: of appendix. And let's see what happens. All right. So what we get back is a list containing one list. Okay, it's not the list. Abcd, it's the list containing the list. ABC de. Will Byrd: that's important. Will Byrd: Alright. So here we've appended these 2 lists, or concatenated the 2 lists and got back what we expected. Will Byrd: Okay, that would be kind of boring, except Will Byrd: now, we can play this game where we can Will Byrd: put a list in that third position. Actually, we can run a computation right now. And we get back this kind of strange looking value list containing underscore dot 0 Will Byrd: underscore dot 0 is a representation Will Byrd: of a one of these query variables not being associated with any concrete value. It means that Q could be anything. You could think of this in logic like an existential. Will Byrd: This is sort of like saying. Actually, in this case, you can almost take it like a universal. It's sort of like saying, for all queue for any value of queue. It is the case that appending ABC to de gives you Abcde. That'd be one way to think about it. Will Byrd: But we can also put the queue in other places like right here. Will Byrd: Ok, so now, we've changed the meaning of this query. So now we're asking for what value of Q. Is it true that appending the list A, BC to Q gives you the list? A, BCDE. Will Byrd: In this case it's pretty clear that that would be the less DEQ would be the less DE. So we're seeing what values associated with Q. Will Byrd: Now, more interestingly, we can have multiple Will Byrd: query variable. So we could say, Okay, for which values of X and y, is it true that appending X and Y gives us A, BCDE, Will Byrd: and now Will Byrd: we see that we have a list containing a list containing 2 lists. Will Byrd: We have a little more more structure, because now we have 2 Will Byrd: query variables. But the main point is that X is going to be the empty list than the first answer. Will Byrd: and Y is going to be list A, BCDE, and we can ask for a second answer. Will Byrd: And in this case Will Byrd: we get 2 results back. Will Byrd: And in the second case X is the list A, and why is the less BCDE. We could ask for 6 answers. We could ask for Will Byrd: a bunch of answers. We can ask for all the answers with what's called a run star. So instead of putting in a number, run, Star just says, give me everything. Will Byrd: Okay, in this case there's 6 answers that we get. Will Byrd: We can also play slightly more advanced games. So, for example. Will Byrd: I could say, well. Will Byrd: how about this? How about I have a list. change it to one. How about we have a list? chris bremer: Oh, just a I had a quick question, what happens if if there's no solution. So I think you showed what happened when there was like, exactly chris bremer: okay, wh. What? Anything's the solution. But I was just kinda curious. What happens if there's no solution? Well, let's make a simple one. How about how about we say A to B Will Byrd: is, ABC, okay. Will Byrd: do you? Do you agree that there shouldn't be a solution to that one Will Byrd: concatenate? A to B, we get ABC, and sure enough, what we get back is the empty list of of answers. Will Byrd: Okay, that's a good question. And and I'll show you one other case, which is, you know, we can also do this, we could say, XYZ, Will Byrd: okay. Now, what do we get back? Will Byrd: What do you think you we should get back in this case HFPUG: or peace Will Byrd: all the lists. Well, okay. Will Byrd: so this is interesting. This is interesting. So notice, I last, I asked for run one. Will Byrd: We don't get that. Let's let's see what we get. Okay. So here's what we have. we get. We get a a somewhat abstract answer that basically is saying, if X is the empty list. Will Byrd: And why is anything. Will Byrd: then Z is the same thing as y. We've tied together the values of Y and Z. We've represented infinitely many concrete values Will Byrd: using one somewhat abstract value. But this isn't a completely abstract value, because we still say that X has to be the empty list. So this is an interesting answer, because it's sort of a combination of an abstraction. Will Byrd: and also concrete. The other thing you might notice well, is there any constraint saying that Y has to be a list. Hmm! Maybe why doesn't have to be a list. Will Byrd: In fact, if we go back to scheme. Will Byrd: I don't know if you knew this Will Byrd: is that legal in scheme. Will Byrd: I know all the Mlrs and Haskellers are. Gonna tell me whether that's that should be legal Will Byrd: that works just fine in scheme that's legal. Will Byrd: Whether that's good taste I don't know. Okay, but we we copied sort of the semantics of scheme. So there actually is no Will Byrd: restriction Will Byrd: that Y and Z have to be lists in this case. So we're copying the the weird scheme semantics where we can have improper lists. Basically. HFPUG: okay, the shootings accounts. Will Byrd: What? What is that? HFPUG: Basically. Will Byrd: Sorry, what's the conscription? Also? Yeah. So it's basically treated it as a cons pair, like when it comes to items like times together. Yeah, that's right. Yeah, this is II could do a simple, I mean, probably the simplest example. Will Byrd: You know, I could do like that right? Will Byrd: So that that's just the same same as comes in. Will Byrd: Put a onto 5. Will Byrd: So so you're allowed to have improper lists as a result of a pending scheme. Will Byrd: Now, now, if I if I really want to prove that to you, by the way. I could, let's see Will Byrd: I've been learning Dvorak on the fancy kinesis thing, and I can't type at all. Will Byrd: And so now this is my first time ages. Alright! Here we go. So yeah. Now, what I could do is I can. Will Byrd: I can do a conjunction. Will Byrd: So I can actually add Will Byrd: another constraint saying that Y is 5. Will Byrd: Okay. Will Byrd: so now, what do you think we'll see HFPUG: last 5 who don't HFPUG: gives list? Item 5. Will Byrd: Is that what you expected? HFPUG: That's what we should have expected. Given that. Given what we said. Will Byrd: Okay. Will Byrd: now, okay. So here is something that I think is cool. and as far as I know, I'll I'll claim you can't do this in Haskell or Mlr. Scheme. Okay, in general. Will Byrd: I can do this. I can reorder Will Byrd: the conjuncts. Okay, so I have constraints that are in a conjunction. There's an implicit. And if you want to think of it that way Will Byrd: inside of the run. Will Byrd: or I can make it explicit. Will Byrd: That turns out that fresh which introduces these new logic variables are lexically, locally, lexically scope. That's also like an Will Byrd: okay. So this is like an and or conjunction. I can reorder those things Will Byrd: and preserve the semantics, and that's true. In general. Will Byrd: There is a caveat, so I'll tell you the caveat in a few minutes. Will Byrd: but I'm allowed to reorder things. Will Byrd: And if I go back to the definition of appendover that is. Will Byrd: here we go. Will Byrd: I can, you know. Okay. So here we have within a Condy clause. This is a conjunction. This is an and I can swap those too. I am allowed to swap those. I can swap those 2. Will Byrd: I can swap this, I can move these things around. I can even take the 2 cond clauses which are like an or Will Byrd: and swap those around. Will Byrd: Okay, so II can play all these games. II can also go within a single equal, equal, equal, and swap the arguments there. Will Byrd: turn it. I can do all those things. And if I run my program, I still get the same behavior. Will Byrd: Try that in Haskell. Okay. Will Byrd: so you know, in some sense, this is, this is a more abstract model. Will Byrd: Now it turns out that there's a little problem. Will Byrd: You know. There's always a catch, right? So the catch is. remember, before I did a run star. Let's try that again. Will Byrd: It's like, I want to get all the answers back right? Will Byrd: Oh. -oh. Will Byrd: what in a terminate? I could do a run? 6. Okay, there are 6 answers. Great. Will Byrd: What if I do run? 7? Will Byrd: Oh. incidentally. Now, why is that Will Byrd: if we go back to our appendo I was swapping things around with wild abandon. Will Byrd: It is true I can swap all these things around, and they logically are equivalent as long as an answer exists. Will Byrd: So Mini Cameron uses what's called a complete interleaving search. Will Byrd: If an answer exists, if you had unbounded amounts of time and memory. you would find the answer with the Mini camera search. This is not true of the default. Prolog search, by example. For example, if you're familiar with that prologue uses a depth. First search which is incomplete. Will Byrd: and there's certain cases where it could search forever and never find it. Will Byrd: an answer that exists, and many canran in theory. Will Byrd: Mini camera will always. The search would always find the result. However. Will Byrd: if an answer doesn't exist, if there is no answer. there's no guarantee that many chemical can find it. Will Byrd: Now, part of this comes down to the halting problem, and part of this comes down to mini camera using search. It's not very smart. If a programmer has insight into the problem, there are tricks they can use to to try to Will Byrd: get better refutational behavior. Will Byrd: But in this problem this program. The core of the issue Will Byrd: is this recursive call coming at the beginning of a conjunction? Will Byrd: The problem isn't that we swapped Will Byrd: the 2 Condi clauses, the oar part, or that we swap these 2 unifications. Will Byrd: The problem is that this, this recursive calls coming first and Mini Cameron executes within a single conjunction many Cameron executes the goals Will Byrd: in order from sort of top down. Will Byrd: So the problem is. there might not be an answer which means that one of these equality constraints or unification constraints might fail. Will Byrd: But the problem is, the the failing might happen after this recursive call, and if you look. Will Byrd: the the d and the res are fresh, they just got introduced. They don't have any value here. Will Byrd: so d and res are fresh at this call Will Byrd: S might also be fresh. Will Byrd: Even if, as if, even if F. The if S. Isn't fresh, you still have the problem that you're going to keep entering this condi with the first clause trying this recursion. It's just going to keep trying to do the recursion forever looking for an answer that doesn't exist. If the answers exist like those 6 answers that exist, and we only ask for 6 answers. Then it works just fine. Will Byrd: Okay? The problem is, we don't have refutational completeness. We have completeness. The search will find answers that exist, if there's enough. Will Byrd: you know memory and and enough computation. But Will Byrd: it might not ever find, be able to figure out or prove, then answer doesn't exist. Will Byrd: Now, in this case it's relatively easy to fix the problem. because we can just put the appendo at the end. Will Byrd: And now, if I try this again, it terminates. But the problem is in a more complicated program. You might have multiple recursive calls or multiple calls to helpers that are recursive, and you can't put them all last. Will Byrd: Okay. Will Byrd: and and and and those sorts of cases. It will depend on Will Byrd: whether or not one of these arguments coming in is the logic variable, or one as ground as to whether or not you get reputational completeness. Will Byrd: So this is the Achilles heel Will Byrd: of Turing complete logic program. This is true and prologue, Truman and Camera, and true in other systems. And this is why Bob Harper claims that logic programming is not declarative. Will Byrd: and there is. There is an argument to be made there, and I understand what he means by that. Will Byrd: So you know, logic programming doesn't Will Byrd: live up to what you would hope it would do. Will Byrd: Because of this problem. Okay, so this, this is sort of the first. Now, I will show you just kind of one more cool thing with the pen Will Byrd: cause, I think, or appendo, because I think I think it's worth seeing. Will Byrd: Yeah, we can also write things like this. Will Byrd: Okay? So we can partially instantiate Will Byrd: arguments. Will Byrd: So so you know, first, argument now is list ev followed by Will Byrd: anything else that we call X, and and that works. and I can. Will Byrd: You'll run Star, and get all the all the results. Will Byrd: So so it's very flexible paradigm. From that standpoint. Will Byrd: However. you know there, there are some trade-offs Will Byrd: now. I can show you, all sorts of other things. I can show you client generation and relational interpreters, and. Will Byrd: you know, kind of our our standard things environment. I've also given a lot of talks on this stuff, and some people may have already seen those. So you know II don't know if you want me to do my usual dog and pony show, or if you want to talk a little bit about things, or if you know at what point you want me to talk about Will Byrd: ideas, for you know Will Byrd: maybe how to go go beyond some of the problems. So Will Byrd: what what do you think? What people would like to keep showing more? I guess we got one. Now we're left. HFPUG: I'm still curious. Why it sucks. Will Byrd: Yeah. So so part of okay. So let's talk about some other issues. Will Byrd: so like, I didn't even tell you the good parts in some sense, right? You just kinda have to believe me. But I've you know, given Will Byrd: lots of talks. Yeah, II wrote, I made this talk called the most beautiful program ever made. Will Byrd: It's like the success of clickbait titles. So if you want, you could watch that talk, and I show kind of Will Byrd: what happens when you write an interpreter for scheme in this style and all sorts of cool games you can play. Actually, let me just show you one thing about that one first. Okay, just so that we can. Will Byrd: Yeah, I'll do it quickly. Okay, I'm not gonna get into all the details. Will Byrd: But I think this is probably worth seeing. Will Byrd: there's other ways. I think you might not appreciate kind of the the full, interesting part of it, and the full kind of while this is going to be tricky to make it suck less. Will Byrd: So I just loaded an interpreter for scheme written in in mini camera. Will Byrd: I usually show quine generation and I can do it this time. I'm just gonna show one more example. Will Byrd: So so in scheme Will Byrd: like, I'm using a shade scheme. Right now, there is the ability Will Byrd: to do this code data isomorphism. People call it right. So you know, I can do things like plus 3 4. That was talking about before evaluates the 7. But I can use this quote thing. Will Byrd: And now Will Byrd: that expression evaluates to the list, plus 3, 4. Will Byrd: Okay? And I can manipulate that list just like a list. I can take the first Will Byrd: thing in it. And I get plus, for example. Okay, so it's not Will Byrd: it's not actually. Will Byrd: but Will Byrd: the procedure that knows how to do addition. It is like literally the simple plus. Will Byrd: But I cannot call this eval function. Will Byrd: And I can take something like the quoted plus that just the symbol plus. And I can get Will Byrd: my hands onto the procedure Will Byrd: that it's associated with, or I can eval Will Byrd: the quoted plus 3, 4 of that list. Will Byrd: and I can get my hands on the 7 just to make it little more clear like I can say, define Will Byrd: lists to be Will Byrd: quote plus 3, 4. Okay? So I'm really not cheating here. This is list I can ask, is Ls a list. Yes, it is Will Byrd: okay. What's the length of it? It's really list of Link 3. Will Byrd: Let me, Eval Ls, and I get back 7. Will Byrd: Okay, so scheme has this eval mechanism has a scope mechanism, and they Will Byrd: they sort of are gen and gang in a way. Will Byrd: Okay, so that's very, very cool and very powerful. Will Byrd: I can also quote, like Lambda expressions and all that checklist. Will Byrd: Well, we are. Gonna write our own Eval in scheme or more. The point. I've written an Eval in scheme Will Byrd: and with other people. And so we are going to just like we called appendo. We're gonna call Evalo in the relational setting, so I could say, Run one. Will Byrd: 1, one cube Will Byrd: evalo. And so the Val. And scheme takes an expression and evaluates it and gives you back a value. Here. We, of course, are playing this relational game. So we don't talk about inputs and outputs. Instead, we have some expression and some values Will Byrd: that's related to the expression, so I can give an expression like cons, 3, 4, and then queue is the value of that expression, and I get Will Byrd: the the pair 3.4 fine. Will Byrd: No. the interesting thing is the the interpreter that I've written, or with with other folks. This avallo thing it supports a fair amount of scheme, actually. Will Byrd: And so it even supports like racket style, pattern, matching, and so forth. So I can do things like write a let Ric. Will Byrd: This is a recursive Will Byrd: form. And I can write scheme append. Okay, this isn't append O, and been a camera. And this is Schema pen. And I could say, Okay, we're back in the horrible functional setting where there's inputs and outputs. So we have 2 inputs. Will Byrd: And I'm going to say, if Will Byrd: L is the empty list. We're going to return. S. Otherwise we're going to cons the first thing Will Byrd: in L on to the recursion Will Byrd: of the rest of L. Will Byrd: Let's see, I don't hope my little thing is not blocking. Okay, here we go Will Byrd: the rest of L to. S, okay, so that's Will Byrd: that is the definition of a pen, and then inside, let rack. I can make a call to a pen Will Byrd: like, append Will Byrd: A, BC, 2 DE, Will Byrd: okay, so this whole, let Ric expression is just a scheme expression. I can literally just take this and run that in scheme. and it will give me list A, BCDE. But I'm running this within the context of an evalo. That's the relational version of the evaluator. Will Byrd: And I'm doing a run one queue. Maybe I can. Maybe this makes a little more clear. I can say, I want to know what the value Will Byrd: of that expression is in scheme. Will Byrd: Okay, so, Val, is my query variable. Will Byrd: and I should get back the value of that expression. And sure enough, I get a list containing list A, BCDE alright fine. But the part that's more interesting is that? Then I can say, Oh, okay. So I want Abcde. Let's say, to be my value. Will Byrd: Now I can say. well, huh! Maybe I can put. Will Byrd: you know, an expression E within this call to append. So I'm appending some expression E to the list DE to get a BCDE. I want to know what the E could be. Will Byrd: And so, okay, EE could be the list you back from, quote the expression, actually quote ABC, all right. Now, I could ask for a second expression. Now. Will Byrd: maybe you know, should there be anything else? Or is that it? Will Byrd: Is there anything other than West? ABC, HFPUG: okay, go on HFPUG: thinking you could maybe have a list of HFPUG: contain a maybe, and CD like a list could end through this and maybe try and record them, you know. Do that with that? Will Byrd: Well, okay. So I don't know if this is, get what you're getting at. But the key thing here is Will Byrd: E is actually an expression, not a list. It's not a value. It's an expression. Okay. So we are getting back expressions Will Byrd: that if you evaluate them, give you the list. ABC, so like, here's one. Will Byrd: This is a little hard to read, maybe, but if I just run this in scheme. Sure enough, it gives you back to the list. Cvc, what this is saying is, this is a lambda Will Byrd: of Will Byrd: that there's like a Var. R's lambda applied with 0 arguments, and it evaluates the list. A, BC, so basically, Mini Cameron is doing program synthesis to find expressions. Will Byrd: and there are infinite many of those that when you evaluate them and give you back a list A, BC. Now, if I put a quote in front that expression. Will Byrd: Then there's only the quoted list. Will Byrd: only quoted values. In that case there's only the quoted list, A, BC, Will Byrd: okay. But it allows us to start playing playing programs games. And I can also do things like this. I could say. Will Byrd: well, you know. what about this car? Cons of Car L, you know, could I replace that with an expression? Okay? And sure enough, I can. So now, I'm actually starting to do real program synthesis where I can start synthesizing parts of the definition of append Will Byrd: from an input output example. Will Byrd: And we've pushed this a fair amount. We've got a tool called Barlamin, where we can synthesize all of a pen from Will Byrd: input output examples. That kind of thing. Will Byrd: So you know, that's kind of the the most interesting example we have. And Will Byrd: now, why does that suck? Okay? Well, that part doesn't suck. That part's awesome. That's the cool part. Will Byrd: Okay? So that part doesn't suck. Will Byrd: But okay, fine. If you think that doesn't suck, I guess I'll just show you the show you one other Will Byrd: thing and see if I can get away showing this. see if this works. yeah, maybe this works. Okay. So I'll just I'll try one more time. Will Byrd: see if I can. Will Byrd: I don't know if you'll be able to see this like if I zoom in. Can you see me zooming in or not? HFPUG: You can. Will Byrd: So so okay, so I guess like it zooms in like that. Oh, cool, alright. Well, then, this is probably easier to read then. Will Byrd: Okay, so this is this parliamental that I worked on because I was. I got tired of trying to Will Byrd: tell a Java programmer who asked me what I do like, you know? How do I explain to them. It always like, give them a 3 h tutorial and lambda calculus, or whatever, so that, you know it's actually better to just kind of put an interface over what I was just showing you. Will Byrd: So I created this Parliament tool, and then Greg Rosenblatt made it much faster. Will Byrd: But the idea here is, we can have a programmed skeleton. Will Byrd: So this is part of a program. But it doesn't have a whole lot right? We're just defining some procedure. But you know we don't know what the name is that the comma a means that's like a logic variable. And this whole thing is quasi quoted. If you know. Lisp. Will Byrd: we don't know how many arguments the function takes, and we don't know what the body of the function is, so we don't know a whole lot about it. But what I could do is start giving examples. So you know, here's our buddy append again. Will Byrd: And so I could say, input and output example. Will Byrd: You know a Pan empty list. The emptiness gives you empty list. And now here the system tries to fill in. Will Byrd: The values of those logic variables based on that relational interpreter. I was showing you that behavior Will Byrd: with optimizations or or with heuristics to help make it faster. And so here it says, Okay, the best guess is that the functions called append. Will Byrd: and well, it could be very attic. It could take any number of arguments, and it returns the empty list. Will Byrd: Okay, it's a static function like, well, that is true. That that match my example. So it's not wrong. Will Byrd: He was like, prove me wrong, you know. Will Byrd: You only give me one example. So that's fine. So we can try giving another example. Will Byrd: So maybe like List A to List B should be listed E, and it'll it'll think a little bit. And so so now it's got a more complicated program it came up with. Will Byrd: Now it takes 2 arguments. We don't know what the arguments are called Will Byrd: and now it came up with conditions. So if so, if the second argument is the empty list, return it otherwise return the list. A, B, Will Byrd: okay, so it's sort of over specializing. Will Byrd: But I can go in here, and I can also edit things like II might say, Hey, you know, let's call the arguments like X and Y, okay. Will Byrd: and now you can see that. Okay, these arguments are are now referred to Will Byrd: is x and y, so I can, you know, do this sort of editing all I want. Will Byrd: I could also, if I wanted to. Will Byrd: do something a little. a little more generic. So here you can see it's over specializing to the A and B, Will Byrd: because those are an example. Will Byrd: But if I want to. Will Byrd: I can use these sort of abstract abstract values instead of A and B Will Byrd: but in this case what I'll do is I'll use another trick which will say, like, I'll just do Will Byrd: another example with 2 different concrete values. Will Byrd: And so that gives me C and deep. Will Byrd: Okay. So at this point, you know, it could come up with nested ifs or whatever. But it's actually it. It finds more quickly Will Byrd: this Will Byrd: this version that doesn't specialize on the exact symbols anymore. So you're you're not seeing A and B there, but Will Byrd: it hasn't figured out the whole thing because it hasn't figured out the recursion so. and try giving it one more test about EF to GH Will Byrd: Now Will Byrd: given them doing a zoom call, you know. This might take a minute. So I'm not. I'm not sure. But you can. Will Byrd: You can kind of see what's going on here, where we're doing input output based program synthesis. Will Byrd: Now, okay, we came up with it in what? 11.6 s. Okay, so here's the got the recursive call. So that is the correct definition of the pen. Actually. Will Byrd: okay. now. Will Byrd: this already shows, though, a couple of problems. I mean Will Byrd: one. Well, I should. I don't. I don't know if this, the demo shows it. But there are problems latent here. Okay, so one problem Will Byrd: is, if I take that first base case and move it last. Will Byrd: I don't know what's gonna happen. This might. It might come back in, you know, 20 s, or it might come back in a million years. I don't. I really don't know. Will Byrd: Certainly, if I reverse the order of these input output examples. Will Byrd: the amount of time it takes is going to increase, you know, probably exponentially so. Will Byrd: there is a dependency because of that conjunction problem I was talking about. Will Byrd: you know, this sort of programming is highly sensitive to the ordering Will Byrd: in, in the conjunction, the ordering of those polls in the conjunction. And it's also sensitive to the ordering of the disjunctions as well, although I think that's not as critical. Will Byrd: So so this is so. So is that HFPUG: I mean, I guess this is where you're getting to, of where there are problems. So so HFPUG: this is is this part of what you're trying to solve, or or this is just a limitation of how it was implemented. Will Byrd: Okay, well, I think, okay, so that's a good question. Alright. Will Byrd: I'm actually going to Will Byrd: for my computer mail cycle. I I'm not actually that curious about how long it will take to, you know, a million years or a billion years. It's all the same to me. Yeah, come back in a million years. We'll see if it made progress. Will Byrd: Okay, so that that's I think that's the right question. Right? So Will Byrd: one of the things has made Minnie Cameron a success. Will Byrd: There are a couple things. One is that the implementation is very small. and in particular Jason Heman and Dan Friedman have a paper Will Byrd: on what they call Microcanon, and that's about 50 lines of scheme code. Will Byrd: And now everyone who gets into Mini Cameron ends up implementing a Michael Cameron, right? So it's like kind of like scheme. Everyone gets in the scheme implements this little scheme interpreter, maybe a compiler right? So same with Mini. Can everyone who gets in the mini camera and ends up implementing one Will Byrd: and you know that implementation ended up in the second edition of the schemer. Will Byrd: And that's great. And so that's kind of one of the things that many candidates known for. And in particular, there's this higher order, representation of streams, so their procedures or functions, that implement streams which are, you know. Will Byrd: basically Will Byrd: lazy, potentially infinite lists, which are how we do all of this. Will Byrd: you know, magic with, you know, how do you have influently a large tables. Well, we actually have streams filling in the competition pull from the streams. Will Byrd: and so all the search and all the laying is is is from streams. Will Byrd: But Will Byrd: while that is awesome, that also is awesome, and the default search in many ways is pretty awesome. This interleaving search strategy that this complete interleaving search that Ola Kiseroff came up with. Will Byrd: All of those things are awesome within certain contexts. and they are decidedly not awesome in other contexts. So if your computation is finite. Will Byrd: You shouldn't be using this sort of mechanism. You should just be doing the prologue depth-first search. It uses much less memory. There's much less overhead. It's much faster. if there, if you are using a restricted set of Mini Cameron to do actual database operations that might correspond closer to SQL, or data log. Will Byrd: in which case you should use a totally different mechanism of solving, which is what a data logs operator use. Okay? So the problem is. Will Byrd: we have tied the semantics of language. Will Byrd: We've we've tied the declarative meaning, the declarative semantics and the operational semantics and implementation together completely. Will Byrd: which means that when Greg was trying to Will Byrd: get Barlamin to to work and be more efficient, and he sped it up like 9 orders of magnitude. In some cases. Will Byrd: you know he had to like, hack it to death. Will Byrd: and he had to, you know, muck around with the search and add special arguments, saying, this, search this part of the search gets this much. Will Byrd: you know, overweight, you know, he was doing all this stuff, I think. Will Byrd: Instead, there's this approach. It's an old idea. Okay. So we, I've been talking to a bunch of people. Who do, you know? For whatever reason, I think this idea is kind of in the air Will Byrd: among people who care about many. Kanarim is like, Okay, it is time for us to go back and realize that that Will Byrd: while that little implementation got us to where we are. Will Byrd: We are stuck because of it. That so there have been several mistakes that we've made over the years. The first mistake, I would say. Will Byrd: was in the first edition of the reason schemer. We tied the implementation Will Byrd: to scheme macros in a way Will Byrd: where we didn't understand how hard that would be for non-skimmers Will Byrd: or non scheme experts understand? So we say, Hey, here's a little syntax rules hygienic macros. Well, if you're not a schemer that is so scary. and even people like David Nolan, who implemented core logic Will Byrd: enclosure, who is a brilliant programmer. He didn't understand it. He didn't understand until I wrote my dissertation, and really went into all the details, and we heard this from many other people that you know scheme has a very different approach to syntactic abstraction than any other language that I'm aware of. Will Byrd: And so we made this mistake that oh, yeah, we'll just see. Here's some simple macros, and they're only like 5 lines long. So people are going to be hacking macros left and right, and I'll know. Will Byrd: No, there's like people just didn't understand the macro. So they're like, what in the world is this? II don't know what to do. Will Byrd: so what? Will Byrd: What Jason and Dan did in the microcanon paper, which I think was brilliant Will Byrd: in hindsight for someone. That's it. But they separated very clearly the macros from the procedural part. Will Byrd: and as a result, people have ported microcanon to you know. Will Byrd: probably hundreds of languages at this point. It's just like a standard thing you do. Will Byrd: So that was important to to realize that we need to pull this apart. And and, by the way, you know, Dan and I thought for the first edition Will Byrd: that run interface, I was showing you. That's just like a macro. There's a there's a Co run run, or just very, very short macros. We figure everyone's gonna roll their own interface. Here you go. Here's a macro, you know, have at it. No one changed it. Will Byrd: no one got it. No one's like, Oh, yeah. Yeah. Well, no. Will Byrd: no. The only people I know who, you know, ever played around with the interface, for people who had, like, you know, implemented large versions of many Canada like, you know, the true experts was the only ones who hacked around. So we completely Will Byrd: mis misunderstood. We completely underestimated the difficulty people would have. Will Byrd: And I think another problem Will Byrd: is we just Will Byrd: in the name of simplicity. In the name of short code. we made this tremendous mistake Will Byrd: where we tied the implementation, which is beautiful, I mean every single character, every single character was thought over and Will Byrd: bled over. Dan spent, you know, more than the year trying to remove one line of code. And then Jason convinced them to put it back. It was like, I mean, seriously, the this implementation has been gone over and over with a fine tooth tone comb, which is great. Will Byrd: But the problem is it optimized Will Byrd: for succinctness and for people to be able to understand it in some sense? But it did not optimize for separating the declarative meaning Will Byrd: from the implementation and the search and the heuristics. Will Byrd: Okay? So the the thing that Will Byrd: I think we've realized that if you actually want to be clever about it about the search, you probably need a first order Will Byrd: data, structural representation of the search tree. Will Byrd: You don't want procedures that are, you know, opaque objects that all you can do is call the procedure and get the next part of the stream. You want some sort of reified data structure. You can inspect the tree. You can manipulate the tree. Will Byrd: You can write debuggers. You can write optimizers, program transformations, all sorts of things like that. You also probably need a compiler. Will Byrd: At some point, you know. So there's only a certain amount you can do with an embedding. But, Eve. Even if you're gonna stick with an embedding. Will Byrd: you probably need a first order representation. You probably just need to break out Will Byrd: as much as possible in the way that Kowalski advocated in the seventies. Now, Kowalski said that Will Byrd: algorithms Will Byrd: equal logic plus control. Okay? So the problem is, we've smashed the logic and control together completely. Will Byrd: and even the implement, even though the implementations, 50 lines of code and in some sense is very easy for people to port it. It then takes them. Maybe, you know, 10 years to realize. Oh, that was like a bad idea, though, most like, now you have to. Yeah, now you have to like kind of unlearn everything to realize that. Oh, yeah, I actually shouldn't have done that, you know. It's fine to learn. But it it really inhibits the Will Byrd: optimizations you can make and HFPUG: And so that's schemer, especially second edition, or the paper Will Byrd: the micro canon paper, like the microcanon paper, is a tutorial reconstruction. Will Byrd: And so you learn about why the interleaving search is important. You learn about different things. Okay, in the book we talk, you know, we walk through unification. So in a lot of ways, I think you do learn the concepts. Will Byrd: However. Will Byrd: what you're really learning is a specific implementation of concepts as opposed to here is a more abstract way Will Byrd: to clearly separate, you know, like it's, you know, you learned an implementation that Will Byrd: chose to mix the logical specification with the operational submit. That's what you Will Byrd: okay, you learned an operational semantics. But there are many others that you could implement. Will Byrd: And so I think the next stage Will Byrd: is to try to take a step back from that and say, actually, we want to abstract over that we want to give. Will Byrd: We, you know, even if we want to keep exactly the same Will Byrd: declared of something. Maybe we want exactly the same semantics as Mini Cameron currently has, or the variance of mini camera because we have nominal logic and a whole bunch of other variants. Maybe we want to keep those the same. Will Byrd: But we want to abstract over Will Byrd: how those are implemented. How the search is implemented. Different relations should be able to have different search. Will Byrd: You should be able to have under the hood inspection of you know the groundness of terms in a way where, as Kent Divig says. Will Byrd: you can do optimization which is cheating without being caught. Okay. So you still want it to feel declarative. Will Byrd: But Will Byrd: that doesn't mean that you should throw away every opportunity Will Byrd: to prune the search tree, for example, or to dynamically reorder conjunctions, which is what happens in Parliament. The conjuncts are dynamically reordered. Will Byrd: and that's one way that you know. Greg was able to speed things up by a billion times in some cases. Will Byrd: So that program I showed you, by the way, that took 10 s or 11 s that would have taken at least a century Will Byrd: to run with the original implementation. And so. Will Byrd: yeah, so so that's the thing. And we want to be able to have specialized solvers and all that need a program or annotations, or, you know, some some smarts underneath the hood to try to Will Byrd: to figure it out. So so anyway, that's what I think is kind of the next Will Byrd: phase of the implementation is is separating those more. Will Byrd: And and there are, you know, pro log implementations like child prologue. They think you a decent job of this. But you know your Mini Cameras Will Byrd: special, I think, in its emphasis on relationality and some of the examples we could do. So I think you know again, I guess here's one way to look at it. Will Byrd: When we first did Minican rhythm. There are a lot of people who could run our implementation. and maybe they could play around with it. Maybe they could kind of understand it. Maybe they could port it to another lisp in the second implement, the second version of the book, or with the the reason, I mean the the Will Byrd: micro camera. They're a whole bunch of people who are able to port a micro camera into a language of their choice and understand it. They were able to understand all that they're able to do little hacks. Will Byrd: So that was great. I think it will raise the level of understanding and raise the number of people who are able to play around with things and experiment. Will Byrd: But what we still haven't seen Will Byrd: is large numbers of people who have the people who have implemented these systems playing around with the optimizations playing around with different search strategies, playing around with those sorts of things. Okay. Will Byrd: you know. So so each time we figure out a way, I think, to raise people's understanding a little bit more. But now I think we've reached a plateau for a while. Will Byrd: where, unless you're Greg Rosenblatt or Michael Valentine, or an old league or whatever. Will Byrd: Then you the sorts of hacks that are necessary to get good performance or to. you know, implement alternative evaluation mechanisms. It's just too hard right now. Will Byrd: And so I think that's Will Byrd: that's the next challenge is to do that in such a way that large numbers of people can and understand it, and they'll they'll be able to hack on it. And Will Byrd: yeah, I think it's important to have Will Byrd: an influx of new people and influx of new ideas we're not supported by. You know. We're not verse. We're not supported by fortnite, you know. We're not fortnite powered. Will Byrd: but you know. So Will Byrd: we we have to have to have to get people who are interested. You know, we we are weirdo powered. Right? Yeah, we need to get some weirdo nerds who are like, Oh, yeah, this is cool. So Will Byrd: so. But that's that's what I think Will Byrd: is sort of. The next thing we need to figure out is how to how to separate the declarative semantics from the operational semantics, and then Will Byrd: have a way for people to be able to explore these heuristics and different search strategies in such a way Will Byrd: that yeah, we kind of kind of get unstuck so that you don't have to be a Greg to create a barman like creating a barman right now is seen sort of the way that Will Byrd: Mini Cameron was seen when we still have the macro, like you, have to be some genius to create Parliament. but it should be the point where, like everyone, creates a Parliament who's interested in this like it should be just like a standard exercise. Will Byrd: It's like, Oh, yeah, you know, here are a few optimizations. And you know, you know, just like there's many set, you know, you can create that solver. And Will Byrd: yeah, small number of lines of code that has a few of the Will Byrd: the the standard techniques are known to work. Well, you know, there's there's no reason you shouldn't be able to create like a barman. Will Byrd: You know, if if you're able to implement a microcanon. Will Byrd: you know the the difference between that and implementing a bar lament should actually be small Will Byrd: right now. It's not. Will Byrd: anyway. That's what I'm thinking. I don't have anything concrete to show you. But you know, I guess part of this is, I was using Will Byrd: this talk as a forcing function to force me to start thinking hard about. Okay, what is it that we actually need? In fact, it wasn't until this ramp that I it's like, actually, that sounds reasonable. Maybe this is good thing to do. Maybe maybe I need to talk to to Dan about doing new book third edition. Will Byrd: So Will Byrd: anyway. So that's kind of what sucks about many Kevin Will Byrd: But hopefully, you can do a version to sucks list HFPUG: questions. So what you just talked about it. It sounds like a very high level. The classic problem, you know build would implementation that you're gonna throw away. Will Byrd: Hmm. HFPUG: stuff right? Well, that way, right? And build a new HFPUG: because we learned a whole bunch of stuff that is that a fair? Will Byrd: Well, II mean, I guess we've been doing this for about 20 years now, and we've thrown away an unbelievable number of these. So okay, that's a different problem. Which also is a problem. By the way, the problem isn't so much that we're throwing away a bunch of things. I mean, that's good or bad. Okay, it's more like Will Byrd: we have Will Byrd: a whole bunch of research prototypes, exploring things like. you know, higher order, unification or our pattern matching or nominal unification or constraint, logic programming of refined it to means, or a whole bunch of other things. Will Byrd: And each one is its own kind of artifact that someone implemented or a couple of people implemented at one period of time using one version of the implementation technology in one programming language. And they Will Byrd: don't compose right? So we have, like 30 Mini Kanderon variants. all of which are interesting. But we don't have what I call Big Cameron. So that was another dimension that we can might go in Will Byrd: is to have Big Cameron, which is okay. Let's figure out how to put all of these features into one system. Will Byrd: Now there's some tension here which is similar to the tension in the scheme community about standardization. Will Byrd: III remember going through the R. 7. You know I was. I was a grad student when R. 7. I'm sorry. What are 6. When our 6 started our 6 Rs. Will Byrd: Our 5 Rs. Was the scheme standard. It was pretty small even then. Some people complain. It was too big. Will Byrd: But R. 6. There was a need for a new standard, it was felt because no one could run code and different scheme implementations. Will Byrd: And the process, let's say, wasn't very smooth. and in fact, it was so not smooth, that our 7 was almost a reaction, or was a reaction to it where they said, Okay, the problem is, there are 2 parts of scheme. Will Byrd: There's like the really tiny jewel-like feature that everyone loves right. And it's great for ideas and hacking. And that's like Micro Canyon. Will Byrd: the tiny little thing that you can hack anyone can implement. And then there's like, Hey, people actually want to use this for real Will Byrd: like, they want to use it like they might use closure or something. And for that, you know, the tiny 50 line implementation maybe doesn't work so well, right? Maybe you want some libraries, you know, stuff like that. Will Byrd: So Will Byrd: in scheme that tension is felt so severely that for R. 7 they actually broke it. The standard into 2 versions, a small standard and a big standard, and the small standard was finished. Will Byrd: 2013 or something. I don't know the big standard still going. I don't know if it'll ever finish. Okay, I mean, seriously, it's been going on a very long time. Will Byrd: And so you know, that's, I think there's that same tension and many canon, because it is a teaching language. It started as a teaching language and a language for hacking up Will Byrd: implementations very easily. So you can explore just like scheme. But there are also implementations like core logic and closure, where a a company that was bought out for probably on the order of a billion dollars Will Byrd: use that technology. So you know, what should it be? Should it be something. Will Byrd: you know, very pragmatic, that maybe has all sorts of features and optimizations. Or should it be this like tiny thing that you could teach any undergraduate? And they can hack up a version in an afternoon. Will Byrd: I don't know. I guess we're trying to Will Byrd: do a little of both. Will Byrd: so you know, there's this big Cameron which is kind of the opposite of what I just was talking about, because that's not something you're gonna have an undergrad do, or a hobbyist do. Big Cameron's like, Oh, yeah, take 30 different implementations and shovel them together. Well, that's not an afternoon project. Will Byrd: But then there's also this kind of. Will Byrd: you know, trying to get more people into the fold. And so from that standpoint, I think, more in terms of books and papers like. So Will Byrd: you know, we have 2 editions of this Mit press book. They were 13 years apart. Will Byrd: and each version had an implementation that had some success. But the implementations were quite different, and I can imagine. Will Byrd: say, a third version that would be different. Still, that would try to separate these concerns more. but yeah, I mean, I mean, I guess part of it. Also, there's this what I'll call the Java phenomenon, you know. Okay, so I'm not a fan of Java. But Java did do something that was really important which has got people to accept garbage collection Will Byrd: that was critical. And if that was the only thing, and also got people except virtual machines, right? So those are 2 things. Will Byrd: Those are all old ideas. But they weren't really accepted as things you could use in industry for serious programming. That was like, I mean, I talked to some C programmers like garbage collection. Go back and do lists more on, you know that was the reaction. And now it's like, Oh, well, if you're not doing garbage collection, you should be doing something more sophisticated, not less sophisticated. You should be doing like rust and borrow checking, and whatever right you shouldn't shouldn't just like is free for all. Will Byrd: So that was a big change. And and Will Byrd: I think it just takes time for people to accept ideas and learn new ideas and techniques. And industry has been very slow to adapt, and I think it's just true. In general, these are hard things like logic. Programming Will Byrd: has a, I think, well deserved reputation as being very hard to understand. So over time we've tried to get more and more people Will Byrd: to understand more deeply some of the core ideas. But every time. There's still like a limit. As to you know. Will Byrd: to to what people, what what we can, under what we can explain. Or, first of all, we're learning how to explain things to people over time Will Byrd: and also to kind of what are the ideas. And you know this group. Will Byrd: when I started grad school. This sort of group didn't exist. There weren't functional programming groups when I started grad school Will Byrd: and when I was working in industry, you know you, I had to explain to people what functional programming was. They're like, what is that Will Byrd: I've heard of that, II think, heard. That's the thing. What is that? It's like, when use functions. What is that Will Byrd: right? And I had to explain to me. I was like, now it's like, Hey, you know, John's got lambda right, so the other, the the landscape has also changed. So some of these ideas. Will Byrd: you know, the the abstraction has increased, and now, like generators, those are accepted idea. Right Will Byrd: now we have verse, okay? Which Will Byrd: is Will Byrd: some flavor of I don't know. I don't know what to call it. I mean, they're saying it's a functional logic language. Maybe. Will Byrd: you know, it's it's not what I consider a functional logic language, but Will Byrd: maybe they will define the term. But it's like very similar to Icon in a lot of ways, and so has has some very interesting ideas in it. Will Byrd: So in a world where there are a bunch of developers, programming, fortnite and verse. Will Byrd: Some of these ideas just might be easier to get past, like, I think over time, we've gotten more abstract. So Will Byrd: so I don't know if it's a second system effect. I don't. I think it's a little different than that. It's more like Will Byrd: Every once in a while, you know we, we feel like we're plateauing either in our explanations to people or people coming into the community or our own ability to make progress. And I feel like right now we're at a plateau where Will Byrd: where we were making some progress. And Will Byrd: now I feel like we're kind of stuck, and we're trying to figure out, well, why are we stuck where we stuck? So that's I think the heart of the issue is that we had this one implementation strategy that worked really well for certain classes of problems. Will Byrd: But it it needs a lot of work to to make it work better for other things. And Will Byrd: we're just like, the implementation that was wildly successful kind of locked us in. HFPUG: Do you ever see a case where? Let's let's take the case of the functional programming concepts sort of merging into the object-oriented languages like. HFPUG: you know, Lambda is going in the job. Do you ever see a case where HFPUG: it just sort of becomes part of the Standard Library in some of the more mainstream, instead of instead of being a separate thing, it just kind of. Will Byrd: are you talking about functional programming and mainstream like languages in particular, or just more abstract things or or logic programming, or what? Will Byrd: Yeah, relational constraints. Will Byrd: Well. Will Byrd: you know, logic programming has been around for a fairly long time, you know. I'd say, certainly since the early seventies. and it it had. You know, it had this kind of weird moment. In a way. Will Byrd: in the 19 eighties with the Japanese fifth generation project, where the Japanese government and this industry consortium sort of decided to standardize on prologue Will Byrd: for a while. and they did some really interesting work. and you know they had languages other than proline Will Byrd: but a lot of it, I think, was in Japanese, and a lot of it sort of didn't escape Japan. And then the funding ran out from the government, and the project kind of went away. Will Byrd: and there was like this kind of AI winner. It's sort of similar to the list machines, right? What happened? List machines in the in the 19 eighties in the Us. You know, the same thing kind of happened with prologue and logic programming. In Japan. Will Byrd: We had custom hardware. Will Byrd: and you know, a lot of money and a lot of ho high expectations. And then people say, Well, I didn't really Will Byrd: really mix. Meet those expectations. So there was a time where in Japan, in the 1980, s. Like, you know, anyone in college learning programming was learning prologue. and it was influential. And then it kind of went away. Will Byrd: And it seems like there hasn't been a follow up moment Will Byrd: where you know, with functional programming. If I feel like functional programming ideas have kind of one in that, you know, it's not like object-oriented programming is gone. But people, I think, accept. Certainly language designers accept Will Byrd: that. Things like immutability are useful, or they can be useful, and ideas of functions as first class can be useful. So you'll you're seeing these languages change Will Byrd: one change I have seen Will Byrd: is that data log seems to have been getting a lot of traction. Will Byrd: Maybe answers that program will start getting traction as well. So it was part of the problem with with logic programming is that you're always skating on the edge of what's expressable in your subset of of Will Byrd: you know all of logic. So it's very easy to enter something Will Byrd: like higher order Will Byrd: unification where every problem now becomes undecidable because you have to unify, you have to say, equivalence of lambda terms like, you know that type of thing. You can't. You know, it's like undecidable problem. Will Byrd: So in logic programming, a lot of the trick is to try to figure out well, what's the restricted Will Byrd: part of the language you can use, like Olen Shiver says, always use the the most restrictive Will Byrd: language you can get away with. Always use the least expressive language you can get away with what you want to use, you know, because you have a lot of leverage over the most restrictive language. That's why use regular expressions instead of writing an arbitrary Java program Will Byrd: when it comes to that Will Byrd: and so data log seems to be to to have made a big impact recently. So at least a subset of logic programming. And of course, SQL can be seen as a type of logic programming. Obviously, that's been very successful. Will Byrd: I think that things like answers, that programming Will Byrd: probably get become more into more more popular cause, like satin smt solvers seem to be becoming important tools more widely. As far as Will Byrd: kind of more prology, minicanron relational stuff. Will Byrd: I think over time. That'll happen, you know. You see things like generators. In languages now. Will Byrd: and there's verse which is claiming to be a functional logic language. Will Byrd: I think it is a functional logic language. It's just, very, very restrictive right now. But maybe the same thing will happen to it that happened to Java, where the first versions of Java actually weren't very abstract. And then over time the language became more abstract. So you know. Will Byrd: II guess some of my issue with looking at verse is that it seems like there are a bunch of places where they could be more abstract and and embrace the the logic programming part of it language more. Will Byrd: But right now they're not doing that, maybe for performance reasons. But I don't think there's anything in language design Will Byrd: that would keep them in the future Will Byrd: from relaxing some of those restrictions and becoming more logic programming. Will Byrd: And so, if if verse ends up, really catching on and over time, if it becomes more Will Byrd: more relational then I wouldn't be surprised if people copy that. Will Byrd: But right now I don't see a whole bunch of Will Byrd: of these features showing up in most languages. Verse, you know. That's why I get into the verse versus like the first language I've seen that was supported by a major company Will Byrd: that claim to have logic programming in its. Will Byrd: you know, paradigm since the 1980 Si think HFPUG: that's the rsd. Will Byrd: so ve VERS E, that's from. Will Byrd: Yeah, that's from epic games where people do fortnite and all that. And so you know. Will Byrd: and and it has to interoperate with C. So there are some pretty strict demands on what they can do. Will Byrd: But the idea is that you know this is part of the metaverse, and they want to be able to have strong reasoning and strong guarantees about what sort of things are allowable that probably couldn't get with C directly. Will Byrd: and so they had this interesting rewrite based semantics, formal semantics. They're based on rewriting. They had this kind of weird confluence proof. Will Byrd: like a church Ross or type confluence proof where they have to have a modified notion of confluence. But that was like the big innovation from a programming language standpoint in terms of the formal stuff like at the Will Byrd: Papal in Boston. Will Byrd: They presented like last year they presented Will Byrd: the semantics that have this rewriting system. So that's kind of cool like they have this. Will Byrd: you know, combination of functional logic, language of rewrite semantics that they can prove confluent for some definition of confluent is tied into a major ecosystem and a sponsored by a multi 1 billion dollar company. And Will Byrd: you know the the. The the head of the company. Will Byrd: you know, was the one who wanted the language. So you know, this is, this is very different. This is Will Byrd: You don't see this very often. So maybe this will be a language that has a big influence over time. I think it's too early to tell. Will Byrd: but Will Byrd: you know, if it becomes wildly successful, and you know, or even if it doesn't, it's like high enough profile that language. Geeks might study the lessons very closely, and so you might start seeing Will Byrd: some of those features in other languages, I will say that I think the language design is very conservative in some ways, compared to. you know, like prologue and Cameron, the the pure subsets. And I think the reason is. Will Byrd: you know, they they want to make sure that Will Byrd: first of all, they can deal with the effects of mutation. And C, okay, and also for performance reasons. So Will Byrd: I think they've been kind of conservative there. But I wouldn't be surprised if over time they relax, or they add alternative operators? Will Byrd: right now they have a list-based semantics. Will Byrd: for example, for a lot of their operations, I think they could go to a set based semes, and Will Byrd: in some cases is they do left to right evaluation of everything. I think they could go to a nondeterministic evaluation in some cases. So Will Byrd: yeah, I don't know. I mean, we'll see what they end up wanting. But Will Byrd: it is. You know, the first time I've seen functional logic language Will Byrd: touted in any commercial prospects, even even if you disagree Will Byrd: with what functional logic programming. So I guess you know, it also reminds me a little bit of Will Byrd: looking at it. II had a little reaction that I had when I first saw closure, which was. Will Byrd: Oh, great! A new list! I'm so excited. Let's see. Let's see about the tail recursion. Oh, no tail recursion. Let's see about the hygienic Macro. No hygienic macros, and I'm like Will Byrd: put it back on the shelf right? But that was that wasn't a fair reaction, because, you know, rich. What Rich was trying to do was different, right? And he was trying to live in this ecosystem, and so, you know. Will Byrd: my reaction of verse was excitement, followed by extreme disappointment. Will Byrd: But I think it's sort of like my reaction to closure where it's like, okay, they are trying to solve a certain problem in a certain ecosystem, a certain constraints that they can't change Will Byrd: And in that standpoint, from that standpoint, maybe it makes perfect sense. And it also may have the longer term effect that people start looking at constraint, logic programming or sorry functional logic programming, constraint, logic, programming more seriously again. So over time, it might be kind of the Java moment Will Byrd: where it's like, well, Java got a couple of really important ideas into people's minds, and Will Byrd: you know now you don't have to make the argument assuming versus a success. Will Byrd: You don't have to make the argument well, functional logic programming will never be efficient was like, well, Fortnite's using it. So shut up right? I mean, that's that's the thing that Java gave you is like, well, garbage collection, too. Slows like, well, you're using that website that's using this written in Java. Will Byrd: So so I have to say I'm I'm I'm quite upset that, like Will Byrd: you've made it so. I can't yell at my children to stop playing fortnite to stop playing it. But they now the need to start programming it? HFPUG: Thank you. HFPUG: So when you're saying that full time track. HFPUG: what does that actually mean? Does that mean that you guys have a communicate like how much communication is happening. Will Byrd: Well, okay. So I should be careful here, because I also don't. Will Byrd: I don't understand all the details. You should watch, you know Will Byrd: I mean there there was a talk Will Byrd: by Bothsimopengs. Will Byrd: and oh, epic games! Will Byrd: I'm totally blanking. Tim Tim Sweeney. Tim Sweeney, and Simon Peyton Jones gave a talk Will Byrd: at ice at Poppo Will Byrd: last January, in Boston. where they talk about this in some detail. and my understanding is that it's already being used versus already being used Will Byrd: with fortnite Will Byrd: in conjunction with C. That's my understanding. Okay, don't quote me on this because I haven't used it in anger. And then the other part was that longer term. The vision is metaverse based, you know, like Neil Steven, Neil Stevenson. Snow crash! You know, metaverse. Everyone wants to have their metaverse. Now, Apple wants to have something kind of like a metal verse, and you know Meta does. And obviously, you know everyone else. So Will Byrd: it's something like that where obviously, there's going to be some big economy. And it's probably gonna have, you know, virtual reality and games and all that, and what Tim Sweeney wants is a system where you could have a million concurrent people on the system. Will Byrd: and they're communicating. And they're trading. And there's economies and all that, and people are trying to, you know, rip each other off, and you know, rip off the system and do all the things that people do in big systems with economies, and the system would be resistant to that, because Will Byrd: we're not going to have the same Will Byrd: set of bugs that you would have if you wrote a big system like that in C, where it's whack them all. Instead, you have this well grounded semantics and the rewrite semantics and confluence, proofs and all that, and you could do formal verification, and Will Byrd: you know all sorts of things that would be sophisticated so that the underlying system Will Byrd: would be rock solid, and you could have guarantees. That's my understanding of the long term vision. Will Byrd: I don't know how that really fits in today Will Byrd: with what has been deployed. But II have heard that there are people right now programming inverse with fortnite. I just don't know the details, and I thought about diving into it, the the other, the other language is interesting, I think, is Will Byrd: the the language icon. ICON. Will Byrd: When verse came out. You know I have. I expected functional logic. I expected it to look like the language, Curry. Will Byrd: If you're familiar with the curry language, or maybe like. You know, Mercury, the Mercury language. Those are 2 languages. I think of this functional logic, and to me verse looks very different. Will Byrd: It looks closer in some ways to Icon. Now, Icon has a very interesting model. Will Byrd: So I think some of the icon ideas getting into, you know people's minds. And then, as far as I could tell, like the verse, people didn't really think of Icon when they were designing language. And then people point out to them, actually, you know, a lot of these ideas look very similar to Icon. So Will Byrd: I think icon Will Byrd: is a language full of interesting ideas. I recommend, if you're a language geek! You check out, icon, and and then take a look at Icon. Take a look at verse and see if they don't look very similar to you. Will Byrd: but yeah, I can't. I can't speak as to exactly what what the long term epic strategy is. I mean, epic seems like they're Will Byrd: in lawsuits every 2 s also. And then and then there's like some big Will Byrd: yeah, who invested in them. Someone wants to invest like a gazillion dollars like someone's gonna invest a billion something Will Byrd: I don't know. They're they're in the news a lot. But I don't. I don't actually care about that. I care about the appeal stuff. It's like, I just want fortnite, you know, inspired logic programming popularity. Will Byrd: So every time you get like what you know, I don't know Dlc. Or something, you know. Maybe maybe that's one step forward to having Mini camera. And you know, take off HFPUG: alright. So so I want to. We're. I'm looking at the time. I want to. HFPUG: thank you. And then I wanna stop the recording and we can keep talking for as long as people talk but this was excellent, and kind of mind blowing for me. Some other people here. This is really mind blowing. So thank you so much. This was, this is a ton of fun. So thank you very much. HFPUG: recording. We can ask our other questions for us other questions, Guy, to show the the stop. The recording. HFPUG: Okay.