Hi, everybody, and welcome to another episode of the Infrastructure as Code Podcast. I'm Ohad Maislish, your host for today. And today, like many of our other great episodes, we have a very, very, very special guest, Mitchell Hashimoto. Michal, it's such an honor having you today. Thank you for coming. Hello. Thanks for having me. I'm excited to be here. I'm pretty sure everybody knows you, but for those who might not have heard about you, who are you, Mitchell Hashimoto? Different things to a lot of people, but I think to the audience of this podcast in particular, probably one of the creators of Terraform, Vault, Vagrant, etc.. One of the founders of HashiCorp I'm no longer employed there at the time that we're recording this, but that's what I've done in the past and that's probably how listeners would know me on this one. Definitely, definitely. So again, super interesting to hear your points of view on the tech and infrastructure as code, So I'll just stop and jump with some questions. What is for you infrastructure as code? What does it mean? Do you think Chef, Puppet and Ansible is also infrastructure as code? What's the difference and how do you compare things like Terraform and CloudFormation compared to other technologies like I've just mentioned? Sure. Yeah. I mean, I think everything you mentioned is to me infrastructure as code. I think to me the code aspect of infrastructure as code. You know, I didn't come up with that term, that term, but the code word in there to me never really meant code as in programing. A lot of people say, Oh, infrastructure as code, actually infrastructure as configuration or something and you could get pedantic about it. But to me, I never thought about it as like literal, like ASCII style code. Like, I always thought it as like codification of processes and knowledge and systems. And so when I think about infrastructure as code, it could be anything as long as it's the process of codifying a system into a repeatable, auditable matter of form. So that's my view on infrastructure as code. So for you things like Docker and Kubernetes fall in that category as well, I guess. To a certain extent, yeah. I mean, like everything is to a different layer or area. Yeah. Yeah. That's why Chef and Puppet for sure, but not in the same way Terraform does it. You know that's not in the same way Kubernetes does it and so on. So if I would ask you, what's the difference between something like Ansible and something like Terraform? What would be your answer? So Ansible, I had the least experience with. So I don't know. I just want to disclaim that. I know it does a lot more than my experience. Since it was so small. But compared to like Chef and Puppet too, the biggest difference was that I felt that those tools as a primary mechanism were focused on within the server, and I wanted to build a tool that primarily was looking outside the server, and that was the biggest difference. I know a lot of at least ten years ago when I when we first came out with Terraform, a lot of Chef and Puppet people said, Oh, but Chef &amp; Puppet could do this. And I and totally, like a lot of technical systems are very generic and powerful, but there is a, you know, like palpable difference when you use a tool for a specific thing. It was designed or instead of something, it's capable technically of doing. And so that was the real difference. Yeah. That's a great answer. So how was Terraform created. Why did you create Terraform, what was the pain? What did you envision when you created Terraform? So the original pain you may know this history was actually the day like the exact date that CloudFormation was first published. I was in college and I wrote a blog post on that day in reaction to CloudFormation being published, where I it was very positive. I was very excited about CloudFormation, but I sort of explicitly said some of the things I was unhappy about and the things I was unhappy about was I felt like it needed to be larger than just AWS, and I thought in order to make it larger than AWS, you needed sort of an open ecosystem, a plug in, in order to do that. And I also felt that it had to be able to run on your own machine, as a bear sort of fundamental technology. But the core idea that CloudFormation was solving at the time when I first saw it, which was describe your AWS infrastructure using some sort of text format, you know, they chose JSON as I think they support YAML now, but at the time it was just JSON and it was I was a big fan of the concept. I hated JSON, the implementation, but the concept was good. And so yeah, years passed and then eventually I just felt like no one really did what I imagined would be happening. And when Terraform first came out, other people were trying. A lot of people think that Terraform was first to market and that couldn't be further from the truth. I think we felt like we were fourth or fifth at the time. Wow. Mm hmm. Yeah. Because the time that something called Chef metal or Puppet at the time that something called Puppet AWS. Yes, Docker had Docker Machine, Ansible had Ansible Cloud. And so we that we were already like if you count those that we already fifth. And so I always thought that we were way behind, but I thought that I had different ideas. So yeah. So basically you're talking about being multi-cloud unlike AWS' specific CloudFormation and creating the amazing open ecosystem that allows you to maximize the value that way. We're going to talk a lot about that today as well. The multi-cloud aspect. It wasn't to be clear, it wasn't that I thought you would mix AWS and Google and Microsoft at the time, but Amazon came out with CloudFormation. Google Cloud I don't think even existed. And Azure was something that was like a proof of concept they talked about, but it wasn't something you could like sign up for or at least that sort of like, I don't know, that was actually true, really. AWS was the only player so I wasn't really thinking multi-cloud in terms of that. I was really thinking like multi-service. I was like, How do I, you know, we all know what's Terraform now with data sources and stuff like how do I like pull information from different places? Spin up AWS, but also spin up, say like Cloudflare didn't exist at the time, but you know, things like Cloudflare, how do I spin up other things? Yep. Aren't AWS, SaaS Services in order to connect it all together? And that's why I wanted CloudFormation. But for everything. Yep. Yep. So you wrote a blog. What happened with this blog? Is it something that got some attention? I don't think anybody read it. You know, at the time at a Tumblr it was on the Tumblr. And then I well, actually, I only found it again. You know, my Tumblr shut down at some point and then Tumblr got off by somebody who was Yahoo! Or someone somewhat Tumblr got bought. And I just thought, Oh, I think I have an account. What did I ever put there? I should download it for history. And I totally forgot about this blog post and I found it and I was like, Oh my God, this is it. And I downloaded it. It's now in a gist. And so it's it's a public gist on my GitHub that no one's ever really given any much attention to. But it's there. Yeah, that's funny. Okay, so you said that you were not the first one to introduce this kind of approach, like Chef, Puppet, Ansible and Docker. What do you think made Terraform a success over the others? Is it community? Is it any other, different approach? What are your reasons? What is the recipe to make such a project successful? Yeah, I you know, I don't think it's community only because I think community is is what helps sustain a project but it's not help or helps get it or helps get it originally successful because the chicken and egg problem there, I think there has to be something really compelling at the core in order to even build that community. And then later on you could say that the thing that keeps it healthy is a community, but early on it really has to be some sort of innovative thing, whatever that is, to whatever extent that is. And I think for Terraform, it was a few things. I mean, I think the ability to run it outside the server was, yes, circa 2014 was a big deal. A lot of... only Ansible was the one that you like ran outside the server. Everything else, you ran like an agent and stuff. And again, the Chef and Puppet people could I don't think they care anymore, but they could like be like, no, you could actually technically run it outside this and that, but it wasn't primary way and you could steal it. And that was a difference. As Terraform was made to be run from your laptop and control things externally. And so I think that's a big difference. I think our ability to let people hate the state file and we can talk about that or not, but the what the state file enabled people love - the ability to complete something from your config and have it actually destroy - people loved that, really loved that. And you know, again, people could say there's obviously negative things you could say about like HCL and stuff, but I think that the configuration language was comfortable enough to non coders, non programing people, that it helped grow infrastructure as code and so I think those things sort of made it helped get it going. And maybe you know it's important to remember that you've done those things while starting a company. HashiCorp and you wanted to make these products a successful. Can you tell us a little bit about the early days of HashiCorp, how a company is being built in the early days when basically what you started is with non commercialized solutions such as Terraform, Vault and Vagrant? So how what was going on in the company in the early days and what were you trying to achieve? So from a from a business standpoint, almost nothing has it going on. I think speaking for both of both me and Arman, but definitely speaking for myself here I was really folk. We had this set of ideas and I wanted to build these ideas and I had no idea how we were ever going to make money on these ideas, but I wanted these ideas to exist. And and I was laser focused on that for three or four years, arguably a bit too long. But I was laser focused on that. And so I think all the early entrepreneur days were really around just making this idea of how we envisioned infrastructure to work a reality for people. Yeah. And that was yeah, that was really the that everyone was on board of that. So you are a lucky founder that was fortunate enough to focus a few years just building great technology without thinking about the next steps and how to build a company from that. Is that. Yeah. To say yeah and that's why we that's again all I will say. We speak for myself here just because I don't want to. I don't want to insult anyone if I'm wrong. But that's why I wanted to seek venture capital support. HashiCorp existed working on infrastructure stuff for about a year before I raised any venture capital. I was just paying out of my bank account, my savings, because I wasn't sure if that was the path that I wanted to take. And what ultimately ended up happening was realizing maybe we could do everything that we want to do without venture capital. But I memorized it would take like if we bootstrapped it and just like we modeled out of basic like revenue and how we're going to hire it would take like decades, basically. And every idea has a window like three decades from now. No one's. Yeah, if you came out Terraform in three decades for now, people would be like, what? We're so far past this. Like, why did you build it? And so I just viewed venture capital as the only option we had to really like with a big bang, be able to hire ten people and start working on the ideas and ship, ship, ship. And so, you know, there's consequences of venture capital. But I think the pros and people can lament on that however they want. Looking at HashiCorp now, however they feel. But you just have to remember that if we didn't get that venture captial, we could not have shipped all those products. And so it's the pros and cons. Type of thing. Yeah, yeah. That's the reality. And I think now it's clear with how much HashiCorp created and the success it achieved. Yeah great. But so okay so those days you created great software. Well let's let's talk a bit about community. So when was the first time you realized that people care about those things and people start to, you know, group together and build and expand this kind of approach? What you know, not every software has a growing community and here you clearly had from from the early days. So what was your observation, seeing that in action? I mean, my earliest observations were of course not HashiCorp it was observing other projects. So things like Ruby on Rails of like Linux kernel, things like WordPress, just observing projects like that and actually being a very small part of their community, just being a user, a small plug-in author, things like that. Like that's how I sort of got acquainted with it. And then my first experience personally was probably Vagrant. I never ever thought Vagrant would be that successful. I was really just building it for myself and then get that out there. And I think when I started getting pull requests and honestly, my best memories at the time were people joining the IRC channel and chatting and things like that. IRC Slack.. 10 years... years away. Yeah, years away. Slack like wasn't even a thought on anyone's mind. IRC, wow, ok. Yeah. I mean, just seeing people join, I think that that's what started to blow me away that, that people really chat about it. Like why are you chatting about that in your free time. It's so strange. So I think that's when I started processing it. And then, you know, bear in mind, I always remind people myself, even that at this time I was probably like 19 or 20 years old. So, well, you know, my maturity level was quite low as well. So these were a lot of new experiences and I was learning how to process them and understand that and so it was just very a very interesting time. Definitely. That's cool. So let's zoom in on Terraform. You've mentioned HCL, you've mentioned state file. I also want to add the terms provider and the module, what are the basic concepts in Terraform? How does Terraform work as a system? I mean, the most basic concept going back and Terraform 0.1 was the idea that you had a number of resources that may or may not depend on each other. They formed a graph, but you had a number of resources and Terraform helps you manage, create, update, delete lifecycle of those resources. And I'm saying that in the most abstract generic way possible, because that was the system in my mind was creating this abstract thing. So and then from there it sort of expanded to what provide resources they provide. And so provider is a is a short shortening for me. I don't know what people are scripting now, but and provider in me with always a resource provider, a provider own resources. They wasn't a cloud provider, it wasn't a service writer, it was a provider of resources, whatever that maybe that's why you have like a filesystem provider that exists and stuff. It's just there's no service or cloud or anything. You have resources. And then from there, modules really quickly was Terraform 0.3, I think was people saying, Hey, how do I bundle up my Terraform code and provide basically encapsulation from a programing concept? How do I encapsulate the details, Take a set of parameters, provide a set of results, outputs, as we call them, and then make that useful to make reusable things that I could update inside of without people, depending on stuff like that. That was sort of that concept. Then I think that's sort of the main. I think those are all the main concepts that are happening here. I mean, I guess, you know, the critical one, the one that I think Terraform was very much unique on was the plan, the idea of the plan. It was one of the first tools, at least that I can remember that ever had that. But the plan was showing you what it would do, before it would do it and that was baked into the core workings of Terraform. There is a big debate. If you talked about plan, do you prefer to merge and then apply or apply and then merge, what is your belief? Merge and then apply. But with a with like a with you need to you need to be using like a merge queue or something. So like one merge has to block all the other merges every plan until you get going. Yeah. Yeah. So you have to get it under control. GitHub makes that really hard honestly. But yeah. And that's like the traditional, you know, that's the traditional core of integration testing. But I feel like Google and Facebook and so on have done with Git has been that sort of concept, which is that you always or someone merges and you retest on to that on top of that and it's really a sequence of merges rather than, yeah, an obvious list coming in. But there is the, the opposite approach of applying and then merge. And there is a project named Atlantis that does also that. Yeah. And also allows you, you've talked about the value of of the plan and having that in a pull request to first of all to make sure that the syntax is, is working on the, you know, basic level that it's not crashing and obviously provisioning the resources that you want. So at some point, HashiCorp also kind of brought Atlantis to to itself as part of HashiCorp. So you realize that not everybody wants to merge and then apply and there are some other other approaches. So for better or worse, I mean, I've never been that dogmatic about how people use a tool. I view myself as, you know, a maker of hammers, and I'm not telling you how to use that hammer. And I, I think certain tech people really like that about the things I build. And I would say customer is more of that community of customers and business people will hate that about me because you want your vendor to have an opinion about how to use things. And you know, I believe HashiCorp now does things like that. But me personally, I just didn't care. I was like, use your brain and use it how you think you should use it. It's really not my I'm not going to spoon feed you like figure it out. I totally get it and eventually, you know, people have different use cases and different, you know, things that you they used to and their own preferences. So if you give them the options, they'll probably make the the decisions that are right for them. That's what I hoped. I mean, that's what I hoped. And I just yeah, I mean, now it's like I'm happy enough, like especially being outside of the company. I just like, I really don't care how you use that tool or what you use it for, it's just like I'm trying to build something useful. And if you find it useful, then I'm really happy. And if you don't find it useful, I hope you find another tool that you find useful. But I'm not offended that it's not my tool. Of course. So speaking about the different approaches. So you mentioned the YAML or HCL, and the same with the CloudFormation. But there is another approach which on one way is simpler to the application developers and it's the imperative approach. Something like Pulumi. What do you think are the pros and cons? Again, everyth... people use X and then use Y other use Y. What in your opinion are the pros and cons for the different approaches here? Imperative versus declarative? Yeah, so my experience doing both is really Chef vs. Puppet so as a point of history, I know you know this, but for anyone listening at the point of history, Chef your, you know, your configuration management with Ruby and it was it was a DSL, but you could still do programing in it. You could have classes, you could have eat, you can do all sorts of stuff. And then Puppet was very similar. Honestly, they fail because they said I was inspired by Puppet. So Puppet was very similar to HCL, where you had a declarative set of fully customized DSL that didn't have a full programing language in it. And my experience with those two really was that I felt the programing language approach I could get more done faster. But when infrastructure reached a certain size or a team reached a certain size, I personally struggled to make sense of it. It was a little bit too Turing complete in a sense. I mean, I know Turing completeness is binary, but, you know, it could you could just do a little bit too much. But with the declarative approach, it felt like the constraints were a positive thing for organizational complexity and maintenance over the long term. And, you know, my personal point of view is that I lean towards that. I think that constraints create creativity and I like constraint. So, you know, I'm I'm one of those people, for example, that I despise, that I feel like a lot of I mean, language popular communities feel like every programming language needs every feature, like everybody needs integrators. Yeah, everybody needs that. And I hate that because I think that unique constraints of what you can and can't do at the syntax level of the language is what helps define what's really powerful about the language. Otherwise you just get this like blah and, and so yeah, so I think that it's a good thing. Of course, you know, going back to what I just said just 2 minutes ago, I not that dogmatic about that being true or false. So, you know when we started hearing people want in more of a programing language approach, my view is like, well, Terraform Core doesn't actually care that HCL was written. And that's what sort of led to the creation of the CDK approach with Terraform with sort of that thing. But, but yeah, my personally, I mean obviously I think based on want to ship, I prefer the declared route. And you mentioned CDK so shout out to one of our previous episodes with the creator of of CDK, Elad, and hearing the story of CDK is also super interesting and you know you mentioned about different approaches and you think one maybe is simpler but you struggle as you have bigger scale. And sometimes you know when I'm referred to no code or low code approaches, which seems to be super easy to get something done. I mean, you know, for me, I wonder about the scale of that approach of low code and no code. So again, if you just want to have a quick demo and want to have somebody, a junior developer, to be able to provision something very fast in a repeatable way, yeah, why do they need to learn all of those you mentioned about providers and modules and HCL and state files in order to protect that state file. And, and all of that if they can just draw some nice boxes and make it work on different clouds or something like that. But when an enterprise organization scales and you have a lot of requirements for your infrastructure you need something very powerful and and scalable, would you tend to to agree? Yeah, yeah, definitely. You need a certain level of I think you know people look at I know we want to talk about Terraform but Vault's a good example people look at Vault and I've heard feedback that Vault's too complicated and things like that and I do think Vault's a complicated product, but when, you know, being there as it became a complicated product, it really was out of the complex needs of the users. And so, you know, the person saying, Oh, this is too complicated are generally the people the have very simple needs. And so I'm not saying that, you know, I'm just sort of saying that, like, it doesn't make Vault complicated. It's just complicated for you and that's okay. Yep. Like that. That's totally fine. Yeah. I want to talk more about the process. Okay. So you used to Terraform in order to provision mostly cloud, but SaaS resources. So anything that you need in your infrastructure. And sometimes I said that this is very risky. You know, so many developers have access to that code and the change of that code influence not just your application but your infrastructure when it comes to stability of the organization, compliance, security and cloud costs. So what is the process? And I want to point you to two concepts. One is the Policy as Code, whether it's Open Policy Agent, or HashiCorp Sentinel or static code analysis such as Checkov and TerraScan and TFsec, so many security companies today that they invest in IaC scanning, well, how does that fit into the process? And did you when did you envision that part of the process should probably include concepts like these? I didn't really consider it fully, I would say until, you know, they started being larger customers that we started to have. I sort of had this obviously naive point of view before, which is that you should just think harder, like stop making the mistake, just think harder. Don't be lazy and don't ever do a mistake. That's all you need to do. Or like or learn to recover quickly or learn to accept whatever or whatever. That's that's a bit naive. Very naive. Very naive. But again, like when this again I was early 20th, so then when I started getting bigger customers, it became very obvious that that was the wrong mindset. And so the first approach was really the most basic, which is simple, static policies on top of plan was really their first intent. But I think beyond that, I think a bunch of you mentioned the huge ecosystem of good tools that popped out, and I think they all provide value in, in a company or organization choosing what level of what level of comfort they need and what level of sort of security they need around things. So I think, yeah, I like the way it turned out basically so far that it's being provided in this like ecosystem approach. And do you have any specific feedback about the OPA project? And because the main focus of OPA is more on Kubernetes, but it also has a lot of value when it comes to IaC such as Terraform. And though sometimes when I talk with people about OPA, it's like two different discussions in the same project. So what do you think about such? It's as far as I see it's the de facto standard for policy as code of Terraform. Excuse me, not sure what is your personal emotions about Sentinel but we we see a lot of of OPA and it's a I think already graduated or about to be graduated CNCF project and has a lot of success in many aspects and in Terraform policies. What do you think about, you know, that such a project became so, so successful that does different things? I, I'm not surprised I think and I think it's a great project. When we were building Sentinel, I don't remember. I think OPA didn't exist yet or it was they were just working on it. It was very close, but I can't quite remember. But it really felt like it felt obvious to me at the time that we were working on Sentinel that policy needed to become more abstract because every single project and every layer is going to have this exact same problem. And you can't expect every single project to reinvent a policy framework in a policy language. And then again, like how do they interconnect and things like that. And so funny enough, I mean, I think the outcome of Sentinel is not at all surprising to me, not at all like it was very much we knew that was what was going to happen. We released Sentinel as an enterprise only feature back in 2016 or 17 or whenever it was and I remember at that moment in that discussion saying that, well, OPA is going to become the standard then, but we have to be okay with that. We were okay with that because it was one, it was something that we felt like we wanted to have, something that we could control and train on and things like that. And you could see now that and I'm fairly certain that Terraform supports OPA and Sentinel The idea was that if OPA ends up becoming a standard, then we'll be able to train on that. But in the meantime, we just wanted something where we didn't want we didn't have the time or money any more at that point in order to build another like large attempt. The attempt to build another large standard style like PROJ fundamental project. So we made this conscious decision that we don't want it become an industry standard across projects. We want it to be a HashiCorp's product specific policy. Yeah. Yeah, make sense. And, you know, I've I've talked with several customers of HashiCorp that wonder if there is or there's going to be a plan the migration from Sentinel to OPA. But that's a question to address to HashiCorp. Yeah. So you've mentioned Terraform Cloud. What is the purpose of having such a solution? If I'm a user of Terraform, why should I consider using something like Terraform Cloud, Terraform Enterprise, that I don't get with Terraform and other maybe open source solutions? So my answer will be back to when we created it again. Like they're the the marketing or mindset around it could be different today. But back when we originally Terraform Cloud, the way I was thinking about it was that people wanted a way to a more managed solution to Terraform, that's how I'd generally describe it, they didn't want to worry about where and how to store the state file. Particularly how to collaborate when there's a state file present. And then there was certain things that you couldn't really do when it was on your machine. So as an example, you couldn't really do drift detection or correction or any of that. If someone like closes their laptop and Terraform can't run anymore. So there was a certain set of features that were only capable if we had a server side component to it and you know, originally like way back, I don't have access to any of this anymore, but there was an RC when we were, before Terraform Cloud where we were designing what we call Terraform Server. And so it was actually similar to like all our other projects like Vault and Consul and so on. There would be a Terraform Server sub command and you would actually run the server and then you could self-hosted wherever you want and just run this thing. By the time we thought about that, the issue we were running into was that we were the number of support requests that I remember handling. A very boneheaded mistake was becoming quite drowning. And so we were like, No, no, we're not going to let people run their own thing anymore because it's just like there's there's only so many fold that you could get that bring everything down before you're sort of like burnt out of that approach. And so yeah, so we went with the hosted managed solution. this is super fascinating. And I think in one of the other episodes in this podcast we have, we had a person named Elliot that said that he was one of the first beta users of Terraform Enterprise. I think the name was Atlas or something, something like that in the in the early days. Kinda... it was sort of a different product. But yeah. All right. So just, you know, hearing the, the needs to a more managed situation and more governance maybe really really aligns with what we what we hear. So I mean. I think that all managed services for the most part address like organizational complexity, that's the like primary thing of course that addresses some technical complexity, like if you run a database in the service, there's the complexity of handling backups or getting it tuned correctly there that exist. But I think that the primary thing that Managed services address is the organizational complexity, which is like how do you interact with it collaboratively? But not only that, how do you separate the billing entity from the user, from the administrator and all these sorts of things? And that's really, all, and security and all access control and it you know, all access control becomes much easier when there's a centralized component. Yeah. So we're about to finish. And my last question for you will be to zoom out on the last decade and try to imagine the next decade and what's going to happen with these kind of technologies, whether they belong to HashiCorp or the entire ecosystem and how infrastructure and cloud is going to be managed. And I also want to remind the audience here that a few years ago, you also created two more projects, Waypoint and Boundary. So maybe it relates to your answer and maybe not. But in any case, I want to understand your vision. If I would ask you, where do you think Cloud management, cloud infrastructure, infrastructure as code, automation, are going to be in a decade? What would be your answer? And does it have any mentioning of I have to mention A.I. or Gen AI in your answer? Is it somewhat related or a you don't envision it this way? Well, what are your thoughts? I would say I think everything will have an AI component to it. I view AI as a feature, not a product. So it's sort of, you know, I always say that if you're like X like, but with AI, then whatever X you do better be really good because the AI is just an add on to that. If you're like a shitty X and then you add AI that doesn't make you a good product suddenly. And so I think that will be a component for sure. I'm not going to disregard that, but honestly I'm not, I'm not really sure. I mean, you know, my viewpoint a few years ago when we started coming out the new products and up to a couple of years ago is really that there's too many layers and too much complexity of those layers. And and that makes sense. When I when I felt like I saw at various times or that you create a bunch of layers, you create a bunch of complexity and then once it stabilizes, you just cut the ones that don't make sense or build another layer of abstraction that just takes the pieces that you care about and makes it all consumable. And that was sort of some of my ideas with Waypoint was like, What if we could simplify the whole like most apps are shaped kind of the same? And so what if we was like made that more automatic for people? I more broadly, I mean, I think that simplification is a part of the future, but I can't make any specific bets. I mean, I think the reality is, you know, post HashiCorp as I've left, you know, eight, nine months ago I had less and less attention infrastructure because I did it for so long on one hand. And I don't want to risk making anyone upset over there and all sorts that. So I'm just along for the ride at this point. What people do. I would say the one thing I'm really happy seeing right now is the innovation happening again in platform as a service. I think that I think that's awesome to see. We went through like a period of time where there was crickets, nothing new. It was just like Heroku doing whatever they were doing and then everyone else doing not no parts at all. And then now there's so many new things popping up, right? And I think that super cool to see because I think there's a huge segment of the general tech market that that is a perfect solution for and so much simpler. And so yeah, I mean, I'm one of those people, like I use assets for all my personal stuff because it doesn't make sense as an individual to build your own infrastructure. So, yeah. Perfect. So, Mitchell, thank you for sharing all of your thoughts about Terraform and teaching us, you know, some knowledge and also your perspective, which is I think, super interesting and inspiring. So thank you for that. Before we leave, what are you doing nowadays? I know you like airplanes and I know you like terminals, like developer terminals. What do you do today? Can you share with our audience? Yeah, Yeah. I mean, I think nowadays I still feel really busy my life and basically split into thirds. I have I have a new baby on one hand while she's getting less and less new, but almost a one year old baby. And then I fly a lot. I've been in aviation for about six years and I still fly a lot. I do a lot of I fly family around, I do charity flights and things like that. So that's a big part of what I do. Basically, my primary hobby and then I'm working on a terminal emulator and that's a passion project. That's something that I wanted to build. I still love building software and that's something I can build and I call it sort of for me personally, I call it my like technical philanthropy, like, you know, non non-monetary philanthropy, because my point of view is I'm going to be on a computer programing something no matter what. And that's just like what I love to do. If I'm going to be programing something, maybe I could program something that I can give away for free and maybe make people's lives a little bit better. And, you know, I'm not talking about anything life changing, terminal, not life changing, but, you know... It's not a cure for cancer. Not even close. And so but it's something that a lot of developers have opened a lot of the time. And so if you can make that small part of their work life a little bit more enjoyable or faster or, you know, in any sort of way, then that's when I do my technical philanthropy. So I love that project. And that's that's the main technical thing I'm working on right now. That's again, so, so inspiring. Mitchell, I want to thank you for joining us today. It's been amazing to again to hear your perspective and and your story. I could talk with you for hours, but I guess we will. I guess we will finish now. Anything you want to say to our audience before we finish. That is thanks for listening and thanks for, you know, this historical looks. I think part of the to me like fringy aspects, the historical look is that you through all these things that I look back and I'm like, man, I was I was so dumb like that was such a dumb thing. And you know what they say. I guess if you don't if you don't look back and think that way, maybe you're not growing. But yeah. So I think a lot of what I what I said today, I would say I've grown a lot and changed a lot since then. But I was really trying to bring back my perspective of how I was thinking at the time of all these things. So hopefully people get that out of it rather than thinking I'm still that 22 year old that thinks that people should make a hit for something. That's great in itself. again, thank you so much for coming to the show and I hope the audience enjoyed it today. So thanks everybody and see your next time. Bye bye. Bye bye.