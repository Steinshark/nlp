I guess many of you who are watching this and some of you may have setup SSL/TLS for But how many of you understand deeply how Do you know what really happens during a TLS Why do we need to handshake? What cryptographic algorithms are used by Why do we need digital certificates, Why does it need to be signed What is a digital signature, and how is it There are a lot of questions, and I don't want to just scratch the surface, So this is gonna be a very thorough video an extremely important building block of the What is SSL/TLS? Well, SSL stands for Secure Socket Layer. It is the predecessor of TLS. and TLS the short form of Transport Layer Security Which is a cryptographic protocol that provides secure communication over a Here's a bit of the history of SSL and TLS SSL was originally developed by Netscape And it was first published in 1995 with version SSL version 1.0 was never publicly released because of some serious security flaws. In 1996, the SSL version 3.0 was published as a complete redesign of the protocol. Then 3 years later, TLS 1.0 was first defined in RFC 2246 by IETF as an upgrade of SSL Version 3.0 And it took 7 years to upgrade it to TLS 1.1 TLS 1.2 came right after that in 2008. Then finally after 10 years in the making, we got TLS 1.3 with a huge improvements in So at the moment, which SSL/TLS version still Well, the SSL 2.0 was deprecated in 2011 SSL 3.0 was deprecated in 2015 And recently, in March 2020, TLS 1.0 and TLS 1.1 was also gone. That means only TLS 1.2 and 1.3 are still OK so let's see where TLS is being used First, it is widely used on the web. All websites that you visit with HTTPS are Or we often say HTTP over TLS. Similarly, email with SMTPS protocol is, in fact, SMTP and TLS. Then FTPS for secure file transfer protocol And there are many other applications of TLS that I don't have enough time to mention. But why do we need TLS? Why is it so important? Because TLS gives us 3 things: First, authentication. TLS verifies the identity of the communicating which normally be clients and servers. With the help of asymmetric cryptography, TLS makes sure that we will go to the authentic website, and not Second, confidentiality. TLS protects the exchanged data from unauthorized by encrypting it with symmetric encryption And third, integrity TLS recognizes any alteration of data during by checking the message authentication code, which we will learn about in a moment. Now the next question is: how does it work? Basically, TLS consists of 2 phases, or 2 The first one is handshake protocol. In this phase, the client and server will Select cryptographic algorithm, or cipher Authenticate each other by asymmetric cryptography And establish a shared secret key that will be used for symmetric encryption So the main purpose of the handshake is for The second phase is record protocol. In this phase, all outgoing messages will with the shared secret key established in Then the encrypted messages are transmited They will be verified to see if there's If not, the messages will be decrypted with So we will achieve both confidentiality and And because the amount of encrypted data in This is often called bulk encryption. Now you may wonder why TLS uses both symmetric Why not just use one for all? Well, it's easy to see that symmetric cryptography can't provide authentication, since there's only 1 secret key for both so they know nothing about each other to verify. Not to mention that how they come up with without leaking it to the public is hard. How about asymmetric cryptography? Sounds like a good candidate. Unfortunately, it's much slower than symmetric And by "much", I mean from 100 times to So it's clearly not suitable for bulk encryption. Alright, now let's learn more about symmetric I guess you've already known the basics. First of all, Alice has a plaintext message that she wants to send to Bob, But doesn't want any one in the public zone So she encrypts the message with a secret that they have shared with each other before. Then she sends the encrypted message to Bob Upon receiving the encrypted message, Bob will easily use the same secret key to Since the same key is used for encryption It's kind of symmetric, so we have the name Now there might be a hacker Harry who can catch their exchanged message on the However, the message is already encrypted, and Harry doesn't have the secret key, So he won't be able to decrypt it. But he can still change it! There's one technique called bit-flipping Let's say this time Alice is not talking And she wants to send 100 dollars to someone. The message is encrypted with a secret key Now Harry catches the encrypted message, Although he can't decrypt it, he can flip some of its bits from 1 to 0 and Then forward that modified message to the Now when the bank decrypts it, they will get a different plaintext content. In this case, it has become 900 dollars instead So it's very dangerous. That's why we need to make sure that the encrypted message hasn't been altered But how? One way to do that is to use Authenticated The idea is to not just encrypt, but also authenticate the encrypted message. The first step is encrypt. Alice's plaintext message goes through a Such as AES-256-GCM or CHACHA20. This encryption algorithm also takes a shared and a random nonce, or an initialization vector And it will return the encrypted message. The second step is to authenticate. The encrypted message, the secret key, and Such as GMAC if you use AES-256-GCM, Or POLY1305 if you use CHACHA20 encryption This MAC algorithm acts like a cryptographic And its output is a MAC, or message authentication Now this MAC will be tagged along with the And the final result will be sent to Bob. Because of this, we sometimes call this MAC In TLS 1.3, besides the encrypted message, we also want to authenticate some associated Such as the addresses, the ports, the protocol This information is unencrypted and known So the associated data is also an input of And because of this, the whole process is called Authenticated Or in short, AEAD. Now, we will see how Bob can check that the encrypted message hasn't been changed It's simply a reverse process. Starting with the encrypted message with MAC, we untag the MAC from the encrypted message. Then the encrypted message will go to the together with the shared secret key and the Note that this is the same nonce that is used Usually the nonce is padded to the encrypted The associated data will also go into the And the output of it will be another MAC. Now Bob can simply compare the 2 MAC values. If they're different then he knows that the encrypted message has been changed. Else, he can safely decrypt the message And use it with the confident that it's the same plaintext message that Alice However, there's 1 question: How Bob and Alice share the secret key with Well, the answer is: They need to use asymmetric or public-key Specically, they can use either Diffie-Hellman or Elliptic-Curve Diffie-Hellman Ephemeral. OK, let's see how Diffie Hellman key-exchange First, Alice and Bobs both agree on 2 numbers: The base g, and the modulus p. These numbers are known publicly by everyone. Then each of them secretly choose a private Alice's private key is number small a And Bob's private key is number small b Then Alice computes her public key big A equals g to the power of small a modulo p. And sends it to Bob. Similarly, Bob computes his public key big B equals g to the power of small b modulo p. And sends it to Alice. Then Alice will receive Bob's public key And Bob will receive Alice's public key Now the magic happens, Alice computes big B to the power of small Bob computes big A to the power of small b And these 2 values magically equal to the Why? Because if you do the math, they both equal to g to the power of a multiply So Alice and Bob come up with the same secret However, keep in mind that Each encryption algorithm may require a secret So to make the secret key, Alice and Bob must put S to the same key derivation And the output will be a shared secret key In TLS 1.3, we use a HMAC-based key derivation So that's why the name HKDF. Let's learn a bit more about this key derivation Generally, the KDF takes an input key material In our case, the IKM is the number S. And we need to tell the KDF how long we want the output key to be, such Then the KDF also needs a cryptographic hash function, such as HMAC-SHA256 And optionally some context or application-specific and a salt. With all of these inputs, KDF will produce Now get back to the Diffie-Hellman key exchange. We know that p, g, big A and big B are known Which means the hacker, Harry, also has access We may wonder: Is this key exchange mechanism Or given p, g, big A and big B computed by can Harry figure out the secret numbers: small Fortunately, these functions will be come If we choose good values for p, g, small a For example: Choose p as a 2048-bit prime number, Choose g as a primitive root modulo p, And choose small a and small b to be 256-bit A trapdoor function basically means it's easy to compute in one way but hard In this case, Given p, g and small a, its's easy to compute But given p, g and big A, it's very hard It's easy to see that big A can be computed pretty fast with O(log(a)) It's a well-known modular exponentiation Computing smaller a, on the other hand, is It's a discrete logarithm problem, Which takes our current-generation of computers So we're at least safe for now, Or until the next generation of strong However, for now, "a long time to solve" doesn't mean If Alice and Bob use the same private keys, for every sessions that they communicate, Then what happens is, Harry can record all of those sessions, and start solving for small a from the session Although it will take him a long time to solve Let's say after session N, he get the right Now he can use it to compute the secret number And thus he would be able to decrypt all of Does it sound scary? How can we prevent it? The answer is ephemeral key, As the name may suggest, We use different private key or each session. So even if Harry can solve the secret key he could not use it for other ones. This is called perfect forward secrecy in So now you understand what Diffie-Hellman It's just Diffie-Hellman with ephemeral How about Elliptic-Curve Diffie-Hellman Ephemeral? Well, Elliptic-curve cryptography (or ECC) where the algorithm is similar, but a different trapdoor function is used. That trapdoor function is based on the algebraic And that's why the name. One amazing value of elliptic curve cryptography It requires smaller keys to provide the equivalent You can see it in this comparison table with RSA. The U.S. National Security Agency (NSA) used which provides the same security level with Sounds amazing, right? However, Elliptic curve cryptography is an Shor's algorithm can break ECC on a hypothetical with less amount of quantum resources than There might be decades before that strong But have we prepared anything for that yet? Is there any quantum-resistant algorithm? Yes, there is Supersingular Isogeny Diffie-Hellman Which is also based on the Elliptic Curve But that's another story though. Now let's get back to asymmetric cryptography. It's an awesome technology that has a wide We've already explored 1 of its application, which is for symmetric secret key exchange, with Diffie-Hellman Ephemeral and Elliptic-Curve In fact, RSA algorithm was also used for key But it has been removed in TLS 1.3 due to various attacks and no forward-secrecy Asymmetric cryptography is also used in encryption Here are asymmetric encryption algorithms: RSA with optimal asymmetric encryption padding RSA with public key cryptography standard 1 Then Elgamal Encryption algorithm. And finally, another important feature of which TLS uses extensively for authentication. Some popular digital signature algorithms RSA with Probabilitic Signature Scheme, Elliptic-Curve Digital Signature Algorithm, Edwards-Curve Digital Signature Algorithm. We will learn about digital signature shortly, But before that, let's learn how asymmetric Similar as in symmetric encryption, Alice has a plaintext message that she wants But this time, there's no shared secret Instead, Alice encrypt the message with Bob's And send the encrypted message to Bob. When Bob receives the message, He uses his private key to decrypt it. Although the public key and private key are They are still connected by some trapdoor Just like what we've seen in the Diffie-Hellman The idea is: keys come in pair, And only the private key of the same pair can decrypt the message encrypted with its public key. Because of this, Even when Harry the hacker has access to both Alice's encrypted message and Bob's public He cannot use that public key to decrypt the Therefore, the public key sharing become very Bob just send the key to Alice directly over without the fear that the key can be used The key is public, So anyone can use it to encrypt messages that Even if they have never talked to each other It's really mind-blowing, isn't it? However, life's not that so easy. Although we know that Harry cannot decrypt He can still interfere with the public key And replace Bob's public key with his own Now when Alice receive the key, she still thinks it's Bob's public key, So if Alice encrypts her message with this Harry would be able to decrypt it with his The reason this can happen is Because a key is simply just a number, and there's no identity information to tell So what can we do? Obviously, we should put the key together And that's nothing else but a digital certificate. So Bob puts his key inside his certificate, which has his name and other identity information The certificate acts like a passport in the But how do we know it's really Bob who owns What stops Harry from making a fake certificate under Bob's name but with Harry's public Well, just like in the real world, the passport must be issued by a passport after a process of identity verification. In digital world, the certificate must be verified and signed This certificate authority and passport authority Who helps us prevent creation of fake passport The certificate signing process happens like Bob has a pair of public and private key. In the first step, he creates a certificate This CSR contains his public key and some Such as his name, organization, and email. Then the second step, he signs the CSR with And sends it to the certificate authority. The certificate authority will verify Bob's They can contact him to ask for more proof Then they use Bob's public key in the certificate This is to make sure that Bob really owns that paired with the public key in the certificate. If everything is valid, the CA will sign the certificate with their and send it back to Bob. Now Bob will share with Alice this certificate, instead of sending just the public key as Upon receiving the certificate, Alice can easily verify its authenticity with Because of this, Harry cannot replace Bob's Since he doesn't have the CA's private Note that this only works because we all trust If somehow the CA is not trustworthy, For example, if they give Harry their private In reality, there's a chain of certificate Where at the top level is a root certificate Who signs their own certificate, And also signs the certificate of their subordinate, Which is an intermediate certificate authority. This authority can sign the certificate of Or they can sign the end-entity certificate Each certificate will reference back to the up to the root. Your operating systems and browsers store of trusted root certificate authorities. That way they can easily verify the authenticity OK let's check out a real TLS certificate On Chrome, we click this lock button and choose This is the end-entity certificate. It was issued by Google Trust Services (GTS) With the signature algorithm is RSA with SHA-256 The certificate's public key uses Elliptic So the key looks quite short. And this is its signature, signed by GTS. If we scroll down a bit, We can see that this certificate is used for including youtube.com And it will expire on May 26th 2020. Now let's look at the certificate of the It's an intermediate certificate authority And its name is Google Trust Services It also has a public key, but with different Therefore the key is much bigger: 2048 bits. And this is its signature, signed by the root The root certificate authority is GlobalSign, And here's its RSA public key And its self-signed signature. We've talked a lot about digital signature, So let's see how it really works! To sign a document, the signer first need to hash it Then the hash value is encrypted using the The result will be the digital signature. Then this signature will be attached to the And that's it for the signing process. Now how can we verify that the signature is Well, we just do a reversed process. First we detach the signature from the document, Decrypt it with the signer's public key Then we hash the document with the same hash algorithm used in the signing The result is another hash value. Then we just compare the 2 hash values, If they're the same then the signature is OK, so now with all the knowledge we've Let's take a closer look at how they're The TLS 1.3 full handshake starts with a hello that the client sends to the server. Actually this message contains a lot of things, but here I just list some important information. First, a list of protocol version that client Then a list of supported AEAD symmetric cipher In this case, there are 2 options: AES-256-GCM or CHACHA20-POLY1305 After that, there's a list of supported For example, this client supports both Finite field Diffie-Hellman Ephemeral and Elliptic-Curve Diffie-Hellman Ephemeral. That's why client also shares its 2 public One for Diffie-Hellman, and the other for Elliptic-Curve Diffie-Hellman. This way, the server will be able to compute no mater what algorithm it chooses. The last field client sends in this message a list of signature algorithms it supports. This is for server to choose which algorithm it should use to sign the whole handshake. We will see how it works in a bit. After receiving the client hello message, The server also sends back its hello message, Which contains the selected protocol version The selected cipher suites: AES-256-GCM The selected key exchange method: Diffie-Hellman And the server's public key for that chosen The next field is a request for the client's which is optional and will only be sent if the server wants to authenticate the client by its certificate. Normally on a HTTPS website, only the server side needs to send its certificate And that is sent in the next field of this The next field is certificate verify, which is, in fact, the signature of the entire Here's how it is generated: The whole data from the beginning of the handshake up to the certificate request is called a We concatenate this context with the server's Hash it, and sign the hash value with the using 1 of the signature algorithms that the In a similar fashion, the server finish is Concatenating the handshake context, the certificate, Hash it, and put the hash value through the MAC algorithm of the chosen cipher The result is the MAC of the entire handshake. Here the server certificate, certificate verify, are called authentication messages, Because they are used to authenticate the With the signature and MAC of the entire handshake, TLS 1.3 is safe against serveral types of Now after the client receives the hello message It will validate the server's certificate And check the signature and MAC of the entire to make sure it's not been tampered with. If everything is good then the client sends with the MAC of the entire handshake up to And optionally the client's certificate in case the server has requested. And that's the whole flow of the full TLS To improve the performance, the client and server don't always go through Sometimes, they perform abbreviated handshake By using preshared key resumption. The idea is: after the previous handshake, The client and server already know each other, so they don't need to authenticate again. So the server may send one or multiple session Which can be used as the pre-shared key (PSK) And it goes with a ticket lifetime as well Now in the next handshake, The client will send a simple hello message, Which contains a list of PSK identities (or A PSK key exchange mode, which can be either PSK only, or PSK with If the PSK with Diffie-Hellman mode is used, then the client also needs to share its Diffie-Hellman This will provide perfect forward secrecy, As well as allow the server to fallback to When the server receives this client hello It sends back its hello with the selected The optional Diffie-Hellman public key of And the server Finish just like in the full Finally the client sends back its Finish, And that's the end of the PSK resumption. As you can see, there's no certificate authentication between in this abbreviated handshake. This also opens up an opportunity for zero Which means, the client doesn't need to to send its first application data to the In 0-RTT, client sends the application data This data is encrypted using the key derived And it also adds 1 more field: early data To tell the server that there's early application If the server accepts this 0-RTT request, It will sends back the server hello just like And optionally some application data as well. The client will finish with a message containing and an end-of-early-data indicator. So that's how 0 round trip time works in Its pros is reduce the latency by 1 round But the cons is openning up a potential threat Which means, the hacker can just copy and to the server multiple times. To avoid this, the server application must in a way that's resilient to duplicate requests. Now before we finish, Let's do a quick comparison of TLS 1.3 and First TLS 1.3 has safer key exchange mechanisms, Where the vulnerable RSA and other static Leaving only ephemeral Diffie-Hellman or Elliptic-Curve Therefore achieved perfect forward secrecy. Second, TLS 1.3 handshake is at least 1 round-trip Symmetric encryption in TLS 1.3 is more secure And it also removes some weak algorithms from such as Block Cipher Mode, RC4, or Triple The cipher suite in TLS 1.3 is also simpler, since it only contains the AEAD algorithm The key exchange and signature algorithms While in TLS 1.2, they're merged into the As we can see in this example, DHE is key exchange, and RSA is signature This makes the number of recommended cipher 37 options in TLS 1.2 if i remember correctly. While in TLS 1.3, there are only 5. Next, TLS 1.3 also give us stronger signature, Since it signs the entire handshake, not just cover some part of it as in TLS 1.2 Last but not least, Elliptic-curve cryptography gets a significant With some better curves algorithm added, Such as Edward-curve digital signature algorithm, Which is faster without sacrificing security. And that's everything I want to share with Thanks for watching, and I'll catch you