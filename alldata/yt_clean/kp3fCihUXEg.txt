These are the 7 most important algorithms coding interviews. We'll start off with depth-first search, and breadth-first search; algorithms, insertion sort, merge sort, and at a special type of algorithm called a greedy We'll cover what each algorithm is and give them, and discuss how efficient they are. structures before learning these algorithms. need a refresher, check out this video here time complexity will also help you during out this video. into it. used to find the position of a specific element I find it's best explained with an example, Let's say we were playing a guessing game number from 1-100 and you have to guess what will tell you if the correct number is higher One possible way of guessing is to start at it. This is called linear search. While this 1, imagine if the correct answer was 100. answer. On top of that, what if our guessing you can see, this becomes inefficient when algorithm. This algorithm has a runtime of Now, let's take a look at a different way Instead of starting at 1, let's start right tells us if the correct answer is higher or numbers to guess. We can keep guessing the and eventually, we reach our answer. This commonly written as just O(logn). algorithm we just looked at before, with a Well, let's look at the worst case scenario, search, it's pretty clear how long it would through all the way to 10,000. But what about but I'm going to go ahead and instead use know is O(log n). So, log (base 2) of 10,000 to reach the worst case! That's MUCH better us. a pretty simple algorithm that you've probably list of things. The important thing to remember sorted. If you ever see a sorted list that is usually a good place to start. don't click off now, because these next to know. Depth-first search, and the one we'll algorithms used to search through trees and Software Engineering Interview Process video, just behind arrays. So yeah, they're extremely We'll be starting with depth-first search, DFS is to start at the root node, and go as to the end. Once we hit the deepest point, comes from, we come back to an unvisited branch, back to an unvisited branch is called backtracking. might traverse through this graph using DFS. a visited array, that keeps track of nodes To begin the DFS, first, we'll start at to the next node. We'll also add both the array. From here, we continue going down this the way to our visited array. Once we reach node, and see if there are any unvisited nodes one, so we'll go down to it, and add it the previous node again. Do we have any more up again. We repeat this process of traversing we've gone through the entire graph. search might be useful is for solving a maze, created for! Starting from the entrance of way to the very end to see if it contains the nearest opening, and continue. given a notation of O(V + E), where V represents total branches AKA edges. We'll explore dedicated to depth-first search, but for now, Big O of V + E. Now that we've covered DFS, breadth-first be a bit easier to understand. In BFS, instead backtracking up, we'll look at every node Let's look at a visual demonstration. breadth-first search, we will also create we've already visited. We'll also create neighbours of a node to. add it to the visited array, and we'll add neighbours queue. We'll then take a look mark it as visited, and add all of it's This process continues, and as you can see, level before we progress down to the next One real-life example of where breadth-first those of you who don't know what this is, the best move is at any given point in a game. player's turn, and taking a look at each looks at all possible moves for the next turn, all of those possible moves. As I'm hoping search, where the nodes are moves, and the Just like with depth-first search, the runtime this will be covered more in-depth in a dedicated save that for another day. algorithms! Next we're going to cover the a quick ask. If you're enjoying this video, friends. I'm usually putting 12+ hours into a full-time schedule sometimes requires me done. I'd love to keep making more and more could share these videos with anyone you know. algorithms. of elements, usually in ascending order. There but today we're looking at the 3 most important of the sorting algorithms, and the easiest Insertion sort works as follows. The algorithm compares it with the second. If the second compare the element in the second position the 3rd element is less than the 2nd element, than the 1st element, swap them again. As until we reach the end and voila! We have Insertion sort is a simple sorting algorithm, sort has a best-case run-time of O(n), and when everything is already sorted, as it only nothing is sorted, because it has to go through As a result, insertion sort is best used for lists of smaller sizes. Once the lists grow starts to become problematic. that might be better for large lists. under the category of "divide-and-conquer" into smaller problems, and solves each smaller Well, if you watched my video explaining recursion, a recursive algorithm! for this. We start by splitting the array in half until the array has been split into going to do a comparison of the 1st element 2nd is greater than the 1st. Now we have sorted combine two sets of pairs, and do the exact for each group of 4. This process continues array, which is now sorted. the best and worse-cases. Comparing that to want to use one over the other. For smaller, has a runtime closer to O(n), whereas merge might want to use insertion sort. For larger, closer to O(n^2), whereas merge sort remains want to use merge sort. and you're understanding how the algorithms the other. Now, time to look at our last sorting Quick sort is our final sorting algorithm, once you understand how the other two work, it for last. Like merge sort, quick sort is The idea is to pick a pivot number, ideally and split the list into two lists, one where one where all the numbers are greater than sublist, until we've reached our sorted Let's look at the visualization for it. number close to the median. Once we've selected list. Now, we place a pointer at the left-most compare the two. If the left-most element element is less than the pivot, we swap them; through the list until our pointers cross; left pointer with our pivot. Now, everything everything after our pivot is greater. We lists now, choosing a median pivot for both, the list is completely sorted. log(n)), but a worst-case run-time of O(n^2). this algorithm, as it has a worse time complexity Well, this is where it gets interesting, and correctly, is actually the fastest of the it are best saved for another video, but for of the quick sort algorithm can be optimized and is on average, 2-3x faster than merge On top of that, quick sort has a space complexity complexity of O(n), so quick sort is better to quick sort is that all of this relies on or inefficiency in the quick sort code can it is a much harder algorithm to implement That wraps up our sorting algorithms. Before one more type of algorithm, which is a special When you think of someone being greedy, what always wants and does the best thing for themselves this algorithm does. the best possible choice at every local decision to make a decision, they just look at what much into the future. use greedy algorithms, and then when you should Greedy algorithms are not used for efficiency, every possible outcome, just the best outcome a greedy algorithm doesn't work optimally. you make here, you have to spend a certain the path. Think for a moment - what should Hopefully you came up with this path as the algorithm, we might not get this. The algorithm and 8. It chooses what's best right then, looks at its next two choices - 9 and 10. which is a 9, and reaches the end. The algorithm we did it ourselves, we could reach the end So why ever use them if they're inefficient? could have easily developed a DFS or BFS algorithm the problem is simple enough for a computer brute force it and have the computer calculate we have impossibly large amounts of outcomes computing can't go through every single This is where greedy algorithms are used. using an optimized algorithm, it's best that's relatively close, even if not 100% One of the most famous examples of this is problem provides a list of cities and distances possible route that visits each city once for total possible routes is (n-1)! / 2. that gives us 12 possible routes. If our salesman 10 cities, that gives us 181,440 possible us an exponential growth in route possibilities. a computer in milliseconds. Now, let's consider every capital city in every US state. As there Take a guess as to what the possible route the billions or trillions? you're not even close, because the total Yeah. And while a super computer might be 50 cities. Just for fun, let's say it was 201193630038546886771851216961501992859687432105357316271899955214969256199314510296022104243484702400239994305098598029315833436497404279450661914834972295498712252043536879959411813863594366259889752975497638060437487731248521800709139047323248145528196943718943243668559590522912891823924988506238316444917977867716256592661979231537778704557131208737174673776714323288305833898698334410145603689571926859794124904063433919187279865873068042689767262110793296600964045439148654215696422201640615779305518488400678652108084373804837935674156012739294660383584566224213118065706254390104000130841575513670913988852392317934085082182512076845699140632405106546380622448179964352557482487709954671110783416286040410666593058405776807918273492023354487801450475268808237923864210944839823122472580382676704099450692721243992479976659550861677778301069725199868140375068918807653563880963424517176312600007944267573665805851051984087960755453894009696589057097272628611932770730531446093980111919485738044253138431483573337348781455617041219604080076890444946982259131621835808381089584454889955951877015637311144994002597722207141006093680872996321478290873314151477785149512162076590808605232916018393453058630079391760375758142112770132585241652113071987143466530845448984241295062729163584113229033263384979326341136403537890695929089444826104082174172412996633021683830088499806415930394193075139732977565578276018046994090306069279300150717847263612103172315898730297341286551895042012216219232828622507201410942626235467595310464511568246636748782756979360279827114374887005706673481357711422931188693769115241932844488230963691907450070383655223320129949745111110882952169950943009283263242530899851178096948508930020405944864959155510585614922950820960534442193560927823062480399361454259648409686194321307419828691145561562512093324676571985068714265963324937668609470347140717059260079007061672414007525699847145076741538822284549536576216639144134932301394932160569541753108547501298694931777138598371411124378793382876172110103786815284749412543984464081376924431698454979913140478060725497435850622258230630189514654560444543471014255320091077199728578402970936374499047127371086791200531838702297870892580414615067679040920048498186262115280427951850312135621708454502076845052966991917888969705485013876736000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 the exact optimal route from every possible algorithm comes in. Let's choose an arbitrary that always chooses the next city that's until we reach the end, and then return to the most efficient way to do it, but as we've solution, and we'll still get an answer cities. are used when finding the optimal solution something that's relatively accurate. for interviews. This is my longest video yet, so if you could smash the like button and I put a ton of effort into these videos, and could see them and learn from them. you in the next video!