Let's say we have a grid of pixels One algorithm that allows us to solve this Of course this doesn't have to a grid of tiles and a tile based But in our case we have a grid of Let's assume it's stored meaning our coordinate system starts Therefore the X coordinate increases to the Before we can tackle the algorithm First, circles are symmetrical. This means we only need to solve the problem We can simply take the resulting pixel coordinates That's going to be very convenient. Second, I will visualize pixel I'm doing this for clarity only, technically our pixel coordinates can So that's something to be aware of. I just find it more intuitive to have pixel Anyway, back to our grid of pixels. The circle is of course defined by Let's call them cx, cy which is the To make our life easier we're going to use a coordinate system relative That means we're going to treat When we place pixels we can simply to make them relative to our entire grid. Okay, let's actually write the algorithm. The drawCircle function will To keep track of the coordinates we're I've decided that we start at (0, -r). Any other side works equally well of course, but I simply figured that the top of To start things off let's iterate over the number We do this by simply iterating That is because the end of our octant is reached when we reach the perfect To make the loop work without repeating infinitely we of course have to And at every iteration we place a pixel at (x, y). Just remember we need to add cx and cy to the x and y coordinates to draw the because x and y are relative So far so good, the function To curve this line along our each iteration whether we should increment y by 1. Highlighted here are the two For this algorithm we take the We call this the midpoint, which is If the midpoint is inside of the if the midpoint is outside of Here we can see that the midpoint is inside of the circle, that we do not increment Y and For the next iteration we've moved The midpoint is inside of And the same thing again for this next pixel. But now things are different. Here the midpoint is outside the circle, which colors the pixel below. And then we just continue iterating. The next midpoint is back inside the circle However at the next one the midpoint is I think you get the idea. We repeatedly check the current midpoint and when the midpoint goes outside That's all this algorithm does. To calculate the current position current x and y variables but Makes sense, as we move half a pixel down. Back to our code let's actually I'll store it in this variable called yMid. Now the next question is how can we check Say we have this arbitrary point over here. Our point is defined using If we draw these as two lines and then the circle and the point we get a right triangle. Let's label the sides of Thanks to the Pythagorean theorem In other words we can calculate the length But why do we want to know this length? Well, right now the length of This means our point is outside of the circle. However if we move the point inside Now c is shorter than the radius. So by checking if c is larger can determine if the point is inside or outside. Back to our code we can calculate if We square x and yMid and make sure Note that we're not taking the square root This lets us avoid the square root All we have left to do is place Currently this is how we place our pixels. What if instead we place eight That looks something like this. Essentially we just mirror our pixel And that's it. We now have a fully working implementation However if you find examples of this And that is because what we're For example we're using the value 0.5. Maybe we can get rid of Granted these days floating point operations are really fast compared to the but while we're at it we Second, we're using quite a few multiplications Ideally we get rid of multiplications multiplication by two, which So let's try and replace these We'll start by rewriting our x2 + yMid2 - r2. This is called the decision Everything is the same as before except we can Less than 0 means it's inside of the circle while an exact zero means we are Our goal is now to use this expression to before our loop, and then also figure out by how Let's start with the initial value. What are the values of x and Well as we can see here we set them to 0 and -r so let's set x equal to 0 in our expression of course 02 is To simplify the rest of the expression we'll use a+b2 = a2 + 2ab + b2. As both of these expressions are identical And as it turns out (-r+0.5)2 Except here a is -r and b is 0.5. Converting all this into the equivalent Next -r2 is the same as r2, as two positive. This r2 and negative 2*-r*0.5 is just the same as -r. And of course 0.52 is 0.25. But remember we wanted to How do we get rid of this 0.25? One way is to just erase it. This makes our initial p value an approximation but it remains pretty close I did some testing and as far as a slight difference in how the circle is drawn. It's not something that's actually but if you zoom in pixel by So that's something to be aware of. Anyway if we get rid of 0.25 we're This may seem like a lot of steps to arrive at such a simple value but I wanted to Especially because depending on how you structure the algorithm you may need Most examples you find online actually therefore they begin this step by Simplifying this expression eventually leaves us I don't think one of these I just found that the way we've But maybe there's an advantage to the Let me know in the comments if there is one. Anyway let's go back to our code and add The beginning of the function looks the same as before but then we define p Then comes our while loop. And at every iteration we now Remember this just means the If so we increment y by 1. Finally we draw all octants' pixels However one piece is still missing to We need to update p at every And of course this amount differs depending Let's start by calculating the amount Again we begin with our variable p which is just Now like I said in this situation But of course our x coordinate is still increasing So if we wanted to calculate calculate the next Our goal is to figure out That's the amount we increment by. To get this amount we simply take the We can then substitute each variable with its First we get rid of the parentheses We see that the highlighted terms are both added Next we can rewrite (x+1)2 as x2 + 2*x* 1 + 12. x2 then gets canceled out. Finally we multiply everything So that's how much p increases when Let's fill that into our function. All that remains is finding out by how where y has been incremented. First we grab our p and pNext expressions again. Now if you remember our code, y has point, which means our pNext But our p expression is wrong Subtracting 1 gives us the proper current p value. And that's it. We just need to simplify this Let's again get rid of the parentheses. r2 is canceled out. We rewrite (x+1)2. x2 cancels itself out. We expand (y+0.5)2. And finally we expand (y-0.5)2. For this we need a slightly different formula. Then we get rid of these parentheses After all this we're left with 2x + 1 + y + y. Of course we can also rewrite that as 2x And there we go. Let's fill that into our function as well. Perfect. This is our finished implementation. Of course this is not the only way to that are very similar to this It's also worth mentioning that we can When placing pixels we can simply pairs of pixels that have the same y coordinate. But implementing that is pretty trivial Thank you for watching and I