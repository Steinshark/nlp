What's the difference between Docker and virtual machines, or VMs? Well, we're going to 1) define these two technologies then 2) describe how they work 3) give a bit of guidance on which workloads fit best for each technology. Now, both of these technologies address something in common and that thing in common is called virtualization. And what I mean by virtualization is a process where software is used to create an abstraction layer. So for VMs, that abstraction layer, or that abstraction software, is called a hypervisor. And a hypervisor is, simply put, something that helps a virtual machine emulate a physical computer. So underneath the hypervisor here we have some hardware. And the hypervisor manages the allocation of resources between different virtual machines on that single physical host. So up here we have a number of VMs. Now each VM runs its own operating system and it has its own virtual hardware. So like virtual CPU, virtual storage, that sort of thing. Now, what about Docker? Well, Docker is an open source platform that uses containerization technology. It allows developers to package applications and their dependencies into lightweight, portable containers. Instead of virtualizing the underlying hardware like this hypervisor is doing for the VMs, Docker containers virtualize the operating system. So each individual container contains only the application and its libraries and dependencies. So let's break down the main components of both solutions, and we'll start with Docker. So the first component I want to tell you about is called the Docker engine. Now, this is the core software that's responsible for managing the lifecycle of Docker containers. So we're talking about things like providing the infrastructure for creating, running and orchestrating the containers. And the Docker engine interacts with the host kernel to allocate resources and enforce isolation between containers. And that's done through two things primarily; there's something called cgroups or control groups, and they allocate resources among the processes. And then there's something else called namespaces, and namespaces restrict a container's access and visibility to other resources on the system. And that ensures that each container has its own isolated environment. Now there's also Docker images. And Docker images are lightweight, standalone and executable packages that include everything you need to run a piece of software. So we're talking about the code for the software, the runtime, the system tools, the libraries and any settings that we need as well. And Docker images are built using Docker files, which are very simple documents which provide instructions for creating the image. And then there's also the Docker containers themselves. And these are the instances of the images that run in the Docker engine. Each container is an isolated and self-sufficient environment that includes only the necessary components for running a specific application and can be quickly started, stopped and restarted. Now, for VMs, we already know the hypervisor is the software responsible for creating, managing and running these virtual machines. And hypervisors come in two types: so we have a Type 1 hypervisor, that's also known as a bare metal hypervisor. And that runs directly on the host hardware, so right on that computer there. There is also a Type 2, and Type 2 is considered a hosted hypervisor, and that's where the hypervisor runs on top of an existing operating system. Now, the other components we should be concerned about, well, there's the virtual hardware. And this refers to the emulated components of a virtual machine. So I'm talking about things like a virtual CPU, virtual memory, virtual storage, virtual network interfaces. And these components are presented to the guest operating system as if they were real hardware. The hypervisor is responsible for managing and allocating these virtual resources to each VM. And yeah, speaking of guest OS, that's another core part of all of this, the guest operating system. Those are the individual operating systems that run inside each virtual machine. And each VM can have its own guest OS, which may differ from the host OS and other VMs on the same host. And that allows users to run multiple operating systems and applications on the same physical machine. Now, when to pick one over the other? While the choice isn't always black and white, let's start with some common use cases for VMs. When would you use a virtual machine? And I can think of three right away. And number 1, really, the obvious one, is the diverse operating systems that I just mentioned. VMs let you run different operating systems, so we could have a VM running Windows, another VM running Linux, all on this same piece of hardware. And that's handy when you're testing applications across multiple platforms, for example. A second big advantage is isolation. Now both solutions offer levels of isolation, but with the VMs, isolation is it's pretty much built in since each VM runs its own separate kernel and operating system. And then number 3 is legacy, and what I mean by that, is that VMs are well-suited for running legacy applications that rely on specific operating system versions or configurations that might not be compatible with the host OS or the other containers. So you can set up an environment that is perfect for that legacy application and not have to change it. Now, what about Docker containers? Let's think about some use cases for these. And first and foremost, top of the list, is microservices. This is probably the most common use for containers-- that Docker containers lightweight nature, its fast start up times and it's the ability to package and distribute dependencies, make it ideal for managing microservices-based applications. Number 2, it's just the speed of things. So the rapid development and deployment in the ability to use the Docker containers because we can quickly build, deploy and scale up these containers and that makes them well-suited for agile development practices and continuous integration/continuous deployment, or CI/CD pipelines. And then 3, on a similar theme, is resource efficiency. Which is just to say that containers share the same host kernel and have a much smaller footprint than VMs, and that allows more containers to run on the same piece of hardware with less overhead. So, look, in selecting between Docker and VMs, essentially you'll need to consider the specific needs of your applications and infrastructure. And it's common to see both technologies used in hybrid environments where legacy applications might run on VMs and then modern microservices-based applications, they'll probably use Docker containers. It's really not an either or choice for organizations. Commonly, you'll see both. And either way, these virtualization technologies have transformed the way we deploy and manage applications.