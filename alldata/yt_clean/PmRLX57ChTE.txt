so you look at the research somewhere between five to twenty percent of change coupling in its simplest forms is based the teams separated based on business capabilities reflected in the architecture using behavior where in the source code this episode Hello. Welcome to a new I am Sven Johann. I am a Senior improving software systems. And today I have my book, &quot;Software Design X-rays.&quot; Hi, Adam. So maybe for those who didn't read first please introduce yourself. a company called CodeScene where I tackle the is maybe a little bit different because actually, been a software developer for a long, long time. interests. And what I try to do with &quot;Software take my psychological background and put it on top I'm the author of &quot;Software Design Thank you. In the first episode, we talked about now in the second episode, we want to start with coupling actually means, not on the code level but Change coupling is a very interesting It's interesting because it's something you As a developer, we typically refer to coupling of code over here and it uses some piece of Change coupling is different because it's more analysis, you measure how the organization In change coupling, we pick up patterns and advanced architecture analyzers, we pick up each time I need to modify a piece over in the module over here. So, there is some And using change coupling we can get a our architecture supports the way we work We all know the situation where we change, let's five completely different unit tests does the change coupling relate to clone the thing I know if I change something and Yeah, so that's an area where I've done a lot this was way before CodeScene, way before I consultant with a team that was very heavy on test got a lot of flaky tests. This was automation The problem was of course that, as a developer, and then you had three other tests failing Now using change coupling, what we could do was we could figure out that you make this tweak in the whole cluster of files, right, so that we kind of we wanted to drill deeper and figure out if is due to drive violations, violations And adding copy-paste metrics on top of To me, change coupling is an clone detection tools and copy-paste detection is that there's simply so much of it. So, you somewhere between 5% to 20% of all code out there that application is bad per se. So, using change amounts of duplicated code and we can figure that are actually expensive to maintain, right, The clone is not an exact clone, right? Usually, you change this tiny little bit. But of course, all of the rest there. Clone detection let's say, copy-paste-edit pieces of code, right? software is a pretty old technique. It's something decades. But again, I think that simply the hard to act upon it because to me, I think one as developers, myself included, are kind We have learned over and over again The problem is that it's simply not true as a have a piece of code here. You copy-paste it and completely different directions. I could very well Or maybe you duplicate some code and you be ideal but is it a really a big problem. So, the our behavior, in a negative direction. We It's easy to miss updating one of those clones. coupling and clone detection really, I agree that it's not always bad. I tend to do second time, then it's time to say, &quot;Okay, now I said &quot;DRY is the enemy of decoupled.&quot; with but in terms of microservices for example or Whenever I change something far over here, I totally different repository. Then things become if I have a problem because maybe I only have this How can I find that out? the incredible hype behind microservices kind of flipped the whole architecture and there are definitely scenarios where you loose coupling is simply more important. minimizing the amount of duplication. At the same the same behavior in two different places if Because if you have that, it could very well to take on that shared responsibility. Maybe There are two aspects to it. One is change coupling across git repositories? The I wrote about this in the book. So, change finding patterns in the commits, files that change commit set. And that clearly doesn't work across look at a ticket system instead. Things like and see that if the commits reference the of depending upon each other. And if it happened So that way you can detect change coupling down to This is something that's very powerful and top of that as well and then see is this it an actual problem that we lack some To me, that it's a hard more challenging aspect is to make that decision, it? What I tend to recommend is I use a general I simply visualize the change coupling and then I the problem domain and any surprising coupling is simply one of the most expensive things Yeah. Rarely people are positively surprised. It's always &quot;You know, don't make your manager But I mean, what would be an example for a the back. You said you wanna show the coupling. So I looked at CodeScene and also when I remember the the amount of coupling of those files and how what's the thinking about this approach? You know, The interesting thing with change coupling analysis techniques that we talked about is that they scale at different levels. You can can use it at the file level and you can use it at start when I pick up a system. I look at the either different layers, different components or out the change coupling between, let's say, the You have all your services like a wheel and then And that's usually my starting point. organizations across the globe at all kinds of a really good job with it. But occasionally there even though you put all these efforts into bonded context, domain-driven design and all that because we basically have to be domain experts to we're actually starting to build our distributed change coupling. When you change the service you you look at the details. What kind of functions or capability here on your business capability and services and update the state in a third one. So As we said, maybe we have two code clones in once and that's fine. It just happened once change it the second time, the third time, the files together in different services. Is there about those temporal dependencies? recommendations in this area because with work on a part of a code a lot and that part of it's very easy to say that, &quot;Okay, we need it's so much harder because it depends on the you just got started on, there's probably going on. So, I do expect a higher degree of change In a more stable system, once the basic any change coupling that's over 20%. That would worry me. I just wanted to add that the other heuristics I expensive with distance. And what I mean with like are these two completely unrelated parts that might very well be one of those surprises. boundaries. That very quickly becomes expensive meetings and they might have conflicting Yeah. I can sing a song about those kinds repositories and one team is responsible for that, manageable and it's also easy to fix because different repositories and can think coupling. But across teams that's going to be from your experience on that problem, you know? start. I think one of the most common issues I've years back, like, two, three years ago, was that &quot;How should we organize our development teams?&quot; Then we noticed that we had very, because you had to do these handovers all the time to a feature team and now we kind of noticed that suddenly we find that we have 10 different It's a much harder answer because the hand with the software architecture. You really, to have component teams, then I think a much people would recommend, stream align the teams. You have the teams separated based on business are reflecting the architecture. I really Yeah, I was about to say. In the &quot;Team Topologies&quot; Ruth Malan. There is the software architecture basically on Conway's Law. And if team setup and communication structure between who cares like a non-technical manager. And Is there a way how to use those insights on working on the same code base to, let's say, to Yes, there are. And I like to think this is one code analysis and &quot;Software Design X-rays&quot; and It brings visibility to the people's side of code. of software design, that the organization that Using behavioral code analysis, you show which team works where in the source code. information so that you can easily show those that team has to coordinate with four other teams. mostly about domain expertise to figure it out. teams around. Quite often, you have to do a more services or components are actually the same occasionally, you find that an organization simply So it's the same pattern maybe we discussed the not-to-do list. You have so many problems but with here we would have the same. If you need to think to use the word, you can look at those parts and also where are teams actually quite distinct the problematic parts to identify where we need Yeah, and I think that's important because the start to have a meaningful conversation between even with organizations that have a fairly high decide what they want to do. They can decide decide for the whole organization. We need that data really, really helps in my experience. have a feeling, usually people don't react to it. your architecture. Let's say architecture in terms feature, how many people do you need to bring into dependencies are, either your hard dependencies or new feature and I have to call a big staff event, when you do those tests with your clients? doing local optimizations. Organizations a lot of coordination meetings and we have a lot that many organizations tend to stuff additional sharing information for example. So, let's do do additional status meetings so that everyone And in my book, that's basically just the way of Because you really do want to keep And the only way of doing that is to autonomously, so that they can have this fit architecture. So that's where I come from. I've been in meetings with around 60 coordinators be true.&quot; How do you visualize those dependencies it's something you should use in each and every Yeah, and I find it fascinating in particular where we're very heavy up on the measuring all we're measuring scalability and all that stuff. We architectural properties that are so important autonomous teams and we are not really measuring analysis can kinda fill that gap. And it can for architecture. And that's the way I've been a very good experience with that. What are the typical steps to fix the problem? it was so unexpected for me was that a lot different teams or coordination bottlenecks, It's something we got wrong either in the stuffed too many responsibilities into one module module, right, or maybe we do have a very modular Maybe it's the wrong modeling concepts that as software architects, it tends to be building blocks and we kind of build our more or less asking for heavy team coupling. big problems. I am currently 300 people. Without the data visualization on the conversation about what the problems are. at that scale have a big payoff because imagine just the staff cost of 300 people. If we Yeah. Exactly. I mean, coordination every once in a while, why not You could almost buy a private jet Exactly. From my perspective, I could have Thank you, Adam, for the conversation. I can also check out the tool. Thank you.