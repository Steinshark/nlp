Hello and welcome to mCoding. Today, we're talking about functions within functions, Of course, don't forget to subscribe so that Let's start with this example that looks complicated, but The question is, what's going to happen We've got these two functions, &quot;donkey&quot; defines another inner function, &quot;chonky&quot; calls &quot;donkey&quot; to get that inner function. And then calls the inner function with an argument. So ultimately, the function returns some But the complexity or confusion of it we have multiple different inner() has a parameter 'y', so that one's easy. But 'x' and 'z' need to come from It might use this &quot;global x&quot;. Or maybe it takes this local x because when the function is actually called, Remember, it's the return results of this 'donkey' call. The nearest enclosing scope might seem like As for 'z', since the inner function is maybe it uses this outer 'z'. Or maybe it somehow gets this inner donkey 'z'. Or maybe it wants this donkey 'z'. But it can't have it because it's not defined yet. So maybe we get an error. Feel free to take a moment and pause if you want But if you're already confused and you know you're This is a tricky part of Python that And as such, even experienced programmers And may not know what the rules are. So what answer do we actually get? The answer in this case turns out to be that it Of course. It uses the passed argument of 'y'. And it uses this value of 'z' in that was defined after the inner We're going to start off with much But once you know the rule, even this We'll start off with some simpler examples. But I want you to keep in mind the key to That's right, compile time. A very common misconception is In fact, it is compiled. And it's also interpreted. A module source is first compiled to bytecode. Then the interpreter interprets the We often don't realize that because it happens automatically. How variable scoping works inside nested that depends on the separation Here's the one rule that you need to remember in Variable lookups happen at runtime. But where Python will look for Let's start simple and work our way up. level_one: we just say `return x`. The only 'x' inside is the 'global x'. The code for every function is There are no assignments to 'x' in this So the compiler decides that it will look Of course, you didn't need this This one you probably expected. level_two: once again, we're just returning 'x'. But in this case, we take an argument 'v'. If 'v' is truthy, we assign a local variable 'x'. Otherwise, we don't assign to 'x'. So, which 'x' is returned? Remember, where we look for 'x' needs The compiler doesn't use any The compiler simply notes that Therefore, everywhere in this function, Of course, that means if we pass then we get the `x = &quot;local x&quot;. But if we pass in something falsy, The compiler determined that 'x' We tried to return that local variable. That's why we're getting this &quot;UnboundLocalError.&quot; It doesn't matter that there was a perfectly good It was determined at compile time that It's going to use the local one. Alright, let's keep going. Level three: here we define our 'outer z'. Our inner function which only takes 'y'. And then we call the inner function At compile time, the compiler says there is no There is no local variable 'x' in this Therefore, it will look for an 'x' in the global scope. There is a 'y' in this local scope. So it will use that local 'y'. And for 'z', there's no 'z' in the local scope. So it determines that And not too surprisingly, indeed, we see Okay, but what if we defined &quot;inner&quot; first. And then defined 'z' afterwards? We do not get an error even though 'z' Once again, at compile time, the 'x' is going to be found in the global scope. 'y' is going to be found in the local scope. And 'z' is going to be found in the outer scope. It doesn't matter where the assignment Somewhere in the scope of the 'level_three' That means everywhere it's treated So, Python decides that this 'z' will But remember, it doesn't look up The runtime for this function is here And by that time, 'z' is defined. So just as before, we see the Even though that outer 'z' wasn't defined at the Just to repeat the rule again, it's But where Python will look for the Let's drive this one home in &quot;level_four&quot;. Here, we define an outer 'z'. Then our inner function. Then a new value for 'z'. Then we call the function. So which value of 'z' does it use? There you see it, it uses the second one. Even though at this point when the function The inner function does not use that value. Instead, Python says the value of 'z' will be whenever the functions run, By the time the function is run in this call, the So it finds that value. Now, this might be where you start feeling like How does it know? What if instead of calling this function right here, And then called it a million lines later? Isn't 'z' just a local variable that's and be garbage collected once Here's where we need to talk about closures. Traditionally, a closure is an object with some kind of extra environment. In this case, the environment would be grouped together with the inner function that keeping it from being garbage collected. Unfortunately, this is one of those cases where there are multiple definitions of a Some people use closure to Other people, including the people use closure to mean just the environment part. Printing out the closure of the inner function, we see that it's a tuple containing a Python determined at compile time that this cell is where the value of 'z' is The cell has a reference to a string object which is going to be the first outer 'z' because we're printing it before we Printing out the closure again after we we see that the cell object itself hasn't changed. It has the same address. However, the string object that it's This use of a cell instead of the object itself you always get the latest value of 'z' at runtime. Because the inner function only references the cell and not the string object itself. This ensures both that when we run And it means that we can define the inner In that case, we see that the cell is just empty. Then, once we define a value of 'z', Also, note that we only have one cell for 'z'. The global variable 'x' does not get a cell. For global variables, Python stores a reference That means that even if you pass this and call it from a different module, it will still look up global Of course, this achieves a very similar The global variable 'x' doesn't need to When I call the function, the most recent value And if my inner function didn't reference 'z', meaning it doesn't have any references then the closure attribute would Let's move on to &quot;level_five&quot;. The point of &quot;level_five&quot; is to show you that meaning their source is actual function objects that get hooked That's what the &quot;def&quot; keyword does. &quot;def&quot; does not compile a new function. &quot;def&quot; creates a new function object And hooks it up to the pre-existing bytecode. That means every call to level five Each of these copies is distinct and Every call to &quot;level_five&quot; has Therefore, the closures for each copy of the inner So in this call, we pass in &quot;n=0.&quot; This call, we pass in &quot;n=1&quot;. In the first call, we see 'outer z 0'. And in the second one, we see 'outer z 1'. Of course, this is probably what you since there's only one 'z' floating around. And now we're back to &quot;level_six&quot;. Let's just follow the rules. There's no assignment to 'x' in 'inner'. There's no assignment to 'x' in &quot;donkey.&quot; There's no assignment to 'x' in &quot;level_six.&quot; 'x' will be looked up in the global 'y' is a parameter of the function. There's no assignment to 'z' in &quot;inner&quot;. Therefore, the 'z' will reference the cell in &quot;donkey,&quot; which eventually gets set to &quot;donkey z&quot; We return the function. And because that function's closure is referencing That cell is not garbage collected, and In 'chonky', we call 'donkey'. And the The 'x' here is irrelevant. The inner function will always look in the global scope When we call 'f', we pass And 'z' is still referencing the cell that So we'll see 'donkey z'. Therefore, when we print this out, Now that you know the rule, it's not so bad, right? Before we get to the final &quot;level_seven&quot;, I'd like First up, what about lambdas and comprehensions? Although lambdas are syntactically a very You don't give them a name. They kind They have this implicit return statement. And Lambda is an expression, not just Ultimately, lambdas are just functions. It's fancy syntactic sugar for All of the scoping rules for lambdas are So the rules for this Lambda The code in the body gets compiled And variable lookups happen at runtime. But where Python will look for Next up, comprehensions. I'm going to use a list comprehension, You may not have realized it before. But defining a comprehension is defining This comprehension which is equivalent to this: defining a generator And this part, defining the generator, It defines a generator function and The scoping rules for generator functions So whenever you use a comprehension, just pretend And use the normal scoping rules. These cases usually aren't In this case, 'x' is treated as a local And the last thing we need before our last &quot;nonlocal&quot; and &quot;global&quot; don't actually correspond By default, the compiler would determine on its own whether each variable was a local variable, Because we assigned to 'x' in this function, the compiler would normally assume &quot;nonlocal x&quot; instructs the compiler to treat 'x' as rather than a local variable of the So this assignment will In our first print statement, we see the &quot;nonlocal x.&quot; Calling the function changes the value of That's the return value, so we see it once. Then we print out 'x' again, Then in &quot;main,&quot; I'm also printing out the global 'x', Let's change this to &quot;global x&quot;. The first print, we'll see 'nonlocal' Our call to 'f' will change the global Then when we print this 'x' again, because in this function, 'x' is a local variable. But when we get to the global print, we'll So indeed, we see 'nonlocal', then the overwritten global, the 'nonlocal' again, and the overwritten global. The lookup rules are exactly the same. It's just that you get to override the compiler This is typically only needed if you want to assign If you're just reading the variable, what the compiler But if you really shadow your variables So I'd say if you're using &quot;global&quot; to just read a value, then the real solution is to just choose Or, better yet, to not use a global So finally, we come to &quot;level_seven&quot;. Please, please, please do not do this. But if you understand the rules, you should be able to understand why Take a moment to think about it and comment below. I'm just gonna blast right ahead. Okay, inside &quot;level_seven,&quot; we define This defines some generator. And it returns an instance of the Because of this monstrosity, 'a' is determined to be a local It doesn't matter. This code will never execute. Because there's an assignment to 'a' 'a' is treated as a local variable of that function. Inside the generator, we explicitly mark 'a' non-local. Every time we unpause the generator, Because 'a' was non-local, Inside this lambda, 'a' is also treated So it finds this 'a'. Then we return the generator and the lambda, In the outer code, we grab our the generator and lambda. If we call the function first, then we get a name error. &quot;cannot access free variable 'a' where it is 'a' was pointing to a cell. That was empty. But if we run the generator first, we see the value 0. Every time we call &quot;next&quot; And whenever we print the function, Just imagine the person who's got And they track it down to the source, But every time they call it, they just Gotta say, that would be a pretty So anyway, like, comment, subscribe. Thanks to Kevin for submitting the And as always, thank you to my patrons and donors. If you really enjoy my content, It does help me out. So please go forth with this knowledge See you next time!