[MUSIC PLAYING] COLTON OGDEN: Hey, good evening. Welcome to GD50 lecture four. This is Super Mario Bros. As seen on the slides not using the actual Super This is sort of like a rip off. But I found a really that has all the basic tiles that There's a link in the distro as I had a lot of fun playing with it. So hopefully, maybe can use some of the sprites in there But Super Mario Bros.-- the actual game based off of-- is the game shown here. I think everybody knows what it is. It's probably the most But this game came out in 1985-- sort of revolutionized It was the game that brought in the '70s thanks to a lot and companies and low QA standards. It basically took the gaming and brought games really back to the This and games like Legend of made Nintendo basically the industry in the '80s and '90s. And even today, with games they're still doing their thing. This is Super Mario Bros. It's a 2D platformer. And what this basically means is He goes around, walks sort of He walks left to right. He can jump up and down. He's affected by gravity. He can hit blocks. He can jump on enemies. He can go down pipes, and It was, for its time, and it spawned numerous offshoots platformers. While we talk about some of the topics we'll actually so how we can take basically tile IDs-- and turn As you can see here, the game is broken You can see the bricks and and the pipes are even all And they map to IDs. And when you take a 2D table or array and render the appropriate you get the appearance of even though it's just composed 2D animation is something So far, we haven't at all in terms of at least characters. We'll do that with Mario. He'll have-- our version when he's moving, he'll have The frames of animation-- if you've ever used one, where And when you display them you get the appearance of animation. We'll be talking about that. Procedural level generation-- generate randomly. So every time we play the everything will be completely different. We don't have to hard code Everything will be dynamic and We'll talk about the basics and how we can apply here, because we are just each with an x, y that's hard All we have to really do is take and then just divide And then we get basically in our array at that point in the world. And so it's really easy to do on what direction you're going every single tile in your world. Because it's just a simple mathematical given two coordinates, since We'll have a little walks around and does a and will go after the player, sort And then lastly, we'll touch on and how we might be able to and that sort of thing. So first though, a demo. So if anybody is willing to test out my implementation James? I'm going to go ahead into here, So as soon as you're ready, and you should be up and running. So as a part of having random levels-- so currently, we have a green alien. The blocks have a random chance And so once they do, Either they have a gem or they don't. You can pick it up, As we can see, the world based on where James's avatar We have some notion of a camera. You're getting unlucky So you can fall down through the spaces, But if you want to so in that case, we collided The one on the right had the gem. So go ahead and just fall So when we fall down, we has gone below the world limit, at the beginning of the game. You can press Enter, it should Notice how we have random We have random tiles. We have random toppers for them. All the blocks are random. We have snails now. They're sort of chasing after James. He can jump on top of them. There's a lot of little moving are actually pretty simple. And I'll show you very shortly. JAMES: Should I stop? COLTON OGDEN: Yeah, sure. That would be a great point. So thanks, James. Appreciate it. Currently, there is no That's part of the spawn an object that the player can a new level, basically. But the whole engine behind this basic And so our goal is seen here. Our goal in this lecture how we can get things like a character and a camera that tracks their And maybe there are pillars in All of this, again-- at least the tiles-- are So all we really need to do is perform Maybe 1 is equal to a tile being And so just by looking at it, We can say, oh, maybe there's a chance column on this x of the world map. Or on this particular y, maybe we spawn a couple above it and and so on and so forth. And it's just this summation equals a nice little So the first thing we should talk And what I've alluded to so far is as being effectively a 2D And it's a little more complicated your platformer is, because some numbers or not. So you should be able to check meaning that the player or whatever can actually collide with it or Not. So obviously, we don't want to We want the player to But if they run up against a wall and they hit tiles below them or above and then stop them based on And depending on how complicated you have animated tiles, for instance. So if a tile's animated, it will based on what timer you're on. Really, the sky's the limit. In this case, we'll be fairly simple. Our tiles will mostly just be numbers we'll see later on. And this is just an example here of background. We have our character, and then we can as being just for the So tiles0-- so I'll actually get here as to how we can get So if you're looking at is going to be where we start off here. And I'm going to go ahead and run tiles0 So this is just tiles0. It's a much simpler program than what is just a color in the Off the gate, anybody have any ideas be if we wanted to implement this? AUDIENCE: Just put the tiles in a loop, COLTON OGDEN: So put the and then have a background. Yes. So basically, if this is first thing we're going to need we're not going to be We'll be storing little mini tables so we can say tile.ID Here, we have an empty table. We're going to populate that. If we're going to draw our tiles, we And what I did was I just chopped So this is tiles.png. It's just literally one sheet that comes with the distro. And then on the right side is just maybe tile ID 1 is equal to solid block, And so if we recall generate quads, into however many quads we want to. Let's say this is 16 tiles tall-- each tile-- and then the whole So it needs to be split We'll just generate quads, and Each of the indexes a quad that maps to one of these tiles. So number 1 will be will be the transparent that's how effectively into what gets drawn onto the screen. The ID is the index into our quad table. So going back into tiles0, we have We're just going to say RBG-- we're just going so we're going to clear the And then this is the And notice that we're It's good practice just to So our tile size in they're all going to be 16 by 16. And so since they're symmetrical, And then here is where we so nested for loop. y gets 1 to map height, Remember, we have to insert a blank going to act as our current row. And then in that row, we're because y is going to be up And so what we're doing here meaning we'll just set an arbitrary If it's less than 5 tiles from the And so sky-- up here on set two tile IDs, as I said before. Sky is 2, so it's going to be And then ground is one. It's going to be the very first So if y is less than 5, that it should be equal to ground. And so down here is where We're going to clear the We're going to iterate over We're going to get and then we're just going to draw the And then recall, since tables are 1 we take the x and the and then we just multiply And that has the effect of at their respective point it seem as if we have this with a random background every time. Which isn't all that interesting, And so that's the very I mean, it's essentially almost the same where we just mapped the were in the grid to indexes in the tile Only this time, they're always so we don't have to worry different from their grid y and grid x. We're not maintaining And so that's static tiles. Does anybody have any draw static tiles to the screen? Pretty basic stuff. The whole name behind is that the tiles scroll based It can be an auto maybe you're an airplane through a level that's and you're shooting things. And you're not really in Or it can be like Mario, And you can walk around and the camera will And so the scrolling is just relative So I'm going to show you get scrolling implemented in our game. And to do that, the function that at a new function-- is love.graphics.translate(x, y). And so what that does is Love2D's coordinate system so it gets automatically shifted by x, y. And so that has the effect of the based on the x, y that we pass it. And so if we maintain a reference we can just shift where everything And that will have the effect of All we're doing is just based on some offset-- x being in this case where AUDIENCE: So it changes the COLTON OGDEN: It does. It shifts everything in the coordinate And so that will basically into the active window at that time. So I'm going to go ahead so we can see how this works. Let me go ahead and So if we're going into currently it looks almost identical. But I can move it if I And so we can see here, this gets cut off here. And then it also cuts off, because It also gets cut off at the And these are details you would by just clamping the x of the map minus VIRTUAL_WIDTH. And that will have the effect of it won't let you go right anymore, Well, all we're doing doing it based on the character at all. We're just using keyboard input. So let's go ahead into tiles1. And so the important thing that as I just alluded to, we're on some value called cameraScroll. It has to be a negative value, up here or to the left-- if we're moving to the left, camera so it's going to get less. So we can say the going left is going to be 0 or or it's going to decrement. If we press right, camera If we want the appearance of moving you actually have to translate Because if we look at this, and if we all of this is going to So it's going to have the And if we translate it to the it's going to have the So if our scroll is positive and we actually have to translate And so that's why I'm calling Does anybody know why we're instead of just calling Does anybody remember So math.floor will return the-- it'll basically truncate the It will basically take off Because we're rendering with push, if we basically offset the you'll get artifacting. Because it's taking your your image onto a virtual canvas, you'll So whenever you draw something and you and you're drawing it to a virtual or it's being condensed, just so you don't get any If you take this out and experiment you take it out of the player's will get weird blurry So that's why that's there, And so all we're doing if it's equal to left, scroll or basically decrement our camera scroll And then just use the You could also just assign when you move left and and then you could give it the But it's sort of mentally So I just made the decision to decrement because we're going less on the x and Does this make sense? Anybody have question? AUDIENCE: I have a question. Is there a corresponding and in other languages like this where COLTON OGDEN: Is there an where you can shift the Not in base JavaScript, probably. I'm not too familiar with CSS. There might be a CSS In a lot of 2D game And a lot of actual 2D game engines sort of encapsulates this behavior. Love2D doesn't have a of why we're doing this-- is because framework, Love2D. It doesn't really give right out the gate, which makes it But a more robust solution or a lot of other game frameworks is And you just basically give that You basically tell that like camera.trackPlayer and that'll have the same effect. It's a little bit more abstract. It's a higher level but it's the same exact So any other questions All right, cool. So that's all we're effectively doing. We're just getting a camera scroll, And then just every frame, before we draw everything. You have to do the translation before draw after the translation gets affected So that's scrolling. Let's get to actually talking about more than just a set of tiles, since If we look at character0, this This is just going to be charactr0. You guys probably know All we're doing is just drawing so just love.graphics.draw. We're getting quads from a tile sheet. I believe it's in the slides. The actual sheet is here. So we have this little guy-- several frames of animation. It's 16 wide, 20 tall, We split it up into quads first. So we know that it's 16 wide by on this image by 16 and 20. And then in this is taking the first frame, which As you can see here, we have We have like a crouching get to more about But here, we have him But you can see all We'll end up showing how you and get different animations. But for the sake of this is just rendering the very first frame. And we can see that-- let me make sure I'm in the we are getting the character And then we have to give him an In this case, we're just so we do 7 minus 1 times TILE_SIZE but coordinates are 0 indexed. And then we just subtract right above the tile instead And then down here, we on, as I said before, Just a very basic hard coded example. Any questions at all So now let's say we want him to move. What do we need? What's the next step if we AUDIENCE: Give him an x and y? COLTON OGDEN: Yes, give him an x and y. So yes, so he does have So if you look at-- So if you go to character0, We have given him an x and y already, What's the other step involved? So if we wanted to move, we need And then we need to take his x-- we're just going to move We basically need to take his and we need to modify that. We can basically do the same thing Previously, it was on love.graphics.translate. We modified the camera scroll. We set that equal to scroll We subtracted or added it. In this case, what we're doing CHARACTER_MOVE_SPEED, and we're but on characterX So the end result of that is And then we can move him left Now, there's a couple of things wrong. What's wrong? What are some of the things that AUDIENCE: The camera COLTON OGDEN: Camera AUDIENCE: No animation. COLTON OGDEN: Does not have animation. Those are probably the two So camera does not track him, Obviously, we want to be able to unless we're at the If we're at the left edge of And that's part of the that it doesn't go past the left edge. But if we're beyond the middle and it should be moving along And then he needs to needs to change every certain number And it has to be only If he's standing still, you Some characters will tap their But let's say for the sake of to stand still when he's idle. And we want him to have an actual We need to take care three pieces if you count So let's go into character2 and is tracking him. So let me go into character2. Let's run it first so we So now the camera is basically In this example, we don't take In the distro, that's fixed. But we have the basic side scrolling follow him. How do you think that Yes. AUDIENCE: Translate the COLTON OGDEN: Yes, exactly. And it can't be exactly because if it is, then the character So we need to offset our We need to basically translate by plus half the character width. And that will have the effect of that offset half a screen width away And so what we're doing is in character2, we're still Actually, that's the wrong file. We are modifying characterX here. So same thing we did before-- multiply the move speed by delta if we're pressing left or right. But also, here-- And we're setting it to, like I said, by 2, half the screen, of his width divided by 2 so that Because remember, are set by their left, not their center. And then we just do what we did before. We translate the scene and we render him at characterX to prevent him from being at a and then it being blurry and artifacted. And that's sort of it in terms of how And if you wanted to you could do the exact same thing. Maintain a cameraScroll so keep them separated. And then you would just translate here. So we're passing in 0, to track along the y-axis necessarily. But all you would need to do And then you could do and whether or not or past a certain point in the sky. So any questions at all as to how All right. So we took care of one issue, But there was one other issue, All he's doing is just moving or is it M.C. Usher? M.C. Hammer? I forget. He's doing that. He's not doing anything. We need to actually animate him so that and that you can also between two separate states. He can be idle, he's not So we should have some as to what's currently going on. So anybody know how we an animation for our character? What are the pieces that we'll need? AUDIENCE: I guess if call a function and a render COLTON OGDEN: Yes. So if he's moving right, that sort of loops through some images. That is effectively We have a class called Animation, And all it basically does pass it in a table, which that you want to animate over. So we can just pass in-- let's go ahead and take a look here. And I referenced the slide are 1, 2, 3, 4, 5, 6, 7, 8, 9, you just pass into the animation. Let's say he's on a ladder. So let's say this is 1, You say, the frames are so those will just loop at the beginning when it's finished So say I want the animation to so I want it that maybe And so that will have the it'll keep track of a timer. So have we gone over 0.2 seconds? Start at 0 and then add If we have, increment what our So our current frame is this one, it's going to be this one. And then 0.2 second elapses, and we So we'll end up using as we can see in the Animation class. Basically, that's all done here. So if we have more than one frame of So we get frames, we get an interval, and then get a current frame. We'll say the current frame is 1. And then as long as we there's no point in looping any animation that only has one frame. And we can, of course, have Idle is only one frame of That's only one frame. We don't need to do any what's the next frame, because But if we were to look at character3, And then that's just And when we move left, he Anybody recall how we can we saw the spreadsheet and there was only one direction how we can get him to look no sprites for him to look that way? AUDIENCE: Flip it on the axis. COLTON OGDEN: Flip it, Recall you can pass in a negative and that'll have the result of That's all we're doing. So this is the default frame, And then we have to keep a reference And if his direction is just draw that frame and then If he's facing left, draw it, but also on the x-axis. And just like that, So all we're doing-- just keep a timer. And then when the timer goes over our And then use modulus back to starting at 1. And that's all done And so you can look if you want to get a handle but it is just a simple sequence of based on a timer. And that has the effect-- just like of our character having an So any questions as to how AUDIENCE: The render is COLTON OGDEN: So no. The render is not in the animate class. So the render is-- I realize I didn't show We have two animations here, so we're just passing in one frame. We're going to give it an interval of 1. It's not going to really matter, but we're giving it an And maybe we want to So by having an interval here, Moving animation-- recall 10 and 11. So it's toward the end of the sheet-- the two walking frames. Interval here is 0.2 seconds. We need a current and then we keep a reference to So if he's looking to to reference this in the And that's what we're going to along the x-axis. Maintain a reference to that. And then down here, the part that is on line 150 if you're Or is it character2? Sorry, character3. If you're looking at we're using So the class will actually just tell you is, because it keeps a reference to and how much has elapsed. AUDIENCE: So the class is generating and plugging it in there. COLTON OGDEN: Yeah. It's maintaining a reference to and it's in the table of frames the definition up at the top here-- lines 51 to 58 where we Basically, it maintains a reference we're at. So if 0.2 seconds has elapsed, we And then we'll go back to 1. And so it'll just basically And frames index 1 is And so the function is getCurrentFrame. So characterQuads, And then here, because we're so that's another thing to consider When you flip a sprite, whatever its default origin is. And the default origin of any So if you flip something it'll appear here instead So you actually have to set when you do any sort of in So you'll notice in the at it that we have plus CHARACTER_WIDTH divided by 2 on these two here. So we shift where it gets drawn, offsets which are here on line 160. So if you look at see it has a lot of optional arguments. And these two at the bottom are And so these only really you do some kind of flipping and you want graphical consistency not Sometimes that's the effect you're it's not. We want him to literally So to flip a sprite in you need a set its origin to Does that makes sense? OK. And also here, 0 is the rotation here. So it's sort of required this many arguments to the function. But we're testing if direction is equal on the x, else just give it 1. So 1 just means default And then we don't flip on the y And so that's in a nutshell how you can stay in place when you animate it. So any questions as to how animations or OK. So we did talk about animations. The last thing we'll talk about So if you recall from Flappy Bird, What are some of the pieces we need? AUDIENCE: Key press, And then we have to have gravity. COLTON OGDEN: Yep. So key press is one thing is going to be the default key. y goes up, and then check for gravity. So not only do we need y, We need velocity, because gravity strictly on position. So if we go back to of a hackish way of because we haven't actually And I'll defer most of the as to the distro, and I'll But right now, we have the where we have tile scrolling. But if I press space bar, I And notice that he has He has a different frame. So if he's jumping, he's So that means now we We have an idle animation, and then we have a jump animation. So effectively, we have idle state, moving Four states, actually. And also, I noticed a slight bug here his frame doesn't change. So it actually probably even if he's standing still. But I guess it doesn't matter too much. We also interpret it as a feature. But he's got a couple of There should be two states here. One is jumping state, And do we know why the two being So if we think about Super Mario Bros. and we think about the differences what are some of the things that change or whether he's falling? How does he interact differently So if unfamiliar, Mario-- when he So if he's below a block has some sort of behavior in it, it whether it's a coin or whether And if he's falling, recall if he he'll destroy the enemy. And so we need to distinguish Because when he's jumping, when he's actually going up, And likewise, when he's falling So even though he's and the gravity is and it all looks like one state, in his state that are relevant. And that's something that and it's in the distro. He has a falling state Even though they share they have different behavior. So let's go ahead and look at So what I've done here is I've So just like in Flappy and we made our delta y so instantly shot up pretty applied every frame. Same thing here. Once we press space, we're going if we go down to right here. So if the key is equal to space, I have Since we're doing all this in things are a little simple. If key is equal to equal to 0, what would check to see if delta y was equal to 0? AUDIENCE: We double jump in the air. COLTON OGDEN: Yep. We'd be able to jump infinitely, We set his dy to JUMP_VELOCITY. JUMP_VELOCITY is a constant up top And then gravity is equal to 7. And so what we do is we set it as soon as he jumps. And then every frame down increment his delta y by gravity. And then we increment his y And so it'll have the effect and he's got a negative start becoming positive and and then he falls back to the ground. And then the hack that I since we don't have collision detection is we're just basically gone below what we set the map's floor. And if he has, then set his position, here on line 133. And then set his delta y equal to 0. And that will allow us because his delta y will be equal to 0. AUDIENCE: So I didn't Looks like there's always gravity, then. COLTON OGDEN: There is I realized shortly before lecture. But all you would really have to Yeah. You could easily take that out of AUDIENCE: It's just a COLTON OGDEN: It is. I mean, it's not expensive, is incrementing a variable If anything, if you're introducing which is probably the I think a branch is more I'm not entirely sure about that. AUDIENCE: Interesting. COLTON OGDEN: Yeah. In this case, it doesn't But it's a good thing to notice. But now notice that we can just because there's no collision detection. We'll talk about how we implement So one thing that we'll start talking soon-- is procedural level generation. So I am a big fan of and platformer levels are at least in a simple sense-- to procedurally generate. And so like with match did was just loop say, oh, get a random And then with the assignment, it where you actually had to check to And then if you weren't, should be maybe a certain amount progressed in the game. With a platformer about how we can take that grid of tile How can we get the results of a level, introduce some variation, right? And so the solution that I is going column by column. So here, we just have a a very simple perfect screenshot of generating the level. But recall, if we just think about being a 0 and these being a 1, it's We could just fill the entire thing And then we could just column by every column. OK, do I want to generate a ground here? If I do, start at the generate earth tiles all the way down. And then go to the next x position, And then maybe every column of you also have a chance to So if generate pillar is instead of starting the ground And then maybe you OK, not only do I want I also want to generate chasms-- just empty space, Because if he falls down-- it it should be game over. So in that case, you just make math.random 10 or whatever it is-- then just go to the next x. Don't even do anything. And that will have the And so little piece by piece-- doing small things like of generating a lot of and random levels. You never know what to expect. And this is a very basic example. You could go infinitely far with it. However many ideas you to create obstacles and interesting you could absolutely implement that. AUDIENCE: How do you handle if You have to have that consistency. COLTON OGDEN: Yeah. So if it's a platform, it depends on And actually, I did a and we did platforms as tiles. In this case, we'll have what we've denoted as are a little bit different than tiles. Because they can have arbitrary have to be affixed to the world grid. But if you were to treat a two tiles wide as is just basically have a flag up equals true or whatever-- AUDIENCE: And then turn it off after-- COLTON OGDEN: Turn it off You also need the size of it. You'll need a flag that's like and so you'll just keep a counter. It's like current platform And if it's equal to width, then And that has the effect of if you don't account for that. So you can also in your logic say, if don't generate a pillar. But you could generate a doesn't interfere with your platform. If you don't have platforms as then you don't have to do it during You can just test. You can just create a game Depending on how complicated maybe make sure that it's not next And you could just do that by getting at the next four tiles-- something like that. We don't do platforms in this that you could pretty And slightly more difficult do with game objects, which and which we'll touch Let's see, we're at level-- oh, another couple of things actually start getting into the This is the sprite sheet for this whole sheet that I found online. It's in the spirit of and it's got a nice little So I encourage you to and just maybe get some inspiration Tinker around with it if you want to. But as you can see here, there's a We have a ton of tiles. These are all tiles here-- different tiles and variations. And then we have a ton And so what really helps of generating these levels so much visual content to work with. And so here, again, are the tiles. Here are the toppers. And then when you take the have these random backgrounds-- these are toppers here, It's incredibly easy to just have and interesting things in your and the algorithms here are very simple. All we're doing is just checking I know. I thought it was really cool and helps of this whole procedural approach And there's actually not that many of procedural level generation Plenty of games like Terraria is a great platformer But I don't think I've seen a game that does something like that. Let's see. What time is it? 6:23. Let's take a five minute. And then as soon as we'll start going into how we actually generation in more detail. All right, welcome back. This is lecture four. And before we took a about procedural level generation So recall, here are just a few examples And you can see they have different Sometimes we have chasms, We'll be talking about a few ways because there's two levels here. In the distro, we'll see there are We can see in the top well, I guess those little purple cacti. And the one right below that, there Those are separate game objects. But the actual tiles themselves we'll to get those generated. So the first thing we want to look at, just basically what we've already done. So I'm going to go ahead And then if we see here, we just like we did before. Now the tiles are different. And if I press R, they're So you can get a sense of just how Oh, I think that might I'm not sure. Haven't seen that yet. But we can see here, I'm pressing R. All I'm doing is taking the and I'm assigning it a in the case of the scope So recall that the topper is and the tile set is Anybody want to just suggest how I'm and what's going on there? AUDIENCE: You're just pulling it COLTON OGDEN: Yes. Yeah, in a nutshell, I'm from a different part of the sheet. Any idea how I'm storing to get it to render like this? AUDIENCE: Maybe you just need to and know that everything COLTON OGDEN: Yes. So you could store the and know that everything That would work for a flat level. I don't think that would be reliable because the pillars are a higher And then there's also So what's going on storing a flag in the tile that says And if it has a topper, then but as soon as we render the And I won't go too deep But what we're doing to get all these too is we have to take all of these and divide them up, right? We have to know that if we want set one, then we should basically its own table-- this into its own left to right actually. And we have basically So we go every set on the And then within each of those, we want and every tile along the the tile sets so that we can So in the actual code, I won't But I'll show you where it is if you're It's in Mario in Source, util.lua, stored our generateQuads function, sheet along its x and y based on We have in here also a generateTileSets from a generateQuads table. So we first generate quads on So we have every single frame of I don't know how many that is. 6 by 5 times 10 by 5, 10 by 4-- that many quads, so thousands of This I'm pretty sure And then we take that the number of sets along the and then the size of each tile set We basically divide it using We basically just divide it up. And then instead of along the entirety of basically do a 2D slice of from the first generateQuads call. So I encourage you to look in You don't need to necessarily know But that's how we can basically and easily integrate it into our code. We can just swap in and sheet we want to work with, is cleanly laid out like this, which You want to make sure that everything is Had things been scattered maybe things were zig zagged or there that-- we wouldn't be able to do something in util.lua with just 63 by getting each individual tile set. So that's an important looking at creating and you want to do some programmatic Let's make sure we're in the right-- we're not in the right going to go into level0 into main. And we have constants now for all of and how many they are wide by tall. We do it here. We get our regular quads so these are just literally every sheet put in one table. And then we just divided and topper sets here with And then we get a random tile set math.random, number of tile And then at the very bottom also, 223-- which is going to be built Level0 is just a flat exactly what we saw before, which ID should be equal to sky or ground. And then this part is alluding to before with we need to store a flag in a And it should be whatever the top In this very simple flat assume it'll be the same y level. In this case, if it's should be true, otherwise, false. So every tile along y 7 is going And this comes into play up here. If we do love.graphics.draw(tilesheet), before, but we have tile sets So remember, tileset got and however many tile sets we had that sheet. Now, we just index into that, And tile.ID will then be whatever our the whole entire sprite at once. And the same thing for topper. We have a topper set, sets here at the topper set where we'll have the collection of And so the two are completely separate. They can be one random color tile with It's global. We have one topper set and one tile And if we press R, which just reset them to random Tile set gets a new random number, It has the effect of-- we can just walk around and So pretty simple. And recall again, topper is-- because the tile that we're standing So in that case, that particular top And it gives us a nice because it actually makes quite a topper versus no topper. And you can also just not that a permutation of the toppers That's flat levels. Does anybody have any or anything that we're doing here? OK. So things are a little The next step will be actually that we can see here in our little like this pillar right Does anybody recall how we go to just flat land? AUDIENCE: For that column, just put COLTON OGDEN: Yep. So for that column, just put more tiles That's exactly what we're going to do. So I'm going to go ahead and I'll run the example here as well So here we have quite a few. And notice we haven't so we're still walking through them. But they're just random. Their random amount is Right here it's pretty lowering the amount a little bit. If you wanted to, you could also maybe and maybe you want a pillar width. You could have anywhere And if its width is greater than and just draw that same height a few and then set the flag back to false. A lot of things you can do with it. And also, they're a little tall here. For the main distro, I ended up But we'll see how we do It's going to mostly be down So what we're doing here-- is we have basically this code here-- line 227 to 236. So all we're doing here is just We're just setting the And now we have a fully All we need to do in order don't have to worry about insertions All we can do now is just directly So all we need to do is we're going to start doing the column by and deciding whether we should And we're always going So here's the flag spawnPillar. And if it's equal to 1, this is going So math.random(5)==1. We have a 1 in 5 chance If we just want a pillar, then so y gets 4 to 6 effectively-- tiles at pillar x, ID ground. And then here's where we because now pillars can be the But they're above the ground level. So we just basically say, when if pillar is equal to 4-- which is then set topper equal to true here. Otherwise, set it to false. So that's how we can get pillars to we're not generating any chasms yet. So all we're going to do-- once we've generated a pillar we'll just say ground gets so towards the very And then we'll just set it to ground. And then topper-- in this that we're not spawning a pillar. Because if we don't also spawn a topper where and it'll look a little bit silly. And then we also want to check And so all together, that has And so if we didn't check we'd have a topper right which looks graphically strange. And also, you can see-- emergently, we're getting And that's just kind of a lot of these randomizations. A lot of these procedural algorithms-- they'll generate outcomes have anticipated, which You didn't necessarily program it to but just the nature of randomization-- And that's another exciting thing is that it can surprise even the It's really cool, and it saves So that was pillared levels. Chasm levels-- who can tell AUDIENCE: You just skip a column. COLTON OGDEN: Yep. you skip a column. So at the very beginning, is, do I want to generate a chasm here? If I do, just skip. Go to the next iteration of the loop. And so we'll take a look at that. As simple as it is, because Lua this will be a refresher, this was in one of the assignments-- it has a goto statement. So basically, same code as x equals one until map width. We have a 1 in 7 chance-- just arbitrary. And this should ideally-- if you're engineering an entire this would be called and just set that to seven somewhere. But we're just setting it to 7 here-- just a static magic number, but Goto continue-- and so continue is here, which is this for x = 1, mapWidth. So it will have the effect of skipping for example. A lot of languages just Lua does not have continue, so this for implementing You create a label via double colon and then you just goto it. And so that's as simple as And so if we go to level2 And so now we've got a little bit It's not spawning a ton It spawned one so far. There's another one. And then sometimes just See, there we go. We get some interesting It almost looks as if someone almost. I would probably, like I said, It's a little tall. That's that. That's basic procedural-- in that's the mental model thinking about generating obstacles. And there's a lot of different Let's say maybe you wanted I mean, it's a common thing in Mario. There will be steps, The same implementation It would be a little bit doing it on a column by column basis. But you'd effectively to something like step would say generate stairs is true here. And then you would just So then you add a tile here. You would go from ground level up go the next one, and then And then do from ground tiles go up. So 1 and then 2 and 3 until you've you stop generating stairs. That's this principle do something a little more complicated. Or pyramids-- same exact And then you just go until or we're at pyramid width And if we're higher than And then you have the effect Yeah. AUDIENCE: Where are generation if it's a [INAUDIBLE]. It's not in the play state. COLTON OGDEN: In this But in the distro, it's going So we've broken out all into just how we did Breakout. We had the same sort of and it just has levelMaker.generate. And then you give it and it will generate an AUDIENCE: An entire level, oh, you generate it all at once? It doesn't generate as you walk? COLTON OGDEN: The question is, does it It just generates all at once. So you could implement a-- if you wanted to do an infinite runner, would break up your level into chunks. And with infinite runners, usually So as you go right, your levels that discarded, so you avoid What you would do is you maybe a 100 by 20 level. And then you would go And then when you get to level end you would generate another one, and then you would just go And you probably would need to splice them together Alternatively, you could no, you probably wouldn't want to pad. I would probably just splice them end to or however many on the left once it's In this case, to But you could very easily-- not easily, but you could very Yeah. AUDIENCE: So we're rendering the entire COLTON OGDEN: The question is, but we just can't see it all? The answer is yes. Currently, in this implementation, so tile by tile is getting For small examples like But for a large level-- like if we Terraria's thousands and thousands 1,000 or more tiles tall-- you want to render only a chunk, And for that, you could use your from one tile to the left and above of the camera and to the right of it. Just render that subset of tiles. So you just need a for loop to AUDIENCE: So you can of what the map's going just render only slices of Is that right? If you put a multi-dimensional array and render as you go-- COLTON OGDEN: Question a multi-dimensional array and then you just render it as you go. The answer is yes. You would have your overall tiles-- your big 2D array of 100 by 20 or And then based on wherever it's just a for loop within So maybe your player is So you would just render from on x and maybe 10 to 20 on the y-- just that chunk. And it's just relative You're always rendering basically, it is effectively It's rendering a chunk of AUDIENCE: But in this code, it's not. COLTON OGDEN: In this code, no. The levels here are-- it's sufficiently I mean, it's not too It's pretty easy. But the consumption-- is very light, because the And even if we did have it's sufficiently small to But if we did get to a point where and then maybe those you just want to squeeze all of your application. You could look into It's fairly simple to introduce that we included in this assignment. Any other questions as to OK. So far, we've talked about We've talked about animation and We haven't really talked about And we won't go into a because the code is a little lengthy. It'll be part of your assignment but it's in the TileMap Basically, the whole gist on a 2D tile array that's fixed, in the model that we've We can just convert just check to see whether or not are solid or not. Let's say we wanted to look at the So if we have our character here. For the sake of illustration, I just to show why we need to do But you take the point here-- his very top left, so which is effectively And then player.x plus we do a minus one for so that he can walk between Because if you don't basically give because he's 16 pixels wide, and if he's between two blocks he just won't fall down, because Because if he's on the hole here-- let's say this is the hole, The x plus the width-- it'll trigger a collision on So basically, you need to minimize to fit through 16 pixel gaps But the gist behind collision-- in this case, this would jumping, because this is the collide with tiles that are above him. You would test for whatever and whatever block falls on this pixel. And if either of them are And if not, then there's So if he's right here, for example-- right directly beneath a tile-- This point and this point are But the reason that we want to is in the event that he is because now this point's and this one's going to check this tile. We can't just check this tile, and there was no tile here him jumping would still It would think that it was So for every collision on every we need to check both corners So when he's jumping, this x, y-- into a tile by So we can say, player.x That's going to equal whatever And then same thing for the y-- we just divide the y by tile And that will allow us If we use those x, y that we get the exact tile at that y, x index So we do that for jump. We check both corners We do the same thing for the we're checking x, and and then x plus width, y plus height. And then if we're doing the AUDIENCE: The bottom left and top left? COLTON OGDEN: We are. So that will be x0, y, and And then if it's the We check x plus width y, and then And so that's the gist behind And you can see it in Point to tile-- this is On line 32, we're basically returning-- this bit of code here-- 28 to 30-- is a check. Because we can jump won't be able to check at plus 1, x divided by TILE_SIZE plus Those won't exist, be outside the map boundaries. Same thing if he goes below it or he So that's all this code is here. It just makes sure that if we we return nil. So that way, we can check nil rather And then on line 32 is the which was we take the y-- so this x and y that we pass in are When we pass those in, we're just and then effectively y divided by and then add 1. Because recall, tables are 1 indexed, So this will result in a 0 indexed Same thing for here-- math.floor(x) So effectively, points to tiles. And then we'll just And the tile-- we can just check, If it is, trigger collision. So that's the gist behind being where everything is fixed. That's sort of like a Because now, what's the What jumps out as being a super imagining that we have, let's say, So if you look and we're just doing a simple on what his x and y is, right? What's the alternative to this? If we were doing this we'd have to iterate over AUDIENCE: Can you summarize? To avoid iterating over you just check the column that COLTON OGDEN: Yep. So the gist is he's got an x and a y. The x and the y are going to be in and his y could be 38 They don't map evenly to tiles. But if we divide those by whatever 16-- that's going to be the exact tile. We also have to add 1 to it, because But we can index our that we get from that-- And that will be the exact We don't have to basically that we iterate over collide with the player using like we've done before. Because recall, in Breakout, They all had their own x, y, They weren't fixed. So we had to actually We had to iterate over them because there's no deterministic way It's the same thing with Because arrays-- you can calculate You have instant access to it. It's an order of one operation If you want to try and you have to iterate through the AUDIENCE: Can you just look for the COLTON OGDEN: You're getting the exact or whatever your tile size is-- and your y divided by 16 is. And you're doing it, recall, depending on what you're looking for. If you're looking for the tiles you're going to be So whatever this value whatever that is divided by 16 and And then that'll get you whatever It will intersect with whatever and whatever tile Same thing with here and here here, here if we're and here and here if we're And we check for collision moved so that these points will be And that's how we can check We do this when he moves and is AUDIENCE: So you're still with his actual narrowing what you're character width-- COLTON OGDEN: Yep. we're turning it from iterating to an instant operation, because the exact tiles that to worry about where he is in the map. It's just instant access. And this only works because fixed in the exact same locations. They're always starting at 0, 0. They're always going to be TILE_SIZE. Things get a little we introduce game objects, which And for those, you do You have basically a collection of game Let's say we have snails The snails aren't going to be at They can move continuously. So for those, we have to actually and then loop through them and say, has If he has, then trigger a kill it or kill the player if he's And if he's in a should die, because he's And you narrow down what collision you here. Tile collision-- when you're you're only testing that when because it's the only time you need to. So that's the only point at which you'll When you're in the falling state is And then you can interact when you're in either the so you should check for left and right AUDIENCE: Shouldn't you always test for COLTON OGDEN: In case what? AUDIENCE: In case you get a chasm. COLTON OGDEN: In case You're correct. This should actually be falling state and player So the question was, shouldn't you when you're walking? And yes-- not just falling, This one only jumping, this and this one for jumping, Does that make sense-- how we can take the x, y and by just dividing it by 16? And do note the plus 1 as well, are 1 indexed. And so when we divide going to get a 0 indexed coordinate. If our x is at 14, we're But if we divide that by So we need to add 1 to that so that still, which will be So that's how the collision works. It's all implemented in TileMap here. And basically every state that the and then player falling, these are all states They basically do all at the bottom, which is jumping state, falling state, and moving And then in the falling state, And then in jumping state, we That's all done within But the actual transformation that's just a function It's just a utility function. AUDIENCE: What's the COLTON OGDEN: It's called pointToTile. So if you're in TileMap on line 27-- pointToTile(x, y). And the first little that lets you basically without getting a tile index error. So if it's just outside the tile limits, just return nil. And so you can do a to see whether TileMap or not when you do the collision. And if it is, then just But assuming that you're within is where you do that transformation-- because we want to get We don't want to get can't index these tiles as fractional I think you might be able to by a fractional number. But in this case, we just want integers. So we call math.floor on y y divided by TILE_SIZE and then we do the same thing for the x. So that's the operation. And then wherever we want to check for we just call pointToTile on That's the backbone behind all the effectively. Any questions as to how this works? Yes. AUDIENCE: So you're only and not the edge itself? COLTON OGDEN: Correct, because you if you're taking into consideration unless your entity is to check for more than three tiles. In this case, our entity is so we only need to check for If we're doing a left collision, If we're doing a right collision, his left, bottom right for bottom. If you had an entity that you need to check every single just means you need to iterate over And then just offset the y that you're Does that makes sense? OK, cool. All right. I alluded to this briefly I don't know if I alluded so much to But in this distro, we're introduced An entity can be almost In this distro, we're to basically be anything that's in this case, the player or snails. Those are entities, and then An entity is a very abstract thing. You'll see it in a lot of game about how to organize your Unity is probably the of what's called the entity you have everything in your game. Every single thing in and then every entity is And these components It's sort of like if you're familiar If you've heard of this as a that's effectively the same paradigm. Rather than inherit a bunch of let's say you have a base monster class. And then you have a goblin so it inherits from monster. And then you have a goblin and then you have an ancient goblin Rather than have this you adopt composition, which and then you fill it with what the behavior of your object is. So if you have an entity-- let's say you give it And then maybe you also give so it's an ancient monster. And maybe you give it so then it's an ancient monster goblin. And then you give it so it's an ancient So it has all the it is without you having to create That's effectively what the model is versus standard inheritance-- the model of your problem. In this case, we're not going But I wanted to bring which we'll be covering in a few Everything you write in And entities, whether they're in form the backbone of most large games. Most games that have model most of the pieces within and do things. And so in this case, entities And then separate from the tiles-- when we do collision for that-- we want to also check collision So we make sure that the player's because that's the only other But you can have an arbitrary If you collide with an So for entity in pairs of If you're in the jump state, then die. If you're in the fall When you're doing most of your that's generally how you'll model it. You'll just iterate over everything Depending on what just collide everything with everything That's effectively how we do it. We have in the-- I believe it's in GameLevel. This maintains a reference a table full of objects. Objects can be-- we'll talk gems, and blocks, and bushes, and For every entity, we just update it. And then for every object, we update it. And then for every object in And then we render every entity. This is just sort of basic how populate it, and then Just containers, tables that maintain and then just update them. The actual interaction because they're dependent If you look at all the different states entity folder, you'll see, for example, we're iterating over every And notice the player has so that it can access And then within that level, So all it needs to do is just the player and the object is et cetera, et cetera. All this code's actually so I would encourage and just understand how all working between the player, the objects, things like blocks are solid, But that's the gist. Have a collection of And then depending on what state And then depending on the maybe that kills the enemy, maybe you become invincible. Maybe you collide with and that power-up triggers your And then if then maybe you render him And then in any of the functions where he no longer dies, he just kills them. So that's sort of the gist behind and how to process it. Game objects are different. Like I said earlier, these are examples The gems on the bottom left If you hit a block-- and I'll show you really if you hit a block, you'll If you collect the gen-- which means increment your score 100. These are all other objects that I But just off the gate, how do you think we Yeah. AUDIENCE: You would And if the player is touching a they would enter the climb state, COLTON OGDEN: Correct. So what Tony said was if they should go into a climb state. And depending on whether or not, if they press a button, And then you would check. If they're at the top of the go into a walk state. Or if they're at the bottom of And that's just another game and then it's a new state for you. Yes. AUDIENCE: You may actually because that way you could have a ladder it just gives you height. But you could use that COLTON OGDEN: What have the ability to jump off a ladder. Is that what you Said Yeah. The ability to jump off a ladder so That's absolutely true. Actually, in the mock up that we I'll see if I can maybe Mario, Mario, graphics, and The whole entire sheet that I used for I don't know what that is. So if you zoom in really high what you were alluding to-- right here, this little rope thing. I'm guessing for the sake what they were trying to illustrate. But you have a game object that Whether it's a ladder just add a new state for the player. If they're in that climb state, which we saw in the sheet earlier, And then they just climb if they're moving up or down the ladder. And then just give them And then when you get to the And you could think a lot of the same like the spikes here. If you're jumping and you hit And so you would check for if the or whether object.lethal equals true. Same thing with this one. And then some obstacles are completely In the case of the distro, and all those sorts of things so you can walk through them. They don't trigger collision, but They're not part of the tile grid. They don't get processed They're not stored in the y, x. So that's effectively how we and how to give them behavior. Part of the assignment is So this flag is in the sprite sheet. So what you'll do-- and I'll touch on this at We're getting close to it. These keys here actually so part of the assignment will be to-- it's actually right here. So I'll go over it really quickly. Ensure the player always So in this case, when James came up The very first time that it generated a chasm right And so he just falls to Just right off the gate, as to what we could do to check assuming that the player's AUDIENCE: At that tile, If not, then just move it COLTON OGDEN: Yeah. What we probably want to do is because we start towards the top. If we find that there's no tiles we probably want to shift the player. And then random keys and locks-- let me open up LevelMaker so we can because most of what you'll be It does a lot of what we did and then it will insert into objects. So objects is a table here. It will insert a game object So in this case, if we're we have a chance to generate So if math.random(8) is 1, in this So we have an additional chance to generated a pillar-- so basically, I think it's a 1 in 64 to generate a pillar with a bush. You just add a new In this case, this is the You give it an x, y, width, And then the frame is relative to string here. So bushes is the texture, and you want to give it-- in this case, we just gave And then a lot of the same This is another part where we We have a chance to generate a block-- 1 in 10 chance this is a jump block. So here we have texture, Notice that we have is how we can test to see whether Hit is false, meaning that And if we have hit it, then we do this You can see where this gets if we look in Player. Player has check left collisions, and check object collisions. It doesn't have check There is a corner case that the logic had to be duplicated. I forget exactly why. But you basically get a list Oh, the reason why is the collided objects when you trigger the onCollide function. So let's go to PlayerJumpState. If we're in the jump state, check to see if we've gotten any If it's solid, call its onCollide we just pass in the And so if you go back where we write the onCollide function. We write the onCollide function So we just give it an because functions are We can just say onCollide where obj is going to be this object. If it wasn't hit already, one so going to create a gem. It's got all the same stuff in it. In this case, it has its own onConsume takes a player and an object. And then this is all You can create whatever These are callback We're just going to play the pickup And then here, in the event we tween it over the We tween its y to be from so it has an upwards And then we have another But that's effectively how Game objects have textures, you can give them callback execute wherever it's relevant to you. In this case, you'll only really because the assignment is They have to be the same color, If the player collides should probably get some flag or something like that. And then you go to the block so you should spawn a And then on collide, you should and then spawn a new game object-- the flag. And then that flag will And when you collide with And that's effectively the So it probably shouldn't take-- I would say probably maybe 40 or 50 AUDIENCE: That game object-- was that a class? It's not a table. What is that? COLTON OGDEN: It is a class. There's a GameObject class. A game object is basically-- and I In the context of this distro, you In this case, what I've between living things as being entities versus game objects, But for a small project For a large project, I would probably and then give different their own behavior and sort of like how you do with AUDIENCE: Are there two ways one with the curly brackets and COLTON OGDEN: There is, actually. So the question was, is there more whether it's parentheses Yes. I don't think I've ever Let's go back to LevelMaker. If you instantiate a takes in just a table as its only This effectively is that argument table. You don't need parentheses. It's effectively doing this-- same thing, only you don't AUDIENCE: And then that's a COLTON OGDEN: Correct. It's just an alternative on things that only take a they get instantiated. AUDIENCE: And you can only COLTON OGDEN: Correct, yes. AUDIENCE: Wouldn't it be easier would have its own set would create a gem which would in turn create a game object? COLTON OGDEN: Can you AUDIENCE: It's kind of hard to explain. Wouldn't it be easier to would have your gem and everything, would be a game object? But in this class, you would say local gem COLTON OGDEN: The be easier to create a helper class that Possibly. I think if you were going to design and if this were going then you would just create a To shrink the number of files that of consolidate everything together in one spot, I decided to just create you could then just create your constructor-- which is this bit and then allow you to override the You can actually give it You could give this some arbitrary named This is almost like an But I think if I were to engineer this large game, I would just subclass. I would just create a class for gem, et cetera, et cetera. It wasn't strictly so we ended up keeping more abstract in a sense-- a But yeah, you could definitely And if you were in an you could have a consumable component. And then that consumable allow you to give it some sort of the player consumes that object. In this case, a gem is a give it a consumable component and then give it a just increments the player's score. You could probably put that It would be pretty easy. And then blocks would so they have a chance to spawn. And then you would pass in that so it would have a chance to spawn the component-- and then also a solid So if I hit it, I should and not be able to walk through it. So you just layer on these components. I would encourage you to think your objects a little bit, particularly makes a lot of use of this concept. In short, yes. I think that's pretty much everything. Let me just go ahead. We're running out of time here, make sure the player starts above and then make sure that when you get and that spawns the goal. So this is all something you can and it will all work with And then you touch the goal So today, we talked The other big Nintendo arguably one of the greatest So we'll be talking about a very where we just have a random a top down perspective, open chests, blow up We'll talk about triggers and events. And then we'll talk about a very simple GUI for opening so that we can see which doors render appropriately and whatnot. And that's it for Mario. Thanks a lot for coming. I'll see you guys next time.