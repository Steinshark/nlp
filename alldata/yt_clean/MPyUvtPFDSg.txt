Hi, I'm Lars from the GOTO team, and I'm here This is a GOTO Unscripted episode where I'm We're gonna nerd out a little bit about programming say a few words about yourselves? Richard, would you like to go first? Sure. I'm Richard. I work at a company called NoRedInk. We're hiring. I've done a lot of Elm in my career and I'm Publications. I'm also really into Rust and doing a lot making a programming language that complies I've also done a course on frontend masters Thanks, and you, Erik? I work at ThoughtWorks, a consulting company. I work mostly as a consultant, helping clients in new ways, using different programming languages require and as new programming languages appear. Interesting. I wanted to do a fun experiment with you two. At the party keynote that we had last night Mark Rendle design the worst programming language that do horrible, horrible things and taking the worst language he could think of. I was hoping we could do a little bit of the to design your ideal language, what kind of languages would you draw inspiration from? I know, Richard, you are working on your programming of this exercise already. Maybe you want to start. Sure. Well, it's a dangerous place to start because I'll try to keep it constrained to characteristics from. So, first off, the prompt was the ideal language. To me, I don't know that there's such a thing It's more domain-specific. If you're building an operating system, I than if you're building a web server versus Beta systems would be another example. In my career, I mainly did web development, that, at least I can start there. I think if you're doing web development, there's Frontend, I'm really happy with Elm, so I'm the web frontend. I guess the language I'm working on, if it's the server-side. I'm a big fan of really ergonomic type checking. I've definitely used languages that have varying Somewhere it seems it's a net negative, it's rather have dynamic types. Elm has an extremely well-designed type system So, I think that is my ideal. That's definitely something I would take from As far as memory management goes, I think be something I would want, building an operating You probably want direct control over that. Maybe I can just start with those two, just What do you think? I'm in complete agreement about the consultant I don't think you should try to design a language. Part of Mark's keynote was the fun of saying and that is, of course, the first mistake So, I completely agree, it depends on what I think for the memory management, we could automatic reference counting, or what Rust borrow checker. Humans have proven over 20, I don't know, management correctly with all the tools and So yeah, give that to the machine. Types, I'm similarly conflicted. I've written large systems in what is, I learned I noticed from Objective-C, where you can if you want. In a large team, it is often quite good in because it really helps you understand the that you can read the code. Writing is only done once most of the time, help. I guess one aspect that you didn't touch upon programming, which was considered the winner programming, and I think the languages that would draw inspiration from, or would at least very state heavy things that are based on you to do something that is more functional, Gotcha. So, I'm definitely on the functional side I spent the first half of my career doing doing functional programming, and I definitely coming from. But, from my perspective, the thing that I aspect about "let's take things away and And so, since that's part of the appeal, constraining and let's have this be one small set of simple That's my ideal. I'm completely with you. I have a computer science background. I completely agree. I love the elegance. I mentioned it in the talk I did about Rust I was showing in Clojure and I enjoyed that I'm a great fan of LISP-like languages, but programming that appeals to human beings: somewhere, and I think that is hard to get And there's one system we wrote for, or with and the backend is not the backend. The backend is just an adapt to cover some and we thought what better place to use functional what's coming from the real backend to something Javascript frontend. We chose Clojure for it. And people were not so used to it. They were struggling and we gave it about and still, when we then asked the teams in write it in?&quot; The answer was Kotlin. They were, like, &quot;Yeah, they're still out It's a sales system, there's a custom object head and we understand this. We know the patterns.&quot; It was heartbreaking for me to see. That was a place where the client didn't object great area of application. Still, on the whole, the team said the experience But when asked, &quot;Would you do it again,&quot; which we choose Kotlin.&quot; That's interesting. I definitely know people who have stories People who have a similar story where they used to React and TypeScript. They tried Elm and then they didn't like it. They're like, &quot;You know what? I wanna go back.&quot; Or maybe they went with ReScript or some of I guess some people would argue with me about But then, I also know quite a lot of people it, and they're like, &quot;I can never go back.&quot; Actually, a lot of our hiring comes from people I can't go back to...&quot; not Kotlin specifically I need more of this functional stuff in my I wanna go back to something you said though humans like classification. That's kind of a fun activity for us. Something that I was reflecting on somewhat object-oriented programming, and I did spend but I don't think it actually helped me out I spent a lot of time classifying what is What should it be? What should the taxonomy be? What should the hierarchy be? But with regards to what I actually get out it really paid off. So, I agree with the point that as humans, that it should be in the language. Maybe it's a temptation that's better removed. Inheritance is probably a temptation that I mean, you can do object-oriented programming I have seen that. Absolutely. It isn't everything. On an abstract level it's just something, But when you write code, you get these almost There's hardly anything in there and you're I get that. I also remember one of the enterprise Java This was more than 10 years ago, but I think of places. We had a rule on the team that we always build when you need to. So, we always say we're gonna use the list to actually make one, and then you're gonna The thing is we always did exactly that. We always had an exact list for the interface, for the implementation. And then, whenever we're making our classes, had to make an interface first. Then we would always make an interface, and all the methods of that interface and then And I looked back and I think I know the principle swap out the implementation for something But based on how often we did that, which zero times, I think we probably would have know what? Let's just assume we're gonna pay the price have all the interfaces in place. We'll just go through and do the change to I think that would have been much cheaper. This was also not about classification, really Thinking about how we can spend so much time a best practice, and then being like, &quot;But I don't know.&quot; really stuck with me. Good point. That brings me to testability. That really should be in the language. Why am I thinking that? Because historically, one of the drivers for testability. Remember about 10, 15 years ago, dependency People sometimes did this and said, &quot;Okay, because then in the test, you only have the You can't instantiate it. Or in your code, you can't instantiate an And then, you force the teams to use dependency So, there were some other motivations behind I'm noticing again when you do unit testing, I've actually written a mock object framework people asked me, &quot;Can you make the Swift version?&quot; I said, &quot;No, I can't because I don't even There's just no way that I can do all the Objective-C. But, that means then, the interface can step away and you can do things in your I think that's a great point about testability and say that, to me, you might as well plan Historically, it seems like most languages a language design, and then there are these do sooner or later. But for some reason it's always considered though you know it's gonna happen. Someone's gonna write a test framework. There's gonna be a package manager and now assume there's gonna be a formatter that's I think Go started that but, I mean, plenty And so, at that point, if you know this is it seems like you should just design for it. You could do a better job or make it more it. And yeah, testing is definitely a big one. And this is something we see with Rust, for They put the package manager into the language. I mean, not the programming language, but There's no way to do Rust without the package They put the unit test actually into the same through. That's an inspiration to take from it. I mean, it should be testable. I think in this day in age, we really have tests because we know that we are writing for a while. We talk about shifting away from project to for a while and if you don't write tests, They're definitely indispensable, can't do Okay. I wanna go back to memory management for a And so, I think we agree that, at least for solving, we probably wanna go automatic memory But, there are a couple of different ways You mentioned automatic reference counting just freeing allocating things on the fly. And then, you have the most popular, which Of those three, to me, tracing garbage collection most popular, just because you have GC pauses. And I know that JVM and Go have spent a lot latency and all that stuff. But, it still seems like at the end of the problem if you can do automatic reference like Rust does. But, then there's always the question of latency have the highest throughput over a given period and so forth. But, I'm also aware of some research and this on, we're going down the automatic reference But, you can do stuff like compiler time reference going to be an increment here, a decrement Those will just cancel each other out so we're It's hard to say in practice. The language is called Roc, R-O-C, roc-lang.org. And we haven't gotten any big enough projects very early stages kind of thing. But so far, it seems like the frequency with these techniques that we learned to do this a lot of the reference counts can be alighted, And my impression was also the tracing garbage I mean, there's a lot of theory behind it, You have long pauses, but in some cases, it And I think it is exactly like you said. The research has gone further now, so understanding or this concept, but they were the first ones And I think what we're seeing now is a lot middle between no memory management and the like, a blunt tool, if you will, right? You know they work and you can't make mistakes, and I think we will see more and more successful On the performance, I'm curious. I know all the theory in Java about the different thrown away. Again, if you're writing websites, probably moment in time to create the response. You can throw them away. You don't get heat fragmentation like you can compact the heap. I think there's room for implementation and for the programmers, they will be happy if I mean if you can't tell where they're using reference content or something similar, as And they probably choose the language based have to use a tracing garbage collector, it's Yeah, yeah. Two interesting areas of research around that. First Compacting. There was a really cool talk at Strange Loop Uncompactable. And it was basically about how they designed can do compacting. Really impressive stuff and they were using Of course, an automatic reference counting And then throughput of automatic reference Apparently, Apple is, because Swift does automatic at the hardware level, making that faster what it was. It was some sort of either a new CPU instruction atomic reference counts to make them faster. And that's definitely an interesting sign think about it, you have this big company Swift as a language, but also in making their That's the type of thing that can influence with what Apple's doing. And so, if Apple's making hardware-level optimizations tracing GC, or I don't really know what that potential thing to keep in mind that even improvements, even if the software algorithms And Apple is motivated. I mean, they have tried garbage collectors, They tried to have a garbage collector for for their use case, it didn't work. So, they are very, very motivated to make by all means, it generally works. I mean, there are probably slightly more cases and holding on to each other. You can still create the same program with just have a static variable somewhere in there I think they will make it work. And like you said, I mean if they can reduce there's very little that stands in the way Yeah, interesting note about cyclical dependencies. This was one of the reasons that we decided Roc is a pure functional language and it's express mutation in the language, there's So, we don't have to worry about that at all. But, that's unusual. Only if you've subtracted that much from the What kind of concurrency model do you think that doesn't exist? Hmm, I don't think I can explain that in the tangent. I come from Elixir, and I think that has a It's sort of building upon the past in the and Erlang was building for the telecom systems. When you're on a phone call, it should be going through that cell tower, not that cell In a sense, it's very good for distributed it's incredibly easy to write concurrent code. It's all built-in. It's sort of by default. You don't really have to think too much about Running a piece of code on this computer versus world over the internet is extremely similar You don't have to jump through a lot of hoops The beam takes care of it all, as long as the same cluster, it's a matter of just telling, And then, it does that. And I think that's a really powerful model. Yeah, so I think Erlang's an interesting example concurrency model that it has. Personally, I have not actually written a from reading up about it and talking to people system. And so, you can pass messages between different, is, I don't want to say threads because they you know, thread-like things perhaps. And then, basically, the message queues are it's all immutable, you don't have to worry that. That makes a lot of sense for a lot of use who's thinking about concurrency in the context they're a lot more concerned with A, single-threaded They probably actually want to do mutations And even though that's a more error-prone they're probably a lot more concerned with So, I think again, it kinda goes back down So, if you're focusing on distributed systems great model for concurrency. I guess it depends on what your ideal language Yeah, I guess it's all a tradeoff, right? Yeah. I think I agree with the idea of having, in which makes it easy to shift data from one To build that in Rust is something similar, I think though sometimes this parallel programming I mean, we don't see these massively parallel 20 years ago. We're seeing more cores now. We're seeing 20, 30, maybe even 60 cores, Like you said, in video games and so on, for that does one task and needs to utilize all Maybe on the graphics card end, but not for So, what we often find is that you need parallel are servicing multiple parallel requests, If you have a web server and you have a thousand the question is should you do that from a But, if you have a thousand threads, then They just shouldn't get in their way. You should have something to make the threads But, to have this thing where all the threads this in the Rust talk, in the simulation, multiple threads because the communication became completely background noise in all it didn't get a speed up. Interestingly, so one form of parallelism data parallelism on the CPU, like, SIMD. It seems like there actually have been a lot several 100% faster than other JSON, like don't use SIMD. But the algorithms are completely different. I started reading the paper on that and it it's just so completely different what they're But it runs way faster because they can do At least currently, they're really good language-level I don't even know how you would design an &quot;Well, maybe the optimizer can recognize that I would love to steal something from a language of concurrency is really great for servers. Is there some similar thing for expressing way so you don't have to get as low level I'm not aware of it. Maybe someone will come up with it, but I You both seem excited about Rust right now, on the horizon that are up and coming, very Absolutely. I've just heard about one, Roc. I wasn't gonna say Roc. I was gonna say Zig. Okay. I haven't heard about Zig. What's that about? Zig is, I would say approaching the same problem different angle. We actually use Zig and Roc for the standard So, the standard library in Roc is implemented I think if I were to pitch Zig, the way that take C and keep the simplicity and the sort Let's add ergonomics on top of it but without But, Rust is like, "Let's try to make a amount of complexity is acceptable as long about memory safety. If it compiles, it's probably gonna work, So, Zig is definitely less on the side of and especially in terms of speed for the developer. The Zip compiler runs super, super fast. The Rust compiler is extremely not. I mean, that's my number one, number two, six complaints about Rust is compile times. How long will I spend waiting for it. Not the case with Zig. It's really fast. They're working on hot code loading for C-like And Zig also cross compiles anything. So on my Mac, I can compile a Linux binary You know, I don't even have to spit up a VM. There are just all these little things that make a Venn diagram, it's like, both of them and things like this. Zig does not have the borrow checker, so it safety, which I definitely very much value But, whenever I'm sitting there waiting for gonna build Roc for Windows and Linux and it be nice if I could just actually cross-compile So, you know, as an up-and-coming language see a really strong appeal. Personally, my prediction is that Zig will of people making games because I think if have to do a lot of memory unsafe stuff anyway. This is my impression as someone who does But, it seems like just to squeeze every last something like that. I'd imagine if you were writing Rust, you're it's like, &quot;Well, why don't we get all these Especially games have a reputation for crunch a compiler, it really kinda adds up. But I don't know. Time will tell. That sounds interesting. I'll keep an eye out for that. What about you, Erik? Do you have any up-and-coming languages you're Curiously not really, to be honest with you. I mean, at ThoughtWorks, a consulting company, the enterprise space, consumer-facing websites, In this part of our culture, we really look We're always trying to find new things. I mentioned this system that we were beginning And we've tracked a lot of different programming About 5, 10 years ago, there was this wave a lot of excitement, but from our perspective, I mean in the web browser at the moment, there's, that's what you use. And on the server-side, as I mentioned, Kotlin compromise. It probably doesn't win in any category, but That said, I am curious to see what will happen I mean I'm telling no secret, I'm not a great I think we even had talks here at GOTO Conference, of JavaScript said they probably would have been pushed to do it in a very short amount And we're still settled with it. Even in JavaScript, you do see this move towards even big frameworks like React are moving JavaScript. And there are reasons for all the jokes about was featured quite heavily also in the party So, I've been waiting for a proper replacement that successful, I think. I mean Dart is sometimes mentioned, but I different web browsers. I'm curious to see what will happen with WebAssembly will emerge to write web applications, not but something to replace what we currently I'm looking forward to that. Yeah. I think WebAssembly is really interesting if you wanted to run something in the browser, I guess we're getting close to the point where the community supports it and builds the tooling So, that's going to be interesting to see Yeah, we've had first engagements with clients implementation of C# and the corresponding I mean, it still has first load times you But, I mean, that is a first promising sign, programming language that, I'm talking about And Elm cross compiles to JavaScript, right? Correct, yeah. Or compiles to JavaScript. Yeah. It's theoretically possible that Elm could does compile to WebAssembly. If I were to make a bet, I would bet that much when it comes to web applications, at Maybe it's hard to predict further than that. I think it's mainly just gonna be games, to A lot of thoughts about why, but one of the care that much about performance in web applications. I think it's sort of close enough. And one of the reasons I think this is the &quot;Hey, look, we're faster than all these JavaScript sizes.&quot; There was this real-world app which was 4,000 not an entire but you know. It's a substantial application that does a Compiled, , that entire application is smaller Evan spent a lot of time making really small got to decrease our bundle sizes.&quot; Nobody cared. And then Evan did a bunch of work optimizing It's like, &quot;Look, we're faster than React And again, people are like, &quot;Okay, that's The idea that, &quot;Oh, well, now that we have than that on performance,&quot; I don't think that's I do think there is definitely a potential you want." You can use C#. But the thing is, we've already had stuff I know one team that's ever used Scala JS, the backend. So, is that really the issue? Is it the lack of speed in the frontend? There was GHCJS for Haskell, which I guess But, I guess it seems to me that that has thing, and I'm a little bit skeptical that compile to something closer to machine code, I think it's just really that JavaScript and And if we look at what's been successful in JavaScript, CoffeeScript, whose tagline was, tagline is just, &quot;It's just JavaScript.&quot; And that's it. Those are the three big success stories and the most popular widely used compiler to JavaScript to the state of JS survey, but it's very, So, I think the real issue here is just that momentum and all this drive to do that, that it still takes something more than WebAssembly I get what you mean. By the way, I don't think CoffeeScript is even. Not anymore. I mean, I agree with you on websites, where website or banking website and so on, what I mean, the one I mentioned earlier is a sales thousands of them and it's downloaded in the iPads or Windows machines. I think there, this is probably no coincidence, that we are seeing making use of WebAssembly. I think there's still a ton of developers used in-house. And they have so far tried React. And React has a steep learning curve and then Angular,&quot; and then they go, &quot;Oh, which one And they'll say, &quot;No, no, forget about this. Let's use Vue.&quot; And they're a bit confused about this. Also JavaScript is not a productive programming at least my prediction, is that big companies And I think C# is already spreading more on You can run it on operating systems other can stay within one ecosystem will put some I think performance is a hygiene factor. It can't be slow in the web browser, but I &quot;We are faster than the most optimized Javascript.&quot; But if it's fast enough then you have a different libraries. We can write C#, which is a better language. You can use it on the server. You can use it in the browser,&quot; because frankly, People say, &quot;Oh, we all know JavaScript. We run it in the web browser and therefore, and that really has some really terrible consequences, from security and so on. So, I think maybe you get different dimensions large organizations that will jump on that But I agree. If I were a startup that builds a B2C website, You make a great point. Yeah. I was surprised there's this sort of, like, teams. I talked to a guy who's an Angular consultant. I was like, &quot;Where are all the Angular apps? Everybody I talk to does React. That's it. It's all React.&quot; And whenever people are coming to Elm, they're And because I'm in, like you said, the B2C no, all of my consultances are 400-person inside the company.&quot; And I had no idea that there were so many You would know it much better than I would, That's a really interesting perspective. I hadn't thought of that. Well, thank you so much for spending some It's been a lot of fun. I feel like we could have gone on for much, But, it's been a pleasure hosting you. I hope you enjoyed it. Yeah. Thanks. Thank you.