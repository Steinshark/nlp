My name is Tess. I work on the engineering team at a company The title of this talk as on the agenda is but I have to tell you that that is like a version of this title for this talk. A more realistic title might be macaroons, That takes us into this. What is a macaroon? Macaroons are a relatively new kind of authorization a group of Google engineers/researchers wrote Last fall, so the fall of 2017, the engineering February we decided we needed to get rid of So it was just like a few months living with with mag macaroons. Let's talk about one of the problems of off who you are. Between these two questions you should determine This is probably, sort of a mundane framing, On just about every project I worked on we same way. This is what we are doing at Chain in spring In this world, when a request came in we would fields and check that username and password If the request passed authentication we would then move on to authorization check where do this. We set each route up with a policy like read to operate within each policy. When a request came in, we checked the policy this user permission by checking that token In other words, we setup this set of access I thought this was just kind of the way auth If you wanted to authenticate someone against there is a whole long history of folks struggling this. That conversation shook out to two separate One relied on capabilities, which is directly action, and the other relied on identity asking are allowed to do that thing. That is a little bit abstract so let me give the authors of the macaroons paper. Let's use this car. Pretty drivable and you might ask how can One way to handle this is to create a key Anyone who has the key, regardless of who This is an example of a capability-based system. Now, if instead the car had an identity base This red car can be our identity car. This car has to be programmed to ask potential them up, maybe through a central driver identity it will start. Okay. Let's extend this metaphor and imagine our which is why he has a suit on. He want the valet to park the car. If this is capability-based car he can hand can run off with the car or if he loses the a token that has complete power. Now, if on the other hand, this is an identity-based information into the car, again using official party. Then after that, the valet will be allowed This isn't great for a couple reasons. One reason obviously is that everyone needs Relying on identity can be dangerous in any is relying on identity can be dangerous in or two different services. That problem is outlined thoroughly in a paper model is unable to make accurate decisions The paper describes the way this happens also. Basically, if there is a restricted action, action, it is possible for the deputy to get another actor who doesn't have that authority problem. That framing is also a little bit abstract what that looks like in practice which is Let's say Bob's cryptocurrency is trying to It will transfer 100 Bob coins from Bob to unless Bob authorized it with credentials. But if Alice can get Bob to load this, his credentials to this malicious URL. The safest way to prevent this kind of attack that to be passed along with each request. This way, Alice can't create a valid request That is interesting because this per-session We have this identity system but we can gain What if there was a middle ground? A bear token like our car key. Imagine the car key could be attenuated or This is like if our Emoji friend could hand but would work within a one-mile radius, or uniform which he has now put on, or another This is how macaroons work. They are bare tokens but their power is limited. One of the neat things about them is as far cookies. To real stretch the car meta ' -- metaphor, This drew us to macaroons. They are designed in this really pragmatic How do they do it? What are the mechanics of a macaroon? I want to step back and talk about the mechanics auth ideas to show how we make macaroons. When you make a request using basic auth, them in the request authorization field and library. Set basic auth request and it works. It is simple, stable and really easy to use, In particular, I want to call out two issues. The first issue is that the username and password somewhere indefinitely typically in a cookie. This is kind of scary because cookies can attacker gets ahold of the credentials, the The second issue is basic auth uses the authorization of authentication so in order to limit what some kind of access control logic and this I talked about. Let's address those concerns at one time. First the danger of passing a username and Instead of passing those two things all the This token is just a random string and when has to maintain a map of tokens to users so This is more or less what I showed before There is a more sophisticated way of doing HMAC is a key match authentication code and This is a sample of how you do it. Generating it and checking it. Not a lot of extra stuff there. You might say what is going on under the hood? This can be described in an easy to understand standard library, which is okay, only a little to note are the new function takes another hash function under the hood and it also takes The return value is a hash. This behaves like any other hash function you pass it. Most of the other parts of this code, this of this package, most of the rest of this sure it can accept input of arbitrary lengths The most important thing to note is these There is no standard way of doing auth and -- not like a common solution but a good stepping This involves storing a single secret key key and using the user's username as the message. Those two things are the input to an H map. This doesn't need to be stored, instead it And like all hashes, and no one can generate stays on the server. The username, along with this HMAC token, submitted on every request. Tokens and HMACs do make auth easier but only A server using token auth still has to check Macaroons have a way of baking the authorization adding layers to cookies. If we start with that same cookie from before, we want to limit this to read-only. We can create a new caveat, for example, the In the new HMAC the caveat is the message The result of this new HMAC becomes the credential This is fairly cute, I think, but what does Well, this is an example from the chain codebase In this example, teach team gets its own macaroon. The important things to notice are we first a caveat that limits this macaroon's power You might notice we encode this as a protocol protocol for caveat. This is all also made possible by the Go macaroons What is going on in that package? This is what a macaroon looks like under the The location is a hint that tells us where We left this blanket chain because we only a unique identifier and the caveats are a So you can have many, many caveats for each The signature is important because it is the The signature is updated every time we add Adding a caveat happens like this. You can see the signature getting updated signature from the old HMAC is getting passed If we dig in, you can see the key, which is to set-up a new HMAC. How is this used in a request? The entity making the request can pass this is valid by recalculating the hashes starting There is a couple things going on in this First you should ignore this grayed out section We just getting the macaroon out of the request the server secret key. For us, by far the trickiest part of setting which I made small and truncated because it This returns a function that can be called caveat for any given macaroon. Significantly that is not the same thing as It just knows the ways any given macaroon The sever -- the server will never need to the token itself. If you had your binoculars out you might notice One of the cool things about macaroons, maybe a macaroon, not just the target services. Any caveat that is added by someone other caveat. The classic example is identity service. Let's say I want to share vacation pictures users so I might use Google and as long as she can also access the pictures. These third-party caveats are added the same The third party needs to have knowledge of ID so it knows to satisfy or discharge it. The other twist, with the third-party caveat, In order to verify the macaroon with this has to be discharged by another macaroon which comes from the third party itself. My sister might fetch the discharge macaroon macaroon to the target service. Although the target service can fetch the These kinds of gymnastics start to look a out. We got really excited about it at Chain because we have. To dig into that, I have tell you what we Chain is a blockchain company and the main Sequence is a blockchain service and come what that is. Sequence hosts many independent private blockchains each server. The relevant part of the architecture looks Two services makeup the core of the product. The first is ledger D which is written in with the main data store and provides the That is like the core product. Then we also have dashboard which is a rails users and critically also does all the user Dashboard is the app that knows about user, When a customer uses sequence, they often talks to ledger direct playoff. Maybe you start to see the off problem here. Who owns off? Dashboard is the only service that knows about Dashboard needs to make auth decisions about is ripe for a confused deputy. Macaroons are perfect for un-confusing a deputy. And we were excited because we imagined a ledgers and organizations and macaroons seemed although we had not designed that use-case Regardless, we dove right in to swapping out Swapping in the macaroons was painless and We decided to have ledger d which ultimately Ledger d meant each team and all-powerful it would hand the golden macaroon to dashboard a green macaroon. We used the term golden macaroon, though, Dashboard would attenuate this macaroon to It would then share it with the end user who When a client application made an APR request And because there was a third party from dashboard alongside the main macaroon. The discharge macaroon would be valid for Our SDKs handled that behind the scenes so a new one periodically. We were pleased we managed to isolate the communicated that inside ledger d but this you know something is coming. Macaroons; the bad parts. One problem was that we just created an availability If dashboard went down and couldn't produce to access the whole API. This is scary since we expected the Go API app. It was very cumbersome to access the API so API every five minutes and provide that alongside Prior to macaroons it was trivial to run locally that most people stopped with noticeable effect Another problem was we let users have rolls role the token stayed the same so the permissions This is confusing to users and occasionally a problem with the way we modeled this. Maybe the concept of a role is not compatible. And revoking a credential took up to five If we wanted to revoke a macaroon, we needed macaroons but any given macaroon was given back. We ultimately solved this problem by making way, which like kind of defeats the whole Revocation is really hard but macaroons did There are a few minor usability issues. Our macaroons were too long to fit on a single and they included characters that were like When you double clicked on a macaroon you they were so long you didn't know you didn't This thing smalls but leads to a lot of suffering, And then finally, the biggest problem, probably turned out to be contentious. It is a cookie with layer but in a bakery, the authors tried to address this saying they were not convinced and we lost hours of developing At this point you might be thinking wow, I like I had the rug pulled out from underneath I know how that feels and my whole engineering We added the macaroons in October and by January By the end of February we decided to remove or what I like to call pumpkin spice auth issues macaroon had. It turned out removing macaroons was way harder We didn't want to break our users so we built This turned out to be impossible because no We could not just do a database migration. The best thing we could do was wait for the it, or its hash, as a new pumpkin spice token that validates macaroons, which is happening recently is going to get locked out so that We gave people about five months. At this point, you are probably thinking this I think we had a bad use case for them. Some of the pitfalls were situational. If you were using a third-party caveat for app you would probably not worry about that And all the literature around macaroons uses be why. With this sparse pair of services, we don't deputy as we might have if he had more services. We were solving problems we had not seen yet right? Even if you have the perfect macaroons-use for them. They are just not commonly used. The caveat format is not specified and not There is a decent amount of literature describing while. My team found we could not do too many experiments We were already doing a few technology experiments in the end. Maybe one of the best auth obstructions I If your team finds itself itching to blaze really like to hear from you and hear how If you find your taste buds tantalized, here And thank you so much.