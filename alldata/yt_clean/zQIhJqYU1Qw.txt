LiveStore is a client-centric, local first data layer I'm thrilled to be the first to tell you and how you can integrate it with Expo local first native apps. In this video, I'll cover a quick intro Then we'll dive into LiveStore details and without a sync engine. Finally, I'll show you a demo app showcasing some of the advantages as well as a powerful LiveStore So what is local first? The term local first was first coined First Software by their Research Lab: but the ideas behind it It's the architecture that power apps like linear, And according to Martin Kleppmann one of the authors of the local the availability of another computer In other words, and write directly from a database, when you are connected to the internet, and available on any of your devices Local first architecture is well-suited as popularized by Figma, and here we have that you can achieve Now, you might be wondering, a local first application? Well, that's a great question. Building a local first It involves That means we need offline support, requires a database on the device itself. But then and update the UI in real time On top of that, we need to think carefully especially if we want to sync This requires a robust data structure, enough to support adding fields It can quickly feel overwhelming real time updates, and data syncing, But that's exactly where LiveStore steps Schickling who in the past also founded a modern local He has dedicated years of research first He's also the host of local first which I highly recommend listening to. So what can LiveStore do for you? Reactive and persistent SQLite. Like I mentioned before, you need to update the UI, and give it a sync So lives are makes that very easy it's also very high performance. TypeScript is a must have nowadays LiveStore comes with a powerful type saved schema, premium Let's see how LiveStore works. As you can see here Use Query and Use store. So you can simply define a query like for example select all from views. And then once you have these query, you can use it with the use query passing And voila, you have it to use and If we start adding more items this query is going to be updating So we don't need to do anything else. Now in this example But we can also do that. Another thing to notice here is that everything is going to be stored We will be storing everything we will have an extra database that is The event history is useful of the application, Also, by the way, we have and this to do its showcasing To create a mutation, using the hook, use store And then from our mutations passing data id as parameter. Once we update A to do these will also trigger or the component and then every single change that we are history database as well in the database Now let's see how this would look. Once we connect async engine back end. So in this case So in the client everything is going But the sync engine to track the changes and sync this state So client A, B, and C will work with the sync engine, and the sync engine of resolving and updating the state, and then sync that back to the client Now it's worth mentioning that having async engine but as soon as it's ready, All right. Now All right. And as you can see here on the right So let's go ahead and open it okay. And here we have the app. So the first state that we can see But if I go to my second screen So in this case I will generate ten users to each of them, 50 issues for Beto (me!) And just like that we have 100 items. So we're quickly Now let's just see what we can do here. We can go to the create a tab assign tab. And also we can apply some filters By the way this is compatible And we can also navigate to each item So this is the app. This is how it looks. One thing that I really want you guys to notice is that each time or opening these and start priority, all this is being fetched Now, if I go ahead and reload the we're going to see that Now typically in local first apps, often a long one, This occurs because on the initial load, However, once the data is stored locally, That's why the queries are very fast and we are just querying directly All right. So the first thing that I want to show So when we are using LiveStore And the way we do that is by importing So this is how it looks. I will show you just these tables And then we can show the ones above. In this case I have a user table dot table, the name of the table As I mentioned previously, So we need to define the type of data In this case id name email. All these are going to be text. But for each property like the primary key Or maybe you can also want to define You can do that as well. Here we have the issues table and it's In this case we're using some integers So fairly simple. And if I scroll all the way down we are exporting the type So in this case I have all these tables that I can use it across my application. Then if I keep scrolling down, basically creating an object And then we call this make schema function passing the tables, mutation So let's see how the mutations look. On the left inside my schema folder And this is great because we can decouple all the mutations that we're going In this case I'm defining a create user. I also have a delete user. And as you can see for inserting user And we are defining the type of data creating a user and we're using effect This is how we can delete a user. We pass the name of the mutation. We defined the structure. So to delete a user, we just need the id And then we delete it So once we have our mutations defined and pass the mutations in here. And that's it. Then we can use the schema. By the way notice that I'm also exporting Now the next step is going to be So if I go to my layout and scroll down, you can see that I'm using a LiveStore This is necessary so that we have access to all the queries These provide And it also comes with really cool which actually gets the progress So I'm just rendering this state And then we also have these render error, If we have an issue And I'm just displaying it as it is now. Render shutdown. It's a property And this is going to be called mostly And we're going But basically the only thing that this is so that we refresh the application Now we also have an adapter. This adapter is necessary for the DevTools Batch update. It's coming from React Native Another important thing and I think it's really cool and if I come down here property, it's going to be called And this is great because this is the time And we can use this function So in this case I'm just checking first And I'm also checking And if we don't have any users And for my mutations Everything is going to be fully typed So you can see that we get autocomplete because the mutation So that's why the first time that logging And if you're going to play around you can come here and switch the user. Now before I jump into the queries, definitions can be removed and mutation schema as long as the changes are forward which means you cannot delete, If you already have data, you can simply But deleting items, it's And also the new items that you add because the previous items that we had Okay, just something to keep in mind. Let's So to show you the queries which basically what we're doing here we are navigating to this But we are passing And we are fetching these details right on the screen. So I'm using this query. And this is how you can structure basically we use a querySQL And then we pass our plain So in this case I'm passing Then we define the schema. So in this case I'm using effect. And this is pretty powerful because this So what I'm doing here is just typing with the type of the issues. So this is how it looks. And then I'm just getting the first item And this schema And if you want to learn you can just go to their documentation. And in this case I'm making this, query. And every time that the issue ID changes, we're going to generate again Of course, then we can use this query Or we can also use the use query hook I can just type for example issue dot. And you see that I have access to all So let's go ahead and delete that. Now just to show you, we can simply access the properties And this is what I'm doing in here. Now let's And let's go back to the home screen. I want to mention, queries that, for example, in this case Right. So this is like an advanced feature a set of conditions. And it's like having an if statement So you don't have to have any JavaScript. This is directly been And I'm using this powerful feature So when I come to my application and stuff or by status, and go back to the created or assignee, you can see that everything, Every time that I switch these properties, I can only show and everything is being handled So all these complexity that you can see that I switch between, So once we have this, piece of the query, a piece of the query, I can come down here This is like the very complex query on top of my get ordering options, the current ordering that the user wants you know, forming this very complex selecting items from the users table And on top of that, I'm saying that I just And you might be wondering, So when you are dealing with local first deleting items because this can cause issues when we are And also it's a good practice Right? So in this case, by the way, But if I come here and delete this issue, you can see that it says deleted So that means that I won't see this issue But the issues still exist. The only difference is that it's deleted. And maybe that maybe so I can undo and delete again. So this is great. And we can, you know, still have this issue in memory for a long period of time and then maybe So doing this, it's And and actually when you delete something But it's just delete it which is a good feature. Now to finish talking about the queries, across the entire application, or when I filter, something, everything, So I'm not using Usestate. And it's actually recommended and the app data, This unlocks many possibilities for example, if I go here and start and let's say that I didn't So they change because I'm handling Every time that I change something, it's So I don't need to care I can just simply say if the user type We can extend this to inputs, user settings, and even navigation. And this is really cool. So for example, let's say that And then somehow I don't know, my app died And if I reload the application, you can see that we are going to restored And I'm not just reloading here, and close the entire application it's going to take me where I was, okay? And if we wait for a second, you can see This is huge. I think this is a better user experience. And for example, let's say that you were And just this means everything Now in some cases, I don't know, mouse position it can make sense to keep the version but in most cases I would recommend Now, on top of that, let's say that the user was typing something here If we were to have async engine, on an Android device, for example, going to be taken to the exact same screen and the user can continue Now, just as a final note, for queries that return many rows, usually both via paginated and virtualized Okay, how to mutate data, how Now let's see the fun part in my opinion, So the DevTools because it makes developing So to open the DevTools, and press shift M, as you can see here This will show you this menu. And at the bottom So if I press enter And this is how LiveStore So on the left I have all my tables. So as you can see reactions and I can quickly click on each one of them and see all the data On top of exploding data and actually we can simply come here and I'll do that in a moment. I want to, also talk a little bit This tab is going to show you active So for example the query that I'm using it's one that is user count. So the user count for example, this query is going to be listening So if I go ahead and delete an issue, Even if I don't, this is going to be updated. This is useful sometimes or otherwise. You can use usescoped query if you don't But as soon as I change you can see that The assigned issues are assigned query, Now we are using issues And this is going to be preserved as well. So for example if I leave my application In the created tab and reload. Once we come back to application, As you can see there, DevTools So in this case But this is great for debugging, especially if you are dealing You can come here And maybe you can, consider using Now I want to show you So instead of the leading everything If we just go to the general tab. And from here Now we get this state and we can reload now, very amazing, is that we can actually just import And in this case, for example, So I hope you can see there. But I have two databases So it has I think 3 or 4 issues. So let's go ahead and open this database. Now on the right you can see the LiveStore And suddenly I have the same state I think this feature is huge. Have you ever struggled Well, that's no longer a problem user database and recreate the exact state Now, you can also do this manually. Now to show you Let's just go ahead and create And we have 50 And this So I can just come here And if I reload the data should be gone. Okay. The data is gone. But these two databases are recreated. So if you want to do this and drop a database that you already have. In this case, these two contain I can simply just copy the LiveStore here and come here, So I'll just rename with this name and delete. Delete this one. Rename. And you can do the same with the mutation But at this point I can just come here And it should be able to grab this data So now we effectively have the same state So we can do that from the file system. Or it's very easy All right. So I close this iPhone SE and let's I also want to show So this tab will show you everything. And this is actually everything every single detail So when I switch something, and you can see here each time that I pressed a key or I typed a letter, a new event was created And this log can be quite extensive since such as typing input fields, navigating AnotherI cool thing, by the way, to the data browser, select to the right, I can change this And as soon as I press enter, actually the database, my application, it's updating So as soon as I press enter on the simulator. Now that we are here, And the app is a table So for example select the tab You can see that If I keep scrolling down, you can see that So in this case I'm on the created tab. But let's come here Hit enter okay. And let's come here. And we can play around This is great. Imagine if we already had the sync engine. And I want to and I want to educate my user you can assign or if you want to navigate to a specific to the navigation. So for example, if I want to navigate Now I in this case only checking the navigation But it's going to take me to the inbox. And let's also say that that he opens so we can say And now the next time that the We open the filter settings. And from here I think this is very powerful We also have signals, signals. It's great to check how many updates So for example, and we can also get real So if I come to the app you can see that This step is an excellent tool It displays a number of updates for each query and updates dynamically We also have these SQLite tab. So basically we have everything And from here we can use the app database So for example if I run this one you know, all the data that we have with this query before So these and many more things that I'm super excited about and allows input the navigation, and also replicating the exact same state And that brings us to the end of this centric local first data layer I hope you now have a better understanding so powerful, and how LiveStore enables native apps with ease. To recap, we explored the key We dive into how LiveStore works And finally, we wrapped up with a demo a local first application make debugging Thank you for joining me on this journey. I'm excited to see how you use LiveStore If you have any questions, or check out the documentation to dive Don't forget to like, share and subscribe Until next time, happy coding!