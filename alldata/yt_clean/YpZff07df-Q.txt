on September 8th one version 1.0 was released creating a buzz in the JavaScript Community you might be wondering what is bun why was it developed and why are comparisons being drawn with node.js in this video we will dive into one explore its features and see how it compares to node.js timestamps are provided so please feel free to jump to the section you're more interested in so what is bun bun is a super fast all-in-one toolkit for JavaScript and typescript apps the beauty of bun lies in its ability to streamline the development process making it smoother and more efficient this is possible because one is not just a runtime it's also a package manager a bundler and a test Runner imagine having a Swiss army knife for JavaScript development that's one for you but why was bun created the Inception of node.js in 2009 was groundbreaking but as it expanded its complexity grew consider it like a city as it grows traffic congestion can become an issue one aims to be the new infrastructure that alleviates this congestion making things run smoother and faster it's not about Reinventing the wheel but refining it ensuring we get the speed and simplicity without losing the essence of what makes JavaScript unique and Powerful but what about Dino when discussing the evolution of JavaScript runtimes it is hard to overlook Dino Ryan Dahl the creator of node.js introduced Dino as a new runtime that aimed to address some of the challenges and regrets he identified with node.js Dino is a secure runtime for JavaScript and typescript addressing many of nodes shortcomings however its adoption hasn't matched that of notes so this video will focus on contrasting one with node.js let's get started by making sure we have a node and a bun project to work with in one vs code window we have a folder called node playground here we will create another folder called Node 1 and navigate inside we will run the command npm init Dash y to create a package.json file with defaults we will also create index.js where we will write our node.js code in the terminal run node index.js and we see Hello node being logged similarly in the second vs code window I have a folder called bun playground here we will create a new folder called one one now we get inside and run the command one init Dash y this will scaffold an empty plot check the command generates a few files and in index.ts we already have a console log statement in the terminal run the command 1 index.ts to see Hello VR1 logged both are projects are set up and ready for more code Snippets let's now dive into comparing one with node.js our first topic is bun versus node.js as a JavaScript runtime a JavaScript runtime is an environment which provides all the necessary components in order to use and run a JavaScript program both node and one are run times node.js is primarily written in C plus plus whereas one is written with a low level general purpose programming language called Sig but that is just the tip of the iceberg let's take a look at other differences when treating one as a runtime alone the first subtopic is Javascript engine a JavaScript engine is a program that converts JavaScript code rewrite into machine code that allows a computer to perform specific tasks while node uses Google's weird engine that powers Chrome browser bun uses JavaScript core which is an open source JavaScript engine developed by Apple for Safari V8 and JavaScript core have different architectures and optimization strategies JavaScript core prioritizes faster start times and reduced memory usage with a slightly slower execution time on the other hand V8 prioritizes fast execution with more runtime optimization which may lead to more memory usage this makes one fast starting up to four times faster than node.js the second sub-topic is transpiler while node.js is a powerful runtime for JavaScript it doesn't natively support typescript files in our node playground in a new folder node 2 run npm init Dash y create a file index.ts within the file let's define an add function it accepts two parameters A and B of type number and returns their sum as a number we call the function and log the sum value to the console in the terminal run node index.ts and we see an error to execute typescript in a node environment external dependencies are required one common approach is to use a build step to transpile typescript into JavaScript and then run the resulting JavaScript code let me show you a basic setup that uses the TS node package in the terminal npm install as a Dev dependency typescript and TS node in package.json you can set up a new script start TS node index.ts with this script in place you can run your typescript file with node.js using the command npm start we see the sum of five plus three a in contrast to node.js one offers a more streamlined approach it comes with a JavaScript trans filer integrated into the runtime this allows you to directly run JS TS jsx and TSX files once built-in transpiler seamlessly converts these files to vanilla JavaScript facilitating immediate execution without additional steps in the one playground create one two navigate inside and then run one init Dash y in index.ts paste the theme function and run one index.ts we see the same output e the difference in speed between node.js and one is magnified when running a typescript file as node.js requires a transpilation step before the code can be run alright for the third subtopic let's talk about module system compatibility a module system allows developers to organize code into reusable segments in JavaScript the two primary module systems are common JS and Es modules common.js originating from node.js uses require and module.exports for synchronous module handling ideal for server-side operations esm introduced in ESX employs Import and Export statements providing a more static and asynchronous approach optimized for browsers and modern build tools let's use colors for common.js and chalk for esm to popular packages for adding colored outputs to the console and better understand the difference in bun and node.js now node has been traditionally associated with the common JS module system let me create a new node project node 3 navigate inside and run npm in net y also run npm init colors and chalk create a new index.js file for the code we're going to require the colors package and log colors.green hello world run the code and we see Hello World in green pretty straightforward to work with the common JS module system if we replace require with import colors from colors and rerun the code you can see there is an error cannot use import statement outside a module to run es module in node.js you have one of two options first you need to include type set to module in package.json or you can use the dot MJS file extension so rename index dot MJS we run node index dot MJS and we see the expected output hello world in green this time with es modules this transition from common.js to es modules has been a complex Journey it took node half a decade post esm's introduction to support it without the need for the experimental flag Still common.js Remains prevalent in the ecosystem one simplifies the module system by supporting both common.js and esm without any special configurations one's standard feature is its ability to support both import and require in the same file something not natively possible in node.js in one playground let's create one three navigate inside and run on init Dash y let's also add colors and chalk packages we can now import chalk from chalk but require colors from the colors package run bun index.ts magenta colored hello from chalk and cyan color hello from colors with bun you can run code using common Json tags esm syntax or even mix of the two modules in the same file this if you ask me is incredible for the fourth subtopic let's discuss web apis web apis are integral to browser-based applications and offer tools like Fetch and websocket for web interactions while these have become browser standards their support in server-side environments like node.js has been inconsistent in earlier versions of node.js web standard apis commonly available in browsers were not natively supported developers had to rely on third-party packages like node fetch to replicate this functionality however from node version 18 there is experimental support for the fetch API potentially eliminating the need for these packages one on the other hand simplifies this by offering built-in support for web standard apis developers can directly use stable fetch request response websocket and other browser-like apis without any additional packages furthermore once native implementation of these web apis ensures their faster and more reliable compared to third-party alternatives with the power of editing we now have the node 4 and 1 4 project with the exact same code making a fetch request to Json placeholder API in the node.js environment running node index dot MJS will log Leanne Graham and so does running one index.ts while the fetch API is experimental in node.js the same is already stable in bun all right let's move on to the fifth subtopic hot reloading hot reloading is that feature which instantly reflects code changes in the application without the need for a full restart in the node.js ecosystem you have a couple of options for achieving hot reloading one popular tool has been nodemon which hard restarts the entire process you can globally install the package and run a file using the command node mon index.js alternatively starting from node.js version 18 there is an experimental watch flag introduced which you can use in the same note 4 folder node dash dash watch index dot MJS we see the experimental warning and the username change users parameter to 2 save the file and the code is Rerun and we see a different name both node Mon and the watch flag aim to provide real-time reloading of the application as the code changes one on the other hand takes hot reloading a step further by running one with the hot flag hot preloading is enabled unlike the node.js methods that might require a full process restart one reloads your code in place without terminating the old process this ensures that HTTP and websocket connections remain uninterrupted and the application state is preserved providing a smoother developer experience so run one dash dash hot index.ts for hot reloading change the ID to 2 save the file and we see a different username for our final subtopic under the JavaScript runtime topic let's discuss node.js compatibility while transitioning to a new runtime or environment compatibility is often a primary concern for developers one addresses this by positioning itself as a drop in replacement for node.js this means that existing node.js applications and npm packages can seamlessly integrate with one without any modifications that is already support for built-in node modules such as FS path and net recognition of global variables like double underscore directory name process Etc as well as adherence to the node.js module resolution algorithm including the familiar node modules structure let me show you an example in the same one for folder in index.ts let me paste the following code if you are familiar with node.js it should be clear we are working with node FS module If I Run 1 index.ts you can see the code runs without an issue we read the file package.json and log the file contents to the terminal we also have a write file content high again to index.html which we can verify you can simply drop in your node.js code into one and it just works it's not 100 compatible but the bun team is working hard to close that Gap but here's the thing while one ensures compatibility with node.js it doesn't stop there one ships with highly optimized standard library apis for things you need most as a developer for example the same code we can replace with bun apis we have one dot file to read package.json await file.txt and one dot write to write content into index.html we have the output and updated HTML one dot file is 10 times faster than fs.read file and one dot write is three times faster than fs.rite file there are other one apis to create an HTTP server work with a sqlite database and even passwords the bottom line is one apis are super fast compared to node.js apis with that we have covered our first topic of comparison the JavaScript runtime the next topic of comparison is bun versus node.js as a package manager one is an advanced toolkit that includes a powerful package manager if you have ever found yourself patiently waiting during dependency installations one offers a refreshingly faster alternative here is a table comparing One commands with npm which is nodes package manager we have one install one add package with the dash dash Dev option one remove package One update package and one run script at a glance once commands might seem familiar but the experience is anything but ordinary one boasts installation speeds that are orders of magnitude faster than npm it achieves this by leveraging a global module cache eliminating redundant downloads from the npm registry one employs the fastest system calls available for each operating system ensuring Optimal Performance here is a speed comparison of installing dependencies for a starter remix project from Cache comparing bun and npm from the official bun website we also have pnpm and yarn for added context make sure to also check my video where I compare setting up a new mixt 13 project with npm and bond one is almost 10 times faster when installing from Cache nodes npm has been the standard for JavaScript package management for years but one really is a speed Powerhouse and presents a compelling alternative alright for our third topic let's take a look at one versus node.js as a bundler bundling is the process of taking multiple JavaScript files and merging them into one or more optimized bundles this process can also involve Transformations such as converting typescript to JavaScript or minifying the code to reduce its size in the node.js ecosystem one link is typically handled by third-party tools rather than node.js itself some of the most popular bundlers in the node.js world include webpack rollup and parcel offering features like code splitting tree shaking and hot module replacement one on the other hand is designed to bundle JavaScript and typescript code for various platforms to bundle with one you can use a simple build command with the power of editing once more I've created a new one project called one five which has a users.ts file which exports a get username function returning user.name and index.ts file which calls it we can build this app using the command Pawn build dot slash index.ts and we specify the output directory as dot slash build folder this command bundles the index.ts file and outputs the result into the build directory we have index.js created the same get username function and the call to get username from index.ts the bundling process is incredibly fast with one being 1.7 times faster than es build and significantly outpacing other bundlers like parcel and webpack but a standard feature in bun is its introduction of JavaScript macros these allow for the execution of JavaScript functions during bundling with the results directly in line into the final bundle in index.ts update the import statement to include with type macro if you run the build command once more you can see instead of making a runtime API call the macro fetches the data at build time in line in the result directly into the final output while node.js has its established building tools one offers an integrated faster and Innovative alternative that could reshape how we bundle applications for the fourth and final topic we have one versus node.js as a test Runner testing is crucial aspect of software development ensuring that code behaves as expected and catching potential issues before they reach production in addition to being a runtime a package manager and a bundler one is also a test Runner while node.js has traditionally relied on Just for testing needs one introduces a built-in test Runner that promises speed compatibility and a range of features that cater to Modern development workflows once test Runner one test is designed to be fully compatible with jest which is a testing framework known for its expect style apis this compatibility ensures that developers familiar with jest can easily transition to one without a steep learning curve executing tests is straightforward with the one test command create index.test.ts and create a simple test of adding two numbers run one test and we see a test passing moreover once runtime supports typescript and jsx out of the box eliminating the need for additional configurations or plugins once test Runner is not just about compatibility it's about speed in a benchmark against the test suite for Zod one proved to be 13 times faster than just and eight times faster than v test this speed Advantage is because of plants matches which are implemented in fast native code whether you're looking to migrate existing tests or start a new project one provides a robust testing environment that aligns with modern development needs node.js has long been a Cornerstone in the JavaScript World setting benchmarks and guiding Developers however bun is stepping onto the scene as a noteworthy Challenger pushing boundaries while it's still early days for one the bus it is generating is undeniable currently it's optimized for Mac OS and Linux and while Windows support is in progress some features are still on the horizon but with everything it offers one is certainly a toolkit you should consider exploring