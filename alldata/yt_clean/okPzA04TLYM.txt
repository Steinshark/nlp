hello everyone, my name is Hadi Farid, my filmic color transform works on a high and most of what I've learned is thanks to Nihal Rahman, a CGI and color science enthusiast and the valuable resources they recommended flim is a color transform that takes in linear values that are bounded in the 0 to1 range in a just an approximation and doesn't perfectly but it's sufficient for most purposes, like tone before digital cameras were a thing, visual representations of scenes on physical photographic film is a strip or sheet of a gelatin emulsion containing microscopically the sizes and other characteristics of the and resolution of the film. ok, here's the grains of silver halide. now silver halight but you can't see those charged particles with the charged silver halide crystals to actual we wash away the unexposed silver halide crystals, silver for bright spots and transparent portions bright light source from the back of the negative, and get a photo that more or less resembles the enough that I'll treat it as paper for the rest there are a bunch of reasons why you might want to the values captured by the camera sensor might clipping those will look absolutely horrible and the same thing happens in 3D rendering where replicate in the display device. film emulation approximates how a print film will look. earlier, so what do papers and displays have in common? RGB values in your monitor can't go above 100% and light. film reaches this limit in a very smooth over just clipping the values. even if we don't film still provides a pleasant and natural to simulate film in computers, we'll need to make level and simulate the individual grains of silver too computationally expensive for practical use make a simpler model. let's start with black and which we'll call fixel for the rest of this video of these fixels. next, we'll associate a number at least proportional to the density of grains number will be zero in the beginning, meaning the changes a single fixel's density, we can easily take note that this makes an implicit assumption inaccurate but it will suffice. let's go back to a of a fixel, its density goes up in a nonlinear by taking the logarithm of the input energy and sigmoid function is a mathematical function whose the sigmoid function we use must be continuous 0 to 1 range. we glossed over one important fact on the incoming lights wavelength or its spectral same behavior for all wavelengths in our simple Watts or Watts per meters squared, or whatever. is 120 units for our little fixel. if we take the we'll call this the exposure. before we put this remap it to the 0 to 1 range because that's what this is where we define the sensitivity range does the density start to go up, and where it this example, we'll use an arbitrary range of -14 starts going up when our incoming light energy when the input reaches 2 to the power of 18. let's numbers from a custom range to the 0 to 1 range. then divide that by the span of the range which is return zero and for values above end we'll just remember that our exposure value the log 2 of the the sensitivity range, -14 to 18, to the 0 to into a sigmoid function. now there are plenty of good candidate, so we'll start from there. if we one multiplication away from calculating the final film have different maximum densities. let's 12 * .72 is roughly 8.7. so that's it, that's the how do we go from the density to the percentage zero when the density is zero and slowly gets that sounds like an inverted exponential function of negative density, and we graph this for all this is inverted because it returns one when the when we develop a real piece of negative film, the and opaque, and the parts that were not exposed a good approximation of the brightness of the I mean how much it passes light through. later, the print film, so in that case brightness that was a lot to explain in one go let's light to the final brightness value of a fixel. energy to get what we call the exposure. then, range to the 0 to 1 range before sending the output from the sigmoid function and our fixel which we arbitrarily set to 12. negative density function to get the approximate let's combine all of that into a single giant map that from the sensitivity range to 0 to 1 with multiply the result by 12 to get the density. and this. we now have an approximation for how a black to light and then developed. to burn this onto a light from the back which is aptly named the the transparent parts of the negative, which scene and correspond to shadows and dark spots. the back light. remember that these opaque parts brighter spots in the original image. this inverted itself, so what we get on the print film the process of printing with a new model, but the well for this as well. all we have to do is to twice. now, of course we could and probably should like different sensitivity ranges or different changes between the negative and the print pass backlight which simply scales the output of the also be multiplied by some factor. notice how the where it represents the density of ink. also is because of the nature of exponentials. later, to get a sense of how well this concept will Nodes. Blender is a free and open-source 3D outside 3D. you don't need any experience I have a linear image, also known as an HDR can calculate a grayscale value by just taking a giving more weight to greens and less to blues, we calculate the log base 2 of the grayscale value 1 range. fortunately, Blender's &quot;Map Range&quot; node implement it manually. let's multiply the output to get the density value. and finally, take 2 to next, we'll put all all of these nodes in a node group. we'll make an input let's name this node group &quot;film pass&quot;. observe how the image changes when as a expected, if we scale the negative gets brightened or let's also scale the output and then send it through another film pass node and just like that, we have film approximation. let's compare the final image how the highlights have become smoother and how the contrast can be decreased or color is typically represented by three each representing the amount of red, green, and and (1, 1, 1) represents white. (1, 0, 0) is and so on. so-called linear or high dynamic range above one or even below zero as we'll see later. so we need to define a color space that we work to quantify color in an accurate way, so after space. it's not actually possible to create an psychological and trying to accurately model the complicated and not yet fully understood. also, the CIE model is good enough and most importantly primaries, a white point, and a transfer function. red, green, and blue in the color space. this primaries are from each other, the wider the more laser-like colors without using negative warm gray values like (1, 1, 1) will illuminant E or I-E stands for equal the same intensity. another common white point function of a color space defines whether the spaces are used in physical calculations while nonlinear spaces can be used in we can convert between different gamuts and white transfer functions need to be handled separately. what most display devices use, Linear Rec. 709 or P3, and BT.2020 which has a very wide gamut and Blender uses Linear Rec. 709 as its working space, it's fairly straightforward to extend our filmic three layers of color filters, each of which respectively. let's call that the sensitivity tone and as the incoming light of the sensitivity tone opposite color of its sensitivity tone, which will slowly turns from transparent into a cyan filter magenta as it receives green light, and the blue layers are then stacked up to get the final color. the three layers together, component-wise. and as white in our model, because a white filter this is named subtractive color mixing even layers are multiplied together, we'll a backlight and expose a color print film to the just like we did in black and white. we'll use on real images. we'll start by separating the channels. it should be obvious that we're going to get the percentage of mixing from white to the we'll make sure the input doesn't have hate them. negative values in linear images which are too pure to represent with our current values to zero is called gamut clipping. these negative values in a smoother way, called since logarithms tend to negative we'll add a tiny offset to the input necessary nor accurate, but in flim, this sensitivity start. we won't implement that add a color mix node and mix from cyan to white. use our film pass node on the red channel to get the mix factor. and do the same then, multiply them together. we've now got a this a node group and call it &quot;color film then, duplicate the node for the print pass. we can get the factor by taking two to let's make that a node group and call it exposure. let's multiply the output of can you guess what this is for? this is the color of the backlight. we can also adjust the exposure for the and try to roughly match the input and the we can get artistic color adjustments by using let's put all of this in a single if we replace the input with pure but something slightly brighter. we observed and called this the black point. this isn't to how real prints work, but if you really want into a separate &quot;color film&quot; node and subtract to avoid color shifts, you can make observing what happens to the average and applying the same factor on the output. make sure to avoid division by zero though. unfortunately our current model has a huge flaw. with an RGB color sweep. instead of slowly turning effect is caused by the fact that the three layers there was a way to introduce cross talk between make up a new gamut whose red channel is affected is Rec. 709. for example, the red channel's value the red channel in Rec. 709 + 5% of the green green channel would be equal to 90% of Rec. 709's and the same goes for the blue channel. let's combine the results of the dot products our new made-up gamut. this is actually we're basically multiplying a 3x3 matrix by a 3D of the matrix are simply the factors we used to other. let's abstract away these dot products let's also make a node group that this transformation effectively desaturates &quot;color film&quot; node, so we need to un-desaturate emulation. this can be done by multiplying the not going to get too in-depth, so we'll just I know this is one mess of a node graph, you were using a programming language, call. let's hide this in a node group let's multiply this inverted matrix by we can see that it has removed the desaturation unfortunately introduced some ugly clipping into it more obvious. now, this clipping is expected gamut and then converting back down to Rec. 709, and there. to mitigate this, we can modify output. you can check out this super simple Smith on GitHub and implement it if you want our gamut conversion matrix is pretty unintuitive things to the image, so let's go back into the scale and rotation for each channel. we'll use desaturate each channel as its scale goes this method is kind of arbitrary and not we'll make sure to divide the final triplet by the let's set the scale to one for start. now, the first matrix multiplication so let's set its scale to one as well. it these nodes at the same time, so let's put I'm playing with the parameters to see let's replace the input with a real let's try another image if we disable and enable the matrix multiplication film emulation in a wider gamut than our working compensation must be done in the working gamut and let's try a few more images and see hopefully, by now, you have some idea of how we it's important to note our model lacks many look of film grain, or halation In color film and many more effects that naturally happen mapping a linear RGB color to the 0 to 1 range in that our model has some differences with flim, one person for free, purely out of interest in so if you've been enjoying it, consider giving and leave a comment if you have any questions