Welcome back to the Cyber Security Architecture Series. In previous videos, we covered security principles, and then we started talking and access management Today, we're going to talk about application security. So let's get started. What are some of the things Why do we have to care, maybe, is the best question. Well, it turns out that essentially all software has bugs. Nobody writes a software of any real complexity And it turns out that some percentage of those bugs will be security vulnerabilities. So therefore, if you follow the logical conclusion, that means essentially all software So what can we do to try to reduce those Obviously, we don't want buggy software but this will help drive the point home a little bit, If we look at the various stages of application development and look at where security or vulnerabilities in general are introduced. Think about the injection phase. It turns out that most of the vulnerabilities and bugs are introduced in the coding phase, And then as we move to unit test, and release, then we find fewer and fewer bugs. So that's the green curve, When are they found? Well, they're found as we kind of move along this process. During the coding phase is in the testing phase, we're finding them. And then hopefully when we get to the real world, Now the interesting thing about all of this is the cost. How does the cost go? Well, it turns out cost goes about like this, where we go from 1x as the whatever you want to base the cost to -- in some cases 640x. It is vastly more expensive to fix a vulnerablity once it's in the field than it is to catch it early. So there's a huge incentive for us to get this right Now, what can we do then Well, let's take a look. We're going to take a look, by the way, That's the SDLC. And traditionally, this is how it's been done. We have some design phase here in general what we're going to do in this particular application. And then we're going to move to a coding phase. We're going to write the application itself. Then we're going to go to some sort of testing phase. And then ultimately we release it to the world Now, what is traditionally happened this is the dev part of the process This is where we're developing. This is where we're releasing and then just operating it The problem with this traditional approach You can see how this process goes. It's also very siloed. This line right And it kind of leads to this sort of "over the wall" mentality. I'm going to write the code and then I'm going And so there's not a lot of communication happening here. It can be a slow process and it's fairly inflexible. And by the way, I'm going to suggest to you, we didn't Very often security gets introduced out here, Now, a more modern approach to this So here we take the two processes, dev, then we're releasing it, we're deploying it, With a DevOps process, This thing doubles back on itself. There's a feedback loop of continuous improvement. There's no over the wall. There's no us versus them. It's an integrated process. It's much more rapid, and it's designed for agility. So this is a much more flexible kind of capability But again, we haven't really addressed the security here. And so what more modern approaches have done is introduce this notion of devSecOps, or encompass the whole thing in a security layer. We're going to put security at every one of these phases. We don't want this to be something that we wait to the end. Security can't be a bolt-on. That is not going to be effective. We need security to be built in So, for instance, with a devSecOps approach, we're That if you were thinking of this in a linear phase not just here, we're going to introduce security We're going to do security by design. We're going to design the system so that it stands up and it's resilient to attack from the first. Not again as a bolt-on. Then we're going to create collaboration different groups that maybe didn't always talk together. But with devSecOps, we have it all working together And then ultimately try to leverage a lot of automation. I'll talk about that Okay. Now, we've covered the software development lifecycle. Next, we're going to take a look at secure coding practices What do we need in order to write secure code? If we're going to shift maybe even design phase, What are my needs? Well one thing I need is a list of secure coding practices. This is a prescriptive way of saying There are certain things that we need to do. For instance, validate inputs. We need to make sure that if a buffer that when someone sends me something, it's not this big We call this a buffer overflow. So that's a type of condition If we don't do all the input checking, We need to specify how we would do authentication. What are some of the other ways What kinds of error handling routines? So it's basically a way of saying, Have we done them all correctly? Well, there's a great resource here. It's called owasp.org. And at this website, what you'll find They have a very good document that is kind of an industry So I would reference that you take a look there. Trusted libraries. Everyone doesn't write all their code from scratch anymore So as a result, we end up relying on code It might be open source, in our code as well, or make calls to it and leverage it. There's a lot of sources that are out there, And even the trustworthy ones need to be looked at with a certain amount of skepticism So trusted libraries are an important thing here as well. And if you want to see what can happen, go look up something called Log4J. This is a very well known vulnerability because everyone was using this routine, which was a common trusted routine from trusted sources, and yet it had a vulnerability in it And those vulnerabilities were discovered. Guess what? Over here in this phase, right So, again, we want to try to eliminate that or at least find it much earlier in the process, if we can. And using trusted sources, at least, helps. It doesn't eliminate the risk, but it helps. Standard architectures. I want to have spelled out that when we're going to do a certain approach, So we want to spell out in advance There's a lot of different sources for that. IBM has an Application Security We'll reference here. Also there are other sources, but you want to be able to spell this out Mistakes to avoid. Again, we're going to go back to our friends at OWASP. They have a thing called the OWASP Top Ten list. And what's really interesting in this is they're showing And it's very interesting to look at this over time. Look, back in 2017, what were the top ten? And look now and the more recent one, 2021? And what you'll find is there have been it's sort of the same list, We're not making these defects extinct. We're just kind of shuffling the order a little bit. But things like buffer overflows and other types of input validation errors have been around for a long time. But this is a great learning resource. So again, I refer you to OWASP. And then finally, The idea of a software bill of materials. That is, I want to know where everything came from, I want to know all the components that I'm using. I want to know where they came and where those are sourced. I want to know what dependencies exist amongst these I don't want any surprises in that. I want to know the versions of all of these And if I'm building applications, I need to know time, need to be updated, and I need to be able to know Again, refer to Log4J. Go and do a web search on that That's a good example where if we have a software bill of materials then we have a much better idea of all the different places and we can recover much more quickly Okay. Now, we've covered the software development and we're now going to take a look at vulnerability testing. We'd like to test for security throughout the process. Remember, one of the things I mentioned in the DevSecOps that is, use more tooling. And two major classes of those tools are static application And DAST: dynamic application security testing. You figured if a one was going to be static, Okay, what's the difference in those two? Well, It's called that So it's like it's looking inside our code. So the box is open in that sense. The black box dynamic, instead of giving it source code, we're actually obscuring It's going to look at an executable system. Think about it differently. In this case, we're going to do I can feed my source code into it, and tell me about those, the ones that it can identify. And the great thing about that is we're moving We're doing a shift left in the dev process at the earliest stage Even if I can't do it in that phase, I'd at least like to catch it during one of these test phases. So it's a little bit later in the development cycle, we hit release when everything gets super expensive. So what I'd like to do is run both of these. In other words, it's not an either/or. It's really both/and. Because there's advantages to both of these, the source code The dynamic scanner will find other types. So you really need to use them both together And again, think about that cyclical devSecOps process and how the tools One other sort of tool that's being used in this space It wasn't initially thought of in that context but it's really becoming popular and that is chatbots. These large language models So a chatbot is good at generating code very quickly. You could say "write me a routine" in, say, Python that will find all the ways to make change for a dollar So that's a nice feature that you can have It can also debug code. So if I've got stuck at some point during the development of some routine, and maybe it will find what my vulnerability is So that's all good stuff. However, there's a downside. The downside is So that is, when we get source code back, But probably you went to the chatbot you wanted it to write for you, not just 12 lines of code, So are you going to inspect all of that didn't make a mistake that introduces a vulnerability, or maybe it's been engineered in a way or someone has hacked it and it's intentionally putting a backdoor in is shared out with someone else, So that's a big risk. It's not necessarily a trusted source, where we've had potentially thousands of eyes looking at it In this case, it just came right straight from the source, So there's a big risk there. And another thing is, if I'm using it to do debugging, then that means I'm feeding my source code into this system. And this system might expose intellectual property. If this code I have is considered confidential, if it's a trade secret, Now I've just taken that and I've given it directly to what is essentially to the Internet, potentially, It might use it might re-use your code in some other case. There was one major company where their developers were using a chatbot to do debugging. And it turned out they were releasing And the company decided So we need to stop that. OK, so that's a quick look at application security. What we've tried to cover are ways to introduce process, do a more continuous process, and use tooling in order to improve the security from sources like OWASP so that we don't keep making It feels a lot if you've been doing security we just keep reliving the same problems So let's learn from those So now we've covered application security. In our next video, we're going to move over That's the thing And so that you don't miss that, And that way you'll catch the next video when it comes out.