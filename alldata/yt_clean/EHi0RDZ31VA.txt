[MUSIC PLAYING] DAVID MALAN: All right. This is CS50, and this And this is that week we transition from C, this lower-level memory and how really computers to what's now called Python, which is whereby we're still going to be able But it's going to suddenly start to Python offers, as do higher-level are what we might over the very low-level ideas that and problem sets and so much more. But recall from week 0, where we began. This was our simplest of programs Things escalated quickly where, suddenly, we had But the idea was still the same of Well, as of today, a a lot of the visual such that what used to be this in C And that's a bit of a going to see some other But you'll find that Python's derives from just how and also, as we'll ultimately and filled the ecosystem That is to say there's There's a lot more problems that that you can now incorporate in order to stand on their shoulders But recall, though, from C that to actually compile that kind of code. So we got into the habit of make And then we've been in the habit the effect of which, of course, is to compose the hello program into the the CPU. We revealed that what is something a little more specific, compiler specifically, with some to output the name that you want, and so forth. But with Python, wonderfully, we're too, and quite simply run it as follows. Henceforth, our programs will no suffice it to say. Our files starting today are which is an indication to the or Linux or anything else-- But unlike C, wherein we've been and running it, compiling our code a change, with Python, those two that any time you make a change you don't explicitly compile it anymore. You instead just run a program called But whereas clang is a see as not only the name of the And the type of that program An interpreter is a program that reads and really does what it says without having to compile it in zeros and ones. So with that said, let me do this. Let me flip over here to VS Code. And within VS Code, let me And as always, I can create a new file I'm going to create this file And quite, quite simply, I'm going to world&quot;). And if I go down to my terminal I'm instead going to interpret this and the name of the file I want And voila. Now you see &quot;hello, world.&quot; But let me go ahead and Let me also go ahead and bring And I'm going to do this as we where I included standard io.h. I did int main(void). I did inside of there printf(), quote close quote, semicolon. And let me go ahead in VS Code. And if you drag your file you can actually split-screen And what I've done here is-- and I've now compared these So here's hello.c from, say, week 1. Here's hello.py from week 6 now. And the obvious-- the But there's still some-- there's Beyond getting rid of did I apparently omit even though it didn't appear Yeah? Sorry? Say one more time? AUDIENCE: The library. DAVID MALAN: The library. So I didn't have to include any kind of print(), apparently, AUDIENCE: main() [INAUDIBLE] DAVID MALAN: So I don't So this main() function, to be clear, told the compiler what the And you can't just start What else do you see? AUDIENCE: No semicolon. DAVID MALAN: So there's no more at the end of this line, And things are getting a What else? So the new line. So recall that in printf(), if you line when you're done printing, So it seems as though Python-- because when I interpreted the cursor did move to They sort of reversed So those are just some of One, you don't have to explicitly like standard I/O. You don't need You can just start writing your code. You don't need these printf() is now called And you don't need the backslash n. Now, there is one thing even though I didn't do it here. Even though in C, it was required any time you want to use a as with a lot of languages nowadays, you single quotes so long Generally speaking, because you don't have to hold hit one key instead of two. So there's an argument However, if you want to use then you have to escape it. And so in general, stylistically, But things are getting a whereby that's not But what's especially and, really, a lot of higher-level you can get done relatively quickly. So you've just spent daresay, implementing your your own dictionary of sorts. Well, let me propose that to do that in Python instead of C. Why? Well, let me go ahead and do this. Let me close these two tabs Let me go into a that I downloaded in advance for class. And if I type ls in here, very similar to what you spent But the file extensions are different. There's a dictionary.py There's a speller.py And there's the exact same that we gave you for problem set 5. So let me just stipulate that I spent And so I gave it a name of speller.py. But I didn't go about really And so why don't we go ahead and together by doing this? Let me clear my terminal, And let me propose that we implement, And what are those Well, they're going to be the check() the size() function, and But recall that in problem set 5, And so while there isn't a I'm going to go ahead and do this. I'm going to create a variable, a called words, and I'm In the mathematical sense, of things that won't contain duplicates. Any duplicates will be filtered out. So I'm going to now, after that, I'm going to create a function And check() takes as input a word. And if I want to check if a I can simply do word.lower in words. And that's it. Let me now define another function took an argument, which was the name into memory. Inside of my load() function, I'm going to say with open(dictionary) And in there, I'm going to go to be the updated version of whatever's it and then splitting its a big, long column of words, each splitline is going to split all And then I'm just going to I'm now going to go ahead and define But in Python, I'm going to go ahead of that set of words, where length, or And I'm going to do one last function. It turns out that in Python, I'm going to go and implement there's not actually because Python will manage malloc() is gone. free() is gone. Pointers are gone. It handles all of that, seemingly So here then is, I claim, what you if implementing it in Python instead. Let me go ahead and Let me increase its size. Let me run Python of speller.py, which the dictionary per se Let's run it on a file called was a particularly big file. And if I hit Enter now, the same output that you saw And eventually, we should see as to how many words how many words were in the fast this whole process was. Now, the total amount of time required longer than it seemed to take. That's because we're and it was taking some amount of time But the code was only taking 1.93 And hopefully, these same kinds the difference being what I did not have your own hash table, is your beyond what I've done using Python here So why, you see, why assuming that you able to whip up within seconds How might you choose And I apologize if you're that this wasn't a week earlier. Why Python or why C? Any instincts? Any thoughts? There's hopefully a reason? Yeah, over here? Yeah? AUDIENCE: I always thought that Python DAVID MALAN: Ah, really good conjecture. So you always thought that and takes up more space than C. So even though, ultimately, this 1.93 odds are it's a little slower than It's possible, too, that actually does take up more RAM Why? Well, because Python itself And it doesn't necessarily know a priori You, the programmer might, and allocated presumably as you might have needed But Python's got to maybe and try to manage memory for you, and The fact that I have so the fact that these lines of means that Python, or whoever invented to of give me this functionality. And so if you think of Python it's doing more work for me. It's doing more of the heavy lift. So it might take me a bit more time. But, my gosh, look how much of writing this code more quickly. And arguably, this code or at least will be after today, week and features of Python itself. So beyond that, it turns out you can Let me go back into my terminal window. Let me close this dictionary.py. Let me go into a folder I have this same bridge that we've seen So here's a bridge. This is the original version Suppose I actually want to Well, you might recall from problem set by manipulating all of the red, are ultimately composing that file. But let me go ahead and Let me create a file called blur.py. And in this file, let me go ahead and So from the Python image and import something called Image, I, capital F. So I'm going to do before Then let me go ahead and create and set that equal to before.filter, ImageFilter, spelled and then we'll give it a value of 10. How much do I want to After that, I'm going to literally save it as a file called out.bmp. And that's it. I propose that this is how you can now much like you might Now let me go ahead in my terminal When I hit Enter, those It seems to have happened quite quickly. Let me go ahead and open now out.bmp. And whereas the previous image looked and open out.bmp. And hopefully, you can for me using that same code. And if we want things to let me go ahead and do this instead. Let me close blur.bmp. Let me go ahead and open And maybe, in edges.py, we So from the Python Image Library, Let me go ahead and create set it equal to just like before. Let me create another set that equal to which comes with this library the same thing-- save this So if you struggled previously, whereby you wrote for the set 4, edge detection, might have then created a file the original bridge.bmp, this new lines of code, now looks like this. So, again, if this is that we had to do all of the point to motivate that what's going on underneath the hood. But with Python, you can to problems all the more And just one last one, too-- in the world of photography and detection, for better or for worse. And it turns out that if you want to integrate it is something that lots of other people as well. So Python, to my point earlier of having that other people wrote, you can install face_recognition if you want or to your programming and for the notion of face recognition. In fact, this is going from some server elsewhere a called face_recognition. And with this library, you Let me go into a directory Let me go ahead and ls in there, detect.py and recognize.py, faces and then recognize specific I brought from a popular So if I open office.jpg, here is one of series The Office. And here is a photograph of someone Now, this is, of course, Toby's face. But what is it that More generally, if I open up to identify all of the it wouldn't be that hard with a marker But how? Why? How do you as humans detect Yeah? AUDIENCE: You have eyes, nose. DAVID MALAN: Features, generally in a similar have different faces, ultimately. But there's a pattern to the shapes Well, it turns out this has been trained, perhaps via to recognize faces, but any perhaps among these folks here. So if I go back into my let me go ahead and run, say, in advance, which uses that library. And what that program is going to do-- It's just found some face. And let me go ahead now and called detected.jpg, which I didn't But when I open this here file, based on this library's But suppose that we're looking for maybe Toby's. Well, maybe if we write a take as input the office.jpg, maybe this library, and can distinguish Toby's face from in the show, just based on this one Well let me instead run python It's going to do some thinking, And it is going to recognized.jpg, which should show And so what has it done? Well, with sort of a green marker, That's maybe a dozen but it's built on top of And this is, again, just one of the Undoubtedly, some number of years and something else will be back in. But that's indeed among the goals not to teach you Python, to teach you JavaScript but to teach you how to program. And indeed, all of the ideas explore more today, you'll see recurring Any questions before we now dive and why I type the things that Any questions along these lines? Anything at all? No? All right. So how does Python itself work? Well, let's do a quick we transitioned from though, from Scratch, say, to Python. So in Python, as with are these things called functions-- actually get things done. So here on the left, recall from week We played with, first, the say the cat say something on the screen. We've seen in C, for instance, the this here, with printf(), with the the backslash n, the semicolon. In Python now, it's going to indeed But the idea is the same Libraries-- so we've seen already seen in Python that In the world of C, recall that besides that header file, we could which was like your file for the CS50 library, which gave Well, we're going to give for at least the next week or specifically, that, again, will take even with CS50 behind you. But the syntax for using a library You don't include a .h file. You just import, instead, All right. What does that actually mean? Well, if there are specific functions in Python, you can be more precise. You don't just have to say, For efficiency purposes, you can say, from the CS50 library. So you have finer-grained control in up if you're not loading into memory, if all you want So here, for instance, in Scratch, was a built-in function, like the say but how we might similarly now do So how might we do this? Well, in Python, or looks a little something like this. Back in week 1, we declared even though later we I gave this a variable name of Then we use CS50's own get_string() the same question as And then, using this placeholder which was printf()-specific, we could string where the %s is. And we saw %i and %f and So this is sort of how, the idea of concatenating two just as we did here in Scratch. So in Python, it turns out it's not but there's going to be And so even what might seem today it really is just different to achieve the same goals. And over time, as you get you too will develop your own or working with a team, decide which conventions But here, for instance, is one way in Scratch but in Python instead. So notice I'm going to still I'm going to use CS50's I'm still going to use, quote But down here is where we It's, again, not called It's now called just print(). And what might you infer the It's not addition, obviously, But those of you who have what does the plus AUDIENCE: It's joining DAVID MALAN: It's indeed joining So this is indeed on the left with the thing on the right. So you don't use the placeholder You can instead, a little But you want your grammar to line up. So I still have &quot;hello,&quot; because I want to form a full phrase. Notice, too, there's also subtle difference on the first line. Besides the fact that we don't have AUDIENCE: You don't declare DAVID MALAN: I didn't declare So Python still has But you don't have to tell the it is. And this is going to and it's just going to be a little Meanwhile, you can do this also a You can instead trust that the print() more for you automatically. The print() function in Python can take in the usual way. And by default, Python for you a single space between its So notice what I've done is, quote unquote, &quot;hello,&quot; Then, outside of the quotes, I'm here comes my second argument. And then I put the same And I'm just going to that it should, by default, can join these two variables, putting You can do this yet another way. And this way looks a little probably the most common is to use what's called a format And this looks weird to me still. It looks weird. But if you prefix a string literally, you can then use curly And Python will not print out literally It will instead interpolate whatever That is to say if answer has some value, like &quot;David&quot; saying f before the and then using these is going to do the exact same thing of comma, space, &quot;David.&quot; So it's going to plug So you can think of this as %s but to keep track of what you Instead of %s, you literally what do you want to put right there? You format the string yourself. So given all of those go about implementing this Well, let me propose Let me propose that Let me go ahead and And as before, instead of just quote unquote, &quot;hello, world,&quot; something a little more interesting. So let me go ahead and, import the function called get_string(). Then let me go ahead and create Let me set that equal to the as an argument, quote And then no semicolon at the end of here, I can pick any one of So let me start with the first. So &quot;hello, &quot; + answer. And now, if I go down to my terminal I'm prompted for my name. I can type in D-A-V-I-D, and Or I can tweak this a little bit. I can trust that Python will concatenate But this isn't quite right. Let me go ahead and rerun python in &quot;David.&quot; It's going to be ever-so-slightly or visually, if you will. What did I do wrong here? Yeah. So I left the space in there, even print(). So that's an easy solution here. But let's do it one other way D-A-V-I-D. And OK, now it looks like I intended. Well, let's go ahead and So let's just pass in one bigger and then, in curly braces, Well, let me go down to my Let me run python of hello.py and OK, I made a mistake. What did I do wrong here, Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: So the have to put before the that this is a special string-- string-- that it should So if I rerun this after adding What's your name? David. And now it looks the way I might intend. But it turns out in Python, you don't In C, recall that we introduced pretty annoying in C to get strings, Recall those short examples we And scanf kind of scans what and loads it into memory. But the fundamental danger with scanf Why was it dangerous to use Why? Yeah? AUDIENCE: What if they give you a really DAVID MALAN: Exactly. What if they give you that you didn't allocate space for? Because you're not going to know how long of a string the So you might under-- you might undercut it and therefore characters being put into that some kind of buffer overflow, which your program. So it turns out in C, get_string() In Python, it's not really that useful. All it does is use a function that And, in fact, the input() function in is the same as the get_string() But just to ease the we implemented a Python version But this is to say if and I just change get_string() I even get rid of the CS50 library at If I rerun python of hello.py, I have that now working as well. All right. Questions about this use of get_string() far? All right. Well, what about variables? We've used variables identified the fact that you don't have proactively, even though, clearly, well, in Python, here's a variable that not necessarily but maybe an integer instead. So in Scratch, here's a variable called counter if you want In C, what we would have done is this-- int counter = 0; that's the But in Python, as you might imagine, out this same idea little more easily. One, we don't need to say int anymore. Two, we don't need And so you just do what you intend. If you want a variable, If you want to assign it a If you want to specify that And just as in C, this is It's the assignment Recall that in Scratch, if you wanted to you could use this puzzle piece here. Well, in C, you could do syntax like It's saying add 1 to counter and then In Python, you can do exactly the So you don't need to But you might recall that in C, there because it was pretty popular. And so you could shorten this to actually just this. += 1 will add value is. But it's not all steps forward. You might be in the Sorry, those are not Why? It's because the designers don't need them because this is-- gets the job done anyway. But there's a question down here in All right. So that's one feature we're taking away. But it's not such a big Well, what about the beyond actually being Well, recall that in the world types, those that came with And we played with quite In Python, we're going to In Python, you're only going to have a float, which is a real typically, an int, or an integer, So Python here sort feels like it's too long So a string in Python is called str, Notice, though, that missing are double and long, which, recall, to store information. We'll see that that might not In fact, Python just into two different types out of the business of do you want a small int or a large Well, let me go ahead and do this. Let me switch back over to VS Code here. And why don't we actually try to play these data types and more? Let me go ahead and like we did way back in So let me do this-- So I'm indeed going to do that we have a similar example at hand. So I'm going to include I'm going to go ahead Inside of main(), I'm going to go ahead that equal to get_int(), and I'm going But if I'm using get_int(), recall So in C, I'm going to need But back in week 1, I I then said, give me another variable and set that equal to that-- And then, lastly, let's just like add two numbers together. So in C, I'll use printf(). I'm going to go ahead and do %i And then I'm just So all of that was in C. So it was to accomplish that task, are really the logical These are the three that So let me instead now do which is going to give me a new tab. Let me just drag it over to the right And in calculator.py, let's do this. From the CS50 library, import which is also available. Then let's go ahead and create a to the return value of get_int(), no semicolon, no mention of int. Let's then create a second variable prompt the user for y, as before, And now let's just go So it turns out that the print() that you don't need If you want to print out an even if that integer is the So it just sort of works So let me go down into my terminal here. Let me run python of calculator.py. And when I hit Enter, Let's do 1. I'm prompted for y. Let's do 2. And voila, I should so no actual surprises there. But let me go ahead and, you know what? Let's take away this We don't want to keep So suppose we didn't give you get_int(). Well, it turns out that get_int() is even though get_string() was kind get_string() with input(). So let's try this same idea. Let's go ahead and prompt the user the input() function in Python Let me go ahead and rerun Python So far, so good. Let me type in 1. Let me type in 2. And what answer should we see? Hopefully still 3, but nope. Now the answer is 12, or is it? Why am I seeing 12 and not 3? AUDIENCE: [INAUDIBLE] two strings. DAVID MALAN: Yeah. So it's actually concatenating So if we actually read the it's behaving exactly It is getting input from the But anything you type at the Even if some of the symbols be decimal numbers, they're still And so x is a string, and we've already seen that if you use you're going to get So you're not seeing 12 as much So how can we fix this? Well, in C, we had this technique where by just putting int in In Python, things are a that you can't quite get one thing to another because the same thing as a char. A string has zero or more characters. A char always has one. And in C, there was a perfect and single numbers in decimal, But in Python, we can do something but convert this input() to an int So just like in C, you You can call one function as the input to another function. And this now will convert And so now plus is going to behave Let me rerun python of calculator.py, we're back to seeing 3 as the this nesting, let me Instead of just passing I could also more pedantically do this. x should actually equal int(x), This would be the exact same effect. It's just two extra lines where But that would work fine. If you don't like that approach, We could actually convert x Why? Well, int, I-N-T, in the context And it takes as input and returns to you the numeric, the but it's actually a function. So all of the syntax that is sort of fundamentally the same as we're not casting but Well, let me go back These are some of the data types It turns out there's a that we'll start to dabble with today. You can get a range of which is going to be like an are kind of like x, comma, y, don't change. dict for dictionary-- it turns out You get hash tables for free. They're built into the language. And we already saw that a data type known as a collection of values that gives you-- gets rid of any duplicates for you. And as we saw briefly in speller-- and it's going to actually be pretty for values in those there data types. So that in C, we were able to get input In the CS50 library for Python, we're They're going to be the same name. So it's still get_string(), not to remain named the same. But get_float(), get_int(), But, again, get_string() But get_int() and Why? Well, let me go back to VS Code here. And let me go back to the whereby I proactively converted each So recall that this is the And to be clear, if I run python I get back now 3 as expected. But what I'm not showing you is that Let me run python of calculator.py, Instead of typing what let me actually type something And unfortunately, we're going the first of our runtime errors. And this, like in C, is going But this is generally it's going to trace back for you even though this one's relatively short. And you'll see that I didn't even get very far And then, with all of these carrot Why? invalid literal for int() function Again, just like in C, It's very arcane. It's hard to understand this But what it's trying to tell me And therefore, the int() function We're going to leave this But this is why, again, and get_float()'s looking kind of CS50's library will deal with Now, just so you've seen to import functions from these things. If you were to use, for instance, in and get_string(), you don't need to You can actually separate them a And, in fact, if I go back to a version I actually do use the so let me actually get rid of all Let me get rid of all this Previously, the way I did this was if you know in advance what But suppose, for whatever reason, you get_int(), and therefore, it you can avoid that issue, too, by earlier. Just import the library itself. Don't specify explicitly which But thereafter-- and you you could specify in order to go into the library, access it doesn't matter if you or any an identically-named You're using here, clearly, CS50's own. So this is, again, just more but with different syntax. All right. Any questions about any of this No? All right. Well, how about maybe whereby we revisit conditionals, do this thing or this thing, sort In Scratch, recall, we might to just check, is x less In C, this code looked like this. And notice that we had parentheses We had curly braces, even though I did you can actually omit the curly braces. But stylistically, we always But you have the backslash In a moment, you're about to see which is almost the same. It's just a little nicer. This, then, is the Python So what's different at a What's different? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: So the conditional You can use parentheses, especially if, But if you don't need them, don't What else has changed here? Yeah? AUDIENCE: No curly brackets. DAVID MALAN: No curly braces, yeah, And even though it's one line of code, Why? Because in Python, indentation is And we know from office occasionally that if you or you didn't manually C is not actually going to care if If you never once hit the Tab C, or specifically, clang, But your teaching to care, or your colleague in the real and hard to read. Python, though-- because you are not the bad habits when it comes to style-- Python as a language decided, that's it. Everyone has to indent in order So the convention as Python so 1, 2, 3, 4, or hit Tab and let it and use a colon instead for instance, to make with this particular conditional. We can omit, though, the We can omit the semicolon. But this is essentially Here in C-- in Scratch, if like we did back in week 0, in C, It's the else clause and write out an In Python, we can tighten this up. if x less than y, colon, First line's the same. All we're doing now is adding an How about in Scratch? If we had a three-way fork in In C, it looked pretty much In Python, we can tighten this up. And this is not a typo. What jumps out at you as weird but Yeah? AUDIENCE: elif. DAVID MALAN: elif. And honestly, years later, I still because other languages and now I probably now biased all But it's elif in Python. E-L-I-F is not a typo. It's in the spirit of let's just So elif is identical to elsif, but it's All right. So if we now have this ability what can we actually do with them? Well, let me go over to VS Code here. And let me propose that we revisit where we just compare two So I'm in VS Code. Let me open up a file And in compare.py, we'll so we don't risk any errors, like if So we're going to go ahead and And in compare.py, let's get and prompt the user for x. So &quot;What's x?&quot; To be a bit more verbose, And then let's go ahead and So if x is less than y, then go ahead than y&quot;), close quote, go ahead and print out &quot;x is go ahead and print out &quot;x is equal but I've added to the mix Let me run python of compare.py. Enter. Let's type in 1 for x, 2 Let's run it once more. x is 2. y is 1. x is greater than y. And just for good measure, let's y is 1. x is equal to y. So the code, daresay, works exactly as But it turns out that we're actually going to get some have been what you expected weeks ago, In the world of Python and in strs, strings actually behave So by that I mean this. Let me actually go back to this code. And instead of using integers, I could do get_string(), but we said So let's just go ahead and And actually, you know what? Let's just start fresh. Let's give myself a string called s the user for s. Let's use another variable called t the input() function to get t. Then let's compare if Now, a couple of weeks And if I tried to compare two strings But if I do if s == t, let's go ahead and print(&quot;Different&quot;). I daresay, in Python, I think this So python of compare.py, And indeed those are the same. Let me run it again and type And those are now different. But in C, we always got &quot;Different,&quot; even if I typed the exact same word, be Why, in C, were s and t always Yeah? AUDIENCE: Because it was comparing address. DAVID MALAN: Exactly. In C, string is the same thing as And because we had called even if the human typed the same things, at two different addresses. So those two char*s were just even if the characters at Python is meant to be higher-level. It's meant to be a It's meant to be more accessible know or want to understand So in Python, ==, even for strings just But in Python, we can too, even more easily than we could Let me close compare.py. And let's reimplement a which allowed us to prompt the do you agree to these terms and So let's do code of agree.py. And with agree.py, let me go ahead and-- actually, let's go ahead and do this. Let me also open up a file And this is called agree.c. And this is what we we wanted to check whether or not the So we used the CS50 library, we had a main() function, And then we used == a lot, and which meant logical or. Is this thing true or And if so, printf() So this worked. And this is relatively simple. That's the right way to it was a little verbose to handle uppercase and lowercase, So that did start to bloat So let's try to do the and see what we can do the same So let me do this. In agree.py, why don't we try to And I will use-- I could use get_string(), but So s = input(&quot;Do you And then let's go ahead and it's not vertical bar now, more English-like-- or s == &quot;y,&quot; then go elsif-- see, I did it there-- go ahead and print out &quot;Not agreed.&quot; So it's almost the same as the C literally, O-R instead So let's run this-- Enter. Do I agree? Yes, for little y. Let's do it again. python That works there. And if I do it again with with capital N, this But what if I do this? Let me rerun python of agree.py. Let me type in Yes. OK, it just ignores me. Let me run it again. Let me type in no. It just ignores me. Let me try it very It just ignores me. So there's some explosion that ideally we should handle, right? This is bad user interface design if even if yes and no in English are So how could we handle that? Well, it turns out in Python, we technically called a list, to maybe So let me do this. Let me instead say not equality, but and check if it's in a Let me say if s is in-- and here comes, in square in square brackets, quote unquote, then we can go ahead elif s in this list of values, then we can print out, for But this is a bit of a I'm only handling lowercase. So let me go into the mix wait a minute, then maybe capital I mean, weird, but we should I mean, there's a lot of combinations. So this is not going to end well. Or it's just going to bloat And eventually, for longer words, I'm So logically, whether it's in what might be a better design for but who cares about the capitalization? AUDIENCE: Don't use DAVID MALAN: So OK, You could only support lowercase. That's fine. That's kind of a copout, right? Because now the program's AUDIENCE: Convert it. DAVID MALAN: Oh, we could Though I did hear you say we I bet that's going to And we probably don't want with Y, any word starting with N, just want the lawyers happy, presumably. You should probably get an explicit or yes or no. But, yeah, we can actually go maybe smaller. But how do we go about converting this? In C, that alone was going to be pretty the tolower() function on every It just feels like that's a bit of work. But in Python, you're going to So there might very well called tolower() or toupper(). But the weird thing about is that those functions just kind tolower() and toupper() just trusted an argument, that is, in fact, a char. In Python, and in a lot of they introduced this notion of which is commonly described as OOP. And in the world of your values can not for instance, and your data They can also have So if you have a data frankly, it just makes should be uppercaseable, and any number of other So in the world of object-oriented like toupper() and tolower() and in some random library that you can use. They're built into the And what this means is that in here, for instance, is the URL of the otherwise known as methods, So you don't go check like we did in C. You type, the documentation, will see in Python's own methods, come with strings. So a method is just a function. But it's a function that comes So let me propose that we do this. In the world of we can come back to agree.py. And we can actually improve rid of this crazy long list, and just canonicalize So let's just check for lowercase n, lowercase no, and that's it. But to your suggestion, that the user types into to permanently change their input-- we can throw the value because we want to more for membership in this list of values. So one way to do this would be So here's the difference. In the world of C, we tolower and pass in the value s. But in the world of Python, and, in Java is another language if s is a string, a.k.a. what's known in Python as an object. An object can not only have values but also functionality built in. And just like in C, with a struct, if you use the dot operator. And inside of this string, I claim, called lower(). Long story short, the only is that instead of doing lower s, in the world of object-oriented and you do s dot name of the method, and don't need to pass in any arguments. So this actually achieves the same. So let me go ahead and rerun agree.py, That works. Let me run it again, That works let me run it again, Let me type in capital all uppercase YES. That too works. Let me try no. Let me try no in lowercase. And all of these permutations because I'm forcing it to lowercase. But even more interestingly, in Python, person, if you have a variable s that function, and then you're immediately you can also chain method calls together We can get rid of this line altogether, And so whatever the return value of Whatever the human types force it to lowercase and then assign called s. You don't actually have to wait altogether. Questions, then, on any of this? No? All right. Let me do one other that's reminiscent Let me go into VS Code Let's close both the C and And let's create a program called is to actually uppercase a whole string. In the world of C, we had to do this And that's fine. I'm going to go ahead in Python, whereby I want to But unfortunately, before need some way of looping in Python, So we need one more And, in fact, if we were to we'd see this and much more. So, in fact, here's a list of all of And it's actually not because so much of the functionality like strings and integers Here is the canonical source of So as opposed to using which is meant to be a available documentation, point you to the official docs. I will disclaim they're not really And they'll generally leave some But at this point in might be a little good to see documentation because that's what you're And so you'll get used to it But with loops, let's that we can compare to Scratch. Here, for instance, in Scratch, is how times, like meowing on the screen. In C, there were a bunch And the clunkiest was maybe where we declare a variable and then, iteratively, increment i until it equals 3, each In Python, we can do this in The nearest translation of C It's almost the same, and but you don't specify int, and You don't have curly braces. But you do have a colon. You don't use printf(). You use print(). And you can't use i++, but So logically, exactly It's just a little tighter. I mean, it's a little easier to read, if you will. You're defining all of these. You're defining this variable Well, recall that in C, we could also was probably more cryptic But odds are by now, you're in the habit of using In Python, though, we We've seen how, in square brackets, you and so forth. Well, let's just do the So if you want Python to do a list of three values, like 0, 1, that many times. Now, this is correct, Even if you've never seen Python Why is this probably not the right way AUDIENCE: Because if you like, three times, you DAVID MALAN: Yeah. If you want to do it four times, I mean, surely, there's a better way And there is. In fact, in Python, there's a function to you very efficiently And by default, it hands you the And if you want more than that, you just how many values do you want. So if you passed in range through 49, which effectively allows So this is perhaps the most And this is actually a term of art. Pythonic isn't necessarily But it's the way to do something based So it's pretty common to do this. But there's some curiosity here. Notice I'm declaring a variable i, In fact, I don't even sort of happening automatically. Well, what's really happening on every iteration of this loop, Python So initially, i is 0. Then it goes through an iteration. Then i is 1. Then i is 2. And then that's it if you But there's this other technique whereby if you're the programmer, care about the name can actually change it to an underscore, It just signals to the reader, your that it's a variable, and you need But you don't care about because you're not going to So that might be an even more But if you're more and using the variable more Underscore does not It's just a valid character So this is convention, nothing What about a forever loop in Well, over here, we can just use again and again and again. In Python, it's almost the same. You still get rid of the curly braces. You add the colon. You get rid of the semicolon. But there's a subtlety. What else is different here? Yeah? So True is uppercase. Why? Who knows? The world decided that in and False is capitalized. In many other languages, It's just a difference that you All right. So now that we have looping constructs, And recall that I proposed that we force an entire string to uppercase. And in C, we would have done this with a But what's nice in Python to loop in Python than it is anything that is iterable. A string is iterable in the sense from left to right. So what do I mean by this? Well, let me go ahead let's first prompt the user for a equal to the return value of input(), colon. Then let's go ahead, as we did weeks &quot;After,&quot; just to make clear to the user Then let me go ahead and for-- and previously you saw me characters, I'm actually for c in before, colon, And that's it. Now, this is a little But let me run this-- Let's type in something like Enter. All right. Well, you see &quot;After,&quot; and I that it is capital C, capital A, And in order to fix to introduce something that's So let me actually go ahead and by actually passing in another And this is a little different But if I go back to VS that there's two One, I did not want the new line Why? Because, just like in week 1, or in week 2. And I don't want a new though at first glance it might have seemed nice that Python it can backfire if you don't So the syntax is going But in Python, with if you want to change the character of every line, you can literally pass in equal to something else. So if you want to set it and that something else is You can actually specify end=&quot;&quot;. Down here, too, if you want to specify characters should be nothing, What this implies is that the default value of this end parameter So if you want to override you just literally And now if I clear my-- if I type in cat in all oh, two minor bugs here. One was just stupid. I had one too many spaces here. But you'll notice that I didn't after CAT was printed in all uppercase. And that we can fix by It turns out when you don't it automatically gives you just So I think this will move So let me clear it now, and hit Enter, type in cat in all and now I have indeed capitalized by character, just like we did in C. But honestly, this, too, it turns out I don't need because strings themselves And if you were to visit the you would see that indeed, upper is a and you don't need to call it I could instead get rid of all for instance, I can just And the upper() function that comes to every character they're in and, So let me go ahead and try this again-- enter, and indeed, it Let me take this one step further. Let me go ahead and combine Let me go ahead and, for instance, let Let me change my logic to be after And now I can use one of those f strings And I can get rid of I can specify this is an f string. So I'm just changing logically so that now I have is the uppercase version of before. And now, if I do python of uppercase.py, And if I-- actually let if I run python of uppercase.py, And lastly here, if you creating another variable put short bits of code inside So I, for instance, could go and not just put a variable name. I can actually put Python code inside of And so now if I run Python even that too now works. Now, which one is the best? This is kind of reasonable to put I would not start writing long that start to wrap, no just going to be a matter of bad style. But this, again, is to say that to solve each of these problems. And so up until now, we've end is the first parameter we've ever Up until now in C and up we've always been assuming that What matters is the order in which you else. Whew. OK, that was a lot. Any questions about any of this here? No? All right. It feels like a lot. Let's take our 10-minute break here. Fruit roll-ups are now served. We'll be back in 10. All right. We are back. And recall that as we left off, And we'd seen a bunch of we could get, say, a cat to meow. Let's actually translate and start to make sense of some of like creating our own functions, at the very beginning, and actually So let me go over to VS Code here. Let me go ahead and create a program as in the past. And suffice it to say if you want we can do better than just saying print(&quot;meow&quot;). This, of course, would work. This is correct if the goal is to But when I run python of meow.py, but this is just not good design, right? We should minimally be using a loop. So let me propose that we improve this And I could say something go ahead and print out So this is better in the sense that But if I want to change this to a or something like that, I can different places-- so just, But what if now, much I wanted to create my own meow() of those languages as well. Well, as a teaser at saw that you can define with this keyword def, which is a But let me go ahead and do this indeed meow(). So let me go ahead and do def meow(), I'm just going to literally do for now, And now down here, notice, I can And I can go ahead and call And this is not the best But Python does not constrain me to as we've seen thus far. But I can define my own like a helper function called meow(). So let me go ahead and just run and run python of meow.py. That does seem to work. But this is not good design. And let me go ahead and actually now let me call the meow() function. And this, too, should work. If I do python of meow.py, But I very deliberately I defined meow at the top of my file. But that's not the best when someone opens the file for a TF, a TA, a colleague, you'd like at the top of the file, just because and know what this file is doing. So let me go ahead and practice what of my code, even if there's at the top of this file. So now I have the loop at the top. I'm calling meow() on line 2, and Well, instinctively, you can If I run Python of there's one of those tracebacks And here, my error is And you'll notice that, huh, And so previously, we saw a different Here we're seeing a that Python does not recognize And intuitively, why might that be, Yeah? AUDIENCE: [INAUDIBLE] top to bottom. DAVID MALAN: Yeah, Python, too-- as it still takes things pretty literally, So if you define meow() on line OK, so I could undo this, But let me just stipulate that as it's probably naive to assume I can just above, above. And honestly, that's going to move to the bottom of the file, which is sort So it turns out in Python, even though it's actually quite common So what I could do to Let me go ahead and define a function in this case. Let me indent that same code beneath it. And now let me keep meow() So if we read this literally, on line 1, And it will do what is On line 6, I'm defining and it will do what's prescribed on even though the keyword def If I run, though, like to think I'll see three meows. But I see nothing. I don't see an error, but I see nothing. Why? Intuitively, what explains I didn't call main(). So this is the thing even though it's function, but it is conventional in you have to call the function yourself. It doesn't get magically So this might seem a little stupid-- and that's fine-- but it is Generally, the very last line of your call main(), because this satisfies on line 1 meow() is defined on line 6, 10. So line 10 says call main(). So that means execute this code. Line 3 says call meow(), So now it all works because the You can think of C as just this line there for you the whole time. But now that we have our own functions, implementation of meow() to maybe an argument itself. So let me make a tweak here. Just like in C, and I can actually let meow() meow So let me do this. Wouldn't it be nice, instead to instead just distill main() into in the number of times you What I could do in meow() here And I could call it anything I want. I'm going to call it n for And then, in the meow() for i in range of, not 3, but n now, that is of variable And then I indent the And this should now Let me run python of meow.py. Enter. And there's 3. But if I change the 3 to a 5 and now I'm getting five meows. So we've just seen a third can implement the idea of meowing And I can assume now that meow() exists. I can now treat it as out It's an abstraction. And frankly, I could even put it into like we've done with CS50, and make So the takeaway here, really, can, similarly to C, But you should understand as to what gets called All right. Other differences or Well, recall that in C, Truncation is whereby if you, for and it's a fractional answer, gets truncated by default because gives you an int. And if you can't fit the remainder in gets cut off. So what does this mean? Well, let me actually Let me go ahead and open, and let's change up what Let me do this. Let me define a variable called x, prompting the user for x. Let me ask the user for y, let and let me proactively And I'll do it in one pretty one-liner And on the honor system, I won't type dog, even really complete without error checking. Now, let me go ahead and z = x / y, and now let's just I don't need a format code. I don't need an f string. If all you want to do is print a You can just say Let me run python of Let's type in 1 for x, 3 for y. I left out a space there. And oh, interesting. What seems to have happened here? Let me fix my spacing and rerun this 3. What did not happen? AUDIENCE: It doesn't truncate. DAVID MALAN: Yeah. So it didn't truncate. So Python is a little to converting one value to another. So an integer divided by giving you this fractional you'll get back what is Well, what else do we want to Well, recall that in C, we had this whereby if you want to represent of paper, it's, like, because the 3 infinitely repeats-- but we saw a problem in C played around with some value. So, for instance, let me And this is going to be the ugliest But there was a way in C, using %f, of digits after the decimal point, In Python, there's something similar. It just looks very weird. And the way you do it in Python is this. You specify that you want an And I'm just going to start f before &quot;&quot;. If you want to print out z, you And so this is just an f string, So it doesn't do anything more than it passed in z. But as soon as you have configure the variable to print So if you actually want to print just to see a lot, you can So it's just using the curly But you then use a dot you specify the number of digits that it's a float. Honestly, I google this all the time But the point is the All right. Let me go down here and rerun And unfortunately, if I divide 1 by Floating point precision So be mindful of the fact that in the world of Python. Floating point precision remains. If you want to do even better exist a lot more libraries, that can give you much greater financial purposes, or the like. But what about another problem If you just count to high, recall overflow the capacity of an or worse, going negative altogether. In Python, this problem does not exist. In Python, when you int, even though we haven't it will grow and grow and grow. And Python will reserve more and more So it is not a fixed number of bits. So floating point imprecision Integer overflow-- not a problem so a difference worth knowing. But what about other features of Well, let's actually revisit one of I ran into earlier, to see how So let me go back to VS Code here. And just for fun, let Let me clear my terminal. And let me change my calculator to We've seen how to define Let me not bother with the CS50 library. Let me just invent my own So def get_int(), and just I'm going to have get int take a prompt, for an integer. And now I'm going to go ahead and passing that same prompt to just like get_string(), shows But I do want to convert So this is just a one-liner, really, So this is kind of like what CS50 did Why? Because there's a problem with it. So let me do this. Let me define a main() Let me use this implementation of Let me use this get_int() And then let me do something And then, very last thing, And this is a minor point, putting multiple blank This too is Pythonic. It's a matter of style. style50 It's just meant for larger files to and be a little more separated All right. Let me go ahead and run Enter. Let me type in 1. Let me type in 3. And that actually works. 1 plus 3 is 4. Let me do the more obvious. 1 plus 2 gives me 3. So the calculator is in fact working don't cooperate and type in Then we get that same but I'm seeing it now in this file. And let me zoom in on my We don't need to see Let me type in cat, Enter, and And you'll see that, OK, multiple functions involved. So what's going on? The first problem is But that's not actually the problem function. So on line 6 of calculator.py, so, again, it's tracing everything that and value error-- invalid 'cat,' which is to say, like before, other base. It just cannot be So how do you fix this, or, really, You won't have to write But it turns out that Python And generally, an of handling certain types of that the only way we is by having functions malloc() could return null, Something went wrong. Some functions we wrote in C could return negative 1. Recall that we could write our to indicate something went wrong. But the problem in C is that if be it null or 1 or 2 or 3, your function as actual values. Why? Because other people are going So you kind of have to use up some in a language like C and treat In Python and other languages-- Java and others-- you You can instead have more out of band And that's what's happening here. When I run calculator.py and I is actually an exception. It's something exceptional, This exception means this The type of exception happens And within the world of Python, there's a whole list of possible exceptions. ValueError is one of the most common. We saw another one before, meow when Python didn't So this is just an But what this means is that there is myself. So I'm actually going Instead of get_int() simply blindly of whatever input the user gives me, this instead. So it's kind of a aptly named phrase. It literally means that. Please try to do this, except except if there is a I want Python to do quote unquote, &quot;Not an integer.&quot; So what does this mean? It's a little weird, the syntax. But in the get_int() function, Python It will try to get an It will try to convert it to an integer. And it will try to return it. But if one of those operations fails, then an exception could happen. And you might get what's Why? Because the documentation Or, in my case, I and now I want to catch this So if there is a to see that crazy traceback anymore. I'm instead going to see, quote But what the CS50 library lets you try again and again and again. Recall in the past, if I it's just going to keep until I actually give it an int. So that kind of implies that we really And the easiest way to is to loop while true, just like And what I'm going to do now is here because what's it going to do? It is going to try-- it's It's going to try to get an input, And just like break return also breaks you out Because once you've returned, there's no So long story short, you won't have But this is essentially what the CS50 the Python version of get_int(). So what happens now? If I run python of calculator.py, but I'm prompted again I type in dog. I'm yelled at, but I'm prompted again. I type in bird, yelled at, If I type in 1, then I because it tried and succeeded this last time. And technically, the CS50 yell at you with &quot;Not an integer.&quot; So technically, if you want to catch the exception, you can and it will just silently So let me go ahead and run this. python But notice now it works It doesn't yell at you, but it does But I'll do 1 and 2, and So that then is exceptions but you yourself won't have to Well, what else can we now do? Well, let's revisit something recall, whereby we had this in the way for Mario, like Let me actually play around now just to see how there's different resonate with you just in terms of the Let me go ahead and create And suppose that I want to It kind of doesn't get any So for i in range(3), just go done. That then is what we took us But if I run mario.py, that I could change the i to an bad to remind myself that i is Well, what else could we do beyond this? Well, recall that in the world of for a specific height. We didn't just always hardcode 3. So I could actually do Let me actually open up from today's and pull up this C version of Mario. So this was from some And this is how we ensures that we get a positive integer and is not positive, and to actually print out that many hashes. Now, in Python, it's actually except for the fact that in But recall that a do because it means you can get the user to maybe try again, maybe try again. So it's really good for user input. So let's actually do this. Let me borrow the CS50's just so we don't have to re-implement Let me, in Python, do In Python, if you want to prompt the and again, potentially, you induce an infinite loop. You just get yourself But the goal is going to be try something, and as soon as you have instead. So we're implementing the idea So I'm going to do this. n, and let's ask the user for a height. Then let's just check. If n is greater than 0, you know what? Break. We've got the value we need. And if not, it's just going to and again. So in Python, this is to deliberately induce an infinite what you want. All right? Now I can just do the same kind of rage sometimes-- for i now I can go ahead and print out-- oops-- a hash like this. If I open my terminal window, it's but now mario is going to So I could type in 3, or I could be uncooperative and And because I'm using the Because I'm using my while of it only when n is positive, I'm So, again, this would be a Pythonic way If I want to maybe enhance this a for instance, we consider something or the horizontal So recall that some time like, four question marks looked a little something like this. Now, the very mechanical way Let me close my C code. Let me clear my terminal. And let me just delete my And let's just do this-- for and print out a question I'm going to run python and, ugh, it's still a But what's the fix here, perhaps? What's the fix? Yeah? AUDIENCE: The end equals [INAUDIBLE] DAVID MALAN: Yeah. We can use that named to just suppress the But let's give ourselves one just to move the cursor correctly. So now if I run python looks like what it might But it turns out Python has some neat if you will, for doing It turns out in Python, You could just say print(&quot;?&quot; * 4). And just like + means really, multiply the string by of automatically So if I run python of again, just some features of pleasant to use so you don't always a loop or something along those lines. Well, what about something like in the world of this brick here? Well, in the context of we might do something Let me go back to mario.py, and let like we did in week 1. So for i in range(3)-- I can nest loops, just like I can then print out a hash here. And then let's leave this alone even Let's do python of mario.py. OK, it's, like, nine bricks all in wander to the end parameter again. So, yeah, let's fix this-- end=&quot;&quot;, let's just print out a new line. So this logically is the same I'm now doing it in Python, just without a conditional, I'm just relying I can tighten this up further, frankly. If I already have the outer loop, I could print out a single hash times 3. And now if I run python of So I can combine these ideas The goal is simply to seed you All right. How about code that was maybe a Well, in Python, we indeed have some And lists are denoted by reminiscent of the world of arrays. But in Python, what's is that their memory is An array is about having In Python, a list is It will allocate memory for you And you do not have to You do not have to know about nodes. You do not have to implement You just get list as a Here, for instance, is some of the And in particular, lists have methods, functions that just make it easy So, for instance, if I wanted to maybe of scores, like we did some time ago, of lists and the function called which will tell you Now, how might we do this? Well, if we read the it turns out there's other functions So let me go back to VS Code here. Let me close mario.py. And let me open a file called we did weeks ago, too. Let me go ahead and, just give myself a variable called or whatnot from weeks ago. So I'm using square brackets, not curly or a list in Python. And let me get the Well, I could do this-- average you just get a lot of And those functions sometimes but lists as their arguments. So, for instance, I can use Python's in those scores. I can then divide that sum by the So length of a list just tells So this is like doing magically 72 plus If I want to now do the math So I can print out, using an f string Let's print out that average here. So let me do python of is the average, slightly imprecisely. But at that point, I'm So that's fine. So at this point, we've seen that we In C, how would we have I mean, we literally created a variable. We then had a loop. We iterated over the array. We added things together. It was just so much more work. It's nice when you have a language that among them sum(), that just But suppose you actually want In C, we used an array, and We can do something a Let me propose that instead of let me do this. from Now let me give myself an empty equals open bracket, closed bracket. And unlike C, where you just can't do and I'll figure out the length to pointers and memory you can absolutely give yourself Now let's do this. for prompt the human for three test scores. So the first score will be prompting the user for their score. And now, if I want to add this here's where methods that come with objects, like lists. I can do scores, plural-- because that's the name of my and I can append that score. So if we read the documentation you will see that lists come with a which literally just tacks a value onto like all of that annoying code we pointer and pointer and pointer malloc() a new node. Python does all of that for us. And so once you've done that, now I The average equals the sum by the length of that list of scores. And I can again print out, with in that variable like this. So, again, you just have more when it comes to something like this. You can also do this, just It turns out that instead of doing You could concatenate scores with itself This looks a little weird. But on the left is my variable scores. On the right here, I am taking and I'm adding the current score And this will update the value as we go. But it does, in fact, as opposed to appending All right. How about some other Let me propose this. Let me close out scores.py. Let me open up a file reminiscent of what And let me give myself a list of names. We won't bother with numbers just yet. Let's just play with So here is a variable called names. It has maybe three names in and John Harvard, as in past weeks. And now let me go ahead and because this is going I want to ask the user for that person's name and the phone by having any phone numbers just yet. How could I search for, a la Well, in Python I could rather, for n in names, if the current then go ahead and print out &quot;Found,&quot; Otherwise, we'll print out All right. So let's try this-- Let's search for maybe Carter. That's easy. He's at the beginning. Oh, hmm. Well, he was found, but So that's not quite what I want. How about David? D-A-V-I-D. &quot;Found,&quot; &quot;Not found&quot;-- all right, not very correct. How about this? Let's search for Eli, not in the list. OK. So at least someone not But logically, for Carter, why are we seeing &quot;Found&quot; Why is it not found? Yeah? AUDIENCE: You need to DAVID MALAN: OK. I don't have seem to have indented If I just go with the else here-- let me go up here and I'm not sure logically because what I think this is going OK, that worked. So it's partially fixed the problem. But let me try searching Oh, now we're sort of &quot;Not found,&quot; &quot;Found.&quot; Why? Well, I don't think we want that someone's not found equal the current name in the list. So it turns out we could fix this But there's kind of a In Python, even for loops And this is weird. But the way this works is as follows. In Python, if you break out of a If, though, you get all the way through and you never once call line 8-- Python is smart enough went through lines 5 through 8. You never actually Here's an else clause to Semantically, this is weird. We've only ever seen if and But for loops in Python And in this case now, if I do python now we get only one answer. If I do it again and type in Do it again with John. Now we get only one answer. Do it with Eli. Now we get only one answer. So, again, you just get a few when it comes to a language like Python problems a little more pleasant. But this is kind of stupid in Python. This is correct, but because I don't need to iterate like we've been doing for weeks in C. I can actually tighten this I can get rid of the loop, and I can quote unquote, &quot;Found.&quot; That's it in Python. If you want Python to search a just let Python do the work. And you can literally just say if in names, which is this list here, search automatically from left to right, And if it doesn't find it this else clause execute instead. So, again, Python's some time because this, too, will for instance, Eli. All right? So we get that functionality for free. But what more can we perhaps do here? Well, it turns out that we might want to explore, namely And a dictionary in Python is in computer science in general. A dictionary was an abstract data type. And it's a collection of key value pairs If in C, if in Python, you want to associate something with you had to, in problem set 5, by implementing an entire spell to store all of those In Python, as we saw earlier, you more simply, a dictionary that set 5's ideas. But Python does the A dict in Python is essentially a hash So what does this mean for me in Python? It means that I can do some So, for instance, let me and let me change my phone Let me give myself a So people is now going And I'm going to demarcate it and closed square bracket. And just to be nice going to have these people no longer as in the previous example. But I want each of the elements pair, like a name and a number. So how can I do this? In Python, you can use this syntax. And this is, I think, the last of You can define a dictionary by using two curly braces like this. And inside of your curly the name, the keys, and the values. So if you want one key to be quote unquote, &quot;name&quot; and If you want another key to be &quot;number,&quot; and then, quote unquote, something for instance, for Carter's number there. And collectively, everything here It's as though, on a chalkboard, I +1-617-495-1000,&quot; row by This is simply the code If you want to be you could style your which makes it a little more clear, It's just starting to add a lot But it's just a collection again, akin to a I'm going to undo the whitespace just want to cram two other people in here. So I'm going to go ahead and do quote unquote, &quot;name&quot; and and we'll have the same And then, lastly, let's do another &quot;John,&quot; and John Harvard's number, let's see-- &quot;949-468-2750&quot; is And then, by convention, you typically But it's not strictly But stylistically, that's So what is people? people is now a list of So what does that mean? It means I can now do code like this. I can prompt the user with the input() now is to look up that person's number. How can I look up that number? Well, for each person in the list of If the current person's name equals typed in, then get that person's number quote unquote, &quot;number,&quot; and print out something like this f And then, since we found them, And if we get through that whole thing, out &quot;Not found.&quot; So what's weird here? If I focus on this code here, The square brackets, though, just Hey, Python, that's it for the list. Inside of this list The curly braces mean, hey, Hey, Python, that's Each of these dictionaries &quot;name&quot; and its value, So you can think of each of these like with typedef and struct. But I don't have to decide in are going to be. I can just, on the fly, again, reminiscent of this All right. So what am I actually doing in code? A dictionary in Python similar to an array with is a little bit different. In C, you might have been in But because it's a dictionary, is you actually use square as being inside the square But all this is now doing is it's setting that number equal to Why? Because we're inside of over each person one at a time. And that's what for-- that's what n does. It assigns the person variable to then this dictionary no need for i and i++ and all of that. So this is just saying, if equals the name we're looking for, get that person's number, and then So whereas last time we were just now I'm going to print an actual number. So if I run python of phonebook.py there then is his number. If I run python of phonebook.py, type And if I search for someone who's not So what's interesting and is they're kind of known as the in programming because in so many interesting, clever ways. If you ever want to associate a dictionary is your friend. And you no longer have to write You can write single lines of So, for instance, if I, too, I actually don't need An even better version of I don't need this though this will look a little uglier. Notice that I'm only creating because I want to set it But strictly speaking, any and then used it in the next line, So I could do this. I could get rid of that line. And instead of printing I could actually do and you might be inclined to do this. But this is going to confuse Python on the inside and the outside. But you can use single So you don't have to do it this way. But this is just to you can put most anything you so long as you don't confuse But let me do one other thing here. This is even more powerful. Let me propose that is names and numbers, names simplify this dictionary significantly. Let me actually redeclare to be not a list of dictionaries, but Because if I'm only I don't technically need called &quot;name&quot; and &quot;number.&quot; Why don't I just associate Carter Why don't I just associate, quote +1-617-495-1000? And then, lastly, let's just associate And that too would work. But notice that I'm going to and instead just have one dictionary is that you can only have one key, You can't have a name key and a number and any number of other pieces But if you've only got we can tighten up this code I can actually do this. If the name I'm looking for is then go ahead and get by going into the people dictionary, and then printing out &quot;Found,&quot; making this an f string, and print out &quot;Not So, again, the difference is a list of dictionaries, methodically, iterated over But what's nice again that Python gives you a lot of support And this syntax, just like you can use it for dictionaries as well. And Python will look for that name And if it finds it, you use this Whew, OK. A lot all at once, but are there We'll then introduce a couple of Yes? AUDIENCE: This way DAVID MALAN: In this case, because I don't have any loop involved. So break is only used, as we've over something when you want But here Python is doing So Python is taking care All right. Just a couple of final features so blocks-- here is the documentation in case you want to poke around as But it turns out that there come with Python, not even is the sys library, whereby you And here's its official But what this means is that immediately available in C is sometimes in Python. So, for instance, let here, and let me just create a is reminiscent of an old the user using command-line arguments. But in C, recall that we got access and argc and argv. But none of those have And, in fact, main() itself So if you want to do you actually do this. From the sys library, you can So argv still exists. It's just tucked away inside of this And I can then do this. If the length of argv, for well, then, we're going to or rather, let's do this. If the length of argv going to go ahead and do ago, whereby I'm going comma, and then argv so whatever is in Else, if the length of argv the human did not type let's go ahead and print out So we did the exact same thing in C. The is how you get access to argv. So let me run this-- python of greet.py get. And actually, I got an extra I included backslash n, but So let me fix that. python But if I do python of now notice that argv equals 2. If I instead do something like But there is a difference. Technically, I'm typing three words at but argv still only equals 2 because It's only the name of your file So that's then how we might print Well, what else might we do using Well, it turns out that you can exit library. So let me close greet.py. Let me open up exit.py just And let's do something like this. Let's import sys. And if the length of sys.argv-- so here's just another And actually, I'll do it the same If the length of argv does not equal 2-- well, let's actually yell like &quot;Missing command-line argument.&quot; And then what we can do is exit out of which is a function therein. But notice that exit() So you know what? It's actually more Let's just import all of sys. But because that has not given let me do sys.argv here Otherwise, if all is well, let's like &quot;hello, sys.argv,&quot; bracket 1, close so-and-so.&quot; And when I'm ready to with a 0 exit status, I can actually So just like in C, if you want to or anything else, you can use sys.exit. And if you want to exit with a So we have the same just accessed a little bit differently. Let me propose that-- let's see. Let me propose that-- how about this? How about this? If we want to go ahead and create recall that there was that pip, whereby I ran pip That's one of the examples And that allows me to install more into my own code space or my Well, we can have a little Let me go back to VS Code here. And just like there's a whereby you can get the you can also use this So if I do pip install cowsay, will install a library called cowsay. And what this means is that if I called, like, moo.py, I can and I can do something because there's a function and I can say something like How do I run this program? I can run python of moo.py, If I increase the size of my terminal we have that same but I now have programmatic capabilities And so, in fact, I could make this I could do something like name = quote-- or rather, name = input(&quot;What's of today's ideas. And now I can say not &quot;This quote unquote, &quot;Hello,&quot; And now, if I increase the size of it's not going to actually It's going to say something like And suffice it to say you can do not only cows but But even in Python, too, can but actual art and actual images. And the note I thought we'd end I'm going to go back into VS Code here. I'm going to close moo.py. I'm going to do pip install qrcode, that I might want to install to And QR codes are these If you want to generate you don't have to go to a You can actually write So how might I do this? Well, let me go into a new And let me do this. Let me go ahead and import Let me go ahead and create a variable Let me set it equal to this make-- no relationship to because you want to make a QR code. Let me type in, maybe, the URL of so, like, youtu.be/xvFZjo5PgG0, And then I can go ahead and do img.save which is a different data type it doesn't come with Python per se-- I can save a file like qr.png, And I can Network Graphic. And so just to be clear, do for me is create a QR code but not as text, but rather as I can post online, or, in our and then open. And so, with all that said, today, a bunch of new features. But the ideas underlying Python are It's just that you don't have to do And here, for instance, in can you generate a massive as you can in a moment with link to something like a CS50 class. So let me go ahead and It seems to have run. Let me run code of qr.png, I'll close my terminal window, to scan this here very CS50 lecture. And-- and-- is someone's volume up? [RICK ASTLEY, &quot;NEVER GONNA GIVE YOU UP&quot;] There we go. What a perfect ending. All right. That was CS50. We'll see you next time. [MUSIC PLAYING]