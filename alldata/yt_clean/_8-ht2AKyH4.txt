Memory, is one important and crucial resource always good to know the architecture of memory, system manages memory and the way memory is programmers. In this lesson we will discuss the concept memory and we will see how to work with dynamic C++. The memory that is assigned to a program or typical architecture can be divided into four One segment of the memory is assigned to store the instructions executed. Another section stores all the static or global variables that are not declared inside a function, whole lifetime of an application, they are whole life cycle of the application as long One section of the memory is used to store function calls and all the local variables stack in our lesson on Call by Reference. Local variables are declared inside a function and they live only till The amount of memory set aside for these three segment, the global variable segment and the while the application is running. We will come back to why we use this fourth segment- heap , in a while. Let us first understand how these three segments of the memory are used when I have a simple C program here. We have a function square that gives me the square of a number. We have another function Square of Sum that given two arguments x and y, and it returns And, in the main method, I am just calling passing it two arguments a and b. Let us now see what happens in the memory when this program executes. Let us say this rectangle in green here is memoryreserved as stack and the rectangle memory reserved as Static or Global variable When the program starts executing, first the main method is When the main method is invoked, some amount of memory from for execution of main. And this total is a global variable, so it in the global section. The amount of memory allocated in stack for execution of main can also be called the stack main. All the local varibales, arguments, and the function should return back to, all this information stack frame. The size of the stack frame for a method is when the program is compiling. Now, when main calls Square of Sum method, let's write shortcut SOS, for Square is allocated for the call to Square Of Sum, and z will sit in this particular stack frame. Now, Sum of Square calls Square,lets again put a shortcut here for for square and it will have its own local At any time during the execution of the program, the function at executing and rest are kind of paused, waiting return something and then it will resume execution. I have drawn these play and pause button here, in case you do total is a global variable , it's here in Global variable because it is not declared inside a function. We can access it anywhere, and then we go to this particular statement Sum, and Square of Sum is calling Square and stack. This program may not be the best way to implement I have written this program this way so that methods calling each other. Let's say right now we are at this particular statement, we are executing this statement. So, at this stage the call stack will have these three methods. Now, when this method finishes, we will return back to this particular statement. As soon as Square function will return, it will be cleared from Square of Sum function will resume. Once again when Square of Sum finished, the control will come to this particular Square of Sum and main will resume again. Now, main will call printf, so once again printf will go to the top of the Printf will finish and the control will come back again to main and now And, now main finishes, program will also finish.So, will also get cleared. There was no need in this program to keep variable total as global. We should assign a variable as global only is needed at multiple places in multiple functions the whole lifetime of the program, otherwise keep a variable for the whole lifetime of We had kept one global variable in this program just to Here, I must point out one more thing, when operating system allocates some amount of allocates 1 MB of space as stack, but the frame and the actual allocation of the local stack during runtime and if our call stack memory for the stack like for example, if and we go on calling and we exhaust the whole stack, then this is called stack overflow crash. One common case of stack overflow is when recursion and your program goes infinitely So, as we can see, there are some limitaions of stack. The memory set aside for stack does not grow during runtime. Application cannot request more memory for stack. So, if it is 1 MB, then if the allocation in stack exceeds 1 MB, our program will crash. Further the allocation and deallocation of memory onto the stack happens When a function is called, it is pushed onto the popped out of the stack or removed from the It is not possible to manipulate the scope of a variable if it is Another limitation is that if we need to declare a local variable, then we need to know the size time only. If we have a scenario like we have to decide array will be based on some parameter during problem with stack. For all these problems, like allocaing large memory or keeping variable in the memory till have heap. Unlike stack, application's heap is not fixed. It's size can vary during the lifetime of the application and allocation or deallocation of the memory. A programmer can totally control how much memory to use from the heap, the data in the memory during the applications grow as long as you do not run out of memory That is a dangerous thing also and we need to be heap for this reason. We also sometimes call heap, free pool of or free store of memory. We can get as much as we want from the heap. How heap is implemented by the operating system, the compiler, is something which can vary, architecture. But an abstracted way of looking at the heap programmer is that this is one large free that we can use flexibly as per our need. Heap is also called dynamic memory and using the heap is referred to as Let us now see how to use the heap in out I will clear this code in the left and I will draw one heap. there is one more thing that I must point forward. Heap is also one data structure and if you this data structure Heap yet, you will learn Structure course. But this nomenclature here has nothing to heap data structure. The term heap is being used only for the large pool of memory. Heap data strcutre does not come anywhere context. This term often confuses a lot of people when heap data structure. Stack is also one data strcutre but the stack segment of the memory is actually an implementation structure but heap is not an implementation To use dynamic memory in C, we need to know malloc, calloc, realloc and free. To use dynamic memory in C++, we need to know about two operators new and delete. These four functions can also be used in C++, as C++ has backward compatibility. It is only a superset of C. But C++ programmers use mostly new and delete. We will see some code examples and try to how things happen when dynamic memory is used. Let us first pick up some code examples in C. Let us write a C I will clean up some of the stuff in the right. 1 MB for stack, this was just an assumption. In reality, the size of the stack will be decided the compiler. It is a thing of computer architecture. Coming back to the code, if we declare a variable like this, variable. It goes on the stack. Memory for this particular variable a' will be allocated from the stack frame of the main Let us say we want to store an integer on the heap. To reserve, or get some space allocated on the heap, we need to call the like this. The malloc function asks for how much memory the heap in bytes. When we say malloc and pass as argument size integer, then we are saying that &quot;Hey, give is 4 bytes. 4 bytes is the typical size of So, one block of 4 bytes will be reserved or allocated on the pointer to starting address of this block. And, malloc returns a void pointer. Let us say, the starting address of this block then malloc will return us address 200. Now, we have a pointer to integer p, which is a local variable to main. So, this will be allocated in the stack frame of the main method. We have done a typecasting here, because malloc returns pointer to void, sorry, integer pointer. Now, p stores the address of this block of is 200. So, we have got some block of memory on the want to use to strore an integer. Right now, we do not know what's there in this particular block of memory. If we want to fill in something here, we need to dereference this location using some value. In fact the only way to use memory on heap reference. All the malloc function does it, looks for the heap, books it or reserves it for you And the only way you can access this particular variable which will be local to your function. Now, let us write something like this. After writing 10 in this particular block, make one more call to malloc. When I make one more call to malloc, one more block of 4 bytes is allocated on the is 400 for this block. Now, the address that is returned by the second call to malloc, we store this address in the So, what happens is, that p is now pointing to the address The next line writes address 20 to this address. We allocated one more block and we modified the address in p to point to this The previous block will still sit in the heap. This memory we are still consuming, it will cleared off automatically. At any point in our program , if we are done using some block of memory which is dynamically malloc, we also need to clear it, because of memory which is an important resource. So, what we should have done here is that once we were done using memory at 200, we should have made a call Any memory which is allocated using malloc, is And to free, we pass the pointer to the starting block. So, now with this code this first block of cleared and then we will be pointing to anohter It is the responsibility of the programmer to clear has allocated it and does not need it any So, you see, in terms of the scope of the variable, anything allocated automatically deallocated when the function And, it does not need to live for the whole like a global variable. We can control when to free anything on the when to deallocate anything on the heap. If we wanted to store an array in the heap, like let's say we wanted to store heap, then all we do is make a call to the memory equal to the total size of the array So, if we want an integer array of 20 elements, then we will 20 X size of int which will be 4 number of So, what will happen now, is that one bit of contigous block of allocated on the heap and we will get the So, we kind of get the base address of the This p will point here, to the base address of this block. And then in our code we can use this, 20 integers as P[0], P[1], P[2] and so on. As we know, P[0] is same as saying value at address P, and P[1] is same P+1. This is what it means. One more thing, if malloc is not able to find any free block of memory, is not able to allocate heap, it returns null. So, for error handling, we need to know this need to write our code appropriately.Malloc The use of malloc and free is C style code. If we want to write the same code, same logic in C++, there is not much difference. Instead of using these two functions, malloc and free, we will use two Delete.And, we will write our code something So, instead of malloc, we are using the New operator here we are using delete here. If we want to allocate an array, we use something like this where we put the size And, if we want to free an array, we use this particular brackets, sorry, one bracket. With C++, we do not have to do all these typecastings, like malloc returns void and integer pointer. New and Delete operators are type safe. What it means is, that they are used with a type and return only. So, here p will get a pointer to integer only. We will be talking about dynamic memory allocation and other detail in the coming lessons. So, Thanks for watching!