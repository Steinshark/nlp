Hello, internet, and welcome to this In this course, I'm going to full stack observability on the performance of open telemetry with your analysis tool of choice. or app is running too slow, is broken, or This is the video for you. mean by over telemetry? Well, let's start off with and telemetry, which is an institute collection And that automatic transmission to The word telemetry actually comes from and metron, for measure. we are going to be facilitating a everything we use in our app remotely. looking at this kind of data, you have The first is figuring out how to And then the second part is deciding So in other words, how are you going to analyze Up until now there has been no real standardized This is down to the fact that we use different programming languages, different This was a problem, especially for those At the heart of open telemetry a standardization for describing no matter what programming language Today, the open telemetry project can API's, and SDKs, use it instrument, so that we can analyze it later on with whatever means we are not tied to anything in the long run. to the next super easy, I will As I mentioned at the beginning, It is made up of many, many If we have a look at GitHub here for the You can see the Governance Committee, If you are interested in getting involved, please do join their mailing list You can even see all the meetings Before we get started, though, I just want to learn on this course. Okay, so in this course, first we're followed by what is observability then we're of open telemetry, then we're going to We are then going to talk about tracing, before adding tracing into our project. finally ending on our distributed projects. We expect our websites, apps and online right? Think of the frustration some of us feel on the backend a feat of engineering is needed that you have access to Netflix or Instagram. at Netflix for a minute. of internet bandwidth in the US, there are with activity peaking in the evening. it's a constant pick. zero loss while processing over 400 billion events In today's video, we will dive deeper into what how we can use data to get deeper visibility Historically, developers about applications in monolith will contain all the code for all the This is all fine and dandy But what happens if your application users will like it and begin to depend and always inevitably use requests So more developers are roped into before too long, your application a situation where no single developer Your once simple application multiple independent development Working on the same codebase and simultaneously then it becomes virtually impossible to know code quality suffers, it becomes harder and harder without having to calculate what the teams can lose sight of how that code might be This generally results in slower, less longer and longer development schedules. behind a microservice architecture is that the when broken down into smaller pieces. functionality into multiple independent modules precisely defined standalone tasks. each other through simple API's. split applications into distinct independent It leads to naturally delegating the scaled applications, allowing work to be done impacting the work of other developers in other However, trying to get visibility into When you have hundreds of services and debugging and troubleshooting can be a nightmare. As we already touched on telemetry is defined as about objects that are far away and sending Now. means how well you can understand what is going Especially as systems become It's hard to see what's going on inside your When talking about observability, we need to the performance and health of our application Met, metrics are measurements collected at one or more numeric values and a count These include error rate, response time or output. at any moment in time. For instance, an event could be the moment Adding metadata to events With the vending machine example we item category, and payment type. such as how much money was or what is the most common payment type use. exporting detailed data and So engineers can recreate what You have probably logged something when you use traces follow a request from the It requires the casual chain of between different entities. highlighting inefficiencies, bottlenecks they can be used to show the end to end latency of However, getting that data is very difficult. single service one by one layer by layer. code itself, which is annoying. open source projects as well as in today's 16 open tracing was released as a cn CF Because the libraries were lightweight and While it made it easy to instrument data, it made binaries without a lot of manual engineering work. open source out of Google, which supported both While it made it easier to get telemetry data like Kubernetes, and databases, it made it hard to not part of the default use case. for modern applications and expedite wide adoption However, developers had to choose It turns out that the approaches of rather than contradictory. couldn't have both the abstract vendor neutral In late 2019, the two projects This brought forward the idea observability instead of two competing standards. Okay, so first things first, let's go a bit meta In order for us to view what Here we have our project. have made with our code editors of choice. it runs locally on our machines. built to listen out for requests. for example, we have decided that we want the requests that it makes. as we mentioned at the start, would be to We are doing this to help us standardize the data. and standardize the data, we need to think how we're going to view it, and so on. By analysis tool, I mean, any type we are going to look at a few of these tools, one that focuses specifically on metrics, and We are then going to send our data Here we have an example of what our data can a metrics app such as permittees, and an will give us an overview of everything as well We will go into each of these Let's start with implementing Okay, so before we start, the only prerequisite I am going to ask of you is that you Docker is a container platform for rapid And if you don't know much about containers I have a section dedicated to both of For those of you that don't have it, and follow the instructions. I personally would choose to As I am working on a Mac, I choose the Mac option. desktop is running on a Mac, I would You will see if you open up the platform Having a container is going to be important such as a tracing back end like zipkin. running, let's get going. Now I'm going to navigate to a folder It's called development. any directory that you would like to work in. I'm going to make a folder for the I'm going to call it open telemetry starting out. terminal, other commands may need to be used. the command cd. going to do is start our container. So, as mentioned, the first thing that you is a tracing back end like zipkin, that as quickly as possible, run the latest If you can't, or don't want you could also choose to download zipkin directly. If you want to explore that option more, I So this is the command to run our container. it has worked. file in our project, we can do so by typing NPM. easier for others to manage and install If you are getting errors, it could be because If that is the case, please visit node j s.org. following the download instructions. I am just going to press enter for all So enter and, and, and, and enter. OK, we are done creating our If we list out all the files on our project, using Now finally, I need to create an app js file. to some of you might have a different So that is totally up to you, however But once we are done, we now As I am using VS code, I'm going to use the And there we go. There is a folder with an app You will see the package JSON file as I skipped all the prompts is just the If you go to the app js file, you will also see Okay, so the first thing I need to do is change not the index j s as there is no index js file. to fill out the description on my project. The next thing I want to do So for this script, I'm going to run node app j s. let's get to adding some packages. to need to install some of its packages. I'm going to store the open telemetry core opentelemetry plugin http opentelemetry. zipkin to get us ready for the next section on an express the only non open telemetry one. Okay, and great. So if we look back here, here are They have automatically So this is looking good. So let's go back and use NPM II or install for And we are done. The first thing I'm going to So const port, process and V port or a string of So const Express. And Express is one of the packages we installed. So we need to tell our file that We are then going to call Express The first thing I want to do is just let us know all is good, and that we So just as a recap, what I am doing here And then with this code, I'm getting it to Okay, next up, I'm going to paste This code is an example of a very basic route. end points respond to client requests. of the Express app object that For example, app get handles GET requests. called when the application receives a In other words, it listens out for requests In this case, the root is our homepage, we a get request is made to the homepage. Now that we have the basic installation done, So as you know, open telemetry allows The next part is actually viewing the data in a the scenes, we will do this with a tracing system. a specialized use of logging to record This information is typically used by programmers in a trace log to diagnose any problems that Distributed tracing, however, also called used to debug and monitor applications Distributed tracing helps pinpoint where So as we can now see, being able to important to the overall performance of an app. to systems using all types of different languages, to do without some sort of common approach. so much with distributed tracing. SDKs, and wire protocols. well supported integration service for For this course, the tracer we're zipkin is a distributed tracing system that helps latency problems and service architectures. And it's currently run by the open I am using zipkin for no other But please do feel free to choose any the choice is completely up to you. into applications, they essentially record timing An example of this is when a web server And when it sends a response. like this, and goes by the official name of spam. and a bunch of spans. represents your favorite food delivery app. Now a few things will happen, You send information back and forth from find a delivery driver closest to you, Each of these operations generates a spam showing In this case, the spans have implicit also from individual services and the trace. a different point and takes We call this latency and network latency. an action and a response to that action. that take place within a network. milliseconds and is unavoidable due to the It depends on several aspects of a network errors on most systems are If your bar ends in red or similar, for Now it's time for us to look These two concepts will allow us to So as we know distributed tracing allows us But how do we find these correlations for need to be able to collect, store and transfer Context is divided into two types, span context represents the data required for It contains the following metadata. flags and the trace state of this bond context. A correlation contacts carries This is usually things such as a data region and other telemetry that gives Correlation context is not required and components A context will usually have information so and propagation is the mechanism we use to bundle so that we have it context and propagation. These two concepts represent the If you would like to learn more about these visit the urban telemetry website. however, a basic knowledge above will suffice. section, we will go through how to first initialize and register a trace exporter. Now in the last section, we ran the latest If we actually visit localhost 9411, we will see So here we are, this is what we are Okay, let's carry on. and j s and add the following code. to us by opentelemetry. you can see I am just copying this code You will also see that this file uses two of Once we have pasted that we need to We have already done part of this as this part and the initial setup section. and open telemetry export to zipkin packages. So provide add span processor, This is from the open telemetry tracing package, news of can export out. So the open telemetry exporters, it can this might not automatically show up for you. So you might have to type those two out, and then I'm going to put Getting Started but you Okay, that is looking good. Okay, great. should happen before your application code runs. tracing and a separate file that required using runs, I will show you what I mean by this. our tracing j s and app j s, your application So let's run that. requests to application over HTTP. localhost 8080 page, you'll see traces exported So he will see we are making a get request to the And here we have getting started. We also get a start time and a duration as a span. some spans might appear to be This is because some applications can be both If this is the case, you will see one span one span which is the server side request timing, Okay, now I'm going to show you one more example. to change my service name to get date. I'm just going to copy this And paste. Now I want to essentially listen out to any So in other words, if someone right now that is us making a get request, we will also So let's go ahead, let's go back to our Oops, I stopped my app running, So I'm just going to start this up again. And great, there is our object with today's date. So now if we visit localhost 9411, so the port we exposed, and click run a query, So there we go, we can now And at the moment, the only request we have Now, I have actually renamed the service, you will see that request is also being stored which one it is by the timestamp. Okay, we are now done with a However, we are literally In the project portion of our course I to instrument a distributed system. to trace multiple services and their In this next section, we're going to learn remediate Prometheus as a monitoring platform scraping metrics HTTP endpoints on these targets. configure and monitor our fast app We will download, install and run Prometheus to Unlike tracing which works in spans metrics measured over intervals of time. mathematical modeling and prediction to derive intervals of time in the present and future. processing, compression and retention of data as well as easier querying. dashboards that reflect historical trends. reduction of data resolution. be aggregated into daily or weekly frequency. In this section, I'm going to be using Now that we have set up end to end traces, First, I'm going to stop this from running. and download the latest release. As I'm using a Mac, I'm going Once that has downloaded open a command line and where you downloaded the promethease tarball. Now I need to unretire it into the newly created name with your downloaded harbor. And now let's go into the directory. you will see a file named permit this yamo this just make sure permit is start by running the dot browse to localhost 9090. And that is our promethease user interface. to receive web requests. I am just going to go ahead and open up a new And I'm going to open up our Once we have confirmed that we need to replace the contents of the So literally just delete everything and This will set the scrape We are now ready to monitor In this next section, we need to initialize initialize a meter and collect metrics and To do this, we are going to we are going to need the open So let's go ahead and install that. So don't do this in the And in here, type NPM II or Great, we are now ready to initialize We first need a meter to create and monitor mechanism used to create and manage create a file named monitoring j s. and add the following code. open telemetry metrics package for this Kant's. and buy it I mean, the open telemetry metrics console constant meter. meter provider we're gonna make a as well as I'm just gonna put your meter name Now we can require this file from your to create and manage metrics. In this next part, we're going to create a middleware function that express can So first off, we need to So once again, I'm just going to copy this projects in order to help us count the requests Next, we need to import and use this So our app js file. all requests from our monitoring js file. const count all requests require monitoring j s. Now let's get to using it. when you make requests your service you Perfect. look at initializing and registering a metrics can export them somewhere where you can see that. and registering a metrics exporter is you need to install the Prometheus So I'm just going to use npm install next step, we need to add some more So once again, I'm going to copy the code and paste it into my monitoring js file. all of you so that if you do get stuck, Now in a separate tab, so just leave running by running the Prometheus binary We do so by using the script we wrote. scrape endpoint and the HTTP localhost listening for requests on localhost 8080. you should see Hello, in your browser and you can verify the current metrics forward slash metrics, which should look the gathered metrics in your Prometheus web UI, Let's go ahead and do that to So I'm just going to add And that is a middle tier route, and So now we have our date, homepage from the and a middle tier route, as I'm also going to need axios for this. help me in making these requests. And nice that is done. Okay, now let's check everything The home page now responds with Hello backend. This is actually because we So I'm just going to get rid The backend route responds with Hello back So that looks good. delete the initial homepage route that we had that Okay, and now let's visit middle tier. And finally, let's visit matrix where we get a Okay. looks like it's all working, we visited all the Now let's go ahead and see So we're going to have to And there we go. I thought let's take a little bit of time to With open telemetry. that I'm going to go through with you. In the backend with open telemetry you can pick being thrown, poorly implemented downstream calls. or downstream API's, leading to Or you can pick up poorly performant code on a On the front end, with open telemetry, leading to JavaScript errors. poorly implemented JavaScript, making your UI And you can even use it to locate geo And finally, for infrastructure, you can use it to resource from other apps, configuration changes, So zero day vulnerability checks, or just miss figuration with your So that is a list of you thinking of issues Now that we have that covered, And this part of the course, I want to show an app with a more complicated back It is a hypothetical project that you can adapt movies for your database. you will be able to trace exactly how we Okay, so here is a project I have pre made, by an open telemetry contributor, Alan storm. service relying on the other, In this project, I have a main dashboard which will return all the movies for our app. we did in the tracing setup. separate tracing js file to trace each So as you can see, each service And just going to minimize this so we So from the beginning of our So as a reminder, open telemetry requires that that trace provider with an exporter instrument specific node modules. So we can see here as a refresher, especially what we saw in the basic implementation. provider from the open telemetry node package. create traces on no Jess. span exporter and the simple span processor And then we need to get the zipkin exporter Now that we have what is necessary, let's move on. So at the moment, we have made a tracing program. remember, we installed a plugin called the node a trace provider object is smart enough This code creates a trace provider The trace processor requires an exporter. Both are responsible for getting the telemetry With this code, we create an exporter then processor, and then added that spam Okay, so that is what that code does. Now, I have left this blank. As this service is going to I'm just going to call it dashboard service. exporter, and then adding We of course need to get Express And so a server and listen out on The app is currently not going to respond with anything for requests any part as I wanted to respond with the dashboard But before we do that, we need So this file is exactly the same as the other file uses a different port. So I'm just going to rename this If I ran this service, we would Now, I'm going to determine how our app responds So I am just going to write up, get, and So I'm making this up. to pass through a request and response. And then I'm simply going to And response, send Jason stringify. And I'm just going to send a movie object So let's put some objects in our array, I'm And each movie object is going to have a name. So for example, jaws is a thriller as And then I'm just going to This time, let's put a different type of film. and once again, let's put a genre. object just with a different name and genre. I'm going to stop after this one, because And let's put Jurassic Park as the Okay, that is it. Okay, now let's run our app. localhost 3000, and put the movies path. And of course, our app is going to So now let's go over to the zipkin we will see we recorded a single service trace. details, we'll see these traces do not In our previous examples, However, a span is just a span of time we can use a span to measure any The Express auto instrumentation plugin creates framework, we can use it to find out how long Express handler took to execute, and so on. going on with the service as a whole, but This is the role most of the contract The core plugins are concerned with ensuring But the contract plugins will create spans specific to the behavior Okay, great. So now that we've done that, I want to instrument a distributed system. is for is essentially want my dashboard js So let's get to writing that code. actually use the node fetch library So this service, use the node fetch Let's go ahead and install that. and type NPM I for install and node batch. type apt get, and then use the route of dashboard function and pass through a request and response. data from a second service. I'm just gonna write some pseudocode to remind us and My second service is the movies service. will essentially help us get all the So essentially our object with the three movies So let's get to writing this function and pass through two parameters. function and a fetch, so the fetch is then I'm going to use these two parameters So I'm going to use a promise I'm going to pass through resolve and reject. And then whatever is in the body, I'm going Russ, Russ text, then body. getting the URL content. Okay, I'm just going to actually change this. And I want to make it consistent with the bottom. So it looks a bit neater is just a So just so it's consistent to that. So once again, let's go down And in here, I'm going to fetch data So the movies service, I am going to actually So const movies, await and use the function So the URL we want to get the content of is HTTP localhost 3004 slash movies. It is the same URL that I have written here. And then I'm going to need to require node fetch. and the package node fetch, I'm going to put And now I'm going to write the word dashboard. write dashboard, and then whatever we've So essentially, the contents Okay, so now I cannot run this file. but we will see an error. on the movies service being up and running. to type node dashboard, j. So it's listening at localhost 3001. slash dashboard, I get an error. movie service to be running. I'm just going to open up a new Okay, that is not running and So now, here's our movies. or let's rerun the dashboard. And then refresh our page. dashboard object with the contents of Amazing. Our code is working as it should. So I'm just going to rerun the And there we go. in a nutshell, the dashboard service is This is true for many apps and which is why this example is the one Now, we can see here that each span The opentelemetry HTTP plugin took care of underlying functionality of node j, So that's how to instrument an Like this is pretty cool, as obviously, and then you can see exactly what time it's going Okay, that brings us to the end of our project. This is, of course, just the surface There is a lot more to it. I sincerely hope you can go through feel more comfortable building your own projects. So far, in this project, we have directly gotten But what happens if we want to try sending it to Does that mean we would have to the amazing contributors to open telemetry The open telemetry collector is process and export telemetry It supports open source observability data formats sending it to one or more open In this next section, I'm going Okay, so for this section, and using the open Relic as our observability tool of choice. to New Relic and sign up. please answer these to the best of your ability. just click save, your account will then be set up. going to ask you to not interact with anything Once here, I'm going to ask you to go on the Once here, I'm going to ask new queue and just select ingest license. And I'm just gonna give it some notes And great, our API key is now created. The next thing we're going to do is For this, I'm going to head in which I can get the open telemetry examples. into your local machine. So I'm just going to go ahead And here it is. you to navigate to the collectors and our exporter have to change this up a little bit. And I'm just going to ask you This line of code will add zipkin as data gets into the open telemetry collector. to use zipkin, we will be telling we will be sending you data in the form of zipkin. zipkin as a receiver and then giving it an Now because zipkin report tracing data, we underneath service. The next thing we need to do is go and make sure that the Docker container is actually able to receive the data through the So we're going to add the Port Now, according to the readme to run this, So in my terminal, I'm just API key I just created with this command. this command, making sure of course So that is my fault. So the nr exporter Docker. and wonderful. that we have been working for in this course. since Thirdly, to work with For this to work, we need to change two things, So this one right here, I'm So we need to do is for the dashboard And that's it. going to reinstall all the dependencies for taken this project from the description below. been doing previously in this tutorial. Okay, now I'm just going to call the As a reminder, the dashboard service I'm going to call it multiple times, so we So maybe just a few more. Let's move on. instrumented the open telemetry collector we should now be able to visualize our data. Explorer tab on New Relic. the dashboard service and the movies service, just Let's deep dive further. dashboard service, that was a spike. So it looks like there were 18 traces with nine That sounds right. And if we dig deeper, you will see service was communicating with to Wonderful. data to do things such as get to the root cause check how your microservices are Okay, and there we have it. before we finish, I just want to take a moment So to recap, in this course, we learnt Then we learnt how to implement tracing into And then we also looked at two Thanks to distributed tracing. benefits of using open telemetry, as well as have implementing it into your Node JS projects. with your newfound knowledge, I would monitoring and digital experience monitoring. and troubleshoot your entire software stack. New Relic To find out more and get a Thanks so much again for