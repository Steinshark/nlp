Hello, I'm Maxwell Anselm, and this talk is all what this talk is not is &quot;how to be a git you've never used it before, this isn't the talk I recommend just go looking up some tutorials. Try then come back and watch this because what this often--professionally perhaps--but for whatever git. You don't understand what's going on. You tool. You feel frustrated, maybe? You know how or you feel confused where occasionally just went on and you have to completely roll back your And so to address these problems the vast git concepts and helping you develop a good going to go a long way toward dispelling all this with the tool. I go through a little bit how making it a little nicer to work with and about good things to know, some cool stuff that So without further ado let's launch right is the bulk of the talk we're just going to So starting with the super basics let's talk a git commit. Well what's in that? Basically it of those files, the permissions of those files, a notable omission here: there are no directories. the traditional sense, so basically the way git git doesn't even care. It might as well not exist. git understands that there must be a directory basically when you're working with git just forget their contents. Generally git will handle doesn't exist and it needs to, git will make it. git will get rid of it. So don't think So you can have multiple commits in git, so git the identifier is this kind of like random is immutable essentially because that checksum is so that's how you identify uniquely that commit. you're in a git repository. There's this HEAD It tells you what the current state of the git We can have multiple commits as I said and those also related to each other so in this case this commit which means that it's kind of based on our to say well now the state of the files have compared to how the checksum was before and git repository our HEAD pointer updates to basic mechanism of how changes occur in a commit--like before we said it's files--another a difference. So rather than thinking about state of the repository we can think about just So in particular--again, notable admission doesn't really exist to git. Rather, in one state you had a file with this path and path.&quot; The contents of the files may be identical it just sees like, &quot;Okay, you used to have one sometimes people are used to thinking in terms of confused by that because the concept So we can keep creating more commits obviously get new checksums we'll keep updating the HEAD so once we have a history like this of a chain way of thinking about a commit is not just in that entire chain back through its whole history because you can think about all the differences final state of the files at that point in history when we say like 0bc1c we mean the entire state you can also think about a commit just as that previous commit. These are two equally valid of confusion is not really understanding when git mind it'll come back later that basically there's So now let's talk about checking out. the simplest possible thing happens: it just moves it'll go through and reconstruct all the states you don't have to worry about that; it does that moving this HEAD pointer around. Now the magic any further commits now continue from where you create a commit, HEAD will move along just as it created this fork in our history. So you'll automatic branching; that's what they mean this behavior where I never explicitly told git a previous commit and changed something and git We can also tag things in git. So if we don't things more human understandable names They're a little simpler, they're really just creating human readable names so that the HEAD pointer. I don't have to memorize a So I talked about automatic branches, well even? So at first these look similar to tags. I and one of these is named hotfix, but now these that? What's special is that if I create a commit it'll automatically fork off but it'll move when it does so. And if I continue committing, and that's really all that a branch is. as you commit. And so you can see here: HEAD, I but rather HEAD is pointing at the branch you're on this branch, which means every time So again, very simple. The concept of a branch not really related to the actual So now let's talk about merging branches, this case we're on the develop branch and we want Well how does git do that? First, it's going to in order to create this new merge commit. It's which we can call BASE, it's going to identify the portion of history that is only reachable from and then similarly the portion of history and then it performs a magical basically it analyzes these three different can be reconciled. I don't really know how this the point is that by analyzing the graph in this automatically resolving any possible conflicts. develop compare to feature?&quot; It also understands since diverged, and using that additional of understanding which conflicts are significant are trivial enough for git to automatically really have to worry about this, but basically conflict it's probably actually non-trivial and pay close attention because something subtle it creates this new commit which is unique in just does the same thing as usual of updating the Well let's talk about merging (a different picture our feature and, as we're working on our feature, our code and maybe we're not ready to merge our on it but we do want to make sure that our code on develop. Well we can merge to resolve into our feature branch to get the latest and then this pattern can continue: we can keep working on develop, and we can get the and we can make sure that our feature is always that there aren't going to be like any So let's talk about merging (another view I was working on my feature and then I wanted feature branch and made a few commits to try And then I decided that actually, you know what? the official implementation. So I want to merge okay, git could do the same thing it did before of with the two parents as we saw before but actually feature to be up to date with new feature? now it's up to date, right? We have into our branch. This is what's called a fast It's nice because there's never any it doesn't create any new commits. So it's Now let's talk about sharing code with So now on the two sides of this diagram here we which is on some server somewhere, let's say, and our computer. Well first of all we can fetch and of those commits, but interestingly it actually list the branches in git it'll actually have this which tells you 1. that it was fetched from a origin (the name according to git). And so this is it keeps them separate from remote changes, And when you check out the develop branch, then work on so now we have our develop branch, HEAD pointer on our local develop branch which kind we'll see in a moment how that's relevant. So that people are pushing new commits, we can repeat our fetch and git is going to do the but then notably it's not going to update our copy of the branch and again our upstream pointer behind the latest changes on our local branch and branch into the remote version of the branch which fetch does this local copy version thing and so a lot of people think like, &quot;Oh, you quite often I use fetch and it's nice sometimes to first look at what before you go ahead and do this merge. It So now let's talk about merging again. So we're on a feature and other people are working on is on a server is as I'm working on a feature I'm version of develop is getting updated every time merge in those changes of develop by explicitly care about my local version of develop. That's into my feature and stay up to date and then see that origin/develop is updated, and I can the real workflow that I often use of trying to branch without having to constantly switch back So now let's go the opposite direction, sharing we're in this situation where I've worked on this a little bit ahead. I have some extra commits. first it's actually going to fetch, because we okay we got our local copy to see where it is, and in our history?&quot; In this case it is, which means update the remote branch, and update our local everything is perfectly up to date. That's the sad case. So in this case we have diverged, right? a little different: they also have a new commit, again what is a push like in this case? It's going my history. There's no way to follow those arrows going to fail and the only way to fix that is to do that is to merge it into my branch. So that's I would say merge origin/feature, now it's in So let's talk about diff and add. Basically a commit--creating a commit--is not actually a inside the commit command usually. So at any time basically look at all the state of all the files wherever the HEAD pointer is at (this is often little collection of like, &quot;Oh you change this, these different shapes; these shapes And for any of those I can say, and when you add them they end up in the index not really doing anything significant, it's not immutable changes or anything, it really is changes are something that I may want to save in And then once I've added a set of changes, that into a commit, make that checksummed, I can also go backwards with reset. So in this through that process basically any number of let's take that last commit and just turn it are still there collected in a single group, but Or I can go a step further and say &quot;You of changes together. Let's throw them back in there but now git is not really tracking them I can do what's called a hard reset and just That's the really destructive operation. Another thing you can do with the changes in just a temporary holding area. So let's say I don't know how I feel about immediately turning those aside and kind of put them in a box. That's want. I can have multiple stashes all with totally want I can tell git to open one of those boxes because maybe I'm ready to commit them, because, for example, those stashes could have actually, conflicts can occur if you remove a branch because you have to be a little generally very useful if you want to have this All right, submodules. These get a lot of hate. conceptually they're actually very simple. So our working tree, now if we have a submodule all could itself be a git repository. And specifically where is that repository from and what is the a repository inside our repository and then git that repository for us. So every time we change switching branches, doing a merge, anything like a diff. It'll say like, &quot;Oh, you changed the that's really all that they do. The big gotcha never change a submodule for you automatically. a submodule you always have to explicitly tell hell out of everybody because they'll constantly and usually that's just because, like, well you like that. The reason why git does this if you're you would constantly be accidentally losing work of committing something in your submodule and be very upset. So to get around that git just submodules up to date, explicitly initialize them, All right, let's talk about logging. This is the history of git. So let's say we have and if we do the kind of default log behavior go through and show the commits in chronological position is like when they were committed, it's in the graph so the whole branching because it's literally just looking back I'm going to show them to you in that order.&quot; isn't listed at all because it's not So this gives you a very basic view, but chronological order sometimes doesn't tell can tweak this, so for example you can show this diagram basically on the right. It'll the whole trace of how the commits relate Of course it won't show that one commit on it you'll only see the reachable commits You can also do kind of complex inclusion A B and ^ for C where these are the include things reachable from A and reachable trim down the graph in this way, right? So reach C from itself. So that's a way to sort of commits, you can get rid of those. You can also to know just like a specific branch of the repo and it'll just cut out everything you have like a very complex branching You can also tell it to look for specific kinds file path and then it's still going to do the at only reachable commits, but it's going that file so you may end up with a weird it's not showing all the commits only the ones And there's many other options for by author, things like that. You can whatever complex query you want to Let's also talk bisecting. Bisecting is probably to call it git's superpower. And the perfect uses--but I think this is like the textbook case it's very clear that something is wrong, but track down the root cause and it would be really that situation, at least I think, you know, &quot;When when someone introduced that bug you probably develop a fix for it, so git bisect helps you has a step-by-step process. Step one is you That's on you. It's kind of a manual process, because as I said you have an obvious bug, so that usually check out the code from a few weeks ago, a test it until you find, &quot;Okay, no bug in this commits, step one is done, and that's it. That's the bad and good commits, git basically does intermediate commits between bad and good to check when the bug was introduced. So what it's going by step. Once you've identified bad and good it's here, yes or no?&quot; You test it, answer it, and then yes or no?&quot; and you just repeat that process. It's through like a month or so of history, it's identifies this is the exact commit when that I was gonna say with bisect I don't wanna I maybe use it like once a year, but when I use But anyway, so now let's go on, these put them in a separate section because I think ones we talked about. There's a general theme git is not going to help you as much, you have should always be a little bit on guard when you revert. So in this situation we have our commit that the last two commits were a mistake. We Well what revert does is it allows us to they're just a diff, right? They're just changes so we can craft a new commit which is the inverse gotcha here is that to git, once it's created between the commits anymore. git doesn't really just a commit. The fact that it happens to be the to git, so it's sort of on you to remember in should never be used again and you should really So it's a little bit risky, right? If someone those mistake commits you could actually So you do have to be careful with reverts. git reset as we talked about before? The simple share a git revert. Because once you've shared a the only way to change it is to go over to their accidentally pushed some bad code, simplest thing and it essentially undoes the mistake. So that's We can also talk about cherry picking. Again, on our feature and incidentally while we're It happens, you know? You randomly did it and that bug fixed on my develop branch, but I don't it's not ready, I just want to get that one bug that bug fix is just a diff, isn't it?&quot; So we You can do it! That's what cherry pick does. But these two random commits are related kind of does it for you because that's what you can cause conflicts that can be really nasty to source branch and the destination branch--were. it is occasionally handy. So All right, let's talk about rebase. So why would here, but let's say that I'm working on my feature it a couple commits ago, develop has since moved for whatever reason I don't like that. I wish version of develop rather than the one a few What it's going to do is it's going to grab the throw them on to develop, same way cherry pick it's going to delete my old feature branch, pointing at these new commits. So it does a lot. It's all kind of rewriting history so notably, commits. They're brand new commits as far different checksums, they can cause conflicts there's just a lot going on. Rebase It also has a ton of options like and edit commits as it's applying them on So why why even do it at all? I think the main and now my feature is done and I want to merge forward merge. That's really the one benefit of I'm just going to say that I Some people always rebase. They rebase every I don't think it's worth the negative effects away with never rebasing. It's very easy to do So that's it for the concepts. So now let's talk easy to work with that has all the nice options Well first of all, remember this is the talk use git on the command line. Because you that doesn't matter at all. The reason is is the command line tool. Anything or some git GUI, github GUI, whatever. Those leave out features that they don't understand, concepts and rename them making it more confusing So it's also just the more transferable skill. git works with git command line. It's gonna your company uses some weird source management potentially isolated to that single team, it's not So how do you get git on the command line? Well, I assume you can get it. I trust you. If you're on from the git website. It includes a thing called already fully set up to use git. If you're on mac it may be out of date. I recommend installing a Then how do you configure it once it's all but there is some basic stuff you really should is your name and email address. That's so it That's good to do. The other really important If you're not on windows I think git But on any other platform you really need includes git information automatically. It's in a directory that has a git repository tied are there any uncommitted changes, are you right there. It really saves a lot of typing I'm not going to tell you how to do this because all tell you how to set them up, so just google other thing you should do is set up SSH keys. I which to me looks like torture. Constantly having Create SSH keys, so just run this command: give it a kind of memorable name depending you're using Atlassian bitbucket name it that, Please don't set a password on it, your computer password on your git key. Copy the public key to your account on whatever git server you use. I think it's under your account settings, there'll keys. Last but not least, go to your SSH config like this. So the top where it says host, that's The other information you'll see when you go to it'll tell you all this information: it'll tell use, if any. And then lastly, specify the identity you've gone through all this one-time setup you want to clone your code, instead of cloning, you you just can use your nice little nickname Next thing you should do is configure your edit some text every now and then, for example, ways to set that up. Also when merging. If you pointer fingers on f and j and stuff like that, You should use vimtutor, it's a command on vim is the default git text editor and it's so Otherwise, if you really don't want to use vim, git to do that. You can set up to use sublime or ugly but basically in your git config you tell like special arguments you need to pass to your specify those there. Using it for merging is a three-way merge before, basically when you do a four files. If you are ever resolving a merge you're using a crappy merge tool and you need to You see the local, the remote, the base, and then setting up a text editor for your merge tool, you open four files. For example if you want to open those four files, you can specify the arguments Often you'll need this trust exit code for an exit code from the text editor to see If you set this option git will just explicitly And you can say yes or no. And then you have to All right, so now let's talk about using git on First of all, I highly recommend making a git with these four commands. It's so simple, just basically makes a fake remote repository on your pushing and pulling and merging and just see how just by using these four Basics of using git on the command line: So you're always going to type git then the totally depend on the subcommand you're using. So every single slide title we talked about during pull, diff, add, all those are subcommands. to need, I tried to cover almost all of them. help. So for any subcommand you can type git help manual explaining why you would use it, all Common workflow if you just want to get your git status gets you a more verbose status readout deleted, has anything changed, stuff like that. like it'll go through line by line and show you, Once you've looked at the diff, doing git add to And then finally git commit to create the commit that. All those have really common options that you're just changing like small parts of lines view to be like, &quot;Oh yeah, you just like removed the entire line changing. git add -p is amazing, walk you through in an interactive fashion line by Do you want to edit this change before you commit -p to be like, &quot;Oh my gosh, I almost committed great for just like finely crafting your commits. editor and type out a long commit message you can All right, kind of last but not least for using example log or checkout or branch or whatever command line and this can actually be surprisingly to identify one. So for example, you can use use the branch name to identify it, the tag There's also relative ways to do it where other commit that you know the name of. you use ~. So like if this latest commit is X, X~ If you have branches that were merged you can use merge occurred, so ^2 is like the second parent, really interesting is you can of course combine you know, the parent of the second parent of this really cryptic. You can chain them in very This is mainly just so that you'll see this online like googling how to do something in git, you'll actually not that crazy about how to identify all these things so you can say like HEAD~3 to Another interesting workflow that is occasionally diff isn't just for showing what has currently You can also diff anything in git, so I can say two branches? Or these two arbitrary commits?&quot; And really useful if you just want to see each other of your code or how two versions of a You can also just specify a single thing, it'll gets really interesting is you can then save that file which explicitly says how to translate from changes and that's what git apply is for. You can changes like an actual commit in the repository. each other. I've often seen people, for example, make something more testable you can turn those you can share that patch file to say like, &quot;Hey! and you'll get this like temporary testing code before you apply it, if you want to fine tune it. So let's talk about aliases. If you find yourself line, aliases are great for saving you that you just type you know the name of your alias when you run git myalias. Very straightforward. name is you can shorten the name of that. You want to run whatever shell command when you type These can also do positional arguments if you and then some argument and have it like substitute that is possible. It's a little if you really want to enhance Some examples of these that I use: updating submodules really quickly, that as I said before with submodules git will the HEAD pointer for the submodule.&quot; but if you show you the full diff of all the things that you want to just destructively throw out all the just junk and I want to get rid of it I have this And that's it! So I hope with this and if you have any questions feel free maybe I or, hopefully, someone else