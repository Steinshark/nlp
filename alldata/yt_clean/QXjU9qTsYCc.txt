In your first programming class, you were Here's how it works. You first write out your program. But a computer can't read it yet. So, in order to actually run your program, you first need to pass it through this special program called the compiler. Then, out pops a new version of your program It was probably then tested by running it with a bunch of inputs and expected outputs or something. So there are two versions of your program. The one you wrote but a computer can't read, and the magically generated one that a computer can read. Except, it's better than magic. The compiler is a complex machine human-readable code and computer-readable code. So, what exactly is the compiler doing, and what does the executable version of your program actually look like? What? You say you have no idea what I'm talking about? Oh, I think I know what might have happened. In your first programming class, in which case this whole process was hidden from you. When you click the run button, your work is and it runs automatically. So now that we're up to speed, what does the executable look like, and how does the compiler... What? You still don't know what I'm talking All you did was Python scripting??? *sigh* Oh my god there are so many edge cases. Ok, this is what happens to programs in general, I don't know, let's find out! At a low level, computers processors can only They can read and write to memory, and they Modern processors do other things too, but Now, an executable program, the one generated for the processor to follow, written in binary. The instructions are things like... read these write bytes to memory, jump forward this many lines, stuff like that. A program, expressed in a list of and this is the kind of program that But why does a computer processor only read Why this specifically? Well in short, here's how a processor works. The processor already contains but the correct circuitry only gets connected together when the corresponding instruction gets fed into it. The 1s and 0s in the instruction cause certain connecting the correct circuitry together If you want to look more into how this works, you might wanna check out crash course computer science particularly episodes 5 through 8. Episodes 3 and 4 are also helpful if you need Though you could just watch my video too... And for the record, crash course isn't paying I just really like this series. But in short, just know that executable programs But when you learned to program, you didn't machine code things like memory management, Programming was about variables, and if statements, Well, these things are just higher-level constructs that make it easier for humans to think about programming. A program, expressed in this form, is called It's the version of a program and thus the version that most The compiler's job is to take this source and turn it into machine code that is computer-readable. But how does it do that? How does it turn a string of text into a list Let's look at some examples: Here's a pretty simple program. Declare a variable of type integer Then assign it a value of 3. For now, this program only exists I know it looks like it has some kind of structure, it's just a meaningless sequence of characters. It's just text. And I know that this program doesn't really Let's pass this source code into the compiler The compiler first divides the text up into It's kind of like the compiler is figuring Then, the tokens are organized into a hierarchical like figuring out what the "grammar" is Then, the compiler records context about the This is the stuff that a computer needs to In our case, the only context we need is the Oh, and the main function too but that's The final step is to traverse the tree, and do the same thing as this particular source *I just wanna that, typically, compilers don't There's usually a few intermediate steps that This is what the machine instructions look It's a little hard to read and interpret, Actually, it's still a pain to read. Let's write it out as assembly code, which is a That's better. Now, we're going to ignore this stuff here. Just know that it's responsible for starting where the program starts and ends. This is the instruction that corresponds to This instruction says to "move" the number Let's run the program and see what happens... And as we'd expect, the number 3 got put It looks like the compiler decided that this And that's it. The compiler took our source code, which said and translated it into machine code, which So, our program is kind of boring right now. What happens if we change it? Let's add a line to increment x by one, We assign it the value of x's Now, we pass it into the compiler again to The compiler finds tokens,... ...parses,... ...contextualizes,... ...and generates. It looks like there's only a single new this memory location. After all, this is the location that the compiler Modifying the variable x is equivalent to modifying Let's run it... The value 3 appears in that memory location and then the value becomes 4. Now so far, we've seen how variable assignments But it's not so simple for if-statements, There are no machine instructions that are Instead, we need to emulate their behaviour Let's start with an if-statement. In an if-statement, we only execute the code If the condition is false, we skip over this code. In assembly, the code inside the block gets some instructions evaluating the condition, In this case, to jump past the block we want The processor knows whether or not we're of the previous instruction. That instruction temporarily set some flags result by the time we got to this conditional If we're not supposed to skip it, then the conveniently executing the code Notice that these machine instructions are Let's see now jumps can emulate other source There's the if-else-statement. Only execute this block if this condition is true. Otherwise, execute this block. In assembly, we have the code in the first Before the first block, we have a comparison In between the blocks, we have a regular, This is so that execution skips the second which is kind of how the if-else-statement works Then there's the while-loop. Only execute this block if this condition again until it's not true anymore. In assembly, we have the block's code, the the jumps emulating the loop. Functions are a little more complicated. Basically, functions encapsulate a code block, Most programmers out there should know that and they can do recursion and stuff. This is what its equivalent assembly code Let's run it to see what it does. Hitting the function call, we save all context execute the function code (which may involve calling more functions), and pop back down once it's done. This makes it possible for functions to call You just push more memory, and pop back down So that's how compilers work! They take your source code, and make machine code. But there's one problem. If you compile your program on one computer and try to run it, it might not work. If the new computer has a different operating it probably uses different machine instructions. So if you want your program to be able to able to compile to that computer's machine code. And if your program's users might run your unless you're distributing the source, you're gonna every platform you want to run on. Every. Single. One. Some languages like Java sneak around this Instead of machine code, Java gets compiled And then the bytecode can get sent to other specific computer's machine code when the It's a bit of a compromise. You get better portability, though it's But regardless, the language you write your of processors and operating systems. Can you imagine what it was like back in the assembly or even machine code onto punch cards? Not only would you need to figure out the You wouldn't even be able to use your program because the other model expected you to punch Things are a little nicer these days. You just write a program, compile it, and *if only it were that simple* all thanks to the people But, remember that the compiler is a program itself. If people use compilers to develop programs, Well, it was probably written and compiled compiling a compiler with a previous version If we follow this chain backwards, at some programs, written directly in machine literally automating part of the process of The history of computer languages is pretty complex. No wonder it took decades to get to where Remember that the next time you're writing code. We have all these beautiful things like syntax programming, functional programming, libraries, But it's still amazing that we can just ...at the push of a button. Nope, wait... There we go, the push of a button. Programming isn't so hard...