[MUSIC PLAYING] DAVID MALAN: All right. This is CS50. This is week 2 wherein we will but we thought we'd first And in fact, allow me to walk have joined us already. First here on my left, we have who? AKSHAYA: Hi, I'm Akshaya. I'm a first year in on concentrating in chemical DAVID MALAN: Wonderful, welcome. And let me have you hang first because we've asked So in your envelope, you have If you wouldn't mind reading it aloud. And as she reads this, allow us level Akshaya reads at, so to speak. AKSHAYA: All right, it's One fish, two fish, red fish, blue fish. DAVID MALAN: All right, very well done. What grade level would you say to your middle school, maybe teacher said you read at this here? So OK, no offense taken yet. AUDIENCE: 1st grade. DAVID MALAN: I'm sorry? AUDIENCE: 1st grade. DAVID MALAN: 1st grade. OK, so first grade is just about right. And in fact, according to one one fish, two fish, red be considered to actually be 1st So let's-- and why is that, though? Why did you say 1st grade? AUDIENCE: It's very basic. DAVID MALAN: It's very basic. But what is it about these Do you want to identify yourself? AKSHAYA: Sure. They're all one syllable and they're like that. DAVID MALAN: Spot-on. So like they're very short words And you would expect All right, let's go ahead and hand here if you'd like to ETHAN: Yes. Hi, I'm Ethan. I'm a first year in Canada, and DAVID MALAN: Wonderful. And in your folder, we have ETHAN: Congratulations. Today is your day. You're off to great places. You're off and away. DAVID MALAN: So this text might on the heels of high school, perhaps. What grade level might he be reading at? So maybe 5th grade. And why 5th grade? AUDIENCE: [INAUDIBLE] DAVID MALAN: OK. Yeah. So a little more complicated. Like the words-- we've got some more we have longer sentences. And indeed, according to one but we would adjudicate your But let's see if we can't if you'd like to introduce MIKE: Hi, I'm Mike. I'm also a first year. I'm in Weld, and I'm in biomedical engineering. DAVID MALAN: Welcome. And your tale? MIKE: It was a bright, cold day in Winston Smith, his chin nuzzled to escape the vile wind, slipped of victory mansions, to prevent a swirl of gritty dust DAVID MALAN: All right, And someone's guess AUDIENCE: 1984. DAVID MALAN: What's that? Oh, OK, 1984 is indeed the grade did you perhaps read that book? So I'm hearing 8th, I'm hearing 10th. So indeed, 10th grade is what a adjudicate that reading level to be at. And consider now the heuristics. So we started with very small words, and then things sort of escalated sophisticated English, more interesting So I bet if we could somehow capture the length of the words and and the position of the even using week 1 material we'll be able to actually write code can take these spoken and actually analyze roughly So that's just a teaser For now, allow us to thank gets a wonderful parting [APPLAUSE] All right. And Thank you all so much. So with that said, there's another and indeed, what you'll is that beyond just focusing on some like we've really done in the past and conditionals and really building blocks or puzzle we're going to increasingly of these ideas which, after important and applicable. So here, for instance, we'll consider and in turn, in problem set 2 this week, which is the art, the science information, and that you can send a message securely through any medium even though Ideally, thanks to be able to decrypt it or actually So for instance, if you were to receive it's indeed a bit cryptic. Three words maybe, but have decrypted even So up until now, though, we've had some And I gave us this picture last week which you can make programs out of your that source code into machine And in the middle here was But it really has been kind and we've sort of had these wheels here in the sense needed to care like what the compiler But today, what we thought we'd do that even though after to be able to use commands to the beautiful abstraction of these lower-level a glimpse of how some Because so that inevitably you've got some bug, you'll have a bottom-up understanding And indeed, these basics, help you troubleshoot problems and So here, for instance, is the And this code here is the simplest of C This is the source code. This, we claimed, was the And it was that program converted one into the other. But let's dive a little into what we mean by compiling code. Like what is happening nothing really feels like magic anymore. It's not just that it goes from and that's that, you understand and frankly, what other humans make as beautifully abstract and as So here are a couple been in the habit of running when and then execute your code. But it turns out that make is actually The first of several white is that make itself is It's actually a program that And by that, I mean this. Let me go over to VS Code here and let And I'm going to go ahead and do include of the curly braces, printf &quot;hello,&quot; So that's the code that we And up until now, if I wanted to dot slash hello, and voila, and it actually executes. But what's actually going there is that make is running and the reveal today is that is something called And this is just another is actually to do the conversion But it turns out that be used very simply like but it doesn't behave nearly as So in particular, let I'm going to go ahead and by running rm for remove, which And then I'm going to say y for And if I go ahead now and run just it seems to be successful, at least But if I try to do dot there is no such file or That is because by default, outputs a file name called a dot out. Like why a? Well, it's sort of a simple name. a dot but this just means name that Clang is going to give us. So OK, it turns out I can do dot that now is my program, but that's It's not very user-friendly. It's certainly not an to put on people's desktops or phones. So how can we do better? Well, it turns out, with Clang, what we'll call command line arguments. And command line arguments are actually we just didn't slap this word on are additional words that you typed at your modify the behavior of a program. And you can perhaps guess It turns out that if I actually want not a.out, which is the do this-- clang, space, dash or whatever I want to call And now if I hit Enter, but now if I do ./hello and Enter, So why is make useful? Well, it just saves us to type out this longer we actually want to compile the code. But in fact, it gets with commands like clang because consider this code here. Not just the version of &quot;hello, world,&quot; last week, I started to get user get_string and then saying, Well, if I go back to VS Code to be that same one-- so let me go ahead and Let me get rid of this simple a string called name equals Question mark, just Then I can do printf, And previously I typed &quot;world.&quot; I obviously don't want to type &quot;David&quot; What did I type last week So yeah, just-- not Command-S, which is a placeholder Then I can still do my new line, I can substitute in something like All right, so if I go now last week, I could just do it worked just fine. But if I instead do clang that this is not going to be sufficient Exact same thing I typed think I'm going to see some errors. So what's this error hinting at here? Well, at the very bottom, it's and much of this you can ignore, but What's the first maybe keyword lines of erroneous output? So it mentions main. That's not that much of a clue because Second line, though, get_string. There's some issue with an Now why might that be? I did include cs50.h, enough to teach the Well, it turns out that if you're that doesn't necessarily come with C turns out that you additionally want to use that library. And not just by including but by an additional command as well. So when you run Clang, you rather command line argument. Literally -l for library, which A library is just code that you want to use in your project. So if I really want to compile this I can still do clang o hello hello.c, I need to tell the compiler to link, And now I hit Enter, the error I can type in my name, and And this is why, suffice it which is not a CS50 thing. This is a popular tool that use to automate these So unbeknownst to you, the -o for you. make, unbeknownst to just because it makes our lives easier. But today, we thought peel back this layer so what's going on behind this and compiling more generally. So let me propose that compiling we've described it to be. Compiling is like this catch-all goes from source code to machine code. But if we really want to get but this is not a sign of things will be abstract away, compiling is in turning source code that you But through an understanding today, you'll hopefully how to troubleshoot issues what's happening because It's just the result of years of humans So when you run make, what's happening? Or in turn, when you run clang, And the first one is So what is this all about? Well, let's consider this code here. And this code is a insofar as it's one of the more And you'll notice, for instance, so I could use printf. I had main down here, whose purpose And then recall we made our own meow with Scratch that just printed But I also included this line This was a prototype. And why did I have to include it there? Or equivalently, what would happen at the top there? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: Exactly. If I didn't include it up here, the would not know what meow is because So this is kind of like a Alternatively, we could just move this but I claim that just eventually once you have Like you can't realistically put them So these prototypes solve that problem. So nothing new here. Just a reminder of what motivated Now let's consider this is just the one we wrote This program prompts and then says hello to that person. But it has two includes And in fact, any line of C that is what we'll call now a It's not really a word you need but it is a little bit different because it starts with that hash. That's a special symbol in C. And what this means is the following. This very first line, cs50.h, is wrote and we installed somewhere in VS And I've claimed you need to use this So just logically, what is Yeah? AUDIENCE: Function [INAUDIBLE]. DAVID MALAN: Super close. So the function called get_string but it's not quite as much It's actually a little bit less than What is inside of cs50.h, presumably? Just a what? Just a prototype for? Which function? get_string. So admittedly, there's some but the important line for today's is indeed one line of code that the name is, and what the arguments, and some other stuff. And so what happens effectively step 1 is this pre-processing line. And essentially, there is some of the clang compiler that looks for and when it sees that, it goes and and pastes the contents of that so that you don't have copy and paste it, and make So in particular, it's effectively the prototype of get_string thereby teaching the By that same logic, what The prototype for? For printf. And indeed, exactly that. So this line effectively gets of the prototype for printf, is a bit more complicated, so let just because it takes a depending on how many placeholders But effectively, that, So the preprocessor does that find and replace, if you will. Now there's some-- again, and this, too, is kind probably has its own file because but the essence of it is exactly this. So preprocessing converts include lines to whatever within the file plus some other stuff. Now compiling we use it as this it has a very specific knowing about even can go back to using compiling So when you've got this same code has happened. So this is essentially happening It's not changing your hello.c file This code gets, quote-unquote, that looks more like this. And this is a scarier language on in this particular class. This is what's known And back in the day, wrote this to program their computers. Similarly, before there was humans very initially used what instead? AUDIENCE: 0's and 1's. DAVID MALAN: So 0's and 1's-- like painfully, be it in code or be it or the like. So again, these are but we're rewinding for today in time. But what this compiler for into this other language And even though this there's at least some If I highlight get_string, printf is mentioned in this code. And even some of these are spelled a bit weirdly, this something in memory and calling So there's some semantics somewhat familiar even though this But unfortunately, this and that's where step 3 comes in. So step 3 of this four-step process And assembling just takes that assembly to the thing we do care So assembling takes assembly As an aside, and I the reason that Clang names its files is a side effect of that being dealing with assembly language All right, so here are some 0's still that fourth and final step, which namely linking. So let me take a step back And even though this code is exactly so no copying and pasting, been plugged in here, this is three different files involved in simple like this. There's obviously this thing There's apparently cs50.h, and But technically-- and you don't have to else on the computer's is a cs50.c file, the staff's implementation of and all of those other functions. Somewhere on the server's that implements printf and all So the dot c is just You don't ever mention the dot c file, someone else stored them CS50 staff in this case. So technically, even when compiling you're really combining three files And I'll write them from which I wrote, cs50.c, which the So somewhere there's these three files. And Clang, our compiler, into the corresponding 0's and 1's. Lastly, this is not yet sufficient been linked together. I mean, I deliberately left a are three separately-compiled files. So that fourth and final takes all of these 0's and combines them into just one final whatever the file name is of choice. So what you and I for the past week and that's what a normal to describe this whole these four different steps is sort of a representative of an And nowadays, if we in class, when we start is another more modern language, that, higher level, even though there's going to be some So any questions on just terminology Yeah? AUDIENCE: I didn't really [INAUDIBLE] DAVID MALAN: Sure. Compiling, if I rewind, is the process looks like this, recall-- whoops, this, So preprocessing just include lines and a few So that's step 1. Compiling converts the C code The assembling step, step 3, converts And then the fourth all of the 0's and 1's from the one, that are involved in your all together for you magically. But at the end of the day, all of this If I jump now to the end make, which, in turn, runs is abstracted away. But the key here is that even with be it the make command everything should be explainable ultimately. Each of those things has a purpose. So any questions, then, now called compiling even though course that you might language or these lower-level details? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: A good question. Are there other types of compilers? Yes. Back when I took CS50, I used a popular Collection, which still exists that you're using for CS50. Clang is somewhat more recent. It's gaining popularity. And frankly, we use it in large are slightly more user-friendly. You might not believe us because if you this past week, they were probably just but it's better than And there's alternatives but more on that when we Other questions? No? All right. Well, what are the implications of the to machine code? Well, it stands to reason maybe you can decompile it-- that Go from 0's and 1's Now that would be handy if you want something in a program that you It's maybe not ideal for though, if you are the person who If you are Microsoft and you that people with Macs and PCs and it doesn't actually sound very can take those 0's and 1's and so to speak, into the because then they can have their and make changes to it without that it might have taken to But it turns out that so doing things in the said than done because there are to implement programs. Like loops alone, you can use for And so there's other ways-- to solve the same problem. So even if you try to and convert machine code there's not necessarily going And the reality is, that it because you lose the you lose the function names typically, might very well be C code, but even a good programmer, to read. And generally, the mindset is, to decompile code in that even without good variable names, good documentation and the like, the program in the first place yourself So there's some on what are otherwise potential threats But that's not going to be the we do get to languages like Python like JavaScript. Some of those are actually Any of your customers, and your family that So with that said, let's introduce that will hopefully from this past week bugs a little more manageable. And indeed, part of the process is debugging it. And it is a rare thing be it in C or any other language, I mean, to this day, I still, 20-plus Hopefully a little bit less of it, but any time you're doing you're not necessarily going to So even in industry, bugs are having techniques to debug is super compelling. Now just for a bit of history, who was actually in but also on the faculty and worked on a Harvard I, which is actually on display at Sciences if you take a But also when working she is known for having at least a mistake in a computer's program-- a mistake in a computer's code. And the etymology of this wherein she and her colleagues were on computers, that a in one of the relays, one of the of the very old now computer, wrote, &quot;First actual So it wasn't she who but this was a story she was thereafter scientist thereafter. We now know bugs to be all too familiar and I thought I would deliberately on some of the programs with So let me go back over me propose that I do something somewhat a column of bricks of height 3. So I'm going into VS Code and I'm buggy.c because I intend I'm going to include stdio.h as And in here, if I want to I'm going to do 4 int i gets-- all right, I'm still new here, so I know I'm supposed And I want to do this until I count And then i++ I remember And now I might go ahead and print which I do want because I want to to make this vertical. But of course, if you've noticed with it compiles OK. So no typos, no syntactical errors. But when I run this, I'm So four in this case. Now this is meant to so that we don't spend time trying to focus on techniques for So-- finding, rather, the bug. So what's one of the first Literally one you have And it is a very quick and what's going on inside you don't have more sophisticated And so in this case, for instance, all right, I'm obviously And let me play a little slow here. It'd be helpful for me to understand why though I'm starting at 0 like I remember as we did in class, like I'm just not So what I would commonly do is go what's going on, and I might literally backslash n, comma, and then I just want to see on is i, what is i, what is i just to help So let me go ahead and recompile and then let me make my just to make clear what's going on. And now it's a little more pedantic. Now i is 0, I get a hash. i is 1, Wait a minute. i is 3, I get a hash. So clearly now, it should be especially if the syntax I certainly don't want or maybe equivalently, I don't So I can fix this in a couple the most canonical solution is To change to what to what? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah. So change the less than or equal So even though this is like counting it's the more typical programmatic And now, of course, if I do make buggy-- and I'll increase my terminal now I see what's going Now it matches my expectations, Now of course, if I'm I should delete the temporary printf. And let me disclaim that using see what's going on is but generally adding a printf and a like it starts to devolve into have no idea what's going on, so Let me propose that if you ever that hill into just trying you need a better tool, And frankly, it's annoying to use printf you have to recompile It's just adding to the number of steps. So let me propose I'm going to go back going to write a different has a helper function, so to speak. A second function whose to print that column for me. So I'm going to say though I could call it anything is going to take a argument height which will tell it how many vertical bricks. I'm going to do the same kind i is less than-- I'm going to make the same mistake i++. And then inside of this for loop, let So I've made the same in the context now of a helper what I'd like to do now, just to be a from the user for the height. And when I do get that int, I want but I do need to give that So I'll say that it's an integer. And now, lastly, I can print_column, call it h just because height is h. Print column h, semicolon. OK, so it's the exact same program So it's not just going to be 3, but I've done something stupid. AUDIENCE: [INAUDIBLE] DAVID MALAN: I've done So this, of course, is not supposed And someone else. What else have I done? AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah. I'm missing the prototype. And this is, let me reiterate, probably Once you've implemented can copy paste its first so that it teaches the compiler AUDIENCE: [INAUDIBLE] DAVID MALAN: Three stupid things. OK. Thank you. So, good. Include cs50.h. And now, anyone want to go for four? No? All right. Slightly unintended here. So let's see. make buggy. OK, no syntax errors thanks to you all. So the code compiles, but and I type in something like 3 manually, So let me now introduce that's generally known as a debugger. And within the VS Code we actually have a command that makes but we didn't write the tool itself. You are about to see a very graphical, tool called a debugger, but we'll start command called debug50, which just to start the debugger without file with all of your preferred It's just an annoying hoop So what I'm going to do is I have already compiled it, I'll make buggy again because to be compiled. It's not going to help like the stupid mistakes I it will help you though with in your code once your code is running. So to run debug50, I'm going to the exact same command I would normally So ./buggy. So exact same thing, ./buggy, When I hit Enter, a whole bunch of-- another error is going to is a good reminder because this It's reminding me that I have to And as that word at which you want your code to break. Not break in make the situation where do you want to pause? Execution, break, execution-- so the program doesn't run all at once. And you can put this and you might have if you've ever hovered the left-hand side next See the little red dot that appears? If I click on any of these lines, that's And I want to break execution at main. So I'm just going to click to That makes it a darker of sorts that tells the debugger though I could put it Let me go ahead and rerun and now a bunch of things are It's going to look a little but there's some useful So one, my code is still here, but the rather, the first line code at or below the breakpoint I set here, which says, this line of We broke at this point, but if I will be executed. Because up until now, every C program I want to pump the But notice a few other So notice that up here some weirdness. There's mentions of variables Local is a term we'll use this week. But there's this variable where did the value 21912 come from? So it turns out, in C, before you by literally typing the number 3, it often contains what's More on those in a couple of weeks. But a garbage value as like remnants of whatever before you ran your program. And that's a bit of but you cannot trust that a variable if you did not put one there yourself. So for now, h is nonsensical. It's a garbage value it means nothing. But once I execute this line, it should All right. Down here, there's a watch section, Down here is what's More on that in the future. But what this means for now is that for instance, print_column. So notice up here, these are the most If I hit this Play to actually run my program to the end However, I can actually step over or I can step into this poke around the contents of get_int So conceptually you can or you can dive down conceptually deeper Lastly, this will let allow you to restart the whole process, So these buttons are And the one I'll click first which is step over. So step over doesn't mean, skip but don't bother me by going into the namely get_int. So when I click this see that my terminal, which is still I'm going to go ahead and type 3. As soon as I hit Enter, probably will change So h, the variable h should And I'll probably see a highlighted, probably line 9 next So let me go ahead and hit Enter and And voila, h now has the value 3, and because the debugger is allowing me Now let me go ahead and print out-- let I'm done with this. Let's go ahead and run It clearly got the value 3. But wait a minute-- oh, and at this point, in which I would have seen the output, So let me actually do this again. Let me go back into debug50 by It's going to think for a moment, I'm going to do the exact same thing. I'm going to step over like to actually see what's going on So this time, instead of and close all the windows and step into my print_column function. So don't step over, step into. Because if I step over-- and now this is what I you can see that it's So in fact, let me undo this, Let me rerun the command a final time. So it goes back to It's going to prompt me again once I But this time, instead of stepping I wrote print_column, so let's step into it, and watch what It now jumps logically to thereby letting me And now I can just step over each So stepping over. OK, so what did it do? It did that whole narrative where it compared i against height. It then went inside of the loop. When I click Step Over, watch what prints out. Now line 14 is highlighted again. It's comparing per the is it less than or equal to height? If so, it's going to go It's going to do this But notice at the top-left is still the same, it's still 3, but i on each iteration. So the debugger is letting me see what's because i keeps getting incremented. So if I step over this line now, So ideally I want this loop to end, notice that the value but 3 is less than or equal to height-- Now I see why less than or equals to, And as soon as that light bulb bail out, click the red Stop go back in, fix your code, and you're back in business. So the takeaways here really Printf is your friend, but only for Get into the habit now of using debug50, You will invariably not for problem set 2 as you going to feel easier and quicker just just to use printf. And the problem with begin to build up like where you really should you really should have you really should have learned you end up spending more and doing things manually than 30 minutes just learning and the buttons of a proper debugger. So please take that advice significant amounts of time over time. Questions on printf or Any questions on this? No? OK. So let me give you a third and final looming over us here for some time. So there is actually this technique And in the absence of a roommate who or knows how to program, in the sitting next to you, in the absence of questions of, if you have simply goes the tradition, just talk Better yet, if it's an adorable And the idea of rubber duck by verbalizing literally out probably with the door that you're talking to this end up hearing any illogic in the proverbial light bulb tends to go It's supposed to be less than, So literally just explaining to a going on in your code help you see in your mind's eye So rubber duck debugging is even if you don't happen to have Of course, you're also welcome lives at cs50.ai, and also within You can ask the CS50 Duck about or you can even copy paste with which you might be having trouble All right. So, with those tools in our toolkit, that we introduce now a few itself and better understand how we can like the readability of text These were our so-called we introduced at least a subset of in a certain format, so to speak. Like in week 0, we said that is just 0's and 1's, binary. And I claimed conceptually that how is a number versus a letter versus a is just context-dependent, or you're using Microsoft But last week, we saw a little not quite as broad strokes as that. It's more about what the being stored in a given variable. Is it an integer? Is it a char, a character? Is it a whole string? Is it a longer integer or the like? So you now have this control. The catch, though, recall, though, has only a finite amount So for instance, an integer and 4 bytes is 32 bits 32 bits, we claimed, but if you want to represent the biggest integer you can Now that's really big for but years ago, Facebook, rumored to be using integers But now that they have 3-plus billion users, an integer is no the Googles, the Microsofts So we also have longs, which use bigger range of values. Meanwhile, a bool, is kind of bad design in what sense? Why might that be bad design? It's only-- it should only be 2-- 1 bit, rather, because Turns out, it's just even though we're wasting but bools are represented Chars are going to be 1 byte. Floats tend to be 4 bytes. Doubles tend to be 8 bytes. Some of this is system-dependent, this tends to be a useful rule of thumb. The only one I can't because a string, recall, And maybe it has no characters, So it's a variable number where each byte represents So with that said, how do we to information being Well, let me remind us that this is Even though this isn't a scale and this is memory, random access memory. And on these black chips, here, are the bytes that In fact, let's go ahead and fill the screen here. And just for an artist's let me propose that if a megabyte, a gigabyte-- like a lot of it stands to reason that no we could just number and we could say that this This is byte 0, 1, 2, 3, and this is So you can think of or just locations, numeric indices individually. Why a byte? Individual bits are not that tends to be the de facto standard. Let me-- so, for instance, if you're a char, it might be stored literally of the chip of memory. If you're storing maybe it might take up that many bytes. If you're storing a long, it might Now we don't have to dwell on the and these traces and all the this away and claim that what is is just kind of this canvas, I If you've ever made of pixels, up, down, left, right, It's this canvas that you can manipulate you want in the computer's memory. So in fact, let's zoom in how your computer is actually storing At the end of the day, no your Mac, your PC, your it has access to for It's a canvas of bytes, now really invites design decisions. So let's consider this. Here is an excerpt from a prompting the user for three scores. Like three test, scores, exam And the purpose in life to average those three want to get a sense of where So we can certainly whip And in just a moment, let me go And I'll write up a new And in this, let me go ahead int main void at the top. And in here, let me go it's not been the greatest semester. So my first score, which my second score was a 73, but my Now you might remember these they might spell a message, but It's just numbers because I'm telling Now if I want to figure out what my So let me just print and I don't want to shortchange myself. I'm not going to use %i because I the decimal point. So we're going to use a float instead. And my average i claim will be divided by 3, semicolon. With parentheses, because like order of operations, I so I can divide the whole thing by 3. But I have screwed up already. I am going to shortchange myself as I deserve, but this one's subtle. What have I done wrong? Yeah, I might want to cast because if you do integral math, divide some integers by an integer, it's so it's going to throw away Even if it's something-point-1, that fraction is going There's a bunch of ways to fix this. I could just use floats or I could cast score1, score2, Frankly, the simplest way is because so long as I've got this will promote the whole arithmetic math instead of integer math. So let me go ahead now So far, so good. ./scores, and but 59.33333-- so in the third. But I would have lost used a float in this particular way. Well, let's consider now what's when I store these three variables. So, back to the grid here, It doesn't really matter I might put it here, the computer makes these decisions. But for the artist's sake, I'm going here. So, score1 is containing the integer 72. Why is it taking up Because? It's an integer. And on this system, So I've drawn it to scale, if you it also takes 4 bytes. By coincidence, but will likely end up next in memory because I've only got so the computer quite likely will And indeed, by that logic, is going to fill in this space here. We'll consider down if things get fragmented-- something's here, something's can assume that this is probably All right, so that's but what's really going on? Well, these are just bytes of memory-- that is, bits of memory times 8. And so what's really of 0's and 1's is being This pattern of 0's to represent 73, and similarly, 33. But that's a very low level detail so we'll generally just think about All right. So if we go back to the wonder if this is the best idea. These three lines of code are correct. I got my 59 and 1/3 for is correct, but code-wise, this Even if you hadn't why might this not be the best like scores in a program? How might this get us in trouble? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah. It's not the best because of different variables for each score. They're almost identically in almost any question involving the the number of things Am I really going to start writing score10, score20? I mean, your code is just going to look except that the number at the Like that should make you cringe going to end well eventually. And typographical errors are going because we'll make mistakes. So how can we do a little Well, let me propose that we introduce An array is a sequence of values So an array is just a chunk of memory So no gaps, no fragmentation. From left to right, top to But these arrays in to give a slightly new syntax that So here instead is I would propose not three, one variable called is going to be an int, and you in that variable. So now I can pluralize because by using square brackets and give me enough room for not one, not And the computer is going to do to back to back in Now assigning values to these but the syntax looks like this. To assign the first value, I do scores, bracket, 1 equals 73; And it's square brackets consistently. And notice, this is a feature-- or a downside of C. We very frequently use the same This first line tells the computer, These next three lines mean, go and put this value there. Location 1, put this value there; So same syntax, but different meaning But the equal sign indeed means to left just like last week. So what does this mean Well, in this case here, we now have a And actually, let me Let me go back to VS propose that instead of having let me give myself an int, and then do scores, bracket, 0 equals scores, bracket, 2 equals 33. And now I have to change this scores, bracket, 0; scores, bracket, So a couple of key details. I started counting at 0. Why? That's just the way it is with arrays. You must start counting at 0 unless And what you definitely go into scores, bracket, ask the computer for three integers. If I blindly do something like You're going beyond the and bad things will often happen. So we won't do that just yet. But for now, 0, 1, and 2 are the So if I recompile this code-- so and I get the exact same answer there. But let me make it more is a little stupid that I'm compiling What if I have a fourth exam So let's make it more the syntax will start to Let's go ahead and use get_int Let's go ahead and get_int and Let's go ahead and get_int and now storing the return values If I now do make scores-- oh, darn it. a mistake. Similar to one I've made before, but we What'd I do wrong? Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: OK. What did I do wrong-- AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah. So I'm missing the CS50 header file. So how do you know that? Well, implicit declaration So it just doesn't know what get_int is. Well, who does know what get_int is? The CS50 Library, that should All right. Let me go to the top here and let me go like this. Now let me clear my terminal. make scores again. We're back in business. And notice, I don't need to do -l cs50. make is doing that for me for clang, but but it is being executed All right, so ./scores, here we go. 72, 73, 33. Math is still the same, but now Now this, too, hopefully This is correct, I would Reeks of week 0 inefficiencies. Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: OK. So I could ask the human how Let's come back to that. But I think even in this Use a loop, right? Because I'm literally doing And notice, this number I would think that a little plus-plus get_int Score, get_int Score-- So a loop is a perfect solution here. So let me go over into this code declare it to be of could do something like this-- so I'm not going to make the same I++. Inside of the loop now, I can arrays are getting really can use and reuse them, but Equals get_int, quote-unquote, &quot;Score.&quot; Now I can type that phrase just will do the same thing, The code is getting better and I'm not repeating myself. 72, 73, 33. Still works the same, but we're Now how else-- there's one design it's a little more subtle. Any observations? AUDIENCE: [INAUDIBLE] DAVID MALAN: Ah, interesting. So instead of dividing by by the array size, which at the but I do concur that that is worrisome But there's something else Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: I'm OK moving So this is a new term of art. To index into an array means So here, I'm indexing into to start at 0 and then 1 and then 2. I'm actually OK with that. Even though in common day life we as a programmer, I just of saying score0, score1, score2 now. But something else. Yeah? AUDIENCE: I could compute the average. DAVID MALAN: I could also because indeed, this is only going-- I'm gathering the but then I'm manually So it does feel like there But let me also identify one and this is, indeed, subtle. I've got 3 here, I've got 3 here, albeit a floating point version. This is just ripe for me making a of those values, but not the other two? So how might I fix this? I might at least do something like this. I could say integer maybe n for I could then use n here, I could use n here, but because I don't want an int because I'm as before, but I could convert and we did that briefly last week. But there's one other thing I could do This is better because I don't in multiple places. Yeah, if I really want to say this should be a constant integer. Why? Because I don't want to I don't want to be and they foolishly change it on me. This just sends a stronger signal to the this value. And now just to point out if you have a number like I've deliberately capitalized for the first time. Any time you have a constant, to capitalize it just to It doesn't mean anything technically. Capitalizing a variable but it draws attention So if you declare it's commonplace to Moreover, if you have a constant that maybe next semester when there's four it actually is OK might be called a global inside of curly braces, it's literally and despite what I said a global variable like this to every function in this file. So it's actually a way across multiple functions, which using a constant. If you intend to change it, than actually using a global in contrast to what I call, by contrast, a local variable. But again, I'm just trying to reduce somewhere in the code. And I do agree. I don't like that I'm still manually even though clearly But for now, let's at been going on inside of So with this array, I now have not I have one variable, an array And if I want to access the first If I want to access the second If I want to access the third If I were to make a mistake which is the fourth element, I'd and worst case, your program could spinning beach balls, Just don't make those mistakes. And C makes it easy to so the onus is really Questions on this use of arrays? Question on this use of arrays? Yeah, in back. AUDIENCE: Is there any way [INAUDIBLE]? DAVID MALAN: A really good question. Is there any way to create an without prompting the human for it? Short answer, yes. If you want to have an array of you could actually do like 13, would give you an array This would give you an array of size are 13, 42 and 50. It's not syntax we'll use for now, It's not quite as user-friendly, if you've indeed programmed before. Other questions on this use of arrays? Yeah, in front. AUDIENCE: [INAUDIBLE] DAVID MALAN: Is there AUDIENCE: [INAUDIBLE] DAVID MALAN: Oh, is there a way to Short answer, no, and I'm about to Those of you who have programmed in certain other languages, it's very You essentially just ask the C does not give you that capability. The onus is entirely on you and me to like n, how long the array is. And so in fact, let me I'm going to go ahead and open that I wrote in advance here but there's not really too many specifics. So this is scores.c premade this time. And notice what I have. One, I've included cs50.h and stdio.h I have declared a constant That is now the same as I did introduce an average function, that I could compute the average That average function is going I want my average to be a But notice this. In answer to your question, average to do something iterate add up all the numbers, and divide I need to give it the array of numbers, numbers are. So I literally have Meanwhile, this code is the I'm declaring a variable I'm iterating from i to n. And actually-- yep. And then in this loop, I'm assigning value of get_int. The last line of main is this-- but don't just do it manually by Call the average function, pass in itself, and hope that it returns a float So I would claim that pretty much should be familiar. There's no real new ideas except for and this average function. So let me scroll down because this is the takeaway In this example here-- let me scroll up to copy-pasted the prototype And here's how I'm There's different ways of doing On line 28, I'm declaring a variable sum, and I'm just initializing it to 0. Why? Mentally I want to add up and then I want to divide by the total So here's my loop where I'm through the length-- so I am adding to the sum variable whatever of the array. So this is array, bracket 0; 2 on each iteration. And then the last thing I'm I'm dividing the sum, which is an divided by the length, which is 3, but 3 so that the end value, hopefully, is So the only thing that's weird When you define a function in C that a simple char, isn't just a simple you don't have to know the You can just put square brackets And I don't have to call it array. I could call it x or y I called it array just to but you do need to know OK. Questions on combining those Any questions? No? All right. Well, we've only dealt It would be nice to actually deal and the like, much like but I think first, some snacks and So we'll see you in 10. See you in 10. All right. So we're back. And up until now, just numbers underneath introduced arrays, which to store numbers back to back to back. So it turns out, you actually week even though you might And let me propose that we first chars instead of three integers. And for simplistically, I'm and c3 just for the sake of discussion. But I'm going to put our in those variables using That's what you do when to make the point that I can store So let me go ahead here and let me create And in this program, I'll first include And then inside of main, Char c1 equals, quote-unquote, quote-unquote, capital quote-unquote, exclamation point. So clearly not the best approach, And here now that you from week 1 that really number-- that numbers are just letters, We can really just use our to tinker with these ideas that there is indeed going to be no So let me go ahead and print out three And then print out c1, c2, c3. So I've got three separate placeholders. And we haven't really had occasion to unlike %s, which is put a whole Let me go ahead and make and it should print out &quot;HI!&quot; in exclamation points just three simple characters. But per our discussion letters are just numbers and it just depends on the So let me change this %c to an i. And I'm going to add a space separate one number from another. Change this to i, change this to So no integers, per se. Let me just print out those chars. Let me do make hi, no errors, So in the case of chars and ints, you so long as you have enough You don't have to cast even You do have to cast one of-- converting an integer to a float that you really intend could be destructive if it can't quite But in this case here, I think we're what's going on underneath the hood. Well, what is going on Well, something very similar. Here's that canvas of memory. And maybe we got lucky and it's like this-- c1, c2, c3. But these are just three but we're getting awfully close a string, which are just from left to right. And in fact, I think if we combine numbers underneath the hood with the idea of an array start to see what's really going on. Because indeed, underneath the hood, And really, if we go it's these three That's all that's going but it's our use of int that It's our use of char that makes it %i and %c respectively. But what exactly is a string? Well, it's really just a and so why don't we go there? Let me propose that we actually call it s-- we'll use So if I go back to VS Code here, and just give myself a single in double quotes. And then below that, let's go ahead and then s itself. And then, turns out, see, I do need to include to use the actual keyword string here but more on that another time. But if I now do make hi, it does compile same thing. But what's going on inside when I use a string called s you can think of the string as I, exclamation point. But it's not three separate But what does this really if I add back the yellow lines? s is really just an array of characters. So we called it a string that this is an abstraction in the CS50 but it's really just an here where s, bracket, 0 presumably 1 is the I, s, bracket, 2 But just by saying string, all I don't even need to tell the going to be in this string all at once. So in fact, let me go over to and we can see this syntactically. So instead of printing out let me actually be a little and then change s to s, bracket, Which is not better in any sense. This is way more demonstrate that I can as though it's an array, which means we just didn't know it. We didn't have the syntax So if I now do make hi, Same exact output, but I'm the string in these a string is just an array treat with the square bracket notation. But how do I know-- how does And this is where strings Like a char is 1 byte no matter what. 1 char, 1 character, that's it. But a string, recall my could be null bytes if it's-- you would think could be 0 bytes if you It could be one character, but how does the computer Like how does the computer not the whole row of memory here? How does it know that it ends here? Well, it turns out, all this time, string and using get_string there's actually a at the end of every string that tells the computer And the sentinel value-- just mean special value that the world If you have a byte with all 0 bits So the implication is that the computer can print out char, because it sees this special value. If it didn't have that, it might printing out values of memory that So I was correcting myself because I said that this string is of Every string in the world, is actually n plus 1 bytes where that you care about, H-I, but it's always going to use one extra at the end. And this 0 value is very as 8 0 bits. So we would actually typically But you don't want to confuse a 0 like the number 0 on the keyboard. And so we would actually typically So this is the char-based So it means the exact C notation that indicates but just makes clear that 0 that you want to see on the that is terminating this here string. So now what can I do once Well, I can actually even see here in VS Code. Let me change these %c's And now, we'll see again those there are the three. I can technically poke around a and let's look at s, bracket, 3. I was not exaggerating in general, if you go past the end But in this case, I know that there is because this is how strings are this is a thing in C. Every string ends with a backslash So if I really want, I can see which is the fourth and final location. If I recompile my code now, make hi That's always been there. So I'm always using 4 bytes, somewhat so that the computer actually So if we go back to the memory it's just as though you have an array of to back to back, the last one of which of characters, but because I'm because I'm using %s and %c, I'm I'm seeing H-I, exclamation point unless no, show me with %i This, then, is how you can Like you don't really it as being individual characters. This is just s, and it but it does not necessarily an array you get it automatically Now there's just-- not This backslash 0, actually a technical term for them. You can call them NUL. It's typically written in all In a couple of weeks, we're going but spelled N-U-L-L. Left hand wasn't but N-U-L means this is the 0 that indicate the end of a string. And fun fact, you've actually seen this Here's that ASCII chart from last time. If I focus on the leftmost column, NUL. You never see null on the screen, Whew! questions on this Yeah? AUDIENCE: Are strings [INAUDIBLE]? DAVID MALAN: Are string structured Yes. They are more powerful In C, you have to build More on that when we get to Python. Other questions. Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: A really good question. Does that mean we don't have a Do we have to create it? Short answer, there is a function, had to write code for it. You can't just ask the string itself What is the-- AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah, you can. It's actually more similar to Python but we'll see that in just So let's introduce maybe So here's two strings in and I've initialized them just so we can explore what's going to So let me go back to VS Code. Let me just completely change So string equals, quote-unquote, &quot;HI!&quot; String t equals, quote-unquote, &quot;BYE!&quot; in all caps. And then let's print them both out Print out %s backslash n, t just If I do make hi ./hi, I should, But what's going on inside Well, in this computer's these are the only two variables is just doing things is probably going to be stored somewhere &quot;BYE!&quot; is probably going to be stored there. And it's wrapping around, but that's But notice that it is that there is this NUL byte because that's how the computer ends and where &quot;BYE!&quot; begins, otherwise you might see &quot;HI!&quot; &quot;BYE!&quot; all on the screen at once if there to printf, stop at this character. But that's all that's when you have two variables in this way. And in fact, what's really going on and here, if I were to want notice that I could refer So s, bracket, 0, 1, 2, and even 3. t, bracket, 0, 1, 2, and even 3 and 4. But if I want to actually just playing around with notice what I can do in this version. If I know I've got I don't strictly need to and v. That's devolving back into the I had multiple variables even though I'm using different What if I want-- what if I do this? string words, and if I want to store two Create an array of two strings. But what is a string? A string is an array of characters, so but the ideas are still going 0 could certainly equal &quot;HI!&quot; words, bracket, 1 can certainly equal And then if I want to print these bracket, 0. And then I can print out %s And the example is not going to be but I've now avoided s and t, I now containing both of these here things. And if I really want where things get even more but just the logical Right now is the previous version If I now use this new version where just like this here, the picture words, bracket, 0 is this string; but what is each string? It's an array of characters. And so you can also think of it like 0, bracket, 0. So the 0-th character of the 0-th word. And this is words, bracket, 0, 1; words, And then words, bracket, 1, 0. So it's kind of like a And you can think about But for now, it's just applying So if I go to my code here and this is going to look a little stupid, %c, and print out words, bracket, 0. words, bracket, 0, bracket 1. words, bracket, 0, bracket, 2 to And now down here, let %c because it's four letters This is words, bracket, 1, but the the second character; words, and words, bracket, 1, It's hard to say when you're but that's what we get by using make hi. Whew! No mistakes. &quot;HI!&quot; Says the same thing. So again, there's no magic. Like you are fully in on inside of the computer's memory. And now that we have this array you can both create these things and however you so choose. Whew! Questions on arrays or Yeah, over here. AUDIENCE: Can you have any array DAVID MALAN: Good question. Can you have an array with Short answer, no; but not in nearly the same like Python or JavaScript or others. So assume for now arrays should be Yeah, over here. AUDIENCE: When you DAVID MALAN: Oh, a really good question. It will-- so for those if you were to look past would you start to see the In this case, maybe the word &quot;BYE!&quot; Could depend on the particulars Let's try this. So let's get a little greedy here and null character by looking which should actually be our null And actually, let's see. Let's go ahead and do this. Make hi ./hi. Still works as expected, but integer so we can actually Integer. And now, if I recompile make but numerically. And now what I think you're and go even past that to but we know semantically doesn't exist, So make hi ./hi. And guess what 66 is. Well, just the B, but yes. 66, recall, is capital B because So indeed, now we're And you can get crazy. Like, what's 400 characters away Eventually your program and so don't poke around too much, but All right, well how about some other Now coming back to the question and we'll see if we can then tie like cryptography in the for the purpose of So let me propose that we go into And I'm going to create Let's actually figure out ourselves So I'm going to go I'm going to go ahead I'm going to include And then inside of main, I'm going get_string, quote-unquote, &quot;Name.&quot; And then I'm going to to count the length of this string. But I know what a string is now. It's char, char, char, char, and So I can look for that. And I can write this in I know a bunch of different but I'm going to go with a while for number of characters, It's like starting to count and I want to do the equivalent of that I type in. So I can do that as follows. While the name variable at quote-unquote, backslash but it's just asking the at that location equal to Which is written with single quotes And what I want to do, while And then at the very bottom here, let's the value of n because presumably I'm starting at 0 and I'm going null character so I don't So let's go ahead and run down here. make length ./length, Enter. Well, I guess I'm asking for David, five characters, If I used a for loop, I but I think this while loop approach, is fairly straightforward. But what if I want to do this? What if I want to make Well, I could do that. Let me-- All right, let's do this. Let's write a quick function It's going to take a string And then you know what? Let's just do this in that function. I'm going to borrow my I'm going to paste it But I'm not going to I'm going to return the length n. So I have a helper going to hand me back and that's why this returns an int, How do I use this? Well, first, I do need so I don't get into trouble as before. Semicolon. And then in my main function, is something like this. I can do int length equals the that was just typed in. And now using printf %i, So exact same logic. The only thing I've done that's added a helper function how I can take some pretty find the length of a into a function abstract it to copy-paste that for loop. I now have a function that will solve this problem for me. Whoops, wrong program. make length. Huh. Use of undeclared identifier 'name.' What did I do wrong? Apparently on line 16 of length.c, Yeah, in front. AUDIENCE: [INAUDIBLE] DAVID MALAN: Good. AUDIENCE: [INAUDIBLE] DAVID MALAN: Good. Perfect terminology. So name is local to main. The scope of name is main, though And so I'm actually s because s is the name of the local happens to be 1 and the same I'm indeed passing in All right. So this is where, again, copy-paste Let's try to make length again. Now it works. ./length, D-A-V-I-D, and working. But this is such like Like my God, like has written a function to get and indeed, other people have. So it turns out that in C, just you also have a string library whose string.h. In fact CS50 has documentation, so to speak, along with But it turns out, in the is a very popular function that you asked about where strlen, one word, figures out the length of a string. And honestly, I've never but it probably uses a while but it certainly uses the same walking from left to in order to figure out what the So how do we use this? Well if I go back to VS the entirety of my I can throw away the and I can include a third of which I claim now is that I can just now use because someone else wrote And string.h will teach the So if I now do make length and ./length, that doesn't bother having So this is another example of a library. The string library is just going to for us not having to All right, well where else How about something like this? Let me go back into VS Code here. Let's create a program called string.c-- we'll play around with our own strings-- So let's include cs50.h, let's include string.h so we can int main void. And inside of this, let's do this. Let's get a string s and prompt the All right. And then let's go ahead and maybe And I'm just going to line up my spaces slightly different lengths, but It's just for aesthetics' And let's go ahead now and do this. If I want to print out every character Well, this is actually even though this version, thereof, i is less than the length of s. i++ is just the conventional way to to right over a string of that length. And then let's go ahead and printing out the string at location And at the very end of print out a new line character just like we've done in the past. So this is kind of a stupid program the %s format code. I already know that printf Suppose it didn't. Suppose I forgot about %s these lines of code here collectively character by character So if I compile this program, make for instance, David, and here's why I hit the because I wanted input and output to they're, in fact, the same length. So let me just stipulate. This code is correct, but there is an Let's talk about design instinctively. What is maybe bad about line 9 that I've highlighted? This one is subtle. Let's go over here. AUDIENCE: [INAUDIBLE] DAVID MALAN: Yeah. I'm calling strlen inside of the Why? Well, recall how for loops worked. When we walked through it last in between the semicolons keeps keeps getting checked. And so if you put a function call there, you're asking the same damn And the length of David, So strlen, implemented decades has some kind of loop in making that code run again to get the same answer So I think your instinct is right. I could come up with another I could do something like this. int length equals strlen of s, and But there's a slightly more elegant way. If you like doing things this is correct as I've now written it. It's less efficient-- it's calling strlen once but a more common way to be to do something like this. After initializing i, you can also And you can set length equal to and now you can say while Or I can tighten this up further. If it's just a number and it's a super n. So this now would be a canonical way but without the inefficiency calling strlen in the not inside of the Boolean expression again and again. Yeah? AUDIENCE: [INAUDIBLE] DAVID MALAN: Correct. Well, I'm declaring i as an I am also declaring n as an int. So they've got to be the same Good observation. Other questions on this one here? No? All right. Well, let's play around further here. Let me propose that there's as well that you might find useful. There's also something called and c's that's got a that we can actually see if we But before we get there, a program that maybe does something like forcing some string to uppercase So let me go ahead and write Let me go ahead and give Include cs50.h, include stdio.h. And for now, let's include And let's go ahead and have And inside of main, let's s equaling get_string &quot;Before,&quot; just Now I'm going to print out just so that things line up because &quot;After&quot; is And now I'm going to do the for int i equals 0, n equals the string And then inside of this loop, I want to force these characters lowercase. And so how might I do this? Well, there's a bunch but I'm going to do it maybe even if you've not seen this before. If the current letter in because I'm in a loop starting through the string or equal to a lowercase a, in single or equal to a lowercase z. What does this mean in English? Well, this essentially logically, if it's greater than or equal to little z, it's somewhere What do I want to do? Well, I want to force it to uppercase. So I want to print out a that prints out the current Well, how can I do this? Well, this is where this gets but notice the same ASCII chart. Here's our uppercase Here's our lowercase characters, Does anyone notice a relationship that happens to be the same AUDIENCE: Capital A [INAUDIBLE]. DAVID MALAN: Yeah. Like this pattern is true. So 97 minus 65 is 32, and that's true letter respectively. So I can leverage that. And this is not a CS50 thing. Like this is ASCII. This is, in turn, Unicode. This is how modern computers work. So if I go back to VS Code Let's just literally subtract 32. But because I'm displaying I'm going to see the lowercase letter Else, if it's not lowercase-- maybe it is punctuation, let's the original character unaltered. And then at the very let's print a new line just to All right, so let's do make uppercase. And let me type ./uppercase. And I'll type in D-A-V-I-D, you'll see it's in all caps. If, though, I type in maybe my last the rest of it will still Now I don't love this technique. It's a little bit fragile I had to check my reference sheet and Even though it will be correct, I could actually do something like this. Well, whatever the lowercase a is minus whatever and I could actually do it is somewhat inefficient in that and again, but the compiler is And frankly, for those more will also notice, no, want to call strlen again and again. The compiler can do some of but it's still good practice But there's probably a better way. Instead of rolling and subtracting 32 or let's use that ctype library. Let me go back up to my header files. Let's additionally include ctype.h. Let's pretend like I read the in fact. And let's instead of let's use a function that exists and pass to it whatever the current Otherwise, I still print And let me go ahead and do And now without any math, no But it gets better. If you read the it turns out its documentation tells it just passes it through for you. So you don't even need to ask I can actually cut this to my and just replace that let toupper handle the situation for has assured me that if it's just going to return So if I make uppercase, now it works and now things I mean, these are mundane but at least I'm standing on who came before me who implemented the heck, even the CS50 Library so I don't Questions on any of It's all still arrays, it's but now we're leveraging libraries All right. So let's come full where and I mentioned support for command line arguments. Like Clang takes command line CD, which you've used in Linux, If you type cd, space, mario in order to change If you do rm like I did by using a command line tells the computer what to remove. Well, it turns out that code that takes words at the command Up until now, you and I have only gotten get_float, and functions like that. You, too, can write code that frankly, just save the human time. They can type their entire thought at the program can complete without again. So here's where we can now start to Up until now, we've just put void we implement main. It turns out that you can put when using C. It's a mouthful, with this bigger expression. But it's two things. int, called argc by but not a string, actually an And these terms are a little argument count-- how many words Argv stands for argument another term for an array-- you've heard it perhaps It's like a list of values, or in this So C is special. If you declare main as not taking void an int and an array of whatever the human typed at as an array and the length thereof. So if I want to leverage to implement some programs of my own arguments. For instance, let me go back Let me create a program, that's just going to greet the So let me first do it Let me include stdio.h. Let me do int main void still. So the old way. And if I want to greet myself or I could do, old fashioned now, get Let's prompt for &quot;What's just like we did in Scratch. And then do printf, &quot;Hello,&quot; So we've done this many This is the old school way of getting user input by So if I do make greet /greet, there's I'm literally just running If I hit Enter, though, now get_string and the program then greets me. But I can do-- otherwise, I could do First, answer's a little this back to name and back to name, just stylistically. Let's, though, introduce so that I can just greet myself by and being done, no more get_string. So I'm going to go ahead and argv with square brackets. string means-- the square string means it's an array is just an integer of the Now I'm going to somewhat I'm going to get rid of my and I'm going to change this line to but I'm going to go into and I'm going to go into location 1. So I'm doing this on faith. I haven't explained what I'm doing yet, and now I'm going to type my name at with clang, with cd. With any of the commands you've I'm going to greet literally David. So I hit Enter, and voila, to what I typed at the prompt by argv. Technically you could call it anything argv and argc from right to left here. Just a guess, then. What if I change this to print out And I run ./greet David? What might it say instinctively? Any hunches? Yeah. So it's going to say hello, ./greet. So it turns out, you get one for free. Whatever the name of accessible in argv at location 0. That's just because. It's a handy feature. In case there's an error or you need to you know what the command is maybe 2, maybe 3 are that the human might have typed in. Well, let's do something a Let me go back to version 1. Let me recompile it, make greet. Let me rerun ./greet David, What if I get a little curious Let me recompile the code, make greet And I mentioned we'd see N-U-L-L, but this is clearly wrong. So I probably don't want to even don't want them to see bogus output. Like this is arguably that it even bothered to show this by Well, what if I do this? If argc equals equals 2, say printf &quot;hello,&quot; argv, bracket, 1. Else, if the human did not give let's just print out some like from last week. In other words now I'm doing this making sure with this if argc equals equals 2, and do you want to proceed. And so now if I do make greet again, But if I don't cooperate and I Just hello, world. If I run David Malan as two hello, world, because that's Again, the first word in argv The second word is whatever Now if we don't even know in advance we can combine today's ideas. This is going to look a little weird, for int i gets 0, i is less than-- how about argc i++? And then inside of this loop, I can and then print out argv, bracket, i. So I can have a loop that once for every word at the prompt. I can print out argv, bracket, i, from left to right. And so if I now run make I just see the program's name. If I do ./greet David, I see, If I do David Malan, I If I keep going, I'll So using just the length of the I can actually do quite a bit there. Now there's actually some fun and this is sort of beside this thing in the world is making pictures and beautiful nowadays Unicode characters, Like emoji kind of make But if all you have are and punctuation, you can actually On Linux systems-- for instance, let me increase the size And it turns out that we've for no compelling reason, but just which has a cow say something. So if I want to have a cow say and you get an adorable cow saying But moo is a command line modifying the output of this change it to say hello, is going to say that instead. So it takes multiple command But it also takes what are called flags argument that starts with a dash is option that you would only know or seeing a demonstration. And if I have my syntax right, if let's see. Instead of this cow say, how and I'm going to change And I'm going to have this version So it's a tiny little duck And you can kind of waste I can do cowsay -f dragon and this is just amazing. Again, not really but it does demonstrate, again, command and you've indeed been But there's one other feature to today, which will be a useful reveal one other thing about the It turns out that all of the programs obviously exit because unless you have an infinite But eventually they exit. And secretly, every program has what's called an exit status. It's like a special return itself that by default is always 0. 0 as a number in the world The flip side of that is because and you've got four like every other number in the world status is bad. If it's 1, it's probably bad. If it's negative 1, it's bad. And in fact, you've probably If you've ever had like a random here's a screenshot And that screenshot, somewhat has an error code like means that the Zoom software that some had an error and it did not exit with And somewhere at Zoom, or a book that tells the programmers This is not useful for you and me. There's some programmer at Zoom oh, I know what I did or my You've seen this elsewhere even though but we'll talk about If you've ever seen 404, like numbers 404 means like file not found. It means you made a typo, the web server but this is just to say numbers are errors. Even though that's not that's an HTTP status But you have access to to command line software already. Up until now, this is how with command line been writing main with And you've never used this-- we I just ask that you trust me and But that int means can return values which can be useful arguments and we just go back to So for instance, if I go ahead and I'll get rid of the dragon. And let's do one other program to play around with the idea of Let me just demonstrate the idea stdio.h, int main, and here And then inside of main, to before like the hello, world. So printf &quot;hello,&quot; Then let's print out argv 1. But I only want to execute that line argument. Otherwise I don't want to even say I just want to abort early and just So I could do this. If argc does not equal 2-- and it's a single equals, but means not equal. So this is the opposite Then previously I would have but now I want to print like, &quot;Missing command-line why the program is about to It's kind of arbitrary. I could also return 1132, This is the only possible error So I'm going to start at 1. Zoom clearly has 1,000-plus in their source code, which is but I'm just going to arbitrarily, But if everything is OK and I do-- it is and I actually get to line 11, I'm going signifies success. And all of this time, every program has secretly exited with that our programs are when something goes useful to have the power to just though the user is not going to see it. Even though the Zoom user It's diagnostically useful to to your TF or TA or CA. So if I do make status now to compile my first name I think this is a success. It should say hello, David If you really want to see the 0, there's You can literally type It's weird symbology, but it's This will just show you what did the with. So if I do this in VS Code, and there's that secret 0. I could have been doing this just not that interesting. But it is interesting, or at least and maybe I don't provide a command So argc does not equal 2. And I hit Enter, I get yelled but I can see the secret status And so now if you're ever in the or in the real world where you're be it with check50 or in the unit tests and other those tests can actually detect and know that your code And if there's different types status 2, status 3, status 1132, it's But all of that is terribly the goal of this week-- and really, is to solve problems. So let's consider an is the ability to send whether it is in file format, Cryptography is the art and Scrambling information. So that even if I write and I send it through this open who could look at the message, if I've should be able to read it, to whom I intended that message. In the world of means scrambling the information can receive it. So if we consider our black here is the problem to be solved. And let me propose a couple Plaintext is any message written that you want to send Ciphertext is what to before you just hand it off in the audience or a bunch any one of whom could So in the black box is a cipher, an algorithm for in a reversible way. It doesn't suffice to just otherwise the recipient It's an algorithm, a cipher that someone else can decrypt it. And here's a common way. Most ciphers take as input not only or whatever else, but also a key. And it's metaphorically but it's technically generally a of lots of bits. And not even 32, not even 64, unpronounceable large, that someone is going to guess that for all intents and purposes, So what's an example Suppose the secret message I want Well, it'd be pretty stupid to hand it to someone in it to get all the way to the back and obviously seeing and So what if I, though, agree with that our secret is going to be 1? And we have to agree upon but 1 just means that is my key. And let me propose that if I want to send &quot;HI!&quot;, change the increment effectively every and if you get to a Z, wrap So shift the alphabet by and send this message now instead. So is that secure? Well, if one of you kind of nosily you won't see &quot;HI!&quot; You will see some information You'll see an exclamation point, so but you won't know what the Now that said, is this very I mean, not really. Like, if you know I'm just using a key you could probably brute by just trying 1, trying go through all the but eventually it's This is actually known, And back in the day, before anyone else Caesar, Julius Caesar, was using a key of three, literally. And I guess it works OK if you're by lore to have thought of this idea, could attack it nonetheless and figure 13 is more common. This is called ROT13 on the internet for That changes &quot;HI!&quot; to &quot;UV!&quot; You might think what's better than 13? Well, let's double the security. ROT26. Why is this stupid? I mean, there's like 26 letters in that doesn't really help-- oh, wait. Oh, I'm pointing at something Suppose the message is more lovingly, Same exact approach, whether or not with an input of 13 And now it's getting a little less represents. And now, what's twice as secure is 13? Well, 26 is surely better, but of that, of course, just So there's a limit to speaks to the cipher being There is much, much better, more that are used. We're just starting with As for decryption, if I'm using a key Yeah, so I just minus 1. So B becomes A, C becomes B, I subtract 13 instead or whatever and receiver actually know it. So in this case here, this is actually If we have this message here and well, decrypting, it might Here's those same letters on the before we adjourn, I'll might have encrypted a this whole day, so if and procrastinated and figured and they didn't seem to well, here now is the This, if I subtract 1, becomes what? U becomes T. And this is obviously-- And if we keep going, subtracting 1-- now because this was CS50. And the last thing we have to say is we outside. So on the way out, grab [APPLAUSE] [MUSIC PLAYING]