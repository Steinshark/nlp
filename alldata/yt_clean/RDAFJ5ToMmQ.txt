In this video, I'm going to teach you persisting your data to local storage in a React yet very efficient way to handle all of this. I'm also going to show you how to take all of can directly use in any component that you before we get into that, there's two things that first one is that if you didn't know, I also we actually learn about local storage in the also show you how to take local storage as one of takes to build an actual real complex project with required to actually build such a project. fetching data, and so much more. And it's also I highly recommend it. I'm actually in the middle content, more modules, more tutorials. And if you the update completely for free when it comes it. I'll leave a link in the description. It's recommend it. And also the second thing is I also called Import React. I love the name. It's, of tricks delivered to your inbox completely for free in the description for that if you're interested. So let's begin. So over here, I have a very simple this count variable over here, which is a state then we're just displaying the initial value over over here to increment it where we're calling Super simple. Nothing fancy here. This is what count over here. We have the increment button. to increment the count. And this is a super simple use as our starting point to actually add local when you're thinking about persisting state, why you would want to persist state in the first state in a React application. So let's take, this wasn't actually a count, but actually that And this button over here, instead of being the to your cart. Let's assume that that is the case. as I refresh the page over here, our count, the lost all that information. To get it back, we have increment button over and over again. That's store this value somewhere in the local storage we can actually get this value back, and we can still change it. That's also very important. for using something like local storage. It's state necessarily. It's not that important. It's a different browser. It's not user specific per want to persist in local storage, as opposed to you're not calling any backend, and everything is to implement this in a really simple but very here, what we ideally want to do is we want this We still want this to be state in our actual able to change this with the button over here. to try to get this value from the local storage to zero, if the value is available, which means if second of all, every time that this value changes, storage, so that we're persisting the latest so that then the next time that we refresh the value directly from the local storage and pick up we're going to have to create some code that is going to be the code that actually works with that into a React component. And as I said, as to show you how to take all of this into a custom use across the entire application. So let's first going to come in here inside of the SRC folder. utils. And this is generally something that folder for any sort of utility, any sort of small application, which our local storage utils are a new file inside of here. And we're going to call we're going to be creating and exporting two in the local storage, and one function to get an with the set item. So we're going to do export which is going to be the key that we actually want using JavaScript, if you're not using TypeScript, just ignore the types. But if you are, it's fine, be of type unknown. Because really, we don't nor do we really care. All that we're doing it directly in the local storage. Then what cache block. And the reason we're going to and then we're going to do catch like this. The local storage, it can actually throw errors. For if it's full, because it does have a finite amount throw an error if there's no space, so we actually going to do is, we're going to do window dot local storage object on the window dot set item, and going to do JSON dot stringify, and we're going doing JSON dot stringify is because you can only any value that we have has to be stringified into then for the error, we're not really going to not that common, but we still need to handle them. going to do here error, we're going to console have something in our console that tells us that the local storage. And then we're going to do the item from local storage. So again, we're going to we're going to have to pass this here a key as that is going to take no other arguments because we're just returning a value directly from the we're also going to do a try catch block for an error, then we're going to do here const item we're going to pass it here the key. And now what then if we have an item, because again, we might set in local storage initially. So if we have an and we're going to return item like this. this. And then finally, we're going to do catch going to do here console dot log error, just like previous example. So now we have two functions set functions. And this is what we're going to use you may be wondering, why did we actually create didn't we just access the window dot local storage we could have done that, there's nothing really to handle this error case, even though it isn't throw an error. And it's always better to create instead that actually handles this. Because in both of these functions in this component. And littered this component. Instead, you put it function and you just use the function and you're any errors if there's any. This is a better way. videos and also in my course project react. So come back here to our actual application. And now actually defaulting this value to zero, we're first instead. And if there's a value, we're going same zero value to be used as the initial value. pass here a function to use state because we can going to do is we're going to do const item equals our utils. And here we're going to pass the going to keep things simple. That is going to be and potentially not. And then we're going to do a initial value. And now the only thing that we need we're just going to type cast this as a number. what actual value is here inside of this item because remember, we actually parsed it over here, don't have the type of it. So we have to actually over here that is going to be a number in any if we just defaulted initially to zero. So now our if I go here to the application and actually if I refresh, we're still losing the count because storage. We're not setting it as it changes. but we're not reflecting those changes in the that, we're going to come here and we're going to which is a perfect solution for our problem going to import this from React. Why is this not we go. We're going to pass this here a function array. Inside of the dependency array, we're going effect to run every single time that the count that we have to do is every time that the count the local storage using the set item function we can import the function from local storage, pass it here the actual value, which is going to it's running every single time that the count then we're going to be able to once we refresh the over here, and return it as our state variable. So our actual application. Let's reload. Now we're refresh and you're going to see that the count As we refresh, I can still increment this, this is I refresh and our account is still getting pulled console, make this a little bit bigger for you. local storage inside of localhost, you're going can I see it, there we go, we have our count, then you're going to see that the value is being single time that I reload, that is the value that this get item, and it's getting returned as a but still allows us to actually change it as state really it in terms of our functionality, we have put it in state initialize it correctly. And sync that value every time that it changes with this is pretty complete. Of course, you could can add a remove item function, which I haven't things simple. But you could easily extend this what I'm going to do is I'm going to show you of this into a custom hook to just literally for us in any react component that we want. and I'm going to make another folder inside of hooks. This is again, a really nice pattern application inside of the hooks folder to make we're going to create a new hook. And this one this is going to be a hook that allows us to have it persisted. So we're going to come use persisted state. And this function is going we're going to do the same thing, we're going to string. And then we're going to take this here value. And this one is going to need a type. And TypeScript. So I'm going to come here at the do t like this, instead of using unknown, like we didn't care about the value, or we didn't really we're not going to know about the value, but we going to get returned from this actual hook and inheritance inference, sorry, as we're using make sense in just a moment, trust me. So then right? So whatever type the initial value is, be. So if we're using use persisted state with if it's a string, everything is going to be a is we're literally going to come here and we can all of this code over here and put it directly going to be recreating the same functionality. we're going to import our get item function, we're to import our set item function. Now instead we're going to pass the key that we have here. pass the key directly, that is a string, so it to change this count variable over here to just clearer. Because again, this isn't necessarily value. And then over here, as the return function, instead of hard coding it as a number, we're that is what the item is going to get returned as. our initial value over here. So we return that to use this value from the hook and actually use we're going to come here and we're going to return value, which is exactly what you state returns. automatic your types and everything we're going to be a fixed array of only two elements. And the the second one is always going to be the setter we took all of our functionality, and we put it over here, an initial value, the initial value is just know that that is going to be what we return over here that just tries to get the item from T. Otherwise, it just returns the initial value, work. Then every time the value changes, we just return everything as a constant as a fixed array And then to use it, all that we have to do is get needed, get rid of everything over here. And we're going to pass it here, the key, we're going to do we're just going to pass zero. And there we go, now we have a custom hook that we created, we can component that we want to have persisted state, value. And if I hover over the count over here, this type is getting inferred from this zero over we know that initial value is going to be of type the local storage must also be of the same type And then we have our setup function, which works state. So now let's open up the browser. And let's we can actually refresh and we're going to we still have 15. In our local storage, I can still works. It's perfect. If I come here and and then just refresh, now we have no value in to a value of zero. And we can start all over can reload and we still have the same value coming exactly as we expect. And there you go, guys, we have a custom hook that we created. And super efficiently. And also remember, we're still never going to break in a way that we don't and we can actually handle it if you want it to. book to bring this into the React world. And now code that we can put in this component. And we can in our application. If you enjoyed this video, and make sure to leave this video a big thumbs up. can click here to watch a different video of really going to enjoy. And with that being said, Solutions. Thank you so much for watching. And