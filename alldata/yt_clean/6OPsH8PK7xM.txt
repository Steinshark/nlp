Ever wonder if we could Today we'll be looking at the most P vs NP, from this unusual angle. By the end of this video, you'll question is ultimately about First, we'll meet satisfiability, or among algorithmic problems. We know literally thousands of still have no idea how to solve it. Next, we'll break a famous cipher and using SAT to run it backwards. Finally, we'll see how the idea to the most important question Our story starts with the satisfiability This is an incredibly powerful problem. We'll see that, if we could use it to reverse any algorithm. Let's see what the problem is about. We're given a bunch of boolean set to either true or false. But since I'm a programmer, We're also given a bunch of logical that have to be satisfied. In the general SAT problem, a complex logical formula like this. But for simplicity, we'll only In this variant, each constraint negations that are connected by OR. So, for example, this constraint or c must be 0, or d must be 0. The task is to set the values all of the constraints. This specific choice works because constraints and simplify, Every constraint Given a large satisfiability out that there is no solution, is a But let's make the following Let's say we do have a Would such an algorithm have The answer is that it would that we have about our universe. To start with the tip of the iceberg, fast SAT solver to break perhaps The security of the RSA cipher rests writing an input composite number really hard computational problem. As far as we know, that is the case, we could suddenly solve factoring. Let's see why. First, let's talk about the inverse Let's say you want to multiply two really We can reduce this problem to SAT. We're going to utilize the you know from school. You've learned it for base 10 So let's convert the numbers 3 and We first compute the intermediate To convert this algorithm to a it as a so-called circuit. A circuit is simply a bunch of wires that apply simple logical functions. You can fix the value of Then the signal propagates through the the output off of the wires at the end. Coming back to our multiplication represent it as a circuit. You can see that there are two sets of We can now encode the numbers 3 and 5 The first part of the circuit uses AND You can see how the values of the gates in the long multiplication algorithm. The second part of the Each row of adder gates adds the next Finally, we can look at the and find that 3 times 5 equals... 15! This special plus gate in the make the circuit more readable. The gate performs a This is how you can implement it You can pause to work out how the other the exact details are beside the point. What matters is that we can algorithm to a circuit. Now, let's see how we can convert Let's take a simpler example first. We create a variable for Next. Consider any gate like this one that says We can encode the logic of this gate Let's start with the first one. On the one hand, if either c or e to be satisfied because not 0 is 1. On the other hand, if both c and e are set So the only way to satisfy If you think about it, this constraint the inputs to the AND gate are Similarly, the other two constraints when one of the inputs is 0. We can do the same thing for all gates. And by taking all these constraints represent the logic of the Let's do the same for our In this case, we need around 80 What happens if we feed Well, the solver ensures that all the circuit being run on some input. Remember that SAT problems Our constraints don't specify any so there are many solutions, each being run on some two numbers. The solver can return any one of these. Let's narrow this down by the input to the algorithm. To multiply, say, 5 and 3, we first and based on that we put additional that just say that wire x1 is 0, If we run our SAT solver now only one solution is valid. The one that corresponds to running the input numbers we specified. If we then look at the variables that value of the product, in this case 15. Okay, maybe multiplying numbers the real fun starts when we realize Instead of adding constraints that specify we can also fix a certain output. For example, if we want to force the do it in the exact same way as with the output wires instead of the input ones. And that narrows down the possible the ones where the output is 15. In other words, we're solving output of the circuit is 15, That is, we're solving factoring. There might be multiple possible inputs solver will just choose any one of these. For example, in this case, 1 times 15. Well, that's not very helpful, is it? When we're factoring, we also numbers must be bigger than 1. We can ensure that's the case by adding It would be a bit too messy to show that Alright, we run the and there we go, we've discovered Brilliant. And if we try to do the same thing for us that our instance is not satisfiable, Can we use our trick on That would require factoring Using our trick, we would get with about 50 million variables. That's way too much for didn't break RSA, fortunately. But the point is that if we did have linear or quadratic time, we would So an efficient SAT solver would mean already a massive consequence. But if you think about it, the If you look back at how we converted of that problem was that you can use a SAT then enabled us to, in a sense, backwards and solve factoring. Of course, you can't literally run satisfiability problem is so hard. It's a bit more precise to think If you think about the original circuit allows us to represent the inverse If there are multiple inputs leading leaves it to the SAT solver to choose one. At this point, it's really important can be represented as a circuit. We wrote a proof of that in our linked read it, just look closely at your CPU. Ultimately, it's just a So, whenever we have an algorithm, and then use SAT to invert it. So, instead of answering the question input, what output do I get?&quot;, we a certain output, what input do I This is an incredibly powerful examples of how it can be used. For example, take the 3-coloring problem supposed to color each node in one neighboring nodes have different colors. So, this would be a valid coloring, but it's no longer valid because now it When we have a proposed solution, it's We just iterate over all the edges, the two sides have different colors. So again, we can think of this Oof, the circuit looks even messier Let's at least fade some of these I won't go into the details here, but gates for every node and for every the coloring is valid on all edges. Then, there's this single output wire It tells us whether all of the gates the input is a valid coloring or not. When we run the circuit on this faulty It's because this NAND gate is not are adjacent and have the same color. Then, we encode it into a SAT saying that the output must be 1. This way, we've managed to The SAT instance now asks to coloring checker will accept. In simpler words, we've encoded In general, think of any problem like whether a proposed solution is correct We can use our trick to encode the But this function maps the This gives us an incredibly We can now finally connect The theoretical definition of a complexity is a polynomial function. The class of all problems where in polynomial time is called NP. And it contains most important computer factoring, and even much simpler The trick of converting works in polynomial time. This means that a SAT solver would imply a polynomial-time But here's a fun fact: the satisfiability A problem is in NP if there for checking solutions to it. And for SAT, checking if a You just iterate over all the constraints So you can view satisfiability Because once you've solved SAT, you've Formally, we say that a problem and any other NP problem can be So using our trick of converting that satisfiability is NP-complete. This is one of the most important and it was proven more than 50 years by Leonid Levin, who you may remember And it gets weirder. Soon after Cook proved that SAT is named Richard Karp published a famous looked around at about 20 other problems the traveling salesman problem, and all He proved this using so called reductions. Basically, similar to how we converted you can start from SAT and convert it Soon after Karp, researchers identified NP-complete problems covering all theory, optimization, machine learning, Remember, NP-completeness means that if NP-complete problem, you have one for So in some sense, it's debatable whether They're all just different formulations All of this begs the question, algorithm for satisfiability? This is the famous P versus NP problem. At this point in time, the best SAT faster than just trying all possible You can solve small instances of SAT already in the 60s, researchers pointed of SAT if you just try and try and try. And that makes a lot of sense, because algorithm for satisfiability would We have this intuition that between verifying a potential Equivalently, we think that if there function, there doesn't necessarily have A polynomial-time SAT solver would mean fast algorithms for literally It would also imply that That's not just because we would Think also of hash functions. Such functions are often called literally designed to be easy to You can think of these Will it blend? That is the question. They perform complicated operations on reverse them if you only have the output. It's analogous to the notion of entropy It seems that it's easier to make a Unfortunately, the difference between can't simply declare P does not equal NP as As far as we know, fast SAT solvers could maybe could invert any messy algorithm. We just think it's very unlikely. But in that case, why don't that P does not equal to NP? The big issue here is that while we with fancy new algorithms to solve ways of proving that a certain problem So we suspect that P does not proving it is really, really hard. I think this is a good intuition for what The heart of the problem is This is of course closely connected to namely whether we can efficiently efficiently verify proposed solutions. That's because inverting a to solve the original problem. I hope you find this If you have a question, Also, check out our blog post where that we made here for the sense of things that we considered too crazy That includes how you can explain the backpropagation as an algorithm If you enjoy our videos, Ah, that's so cheesy, isn't it? If you enjoy our videos, like supporting us on Patreon. I'll see you next time.