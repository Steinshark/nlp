- Welcome back to fsharp Conf. And we're here with Jeremy. And he's joined us from Portland. - Hey, y'all. - It's actually warmer there today than here. It is super cold. - You chose the best day to come. - Yeah, no joke. - And you're going to be talking about SAFE Stack. - Yeah, SAFE Stack 2018. - Yeah. but a lot's changed since then. - Yeah, you gave a similar talk at .NET- - I remember. It was awesome. And it was warm, so this year we'll be getting because it is super cold. - Yeah. So, because there were quite a few changes, And I know that there are going - There will be some live coding. It won't be as amazing as Tamiz - It will be amazing. Cool. I'll let you get started. All right. Like Lena said, I am Jeremy, and we're gonna Before we get started though, I want to give a shout Conf happen this year. Like I said, I'm on Twitter @mrjabbott. And you can email me here. And I have a blog that I never update. So, yeah. The SAFE Stack has everything. So, what is it for? It's for functional-first full stack development. We're going to break down talk about some of the features and then we're gonna do So, to get started, at a high-level Azure, Fable, and Elmish. It used to be called like it was just Suave. In the last year and a half and we have a lot of options now on or web APIs or whatever the case may be. So, on the server, we can use either We're gonna talk a little bit about Suave today, The A, of course, stands for 'cause that's a whole different conversation. But SAFE Stack apps can be deployed to Azure And then we're gonna dig into Fable and Elmish. One of the cool things about the SAFE Stack is that it allows you to share code And I put that caveat in there because but we're gonna look at some scenarios And it's F# all the way down, so there's So, why would we do this? One, type safety. If you're doing any sort of client-side code, TypeScript or some other transpiler, So you're gonna have to deal with things equals, weird number types, As we're gonna see through our live coding demos, Like I already said, some practical code reuse. We get to leverage our F# language features so pattern matching, I don't have to worry about, again, other weird One of the really cool things about the SAFE so you can hit up LambdaFactory or Compositional IT if you do want to get some more on how to support the SAFE And these slides are gonna be posted later, One other thing to point out is the SAFE Core daily validation, And also, while we're talking about Stack with React Native, GitHub repo, there's an example of that. Cool, so let's dig into what So, server-side F#. You have a few options. These are just some of them. There's Suave, Giraffe, and Saturn. And we're gonna really focus on Suave and Saturn today, And a really basic example, this is what a And we have what's called a web part here up. It basically is ... a web part is a function that represents and then you can compose those together So, in this case, I have a web part And then I could actually compose so if I had a get request I would get back that Hello F# Conf. Then if I said opposed to goodbye, And the key part of how these web parts work based on different little So, if I'm doing a get, I hit this branch then I would keep going and so on and so forth. And the same for the post scenario. One thing about Suave is it's not just I can configure the web server I'm just using the default But like I just say start web server. I give it this web part, which is the composition and that kicks off starting my web server. Another framework we're gonna talk about What I really like about Saturn is that and web development on that stack, if they're not familiar with the language So, something like Suave might not be the best way with all the functional even though F#'s an odd they're also gonna start that might scare them which are used for composing the web parts. Even though after you get used to it It's just one more thing that So, it's another hurdle to adoption. And what I like about Saturn is that Saturn adopts and it also can return We're gonna use a spa-style app today. When you talk to somebody, and you're that's a vocabulary that they're already Web API or ASP.NET Core or whatever the case may be. So, what I like about this example is I have an action, except I just threw a little emoji in there 'cause why not? And then I have a controller or whatever the case may be, And then I set up my router. I'm gonna forward anything that goes Then I set up my application. And what I really like about this application piece of just setting up and ASPI Net Core. And that's one of the things is it uses computation expressions to hide some of Doesn't necessarily prevent you from using it, but it just sort of gives you some really And this is actually true. If you present this as I have at my own ... like where I work, this is a lot more user-friendly So these are things that they can reason about And Saturn sits on top of ASP.NET And Giraffe is actually except that instead of using its own it really is just building Core so you can take advantage of Kestrel And then Saturn just And like I said, it has some Saturn has what are called rings, It also has something called moons, to write like a full web application. So, you probably need some sort of persistence model, but you also need to be able to change It hooks into Dapper for a database Simple.Migrations for doing One other really cool thing about Saturn So, I can do dotnet new - which you all should go do And I can say dotnet new saturn. Give it - lang F# and blah, blah, blah. Go to the source. Then I get some really cool for templating out really common so I can create a controller, and my migration by using something This application is about storing Pokemon so that's why that's what that is. But I can put my keys right here And then I can actually run my migrations. And so, this is some really nice tooling or maybe some other completely And Saturn gives that to you So, next up, like I said, So, we've done S and A, but now we're gonna do Fable, And if you're somebody like me who's really, especially with making things look nice, Fable, well, first off JavaScript. This is my trying to do anything in JavaScript. But the way Fable works is basically you're writing F#, but behind the scenes, it's using web pack JavaScript that is usable well, in all modern browsers So, you're going from F# and then using Fable And it lets you create, write F# If you go to Fable.io and click on the REPL, you can play with the REPL in the browser and see what some of that And I would highly recommend I've been using it a lot lately, because I haven't had to dig for things that I'm not super familiar with. And I've had a really great experience. So, last thing before we get into some live coding Elmish leverages the model view So, the idea is I have explicit state and I have an update function and make a small change And then the view renders whatever So, it's not just for web apps. To show that I'm actually gonna If I can find it. Not that one. That actually shows how to use ... how Elmish works at a super high level. So, like I said, Elmish is based on Elm, In this example, my model is just a record type It accepts an input, and it has some output also. And then these are the messages that will be used So, obviously, since we're talking the view is actually just So, our view in this case actually is and then whatever the user and Elm dispatches through the application cycle So, in this case, I read something in. I turned it into an actual message type. And then I dispatch it. And then the update function whether it's error increment, Will not actually mutate. Will create a copy of the record type and then that'll get rendered. So, if I run this, give that a few seconds. It says, &quot;Enter command of increment, So, I'm gonna say increment to get started. Hopefully, that works. It's one. We can say it again. And what's happening here is when it says read line, And basically, if you have increment, If I put in something that's not valid, And then if I exit, it just kills the app. So, at a high level, that's really So as you define some messages, and a discrete change and then that gets rendered. And then inside the view, I can, I can dispatch other messages Cool. So, before we get into our live coding, let's talk You need to have the .NET anything higher than that installed. I think I'm using the preview or one of the previews I'm pretty sure I'm using 9 something. Yarn or there's some overrides If you're on a Mac or on Linux, and that's just for the build tooling. At production time you just need the .NET And then for an IDE if you're using one VS Code with the Ionide extension, You can install the SAFE template So, I can say dotnet new - i Safe Template. And then I can create one. Dotnet new SAFE. Don't forget the -lang F#. And then give it a name and an output. And then I can go build it. The template has some pretty cool options. So, like we talked about, you have The default is Saturn, but if you want to change that On the client-side, since we're using Fable, which is an open-source CSS framework so you can use the Fulma bindings without having to do And these are just some of the options. I can say --Fulma basic, landing, hero, Or you can use whatever framework you want So, for our live coding demo So, in this case, I said dotnet new SAFE - lang F#. And I'm using the basic Fulma template. If you're on Mac or Linux and you want you need to give it execute permission But, I've already done that, I don't need you anymore. Don't need this one anymore. All right. So, we have ... Like I said, this has already been spun up, and I've made a few minor tweaks to it But, you get up here, I've got a basic model going. If you remember from our Elmish example, I only have one message type right now, and that's just And then I have just a function which you have to pass to get it started. In this case, obviously, at some point And hopefully, we don't have With me, that's probably And then I have my view stuff here. In this case, we're actually using React, so this can but if you think about the syntax here is basically Let's find a good example. When you think about HTML elements, I have a function HTML attributes and then it takes as a second argument, So, when I read through this, I can reason about it and I don't really have It's just basically a pure React component. And then I have a container element I have a thing that says, And then down here is just the So, let's take a look at what You probably already guessed but we're gonna wrap an API to prevent And so we're gonna look at the Pokemon API and F#, As you can see, content goes here. We go back to our code right now. We have content goes here. I already have this running in the background. And what's really cool about the SAFE I have the web pack dev server recompiling and hot reloading the And on the back end, I can use .NET which means I don't have to spend time Like been looking at my app And to sort of demonstrate that we're We're gonna go back to the client. We're gonna wait a few seconds. Bam. And that's just on the client-side. We're about to make a bunch of server-side changes. So like I said, we're gonna And to do that, I've already created some So I have a couple of endpoints that I'm wrapping And I have some little helper functions And then it's getting mapped to a shared Inside of shared, I've got a couple types that are so if I go to client, fsproj, I can see And also if I go to server fsproj, So, I kind of mentioned earlier A common use case, at least one that I would use, would be I'm gonna have some and I have to model that on the client So, this is a really great use case for that shared I can model that in the client And we're gonna do exactly that here. So, first step you're ... Maybe my client should actually do something So, I'm gonna cheat and go over to my so I'm actually gonna create And I already did this 'cause I don't So I go in my Saturn controllers. I'm actually just calling the API wrapper. We're gonna kinda break down again So, I have an index action and under the hood, If that wrapper returns success, we're just going And if it's not, we're gonna raise an exception. And then down here So, I use a computation expression to set this up, So, in this use case index It doesn't take any arguments. Down here, by default, Index says, &quot;Give me a handler.&quot; That nhtp context and then returns nhtpFunc, So I have that setup. So I need to go wire that up on the server. You can see it's already rebuilding So on the server, in my server code, I need to So, we're gonna create an API router Back on the server. So go over here and then I'm gonna So now I can say forward anything that's, so it's just going to like the IP address But if I want to go anything to the API, and I'm gonna say API router. Save that. And it should, in a second, tell me everything's okay. And we can actually test that here. Says application started. So I say send. In a few seconds, I should get Cool. So, that covers updating the server. We already saw the rebuild. I was able to test it immediately without So we have to do some client-side work. So, we need to update our client-side model. Right now we're just going So back to the client. Go to our model record type. New line. Cool. And that broke the emit 'cause We're gonna say by default we don't have any results So, we're good there except for that needs to be And that's good on that side. We need to add some new message types So, the way this is gonna work is emit using Fable's fetch wrapper And then once that promise is resolved, to actually update the model Oops. Don't need the top one anymore. Get rid of that. So, now I've updated my emit, Let's see. So, before we fix those compiler errors So, come up here. Fetch is pretty cool I did this last time too. It uses a promise computation expression, so I'm able if you're used to using like or the acing computation expression without having to do So, in this case, I had to find Content type's And then I just say fetch dot fetch as, and this is And then I match on it Again, what's really cool about this is is like this is And this is gonna get compiled So now the emit command isn't It's gonna kick off our loading the client We're going to update Before it was command dot none. Now it's a command of a promise. I give it the function to call. Some extra arguments And then I give it an argument if the request is successful if the request is not successful. So, if it's successful, we're gonna which accepts a Pokemon list. If it's not, we're gonna call load error Now we need to update my update to Well, I already did that. So let's go over here and add What I like about the update save There's not any major magic So, let's kind of break This match expression is gonna and a subsequent command As you can see here, most of the time So, in this case, on the emit we say On the load list side, we can say a Pokemon list So we create a new record type And then we just set And we say loading equals false. Now, if we actually want to see that though where it says content goes here So I have a little function We're gonna throw that right here. And most of these functions, and they take in like a model If the view that's being rendered doesn't you can forgo the dispatch part. In this case, I'm not using And then I'm gonna sort of create that will cover all of our Awesome. So, in this case, as soon as I hit save again, So now we need to replace our STR Model. Sweet. So now if I go back here, I have content. So what did we just do? We added a controller, message types to deal with loading We updated the model to represent I don't think I need that. And then we added some new view code So, we've kind of got something here and I'm guessing a lot of people don't know They're just words So, why don't we add Like if click on one of these, we should see And this will give us a chance So, we're gonna start First, we're gonna add which will be our show action. And so following traditional and it's a get request, and then returns So, that's what we're gonna do here. We go into our controller again. We add another function. This is the show action one. It's, again, just calling the API wrapper And the model is fairly similar There's probably some abstraction but we'll deal with that later. And then I want to wire So I can say for show, One thing that's important to point these functions could be named anything I'm just using that way So now I've actually already and now that I'm listening to me I think most people know And it's okay Cool. So, now we can wire up the client All right. So, we're gonna follow that I need to write a function that is API, which is, in turn, and the deserializing So let's go add that function. We may as well just put it right This is, instead of load and somehow I still So, there's not anything that's super Probably another great example but we're, again, We expect a Pokemon response And now we need to create We can also create our function that returns the command that So we can go do that down here. Just for consistency sake, or maybe not, And right now I have an error at least one message type I got a super fun red error for that. So, first, we're gonna And also just results, I need so I need to have a command to ..., or I need to keep so that I can use it somewhere. So, we're gonna update our model one last time, So there's the idea of search text, And then there needs to be a way to indicate and then also change it based So now the model's updated again. If you go down, our net function's gonna be upset So let's add those. Pokemon equals none. And search text equal empty string. That's fine. So now we just need to go back in So, we actually have three of them. We have the clipped event, we have or not events, messages. But kind of similar ideas. So let's go pop those in. Also now that reds all gone away. The problem is though my update function so we should update And we're gonna do that right here. We got load list, so really I think we'll try that one. Let's see. Update is somewhere. There it is. Add those in. Let's actually line everything up So, now on clicked we're gonna On Pokemon loaded we should update the And we also need to update the view So, we're gonna add one more function in here And we're gonna throw that in here And we need to actually use that. So we can say results column, And one last thing that we have to do That's actually not right. We already did results. My bad. Sweet. And it's compiled successfully. If we go look at our view ... Now if I click on one, Cool. And we know it works when I do that. So, let's go look at one thing real fast. A sink load. Name. Let's see. Yeah, so this is case sensitive, so So, we're gonna do this real fast. And I'm glad I remembered Dot to lower. Save that. Let it run. Let's see. Let's try that one more time. Boom. So now I have on the right if I click that model we created Pokemon will actually change. We can pull that up Ignore the web socket errors. I don't know why those happened. But I can see oh, Cool. But I'm not worried about that one, so we can also say The problem right now is I'm never So that's actually a bug But you can see every time Pokemon clicked, Charizard, And then we update the state. Loading is true. We have some error text Search text is that. If we look at this one actually though, the selected Sweet. It's right here. And then get the new message and we can see that selected one So we can sort of keep track and there's some tools that will and replay messages So, that's the end of the live coding part. There's a few other things we could do, So, the main things I wanted to point out even when I had a bug. I could just go make the change to it, I just want to make sure things to make a request to it to make sure And then on the client-side, So, to go back to our slides for a second. The only parts, like I said, to sort of save us some time. Type providers aren't really although obviously, they could be when you're dealing with other APIs. I really just wanted to deal with and how Fable and Elmish work. Cool. There's another flag you could So if I say dotnet new save and it will actually add to create a Docker image And then you can use, like I said, I don't think I have anything else. So, I hope that in this almost 45 minutes can make you really productive, Elmish can help you really track down bugs We found one while we were looking at it. There's a couple other things On the server, not on the server, but for the app we're Paket instead of just regular NuGet packages. So, if I go look for like we're just I don't have any package references in here. Instead, I have a reference And then I have a Paket references file, which explicitly defines And what's really cool about this Well, there's a few things, I can see what all of my client-side dependencies are all the way down not just the things but also the dependencies for those, and also makes for repeatable builds in a actually repeatable way. So I would highly recommend looking at that. Paket also has a CLI obviously so if you are using either package you can convert those over using Paket's convert from NuGet. It works really, really well. And then my build script it using fake, it's pretty simple as far as fake scripts go. The key part to it is probably the run command, It's kicking off the web pack dev server for Fable, Let's see. There's a bunch of resources. Like I said, I'm gonna tweet the slides out. The SAFE Stack docs are great. Compositional IT just did a SAFE Dojo app. It's on GitHub and it walked you through a really And then I have links to the docs for Saturn, Like I said, I'll have the slides out later. Thank you for your time, - Thank you so much, Jeremy. - Let me check. Yep. So, I did get a few questions here. - Just one question from someone in the audience So what are the trade-offs? Talk about that as well. - Yeah, I think the best ... As far as trade-offs go, I, with respect to If it's just like an F# team and I mean Giraffe or Suave is probably fine. I would probably favor Giraffe personally over Suave But Suave is equally fine. I've actually published apps I like Saturn because for like I can explain concepts And then as we need to do we can pull out some of the Giraffe functionality And that's the way I can describe it. - Sounds good. Let me check if there I think that's the questions we've got. - Okay. Thank you so much. - Thanks very much for coming, - All three hours. Well, see for someone - That's a few countries, right? Thanks again for coming. And if you're watching us live, stay tuned. We'll continue in a minute with a Q&amp; Software Foundation.