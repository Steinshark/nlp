Ahh, Minesweeper. For many of us, it was a defining game of our childhoods alongside Pinball and... ...Solitaire? But funnily enough, as a kid, I never actually figured out how to play it. I feel like someone did tell me at some point what the goal was and what the numbers meant but my baby brain probably decided it was too much effort. Instead, I'd just set the size as big as possible and the mines as low as possible and pretend I was a minesweeping god! [censored] yeah, ever seen a one second speedrun?! But recently, I was playing around with the Flash emulator Ruffle and came across this gag in an old Flash game called Windows HIV. And of course, I'm the kind of person who's like: [nose exhale] I wonder if you could actually do that? I mean, hey, April Fool's was coming up so I thought it might make a... [nose exhale] ...worthy prank! First, let's make sure I'm not being obtuse and you can't just set the mines to a high enough number to fill the screen. 9 times 9 is 81, so let's put that in! No, it's limited it to 64. And if I choose the expert size, it limits to 435. So I guess there's some sort of algorithm in place ensuring that the game remains... well, I don't want to say &quot;winnable&quot; exactly. Well, looks like this is going to require some hacking after all, so let's get to it! So occasionally people just getting into romhacking ask how I know where to start. I mean, in a program with thousands or even millions of lines of assembly code, how do you find &quot;the thing&quot;? Well, the truth is it's mostly educated guesses and luck, however on PC, you do get a huge benefit in the form of &quot;export symbols&quot;. What are export symbols? They're the main way that a process calls code in another library. Libraries like the ones in Windows or the standard C library. Since all of these libraries are well documented, even if we know nothing about the Minesweeper code itself, we can still get a good idea what it's doing by how it calls these other functions. So we want to find whatever code sets the tiles to mines. Well, we know it places them randomly and unless they went to all the trouble of writing their own random generator into the game, it probably uses a standard function from one of the aforementioned libraries. Checking over the symbols, we can see that, yep! It imports &quot;rand&quot; from the standard C library. I'll put a breakpoint on that, which basically means the debugger will pause the game and tell us whenever that function is called so we can see exactly what's going on. And there we go! Here's where the game calls &quot;rand&quot;. The game only uses &quot;rand&quot; once, wrapping it in a small function that I'm going to assume is used to limit the result since &quot;rand&quot; itself doesn't actually have any options to do that. This wrapping function is called twice in the game, both in the same loop, effectively making this the only place in the game where randomly generated numbers are used. Looks like where we want to be! But initially, the fact that it was called twice kind of confused me because for some reason I'd assumed the way it would work is by looping over every tile in the game and randomly deciding if it was going to be mine or not. I don't know why I thought this because it's objectively a pretty bad way of doing that, but eventually I realized what it was doing and what actually made a lot more sense. It chooses a random X and Y coordinate, hence the two random calls, and checks if that coordinate is a mine; setting it to a mine if it isn't. It does this on loop until it's reached the number of mines it's trying to make. So my first thought was just overriding the mine count in this loop. Sure, it limits how many mines you can enter, but if the loop just happened to make more, it probably wouldn't notice. I didn't know if this would work, because I mean, picking tiles randomly until they're all mines is not very efficient at all. But I wasn't prepared for what did happen... No infinite loop, not even any noticeable slowdown, just... this. Soo... yeah, in an attempt to make all of the tiles mines, I've made... none of the tiles mines. This... made... no sense to me. At all. And stumped me for quite some time. On a whim, I tried some slightly lower numbers and it worked pretty much as expected, at which point, I gradually figured out what was going on. Apparently, it's a common rule in minesweeping games that the first click not be a mine. I guess that would be pretty unfair. So on the off chance that you do click on a mine in your first move, the game quietly moves it somewhere else so your first click is always safe. So what happens when we make it extremely likely that your first click, and in fact every subsequent click, is going to be on a mine? Well, I think what's happening is the game is still trying to prevent a &quot;game over&quot;, but since there really isn't anywhere for it to move mines to we end up in this kind of limbo state where all the tiles are both mines and not mines. And they probably didn't code for this sort of scenario because ordinarily the game ensures a certain amount of free tiles. Well obviously that's not going to work for our gag, so how can we get around this? I decided to whip out Cheat Engine for this. It can be a little better for finding specific values in memory and is another good way to find where to start if symbols don't happen to help in a situation. I made a guess that the value we were looking for would either be a boolean, that is, a true or false that's set to true when a free tile is unveiled, or just a number that counts up how many free tiles are revealed. Either way, that value would start at zero upon reset and would be greater than zero once a tile was revealed. My hunch turned out to be right, and I soon found value where if I forced it to one, a beautiful grid of mines appeared every single time! So now, I just have to find the assembly instruction that sets it to zero, and set it to one instead. Turns out it was right under my nose the whole time. Right below the random placement loop was the instruction setting it to zero. Great! The only problem now is... replacing it. An instruction that sets it to one will require more bytes than we have, so we'll have to make some more space somehow. Here's what we can do. You see this other instruction here that also sets something to one? Setting to an immediate value such as this &quot;one&quot; rather than the value of a register like the rest of these instructions takes up a lot more bytes of code as you can see over here. If I was to set this to use the EDI register rather than &quot;one&quot;, it frees up quite a few bytes. Look at all this room for activities! Okay it's only four bytes, but it's enough room for an extra instruction that increments EDI by one so that now... it equals one. Then we can shift the instruction we want down so that when it runs, EDI will be set to one for it too, effectively setting both of these to one with less bytes than before. We even have enough space to decrement it back to zero for the rest of the function, though we don't actually have to do that because the code overwrites EDI's contents shortly after anyway. And with that, the game lets us die every single time! Excellent, but we're not done yet, are we? This is all well and good for the beginner size, but since the mine count is now hard-coded to 81, for any larger sizes it doesn't work anymore. So we're going to have to change the earlier code to calculate the amount of mines it needs on-the-fly, and once again we're in luck due to some surrounding code. It turns out here, register EAX is the width and register ECX is the height. This is actually really convenient because any x86 multiply is done to the EAX register so the numbers are already where we want them to be. So the simple instruction &quot;mul ecx&quot;, or multiply by ECX, will get the exact number of mines we need into the EAX register. Coincidentally, the register that's used to set the mine count in memory. Again, very convenient! So here's what we can do. We can naturally nop this instruction that loads the mine count from the settings. Next, I'll have to shift these instructions around because the function call here messes with the registers. So now, when the mine count is set from EAX, it happens when EAX is equal to the playfield width. All we have to do now is throw in a &quot;mul ecx&quot; to multiply by the height, and we get the total number of mines needed to fill the playfield right into our mine count! And there we go! No matter what the size, the playfield is always all mines! I'm actually pretty happy with this hack! It's simple yet effective. Sure, it could be cleaner by rewriting the loop without any random calls, but eh. If it works, it works, right? Time to create a patched executable and send it to some friends! So Matt sent me a file called &quot;aprilfools&quot;. Yeah, this bodes well. Right. Winmine-- oh god... Better? o- okay... This wasn't what I was expect-- oh no... Oh no! I'm so bad at Minesweeper-- right. You know what? Actually this is good. This is good, because now... I'm at exactly the same level of everyone else playing Minesweeper. You know what, thanks Matt! God damn... Now if you want to try this out yourself, there is a download link in the description, however the version you're getting is going to be slightly different to the one I made in this video because the version I hacked was the XP version, and it turns out for some reason, it doesn't run on Windows 9x, which felt like a bit of a shame. Meanwhile, the version that ships with 9x is 16-bit so it won't work on most modern computers either. However, the version that ships with NT 4 is both 32-bit, so it will run on modern computers, and also will run on 9x. So I went ahead and did exactly the same hack to that version and that's the one you can download. It should work on every version of Windows from 95 onwards. Now even though this hack was fairly simple, I learned later it actually could have been a lot easier. Firstly, you can actually find Minesweeper debug symbols. These are like export symbols, but way more OP. They provide human-readable names for pretty much every function and variable in the program. You can see how having actual words instead of random memory addresses would have gotten rid of a lot of the guesswork. Secondly, there's actually a GitHub project called ReversingMinesweeper which is apparently a largely complete decompilation of Minesweeper back into C++. So one could have just edited and recompiled this instead of hacking up the assembly code. And finally, if you want to be really naughty, an old Microsoft leak from 2004 actually contains the complete source code for Minesweeper. Not only could you have recompiled this, you can actually see exactly what code produced this assembly. It's pretty cool! Uhh, by which I mean, wrong and illegal... Please don't remove this video at Microsoft... Well, Happy April Fools everyone! Thank you so much for watching this video. I'll see you in the next one. Bye guys!