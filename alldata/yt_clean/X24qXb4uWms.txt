Hey guys, this is Sig from Eldr.io, and I'm back request to do a video about concurrency in Golang, mutexes, general multi-threaded programming in video to do. So what I want to do is give you a programs in Go, and tell you a little bit things you might run into. So for this example, and I found this Exchange API on GitHub. I'll a fun little project. It's basically, I think, it does is it allows you to fetch currencies, real money and cryptocurrencies, if that's your and then for each currency you can use this unique has in relation to all the other currencies. using this API. So that's what we're going to do we can make it concurrent. So if we go into So I've implemented some base stuff for us to get not on the business logic here. So what I've done my currency exchange is a struct, and it has of currencies, kind of like we just saw. And then like we just saw in the API as well. It has are basically this currency's exchange rates that the exchange rate pertains to. So basically functions in here, fetchAllCurrencies, which just currency's map. And then you can fetch a currency and then it goes out and fetches the currency we just saw to fetch a bunch of rates for each currency exchange to have all the currencies, other currencies in our currency exchange. So I've actually written a little bit of boilerplate naive implementation that just instantiates a new and then it calls fetchForAllCurrencies that we because I don't want to fetch all of them for just fetching 10 at a time. And then it actually through and loops through all the currencies. And right? And then it goes in and it stores the rates it takes a benchmark of how long that took. And at actually run this. Let's have a look and see what we got 10 currencies, and for each currency, we've what happens. It took a little bit longer there. not all currencies have a name, but it works, takes roughly around a second and it fetches all what if we wanted to speed this up a bit, right? might say is, sure, we fetch all the currencies, the rates for each currency. What if we were able that in parallel, so to speak? Now, Go has several most simple implementation is using goroutines. goroutine anonymous function, it's basically function and you say, run this as a goroutine. go func and then do something. In this case, let's concurrently. So we can create this concurrent just stick all of this inside a concurrent actually telling the Go compiler is, when you and then spin up a goroutine, which is a and do this work that's inside this function we'll fetch, we'll make the API call and we'll we should be able to do to print out the things a feeling we might run into some trouble. So this see how quickly it finished. You know, this is way are dealing in it with a concurrent program. So currencies and we say go func, so basically go the main thread, the one that's calling our in, doesn't wait for this to finish. The main it prints things out, and then it exits down these go func go routines. It just carries on and we're running into. See, we were executing finished doing their work yet. Okay, so this is go actually has a nice way of solving this, which are in the sync package. And we can go in and so. And a weight group, kind of like the the to increase things to wait for and then decrease assert that the weight group has fully completed. pointer or a reference pointer, it's called in that counts references. So you can increment it by complete. And then you can wait for it to reach waiting for to complete here is all our different So what we need to do is we can go in here and we the weight group. So we're saying here's some work work going out and fetching the currency rates for one and we can wait for this. So then what do we First of all, inside our go routine, we can now go our go routine out here, this is outside of our go And then inside the go routine, we do the work and keyword or function adds x amount of entities to So this is a common pattern that we use. And simply call weight group dot wait. So what this weight group dot wait until the weight group So I'll clear this and run it again. Boom, and it rate exchange again. And in fact, if we run this, was before. Before we were hitting around 800, 900 concurrently. So in parallel, although concurrent doing them concurrently. And so we've sped up our However, there are also some problems with this. that we have all these go routines. They're going they go in here and they change, they mutate the at currency again, right? We have these two maps. So our go routines are changing the data inside the same time, depending on how long this takes. trying to write to this map at the same time. This actually not read and write concurrent safe. safe or concurrent read safe. What that means is an exception if you try to read or write to it We can actually try this out. Let me just grab we want to do now is we have this code. Let's go Get rid of that. What we're doing now is we're spin these up as many as you want, as many as your do is it will go in and it will just keep hitting for US dollar or for USD. So this is like a little on, you know, it does this forever, it just keeps anything for USD? Do you have anything for USD? let's try running this now. Click clear and we'll The whole thing is blown up basically. Each of our and this is because, again, we are accessing a time. We've got a thread here in our goroutine down here, one for each currency and we've got 10 any given time trying to write to it at the same ever want to be in. So how can we resolve this? so-called mutex. So what is a mutex? A mutex is sort of a pointer to a something that can only you can lock the mutex and if you lock the mutex, it and if you unlock the mutex, you leave it up it as a resource that can only be grabbed by one here and Go has a great way of implementing this group from and you can add to your struct simple mutex to the MyCurrencyExchange struct. We could just adds a base generic one to the struct. And has a sync.mutex field, whenever we access for example, down here, we can call lock we can call unlock. So now when we're writing, it says I'm about to change some shared state I can't do that. I'm not allowed to do that unless When it calls ce.lock, the operating system will who's next in line to pick up the mutex. So it for the mutex to become available. So if another state, it can't, we can't, or this thread that cannot obtain the mutex lock. And so it sits turn. And then eventually the other thing up and do our work and so on so forth. And this accessed by one thing at a time. So likewise, is another thing that we are accessing, a shared scenario. So now we've got mutex lock around both we're back to things working just fine. So state of a shared resource and doing so in a it's also called. But there's one more thing I well, this is a very well established pattern. this to protect resources is a great way of imagine you kind of need one for each, unless for each resource that you're trying to do. And so goroutine or dedicated thread, and it can be the of gathering work that's coming in from a bunch results into a shared resource. So that sounds that with channels. Because if you think about So right now, we're going through all of our and we're fetching currency rates. Great. This currencies that we're pulling in. But what if we hundreds or thousands of currencies? With this up a goroutine. to fire off API requests for each with all the amount of Bitcoin or whatever crypto loads, right? We don't really want to spin up a want instead is we want a worker pool of threads pick up work, and then they can do the work and the next work until there's no more work to be pattern or worker pool pattern. It really depends doing this by using so-called channels. So let's implement a function called runCurrencyWorker. So already having some great ideas, but let's ourselves. So what the runCurrencyWorker will it will create a threaded worker that will sit and return a result. And let's show you how through this channel stuff in just a second. concept called channels. Channels are essentially really interesting characteristics. So channels into a buffer essentially, but that buffer safe in really interesting ways. For example, a blocking operation. So a thread will sit there anyone on the other side ready to read from the indicate. So you can see we've got the channel currency channel, the arrow on this side indicates the other side means that we can write from the like this, we're saying here's a channel, which is for this currency worker is one that the currency one that the currency worker can write to. And type of currency.currency, right? So currency is, currency in our currency exchange. So what we're so we can identify it, but also two pointers that can send or receive currencies. And one of writing. So this is a little bit strange maybe, sense when we actually implement it. So let's go That one looks good. So we'll say, okay, we've channels are great because they're implemented like other data structures that you're used to. a channel using the for and range keywords maps. And we can actually go in and we can, but we can walk through it. So we can go in and we to read from the currency channel. This is the looking at the arrow here. It will go in and Whenever it reads from it, it will print out to print that out. We don't need that. Then will fetch currency rates using the code from the will update the rates and then it will write the the arrow here is saying right into the result right? And then another thing we can do is at some loop. And the way channels implement in a Go means So you can call close on a channel and that will to loop through it to actually break out of their has stopped. So now we've implemented our worker. or remember what we're trying to do. What we're spin up all these routines all the time for all of workers. So let's create a set pool of workers, this. So first, before we can do that, we need just like we create maps, this is exactly how function and make a channel of the desired type. can be anything. They can be channel string, they also channel of your own type. So in this case, do is make and actually take a parameter because unbuffered means it will just try to use as much But if you know how much you want to send at the maximum is you're ever going to send, and only so many currencies in our currency exchange. be no longer than the length of currencies that more than the total count of currencies that and here we are firing off concurrency and they're all going to fire up and listen on We're going to get rid of all this stuff we don't loop as well. So now we fired off goroutines for what's coming back from these workers? Well, the multiple ways, but one way I like to do it is and then we'll actually keep track of how many count, right? We'll set it to zero first. At this of our workers. And then we have a desired finish want to keep going until we've got results for all we've got all the results, then we can say, we've So we'll say closing, and then we can actually, as we can break out this for loop. So this is kind of we want to do one of two things. We can And this is a kind of special syntax that Go has this. So what this means is, let's just walk say the case where we're reading from the result is us saying, we're gonna read a value from the right? So we'll set that, we'll bind this currency and then we'll store that currency in our right? The other thing we'll do is, since we've count, like so. And this is actually the most we've got multiple threads here that could be some kind of timeout as well, right? So another shorthand to say, let's have a timeout on here and do stuff, then we're gonna get rid of them, right? tough luck, you took way too long. I was getting Let's just go ahead and format this. So again, clear. So we've got a result count that we set to and we say, if the result count is equal to the our results and it's happy days, right? We close cause our workers to break out of their full loop And if that's not the case, we go into the select result channel. So this will block as well. but block but this one will still execute in the sense first this one will trigger. This is why this bit higher but we'll say if it's taking more than break out and we didn't succeed in our operation. from the result channel we store that inside our count and then we loop right and we go again and the result count is equal to all the currencies. probably not going to work because we're missing a happens. First of all it fails because I have an the worker started but you can see we timeout again timeout it's not happening right nothing's what's going wrong here? Well there's a couple know we can actually make it more dramatic like whole program. But the crucial thing that we're currency channel for the workers to pick up. If a value from the currency channel which is their we actually need to send all the work to do on let's iterate through our currencies like so and want to do is we want to send it on the currency going we're just iterating through all of this and to be processed on the currency channel. This will so our main thread will exit out of this it'll go result gathering loop so and meanwhile all the the work fetching the result putting it back on that up our main thread will then bring it all here goes nothing let's try it out and there we go things seem to be working you can see though that order is kind of weird right so even though buffered so at least we don't get characters all are kind of saying you know they're actually because here we're closing the result channel but and this worker pool actually doesn't grow even if that right I've got this thing in here let's just our workers we just still only have five workers this work so here the workers are starting boom so lot more things and we only we still only use five extra threads with five different workers spinning up all these extra threads. So I to concurrent programming in Go using channels, hope this is a practical example. As always I'll code in the pinned comment below and thank you so