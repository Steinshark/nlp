A linked list is a common data structure frequent topic in technical coding interviews. and prepare you to use them both Hey, programmers, Alf Infrastruktur, here, welcome really get you well prepped for those linkless this a little bit of a crash course, like I do in I want to go through two pieces of information draw things out visualize things and understand and implement the code behind it. Right, so we're here. So this is going to be an introductory you know nothing about linked lists, but you're understand things like a while loops, for loops, assume that you know, a little bit of recursion, solutions for many of our linked list problems. So what I want to do is start by understanding eye view. The first thing we'll need to know is right? So we're organized as data. And in many nodes. So as the first checkpoint here, you can think of a node as just a container for nodes, you really think of them as some here, I'll put a letter or character inside of you like. It could be a strings, numbers, Boolean, a linked list contains many nodes. So let's say different pieces of data. So I have the characters And if I wanted to make these nodes comprise a links. In other words, if I have a node like a, I that is a points to B, right, can also say that term we actually like to use for this is really to be very common linkless terminology, and a later on. And now you can already see why you call a bunch of nodes linked together. The important right? D is the last node in our linked lists. being the last node, by having its next pointer you can have its next set to null, right, the null So sometimes during this course, I'm the null note or the null reference, just Alright, now that we know what a linkless looks that you're going to hear, right. So when we refer the a node in this diagram, I consider that the we can refer to the very last node in a link list in problems, we're referring to the first right? If you think about it, because I have this note and a second node, but you can think of a words, if I started at the head of the linked and I can go to the B node, so I can just I can see that b has an X that goes to the C node, goes to the null node, which must mean that I'm very key characteristic about the linkless. Right? that it's an inherently ordered data structure, of these nodes, and we do that programmer thing a position of zero, B has a position of one, and So there are four nodes within this linked list, and the position of the tail is three. So so far, link list, like when would this data structure that we know about? In other words, you're an array because an array is also an ordered data So here I have my linkless up top, if I wanted but in an array form, it would look something And I know that that array has some indices, I know that the indices of an array correspond Right. And obviously my link was is made of The most important difference between an array contiguously in memory, that means all of your right next to each other in your computer's in the runtime of different operations now I wanted to step through a scenario, let's say index two of my array. And the key specification I don't want to overwrite the current element this operation, I have four elements in my array five elements in my array, and they should go A B at index two. So how will this algorithm run at you need to do is obviously find the index two, I need to put the new Q element, but I can't just insertion not overwrite. And so what happens under perform this insertion operation? Well, we hope and it should occur after D, right. Assuming that to shift all of the elements to the right over by right, I need to put c over a one position to the at index two. Right. And of course, now D would be important step we took here was to actually that could mean that you need to shift over a So in this very small example, I only had to move a very long array, and there were, I don't know, would have to shift all of them over one by one. for such a simple move of inserting Q, right. that does have an O of n insertion time, right, in array, that is you're inserting a very first new by one index in the array. And since there are n shifts. Awesome. Now let's compare that to a So let's say I still wanted to insert the value that means I need to create a new node in it is not required that the nodes are we can have these like nodes exist anywhere in And that's kind of a very low level statement. But shifting when I perform this insertion. In other to be composition to have my link lists, now to adjust B's next pointer. So I'm going to to point at q, then I set Q's next pointer I've actually changed, the logical order of Right, queue occupies position to see occupies great about this is, let's say that there let's say there were 1000 nodes, but wouldn't have my insertion point, I just need to change about a constant number of operations. I will say that will be constant of one time. So here we see list data structure and our array data structure. between these two. But for now, we'll leave it throughout the course I'm sure it's going to come the core core core, a linked list algorithm In other words, how can we just touch and Well, the important thing to know is if you wanted words programmatically pass a link list into a to the head node of a linked list. Because by accessing the next property of every sequential list, right? And so to actually we just need a handful of variables. Most a current reference to look at the current node right. So if I have this current node of A, and I current dot next, right or something similar I can just set current equal to current dot has an XT. So I do that again, at the C node, assigning current equal to current dot next, current would be D. And so current dot next would set current equal to next, I'll be right at null. In other words, we can stop the algorithm when point would have visited every node of the link I was kind of speaking upon this algorithm as if you how you can solve this one recursively, it's I would want to actually hop into some code. So a link list as well as the core traversal let's do this. So here I am, in my text editor, although you shouldn't be able to follow along in to do is just manually build a linked list. And to right, so we're gonna stay a little bit class. So from JavaScript, I need to give it we're going to need to store inside of an instance the actual value. But I also need to store a if there even is an x node, right. So to my so I can say this dot val equals Val. And I'm just right, I can just manually reassign this next that's all you need to start creating some I want to construct a linkless, I'll just create make it a new node, I need to pass in the value to here, maybe some capital letters this time. So the it's will have my B, my C and my D. I'll give them strings or characters within the values of my if you want, it's no big deal. What I want to do way, I can just have a linked list, I can start this part would be kind of taking care for you that you're taking in a properly structured link for myself, what I can do is say things like A's So I'm making A's next property, now become the B together, right? A's next is pointing to be the pointing to D. And there is no other nodes in my I know automatically, these next would currently of my linked lists. So like visually, I think that points to B, which points to C, which no, so I'll be explicit here and just draw link list ready to go, let's go ahead and write to iterate through every node of the link lesson, very foundational here. And so all maybe choose to best way to go about doing this. So I'll create linked list, it's going to take in the head of here. And I just like to call it head, right. how I would actually want to call this function, And give it like the real head of the link list, reference to the a node. Cool, so I'm actually of Node as the head of my link list here. And So we're gonna really just implement the So if I want to just traverse through a link to continually update a current pointer. So I'll which means I'm really starting at And then from there, how far do I need to go while your current pointer is not equal to no, then there's some stuff to still iterate through. If I wanted to, like print out or process my we're going to print out this current nodes value. terms of current, because I hope to update current now that I printed out current vowel, what I want what I should do is set current equal to current simple variable assignment. Right? So let's run through how this actually operates. It's very linklist algorithms. So let's give that a run ABCD. Awesome. And there I have them. So how does annotate this drawing as we step through the exact my function over here, I'm really only going to that starts at the head of my linkless, which give myself some room here, I would say that the A note, so I'll kind of represent like Cool. And what I want to do now is consider my While this current variable is not equal to So if I check that on the first iteration of that null. So I can run the code inside, which means Right? Since current is an instance, of node, be printing out the A that was initialized inside Now here's the important part. Right? Now, that means current dot next would be actually equal to current dot next, it has the effect Now I can check my condition again, is current current value of b, and then go to the next. At The C note is still not equal to null. So node of D. And this is still true, right? D is And I actually proceed another iteration, current dot next is null. So this would to no. But things work out great here, because is current not equal to null, in other words, is my while loop. Right. That's how I'm able to print So I think something to draw your attention I think the best way and the most robust way not equal to null. The most common mistake I see condition should be about like roughly the tail well, current dot next is not equal to no. short. If I ran that, I would only really print right, I would be checking all right, before I next is no, so I won't even print out D, which is your algorithms, especially about linkless, try So I'm not going to do any premature checking of instead, it's better to actually go to the are at the null pointer, right, the null node. And we'll just make sure that this still works traversal. It's going to be the baseline code for this a step further. And I'll show you how you it's really the same logic, you just turn it into go ahead and do this one together as well. When I problem to work through. And so if I want to frame I like to start with my base. case, your base condition you wrote inside of your while loop. In Well, I'm done with the algorithm once. I'm equals no, then I'm done. So just return. Notice that here, I'm keeping this argument as containing many linked lists. In other words, at the sub list inside B, is the head of its own a smaller linkless. Still. So I think that's okay, shows that you're buying into the recursive nature and just return out, once my head is looking at But in the recursive case, what I want So if my head is not equal to null, right now, just print out this nodes value, right, just like And if I want to actually progress to the next I just do a very proper recursive call here. makes it recursive. And what should I specify as node in the linked list, right, so I'm passing to do for this one, very, very short and to the then I'll help you trace through it a little looks almost the same. But I think it's good if And really, the key argument we need to trace call, really passing in the a node as head. And so that's false. So I go into this console dot log, and now I make a recursive call upon the next node next refers to B. And since I'm making a call to B. And I check the condition again, is b equal to and then make another recursive call on B's next, all the way down to let's say, a when head is D, that's false. So I go ahead and print out D, which And I would make another recursive call upon DS And I would indeed make this call. And now I'm head equal to null. And that's definitely true And I end my recursion, right, this base case, compare and contrast, these two pieces of code, we go through these linkless problems, sometimes you know, what style of problem you're solving, a little easier to write over the other, which is maybe, you know, choose a favorite and decide what practice both. Alright, let's head back into the And I want to go over a approach for this link this problem is going to be given the head node containing all of the values within the nodes Bear in mind in this problem, we're given a Singly pointer to the next node in the linked list, we have a next pointer that points to know that being there's problems, we're just going to have to pattern that is just traversing through a linked this one, maybe with an iterative description. right? So we want to create our values array, and an empty collection. And to implement this core we're going to need a variable or just a of the linked list, right? Bear in mind but I know the head is like the ultimate starting access everything throughout the entire list. head. And what I can do off the bat is just check So I have the a value inside of values now And that if I access its next property, I would have set current equal to current dot next, basically Same thing as before I can add my I'll just proceed in this way, right, same And things get interesting once we So I'm currently at the D node. And I go Well, we'll have to do now is consider the stop our traversal. Well, bear in mind that these that explicitly just for this drawing. So these continue this algorithm in the general sense, so my current pointer now points to know. And I think So once current is no, we know that we've hit the And if you look at the order of our values, What can we say about the complexity of this number of nodes in this link lists, then right? Because we're just are really iterating if we consider the output right now would just And I'll tell you what this looks like a pretty well implemented in two ways. First, I'll show to implement this one recursively. Really, use the same sort of mechanisms. So Hey, programmers, Alan here, right now want to values problem. So we'll jump right in. And we'll version that we spoke about in the approach video. definitely make sure you check that out first, what I want to do is use a pointer really just a I'm going to initialize it to be the head. And probably need for a linked list is just a the way that looks is I want to keep iterating so just not equal to null, no would mean the standard code I need inside is to progress to the equal to current dot next. So now think about function, I do want to return an array of all the say let's, or maybe const values, because an empty of my nodes of the linked lists, at the tippy top nodes value, right, every node has a dot Val and and just push it into values, right? So values dot is done running, I must have hit the end of the values array. So before we run it, one thing I a main logic, it's always important that you try So for example, my condition is saying, while while current dot next is not equal to no, right, that, but ends up being more clunky than anything. for linked lists, I always try to stay very node. So what I don't like to see is patterns to just shift your frame of reference because if that your linkless has a particular length. expressions about simply current, right, so push current dot Val. And then I can just update that every node is going to be processed in this And if all is well, we can transition into the do this recursively I'll just do that down below. get the most optimal complexity is really with two same thing. It is going to call a helper function. And this function is going to actually do the the linkless, and also a reference to the values any non primitive types, so basically, things like reference, right? So what I want this fill values array, because this main function is going to look like? So we'll say fill values, it's going I'll start with a base case here. And really, patterns from the iterative code just into their to stop my recursion, once my head is no, right. then you can stop. So just simply return, right to have a tough time and probably end up with some right. So again, I always try to stay very your next node, just handle yourself, right? So if head is null, then nothing much to do just I know that head is not null, so it must be a to values, right. So I can say, head dot Val, and right, we're call that values is referring besides this current head, there could be other I can just call recursively fill values, and pass along head dot next, right. And that means in and now head is referring to the next node, and all the way until we get to the very, very last these next, which is no, in which case, we would we run it, just a few issues that I need to And also when I call filled values, of course, you I know that every call wants to add its value into test run. See what we get. Cool. And now you also So the reason I like to split up my recursive is so my recursion doesn't actually have to create recursive calls are just adding their values to of arrays all the way through the recursion, runtime. Cool. So when it comes to comparing these terms of their time and space complexity, right? JavaScript walkthrough. I want you to practice because they're gonna both be very useful for Hey, very amorous. Welcome back. Right. Now I some list problem. So in this problem, we're numbers as the values, what you of all the values in the linked list. So for this 20. And so how can we go about solving this really all you have to do here is just traverse in order sum. So let's say we start from the beginning. we can also just use a pointer that starts at we can take current value and add it into our sum of to add it to my sum, by total sum is right now I can add this eight into my sum getting 10. next 13. next iteration, I can add seven into the some seven does have a next pointer, and it does point What I can do at this point is actually continue condition when my current points to null, right. loop like, you know, while current is not, no, it's pretty straightforward. We're definitely a number of nodes, we have O of n time, and then our space complexity here is actually only variables we need to maintain are really just going to store some primitive values in there. So So the internet It was really straightforward. can we solve this one recursively. If you saw that call your function many times, and we start And what this should do is really just call upon dot next session, give me a call to this eight and that should call upon the seven node. call upon its next, which would be the null I think it's a really great one, where I can do then I can just return zero, right? Think of no as of an empty list? Well, that would definitely be right? So I'm saying this call to the null node means returned to your caller. So the zero would the seven node should do is at its current value, and then that returns up the stack. At this can add its value with that seven getting 10 Just me 18. And finally, two can add itself into that correct answer, right. So there are plenty of ways we're definitely going to have one call for be O of n time. And the space complexity would we would have O of n space here because of the recursive functions, we should include the space right? So O of n over here. And notice that we would have you know, roughly like four or five the two strategies, I'll think well code up, Hey, programmers, Alvin here, right, now I sum list problem. So I think we'll get things for this. So I know I want to create a sum and I'll say, Let's sum equals zero, I know by the that total sum. Now I need to lay down my very list. So I'll say let current, we're going to keep to initialize with simply the head node. And I linkless traversal, I just want to iterate a while equal to null, then it's a node so I can actually this pattern, right set current equal to current the link list and sequence. But how do I actually I just want to take it and add it into the sum, eventually, once I hit the very, very end of the null. So I exit the while loop. Now just return variation off of our last problem, just doing I think I'll show you the recursive version, which all about starting with a meaningful base case, typically, for my linkless problems, my base case of represents the scenario where my linked list that means it has no nodes. So what's the total so I'll check if head is equal to null, then compatible types here, I know, when my linked return a number. And even in the base case, I I return the number zero. Nice. Let's say now we no, then it's actually a node. So I can look what I want to do is take that number and add it How can I get the sum of the remaining nodes calling your function recursively. Right? And to think about your recursive call for the type a number representing the total sum of everything add it to my value, and that should give me my give this a shot. And the recursive code is quite it comes to like an apples to apples comparison both have the same runtime, right, they both N calls in the case of my iterative code I have recursive version also uses n space, right? That's every function call onto the call stack. So out a base case, I would have n calls on the call we would actually use only a constant amount of here. That being said, I highly recommend that depending on the problems that we solve, you may hey, programmers, before we continue the course on own data structure and algorithm platform that is all of the content that you're launching in this Free Code Camp is also on structure dotnet, with a the course, I cover all of those classic, you of videos for every single one. So if you enjoy structure dotnet. And if you hop into any tour over here. So if we go to this insert, no you can view the problem, you can run your what will bring you the most value is my kind be able to have a high level approach for walkthrough. So you get the nuts and bolts code still, if you're not like a JavaScript, I know you can totally switch the language. So for all is switching to C++ would obviously change the different videos right here you see a C++ specific my content, and just want to check out more head over to structed dotnet. I'll leave a link And with that, let's head back into our linkless I want to go over the approach we can use for this to solve this one. So in this problem, we're going also have a target value we want to do is return is contained within the link list. So for this you should return true because C is definitely let's say I gave you a target of G. And that's g is not a value of this linkless. To solve linkless traversal algorithm. So we'll step the long run, we expect to get back a true here. head of the linked list as input, and I'll create of course, I'm going to progressively update this right? So what I can do is whenever I'm situated value is equal to my target value. So right now I should keep looking through the link lists. I know update current to be current dot next, and then I And finding that can hit a point where I see that of c. And so I can just do an early return true, I can just return my final answer. Now let's that my target was G, we're going to start the And we keep looking through the linked list. And we know that current is going to be equal to null, end of our link lists, right. And at this point, list, we know that we didn't see the target value And so at this point, we can do return false. right? Where we check some conditional inside of a we'll return true early. And afterwards, after We talked about this iterative strategy, we know to iterate through every node of the linked And our space complexity here would just be O of variables. So That was the iterative solution, So let's say we were looking for the target of So we know we're going to make a top level call just think about some base cases to use here, One that can return true, and another that can just simply check, alright, if my heads value And the opposite scenario, let's say that my What I always try to do with my recursive code their own valid inputs. So in particular, then that kind of represents the empty linkless. false because I definitely can't find the target run for current input of targets C? Well, I would a recursive call upon B. Same thing, right? It's I see that my current heads value is equal to my Boolean true. And I know that this return value is B is going to pass it back up to a and of course, Let's say we had a scenario where a target then we can see the other base case fire at the a calls B, B, call C, I still find the value c calls D. And finally, when D looks at its because these next is technically no. And at so I can return false. And like before When we talk about the complexity of this the number of nodes, we're definitely going to every node of the link lists. But we also have O the time we bought them out at a base case, we know that the worst case scenario is if our That being said, I think these are two fair a shot on your own. If you get stuck. I'll catch Hey, programmers, Alvin here, right solution for this linkless find problem. So we'll the iterative solution. And so we'll start with the head. And we'll just lay down the foundation, while current is not equal to no. And while it's of the link lists, just set current equal to the logic specific to this problem, right. As I value, so if current dot Val, if that is equal then I can just return true cuz I found the thing only after the while loop, right? It's important Because only after you check every single node of hey, the target value is not within the is write a like if return true, and then else Because let's say you don't find the target then you would just incorrectly return false So none of that we at least want your code see what we get. Nice. And there we have our problem. Let me quickly show you the recursive So in the approach video, if you haven't But in the approach video, we mentioned that two base cases, right? I'll start with the base that kind of represents the end of my linkless or I can't possibly find the target within Now I need my other base case, right? paid my like I can look inside of head and I can check if head the thing I'm looking for so just return true. So then one that returns false. But let's say neither and my head value is not equal to my target, link list. So here's where I bring in recursion. head dot next, and you can pass along the same alright is the target found in the next notable And I know that this call is going to either true or false. I just want to pass that up. give that a shot. Cool. And there For this problem. Do you bear in mind when it Technically, we would prefer the iterative But the iterative version has constant space, Whereas my recursive code uses a linear amount of what I want you to do is practice both of these Hey, programmers, Alan here, right? Now I want to value problem. So in this problem, we're going to accept an index as input, what we want to do is and we will start counting our indices at zero. linked list as having index zero. So for this of this linked list, you should return the value c. And of course, that could be giving you any asks is pretty straightforward. But how can we here is a basic counting algorithm. So we know we so when we initialize our current pointer to be our count to zero, then from here, it's just our equal to current dot next. And when I do that, is one. Basically, I have tracked the index next iteration when current goes to see, At this point, I can see that my target index and value within that particular node. But think about if n is the number of nodes, the time complexity case, we just have to traverse through the the space complexity for this is constant, because So that's how you can solve this one irritably. though, so let's reframe our point of view here, recursively. And we know we still want to find I know that the top level caller is going to pass and also their target index of two, I can use my I make a recursive call on my next node. When what I should also do is pass along the index, but hey, this current note of B has index one. And if next note of C, and I also decrement, my index basically means that I want to return this very return no dot value, that would be our base case. going to return back up the stack. So the c value Very classic recursive code. So this we analyze the complexity of this, we're going And the space complexity is actually also linear because we're going to be storing every call upon your own, try to give it a shot, implement for this problem. And if you get stuck, Hey, programmers, welcome back. Right now I want this get node value problem. So hopefully, if not highly recommend you do that. And we'll strategy off the bat. So I'm going to need two and one of them typically is always going to be the end of my linked list or I have an empty know that we'll actually cover a few scenarios. actually get past a very, very large and Next. So seven. But the link list only has four different would be three, right? 0123. So if ever our target null. And so this should help me satisfy that, the edge of the link list. Nice. We're gonna need particular node that we need to return its value index like we set in the approach. So I can check this current node, the current node would be Nice. So bear in mind, we're counting I need to call my function, get node value, and then pass along index minus one. And the value of the node at the given index. So I I do a quick sanity check here. Bear in mind, example, example, 00, we know that A is going because we're going downward. And when I make the I call on C, C is going to receive index zero, the stack. So kind of counting downwards here in Let's give us a test run. Bear in mind, this linear space complexity, we can actually cut down So I'll show you that right now. So the intro probably wondering, why are we doing such simple right? To me, it's all about the foundations. your current variable to be the head node, right, my current is not equal to no, then keep on going what I should do is set current equal to current specific logic here, right? I know I want to these iterative patterns, all counts upwards. just like this. And whenever I progress all set count plus equals one. So I'm counting is equal to my target index, and I can just return value. So again, we're counting upward in the be counted downward. Nice. Let's go ahead and run pass, but we'll give it a go. See what happens. has already been declared, because of course, I can't read declare your const variables. So the test where our index or a target So we should have our function return null. If right now we're returning undefined, which is ending, right, we're going to hit the very, very over and we're just going to hit line 16. When we're just going to by default, return undefined. just by default, return null. And that should Cool. And there, we have an iterative solution. time complexity, just like the recursion, but we consider this constant space, because we and count. That being said, what I want you to because in the next few problems, it's going to Hey, programmers, welcome back. Right now let's list problem. So in this problem, we're going we want to do here is actually reverse the order list contains the values ABCD in place, meaning we we want to actually change the order to DC ba just In this function, what we should do is also return your function for this input should return the D to solve this one. When it comes to the tools we we always have to iterate or traverse through requires at least one pointer. Typically, we multiple variables. So let's say I began my of the link lists. What I'll also need is to because I haven't visited any other nodes, we And we know this entire time, if I have access in the list right by just accessing current a temporary variable here. And we'll call So I know I need to have the long term effect of link list. In other words, I need to make a point set current dot next, in other words, setting this. Now it should be abundantly clear why because once we reroute current dot next to point that next variable. So what I can do now is to be the next and set my previous to be the like this. And now I can set current dot next this pointer. And this process continues. we have to also remember is technically since D it actually did have a next pointer And so at this point, I can actually continue current dot next to my previous rerouting this iteration. If I set current to be the next, it's which means we hit the end of our linked list the current state of our linked lists, it points to B points to a points to null. So things the new head of the link lists, I can simply So that actually works out pretty elegant. if we implement this in an iterative way, and we runtime is just going to be O of n, really just we can say that the space complexity is constant, So overall, this is a maximum efficient algorithm code walkthrough for this, I'll actually show you Bearing in mind that the recursive would actually before we get there, try to give this a shot I'll catch you in the walkthrough video. See Right now I want to go over a JavaScript solution So hopefully already watched the approach video, implement that strategy pretty closely. So I'll know we just need to lay down at least initially, keep my current variable initialize that to head And I know that the basic code would always be set move sequentially through the linked lists. But So the key here is to have some variable, we'll null. And if we were wondering why null is a great what needs to happen on the very, very first our current is going to be a, and in the long run, right because he needs to become the tail. on the first iteration, we can immediately just that would actually have that arrow But then at this point, we need to make sure So before we just reassign current dot next, would lose access to whatever the actual next note I'll say maybe const next, equals current dot make progress to the next node of the linked awesome. So that's looking pretty good. And not should now also point to current shifting my full here. Let's go ahead and maybe analyze a little So let's say we had a link list points to see, we know we have initially current we know that when I save that next variable, it's that. And technically at the very start, we use like capital n represent null. And I know Awesome. So on the first iteration, we current dot next equal to previous current dot current dot next to be previous, it has this the opposite direction, once I do, they would see why we saved next for B, right, that way, you Cool. At this point, I can set some variables, so I'll set it like this, then I also set the point of view. And if you look at the state aligned. For the next iteration, I would just set and so forth all the way through the very end of once we actually end when current is equal to actually contain the new head of the link list. it doesn't make sense that previous would be the while loop, I know previous is going to be the becomes a head, and vice versa. Cool. So really I will tell you that the logic here can get pretty So we'll give it a test run, see what we get. runtime o of one space solution. Awesome. There we the recursive version, it will have a slightly noticeably more concise. So I think it's still to translate the same premise into its recursive access to two variables, or two pointers. And the default argument here. So I'll set previous equal this is how you just do a default argument. Right. when they call reverse list, by default, start with the classic base case, right? If head And what I can do is actually just returned over here, right previous would actually be writing the recursive code, I'm just going iterative patterns into their recursive analogues. just a temporary variable. Because if I override I would lose access to it otherwise. So now and traverse through the rest of the link list. head as the new previous, really just I think about the return value for verse right, it's going to return hopefully, the new that return value, do stay aware in this problem, of the reverse link list. And this should Nice. And here we have a O of n time right? So apples to apples comparison, if you should prefer the iterative version. nice value to practicing both of these. And this So make sure you have this down pat. Before we Hey programmers, Alvin here, right now I want to problem. So in this problem, we're going to take these two lists together. In other words, I need such that we alternate between the nodes of list always start with the first note of list one. And being said, let's take a look at another example. comes to the length of both of our lists, except But besides that, what if one of my lists was to do is alternate as much as I can, and then nodes. Soon as I alternate with AQ br, at which So I just take all of the remaining nodes And so we'll want to keep that edge case in mind So where do we even start with a problem like linkless pattern, right? We just know how to And so what I can do is actually maintain one and another for list two. So let's say I know I'm past both of these head nodes, head one I can set up some respective current pointers. to start with the head node of list one. So I'm need to do is also track the tail of my output all of our pointers in place, we're going to how we can add new nodes to our current output, the first node of list one, then I need current one. And so current one should really be at least a starting node, how can I come up with establish a simple alternating pattern, then what started zero. And then based on whether or not which list you should take your next node. And so what I should do is whenever my count is even, is odd, I'm going to grab a node from list one. number. And so I'm going to take my next node from and it tells me I should just take that cue so now that I've consumed a node from list two, I just like this. And I also need to make progress my tail also to its next, that way, I can get At this point, I need to increment my count by I should take a node from list one. So I look at just like this. And I make progress on all of current one, I'm going to progress my tail now I should take a note from list two. So I take to its next, it's going to become No, when I set and then I increment my count. So now my count it looks like I've exhausted all of the nodes right? Whenever we finish all of the nodes our output with all the remaining nodes And so at this point, what I can basically this C chain and everything after it, just like this. And of course, I want to complete be the correct output. And so overall strategy link lists, and maintain accounts, right, then that'll tell me from which list I should need to maintain some tail pointer we can use. So Let's talk about the complexity of this one. Since we should probably use two terms to describe of list one, and I say m is the length of is the minimum between n and m. Recall that we really only needed as many iterations as the traced through. Now once we hit the end of one algorithm by taking the remaining nodes of the that finishing step only takes an O of one time, which will always be in general, the shorter one, don't have to iterate fully through both of them. know, some form of a linear runtime. For the space constant, right? We're not actually creating any next pointers. And in terms of our variables, we this seems like a reasonable strategy, what I want it's going to be some really interesting and if you get stuck, I'll catch you in Hey, programmers, Alan here, right now I want Zipperless problem. So we'll jump right in, start with an iterative version of this, the our classic linkless traversal. But do it twice really. So I'll set my let current one, start the start at head two. And I'm going to need linkless. Second check, while current one So notice, as soon as one of my linkless hits Cool, we want to be sure to do is set up also a we always start with the first node of I'm zippering, ABC and XYZ, I always start that to get the ball rolling on my resulting But we do have to rewire all of these next say head over here, and this will be the head that by the end, something like that, I'm going and then current one will actually have to start So I'll set current one equal to we'll say, point from there. And in addition to having this you know, the new head of billing class, which of it. So maybe we don't need this variable. But right. So I'm going to say left tail, I think head one, say no head, one's going to be I need to add things after the tail building up Now we'll go ahead and increment our counter, let count beginning at zero. And dependent on tell me whether I should take a node from list one our main code over here. I know I should end any the count, right? Count plus equals one, I'm just And I will start by checking the parody of that so I'll simply check if count mod two is an else it's odd. So bear in mind, I started my one. And initially, I start my count equal I'll take something from list two. So what I can so current two, and I want to make that the next output. So simply tail dot next equals current something from list to I need to progress that so that this code over here, when it's odd, it's And in addition to that, we need to make sure that happen in either scenario. So I can put that equal tail dot next. Nice. So this should help me worry about is based on my while loop, this while of my current pointers hits null. And it could the other one is still pointing to some data. And is just tack on all of the nodes of the other list check here, right? If, let's say, current one that I can just take that stuff and add it to And symmetric for current two, of course. So about a scenario like this one right here, we know or list one is longer than list two. And so by the roughly we're going to be at about this C node or those remaining elements looks like D, and add DEF. Cool, and we just need to check both let's give this a nice test run. Gonna always but it does have some interesting patterns. for Zipperless. For this code, we're looking I think what we'll do is, let me also show It's very similar and strategy, somewhat shorter think it's more simple or not. We will have to especially for this one, we're going to have some a linear space for recursion as well. So patterns. So I know I should stop my recursion So that's very similar to what we just said then you kind of at the end, you can just for my function needs to return like the new head case here, where I return null is basically a What you should be doing as you solve linkless say this as a linked list, going from A through going from B to Z is also a linked list. So So if they're both null, then return null. But if head one is no. All right? And that would mean had to have some stuff, well then just return the other side, right? So we've had two is nil. have had one. And what this base case or these logic, just like this, right? How can I take of my lists running out and just tack it on to I'm just gonna return the other pointer. Cool, recursive code. So there are a few ways you can checking for even or odd, what I should be able to I know I need to make my head head one, really. So and I need to make head one dot next And as soon as I do that, I would actually so I should have saved that. So I'll dot next before I overwrite it. And I guess why next to pretty common thing we have to do for a pointer, maybe save it in case you need it still. and then from there. I know I need to And also, next to it should be right. And then know Zipperless is going to return In the head of to head to so had to dot next equals that return node from this recursive call. So this code is it is quite a bit shorter. So we're getting error that's on me. Give that a go again. little recursive solution for this. And so just maybe it's worth stepping through at least one lists had ABC and XYZ, trace through at least y, z. Alright, so I know in the context of that's going to be head one. They also have head I'm not hitting the base cases for this, because their next. So nothing fancy here, I have next the core logic of actually alternating, what I do to. So I don't want to just kind of merge them although you know, I'm not creating new I said it's next to x. So that already looks good to whatever the recursive call is, when I pass kind of ignore these. Right? So I'll take out just be the same thing over here. H two points to y. well, same thing. I just take head one, right? So eventually it's going to return over Because head one is B h two is wine head one