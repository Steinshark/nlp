Hello, my name is Christian Clausen. I'm a technical agile coach and author of I'm sitting here with Michael Feathers, the Legacy Code,&quot; which has helped thousands of Michael, what are you up to these days? What am I up to these days? Lots of things. I'm a chief architect of Globant, but I also well. Yeah, I think I kinda, like, of broadened or six years or so, but it's just been very So I like to think about things at a deep things on the horizon now to play with. So that's pretty much what I'm up to. Cool. You're not looking at legacy code anymore. Is that because you've fixed all of the legacy No, no, no. I mean, people keep writing it all the time, So it's like, that's impossible. But, no, it's not that I'm not dealing with It's just, basically, I think my scope has I'm just looking at some other things also. Yes. I guess that's the best way to put it. Okay. Well, that leads naturally to my first sort If you were to write the book like today, Well, it's an interesting thing because I core ideas, are kind of like a little bit it still continues to sell very well now. But I think it would make more nods to current reaches the reader and says, &quot;Hey, by the with right now,&quot; but still it's like it's testing, that kind of thing. So it's more like how do you sort of approach That kind of thing. There's a lot more now that I would say about almost like the sideline pursuit I've had It's kind of like you go around and you're you're kind of like, okay, well, how do we And Agile had some answers that have been real mechanics of how it happens and really and individual level. It's been, like, a lot of what I've been thinking book. That and functional programming, because there Well, that seems interesting because, to me, It's just when code ages, it becomes legacy. I think also we should probably deal with very much in the media, and it's AI, and machine code quality and legacy code in particular. Is refactoring gonna be outdated? Well, it's an interesting thing about that. So I've been playing around with it a lot I sense that we're safe for a little while I think there are a couple of different things One is that we've had code generators for have always been people who say at some point, and we'll be set, right? But there are always, these interesting things do well? How much effort is it to go and actually sort And I guess, the other big thing with this language, right? We are generating code. We need to understand code well enough to like gauge the correctness of solutions because There's, like, the hit-and-miss thing with It'll give you something that's good sometimes of like off track because it's dealing with So I think we've got space in this. But I think, in a way, prompting is just gonna And then we have to kind of figure out what pieces we can generate and then the ones that So we'll still need modularity at a very coarse-grained Those are some thoughts about that, I guess, Yes Sort of like a, it'll be a new type of Yes. Yes. Well, you have to coax it and prompt it, right? Yes. And you have to guide it. Like you have to learn to guide it and say, things. And, like... Right. So it becomes just a... it becomes a programming in some sense, but can do more for you, I'm Which is kind of hard to imagine, right? Yes. Because programming isn't frustrating at all. I haven't worked much with the Copilot or were also very into that when it came out. It was like, oh, now we won't have to do these to write them for us. And I mean, especially if you're working a at least, follow a similar structure to how more helpful. I don't know, have you tried Copilot? A little bit. Not as much as some of the more recent things. I think the thing is that everything with a lot of it right now just turns into this way. So you are given things, and then you have go and figure out whether it is the right So there's this degree, there's like this a lot of things. It's kind of like at what scale do I generate for what I need to do? I've used it to generate test cases. I've just been kind of happy with what it's I think if nothing else, you get, like, enhanced There are certain things that you might not in using it because it sort of, like, introduces That's pretty interesting. I've also seen people using, I think it's and more where they generate a lot of sample that, I think. Like fuzzing in a sense. Something like that. It's great for that sort of thing. Yeah. Cool things. Guess we'll see where it goes, right? And it's kind of funny, I'm supposing that at this and sort of say, &quot;Ah, those guys, It's hard to predict the future. When Copilot took over the world tomorrow Exactly, right. So what's the date stamp here? What's today's date? Today's the 20th or 21st? Date stamp for our opinions here Talking about testing, your book talks a lot Agile alliance sort of massive on TDD, stuff So before we jump straight into testing, how How do you recognize if you're sitting with Well, I don't think there's any hard line I think legacy is a subjective judgment that and the hardness to understand something that A traditional definition is it is code you And at one point, I started throwing around It's like, well, maybe it's a code without without tests is qualitatively different from as, like, a safety net for what you're doing, It's really a subjective judgment. I think the main thing I keep coming back understand what you're working on, right? And if you have trouble understanding it and really in trouble, right? So everything is about getting that understanding those different things. There's really a slippery slope on that. Things can kind of fall apart. That's an interesting take because I would that you feel, and it's very close to what Yes. The difference, I think, from my perspective, read code because humans read code very slowly. And so the more of that I can skip, the better. And good method naming, for instance, and, is a way to sort of eliminate a lot of the code. And then confidence comes from something else, Like, do I trust that this works, even if Fair enough. I think in the book, I kind of like nodded this thing of, like, to what degree you can system does, right? And I think this is a general thing. It's kind of like when we make systems, it's it does and it's like it should be pretty So if you find something completely counterintuitive test or just through reading things, you might It's like are things really to the point where lost or that I could be kind of tripped up So, fair. I think it is the quality of the code base So I agree. Yes. A test is one way to sort of gain some of You also mentioned in the book, which I absolutely on that in my own book, is, like, leaning Like, the compiler is so powerful. Type systems have gotten so good, you can work with them correctly. Yes, definitely. And I think it's funny with that too because the other thing that I talk about a bit is more about your code, right? Which I basically see as another form of testing, But it's like it's another level for gaining system behaviorally. So, it's good stuff. Yes. Definitely. And yours is the first formulation of TDD Because it seems to trip up a lot of people the red-green-refactor. No. And it's funny with that too because I think in dynamically type languages, but definitely, in Java at least at the time that he wrote But yeah, it's a piece of it, particularly What's kind of funny for me is quite often, I actually prefer dynamically-typed languages there's this thing of, like, you have way different ways of interrogating the code base. So it's a trade-off, you know? I'm a little bit unsurprised that you work like you have a lot of discipline in writing, Whereas I find my huge challenge when I'm have a lot of testing discipline, I have a And so, I'm very challenged in my confidence Well, can I tell you a little story about Because it's a little story I like to repeat. Of course. I think I put it in a blog a long time ago, computer lab, and you'd sit in there, and things. And we were programming in Pascal, right? A very early language that way. And I was sitting there and doing my assignment at the person next to me, and on her terminal, or something like that. And I thought, oh my God, I've never seen And I'd, like, gone through almost all of and then I thought about why I hadn't seen And the thing is because I taught myself programming college and started learning Pascal, which And I just realized that essentially in C, because it's hard to know when you messed crazy errors because you're over memory and So I think there's this interesting thing and sort of build your discipline in a way, Now, it's a terrible thing to advocate because saying, &quot;Go out there and march in the woods person,&quot; right? But I think there is a piece to that as well of develop discipline sometimes are very useful So, just a thought. I agree. And, from my perspective, I started coding fancy thing. So, I put my parenthesis, the close one, when I've never had a mismatched parenthesis, right? Because that wouldn't have worked back then. I couldn't have sat there counting them. It's fair. But it's a thing. I think those are things that you need to discipline at some point in your career, then And it's like once you get that mindset of because you're able to go and dip into it when you need it. So it's just another tool that you can have, That's just my sense of it. Just a side note, a side question, I've noticed I don't use them because back when I started And so, I do printf debugging always. That's the only thing I do, and it always Like, do you have that same experience? Do you use debuggers? I did use debuggers before hearing about TDD of it. Occasionally, I would fall into printf, but, in and doing it with tests, for the most part. The thing I always ask myself as kind of like go and figure out the thing I wanna understand? And if it isn't very easy, well there's something I need to do something to go and at least testing affordance to go and get the answers So, things like that. But then, I would expect that the code base modeling. That's my general sort of rule of thumb. So then, some things will be hard questions, I think they will be hard questions. I think it's not like we have layers, like, as much anymore or that we advocate having like, query layers within an application, So if you have a good domain model, in a sense, and ask questions in terms of the domain. You might be dealing with an area of four that you can ask the question at the appropriate Maybe you need to go and jump out to an end-to-end more of the domain and more of what's going levels. And the design of the system should support I mean, at its base level, if we have something we're gonna have like fundamental computations. They'll probably be held in maybe two or three well enough to go and query those in the test, about how all the accounts interact and stuff So it's this thing of like developing almost And it's not like they're specific layers, the system. I think that's the thing I would say. I think I get that. But it feels like some things are just inherently the system. Some information is sort of embedded deep sorts of other things. And, at some point, the complexity is there I just keep going back to that thing of, like, It's when the complexity is there and it's some sort, then I'm okay, what's wrong here, Even if I can't fix it right away, I just for design. One of my favorite talks I ever gave was, It was called &quot;The Deep Synergy of Testability And I think about writing more about this to that thing that almost everything we can of some kind of a design problem. If you address the design problem, then you affordances. To me, that's a beautiful thing because it You're able to listen to the system and learn of it, you know? I would have the same view of it just with instead of testing. If I can't type this correctly, if I need I haven't designed it correctly. Totally. I do like to just kind of sidestep the whole better? I like 'em both for different reasons. And I think that it just comes down to context, That whole area is just kind of, like, it's or another on that. It's just what you need. You'll also have an easier time on the internet so to speak. Fair enough. Well, it'd be fun to piss off both sides. Yes. Sure, sure. It's fun. How you get your fun, it's not recommended. I've been through a lot of organizations, I see a lot of them are struggling with testing. Like, it isn't as prevalent in the industry So if a person is in one of those organizations, How do we move out of this rut or whatever Well, I kind of like the silent approach a But I think it's just because having a background you say to people, it's like, &quot;Hey, you gotta rebel, or they're gonna be kind of like, &quot;Who and, &quot;Sure. I feel like what I was doing was good before, But I think an interesting thing is, like, have to do your work and you have to do it And the thing is, if you discover that these because that's what they do, these techniques, to recognize, wow, this person's having less The people that are interested in getting And it's very much like sometimes leading It's just by going and sort of doing something to go and try things out. The thing that I find problematic quite often way of doing things in the organization,&quot; to do it this way, we have to do it this way.&quot; They just create enemies, right? You have to keep your passion intact a little you're doing and you're making things better, galvanizing effect inside the organization. For a consultant, things are a little bit hook to go and change things, and then you people to some degree. I think a little thing that I used to do with really curious about things and also the people them, then it becomes kind of viral, in a And it's great when you find a person who's You know, it kind of helps to some degree. But I think the other thing to recognize too right? That's just the way things are. People are different. They have different views about how they're life, you know? So, I'm assuming, as a chief architect, you No, I think the chief architect is kind of I think I kind of chose that title within wanted to highlight to my friends outside organization that architecture is important. I think after many, many years of Agile, there's of emerges. And I think that the kind of thinking that extremely important and that kind of thing. So I do work with different teams across the client accounts, and stuff like that. But it's not a direct architect role in that I think it was more of a signaling thing on No, I understand. So, your teams or the teams you work with, Like, do they use TDD and stuff like that? Yes, some do, some don't. The thing is, it comes down to the type of for. It's funny because there are many different an organization and producing value. So quite often, it's definitely on the pallet All right. Well, and it's super interesting what you're as a developer and you start using some tool using it, and somebody else is gonna see it. I've met people in the industry who had the come in because they were on their way away I was like, &quot;What? Why are you going...like, why are you doing It's because tests can sometimes hinder sort they're very structurally dependent. I think the interesting thing to me is, sometimes, many people putting some of the tests in the I'm gonna go and change the system.&quot; I'm going to go ahead and do a structural cover it completely. If I can develop confidence in another way tests and find out, well, they aren't working And I'll rewrite tests that will cover the I think that we can overly valorize the tests get rid of any tests at all.&quot; Then you're in a situation where you're just right? And I guess the other thing you're probably and how do you develop in a way where you from refactoring, right? That's an interesting question for these things. And I've found that a lot of... So a lot of the struggles that I meet with, aren't experienced with it when they come to learn it. And it's not an easy skill, especially because on the red-green-refactor or, like, sort of Whereas I find that the most painful thing Because if you learn how to do test stubs, I think there's that. I think the other thing that's wild for me the way that TDD kind of spread across the took it to be, like, okay, you write one unit and you're good. Right? but then like BDD came along and it's kind Particularly when you look at what Kent has Ian Cooper's take on this as well. You start out growing tests from a particular You're decomposing things as they get bigger. So your tests are over here, but they cover I think that's the key message that needs mapping of test classes to production classes. I think that's a way where people kind of into a corner to some degree. Especially when you start testing with, like, If you don't stay to the public interface, when you want to restructure that code. What's wild about this too is that essentially this years ago. It's like we don't have a good thing now to public, right? So public is a code-level thing at the class A method can be public or not, but you need an interface that we see from the outside area and unit. Of course, it goes and kind of, like, differs But, you know, that kind of separation is So, it's not overt and we have to go and make methods that we are holding in variance on So, pretty tough. I remember having trouble also when I wanted quite public to the, like, API, but public And then the testing classes would've to be weren't visible. But I didn't wanna compile them in the same my test code. So it was just a whole... Trying to design around that took, like, days I tend to try to convince people to go and well, particularly, I guess, for me, I get situations. You don't have many other options in terms going in and starting to get control of the them in parallel that way. There are some valid reasons not to do that, you can have that discussion and move to doing into going and building an easier way of working It certainly changes sort of the whole view but I don't want the tests in the thing that So it's sort of like the constant struggle. Sometimes, that's kind of like a sense of...it's It's kind of like, oh, well these things are They shouldn't be in the same place. Right? I don't know if I mentioned this in the often. I think it was Voltaire who had the saying, best is the enemy of good, in a way, right? So you're sitting there and you're working saying, &quot;Wow, you're breaking dependencies look ugly.&quot; And you have to kind of like, &quot;Have you looked I mean, it is kind of ugly, right? That kind of thing. Some of the things that you do to go start are going to violate some preconceptions you there to facilitate doing the refactoring So, it's cracking the eggs to make the omelet I mean, when you say that, we have to talk Yes. You also mentioned in the book that you don't easier. Well, the thing is that when you say it that but that simplification is good, but it's breaking encapsulation, but selectively in to go and test things,&quot; right? And you do it reluctantly, but you're doing you should be thinking about what it is you So to go and break encapsulation at the edge as your place of encapsulation is okay because of value. So it's a matter of finding the things of I want to basically sort of like, be outside And you might have to break at those edges layer around the value that you're trying I tend to think rather visually, so of course, But when you think about it, a lot of systems, in particular ways, in particular shapes. It's like sometimes you're looking at 'em can be part of a bigger thing. So it's up to me to go and build that bigger And other times, you have a thing which has it apart and then you have a different task, this from the outside of the test to be able If I'm working with something that's, like, the tendency of local changes to have global That's sort of what I'm scared of. That's the issue with legacy code is that Yes. And humans can't seem to get that into their We are used to local, local. So, often, I would try to encapsulate things all of these effects, right? They can't escape if you encapsulate them And I noticed that you mentioned also the And it's like exposing data, obviously, constructors Yes. So then, my approach would be or my intuition things. But then, you're saying that you would have something changes non-locally, right? That's what the test should be there to do. Well, I always look at the test as basically, If the thing changes in a way that you didn't to go and break. So for me, it's the work leading up to writing so that the effects don't propagate necessarily, Or at least you have a barrier to go and make If you are accessing a singleton inside of to go and inject that value through the constructor directly within the class, right? You slowly go and start to build these firewalls this. But a lot of these tend to be bigger issues So it's kind of like it takes a while to go have to go and sort of assess the value of go and tell you about whether these side effects I think it's a very problematic thing because is that code grows in a particular way. And it's like if you have like lots of global be able to fix that in your lifetime necessarily, But you should be able to go and at least understand where the trip wires are. If something goes wrong, you wanna know about So the code is less understandable by reading the feedback that you can't get by reading a particularly bad way. So, there is this question of legacy code terms of your plans for how good it's gonna What is reasonable? How much time should you invest in fixing Well, here's the thing that I think is a very, You know about, like, the 80/20 rule, right? It's like 80% of the work happens in the last things. It's part of something called the Pareto Principle, And there are a lot of natural systems that the code has a higher value than the other If you do a distribution of method sizes in tend to be small, but then you have maybe right? So it's a mathematical thing that happens systems, or incremental value seeking. The thing I'm always looking at with a system areas, right? And my notion of value is a little bit generalized. It's not just what the business thinks is changing frequently right now, for instance? What are the things that... What are the more bug-prone areas? So it's not valued as much as kind of like areas where basically, you have some criticality, You look at those and you're kind of like, points into stability? And the interesting thing is that the 80/20 There are many, many files in your system and there are others where basically, you And that's gonna change over time in the system, you know where to concentrate your effort. I think that the thing that's kind of important area and recognize it's a very stable area It's kind of messed up in the way it's structured get a return benefit for investing in that It's like you wanna stabilize it, understand of code, but you don't wanna kinda like bolster is extremely easy to go and work in because So I think having a very comprehensive conversation where these hotspots are and where these value what you're gonna concentrate on is very important. A lot of this is outlined by Eric Evans, like You have like the notion of down to context He mentions with like anti-corruption layer really... It's really about going in and finding these on that. I think that's the thing. It's not an easy thing necessarily, but I value is not uniformly distributed across It simply isn't, and we should behave differently that. I know that hotspot detection is a major part And do you use tools like that? Well, I've used it a bit. I'm actually on the advisory board of CodeScene, So it's, yeah, I know Adam Thornhill from Great guy. I like that because I think the interesting of like there's a lot of information in our And he just sort of launched in there and around that sort of thing. So I think that's extremely valuable. I think it's one of those things where you or you can build awareness. And a lot of this tooling goes and gives you We also do things like planning, like, oh, an impact on to the code base, and various of systems. It's like SonarQube is good too. There's lots of tooling out there that basically good. How should an organization sort of tackle, What should they start... Like, how much time should they invest? Like, what policies should they put in place Yeah, that's an interesting thing. I think it comes down to that kind of value earlier, right, and just sort of figuring There are things like application portfolio people tend to do, but you need to figure The term I use quite often is rules of engagement. If you figure out where the very critical people can't just come and commit against You need pull requests with particular people, do this to go and sort of like sort of build In other areas, it might be just, well, anybody that's okay because it's low criticality. But getting people to see that value across of thing. The secondary thing is figuring out whether things well, right? A lot of times, historical reasons lead us We're separated into different teams that that are kind of like there. I am a fan of the Team Topologies' work. I think it's really kind of good. I think if I had any little criticism at all, arrives at a very, like, this is the way you And that's good because it does seem to cover But I always tend to want people to go and you into trouble, and how can you actually the problem disappears in some sense. So I think those are kind of like macro-level And beyond that, it's like building a culture I think to the degree that basically, the people work on refactorings together that they think something's bad, right? I think is the important thing. It just really comes down to basically, raising I think also kind of like connecting with Having the developers connect their pain with It's always been troubling to me to find developers They don't think about it as pain, they think And then you can show them how they can make kind of like, &quot;Oh wow, I have something I I know this is a long answer, but the whole Because essentially, it's like if you make there because you were called in to fix something of change, you're going to make things a little get that benefit. The areas where you do this that are high and then the things that you do to make things return on these things. Maybe other areas of the system are just never and add testing because nobody's ever changing But it's not like you look at a 10,000 file because we'll never get tests for that 10,000 So, there's a certain nugget of the system system that once you start making a headway, And that's a very useful thing to get across. You have this thing in the book, when you part of this system, people will sit down suspiciously like work, I think, you say in way of saying it. I sort of try to hack into that and give them up methods. And it's easy also, they can do it without Whenever your eyes glass over, have people time because they can't tackle problems if Like, have them do something with their hands Totally. Just one little plug for something else. There's a small thing I mentioned in the book Every time I talk to people, I sort of offered which is kind of like, take the code, throw file as opposed to like your program language possible errors and stuff like that. And just start renaming things and moving Don't worry about breaking things because That is so counter to our intuition as developers we change things. But when you know you're not gonna check in hands-on, you start to go gain much more insight Even if you can't actually sort of like fix of where the danger zones are and stuff like I love the scratch refactoring thing also. I noted it in my notes because it's very similar that I do basically. Except I also check it in and I take smaller But it's very much the thing that if you try you think about it too big, you won't go anywhere It'll just be stuck. Sort of paralyzed by the opportunity. So that's getting past fears, taking the first That's the way it goes. And trying something out and like just, yeah, As you also say, start writing like a single If you have something like you can start improving bit. To me writing a test is asking a question And if you're curious about stuff, then you those tests. I think we don't have too much more time. Is there something you wanna sort of plug Not necessarily. I think the thing is it seems like the AI short term and that's maybe we look back at it didn't. But I think the bet right now is that it's The key thing is that when you're working to learn more about how design works in a And so, something is exciting about doing I think that a lot of the things that we basically be still, very important as we move forward It's hard for me to imagine a situation where we don't have to think about cohesion and We might have to think about them at a different things is immersing yourself in it and legacy And that's the way I kind of look at it. Spot on. I totally agree. Cool. Thank you very much, Michael, for sitting It's been super fun. Yeah, it has. It's fun. Thanks for your interview.