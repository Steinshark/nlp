- Hello, everyone out there in the live stream. Thank you for being here live or watching it later on YouTube. If you've got comments, thoughts, throw them into the live chat. We'll make them part of the show. Carson, great to see you. You ready to kick this thing off? - Yes, I am. Let's do this. - All right. Carson, welcome to Talk Python to Me. - Thank you. I'm really happy to be here. I'm very thankful that you're willing to go a little bit outside the lines of a normal Python development to talk about something like HTMX. You know, I'm extremely happy to see HTMX getting picked up particularly by the Django community in Python. So I was very excited to come on here. - Yeah, I'm really excited to have you here. It is such a cool technology. And I think so often the JavaScript story is, oh, you're doing this other technology that you like. Let us tell you how you should drop that and go do JavaScript, right? And what I feel HTMX brings is whatever technology using Django, Flask, even some other thing like Rails or ASP.NET, whatever it is that you already got working really well, here's a really cool way to extend that. We're gonna dive into that. So I think, I've had people reach out and say, oh, I'm a JavaScript developer. Let me come onto your podcast and tell people about how cool Node is. I'm like, well, I'm not really sure that's the best topic for a Python-focused podcast, so I'm going to decline your invitation. But I was really happy to get a chance to have you on the show because I think there are many people out there who are nervous about JavaScript. They're not yet learning JavaScript. They know they need some interactivity, and they feel that means they have to abandon what they've already learned or what they actually love. And I don't think that's the case. And we're going to dive into that. So I think HTML plus Python Web Frameworks is a beautiful thing. But before we get into that, let's just start with your story. How'd you get into programming and yeah, start there. - Sure. Well, I've been programming for a very long time now. I started programming in college back in '94. Actually before that, I was programming on a Mac and HyperCard, which is a very old technology, which I love. - The web before the web. - Yeah. - It looked like a internet. - I can talk about that. If we talk about HyperScript at the end, maybe that'll come up again. But so I started programming in college and then very early on started programming for the web back when it was CGI scripts and Perl and stuff like that. And then I moved into Java during kind of the original dot-com boom and did a lot of the, was in the Java world for a long time and eventually moved into Rails. And so I've been programming in Rails now for the most part. I do, I program in a lot of different stuff though, mainly Java and Rails. And I have to admit to your audience, please don't judge me too hard, but I haven't used Python very much in anger. I've used it for local sort of sysadmin scripts, but not for a bunch of web development. So, but you know, Rails and Django share a lot of things in common with one another, and they're both great server side pieces of infrastructure. And I always felt like it was a shame that they were kind of being left, that they were being ignored to a large extent by the bigger JavaScript frameworks. One term that I try and coin, there's a lot of different stacks out there, right? Like the lamp stack and so on and so forth. And one joke stack that I've made up is the how stack, which is how H-O-W-L. - H-O-W-L. - So HTML on whatever you'd like. (laughs) So use HTML on the front end and use whatever you like on the back end. And that's a cool way. - And HTML is really empowering for this, right? I mean, that's like kind of the philosophy in some degree. I mean, you got a joke stack, but like literally that's sort of. It's a joke, but it's kind of true. So, yeah, yeah, absolutely. And how about now? What do you do day to day? Um, so day to day I teach part-time at a university, and, my, my passion's actually programming languages. So I teach that as well as some other programs, classes at a university, uh, part-time, and, then I also, I work for a startup as well that I've I've been working on for a long time and which uses Intercooler JS, which is the predecessor to HTMX. The story with HTMX was that, well, we can go into it in a little bit if you'd like to, but that's what I'm doing now. So kind of a mix. I find myself doing a lot of different stuff. - Yeah, that sounds like a really nice mix. I love universities. I love university campuses. Maybe it's a slightly different story today with COVID, right? But I think we'll kind of get back to it. but some of my fondest memories are just, you know, spending time dreaming about ideas, walking around various campuses. - Yeah, it's a good energy. The kids aren't quite as beaten down as some of the, when you're in the corporate sector, I mean, you see a lot of these posts on Hacker News and so forth, just old guys, older guys and gals that are just sick of the grind. And so it's nice to be around younger kids that are maybe not quite as jaded and there's just an energy and it's a beautiful environment. - Yeah, it keeps you young being around that crowd, I do think that's awesome. So I wanna start our conversation by taking a little bit of a step back and I think we've circled around this a little bit, but when people are working in some technology, let's focus on Python, but it could be Rails like you had said before, and they've got something working really great. You know, you come to some part of the site and it's like, well, this should be really interactive. Like I wanna click on this thing and depending on what I select here, I want that dropdown to select that other thing. Or as I search here, I wanted to actually just fill it as I type. I don't wanna have to type in the search text, hit enter, see what comes back from the server. Oftentimes that is sold as a, well, your site is gonna be more responsive if it's running on the front end. And sometimes that's sort of true, but I feel like a well-designed website can be really responsive. Like I don't really feel like the speed thing is the story, but this interactive like navigation thing where it resets where it is, like that is a real challenge. And so often people get pulled down this path, right? Well, you wanna have that experience. So is it Vue.js or React? What are you gonna do? And then 10,000 lines later, front end code, you've winnowed down your back end to just a couple of simple HTTP API methods, then also something that serves up like a HTML static page. And then the question becomes, well, why are we doing Python? Or why are we doing Rails at all? Why don't we just do Node on the back end and we just have that as our entire stack? I feel a lot of times people either end up going down and throwing the baby out with the bathwater type of thing. You have this really cool server side ORM and a bunch of stuff happening that you really love from your server side, say Django or whatever. But you've kind of already gone, you're just so close, you're just like, &quot;Well, we're already mostly writing JavaScript, let's just write JavaScript.&quot; So I think that's one side of the story, and I think there's real pressure on the other web frameworks, Python and other spaces for that. The other side is people who are not doing that, but they feel bad. They're like, I know I'm doing it wrong. I know I'm not using React. I'm just using Django, but this is all I know. And I just not ready, or we're just not a big enough team. How's that sit with you? What do you think? - Yeah, I didn't like that. That's exactly the pressure. - I don't like it either. That's why I'm so excited about HTMX. - That's exactly the pressure that I felt on Rails. I liked Rails. Ruby is a programming language I'm so-so on, it's fine. It's got its issues, but I liked Rails quite a bit. And I just disliked that pressure to adopt something else on the backend that came with using these more complex JavaScript front ends. And like I said earlier, it was just a shame. And the other aspect of that is when you go to that model, when you go to the Vue.js or the React model, your backend becomes pretty dumb, right? It's just producing JSON. There's validation code and yeah, your validation code can now live on both sides, which is important because the front end is not a trusted computing environment. So you can't trust validations that are done on the front end. You always have to redo them. - You just redo them again anyway, that's right. - Yeah, and so there's just all these kind of, I don't think they're complete arguments, but it's just with the grain to start pushing JavaScript onto the backend, especially once node really came out and gave JavaScript a good runtime on the backend. And it's not a good thing. And the reality is, is I hope we can demonstrate with HTMX today that a lot of very good UI or slash UX patterns from the web can be achieved using just HTML, using the original HTML model, the original RESTful model for the web. I know that's kind of a fancy term, but just using the original model of the web, just kind of generalizing what we're already familiar with in our day-to-day development, links and forms. And so that's where HTMX is coming from, is this idea, wait a second, let's take a step back. We don't need a super complicated front end. We just need to- - We don't have to push it all down to the front end. We only need to push a little bit of that interactivity down, right? - That's right. And that interactivity can be defined in terms that are very familiar to us from normal HTML. So let's just take HTML and try and push it as a hypermedia or hypermedium, I guess I should say. People get mad because hypermedia is plural, but I say it anyways. So, you know, that's where HTMX is coming from. It's very similar, you know, this frustration with the industry, particularly, I don't think this is strong now because Python has had, I mean, you go and you look at the trends and Python is just crushing right now. And, but-- - Not a resurgence, but such an acceleration from where it was 10 years ago. - And I think if you compare that with five years ago, JavaScript was really the thing that was accelerating the most. I don't think that's true today. I think JavaScript is maybe plateauing a little bit. There's still plenty of JavaScript out there, obviously. But I feel like Python's really taking off because of big data and some of the AI tools that are available in Python. And so, and then some of the great older tools like Django and Flask that have been around for a long time and that do a good job. So, you know, again, just very similar situation with you where I'm looking at this going, man, this stinks that you have to become either like a killer JavaScript front end engineer, you know, and then have two languages that are pretty complicated or abandon whatever backend you prefer in favor of JavaScript. - Yeah, I'm a hundred percent with you. Let me pull up a couple of things. One, here's that graph that you were talking about. - Yeah, that's exactly the graph. - Of Python going pretty wild. Like you talked about JavaScript plateauing. So this is the stack overflow, you know, stack overflow trends for the major programming languages. So this is really surprising to me and I find it quite interesting here. Also a couple of things from the live stream, Nick Harvey. Hey, Nick says, &quot;For me, it's a constant battle &quot;between all the benefits of server-side, &quot;plus I don't want the page to keep refreshing.&quot; - Yep. - Yeah. - I sympathize, Nick, and that's exactly what HTMX is designed to help with. The real bad part about the original web, and browsers, we have to say, I think you made this point earlier, Michael, browsers have gotten better at making the page transition not quite as clunky visually. So you can do sort of web 1.0 style apps and get away with it for a lot of stuff. - Yeah, you talked about doing programming in '94 and I remember the first mosaic that I saw that was the graphical web. And I was just, my jaw was just dropped. I'm like, this changes everything. I had been using Telnet and like Gopher and all sorts of crazy stuff. Oh my gosh. And I'm just like, this is a new world. I literally think I had to skip the next class I was supposed to go to, because I'm like, I can't, I have to explore this. This is unbelievable what I've just found. But I remember it going clunk, clunk. You could just see it building the page as it comes. And that was, yeah, it's, luckily it's not like that anymore. - It's the big problem. It is, you know, it's much better now, but it's still a problem. And it's a big problem for, you know, many UX patterns. You just, you don't want it. And that's exactly what HTMX is designed to help with. - Absolutely. - Stay within that original model of the web. can use whatever backend you want to produce your HTML, but we can get better user experience out of it. - Yep, yep. So also RJ out there in the live stream says, &quot;I just discovered HTMX a few days ago, great timing.&quot; Auto-complete, fix that, perfect. Yeah, so speaking of which, let's go ahead and let's get into it, right? So we've set this up as a, it doesn't have to be either or, it doesn't have to be either Django or Flask or React or Vue, right? It doesn't necessarily have to be that way. And there's some really cool stuff going on here. Like, let me just read this little introduction you got over here at htmx.org. It says, &quot;HTML allows you to access Ajax, &quot;CSS Transactions, WebSockets, Server Sent Events &quot;directly in HTML just using attributes &quot;so you can build modern interfaces simply.&quot; Which is really nice. And one of the things that frustrates me about these frameworks, like I do some stuff in Vue and like, I'm not against it. I just wanna put out there, I realize there are apps that are absolutely making sense to build with Vue or with React, right? Are you trying to build a mobile app that is really sort of a progressive web app? Like, that should absolutely be in that. Are you trying to build Gmail? It should very likely be in something like Vue. But most of us just want a sprinkling, like a little salt, a little bit of niceness here and there to our app. And in order to get that, these days JavaScript has moved so far that it's no longer this simple little language that you just include a tag and then to the file and you're good to go. It's like, you've got webpack and you've got CLI tools and you've just got all this stuff to go, right? So what's the getting started experience for HTMX? It looks pretty straightforward. - Yeah, it's a small, it's a no build library. So there's no build step associated with it. You just drop it in. You can use a CDN if you want. And so the starting experience for it can be as simple as just adding a single attribute or maybe two attributes would be the minimum thing. And so it doesn't require a total rework of your front end. And that's one concept I like to talk about with my students is this idea of a complexity budget. Your application has a complexity budget, you need to spend it effectively. And so with HTMX, you can pick the parts of your app that need it and add interactivity to them. and the remainder of your app can remain just a standard, you know, web app that works the normal way. And because of that, you can sort of spend your complexity budget where you want to on your app, rather than saying, okay, we're going to react, and now we need a React router, and now we need GraphQL, we need all this stuff. - Our next sprint is gonna be the rewrite sprint, right? - Right. So it's just, I hope it's, you know, people would agree that it's a lightweight library in that sense, and that you don't need to do a whole lot to make things work within one particular area. There's some attributes like HX boost, for example, that you can just kind of toss on the body tag and it'll turn all the links into AJAX requests and all the forms into AJAX submissions. And so it's kind of like a TurboLynx if you're familiar with that technology in that sense. So, that isn't a big focus of the library, but it's there as well. So hopefully relatively lightweight. - Yeah. - And the user experience. Go ahead. - I was gonna say, so you basically include a script tag to link to HTMX, it's 10 kilobytes and it has no dependencies. - Yep. - Yeah, RJL out there in the live stream says, &quot;I strongly believe that these JS libraries, &quot;speaking of Vue and React and whatnot, &quot;are overkill for the majority of CRUD amps &quot;that exist on the web, Probably 90% of the Crub apps are built within private corporations. I've been doing that since '94. And then also Nick says, &quot;NPM and Webpack are both a blessing and a curse.&quot; Yeah, especially if you're a backend sort of person. - Yeah, I never liked big complicated build tools in any, you know, in any, even on the backend. I just, I'm not a big fan of them. I like dependency managers, but beyond that, I don't want a bunch of stuff going on. - Yeah, I'm with you on that as well. All right, so let's talk about the motivation that you got here before I get into some code because I think it really sets the stage. I mean, obviously, we've been setting the motivation here, but you throw out some questions, some hypotheticals like, &quot;Hey, why should only anchor tags and forms be able to make HTTP requests? Like, if I click on an image, shouldn't it be able to make an HTTP request? Why should click and submit be the only events that trigger them, right? Like I don't know, mouse over or key down or something like that, right? Probably key down for a smart auto-complete search. Why should only get and post be available? And why should you, why should they only replace the entire screen, right? - Yeah. And that last one's really the crux for what Nick was talking about earlier, right? Is why should web requests have to do this big, chunky replace the whole screen? if you have an action that only updates a small amount of that screen, why not just return the HTML for that small amount of the screen? And then in that element that's issuing that request, specify, oh, put the return content into that thing. And that's exactly that. So HTML has an attribute called HX swap that lets you, or excuse me, HX target that lets you say exactly where you want to place the return content. And then HX swap is another attribute which lets you tell HTMX exactly how to do that swap if you want to replace the whole thing or just the inner content or append it or whatever. - So let me lay out an example here of a type of app that feels like it would need view or something. I'm just gonna pick on view as like the catch all for all the major front end frameworks going forward. So imagine I've got like a photo gallery of like five images up on the screen and I wanna be able to click on that image and then have like a details of it, like maybe the exit tags or like where it was taken or other stuff stored about it on the server. I don't know, maybe it's like a Wikipedia thing and like you click on the picture and it gives you some details about the picture below. And you just wanna keep that there. And as you click on them, maybe even use an arrow key as you click around between them and have that happen. That's the kind of thing you're talking about, right? Like I could set it up so I could have an event where I interact with the image, then it does a swap. And explain to me what I have to write in order to get that bottom part to like reload. - Yeah, all you would do is on that image, you would say HX get, and you would give it the URL to get that information from, and that information will come back in HTML form. And then you would say HX target, and there would likely be a div down below that would be your details div. And let's say it has the ID details. So your HX target attribute in that case would be hash details and that tells HTMX when this request comes back, take that content and jam it into the details div or whatever that has exactly details on it. And then if you wanna-- - Bottom section, sorry, go ahead, keep going. - And then if you wanna, depending on how you wanna do that swap, the HX swap attribute lets you say, default is inner HTML. So it'll swap that into the inner HTML, but maybe you wanna replace the whole thing for whatever reason, you could say HX swap outer HTML. And then there's a bunch of attributes and there's some syntax and there lets you control scroll state, whether or not something gets pushed into history, depending on how you wanna do that and so forth. And so there's a lot of stuff like that that lets you determine exactly how that swap is gonna happen. - Yeah, fantastic. So right on the home screen, you've got an example that is commented without the comments, it's four lines of HTML. - Right. - And that's the entire application. I guess you probably would wanna wrap that in like a HTML and a body tag, but beyond that, right? So what you do is you include the script and then you have a button and on the button you have an attribute that says HX-POST=/CLICKED. Then you have your HX equal dash swap equals outer HTML, presumably of the button, right? So you could say click the button and the button would replace with like a map of where you are or a grid of results or whatever the heck the returned HTML from slash clicked is, right? - Yeah, that's right. And it's HX post, right? Is that what you said? - I hope, yeah, HX post. I probably said it wrong, but yes, exactly. - No, no, it's okay. I just wanna make sure. - Yeah, yeah, keep me honest here. - No, it's all good. - It's hard to do code visually, right? - My screen is flickering again, so I wanna make sure I'm on the same page as you. - Yeah, yeah, yeah, this is just a quick start at the home page. And so this is, I mean, this is so neat because when people think about all the stuff they have to do, in order to adopt this type of dynamic page that you're talking about, what you have to do is you have to have a method on the server, a view method on the server that returns HTML fragments. Instead of returning, you know, the whole HTML body, whatever, like if my story where I said, I'm gonna put a grid of results, you have to have a server side thing that can generate HTML for a grid of results. So you could do that with like a template, like a Jinja or a Django template or a Chameleon template on the server and just pull the data out of your database, bind it, and instead of returning, have your template contain a full bit of HTML, It's like an HTML fragment. - Yeah, exactly. In Rails, they're called partials. That's the language the Rails community uses, but it's just a sub template. And so typically what you would do in an HTMX based application is you would have your normal templates and then they would include these sort of sub templates or partials again, to use the Rails terminology. And so the HTMX kind of pushes the factoring problem to the backend. So you factor your templates out on the backend rather than maybe creating components on the front end is how someone more familiar with Vue might think about these things. - Yeah, it's like the little component bit on the server side though. - Yeah, so you do your factoring on the backend and then hopefully you are designing a good URL schema, a nice restful URL schema, and it all kind of makes sense with several sources and so forth. - So in this example, there's just a button, it just goes to slash clicked. but in my scenario where I had five images, the URL, like the HX-POST could be /detail/1, /detail/2, and when you render the original HTML, you can preload into those embedded pieces, the right data to pass on when it gets clicked or what gets interacted with, right? - Yeah, exactly. So that image is a resource, right? if we're thinking restfully, that image is a resource on the server. And so it has a URL associated with it. Let's say images/1, let's just say that. And then images/1 might have a sub-resource of images/1/details. And so you would, you know, you render that image and then that image/id/details is what returns the details you were talking about earlier. And you would probably use HX get in this case because you're retrieving information without a mutation. So post is probably not an appropriate HTTP verb or action to use. And so you would get that and then, slam it into the div below the images. - Right, exactly. And it's, that's almost exactly what you would do if you were gonna write a server side only thing. It would just pull up that details page and would have a back button to get to the other ones or something like that, or maybe it would reload the whole page and then just stuff that in the bottom. So the experience of writing is almost, it's almost unchanged, right? You get a fully leveraged the server side thing. - It is, and that's a great point. It is, it's very similar to a link, right? And the advantages here are that you don't have that clunky user experience. You do have a smaller payload. That tends not to matter that much. People make a bigger deal out of that than I think is necessary. But it really retains that simplicity. And on top of that, you also have all these tools that have been developed over the last 20 plus years of web development that are suddenly available to you again, such as caching and SQL tuning on the backend and so forth. All that institutional knowledge that we built up about how to create good, fast web applications applies using the HTMX model in a way that is not as obvious if you're front end, you know, there's a whole separate style of development for developing JSON APIs at this point that just doesn't have a lot to do with that original model. And so we're relearning things. How do you, you know, that's, that model is really RPC remote procedure call, I think. And so that is just, it's just a different mindset than the hypermedia infrastructure that we're used to as web app developers. - Yeah, for sure. So you talked about this complexity budget before. And one of the things I like about this is I can have already built my application and I can decide, you know what? It would be a lot better if instead of doing a full refresh for this part, we could just add some interactivity to this, right? It feels to me like it's very easy to go to an existing web app and add this more dynamic nature to it and certain focused areas with HTMX. - Yep, exactly. And that's, again, I advocate for that. I think a good MVP written in the web 1.0 style can validate your app. You can start getting feedback very quickly without this really expensive from, in development terms, front-end investment in your technology. And then once that works out, you can start seeing how users are using your app and improving it from there. And so it lets you delay committing your complexity budget deeper into the development process. I think that's a big advantage of these lighter weight front end frameworks. Alpine JS is another one that I think lets you do that to an extent. You can just kind of sprinkle in when you want. And in fairness, I have heard people say that Vue is it can also be used in this way. So I don't wanna say that. - Yeah, I do. If I had to pick a rich front-end framework, Vue is certainly where I'd feel really happy because while it does have the CLI stuff and it does have a lot of that style, it also has the ability to just drop in JavaScript file for Vue.js and then indicate here's a sub tag or some subset of my page and now that's the app. Make this page go, right? There's that nice aspect. But yeah, I just feel like you still get to do all the important stuff on the server here, which is pretty cool. Pradhavan out in the live stream says, &quot;I heard about HTMX at DjangoCon EU. &quot;Really like the project.&quot; Firefire maybe. - Yeah, we got a lot of mentions at DjangoCon EU and I'm hoping we'll get a bunch at the US DjangoCon as well and I'm not, again, since I'm kind of, I have to, again, admit a little bit of an outsider in the Python community. I'm hopeful that I can make more contacts and really help, HTMX help Python developers stay in Python. (laughs) So do this more, do provide better user experience for your users, but also stay within the Python world. That's obviously just, it's growing gangbusters. - Yeah, for sure. - Well, if your screen is willing, actual screen on your like actual monitor is willing, let's look at some examples. So I think- - I have to admit I'm flying blind right now. My screen is- - All right. - On me. - Hopefully I'll try to describe it. You'll have to- - Yeah, I've got my phone up so I can follow along. - Yeah, perfect. - Sorry, Linux. - No, no, no, it's all good. It's all good. Versus people listening. It's not that like the screen sharing is not working. Like the actual whole display is having a trouble. - Yeah, I switched to Linux. - But luckily it's still going. - Yeah, I switched to Linux two years ago and 99% of the time it works great. But of course on this podcast, besides. - Yeah, well. - It's fine. - Murphy waits for the maximum pressure. - Maximum pain. - Exactly. But yeah, so let me just go through a couple here that I think we're need. I had pulled them up. One of them was this active search, because I feel like this is the type of thing that is like really easy, but also really calls out for some interesting JavaScript things. So over here, you've got a page, you don't have the outer shell bits, right? Body and HTML, whatever, you don't need that. Right, you've got a header that says, what we're gonna do is we're gonna search. - Yep. - And then you have an HTMX indicator next to the title, Presumably when something's happening over an AJAX request, that thing spins and then when it stops, it goes away. Is that what that means? - Yeah, that's, so the class HTMX indicator is a class that's dynamically indicated, or excuse me, dynamically added to your webpage. And it allows you to start with an opacity of zero. And then when a class is added to it, it'll transition to an opacity of one. And so that's the best pattern that I found for having a request indicator. And one of the problems that you run into and all, you know, even normal web requests, browsers these days often don't do a very good job of notifying users something's happening, right? And so this is particularly a problem when Ajax is in play, there's no indicator to say, hey, something's going on. And so HTML provides infrastructure for doing that sort of thing for you. And so that's- - And you don't have to do anything, right? Just having this thing exist, it knows, okay, if I'm doing a request somehow, some way, like while it's happening. - Well, yeah, you do have to call out the indicator that you wanna show. Now, one thing I should say with attributes, they're typically inherited. So if you had one indicator that you wanted to show for all Ajax requests, for example, you could put the Ajax indicator attribute on the body of your web app. And then all Ajax requests would then use that 'cause it's as with CSS attributes are inherited and most attributes are inherited in HTMX. And so you can hoist attributes up the DOM and have them apply to multiple things. So you can avoid repeating yourself using that technique. - Okay, cool. So we've got that little indicator there - And you, yeah, like you said, so you've got to indicate which indicator you want to use, but you don't have to trigger it. - Yeah, exactly. - You've got an input, like a text input, and it has a placeholder that just says, &quot;Please begin typing to search.&quot; It has an HX-POST, which is /search. Presumably it's posting the data of it as a form, right? - Yeah, it's posting it. Yeah, exactly. It's posting it and including the, by default, If it's on an input, it'll include that input's value. - Nice. And then it has a trigger. So the trigger is key up, changed. That's two things, right? Like, so if I command V it, or like somehow like drag text into it or key up. So either event, is that what that's saying? - No, changed is a little different. So key up is the event that we're responding to. And then change says only issue your request if the input value has changed. - Got it, okay. So if I somehow hit, - So if you hit an arrow key for example. - Yeah, yeah, exactly. Okay, got it. Arrow key or backspace. - The value doesn't change. You don't wanna issue a request in that case. - Yeah, that makes sense. The other thing you have is delay 500 milliseconds because it depends on what the event is. Like click, maybe it doesn't matter, but like mouse move, you're gonna get a lot of those events, right? You don't wanna just wreck the server uselessly. You wanna say, okay, like, instead of just flash, flash, flash the screen, like just wait till they've slowed down typing. - Right, exactly. So this is called debouncing an input, right? You don't wanna, on every event, you don't wanna issue a request. That would be crazy and not a good user experience. And certainly it would be very hard on your server. And so what you can do is you can add a delay modifier to a trigger and say, delay, wait until a key up. So if a key up occurs, wait 500 milliseconds. And if another key up occurs in that 500 milliseconds, don't issue the original request. So you effectively wait for the user to stop typing before you issue a request. And there's another option, which is a throttle, which might be more appropriate for mouse movements where you say only issue a request every second or something according to mouse moves. Depends very much on what you're trying to accomplish with your UX, those are two different techniques for it. - Yeah, okay, very cool. The final thing is to set the target, which is a CSS selector. So hash search results, which is the ID. And you've got a table with the search results and that's it. This is the, besides the server side that does the actual search response, this is the entire implementation of your dynamic search page, right? - Yeah, that's right. So what is that? That's, it looks like four attributes. You have four attributes to implement dynamic search or active search, I think is what Google terms it when you go to Google and start searching. And this is a great example of something that I think many web apps would benefit from. And it can be achieved very quickly with just a small amount of HTMX on the front end and a small refactoring of the code you probably already have on the backend. - Yeah, what I really like about this is if you've already implemented the search page to return a table of results, you've already written all this code. Everything is here. You have a form, you've submitted the form, you've got a response, you've rendered the table, you probably show the form again. Although those things are present, you just can turn it to a on key down, key up rather, basically make it much nicer without almost any effort. - Yeah, exactly. And again, I think this is showing how HTMX is taking HTML as a hypermedia and pushing it forward, right? This, you know, I think in an ideal world, this would just be part of HTML. It's just taking this hypermedia concept and saying, let's go further with it because HTML is kind of stalled as a hypermedia and they aren't doing much with it. So that's very much where HTMX is coming from. And that's the philosophical underpinning of the library. - Yeah, super cool. All right, so one of the things I love about your examples, one, this whole library has a rich set of examples. We'll go through two others, I think. - Sure. - And, but one, the examples are there, they're clear, they're visual, and you have a live one right embedded in the page. I don't have to pull up like rebel it or whatever to like go figure out, well, how's this really gonna work? I can just go here. So if I wanted to see if there's a user named Michael, I'll just type MI, no, but there are, there's a username Molly with MI in the domain and there's Jessamine with an MI in her name and so on. Right, so I mean, that's amazing. - Yeah, yeah, I really, I've tried to focus on making things as visual as possible because what I run into is people don't believe what you can accomplish with this library. And so I really wanted to make it jump out and say, hey, you know, yeah, there's stuff you can do in Vue.js that would be tough to do in HTMX or React, you know, React or whatever you're using for your front end. But nonetheless, there's a lot of stuff that would benefit a lot of web apps that they can be done using this simpler model. And if you're able to, you know, the question is, is it good enough? And I think it is good enough for 90, 90 plus percent of the websites that are out there. And it certainly would improve, you know, the vast majority of websites that were out there with just a little bit of HTMX. - Yeah. It reminds me of what jQuery did for the web. It doesn't remind me of jQuery, but jQuery for, I know probably a lot of people view jQuery negatively as like the sort of spaghetti code type of story these days, but when it came out, it was like, oh my gosh, I can sprinkle in a few things and this becomes really amazing, right? And I get that feeling as well. It's like easy to add to something that exists. - Yeah, that's right. And this whole thing, I came out of the jQuery world just like you did. And so I think you're right that there's, with jQuery, there was always an incrementalist approach. You could add things incrementally. You didn't have to buy into a huge bit of infrastructure. It turned into spaghetti code in the long run. And I agree with those criticisms of jQuery. And so hopefully with HTMX, because of the way it's built, you're not gonna run into those same issues. And I think there's some, conceptually there are reasons why that is. So with HTMX, you tend to put the actions on the thing that does the action. Whereas in jQuery, you would move things to a separate place. - Right, like dollar document ready sort of thing. - Right, they would be living somewhere else. And that was kind of sold under this idea separation of concerns, which is a design principle for software. I've been trying to push this idea of locality of behavior, which is intention with separation of concerns. And the idea of locality of behavior is that you want to put the things that a code unit does in the code unit. So, button should say what it does. It should say, &quot;I issue a post to this URL, and then I do this with the response.&quot; And that's exactly what HTMX does. And again, that's in contrast with jQuery where you would hook up a click handler in some other place and you would just be staring at this button wondering why it was doing what it was doing. And so locality of behavior is what I'm trying to use as terminology to describe this idea of putting stuff in line in the HTML to explain what this thing does. And there are other tools that are doing this as well that are getting popular. The two big ones are AlpineJS and Tailwind CSS. Both of those, you put your stuff in the HTML. And I think those two products pair very well with HTMX in that you can kind of do everything right there in your HTML. Can be a little overwhelming at first if you're not used to that style of programming, but it has a lot of benefits associated with it. - Yeah, cool. I've never, I haven't even heard of AlpineJS, so I'm gonna definitely have to check that out. But Tailwind I've heard of, and Tailwind's pretty interesting as well. It's like sort of a replacement for Bootstrap, but not in the same sort of abstract style. It's more like you say, you describe it as the way you want it to be. Like, I want the font to be medium, rather than say this is the main text, and then main text is added medium size, right? - Yeah, exactly. You inline things. So when you're looking at a button, you can see why it has rounded curves or why it has the padding that it has and so forth. And so I think people have started to recognize the separation of concerns while certainly a good thing in some ways and a valid design principle has some disadvantages. And the big one that I see is this sort of spooky action at a distance where someone can change a file somewhere else and suddenly your button doesn't work anymore or whatever. - I think, well, the separation in this scenario is HX-posts is /search. Like this describes in the, exactly in the web sense of what a URI means to describe this is what I want this to be, but it doesn't describe the implementation of it, right? That lives in the server. And so I think there's an interesting philosophy there as well. - Yeah, yeah, there is. And it's really that rest, the restful uniform interface idea from the early web. It's, you know, I keep saying this, but we're trying to take HTML and drive it forward as a hypertext. - Yeah. - Give you more power as a hypertext developer. - Yeah, super cool. All right, let's take a few things from the live audience. So we got Nick says, &quot;I love that this supplements server-side frameworks &quot;like Django rather than trying to replace parts of them.&quot; Yeah. - Yeah, absolutely. - Sure. Alec has an interesting fix for your monitor. Pseudo app install new monitor, easy. Since you're on the list, right? If I could get a terminal to show, I've got my laptop monitor over here. I'm literally staring at a blank, at a black screen. It flickers every once in a while, so I get a preview. - Get a quick view. - I'm not touching anything. If it's recording, it's working. - And then Nick also says, &quot;Now we need an HX-Python tag to run arbitrary Python in the browser.&quot; Just kidding. - Well, yeah, no, I don't. I actually, with HTMX, I think that you've removed a lot of the pressure to have Python in the browser. with HTMX. And so I was, you know, all jokes aside, I was optimistic when WebAssembly was first proposed, that it would break the dominance of JavaScript in the browser. But my experience thus far, and I have to admit I haven't looked at it in a while, is that WebAssembly has been so low level that it's probably not gonna help. And maybe that was, I can't tell if that was intentional or not. But in my experience, there wasn't a good interop layer between the DOM and WebAssembly even. And so, okay, the vast majority of scripting I wanna do is DOM related. - Yeah, it's all about the DOM. So let me give you my WebAssembly sidebar here and I'd love to hear your thoughts. I hear two problems with WebAssembly. One is this DOM story, right? Like this could be fixed, right? WebAssembly could be evolved to have like a, Like, and here's the DOM API. - Right. - In a real straightforward way. I know there's a lot of separation and whatnot, but I cannot believe that it couldn't be figured out. Two, the problem I hear about this is, well, you can have Python in the browser, and things like PyIodide have actually done this to like compile the C into WebAssembly, the CPython runtime in the scientific libraries, into a WebAssembly thing, and then you can download it, and you can do limited stuff. It's limited because of the limitations of the DOM, but you can still run Python in your browser. It just so happens it's a 10 meg download. Right? But here's what I would love to see. I would love to see the major language providers, C++, Python, .NET, you just go down the list, Java, Rails, provide a web assembly thing against some API, and every major browser just builds that in. So my Firefox comes with Python, Ruby, Java, and .NET. These are all like 10 or 20 meg binaries. - Right. - The world would be, then that whole problem of, well, do you download it? What if you re-download? What if it's out of, like, just, they ship JavaScript. If all they had to do is include a host of other features as WebAssembly, the problem would be solved. But there's just a little too much friction along the way to make that happen, I think. - Yeah, it really, the core problem there, I think, is the core libraries that come with all these programming languages. It's one reason why Rust actually does pretty well with WebAssembly, it just doesn't come with very much. And so that's a reasonable solution. If I was super passionate about Python, I might look at just writing an interpretive. And it sounds like there might already be an interpreted version of Python in the browser. So HyperScript, which is a scripting language that I'm working on as kind of a passion project that's loosely associated with HTMX is a scripting language and it works in the browser and it's just interpreted. And JavaScript is so fast in the browser now that you can actually get away with it. So as long as your Python wasn't, you know, trying to do scientific computing, you're just trying to do basic web scripting, you know, adding classes to DOM elements and so forth. - You wanna do Vue.js stuff like stuff, but you don't wanna write, you wanna create Python classes and then like hook Python functions to them, right? - Yeah, that actually, in my opinion, if I were gonna take a look at that problem, I'd look at doing an interpreted language. - Yeah, interesting. There is a Sculpt, which is pretty interesting. And this runs Python in the browser. So like the example on the homepage is like a little turtle on an HTML canvas and this is a client side, but it's like close, it's not the same, right? - Right. - I mean, that's the same for all the languages. All right, let's go back to this example here I think there's still a lot of really good things we haven't even touched on. And we're only on what, four tags? Yeah, I know. So we talked about this little example here. And as I'm typing, people can see the little searching. If you go and type, they can see like in the H3, they can see the little searching bit. But all of these things I think are neat. But you kind of wonder, well, what's happening? Like what's going on really? Like, especially if this is a server side thing, what's the HTTP traffic with the server. And you added this little like built in debuggery toolbar thing. It's not a debugger toolbar, it's a debugger footer. - Yeah. - A debugger footer. And as you interact with the examples, every one of the examples, you can see, well, what is the initial traffic? What is sent over? And you click on it, it has a history of all the requests that thing made. What was posted over and then what was returned from the server and it's super clear, right? Like, you go to the last one, I could see exactly this is what's on this, you know, up at the top. And you look at the bottom, well, there's the TRTDs that make that happen. - Yeah, yeah. Again, I really wanted to focus on the examples to drive home just how easy it was. And then also what you could accomplish with the library. - Yeah, quite cool. All right, let's touch on a couple other examples. I pulled them up because I wanted to highlight them. Click to edit, okay, let's go look at click to edit. That's a pretty good one. - Yep. - Oh, that's the very first one. - Again, I apologize, I'm on my phone. - Yeah, yeah, yeah, yeah, no worries. So here, what you've got is you've got a form and it's not form-like, it's like just static text with divs and spans and whatnot. So you've got first name is Joe, last name is Blow, email is such and such. And if you hit click to edit, those things all become, the values become in text input. So I could make Joey Joe and hit submit and in place it becomes Joey, right? Something that's right. This is a really cool example, right? Like instead of having forms everywhere, you can just have HTML and like a grid and you could say, an example I would imagine maybe is a grid of responses. And then you wanna edit one of the lines at the grid, right? I wanna edit this entry and then boom, those all become dropdowns, flex, or they become date time pickers or whatever the heck you wanna make them become. And then- - Yeah, like an editable row. - Yes, exactly. - Yep. - Yeah, exactly. - Yeah, that's exactly right. - Yeah, super easy example of what's happening. If you click edit, it returns the form HTML text. When you submit it, it returns the div span version of it. It's beautiful. - Yep, yeah, exactly. So, you know, we'll probably not go into the details of all the attributes that make this happen, but there's an HX get to get the form. That form gets swapped in to that little element. You don't have a big page refresh, you don't go to some other URL. And then you can click save and it just does a put, put being the traditional way to update something. - You know the URL and you wanna make a change to it instead of a post, you do a put 'cause that's restful. - Yeah, exactly. And so you use an HX put, and then when that put succeeds, you would render just the row again. And if that put failed for validation reasons, for example, you would just render the form with the error messages in it. And this is very similar to the way you would do standard web app development in the web 1.0 model, but you managed to bring down your target to just this little form. And so you don't have to do redirects and stuff like this anymore. - Interesting, I hadn't really thought about the errors. Yeah, I hadn't thought about the error response, but for example, you could say, return the form, but in your server-side template, you could say, well, this one has an error. So what we're gonna do is put an error message at the top and we're gonna put an error, has error attribute onto the form element, which will make it glow red or something like that, right? - Exactly. And if you wanted, so one common thing to do is to you have your error messages elsewhere, right? They're not down in that element. I like inline error messages myself, but a lot of people like to show errors at the top. And so HTMX, excuse me, has tools to do that. You can use what's called an out of band response. So you can have a content that is streamed down that specifies this is out of band content and it needs to go somewhere else in the DOM. Typically it uses an ID. And so you could use that to put an error message up on the header if you wanted to do that. Another common way to do this, one that I like, if you're gonna have something like that is to have some sort of growl library where-- - Yeah, a toast notification pop-up type of thing. - Exactly, something like that. And so for that, what you might use is the, HTMX has some fairly well-developed response headers, and one of them is HX trigger. And you can use that to trigger an event with an argument, the argument in this case would be the error message to show and then you can write a little bit of code on the front end to listen for that custom event that you're triggering and then show a toast message saying, hey, save didn't happen. - Okay, now that's cool. - So there's a bunch of different tools in there depending on what you're trying to accomplish. - Yeah. All right, on the live stream, Apar says, &quot;Hey, from San Francisco.&quot; Hey, welcome to the live stream. Nick has a comment, &quot;I'm curious how this compares to two-way binding &quot;with something like Vue. &quot;Is the DOM reactive with an underlying data model &quot;so that they stay in sync?&quot; - The answer is no. So HTMX adopts the original model of the web, this RESTful model where hyper, you may have heard at some point in your programming career, the acronym HADEOS. It's a bad acronym, particularly these days, but the acronym stands for hypermedia or hypertext as the engine of application state. And so there is no backing model on the client side, rather the model, the source of truth is the backend and the front end just sits there and reacts to user inputs. And whenever a user input occurs that needs to trigger a state change, a request is issued to the server and then the updated state of that resource is returned via HTML. So that's the-- - It kind of flows through this interaction, right? So let me give you an example. So in this click to edit thing, when I click edit on the button, it knows it's on slash contacts contact slash one. and I click the edit, what comes back is a form and has hx-put with /contact/1 as the action. So then when I submit it, it flows that it was row one or item one I was editing on over. And then when it comes back, the response is, well, now it has the edit/1, the contact/1/edit in the URL. So it kind of flows the, this is actually super hideous. There's many things that you find in these APIs and people adopting REST are like, oh, we're gonna take all the REST principles except for this hypermedia as application state. That we don't really care about. But this, the more you talk about it, it really is. - Yeah, well, it is. It's 'cause people, this is a long conversation, but holy smokes, I've been arguing with people on the internet about this for a while. I don't think REST makes any sense when you talk about JSON because it does to some extent. - The HTTP verbs make sense. - Yeah, they do. - That's about it. But other than that, right? There's a lot more to the whole REST. - Maybe the URL layout in some cases makes sense. But when Fielding wrote his, Roy Fielding is where the term, his dissertation at University of California Irvine is where all this terminology comes out of. And what he wrote, he was describing the web. He was describing HTML. He was describing like the way web 1.0 worked with that. And a big focus on that was this idea of stateless HTML in Hypertext as the engine of application state, that being one of the crux issues within the section that's about what's called the uniform interface. We don't want you to get too much into the details of that right now. I'd be happy to talk about that maybe offline later, or maybe in a different context. But when you're in JSON, Hypertext isn't the engine of application state. There's a client-side model that is your application state. and now you're in a stateful world and you're in some ways much closer to what thick apps used to look like back in the 90s than you are to the original web model. So it's a different model and there are advantages and disadvantages to it. I like it a lot. I think there's a lot of power to it. And so to make a long story short, no, there's no reactive aspect here. The DOM is the source of truth. The server is really the source of truth, but the DOM as far as the user is aware is the source of truth and it's stateless, just like the original web model. - Right, the view model is super nice. I mean, you create these little JavaScript classes and they just kind of build up their data and it's really cool and it binds with the DOM, but like, what if someone refreshes the page? Or something like that, right? - Yeah. - Oh my gosh, it's gone, oh no. So yeah, there could be drawbacks as well. - Reactivity is, you know, sometimes I can be a little too hard, I think, on just the nature of the internet, but reactivity, this notion of a reactive two-way binding, that's new. That's relatively new. There were UI toolkits that did something, did similar stuff, but not as deeply as the current set do. And so there's something new there and it is useful in a lot of ways, but for a lot of apps it's overkill and there are disadvantages that are associated with it. Syncing the two models is difficult. And if you let your DOM be the source of truth, the server be the source of truth and your DOM be a stateless representation of it, then there's a huge number of advantages that come along with that. - Yeah, that's for sure. Like if you have the same page open on multiple tabs, for example, like the database is still in sync of the server. All right, let's look at one more example then we'll do a little bit of wrap up. I'm a little hesitant to show this to people 'cause I kind of hate this, but it's also a very neat. (laughing) Infinite scroll. - Infinite scroll can also be implemented as click to load. - Yes. - So I too am ambivalent towards this pattern, but it's so common. - What I don't like about it is it's super hard to share it with somebody. They say, okay, go to this part of the search result. Like, well, where is it? Like, well, keep scrolling down. No, like hold down the, you know what I mean? It's just like hard to share or to get back to you. Anyway, like it's a lot, I don't know. But infinite scroll is neat. And so here you've got a table row that says HX dash get slash context slash page equals two or question mark page equals two as a query string. And then HX trigger is revealed. This is like, as you scroll down, when it becomes revealed within the DOM, run this and then swap after end. - Yeah. - What's that mean? - After end, so what that means is, so you'd put this code on the last row, the last result of your page of results. And so what that's gonna do is it's gonna issue a request to the server, and then when it gets that content back, it's going to append it after the end of this element, the element that this is on this table row. And so that new content, which is presumably gonna be a new series of rows is going to get appended after the last row. And so that's how you get that next set of rows. And then on the last row of that, there would be again, this when I'm revealed. - This response will come back with an HX get on it, right? - Yeah, so it'll come back with the HX on it and it'll just keep going down the line until you finally get to a point where you don't have any more. And so you don't bother encoding one of these revealed triggers and that would just be the end of it. So I agree with you on, as you are, I am ambivalent towards this. I tend to prefer paging for exactly the reasons that you talk about. And I should note that there is an attribute called HX push. Is it HX push URL, excuse me, that will push the URL of the request up into the browser's history, like into the URL and add it to the history. So you can use the back button and all that. And it does all that kind of automagically for you. - Does it allow deep linking? - What's that? - Does it allow deep linking? - Yeah, yeah. Now that being said, if that URL, someone can copy and paste into a new tab, for example. And so you have to handle both the HTMX request to that URL as well as the normal non HTMX request to that URL. And those might be very different. - Yeah, but if you did that, then it would support potentially deep linking into this sort of experience, yeah. - Exactly. And so, and then I just finished that thought. there's a header that comes in when it's an HTMX request, HX requests true. And so you can check that header and say, okay, this wasn't an HTMX request, so I need to render the entire surrounding for this thing, or, oh, it was an HTMX request, so I just need to render this partial. And that's a very common pattern to have a little if statement on a URL that needs to service both of these to check the header value. - Oh, that's pretty cool. - Yeah. - Nice. Okay, so let's see. Let me, I'm gonna do it, I'm gonna scroll here. - Yep. - Here we go. There you go, see the indicator and down cuts some more. Oh, fantastic. Yeah, there we go. And you can obviously, you know, pull up the little debug footer and see those behaviors here, which is great. - Yeah, and again, back-end agnostic. So just, this could just be normal Python on the back end, nothing fancy. - Django, Flask or Rails, take your pick. - Yep. - Yeah, I mean, it could, I've been bagging on Node 'cause I'm not a huge fan of it as a platform that I wanna work on, but it could also be Node, right? Like, if people out there are doing that, it could be that. - Yeah, hypertext on whatever you'd like. - All right, so let me wrap this up with a little bit of concreteness here. So tell us really quickly about, there was Intercooler and now it's HTMX. Just real quickly, what is the story with this transition? - Yeah, so I created Intercooler, which is the predecessor to HTMX. HTMX is basically Intercooler 2.0. And I created Intercooler back in 2013, I believe. And it was, again, I came out of the jQuery world. And so I had, it started off basically as a jQuery plugin and it grew to the point that I felt like, okay, I'm gonna create a separate library for this. And then in last year when COVID hit, I had always had in the back of my mind that I didn't like the jQuery dependency in Intercooler. And so I just, we were, you know, everyone was kind of at home and in order to avoid losing my mind, I said, well, I wonder if I could pull the Intercooler, or excuse me, the jQuery dependency out of Intercooler. And it turned out JavaScript's come a long way and I was able to do it pretty quickly. And so as I was doing that, one other thing that I thought about, I really, you know, I learned a lot as I built Intercooler.js and I developed a much firmer sort of theoretical basis for it is like, okay, we're really, we're trying to drive HTML forward. And one thing that had always annoyed me about Intercooler.js was that it was compared with, with, you know, Angular was the big one when it was first out and then eventually React and then, and Vue.js, and because it had that JS in the name. And so there was people would treat it as a JavaScript library rather than thinking of it in these more hypertext oriented terms. And I was astounded to find out that HTMX org was available in 2020, but it was. And so I grabbed it and was like, this is a great name. I originally called it something else, but that came to my senses and said, HTMX really captures this. We're trying to extend HTML. - It's available as a domain name and it captures what you're after, perfect. - Yeah. - Okay, cool. - So it worked out very well. - So let me round out our conversation with a concrete example here for this. So people might wonder like, where is this being used out in the world, right? Obviously, I think it makes a ton of sense, especially in these little like backend, internal corporate apps that don't get a ton of love, but could really benefit from this. But there's also some popular ones like realpython.com out there is one of the most popular ones, Python websites out there run by my good friend, Dan Bader. And I was just talking to Dan saying, I'm gonna talk to you, Carson. He's like, oh, I love this. I actually use Intercooler on the site. - Okay, cool. - Yeah, if you go over to the quizzes section, you can pull up one of these quizzes and you hit start, they sort of like test your knowledge thing. So here it says like, for example, in Python three, the maximum value for an integer is two to the 63rd minus one. Oh, that's so false. And you click on it, it like reveals the check answer of the thing. and then you go to the next question or you can expand the explanation. How would you express A5 as a base 16 integer? I have no idea. - All right. - Anyway, I will-- - Not the point, not the point. - This thing, this experience of going through these steps with the progress bar, 'cause there's a cool progress bar, and an HTMX and all that stuff. This is a cool use case of that type of situation that's really nice and easy to do. - Yeah, and there's a huge amount of code that's written out there, even in apps that are more dramatic and need this reactive infrastructure in places, there are probably places within the app where that's not necessary. So, one common thing I'll say is, okay, maybe HTMX doesn't apply to your entire app. Maybe you're doing concurrent editing of rich, using Canvas or something crazy like that. All right, fine. But you probably have a settings page for that app. And that setting page is gonna be fairly standard forms, you know, and that's something where maybe rather than using whatever reactive component you're using to manage the really complicated state, you could tear all that out, save that complexity budget and just use HTMX just to sync with the server for your settings page. And so, you know, but even, you know, how many crazy apps do we use day to day? For the most part, I use, you know, I go and I read blog posts, maybe I check my email and so forth. And a lot of those apps could be improved pretty dramatically by just using some basic HTMX patterns without adding a huge amount of complexity. - Yeah, I totally agree. I totally agree. All right, Carson, I think we're pretty much out of time. But let me always ask two questions at the end of the show, same two questions. So I'll hit with them before we close it out. So if you're gonna work on HTMX or do some other programming, What editor do you use these days? - I use WebStorm. - WebStorm, right on. Yeah, I'm-- - Jeff Brins. - Yeah, I'm a big-- - I'm a Jeff Brins guy. - Yeah, same here. I'm a big fan of PyCharm, and basically the web side of its functionality is just WebStorm, which is well, which is very cool. It's super nice. - I encourage people to pay for their tools. If you're a programmer, spend some money. I mean, they have stuff for free, but they do tremendous work. I know that what's the Microsoft editor has become very popular. - Yes, good. - Yeah, but I don't know. It is what it is. You know, it's a holy war situation. So don't take me too seriously on this. - Yeah, I like your philosophy. - If you're willing to listen to me, if you're willing to listen to a random guy on the internet to at least take a look at the JetBrains stuff. - I like your idea of, you know, support and encourage the things that you wanna see more of. So for sure. And then normally I ask for like a Python library that people are really interested in, but in this case, how about a JavaScript library or CSS library or something like that that you think people should really check out, like something on NPM or maybe Tailwind or whatever. - Yeah, I think looking at Tailwinds and looking at Alpine JS, if I may, we didn't really get a chance to talk about it, but HyperScript is a scripting language. It's kind of a natural language, scripting language for the front end, very front end focused. That's kind of got some interesting aspects to it. But I think, you know, rather than recommending one particular library, I'd say just that this idea of locality of behavior, looking for libraries where you're putting the code in the code unit rather than having a bunch of different places. And so Tailwinds and AlpineJS are two that jump out at me in addition to HTMX as being worth taking a look at. I know there's a lot of Django people that are using that combination and are very passionate about it. - Yeah, fantastic. - Yeah, I know some people certainly passionate about it as well. Nick out in the live stream says, view single file components violate the separation concerns and lead towards this locality that you talk about as well. I think that's a great point. - Yeah. Yeah, I think front end components are kind of moved that way as well. That's exactly right. Now, I think that comes with a lot of other stuff that I don't think is necessary for a lot of web apps, but there's just this move, I think. And so I'm trying to use again, locality behavior, And I've got an essay up on htmx.org/talk. You can look, there's a locality of behavior essay where I'm trying to push that term and get people to adopt it when they're trying to explain to people why, hey, why are you inlining all this code? - 'Cause they're like, oh, this is the worst idea ever. Like, no way. - You can't, no, you can't. And it's like, well, you can. And most people, and people are actually having, experiencing productivity and maintenance increase, you know, increases when they do it, so. - Yeah, I like your idea of the spooky action at a distance, like a little part of the cam in there. - Yeah. - Yeah. - Cool. All right, final call to action. People are psyched about HTMX. Maybe they're psyched about not doing too much JavaScript on the front end. What do you tell them? - Well, check out htmx.org. Please start the GitHub repository. That is my primary source of compensation for HTMX at this point. And we have a Discord server that you can jump on as well if you have questions. Twitter is getting more active. If you follow HTMX, there's HTMX underscore org on Twitter, which I run and it's getting more and more active, but the discord is friendly at this point. And so I encourage people who are interested in this to jump on there and ask questions. There's a lot of people that understand the library very well and know a lot of different backends because HTMX is backend agnostic, kind of each backend needs its own sort of expert to help out with it. And so, you know, hopefully in a few years, we built up a good set of example libraries, but at this point, if that's not available, then the Discord is probably the best place to check out. - Okay, fantastic. Well, thanks again for being here and thanks for creating this. A lot of nice comments in the live stream as well, saying thanks for creating it. So I think you're onto something here and I'm happy to share it with people. Hopefully it can super power some of these Django, Flask, et cetera, apps without replacing them. - Yeah, I really, and I appreciate it again, you taking something that's obviously outside the normal Python world and giving me a chance to talk to people about it because I do think it will help people stay in Python longer before they feel like they have to abandon it for JavaScript. - Yeah, we can remove some JavaScript guilt of not doing the front end for it. That's right, all right, awesome. - It's okay, it's okay. Don't ask me to use JavaScript for everything. - That's true. All right, thanks again. See you later. - Have a good one. Bye bye. - Bye. Thanks everyone out there on the live stream. I'll catch you on the next one. Bye all. [BLANK_AUDIO]