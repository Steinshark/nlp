binary tree is a common data structure It's also a frequent topic and technical coding binary tree algorithms and prepare you to use Hey programmers, Hamilton from Shruthi, elk to how you can do well on those technical interviews store for this course, like usual, we'll go over as well as of course be more practical and come a one two punch. For every section, we're going to truly understand the algorithm on the whiteboard we'll go over to the code implementation. you'll be able to find the corresponding exercise, In terms of the prerequisites for this not new to programming. And maybe you've dabbled And you're also familiar with some recursion. nothing about binary trees, and even just trees in So first order of businesses, let's actually like the programming concept, right. So when we typically we draw nodes as circles, right. And here I have one node. And I could point to some nodes. So here are the circles, I'm going to refer them, I'm going to call edges, right. So this is come in many different shapes and sizes. So here's terms we can use during our technical interviews. helps if you speak the language, it does show structure, we could store values within the nodes letters. When it comes to your programs, you can numbers, or even other objects. So because we have other words, I think of like a family tree, right? parent. If b is the parent, I know that children and child is like a relative relationship. Let's let's say I looked at a as the parent, well, that the case of the C node, if I think of CSM parent, node. So feel free to use that parent child among nodes within a tree. Another terminal is right? So a root is going to be a node that has no has no parent, right? There are no arrows going if I look at the nodes in DNF, we call that has no children, right, so d and f have no we're going to have a single root and we could do is make sure you generalize your understanding looks like every leaf is two edges away from the roots, any leaf, it could be the case that I removed that F node, which case C is now a leaf, than D and E, it's not the bottommost level, it node is just a node that has zero children. All let's hone in on the real topic here. Right, course, I want to go over the basics of binary to begin with. That's really a dead giveaway. A binary tree is a tree where every node has at screen, I have a binary tree. If I gave a another this would be a tree but not a binary tree. Right? most three children. So let's say I kind of remove And it could be the case that a node has less right? So if I gave C, just a child of f, this is within my tree, that node will have 01 or two right? So you want to be sure to remember that two children. All right. So I'll be the first is right? It's probably the easiest criteria and to add into our definition Have a robust at least for us in computer science, we think meaning there should be only a single node that it would be like the topmost node. So right If I had some other node in this drawing, I would no longer consider this a classic Let's go on to our final criteria, we also need between the root and any node, right. So looking tree that meets all three criteria. And let's say only one root, so we're definitely considering the this is really a binary tree, then we're connects A to E, a path is really just a series so to get from the root a to the node E, I one path. And that's the only way to get from Let's say I chose another node like F. There is and that's just a CF, that would be the only path. within my tree, I can get a scenario like this, we can see that B has three children, but also in any node. For example, if I chose a and the But another way to get there would be a, b, c, f, when you're considering a binary tree. Awesome. So where I think some students tend to struggle with out some nodes over here, this would definitely different rules, right? Let's say the root node A right? Because the binary tree only demands that root, and we still have only one path from root that has a node, which would be the singleton right has one route. And there's not really any And every node does have at most two The final edge case we want to think about right? We consider this as the empty tree. This any empty tree as actually being a binary tree. with some algorithms later on, right. So a common have an empty tree, that's a tree with zero Let's say I had this structure to take a moment This would not be considered a binary tree. So the first one, it does have at most two children exactly one root here. Remember that a root If you look at every node in this picture, every every node has at least one parent, And furthermore, there is not exactly because we have a cycle within the structure. right and I wanted to travel to see, one that'd be one path. But I could also have another again, there would actually be an infinite number is definitely not a binary tree. And there kind example, looking at this one, now I need criteria for every node. But I also still have exactly node. However, there is not one path between the So these rules are really worth remembering, more difficult binary tree problems. And if you different problems in a binary tree framework. encounter in your interviews are problems data structure you're dealing with, you're just what if I gave you some structure like this, take If you look closely, this does meet all I can just treat a as the root because it has no because they have no children. I just drew you really range things in a classical binary tree has the same relationships as a previous drawing, matter what do you understand these three rules not be as explicit as a nice triangular shaped theory of how to, you know, look at and reason go ahead and start to talk about how we could words, how can we do this in some code? Well, I think you're going to represent these as going to be some objects. So it could be like an within this object would be the current value. So node. But I also need to refer to some children. to the children, right, those are just going to binary tree is very common to refer to the Notice that some nodes here, like the C node, only has a node dot, right? It does not have a like null or undefined. To represent a child that he, he has no left and also no, right. So here's editor. And I'll show you how you could represent here we are in my text editor. Let's start by to follow along any language that you choose, I think the best way to present a node is just some classic class syntax, let's create a node I think would be valuable to take in the initial I'll take the ns a constructor argument, I can two more properties, one for my left, so I can say that means by default, a node will have no left no right child, right? So when you use no to awesome. That's all you need to create, you know, this class a lot during the course to test our eventually wire up a tree. Well, I'll just call nodes, I'll just store them to some variable new instance of node, and I'll store some value I'll create a bunch of these different nodes, that you also set their pointers properly. So D, E, also do F. And then I'll just manually So what if I did syntax like this is since I'm in I can say, A's left is going to be B. I can and then B's right is E. And maybe Finally I can I'm connecting some nodes together, I should a as a root, because nothing points to a of the NC. And then along with Finally, C just has a right child of f, this is during the whiteboard session, right? And programmatically, right? So I always think it's right? Obviously, we created this tree in a very applications to just maintain and create trees we'll start by creating all of our Right? And so with that, now that we have an let's go head back to the whiteboard. And Hey, programmers, Alvin here, right? Now I want So this will be a good review of the depth first this problem? Well, what we want to do is take in going to take in the root of the binary tree. binary tree, we know that that node is going to which may point to other nodes. However, if let's its point is going to be set to No. So that's how for now, let's just stick to the visual represent we could start with the root node of a, what we'll And we're going to have to maintain these in according to a depth first traversal, I could important decision, right, we can either go to I need to go deeper in the tree before I move And once I bought them out at D, there's I move laterally to the E node. And this pattern from E. So now I go to C. And then from C, I go on this binary tree. Notice that it goes A, characteristic is we must go deeper in the tree the tree. That being said, How can we actually familiar with depth first, traditionally, then we a stack. So let's get situated over here. So we'll a really close look at how we can use a stack to that a stack is a sequential data structure where and remove things from the top of the stack. we can't really insert or remove elements from things to the stack, I was added to the top like like this. Alright, so when I begin at this start with the root node of a. And by default, I it on my stack. So it's the only thing on my stack different stack frames. And really in my program, of node or some pointer to it. Cool. And then So the main flow of a depth first traversal, we'll is not empty, because I have at least one element. the top element of my stack. So I'm gonna remove being explored. And when something leaves the now. So I need to list out my values, because So by now I've just visited the a node. At this So I look at the a node in the tree, and I see its right. And from there, I push or add those two and I put B afterwards. And notice if I push my that makes it such that my left child is I would hit them next. And that actually ends on And now I asked that same question is my stack I'll call it B, my current, which means I could Nice. From there, I consider B's children, I push E, followed by pushing D. That ends that my stack is still not empty. So I know I removed list of values. But if I look at these children, nothing to add to the stack from here. And And now I still have stuff on my stack. So now as before, right, I add to my values, he has Finally FC, I removed C from the stack, and I I see that the C node only has one child, so I'm would push the F node onto my stack. And that's comes to implementing your depth first traversal exist before you add them to your stack. And now we remove it from the stack, we add it to our this iteration and now my stack is empty and I know that I must have traveled through the entire correct output over here. So just by using a stack we got pushed to the top and removed from the top remember is you should add your values into your stack. That being said, What can we say about the it's actually pretty straightforward. Let's say tree, then we can say that the time complexity of just going to add that every node eventually to stack exactly once. So it's not like we're double just run in O of n steps. In a similar way, we the only thing we stored was really the And we know that we're not going to put ever we have a linear time and space solution for I think we have a good understanding about the go ahead to the walkthrough video. And we'll programmers, Alvin here, right. And I want to go values problem. And so we're going to do here is traced through in the approach video, pretty much version. And that means of course, we will solve solve it iteratively first, and afterwards, Alright, so let's jump right in over here. Like iterative version really relies on us creating a you can just go ahead and use your like array just a plain old JavaScript array, I'll go ahead an array to represent a stack as long as we stick array push, which adds to the end of an array, of the array as well. So I'm going to consider the Cool, we'll go ahead and do is initialize Nice, then I can have my main loop for the running the algorithm while there's stuff on our is greater than zero. So while I have there is some work to be done here. And that will we know that we start interation by just stack dot pop in JavaScript, that will also return that my current const current. And that is going one of these objects. Cool. So now that I let's say for now, I just I don't know, this one as we go. So console dot log, current node has a dot Val prop on the inside. And then So you might go ahead and guess that to do that, push the left child, one out here, so node or But we also need to make sure that these There could be instances, for example, only has a right child, but has no left child, left, because that'd be pushing no onto my on. Right? So I want to only push the children if the left exists and push it and also if the add some guard statements for both of these. So if the current has a left and right side, current cool, maybe we can inline this, if you prefer. if they exist. And that should actually be the putting our values inside of an array like the see the correct order of printing here, because is removed from my stack. So I'll go ahead and case, so I could just steal this little stub over Right, so I'll test this I can hit Run, if file just like a script. So it's not just going to run my file as is. So if you want you're gonna have to be sure to call your the inside. So I'll just run Run this manually. looks like node is not defined because I forgot give that a go. Alright, so looking at our output, like we expected, right? I got ACF, B, D, if we technically did print out a depth first print, c, f, and then B, E, D. So let's say we really and all you have to do is flip the order that you looking at these two lines, right? When I add and then the right child. If you push the left afterwards, that means that the right child's if you do it like this, this will favor the But if you did it like this, now you'd be toward the right. So with that small change, we have a nice AB de ECF. However, in this those values in an array. So I can kind of I don't need this class definition anymore. And in some results array. So I'll say, maybe result pop elements from the top of my stack, result dot push, and I'll push that value into the that means my entire tree has been explored. which return my results. Cool. So this should be a on this. give that a go. So it looks like we're looks like we're getting can't read property So if you actually go into the prompt, those over here. So I want to go to zero for now ahead and they pass my function, no, right kind node. And we can kind of trace it what happens That means when we initialize our stack, our stack even an instance of note just now. So that means you know, Do I have anything in my stack, and when I pop, the top element of my stack current null dot Val. And that's actually where our can't reference property Val, of null. And so that we actually never allow anything No, to enter here. mentioned also be true for even the top kind of seems like a corny, you know edge case. go into your interviews, right? What And so I'll just guard that explicitly, so if my entire tree is empty. So if route equals array, right? Because that means there are no expected answer, according to this, right should should be pretty good. Nice. And there, this depth first values problem. Alright, so Let me show you another way. let's implement So I'll just kind of redefine it down below. And because they're going to serve as like the tree problems. And so when I think about the I must think about the simplest case of my So in the case of a binary tree, the simplest tree or just a no root, right? So it's not even inside of a binary tree. It's going to be about going to check if my route is no, and I have an if it's its own input, because it really is right in array of all the values in the empty tree, it's right? Because there are no values, And then from there, I can generate my actual my stuff recursively. That means I have to invoke it. And I'm going to call upon root dot this call over here would give me back an array And this will give me an array of all the values into their own variables respectively, you don't especially if it's the first time implementing I'll call this one my right values. And here's how all about taking when I call is a recursive leap test 00. And so this is our tree visual, right? So when I actually make this top level call, recursive calls, right? I know when I do depth depth first values of root dot left, that means and here's how I have to actually pretend my code result from this call, right? So if I passed back is the full array representing the depth right. So if I got correct data over here, That would actually be the full depth right. And I'm kind of doing that just mentally, it's going to be a similar story for my right and I passed in my right child See, is just an array of CF, which would be the And now that I have, you know, my left subtree think about how to combine it all together, right? both of the results from my children, right, what the array, followed by my left children, followed JavaScript syntax for that whenever returning going to throw in a root dot Val, that's myself. the values in my left result, put them in here and And I'll do the same thing for the right values values just so I return a single array, and this kind of taking the leap of faith and assuming right, I have a, and I plug in substitute B, D, E, we run this, I'm not going to, you know, assume kind of new to this spread operator. So let's say had an array of some stuff. So I'll So we'll throw in fleabay, we'll throw in Jason, whenever I have an array, I can just use a spread example, I can say const will say new peeps. And square brackets, it gives me a new array put an element at the front, we'll call it Alvin. So just imagine I took all of the elements here any initial nesting. And then at the end, I don't console dot log, what new peeps looks like so I'm this file as a script, just so we can review this of make this bigger. Notice that I have correctly and I have all of the things from peeps in the So you can do this. You can also use like the to see me use this spread syntax a lot because let's go ahead and actually test this code. So is another working solution for our depth first can solve this problem also recursively. So I know traversal requires a stack data structure. under the hood, your programming language is using the call stack, right? That call stack which is really convenient. Cool. All right. I want you to actually practice both solutions very necessary to actually master some later some time on this practice makes perfect, Hey, programmers, Alan here, right? Now I want to really just going to be a little variation off of it's really important that moving forward for all that we have both versions down pat. So in this once again, very classic binary tree structure, of all the values according to a breadth first starts with the root node of a, so that's go to B. So right now I have my a node, and also previous problem in a breadth first traversal. And I travel across before I go deeper. So in our and not D for now. So I add my C node c value to entire level, and there's nowhere to go across next level. Now I have D, and then E, and then F. the breadth first traversal starts with would have started A, B, D. That's a And so how can we go about implementing Well recall that the depth first used a stack breadth first is now going to use the queue data of that structure. And so let's kind of step going to use and track my queue. And just recall the back of my queue and the front of my queue, the front of the queue. Right. And so no one gets ordering, think of a queue as just like waiting in So how do I begin my algorithm, I'm going root node. So I'm just gonna start with a on my algorithm. So my main algorithm should check it's not because I have at least one element. And so we know that a would be removed, A node being explored when something leaves say that now it's being visited. So I would add a I need to look at his children. He has two add them into my queue. And so let's say I Notice that C must enter behind B, right. And I have the next iteration of my algorithm, I take right So b is now my current, I add B to my I push D followed by he behind it. At this And it's so on so forth. From here, see leaves the and I look at sees children see only has I go ahead and add them to the back of my queue. right at this point had my next iteration. At this I still have some stuff to remove. So D leaves in Since D has no children, there's nothing to add queue, I added to my list of values, no children, leaves the front of my queue, I just add it to my now my queue is empty, which must mean that, hey, are no more nodes to explored, I explored and All right, and this output actually looks correct, about the complexity of this algorithm. So we know from the get go, that n is going to be the be the term for our sides of input. And we can say roughly, because we know when it comes to visiting we're going to add every node to the queue once, the queue also wants, so it's not like we're we're not going to double visit any of these. In a of n at most, because, you know, we're just going And in general, it's probably going to be less we use in our queue. An important thing I'll time complexity of this one, here, we're going that's if we can assume that adding something now something from the queue occurs in constant if you use actually, a built in an efficient queue complexity for our breadth first. But if you use perfect queue, then you might have an actual worse O of n assumes that we have a maximally efficient With that being said, I feel pretty good in the walkthrough video, and I'll show you a Hey, programmers, Alvin here, right now I want breadth first values function. So hopefully, in which case, this one should be pretty much a the motions of it, because it's going to be useful always hear me say, Alright, so to tackle this right? So nothing fancy in JavaScript, what I using very specific methods, right? So I'm cube. And we're going to initialize that queue guard against upfront is imagine they gave us the initial route is no, which case it would return an empty array. So I'm going to guard for No. And if it is, just go ahead and return an I need to start in my main loop from algorithm. just like we spoke about in the approach video, then keep on going. Now I begin a single iteration of my queue, right? So it's really up to you which remove from one end and add to the opposite end. it's the front of my array, I'm going to treat right? So if I want to remove the front and say, that removes the front also returns to me, that x. And then from here, I need to add this node main flow for this breadth first traversal. hey, if my left child exists, so if, let's what I should do is go ahead and push that into my and it's just going to be symmetric So if the right exists, then push the Awesome. And so that looks pretty good. And the nodes I visit in an array for the so nothing too fancy. I really want to insert some array, I'll call it values, sort of empty whenever and push it into my values. So I say values dot And do note that, what you can't do is just take value, it must be a totally separate thing, traveling through in a breadth first order. And the order in which things lead the queue. as soon as something leaves a queue, that's what I Nice. And after my while it's done running, So let's give this a test. I'm gonna have a few test cases to pass. And there we our breadth first traversal. Just something I want So looking at, I don't know, like the very breadth first, what they asked us to do is that moves from left to right, so notice it goes not a CB, right, those would both be technically kind of choose depending on what problem you're or right to left. For me, because I push the left going to leave the queue first, right, because checkout. So if someone enters first, that is the the right go. And you can just flip these around. goal. So depending on what your problem warrants, And this is actually probably like the only from just some superficial changes to like the only go to solution for a breadth first traversal people try to do a lot is there is not really a traversal recursively. And that should make needs a queue order right needs to use a queue. If hood, it's using a stack. And so that stack versus And you're going to have a really tough time So always just writes the iterative version recommend before you hop into the next video, make because we are going to level up difficulty a Hey programmers, Alvin here, right now I tree includes problem. So the premise of this and also a target value to look for. I Is that target value found within the binary the answer is obviously true or Yes, right, you for give you another target value like Because that value j is nowhere to be found within do here is we're stepping through the canonical problems. And I think I'll walk through both was testing or I wanted to trace through rather of attacking this one, right? We know that in a binary tree as input, they're only going to give if you have access to the root node, then you know tree, right. So what I can do is just perform any Now let's just do either the breadth first search think for this trace, I'll stick to the breadth queue, right? So as we trace through this, I'm hopefully you recall from our previous problems you start with your root node on your you mark it as your current right. And here's this particular problem. When something leaves is that current value the same as my target value, found the thing I'm looking for, right? And what look at his children. They both exist, I add them to my queue. And now I'm on to my next iteration and I have to check, hey, is B, my target, I look at B's children. So I take that D and process just continues, see leaves front of my I would add C's children to my queue. So I just And so d leaves the front of my queue I check is d right? Recall that in our breadth first traversal, don't want to add any, like null pointers into right, I still have stuff in my queue to check. I check Is he my target. And indeed it is right at inside of my binary tree. So what I can do is just right? There's no point of actually looking figured out that, hey, my target value is indeed is, it looks like I only checked for IE once was initially added to my queue. Technically, you queue. But we'll kind of see when I walked through cleaner code if you just checked for your target see that when we go through the code. It's just a this iterative breadth first strategy, what can as the number of nodes, then we know that the a classic breadth first traversal. So nodes the queue once that's open, right. And again, right, where our queue add and remove operations time. And for the space complexity, it's also just going to store our nodes within the queue. iterative breadth first solution, not to this version, and the depth first version, that would the iterative debt per solution, which case you about, but just use a stack instead of the queue. right. And the reason I think it's really this is, as we move to more complex topics, you're useful, right? So we have the same input, right? binary tree. And now I want to check recursively attacking this? Well, we're going to need to think really two types of base cases, we'll have we found a match. And so whenever I counter a my target, then I'm gonna have that node or that like, affirmative base case. So I'm just gonna you know that this II nodes gonna return true. And Four times where I call upon an empty false. And recall from our previous lectures, explicitly our null nodes. So I'm going to fill would have a left child that is null. So I'll kind node like that is going to return false. Because all of my recursive calls as if they're their own can you find this E value within an empty tree? The answer to be no, I can't find the value in And so from there, I'm also going to draw null pointers, right? So it looks something like give it a null left and right, because I already right? So that's why I draw my tree like this. Cool. So we just labeled all of the base cases, a leaf is just a node with with no children, all of these Boolean values to get the true at that is at the a node, or the a recursive call, And the logic we should use is really just So let's start evaluating our return values and somewhat of a similar pattern to like the tree is focus on this D node over here, this node has And when it actually gets those falses returned to false or false, which evaluates to false, right? I cannot find the value, which makes sense. That's look at this B node, now this B node has values to bubble up a little bit. And I take the order true. And this process continues everywhere in the me false. At the C node, false or false gives me true or false, give me back a final true, which you realize how similar the solution is to our some problem, I combined my left and right, addition. But this time around, I just need so by just adjusting the type to Boolean, we out George Boole. And so with that, I think let's and I'll show you it using the interest of the recursive version, which is my personal Hey, programmers, welcome back. Alright, and I tree includes problem, right? Well solve this both we'll start with the iterative breadth first be implementation of the classic breadth first classic a breadth first traversal code, and then So you should be familiar with it by now. But for cube. So I'll say const, q equals an empty array, inside. And from there, I have my main algorithm, So while queue length is bigger than zero, and traversal, what I do is Q dot shift, so remove remove the first element. And I'll save that into an instance of node. And for now all why don't I don't know, console dot log, what current what I want to do is really add its children into general, I'm going to write like q dot push, so I get a nice cue order, push the left child, But imagine that I have an asymmetric node or only have a right child, so it's left would be no. my queue as the left, which is no good, right. And if they exist. So something like this, hey, if the then I can go ahead and push it. So this is the main traversal part of the code. So I'll maybe just this call, so I'm not gonna return should at least see my values printed. If I kind node class, I should see the values printed in a D, E, F, recall that breadth first traversal so I must finish a level before traveling to the a script. See what we get here. A, B, C, D, E, F, And now I can work in I think, the conditional over here. So pretty straightforward stuff. We'll queue. I can check If the current nodes value is looking for. So just return true, right, you're of the tree because you can return true. But on is not the target value, that I must continue So if I finished the entire while loop, that means found the thing I'm looking for, I should return are really common mistake people tend to make is, what you don't want to do is just do like, else Right? Because this would only check like the very check if the root is not equal to the value. not really useful, because it could be somewhere return false pattern over here. But with that, I as well run the test cases by hitting that test did not for C. Cool, and there it is, right? Can I look at that spec. Test five gives us a null you cannot find the B character inside of the And so I can just handle that one explicitly. route is no, right, if that's the case, then just in an empty tree. Right? The reason our then I initialize my queue with no. And when or rather shifted from the queue in the first is an illegal JavaScript operation. Nice. And there, we have our breadth first All right, now let's work on the recursive depth favorite, because it utilizes a pattern that I much more difficult problems. So like we said, the approach, you definitely want to check what I should do is check Hey, if my root is then just return false, right, because I can't that's just a given. And from there, I know I'm depth first traversal code, which means you call what recursive means. And you pass along your right. And when I should be sure to do write the target that you're looking for, it never are going to give me back boolean data. And I call would represent whether or not I found the the result of if I found it in the left subtree. And I can just do the logical OR on both of then return true. So I could just write in line in my right subtree, then this left hand side this entire thing evaluates to true. And let's either subtree. So this evaluates to false. this or false gives me false. However, one thing I need after I check if my route is no, what I want to currently at, maybe it actually has the target, then you're also done, except you can return of our approach video. So let's give this a shot. clean this code is. I will admit, you know, it's recursion, in which case, I'll totally convinced kind of clean this code is really leverages bring up is it's really keen that I put this right? So let's say I flipped the I believe that would not work out always because so I'm feeling a test 00. But in general, if you right? You're gonna start by checking right? Can I read property valve? No. So you want checks if your root is null, right? Because that this is actually the code you want. Over here. tree includes solution, I want you to practice Hey, programmers, Alvin here, right? Now I want And so in this problem, I want to take in a binary this time, the values within the nodes of this what I want you to do is compute the total sum of we should end up with 25. And so hopefully, you're especially given you know, the algorithms I've studying our problems, and are there hopefully, this one, we could of course, just use any type breadth first or a depth first traversal. And we And of course, we probably initialize that sum or depth first solution, I think, is very to really step through that approach with you especially if you've done the previous two actually how to solve this one recursively, which we know that hey, depth first traversal relies it is utilizing the underlying call stack. And so when we trace through this type of some problem we're going to do is try to be especially if you struggle with recursion, for particular nodes of my tree, like the four I know like programmatically, what that means is no, or it's a null pointer. And so I'm just Again, they'll just help us really understand how And so if I know that I can put like then it could be the case that other nodes like left and right children that are also know. So it would look something like this. Cool. And this comfortable with recursive problems, especially is, we know that when it comes to solving any case, that is like the simplest version of our base case needs to be about the null node, right? or represents the empty tree in a sense. In other of a null node or the sum of an empty zero, to write elegant recursive code as a problem in itself, right? So if someone I would return the total sum of zero. And what they would return zero as their computed sums. information to actually build up my main solution? to the left. And what I have to do is figure and I can compute that given the values if I return those two null values returns to zero. which just equates to four, right? And that is number above a node represents the total sum the total sum of that four node is just four. over here, right? When these base cases return have to add my left and right child together gives me to not do that same thing. For this note right? It's a calculate the total sum rooted at to the top. And now I do four plus 11 plus two, quick spot check, right, this 17 does represent and we'll carry on over at this one node, we know And now at this four node, I can compute its total child of zero, right? Because it has a null node. is perfect. And finally, at the main route, now I three plus five. And that gives me a final answer So that's how we should really think about our I kind of draw it out, I think about the but typically about the null node. And then from its result given its children's answers. Alright, it's pretty straightforward. We'll go ahead and in which case, I can see that my time complexity make a recursive call just for every node of the right, we're going to have just one call for every just going to do some simple arithmetic, right, we not like we're going to have like a loop inside the space complexity is O of n, just because we we are going to solve this one recursively. And so which would be actually a maximum efficient a I think, let's head over to the walkthrough Hey, programmers, Alvin here, right? Now I want tree some problem, I think this time around, and So we'll start recursively. And we'll begin with the simplest version of the input, where any additional calculations, right? I know given is going to be the empty tree, right? I And if your root is no, you have the empty kind of inherently, it's just zero. So I'll I'll think about how I can compute my answer, the results of the some of my left subtree. just call recursively. So tree, some of root Cool. And I know that these two calls, they return subtree. And the sum of my right subtree. As the sum? Well, it just is myself. So root out value, in my right subtree. Right. And we'll go But this is nothing fancy, really elegant code a diverse output. So this code does work on trees helps me you know, really believe the magic of right? So let's say that I'm stepping through tree So I checked the base case, is this three node? right. And I know that when I break down this code be like three, so I'm kind of corresponding, this when I make the recursive call on tree, some root of this subtree starting at 11. So I'm looking if I take the total sum of just that left 13. It's now I'm saying plus 13 over here, subtree I know that this call is for this that should just magically return by the five, right? I'm going to assume So you're out the five, right? If I take the total That would give me the correct answer, right. I just write the code. And then I assume I figure out how I can take those sub valleys and that should be my final answer. So here which would be some sort of a depth first And if you'd like, I can also show you the And I always practice usually my problems doing if it's reasonable, and is really reasonable our breadth first code by now, right? So I'm just root that is already know that that's kind of an right? Because as some of that empty subtree, that can begin my main code. So while my who begins with the Route Route, I want to loop length is bigger than zero, I'll begin a single the front of my queue. So in JavaScript, for me, and also returns it to me. So I'll save in this current, I know that contains the value is go ahead and track some running sum. So I'll And as I remove something from the front and add it to my total, something that will sum. And from there, I just need to add my right? If they exist. So if I have a left, then what I'll do is add that left child into again, make sure you're following your cue push adds to the back, it's really important that work on opposite sides of my queue. Otherwise, I'll write something symmetric. For the right I'll just go ahead and return my total sum. course, it's technically a breadth Nice. And here we have that solution. So one be consistent how you implement these algorithms, am a fan of a writing my like processing logic for where I add the value of my current node into typically when a node leaves the queue, and not up being less repetitive that way, for example, where it's like, Alright, well, you know, I guess that means it exists. So not only will I push it, plus equals current dot left dot Val, right, so it's added to the queue. And you can write you can see that because of this, I kind which does not make it super clean. And I think now you actually never added your root value to begin your total sum as root dot value at this right? So you can run this, this would probably what I think is the best design for this pattern. your values when they leave your queue because you So I'll prefer it at least like this. Cool. recommend you practice both versions. I do it iteratively have them both down pat because Hey, programmers, Alan here right now. tree min value problem. So just like we've been binary tree as input into our function. And value within the tree is. That is we want to find the tree is going to be non empty, right? And particular tree example, it's pretty plain for is just this three. Alright, so our function just to see that the answer is three. But how can we we should look to our tools in our binary either a breadth first or a depth first traversal. a depth first or breadth first iterative piece the tree, then you just need to maintain some And whenever you hit a node that is smaller that minimum variable. And by the end of So the iterative version, I think, is pretty that when we get to the code walkthrough. But for we'll step through this one recursively, right, And so let's take a look at this tree. And null pointers, like usual, right? So these dark meaning that there are no, right. So for example, but its right child is 12. And that's going to be I should make a base case about those null what I want to do is figure out what the smallest value for our null nodes would be to return that I should not really consider any of the positive infinity, I know that positive infinity compared to any numbers that are actually just fill in all of these infinite values. null node, or a null pointer, we're going to Now using those infinities as our basis, we So looking at this for node to the left, what I it received, right, and also the value within alright, compared between infinity for an them? Well, I know positive infinity is a very should be four. And so this call should return similar story for this 15 node. Once I have a comparison with those values against myself, infinity? 15 and infinity, the minimum is 15. I evaluating this 11 node, right? Now I have some right? I compare my left subtree value, which And also myself, which is 11. So among 411, and just be the four, right? So this node should this makes some sense, because I have this answer within that subtree rooted at 11, the smallest Now we'll just go ahead and valuate the rest of can't evaluate the three because I need a value on 12. And I just do the comparison, right? What's let's just definitely 12. Finally, at this three the minimum there is three. And finally at the what's the smallest among four, or five and right, which is exactly what we expected. And so depth first recursion, we can totally solve this our child sub solutions into our main solution at every point of this tree, we asked ourselves, subtree and given the smallest value in the right smallest among those three. And then when it straightforward. We'll go ahead and say that n is know that we're going to have a call for every n time. In terms of the number of recursive calls, call, it sounds like we're just going to do some among three things. Since three is a constant have just an overall time complexity of O of n, Now, that being said, we'll also have O of n that we use for baseline depth first traversal. problem. Because what we'll do, we'll go ahead and Hey, programmers, Alvin here, right now I want to value problem. And of course, we'll solve this showing y'all maybe some iterative solutions. And breadth first, along the way, right. So you know, within your binary tree. So just go ahead and set start with a stack over here. So I'll say Kant's, aware of is looking at the assumptions in the the input tree is not empty. And so that means I if the top level root is null. So I can just go inside. Cool. And then from there, you need your So I'm going to loop while my stack is not empty. So if that's the case, and there are still some this algorithm, let's say depth first, by doing go ahead and call that my current. And then if our children exist. And if they do, I'll So I'll write a pattern like this, I'll say if, to No, then I can go ahead and push that existing and I'll push current left retinas a few times by code for the right hand side. And this is kind But as I look at this current node and its value, the minimum value within the tree. And so because we're going to use a variable that I'll update thing I've seen. So I'll initialize this as let default value for this. And so I'll go ahead and So if you're unfamiliar with some JavaScript, guaranteed to be bigger than all other numbers, I'm choosing a big number, like positive infinity, is because when I see any actual values of my infinity. So these numbers would replace my right? That's a pretty common pattern, right? typically your default value is positive infinity. default value might be zero or negative infinity, And so with that default value, where do I choose to do that right after or something leaves If I wrote it, when I added my children into which is kind of annoying. So I'll just check, actual number value, current value is less than right? So just replace that variable with current we should just return that variable, right? And that a shot, run these test cases. And this right? Awesome. So if you wanted to switch it trivial in terms of the change we make, you can because that would remove the front element still adding it to the back. And I guess you So very minute difference. Well, Cool, passes all of them. Nice. And one thing immediately when I recorded this video, there data structure just baked in, like you can't when you actually do the array dot shift method, right, because if you remove the front element of shift all the other elements over one position. index two becomes index one, and so on. And so exactly like this, just using a regular array, technically like an O n squared solution, which the specs, typically n squared for most problems to get the blazing fast solution. But now let's version, which would be a recursive version, Right? So we'll say const, trimming value, to establish this one recursively will always you saw these curly guys. So I'll start my base then that kind of means I have the empty tree, While that must be infinity, right? For right? It's just a good default value, Cool. And now what I want to do is I want to make on my left child, and I call it on my right function calls return. Right? Although they're me back the smallest value in the left subtree. maybe, just to be clear, I'll go ahead const, I'll say, left. Min. And also this the smallest in the left and the smallest in the right? I am ru dot Val. So I need to choose the so you can write like a conditional. So just best way to implement this in JavaScript is just you always have access to the global capital math going to find useful right now is math dot min. and an arbitrary number of arguments. So give sure to access the value because you Smaller between route dot Val, my left men and my to the approach drawn we did right where we had So before we run it, maybe you're unfamiliar with Let's say I had some numbers, we had 10, we 12. And also 100. And if I console log with that I'm not going to execute the tests quite yet. smallest perfect. And now I think we're ready to there we have it. Cool. Alright, so there, we have problem, recommend you practice all of these maybe just have in your back pocket. That way, right. So you should have no issue thinking about now, you know, we're getting pretty comfortable fall back to either a breadth first or a depth we're definitely going to look at some spin offs more complex logic using these algorithms as Hey, programmers, Alvin here, right now want to pretty wordy title, let's take a look at what taking in a binary tree as input, and we want to in particular, root to leaf paths. So just to for us has a single root and you can identify the the node with no parent, right? And then also a leaf is a node that has no children. So do node has no children, some Like 11, and three in right. So it could be the case that a tree has leaves. But a tree for us typically only has a all three of the different root to leave paths, terminate at a leaf. So one of those paths would do is consider its total sum. So just summing If I do five plus 11, plus four, that would give possibilities. If I look at another path, let's would give me 18. That's another option. The only five to five plus three plus one. That gives me three options, I want to choose the maximal path So in the long run, we need to come up with from the root to any leaf. And that sounds like doing that one? Well, hopefully you notice some previously. So just by looking at the name of this right? I can think of the tree some problem seems like that minvalue. Problem are, we had I want to maximize something here. And so probably of my previous knowledge to come up with a pretty on our previous experiences, right. And I think we're gonna solve this one recursively. for tree problems, that is, a recursive code pathfinding things, right, and building pads and we should have our base cases be, if we're gonna all right, you need to consider paths, but end at a leaf node. So the leaf nodes, like So my base case is going to be literally about with no children. So for example, let's say then what's the total sum of that leaf node? kind of think about your base cases as if they're so a totally separate scenario, right? Now, let's and its value was 42. And I asked you to, alright, tree, this tree is very small, right? If you node, right? Because it has no parent. And I've leaf here. And it's also the 42, right? Because it in this example, is the root and the leaf, would just be 42. Cool. So I'm thinking about my And what you'd probably recognize here is, in this that is not about a null node, right, we will if we have an actual leaf node. And that's right? They say root to leaf path. Awesome. So if my leaf nodes in this diagram. And I know that So just plugging those in, right? And now I can right? So given this 11 node, what decision does right? So let's read ourselves at this 11 node. right. And so if i route myself at 11, the subtree. And the right hand side to now represents Since I want to maximize here, the key right? I choose the bigger of them, right? So And what I do is I take that four, and and that gives me 15. And that would actually be check for correctness right now, if I root myself right? I can either do 11 plus four, which Right and that 13 is smaller, so I won't prefer in good shape. Now let's take a look at another node. So it has a value on its right hand side, but the left child doesn't exist, right? And we know that the left child or three dot left is plug that in here. And here's where we should it's very natural to course correct as we go. Well, we know that whenever we have a null node, we can kind of just ignore it, I guess, we want of our internal logic. So bear in mind in this from our previous problem, right, the min And so we made our null nodes return infinity, my null nodes, return infinity, by default, I know right? Because infinity is very large. And we So because in the long run, I want to find the null nodes return negative infinity, right? to win any contest where we compare things, So for this null note, I'll plug in that able to do the same business logic as before, and I can look at the results I get for my my left path, I get a negative infinity, or in my between them, right? One is bigger than negative what I do with that one is, I add my current value right. And that makes some sense, because if the biggest path from root to leaf, or sub and now we have ourselves at the ultimate root I check the bigger of my two children, so I'm giving 20. Like we said before, this 20 logically Cool, so there we have it. And if you want to take unusual. So we're going to have n as the number because we're going to have to make a call a the tree. And if I think about any particular we're just going to do a comparison, right, I just going to have any, any loops within our calls, I Like we always say space complexity is O of n, ahead and code this one up. And it should feel problems, as well as some a min value max value I want to go over a JavaScript solution for this going to be a pretty interesting tree problem. sure you watch the approach video before this. that we want to implement here. Right? And so say that's probably the best way to solve this when I want to do is start with a base case, to leaf paths. So our base case should be about go ahead and check let's say, if my root left is No, right? That's the definition of a leaf. So if then I should return the value stored at this we're kind of emphasizing here is that base right, we have no children. Nice. And we will need say we left it like this, right? So we said that the decision we make at every note is I choose the and then I add myself to it, right? So I know I'm the same function. And right now you should be root left, and also root right? That I think about the max pass some through my left subtree subtree I just want to choose the So no I swear to you saw me use the math dot min And I know that these calls these expressions pass these guys in, in line. So I would just max between these two results, and I'll max, your child, right? Maybe I'll write there, I just add myself to that max route dot valance myself, plus max child. And it except for one thing we're forgetting. So lines here. And what scenario Am I missing? We did what is not present here? And that's something come up with a nice, meaningful and consistent should translate to some piece of code over here. See what we get? Yeah, so we're getting an right, I found on the very first example. asymmetric node, like this four over here, what would happen in this instance, we know that our route is going to be this is not hit, right? Because four is not a leaf, child does not know. So instead, it's going to max path, some of root dot left root that left is now we're seeing is no, and we're gonna check right? It's exactly the line that's broken. when we bought him out at a leaf node, what if we then we said that a good value to return would be in the long run, do like maximal logic and want to that won't interfere with any of us taking a was negative infinity. And I would just prefer right? Negative infinity that is. And so Cool. And then we have a nice solution problem. So notice how short the code is, though, right? At this point, it's okay if it have some familiar patterns, right, I still here. And we typically only vary in how we take and combine them into our higher level answer. So in the next one. All right programmers. That wraps If you want to explore this binary tree topic, or topic more deeply. Be sure to head destructing through tons of problems where we have video problem. I think you'll find this especially for those technical interviews. Thanks