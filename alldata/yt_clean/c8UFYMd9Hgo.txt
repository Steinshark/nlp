Hey folks, today we've got a jam-packed lecture looking at functions in Python. Welcome back to the complete course Mastering Python. I'm Gunnar, in this channel, is all about teaching you how to code. Today, we're going to look at a super powerful concept in programming functions that don't only help you write more efficient, but also more organized code. We're going to look at everything. We're going to look at declarations and generator functions, decorator functions, lambda functions, the lot. So without further ado, power up your IDE of choice, VS code, PyCharm, whichever you like, and let's get coding. A function is a block of code that performs a specific task. It's a way of packaging up a set of instructions that you can use over and over again. Now, to define a function, we use the def keyword. Here's the basic structure. We use the def keyword to tell Python that we're defining a function. Then we give our function a name, in this case, greet, and define any parameters that the function needs. Here, we tell it that the function needs to receive a variable, which we call name. You can think of this like a string that you give the print function so that it knows what to do. Finally, we finish off the first line with a colon, which marks the end of the function header. Next comes the function body. This is where you write the code that the function will execute. This must be indented as a block so the function knows what belongs to the function and what doesn't. As we've seen, we can pass data to the function in form of arguments. Of these, positional arguments are the most basic way to pass data into a function. They're called positional because the order in which you provide them matters. Here, for example, in this function, name and age are parameters. And when we call the function, Alice and 25 are the arguments. The order is important. Alice matches the name and 25 matches with age. If we swap them around when we called the function, it would consider 25 to be the name and Alice to be the age, which really wouldn't make much sense. We can also use keyword arguments, which are passed to a function using name value pairs. They offer more flexibility and can make your code more readable. Here's an example. Instead of simply calling describe with positional arguments, we are explicitly naming the arguments, in this case animal and name. If we change the order that we provide the arguments in, it still works. That's pretty cool, isn't it? Now, this can be especially useful in functions that have many parameters. We can also give our parameters default values. Now, default values allow a function to work, even if you don't provide all the arguments. Here's how it looks. In this example, if we don't provide a greeting, it defaults to hello. However, be careful with mutable default values, like lists or dictionaries. They can lead to unexpected behavior. For example, you might expect the second call to return just banana, but actually it returns a list of both apple and banana. This is because the default list is created only once when the function is defined. To avoid this, use none as the default and create the list inside the function. Now, each call to the function will start with a fresh list and empty list. Remember, you can always override default values by providing your own arguments when calling the function. Right, return statements. Return statements are crucial in functions. They allow your functions to send data back to wherever it was called from. When you want your function to output a value, you use the return keyword. Let's have a look at this in action. In this case, the function add numbers returns the sum of A and B. You can either return a single value, as we did a moment ago, or multiple values. When returning multiple values, Python automatically wraps them into a tuple. You can also use return statements to exit a function early if a certain condition is met. In this case, we are defining a function that divides two numbers, in case that B is equal to zero, and since we can't have division by zero, we want to end the function here and give the user an error message. Once a return statement is executed, the function immediately exits. No code after the return statement in that function will be executed. Now, if a function doesn't have a return statement, or if it has a return statement without a value, it implicitly returns none. In this example, we simply print a greeting message. There's no need to return a value. I leave it up to you as a little exercise to check that the greet function actually returns a none value. Documenting your functions is vital if you want to be able to understand your code base in the future, or if others are going to work with your functions, and doc strings are a great way to document your functions. They are a description of your function and make your code more readable and easier to understand. We create doc strings by using triple quotes right after the function definition. Here, for example, we have a detailed description of what the function does. It calculates the area of a rectangle and takes two parameters before returning a single float. You can access a function's doc string using the doc attribute or the help function. When writing doc strings, it's best to always include a brief description of what the function does and list and describe all parameters. If you also want to specify the return value and if needed, write a short example of how to use the function. It's important to note that in Python functions are first-class objects. What this means is that you can treat them like any other object, such as assigning them to a variable or passing them as arguments to other functions. Now, in other words, you can assign a function to a variable, creating a new reference to the function. Let's look at this in practice. Here, we create a function called greet that returns a hello string and we can then assign the variable say hello to this function. So, when we call say hello, it will call the function and when we run this, it gives us hello Alice. This feature allows for dynamic dispatch where you choose which function to call based on certain conditions. Now, you can also pass functions as arguments to other functions. This is commonly used for callbacks and creating higher order functions. Here, for example, we create a higher order function that just applies an operation on the two parameters it's given, except that we don't know which operation it will use. The function that defines the operation is passed to the apply operation function as a parameter called operation. We can then call this function passing either the add or multiply function as a parameter, giving us 8 and 15 as output. This technique is super powerful for creating flexible and reusable code and it's widely used for implementing strategies or plugins. But functions don't end here. There's lots more that we can do with functions in Python. We can, for example, create anonymous functions that don't have a name called lambda functions. It sounds really weird, but it's super useful as well. Now, lambda functions are small one time use functions that you can create on the fly. The basic syntax for lambda functions is lambda and then the arguments that the function takes, colon and the expression to apply. For example, we can create a lambda function that adds two numbers together and then store it in the variable called add. You see, the lambda function has two arguments x and y. The expression is adding the two numbers together, which the lambda function then returns. When we call add, you see that we get an output of 8 as expected. Lambda functions are commonly used in functional programming concepts like map, filter and reduce. The filter function is used to construct an iterator from elements of an iterable for which a given function is true. But most of the time we don't need to write a full function, but just want to perform a quick operation. This is where lambda functions shine. Here, for example, we want to filter out the even numbers before converting them back to a list. We create a lambda function, lambda x, where x modulus two equal to zero, which takes values of x and determines if this number divides two evenly. This function is performed on every element in numbers. Filter only return the values where the function is true, so only the even numbers. After that, we make a list out of it and print it. Pretty cool, right? We can also use lambda functions with the built-in map function that allows you to apply a given function to each item in an iterable and return a map object, which we can easily convert into list or tuple or whatever we want. It's particularly useful when you want to transform or process a collection of data elements in a single line of code. Here we start with the list of numbers and map through it. For each iteration, we apply the lambda function, which takes x and squares it. Finally, we create a list out of the results and we get 1, 4, 9, 16, 25 as output, as we would hope. Functions can also call themselves within their own code, and this is what we call recursive functions. They're particularly useful for solving problems that have a recursive nature, like traversing tree structures or calculating factorials. A recursive function typically has two parts. First of all, the base case. This is the condition where the function stops calling itself. And then secondly, it has the recursive case, where the function calls itself with a modified input. Let's look at a simple example of calculating factorials. And this is how it works. Now, if n is 0 or 1, we return 1. This is our base case. This is what we start with. If n is not 0 or 1, so if it's bigger, we multiply n by the factorial of n minus 1. So we're calling itself, and this is the recursive case. The recursive case continues on until we reach the base case. Now, recursive functions can make your code more readable for naturally recursive problems. They're great for working with hierarchical data structures like trees. However, be careful with recursive functions too. If they go too deep, you might run out of memory, so you always have to be careful with them. Okay, let's look at another cool feature with functions called decorators. Decorators are a fantastic way to modify or enhance functions without changing their core logic. Think of them as wrappers that add extra functionality to your functions without modifying the original code. It'll be easier to just look at an example. Now, here we define a decorator function called my decorator, which takes a function as a parameter. Inside the decorator, we define another function, in this case, we call it wrapper, which calls the function that we received as a parameter plus some decorator-specific tasks. It then returns the wrapper function. To use the decorator, we place the at symbol and decorator name right before the function definition. When we run this code, we get something is happening before the function is called, then the output from the function, in this case, hello, and then something is happening after the function is called. In other words, the at my decorator line is equivalent to say hello equals my decorator of say hello. It wraps our function with additional behavior. When you stack multiple decorators on a single function, they're applied from bottom to top. Here, for example, we define two decorators, bold and italic, which wrap our text in HTML tags. When we stack them onto the hello function, we can see that the italics is executed before bold, right? So far, our functions have always had a defined number of arguments, but sometimes you might want to create a function that can accept any number of arguments, like the print function, for example. This is where arcs and kw arcs comes in. The star arc syntax allows a function to accept any number of positional arguments. Using the star arcs as an argument to our function, we're telling it that there might be any given number of arguments. We can then iterate through them as we do here. Printing out the results, you can see that we can use any number of arguments. The star star kw arc syntax allows a function to accept any number of keyword arguments. Here's an example of how you use the star star kw arcs. We can then unpack each item from the dictionary list of key value arguments, and in this case, print them. It's important to note that when you mix regular arguments with star arcs or star star kw arcs, always put the star arcs or the star star kw arcs at the end of the parameter list in that order. We've already covered a lot about functions in Python, but there are a couple of more things to look at. Generator functions, for example. Generator functions are another cool feature of Python. They allow you to generate a sequence of values over time instead of computing them all at once and then storing them in memory. In this example, we're creating a countdown function that yields a lower and lower number until it hits zero, like a real countdown. We define the function as before, but this time instead of a return statement, we have a yield statement. The yield keyword is what makes it a generator function. It returns a value and pauses the function's execution until the next value is requested. You see, we're counting down from five to one and lift off. Using generators has many advantages. It's more memory efficient for one. Generators also produce values on the fly rather than all at once, which is great for large datasets. They also compute values only when needed, and this is called lazy evaluation, which can vastly improve performance. And finally, you can create infinite sequences with them without running out of memory, as in this example. And there you have it, functions in Python. It wasn't that difficult, but they're a super powerful concept. Next time you write a script, try to incorporate functions, and you'll soon see how much more organized and more efficient your code will become. Next time, we'll look at modules and packages, another great concept in Python. So don't miss it out, and I'll see you in the next video. Happy coding!