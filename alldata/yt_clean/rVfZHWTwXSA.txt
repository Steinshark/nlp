All right. [NOISE] Um, let's get started. So, um, let's see, logistical reminder, uh the class midterm, um, is this Wednesday and it's 48-hour take-home midterm. Um, and the logistical details you can find, uh, at this Piazza post, okay? So the midterm will start Wednesday evening. You have 48 hours to do it and then submit it online through Gradescope, uh, and because of the midterm, there won't be a section, uh, this Friday, okay? Oh and the midterm will cover everything up to and including EM, uh, which we'll spend most of today talking about, okay? Certainly don't look so stressed. It'll be fun. [LAUGHTER]. Maybe. All right. Um, so what I'd like to do today is start our foray into, uh, unsupervised learning. Uh, so far I've spent a lot of time on supervised learning algorithms including advice on how to apply supervised learning algorithms. These pens are great. In which you'd have, you know, positive examples and negative examples and you run logistic regression or something or SVM or something to find the line- find the decision boundary between them. Um, in unsupervised learning, you're given unlabeled data. So rather than given data with x and y, you're given only x. And so your training set now looks like X1, X2, up to Xm. And you're asked to find something interesting about the data. Uh, so the first unsupervised learning algorithm we'll talk about is clustering in which given a dataset like this, hopefully, we can have an algorithm that can figure out that this dataset has two separate clusters. Um, and so one of the most common uses of clustering is, uh, market segmentation. If you have a website, you know, selling things online, you have a huge database of many different users and run clustering to decide what are the different market segments, right? So there may be, you know, people of a certain age range, of a certain gender, people of a different age range, different level of education, people that live in the East Coast versus West Coast versus other parts of the country. But by clustering you can group people into, uh, different groups, right? So, um, I want to show you an animation of, um, really the most commonly used er, er, clustering algorithm called k-means clustering. And let me show you an animation of what k-means does and then we'll write- write out the math an- an- and tell you how you can implement it. So, um, let's say you're given data like this. So all these are unlabeled examples. Uh, so just x plotted here. And we want an algorithm to try to find maybe the two clusters here. Uh, the first step of k-means is to pick two points denoted by the two crop- two crosses called cluster centroids and, uh, the cluster centroids are your best guess for where the centers of the two clusters you're trying to find. And then k-means is an iterative algorithm and repeatedly you do two things. So first thing is, go through each of your training examples. Oh I'm sorry. Oh okay. Thank you. All right. Let me know if that happens again. Okay. Right. So, uh, you guys saw that, right? So. Right near two cluster centroids. So the first thing you do is go through each of your training examples, the green dots and for each of them you color them either red or blue depending on which is the closer cluster centroid. So here we've taken every dot and colored it in red or blue depending on which side it is- which cluster centroid it's closer to. And then, uh, the second thing you do, uh, is, uh, look at all the blue dots and compute the average, right? Just find the mean of all the blue dots, um, and move the blue cluster centroid there. And similarly, look at all the red dots- and look at only the red dots and find a mean- finding the- oh now what's wrong with this? Let's say- oh this thing though is very strange. Right. Apparently, if I keep moving my mouse, it doesn't do that. All right. Thank you. Uh, and then find the mean of all the red dots and move your, uh, red cluster centroid there. So let me do that, right? So the cluster centroids move as follows, um, to the mean of the red and the blue dots and this is just a standard arithmetic average, right? Uh, and then you repeat again where you, er, look at each of the dots and color it either red or blue depending on which cluster centroid is closer. So when I recolor every point based on, you know, what's closer, so that's the new set of colors, right? Um, and then the second part of the algorithm was again look at the blue dots, find the mean, look at the red dots, find the mean, and then move the cluster centroids over. [NOISE] Excuse me, uh, to that mean, okay? Um, and so, er, and it turns out if you keep running the algorithm, nothing changes. So the algorithm has converged. So if you look at this picture and you repeatedly color each point red or blue depending on which cluster centroid is closer, nothing changes. And you repeatedly look at each of the two clusters of color dots and compute a mean and move the clu- clu- clusters there, nothing changes. So this algorithm has converged even if you keep on running these two steps, okay? So um, let's see. Let's write down in math what we just did. [NOISE] All right. So this is, um, a clustering algorithm and specifically this is a k-means clustering algorithm. So your dataset now does not come with any labels. Um, and so in, uh, k-means, step one is, uh, initialize the cluster centroids, right? I'm gonna call them Mu_1 up to Mu_k, uh, randomly, okay? So this was a step where you plop down the red cross and the blue cross. Uh, and when they did it on the PowerPoints, you know, I did it as if we're just choosing these as random vectors. In practice a good way of the- actually the most common way to select a random initial cluster centroid isn't quite what I showed, is to actually pick k examples out of your training set and just set the cluster centroids to be equal to k randomly chosen the examples, right? So in a low-dimensional space like a 2D plot, you know, you can do on the diagram, it doesn't really matter but when you work with very high dimensional datasets, the more common way to initialize these is just pick, you know, k training examples and set the cluster centroids to be at exactly the location of those examples. But then low dimensionless spaces it- it- you know, it doesn't make a big difference. Um, and then next you repeat until convergence. Um, step one is- right? So this is a- well now I'll just write this down, okay? Um, so does that make sense? So the two steps you would alternate between the first one is set Ci for every value of i. So for every example, set Ci equal to, you know, either 1 or 2 depending on whether, er, that example Xi is closer to cluster centroid one or cluster centroid two, right? So ju- just take each point and color either red or blue. Uh, or and represent that by setting Ci equals 1 or 2, er, if you have two clusters. If k is equal to 2, right? Oh yeah. [inaudible] Oh. Er, the notes say L1 norm squared? From this morning? Uh, what notes were sent out this morning? [inaudible]. Oh that's red. It shouldn't be L1 norm. Uh, if it says L1 norm, that's a mistake. Sorry about that. Er, but usually- an- and it turns out whether you use L2 norm and L2 norm squared that gives you the same answer because the algorithm is the same either way. But it is usually- do we have a typo on the notes? [inaudible]. Oh I see. Oh got it. Oh- oh- oh okay. Let's say in notes we wrote that. Okay. Cool. But by default, when we write that norm we actually use- we mean L2 norm. Yeah, right? But by- by default this is the L2 norm of x if is unspecified. Er, if it's L1 norm, we usually write this. So L2 norm is more common and with or without the square it you get the same result. Okay. Cool. Thank you. All right. So let's color the dots. Um, paint each dot either red or blue. Uh, and then, um, uh, for this, um, this is, you know, some key examples and take all the examples assigned to a certain cluster, right? Assigned to cluster j and set Mu_j to be average of all the points assigned to that cluster J. Yeah. [inaudible] Oh sure. Er, no that does not work. Uh, you know, I don't think -I don't know if I have- all right. Now, that the black markers are working, um, this is better? All right let me try to use this? Is there a part of this that's unclear? If this part you can't see, I'll write it out more clearly. Yes. Go ahead. Let's go ahead. [inaudible]. Oh sure. How I do it, lights in front? [inaudible]. Got it. Let there be light. All right. Awesome great. That was an easy request to satisfy, great, you know, okay. I guess we'll actually look at it for another minute. All right. Is that okay? Thank you. Okay. This wasn't part of it. Okay. All right. Now, I can move it up. [NOISE]. All right. Um, so it turns out that, uh, um, this algorithm can be proven to converge. Um, the, exactly why it is written out in the lecture notes. But it turns out, if you write this as a cost function, right? Um, so the cost function for a certain set of assignments of, uh, points of examples to cluster centroids and for a certain set of positions of the cluster centroids. So, so c, these are the assignments and these are the centroids, right? So, so this cost here is sum of your training set of what's the square distance between each point, and the cluster centroid it is assigned to, right? So it turns out, um, I want to prove this, uh, little bit more detail in lecture notes but I'm going to prove this. It turns out that on every iteration, k-means would drive this cost function down, um, and so, you know, beyond a certain point this cost function, it can't go even, it can't go, uh, uh, any lower. Well, this, this can't go below 0, right? And so this shows that k-means must converge, or at least this function must converge because it's, uh, a strictly non-negative function that's going down on every iteration. So at some point, it has to stop going down, and then you could declare k-means are converged. Um, in practice, if you run k-means in a very, very large data set, then as you plot the number of iterations, uh, j may go down, and you know, and, and just because of, a lack of compute or lack of patience, you might just stop this running after a while. It is going down too slowly. So that's sort of k-means in practice where maybe it hasn't totally converged, we just cut it off and call it good enough. Um, now, uh, uh, the most frequently asked question I get for k-means is how do you choose k? It turns out that, um, when I use k-means, I still usually choose k by hand. And so, and, and this is why. Which is in unsupervised learning, um, sometimes it's just ambiguous, right? How many clusters there are [NOISE]. Right? Um, with this dataset, some of you will see two clusters, and some of you will see four clusters, and it's just inherently ambiguous what is the right number of clusters. So there are some formulas you can find online, the criteria like AIC and BIC for automatically choosing the number of clusters. In practice, I tend not to use them because, uh, um, I usually look at the downstream application of what you actually want to use k-means for in order to make a decision on the number of clusters. So for example, if you're doing a market segmentation, um, you know, because your marketers want to design different marketing campaigns, right? For different groups of users, then your marketers might have the bandwidth to design four separate marketing campaigns, but not 100 marketing campaigns. So that would be a good reason to choose four clusters rather than 100 clusters. So it's often, uh, uh, if you look at the purpose of what you're doing this for. Um, I think in the previous exercise, uh, in the homework, you see a, um, image compression, uh, exercise where you want to cluster, uh, colors into smaller number of clusters. You implement this. This is actually one of the most fun exercises I think. Um, uh, uh, that, uh, uh, but so there you'd, you know, be saying, well, how much do you want to compress the image to decide how many clusters to, to try to use, okay? So I usually, um, pick the number of clusters, you know, either manually or looking at what you want to use k-means cluster for. Um, when we're trying to cluster news articles, uh, the Google News example, I think I showed in the first lecture. You say, well, how many clusters is going to make sense for, for, for news articles, okay? All right. So good. So, uh, yeah? [inaudible]. Oh sure. Well, k-means get stuck on local minima. Yes, k-means gets stuck on sort of local minima sometimes. And so, if you're worried about local minima, the thing you can do is, uh, run k-means, say, 10 times, or 100 times, or 1000 times from different random initializations of the cluster centroids. And then run it, you know, say 100 times, uh, and then pick whichever run results in the lowest value for this cost function, okay? All right. Um, so you'll play with this more in, um, uh, in the programming exercise. Now, um, there's a, there's a problem that seems closely related. Um, but, but it's actually quite different ways to write the algorithms which is density estimation. So, so let me motivate this. Um, I actually have a- well, right, sometime back had some friends working on a problem which I'll simplify a little bit, um, of, uh, uh, you know, you have aircraft engines coming off the assembly line. All right. And every time an aircraft engine comes off the assembly line, you measure some features of these engines. You measure some features about the vibration, and you measure some features about the heat that the aircraft engine is producing. And, um, let's say that you get a dataset, right, that looks like this, okay? And, um, the anomaly detection problem is if you get a new aircraft engine that comes off the assembly line, and if the vibration feature takes on this value, and the heat feature takes on this value, is that aircraft engine an anomalous one, is it an unusual one, right? And so the application of this is, um, that as your aircraft engine comes off the assembly line, if you see a very unusual signature in terms of the vibrations and the heat the aircraft engine is generating, then probably something is wrong with this aircraft engine, and you have your people, have your, have your team inspect it further or test it further, uh, before you ship the airplane, before you ship the engine to a, to a airplane maker and then something goes wrong in the air, and there's a, there's a major accident, or major disaster, right? And so anomaly detection, uh, uh, is most commonly done, or one of the common ways to, um, implement anomaly detection is the model p of x which is given all of these blue examples, given all of these dots, can you model what is the density from which x was drawn? So then if p of x is very small, then you flag an anomaly, right? Meaning that, Gee, I think something's funny here, uh, and maybe someone should inspect this aircraft engine a little bit further. Um, so anomaly detection is used for, a task like this, for an inspection task like this. Um, it's used for, um, uh, many years ago, I was actually working with some telecoms providers, you know, uh, uh, helping out telecoms company on, um, anomaly detection to figure out if something's gone wrong with a cell tower network, right? So if one day one of the cell towers start throwing off network patterns that seem very unusual, then maybe something's wrong with that cell tower, like something's gone wrong. We sent out the technicians to fix it. Uh, it is also used for computer security. If a computer, say if a computer at Stanford starts sending out very strange, you know, um, uh, uh, network traffic, that's very unusual relative to everything it's done before, relative what this is, is a very anomalous network traffic, then maybe IT staff should have a look to see if that particular computer has been hacked. So these are some of the applications of anomaly detection. And the good way to do this is, given an unlabeled data set, model p of x. And then if you have very low probability samples, you flag that as a possible anomaly for further study. Now, given this dataset, um, uh, how do you model this? One interesting thing about this green dot is that neither the vibration nor the heat signature is actually out of range, right? You know, like there are a lot of aircraft engines with vibrations in that range. There are a lot of aircraft engines with heat in that range. So neither feature by itself is actually that unusual. It's actually the combination of the two that is unusual. Um, and so thus, thus, what I want to do is, uh, come up with an algorithm to model this. And in fact, we'll come up with an algorithm that can model, you know, maybe, maybe your data density looks like this, maybe more of an L shape like that. But how do you model p of x with the data coming from an L shape? Um, and it turns out that there is no textbook distribution, right? You know, there isn't, you know, if you look at a simple exponential family of model, the types of distributions, there is no distribution for modeling very, very complex distributions like this. So what we're going to talk about is, um, the mixture of Gaussians model which we look at data like this, and say, it looks like this data actually comes from two Gaussian. There's one Gaussian, maybe there's one type of aircraft engine that, that, that, you know, is drawn from a Gaussian like the one below, and a separate aircraft- type of aircraft engine that's drawn from a Gaussian like that above. And this is why there's a lot of probability [NOISE] mass in the L-shaped region, but very low probability outside that L-shaped region, right? And, and, and these ellipses I'm drawing are the contours of these two Gaussians, right? And so, um, what I'd like to do next is, uh, develop the mixture of Gaussians model, um, which is useful for anomaly detection, and, and, uh, uh, and, and then this will lead us to our second unsupervised programming algorithm, okay? So, um, in order to make the mixture of Gaussians model a bit easier to develop, let me just use a one-dimensional example where x is in R, okay? So, um, let's see. So let's say that, uh, we gather a data set that looks like this. [NOISE] Right. So it's just one row number. So it's just on num- number line I plotted a few dots. Um, so it looks like this data maybe comes from two Gaussians. Right? It looks like, you know, there's some data from this Gaussian. And there's some data from that Gaussian on the right. Um, and is- and if only we knew. Right? Which example had come from which Gaussian, if, if we knew that these examples had come from Gaussian 1, which I want to denote with crosses. And if only we knew- no, that was here. What- but actually this is fine. I'll leave that one there. If only we knew that these examples had come from Gaussian 2 which I'm going to draw with Os, then we just fit Gaussian 1 to the crosses, fit Gaussian 2 to the Os and then we'd be pretty much done. Right? Um, oh, and, and, and sorry. And so these are the two Gaussians. And so the overall density would be something like this. Right? Tha- that's the probability. A lot of probability mass on left. A lot of probability mass on the right, low, less probability mass on the, uh, in sort of in, in the middle. Okay? So the overall density I'll just draw again, would be, low high, low high something like that. Right? Um, but the reason- and, and, and if you actually had these labels. If you knew that these examples came from Gaussian 1, those examples come from Gaussian 2, then you can actually use an algorithm very similar to GDA, Gaussian discriminant analysis to fit this model. Uh, that the problem with this density estimation problem is, you just see this data and maybe the data came from two different Gaussians. But you don't know which example actually came from which Gaussian. Okay? So the EM algorithm or the expectation-maximization algorithm will allow us to, uh, fit a model despite not knowing which Gaussian each example that come from. So let me first write down the, um, mixture of Gaussians model. Uh, and then we'll describe the EM algorithm for this. So let's imagine- let's suppose that as a, um, so the term we sometimes use is latent, but latent just means hidden or unobserved. Um, random variables z. Right? And x_i, z_i, um. Okay? So- this part here. So let's imagine that, um, there's some hidden random variable z and, and the term latent just means hidden or unobserved. Right? It means that it exists but you don't get to see the value directly. So when I say latent, it just means hidden or unobserved. So let's imagine that there's a hidden or latent random variable z and, uh, x_i and z_i have this joint distribution. And this, this, this is very, very similar to the model you saw in Gaussian discriminant analysis. But z_i is multinomial with some set of parameters Phi. For a mixture of two Gaussians, this would just be Bernoulli with two values. But if it were a mixture of k Gaussians then z, you know, can take on values from 1 through k. [NOISE] Right? Um, and it was two Gaussians it'll just be Bernoulli. And then once you know that one example comes from, uh. Gaussian number j, then x condition that z_i is equal to j. That is drawn from a Gaussian distribution with some mean and some covariance Sigma. Okay? So the two unimportant ways. This is different than GDA. Um, one, well, I've set z to be 1 of k values instead of one of two values. And GDA, Gaussian discriminant analysis. We had z, you know, uh, why the labels y took on one of two values. Uh, and then second is, I have Sigma j instead of Sigma. So by, by convention when we fit mixture of Gaussians models, we let each Gaussian have his own covariance matrix Sigma. But you can actually force it to be the same way you want. So- but these are the trivial differences. Uh, the most significant difference is that, in Gaussian discriminant analysis, we had labeled examples x_i, y_i. Where z- y was observed. Right? And then the main difference between this and Gaussian discriminant analysis is, now we have replaced that with this latent or hidden random variable z_i that you do not get to see in the training set. Okay? So now, uh, actually you guys are right. These pens are terrible. All right. Oh, that was better. Cool. All right. So if we need the z_i's. Right? Then we can use, um, maximum likelihood estimation. All right? So if only we knew the value of the z_i's, which we don't. But if only we did, then we could use maximum likelihood estimation or MLE to estimate everything. You know. So we would write the log likelihood of the parameters. Right? Equals sum, um, log p of x_i, z_i, you know, given the parameters. Right? And then you take the derivative, set the derivatives equal to 0 and then you guys did this in problem set 1. Right? And, and then you would find that Phi j is equal to 1 over m. Right? Okay. So if only you knew the values of the z_i's, uh, then you could use maximum likelihood estimates, um, will- and, and this is what you get. And this is pretty much the formulas. Actually the- the- these two are exactly the formulas, uh, we had for, uh, Gaussian discriminant analysis. Except with replace y with z. Right? And then there's some other formula for Sigma that's written in the lecture notes. But I won't, but I won't write down here. Okay? Um, but the reason we can't use this, use these formulas is we don't actually know what are the values of z. So what we will do in the EM algorithm is two steps. Um, in the first step, we will, uh, guess the value of the z's. And in the second step we will use these equations using the values of this z's we just guessed. So let me- so, so sometimes in, um, the machine learning is something that's called- there's a bootstrap procedure where you get something that runs an algorithm. You're using your guesses and then you update your guesses and then run the algorithm again. Let me, let me make that concrete by writing this down. So the EM algorithm has two steps. The E-step, um, also called the expectation step is set to w i j. So w i j, um, is going to be the probability that z_i is equal to j. Okay? Um, given all the parameters. And, and much as we did with, um, generative learning algorithms, right, with generative learning algorithms, we used Bayes' rule to estimate the probability of y given x, and so to compute this, you use a similar Bayes' rule type of calculation. And so this would be [NOISE]. Oops, right, um, where, for example this term here P of x_i given z_i equals j. This would be a Gaussian density, right? This comes from a Gaussian density with mean Mu j and covariance Sigma j, right? And so this term here would be 1 over 2 Pi, to the N over 2 Sigma j, so one-half e to the negative one-half. All right. And then this term here, I guess this would be Phi j, that's just a Bernoulli probability, remember z is multinomial. Right, so z is multinomial with parameters Phi. So I guess the parameters Phi for multinomial distributions tell you, what's the chance of z being 1, 2, 3, 4, and so on up to k, and so the chance of z_i being equal to k is just- chance of z_i being equal to j is just Phi j right? It's just v to the off one of the parameters in your multinomial probability for, um, for the odds of z being different values. okay? And so, um, and similarly the terms in the denominator. This term here is from Gaussian and that second term is from the, um, multinomial probability that you have for z. And so that's how you plug in all of these numbers and use Bayes rule and use this equation to compute given- all given the position of all these Gaussians, what is the chance of w i j taking on a certain value, okay. And, and so to make this really concrete, you remember how I guess 1 or 0s, or the other way, um, If you were to look at these, uh, if you were to scan from right to left, remember how, you know, you get a sigmoid function, or the sigmoid can be this way or this way or it depends on the sign. I guess if these are positive samples these are negatives. You have a sigmoid function like this. And so w i j is just the height of this Sigma, it's just a chance of, you know, each of these examples being, coming from either the z equals 1 or z equals 0 and then you store all of these numbers in the variables w i j. Okay. So w i j is just to compute the posterior choice of this, this example coming from the left Gaussian versus the right Gaussian. You just saw that in the variable w i j. So that's the E-step, um, and you compute the w i j for every single training example i. Right? I think it's the M-step is, um, yeah. [BACKGROUND] Sorry, is this what? [BACKGROUND] Oh this one. Yes. Sorry, yes. Thank you, there we go, thank you. Yes, there's a following Gaussian. Okay. So in the- so the E-step tells us, you know, we're trying to guess the values of the z's right, when we figure out what's the probability of z being 1, 2, 3, 4 up to k was stored here. And then in the M-step, what we're going to do is use the formulas we have for maximum likelihood estimation, and I want you to compare these with the equations I had above, right. Okay. Well, I hope you see. So these equations are a lot like the equations above, except that instead of indicator z_i equals j, we replaced it with w i j, right? Which by the way is the expected value of this indicator function. Right, because the expected value of an indicator function is just equal to the probability of that thing in the middle being true. Okay? Um, and then, and then there's a formula for Sigma j as well that you can get from the lecture notes, but i won't, I won't write down here. Okay. So, um, one intuition of, um, this mixture of Gaussians algorithm is that it's a little bit like k-means but with soft assignment. So in k-means, in the first step we would take each point and just assign it to one of the k, k cluster centroids, right? And if it was a little bit closer to the red cluster centroid than the blue cluster centroid, we would just assign it to the red cluster centroid. So even if it was just a little bit closer to one cluster centroid than another, k means we just make what's called a hard assignment meaning, you know, whatever cluster centroid it's closest to, we just assigned it 100 percent of that ce- cluster centroid. So yeah, EM is, uh, you can think, uh, EM implements a softer way of assigning points to the different cluster centroids because instead of just picking the one closest Gaussian center and assigning it there, it uses these probabilities and gives it a waiting, in terms of how much is assigned to Gaussian 1 versus Gaussian 2. Um, and the second updates, you know, the means accordingly, right? Sum over all the x_i's to the extent they're assigned to that cluster centroid divided by the number of examples assigned to that cluster centroid. Okay? So, so, so that's one intuition be- between EM and k-means, um, and in a second, uh, uh, but, but when you run this algorithm, it turns out that this algorithm will converge with some caveats I'll get to later, and this will find a pretty decent estimate, um, of the parameters, you know, of say fitting a mixture of two Gaussians model. Okay? So this is, um, the- a- and so if you are given a dataset of say airplane engines, you can run this algorithm for the mixture of two Gaussians. And then when a new airplane engine rolls off the assembly line, um, um, so, so after you're fitting the k-means algorithm, you now have a- after fitting the EM algorithm, you now have a joint density of a P of x comma z. And so the density for x is just sum of all the values of z of P of x comma z. And so, and so a mixture of Gaussians can fit distributions that look like this, it can fit distributions that look like this, right? These are, these are both mixtures of two Gaussians. So this gives you a very rich family of models to fit very complicated distributions. And now that, um, right, and you can also fit, I don't know, something like this. So this is a mixture of two Gaussians, I guess one thin narrow Gaussian here and one much wider fatter Gaussian. So a mixture of two Gaussians can actually fit a model of different things, um, uh, can fit a lot- and a mixture of more than two Gaussians can fit even richer models. And so by doing this, you can now model P of x for many complicated densities, or including this one, right, this example I had just now. This will allow you to fit a probability density function that puts a lot of probability models on, on a region that looks like this. And so when you have a new example you can evaluate P of x, and if P of x is large, then you can say nope this looks okay and the P of x is less than Epsilon. You can flag an anomaly and say take a look- take another look at this here. Okay? So, um, I kind just wrote down this algorithm, with a little bit of a hand-wavy explanation for how it's derived, right? So like I said, if only you knew the values of C and just use maximum likelihood estimation, so let's guess the values of z and plug that into the formulas of maximum likely estimation. It turns out that hand-wavy explanation works, in the particular case of, um, the EM mixtures of Gaussians but that there is a more formal way of deriving the EM algorithm that shows that this is a maximum likelihood estimation algorithm, and that they converge at at least a local optimum. Um, and in particular, there- what we'll do is show that if your goal is, um, uh given a model P of x, z parameterized by Theta, if your goal is to maximize P of x, right? Oh, excuse me. So this is what maximum likelihood is supposed to do. That EM is exactly trying to do that, okay. So, um, I'll go on in a minute to present this more general derivation, the - the form of general derivation of the EM algorithm tha- that doesn't rely on this hand-wavy argument of I guess it's easier use maximum likelihood with the guess values. So I'll do the the rigorous derivation of EM in a minute. But before I do that, let me just pause and check if there any questions. Yeah. [inaudible]. Um, yeah, uh, maybe- let's see. Maybe I'll help to not think of them as weights. Um, yeah, I think thi- this is actually the weighting you assigned to a certain Gaussian, so there's one intuition, uh, hen - hence the weights, but, um, um, let me think, what's going to explain this? So one way to think of this as wij is how much xi is assigned to, you know, to- to- to the um, uj Gaussian. So, um, wij is the strength of how strongly you want to assign that training example xi to that cluster or to that- to that particular Gaussian. Um, and so this is the number of 2, 0, and 1 right? And, uh, the strength of all the assignments, and every point is a sign with a total strength equal to 1, because all these properties must sum up to 1. And so, when I take this point and assign it, you know, 0.8 to a more close Gaussian and 0.2 to a more distant Gaussian. And this is our guess for, you know, well there's an 80% chance that it came with that Gaussian and a 20% chance it came with the second Gaussian. That makes sense? [inaudible]. Oh I see. So let's see. Um, so when you're running the EM algorithm, you never know what are the true values of z, right? You're- you're given a data set, so you're only told the x's, and as far as we know, uh, these airplane engines were generated off, you know, two different Gaussians. Maybe there are two separate assembly processes. You know, one from the, uh, uh, one from plant number one, one from plant number two, and maybe they actually operate a little bit differently, but by the time they merge onto one, um, uh, you know, by- by the time the two suppliers of aircraft engines get to you, they've been mixed together, and so you can't tell anymore which aircraft engine came from proce- plant one and which pla- aircraft engine came from plant two. Um, and they you know there are two plants, where you just see the stream of aircraft engines, you're hypothesizing that there are two types. And so in every iteration of EM, you're taking each, uh, aircraft engine and guessing, you know, for this one, I think there's 80% chance that it came from process one, and a 20% chance it came from process two, so that's the E-step. And then in the M-step, you look at all the engines that you're kind of guessing were generated by process one, and you update your Gaussian to be a better model for all of the things that were- that you kind of think were generated by process one. And if there's something that you're absolutely sure came from process one, then it has a weight of one close to one in this. Do you think that was something that, you know, there's a 10% chance it comes from process one, then that example is given a lower weight and now you update the mean for that Gaussian. That make sense? Cool. All right. So, [NOISE] 33 minutes. Yeah. Okay cool. All right. Well I still remember when, um, I was an undergrad doing a summer internship at AT&amp;T Bell Labs. Um, and then someone a few offices down had learned about EM for the mixture of Gaussians for the first time, and he was running it on his computer, and he's going around to every single office. Saying, &quot;Oh my God you've got to check this out, this is unbelievable look at what this algorithm can do for three mixes of Gaussian. &quot; So tha- that shows you, those are the type of people I hang out with [LAUGHTER]. All right. Um, so in order to derive yo - you know, so -so this is a slightly hand-wavy argument. As I uh, let's get- let's guess the values of the z's. Let's just have these weights and plug them into maximum likelihood. Um, what I would like to do is give a more rigorous de- derivation for why EM Algorithm is a reasonable algorithm, and why it's a maximum likelihood estimation algorithm and why we can expect it to converge. And it turns out that rather than just proving, you know, that this is a sound algorithm, what we'll see on Wednesday is that this view of EM, uh, allows us to derive EM in a- in a more correct way for other models as well, the mixtures of Gaussian. On, on Wednesday, we'll talk about, uh, uh a model called factor analysis, it lets you model Gaussians in extremely high dimensional spaces, where if you have 1,000 dimensional data, but only 30 examples, how do you fit a Gaussian into that? So we'll talk about that on Wednesday. And it turns out this derivation of EM we're going to go about- through now is crucial for, um, applying EM accurately in- in- in problems like that. Okay, so. Uh, in order that live up to that derivation, let me describe, um, Jensen's inequality. So let f be a, a convex function. Um, to do EM, we're actually going to need a concave function, so it'll be all minus of everything, but we'll get to that in a second. But so, a convex function means the second derivative is greater than 0, or in other words, it looks like that, right? So that's a convex function. Uh, let x be a random variable. Then f of the expected value of x is less than or equal to the expected value of x. Okay. Now, [NOISE] um, [NOISE] maybe, um, here's an example. All right. So here's the, um, let's see, there's the function f of x, and let's say that these are the values 1, 2, 3, 4, 5. And suppose that X is equal to 1 with probability one-half and is equal to 5 with probability one-half, right? Just for the illustration. Then here is f of 1. Here is f of 5. Um, here is f of 3. And f of 3 is f of the expected value of X, right, because so the expected value of X. And sometimes I write this without the square brackets, right. It's the average of X is equal to 3. Um, and so the expected value, excuse me, f of the expected value of X is equal to this value, whereas the expected value of f of x is the mean of f of 1 and f of 5. All right. So the expected value of f of x. F of x is a 50% chance of being f of 1, and a 50% chance of being f of 5. And so the expected value of f of x is equal to this value in the middle. It's really take these two, right. Take this value and this value and take their mean. So is this value up here, and, and this value is the expected value of f of x. Okay. And so in this example the expected value of f of x is greater than f of the expected value of X, right, as, as predicted by Jensen's inequality. Um, I'm gonna just draw one illustration that may or may not help, and some of my friends like it, I sometimes use it but if it's confusing then don't worry about it. But it turns out that if you draw a line that connects these two, then the midpoint of this line, um, is the height of f of expected value of x, right, so the height of this. You know, so, so given these two points, this point and this point, if you draw this line, it's called a chord, um, then the height of this point is the expected value of f of x. And this point is, um, f of the expected value of x. Right. And in any convex function, you know, really take any convex function. That's also convex function. If you draw any chord, that green point is always higher, right, than that green point which is why- which is another way of seeing why Jensen's inequality holds true. Okay. If this visualization doesn't help don't worry about it but it's just a- actually what a lot of my friends do is we keep on forgetting which direction Jensen's inequality goes. [LAUGHTER] Why are we not using Jensen [LAUGHTER] that's not great. So a lot of my friends don't remember, we draw this picture and draw that chord, and we quickly figure out which way the inequality goes. Um, all right. So one addendum further. If f is strictly greater than 0. And so if this is the case, we say f is strictly convex. Then- Okay. So, um, let's see, a straight line is also a convex function, right. So this is a convex function, this is a convex function and this is a convex function. It turns out a straight line, that's also a convex function. But so in this addendum is saying that if f is a strictly convex function meaning basically it's now a straight line, right. And a bit modern, it's not a straight line. But if the curvature if it's always bending up, uh, then the only way for the left and right-hand sides to be equal is if x is a constant, meaning it's a random variable that always takes on the same value. Okay. So Jensen's inequality says that, you know, um, left-hand side is going to be the same as right hand side. Sorry, I think I reversed the order of these two for that equation that doesn't have it. But so Jensen equality says left-hand side is always less than or equal to the right-hand side, and the only way it's equal as if X, you know, is a random variable that always takes on the same value. Okay, yeah. What if- What if the value of f of 1 was equal to the value of f of 3. Wouldn't that? Yeah. So it turns out what if value f of 1 is equal to the value of f of 3. It turns out, it does. Vary. So let's see. So one way that [NOISE] could happen would be if the function were like that. And then if you take the- draw the chord, take the mean it's still higher. [inaudible] The point of f of 1. [inaudible] Then it's important. If, if you kind of flat that part here, then the function is not strictly convex. And so it's still less than equal to but it's not, but they can't be equal to if x is random. Okay. So and we'll use this in a little bit. We'll actually end up using this. Um, and again for the strict probabilistic, you know, if those of you that, I don't know, take classes in advanced probability, the technical way of saying x is a constant is x is equal to EX with probability 1. You know, I, I think that for all practical human purposes you do not need to worry about this. But I think if you [LAUGHTER] take a class in measure theory. The Professor in measure theory will be happy if you say this and you say x is a constant but maybe, maybe none of you. Okay. Just don't worry about it. Um, oh yes. Okay. Now, um, just one more addendum, um, to this is that the form of Jensen's inequality we are going to use is actually a form for a concave function. So instead of convex, um, I'm gonna say concave. And so, you know, a concave function is just a negative of a convex function, right. If you take a convex function and take the negative of that, it becomes concave. And so the whole thing works with the- with everything flipped around the other way. Okay. And yep, so this is strictly concave. Okay. So the form of Jensen's inequality we are gonna use is actually the, um, concave form of Jensen's inequality, and we're actually going to apply it to the log function. So the log function, right. Log x looks like this. And so that's a concave function. And so the inequality we'll use would be in this direction that I have in orange. All right. So here's the density estimation problem. Meaning, density estimation means you want to estimate P of x. All right. So we have a model for P of x, z, with parameters theta. And so, you know, instead of writing out mu, sigma- mu, sigma, and phi, like we did for the mixture of Gaussians. I'm just gonna capture all the parameters you have. Whatever your parameters are, I'm just gonna capture them in one variable theta. And you only observe x. So your training set looks like that. So the, um, log likelihood of the parameters theta is equal to some of your training examples log P of x_i, parameterized by theta. Um, and this in turn is log of sum over z, P of x_i, z_i parameterized by theta, right. Because P of x, you know, is just taking the joint distribution and summing out, marginalizing out z_i. Okay. [NOISE] And so what we want is maximum likelihood estimation which is define the value of theta that maximizes this log-likelihood. And what we would like to do is derive an EM, derive an algorithm which will turn out to be an EM algorithm as an iterative algorithm for finding the maximum likelihood estimates of the parameters theta. [NOISE] So, um, let me draw a picture of that, I'd like you to keep in mind as we go through the math, which is, you know, the, the horizontal axis is the space of possible values of the parameters Theta. And so there's some function O of Theta that you try to maximize. This right. And so what EM does is, um, let's say you initialize Theta as some value, you know, maybe randomly initialize, um, sim- similar to the k-means cluster centroids. Where just randomly initialize your mu's with a mixture of Gaussian's. What the EM algorithm does is in the E-step, we're going to construct a lower bound shown in green here for the log-likelihood. And this lower bound, this green curve has two properties. One is that it is a lower bound. So everywhere you look, you know, over all values of Theta, the green curve lies below the blue curve. So this is a lower bound. And the second property that the green curve has is that it is equal to the blue curve at the current value of Theta. Okay. So what the E-step does, uh, which you'll see later on, and just keep this picture in mind as we go through the E-step and the M-step is, um, construct the lower bound that looks like this, right. Oh, and, and also, uh, to, uh, to foreshadow probably the derivation. Right? There- there was an addendum to Jensen's inequality where we said, well, under these conditions it holds with equality. Right. E of f of x equals f of e of x. We said, &quot;Well, the two things are equal with under certain conditions.&quot; Um, we want things to be equal. We want the green curve to be equal to the blue curve at the old value of Theta. So we- we'll use that addendum to Jensen's inequality when we drive that. Um, so this E-step is draw the green curve. And then what the M-step does is it takes a green curve, and then it finds the maximum. Actually, certainly stroke [inaudible] so I'll draw in green. What the M-step does is it takes the green curve, and it finds the maximum. And one step of EM will then move Theta from this green value to this red value. Okay. So the E-step constructs the green curve, and the M-step, uh, finds the maximum of the green curve. And this is one iteration of EM. The second iteration of EM, now that you're at this red thing is will construct a new lower bound, and then again, you use a different lower bound. Everywhere the red curve is below the blue curve, and the values are equal at this new value. That's the E-step, and then M-step will maximize this red curve, um, and so on. Now you're here. Construct another thing, do that. Right. And you can kinda tell that as you keep running EM, this is constantly trying to increase L of Theta. Trying to increase the log-likelihood, until it converges to a local optimum. Okay. Um, the EM algorithm does converge only to local optimum. So if, you know, there was another even bigger thing there that it may never find its way over to that other- that, uh, better optimum. But the EM algorithm by repeatedly doing this, will hopefully converge to a pretty good local optimum. Okay. All right. So let's write on how we do that. Um, let me think. Actually, let me use the other board. No, I think this is okay. All right. So I've already said that our goal is to find the parameters theta that maximize this. [NOISE] All right. Uh, and so that equation we said are just now is sum over i log, sum over zi, p of xi comma zi given Theta. Okay. So this is just what we had written down, I guess, uh, on the left. What I'm going to do next is, um, divide by- [NOISE] multiply and divide by this. Okay. Um, where Qi of zi is a probability distribution, i.e., the sum over zi, Qi of zi equals 1. Okay. So I'm going to multiply and divide by some probability distribution, and we'll, we'll decide later how to come up with this probability distribution Qi, right. But, you know, I'm allowed to construct a probability distribution and multiply and divide by the same thing. Right. Now, if you look at this, all right, let's put square brackets here. If this Qi, that is the probability distribution meaning that sum over zi Qi, zi sums over- sums to 1. Then this thing inside is, um, equal to sum over i log of an expected value of zi drawn from the Qi distribution of [NOISE] right, actually, if I, let me use colors to make this clearer. Right. So the way you compute the expected value of z-, you know, some function of zi is you sum over all the possible values of zi of the probability of zi times whatever that function is. So this equation is just the expected value with respect to zi drawn from that Qi distribution of that thing in the square brackets, in the purple square brackets. Now, using the, um, concave form of Jensen's inequality, we have that this is greater than or equal to [NOISE]. So this is a form of Jensen's inequality where, um, f of E, x is greater than or equal to E of f of x, where here, um, this is the logarithmic function. Right. So the log function is a concave function. It looks like that. And so, um, using the, I guess here using, using the form Jensen's inequality with the signs reversed, um. Right, f of Ex is greater than equals E of fx. So you get log of expectation is greater than equal to expectation of the log, all right. And then finally, let me just take this expectation and unpack it one more time. So this is now sum over i, sum over zi. [NOISE]. Okay. So I just took this expected value and turned it back into the sum of the random variable probability, times that thing. Okay. So, um, if you remember this picture from the middle, what we wanted to do was to construct a function, construct this green curve. There's a lower bound for the blue curve. And if you view this formula here as a function of Theta right, so your x, um, x is just your data, and z is a variable you sum over. So this whole thing is the function of Theta, right? Because x's are fixed, z is just something you f- sum over. So this whole formula here, this is a function of the parameters Theta. And what we've shown is that this thing, you know, this formula here, this is a lower bound for the log-likelihood, uh, for- for, for, for this thing. I guess this is L of Theta. So- go ahead. [inaudible]. Oh, how I got to this equation? Uh, sure. Um, let me think. So let's see. What's a good way to do this? Um, uh, yeah. Let's say that z takes on values from 1 through 5, right. Let's say z takes on values from 1 through 10. So you roll a 10 sided dice. And I want to compute, um, you know, the expected value of, uh, some function of, of some function g, g of z. Right. Then the expected value of g of z is sum of all the possible values of z of the probability that you get that z, times g of z. Right. So that's, that's what's the expected value is of a function of a random variable. And, and this is- and the expected value of z is sum over z, P of z times z. That's the average of random variable. And so, um, in the notation that we have, the probability of z taking on different values is denoted by Qi of z, which is why we wind up with that formula. Does that makes sense? Does it? Okay. Is that okay? Does that make sense? Yeah. All right. If, if one of these steps doesn't make sense, let me know. Th- other questions? Okay. All right. Hope that makes sense. [NOISE]. Um. [NOISE] Now, one of the things we want when constructing this green lower bound is we want that green lower bound to be equal to the blue function at this point, right? And this is actually how you guarantee that when you optimize the green function. By improving on the green function, you're improving on the blue function. So we want this lower bound to be tight. Right, the, the two functions be equal, tangent to each other. So in other words we want this inequality to hold with equality. So we want, um, yeah, so we want the left hand side and the right hand side to be equal for the current value of Theta, right? [NOISE] So on a given iteration of EM where the current parameters are equal to Theta, we want, we want- I know this was a lot of math but, you know, we want the left and right hand sides to be equal to each other. Right. Because that's what it means for, uh, for the lower bound to be tight, for the green color to be exactly touching the blue curve as we construct that lower bound. And so for this to be true, we need the random variable inside to be a constant. So we need P of x_i, z_i, divided by Qi of z_i to be equal to const- to, to a constant. Meaning that no matter what value of z_i you plug in, this should evaluate to the same value. In other words, the ratio between the numerator and denominator must be the same. Um, unfortunately so far, we have not yet specified, how we choose this distribution for z_i, right. So, so far the only constraint we have is that Qi has to be a probability density- has to be a probability distribution over z_i, but you could choose one of the distributions you want for z_i. And it turns out that, um, uh, we can set Qi of z_i to be proportional to p of x_i, z_i parameterized by Theta. And this means that for any value of z, you know, so z_indicates as it could from Gaussian one and Gaussian two. Right. So this means that the chance of Gaussian one is proportional to the chance of Gaussian one versus Gaussian two. Whether z_i takes on one or two is proportional to this. And I don't want to prove it but one way to ensure this, and this is proven in the lecture notes. But it turns out that one way to ensure. Um, well so the Qis need to sum to 1. So one way to ensure that this is proportional to the right-hand side is to just take the right-hand side. Sorry. Let me move here. So one- so let's see. Right. So the Qis have to sum to 1. And so one way to ensure the proportionality is to just take the right-hand side, and normalize it to sum to 1. Um, and after, after a couple of steps that are in the lecture notes but I don't want to do here, you can show that this results in sending Qi of z_i to be equal to that, that posterior probability, okay? And so, um, sorry I skipped a couple steps here. You can get from the lecture notes, but it turns out that if you want this to be a constant meaning whether you plugged in z_i equals 1 or z_i equals 2 or whatever, these evaluate to the same constant. The only way to do that is make sure the numerator and denominator are proportional to each other. And because Qi of z_i is a density that must sum to 1. One way to make sure they're proportional is to just set this to be with the right-hand side but normalize the sum to 1. Okay. And we derived this a little bit more carefully in the lecture notes. So just to summarize, this gives us the EM algorithm. Let's take all of this- everything we just did and wrap in the EM algorithm. In the E-step, we're going to set Qi of z_i equal to that. And previously this was the w_i_js. Right. So instead of- so previously, we're restoring these probabilities in the variables you call w_i_js. And then in the M-step, we're going to take that lower bound that we constructed, which is this function, and maximize it with respect to Theta. Okay. Um, and so remember in the M-step we constructed this thing on the right-hand side as a lower bound for the log-likelihood. And so for the fixed value of Q, you can maximize this with respect to Theta and that updates the Theta, you know, maximizing the green lower boundary, that's what the M-step does. And if you iterate these two steps, then you find that this should converge to a local optima. Okay. Oh and just maybe that's the obvious question. Um, why don't we try to maximize right Theta, uh, why are we trying to maximize the log-likelihood directly? It turns out that if you take the mixture of Gaussians model, try to take derivatives of this and set derivatives equal to 0, there's no known way to solve for the value of Theta that maximizes the log-likelihood. But you find that for the mixture of Gaussians model and for many models including factor analysis that we talked about on Wednesday, if you actually plug in the Gaussian density- uh, if you actually plug in that mixture of Gaussians model for P, um, and take, you know, take, take derivatives, set derivatives equal to 0 and solve, you will be able to find an analytic solution to maximize this M step, and that'll be exactly what we had worked out in the early derivation of the EM algorithm. Okay. But so this derivation shows that, uh, the EM algorithm, you know, is a maximum likelihood estimation algorithm with optimization solved by constructing lower bounds and optimizing lower bounds, okay? All right. Um, that's it for today, and only it's stuff up to here, right, and so this stuff will be up to the midterm but we'll talk about factor analysis a lot on Wednesday, but it will not be on the midterm. Okay. So let's break for today, and I'll see you guys on Wednesday.