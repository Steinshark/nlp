- [Nicole] Our first project is to build a simple and it'll live at /light. - [Mike] Yeah. It starts off with a brightness of 10% and we can adjust the brightness back down a little bit - It's basically a glorified counter, of LiveView, so to speak. So let's go build this. We've opened the live_view_studio directory, And let's start by defining the route And we do that in the router And we're looking for this scope right here, standard browser pipeline. And there's a typical route to the Phoenix homepage. And then we added routes for these other LiveViews - At this point, we just want to add a new live route - To do that, we use the live macro and give it the and then give it the LiveView module, So requests for /light will get Save the router, and then we'll go define that module. And by convention, LiveView modules live in the - And we see these other LiveView module files in here - We'll create a new file named light_live.ex and then And because I'm using the ElixirLS extension in it figures out the module name based on the file name. So it's LiveViewStudioWeb.LightLive. And it's just a regular Elixir module. And to pull in all this stuff to make this a LiveView the live_view behavior. - And a LiveView module typically has three primary So let's start with the mount callback since it's the It's automatically called when the request comes in And it's here that we assign the initial state of the - And mount takes three arguments. The first one is params. It's a map containing the query parameters as well as And we don't need those for this LiveView, And then the second argument is session and it's a map LiveView, so we'll ignore it as well. Finally, the third argument is the LiveView socket. It's a struct, and we do need this one because the state is stored. And to assign state to the socket, as the first argument, - Well, let's say we want the light to initially be set - Sure. So the key will be brightness and the value will be 10. And the assigned function returns a new socket struct So let's go ahead and assign that socket equals - Now don't worry, we'll look at - And then mount must return a tuple with two elements, Now you'll often see this inlined. If we were just to take this, And because assign returns a socket, well, But we'll go back to the two-line version for now and - Okay. So now we need And we do that by defining a render function. - And render takes a single argument, assigns, assigned to the socket in mount. And render needs to return a And we create that template - Hello template. - And start it with &quot;&quot;&quot; and it also ends with &quot;&quot;&quot;. - And this ~H sigil creates what's called an which is static HTML plus embedded Elixir or EEx tags. So let's start with some static HTML. Let's have an h1 with the heading Front Porch Light and And inside that div, And then inside of that, we'll have a span. And the app already includes CSS So, in this span, we want to render the brightness - Right. And it's in this assigns map that's passed to render. And we can interpolate the brightness value using an to get that value And then we want a % on the end of this since we Or since we're in a template, an @ sign. So we can remove assigns. So now, in the browser, if we go to /light, So when our app receives an HTTP request matching this module is invoked. It assigns the Live View's initial state, then render is called to render HTML, to the socket. And one cool thing about the HEEx templating engine is - Yeah, like, what if we forget the last div? - Well, we get this compile-time error in the browser: I love this. - Now if you're wondering, file rather than directly in the render function. - But unless it's a really unruly template, where it's easy to reconcile with the code. And I have a pretty high tolerance for templates in my between two files. - Blah. Now, later in this course, along with some other important Now we've said this socket here is just a struct, - Well, let's take a closer look by inspecting it and initial brightness IO.inspect(socket). Save that. And now if we hop back into the browser, So now if we take a peek at the server log, an assigns field whose value is a map So, in this case, the map has a brightness key with a LiveView assigns by default. And notice in this __changed__ map, So calling the assign function as we did in mount in this socket struct. Then when render's invoked, can access the LiveView's current state. Okay, so let's remove this IO.inspect. - So let's take the next step. If the brightness is 10%, To do that, we need to style this span so it has a - Sure, we'll just add a style attribute with a width, of brightness right here. And you might think we could just use the same EEx tag Oh, and we want this to be a percent, But inside an HTML tag like this, HEEx templates are validated and this isn't valid HTML. Instead, within HTML tags like this, so a curly here and a curly there. And then rather than using these And by using these curlies, It's a string and we want to interpolate the value of So it's just # another curly there and one there. So this whole thing is an Elixir expression that interpolated into that string. - So the rule is EEx tags can only be used Inside the tag itself, curlies must be used. And now our light meter lights up. Nice. So now let's make this more One to turn the light on and one to turn it off. - Sure. We'll put those We'll have a button and it'll have an image. And this one's going to be images/light-off.svg&quot;. We've got some SVG files in the priv/static/images And then we'll just copy this button. And this one's going to have the light-on.svg. Save it. Browser reloads and we've got our two buttons. - Now, when one of these buttons is clicked, And we do that by sending it an event. - So starting with the off button here, and its value is the name of the event to send. And because we're just wildly creative, And LiveView refers to this phx-click attribute and as a binding. It binds a click event to the button. So when it's clicked, an off event will to the LiveView process. And similarly, the on button should send So we'll just add a phx-click div, - And then to handle those inbound events, - And we'll do that down here beneath render. Give ourselves plenty of space. handle_event. And it takes three arguments. The first is the name of the event. We want to handle the &quot;on&quot; event with this one. So we'll pattern-match it. The second is any event-related payload, so we're just going to ignore that second argument. And then the third argument is the socket, which, process assigned to it. - Okay. Well, we want to set the brightness value to 100. - Right. So we just use the assign function again this time to And it returns a new socket. So we'll assign it to the variable socket. And then handle_event needs to return a tuple with the - And whenever a LiveView state changes, newly-updated state. So now over in the browser, if we turn the light on, - Cool. So now to handle the &quot;off&quot; event, We'll pattern match the name of the event, Save it. Browser reloads. We can turn it on and turn it off again. - And we've got some CSS animations behind the scenes So now that we've got the hang of this, the lights up and down. And we'll learn something new along the way. - We'll start by copying this off button here And we'll have this one send a down event. And we've got a down.svg. And then we'll copy that button, paste it below, And we've got an up.svg. And then we need to handle these two inbound events. So down here we're just going to copy - And, in this case, we want to bump button is clicked. So to do that, we need to access - We can access that using socket.assigns, And from there we can get access to the value of the Then we just bump up the value by 10. Then we just need to assign the new value So, instead of 100, this will be brightness. And doing it this way will work but there's a shortcut. When updating a value, than the assign function. An update takes the socket and then the key, So we'll pass it the atom :brightness, which is a function. And we'll pass it an anonymous function using And this function receives the current key's value, So that's &amp;1, which represents the And then we just need to return the updated value. So we'll bump that value by 10, + 10. So this updates the brightness value in the socket It's an anonymous function that takes the current value and returns that new value. And by updating that value in the socket, So now if we hit this up - Then we need an event handler to dim the lights and - Sure thing. - We'll change the event to down and then it just needs So now we should be able to crank up the brightness. There we go. And dial it back down a little bit. Perfect. - So stepping back and looking at what we've done, by assigning values to the socket. Render returns a HEEx template, And we have handle_event callbacks They change the state of the LiveView And whenever the state changes render's automatically - So it's a pretty simple programming model and we're but there's more going on behind And next up, we'll look at the life cycle