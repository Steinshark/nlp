Hi and My name is Max, and in this course I'll And React Native is an amazing library on the React library, mobile And therefore, I'd suggest let's not waste And let's start What exactly is React - [Maximilian] So, what Well, as the name applies, And with React.js and React Native, you can build real React for iOS and Android, which are real apps you can distribute through the app stores by any user with an iOS or Android device. Now React.js is a library from React Native though. React.js is a JavaScript library for building user interfaces. And it is typically used That's also the environment But actually, if you worked with React.js, you might know that there, the React DOM library that because React itself, without React DOM is platform-agnostic, which means you can use React in conjunction with React but React the library itself, about the underlying platform. React just gives you for building virtual component trees, and then you need an extra for translating the result React produced to an actual platform like the browser. Now, React Native is basically an alternative to React DOM, therefore. React Native gives you a collection of special react components, which you can use in your JSX code. So React Native ships with And those components are then for the iOS and Android platforms, and React Native will also take care about this compilation step. In addition, React Native also exposes certain native platform APIs like using the device camera so that you can use such even though you need to tap into native device APIs for that. And therefore in the end, It just does not target the but instead iOS and Android. And React Native gives you all the components and the with those platforms and to That is what React Native is all about. And therefore, in order you also must know React.js because you will write and then just use these and APIs in your React JavaScript code to produce those native mobile apps for iOS and Android. - [Maximilian] Now, how Under The Hood though? If you're building a React then you are typically which should look very familiar, if you worked with React.js before maybe, or most likely for building browser based apps. This is a React Component what you see here. And it's just one way of writing such a Component. We could also use the of defining an arrow function. And we could also use a But it's code like this, which you will write for React Native and it's code like this that will be compiled So which will be bundled into a Real Native App in the end. Now, if you take a closer look at the code snippet on the left here, you will see two Components two JSX elements in there, which you don't know from web development, the View and the Text element. These are some of these special Components that are exposed by React Native, which will be compiled by React Native. It is worth noting though, that it's really just the Views. Just this JSX code that is compiled not the JavaScript logic itself. I will come back to that in a second. So the Components, the JSX elements you use are compiled to native elements for And to make this a bit take a look at this comparison table here, here we got a bunch of elements, as we would use them in the browser if we would be using react-dom and then the equivalence for the native platforms, and then the Components exposed by React Native to So for example if you want to display an input element where users can enter some text, then when building a web app we would use the HTML input element which is available in JSX when we're using react-dom. If we would be building with Java or Kotlin then it would be the that is provided by Android, which we need to build. For iOS it would be the UITextField element and with React Native we would use the built which is provided by React Native and which will then be for Android or to UITextField for iOS. So React Native maps and like TextInput or View or many other Components about which you will learn to their respective platform equivalents. That's one of the main jobs React Native will take care of. But what about the logic? I mentioned that those Views the JSX elements are compiled to their native equivalence. But what about the JavaScript code you write outside of JSX? What about all these functions? If statements? State management? What about that? Well, unlike the UI elements, the logic is not compiled. The UI elements which are those Components exposed by React Native are compiled as you learned, but the logic which you write in JavaScript is actually not compiled but instead it's running that's hosted by React Native in the native app that was built. So React Native basically spins up a simple JavaScript process as part of your native app that's being built. And it manages this process for you. And it allows this process to talk to the underlying native platform and therefore your JavaScript code will run as JavaScript in the native app that's being built but it will then talk to or iOS platform, through a basic translation bridge. You could say that is provided by React Native as part of your native app. That's how you can think about this. And that is it for now. That's how React Native works Under The Hood and what it does for you. You don't need to know more. You can of course dive into the official docs if you do want to learn more but that is what you should know in order to work with React Native, because I believe it's always important to have a basic understanding And this is how React Native works. - [Maximilian] So I would say it's enough for the theory for now. Let's get started. And for that, you can simply to find React Native dot dev, which is the official Now on this site, you can learn more about React Native and it is a great additional resource if you do wanna dive deeper but of course you will and everything you need to know in this course. Now in here, on this side, it is a good idea to click because there you'll learn how you can create a React Native project. And what you will learn here, is that if you do click on on setting up the development environment, that you got two choices. That you can use a tool called Expo CLI, which seems to be recommended because it's the by And that you can use the React Native CLI. Now, as I just said, Expo and indeed it is my recommendation as well and it is the tool we But you could also use Both approaches will give in which you can build React Native apps. So what's the difference then? Then we have the Expo CLI CLI stands for command line interface and both tools are tools that exist in order to help you create and run React Native apps on as well as build React Native apps so that you can ship So these are the tools you and to get those packages, which you can upload to the app stores. These two tools are crucial, but you don't need to use them both. You can use either of the But why do we have these two tools? And what's the difference? Well, the Expo CLI, or just Expo as I will also and the company behind this CLI is in the end a third party A service that is entirely free. You don't have to sign up, You can sign up and you can pay, they do offer extra paid services but to build React Native you don't need to pay. When using Expo, the CLI, and a couple of other free you get a managed app as I like to call it, which means creating projects is easy, writing code is a bit easier, tapping into Native like using the device and in general, when using Expo, the Expo CLI and also provided by Expo, writing Native apps with React Native is more convenient than with and without Expo. There is less friction to this process. And the best thing is that you can still and ecosystem anytime, if you need to. If you start by using Expo because it's easier to and then at a later point you find out that you wanna switch to just using the React and not using Expo. You can do this anytime. That's why it's also the default selection to start with Expo, because it's easier and you can still switch Now, why do we have the Well, because it existed because this is the tool and the community around React Native. It gives you a barebone React Which means you will need and setup work on your own. There are less convenience features, and if you need to tap into like using the camera or other features, then it is often a bit more work when not having Expo around Expo is not just about the it will also give you that you can use when writing code, that will make your life Now, what the pure React Native is that it is often a with Native source code. So with source code written in Java, or Objective-C, or SWIFT or Kotlin. So if you must mix JavaScript code and Native device source code, then using just their React But the idea behind React Native is that you don't have and therefore this might And for all these reasons, and especially since you can we will use Expo in this course. As you will see it's super and it will make building - [Maximilian] Therefore, back here on the official React Native website, we will stick to this Expo and we need to run this command in order to install the Expo CLI, which is the tool that will then allow us to create Expo-based Now, we do install this tool with NPM, which is the Node Package Manager, and therefore, you need Now, we don't need to install Node.js because we will write any Node.js code, but simply because we need and also because Node will be used by some packages under the hood. Hence, you should visit nodejs.org and make sure that you download which in my case is version 16, but simply download whatever when you are viewing this. I will download this and simply And there is an installer and also for Linux, so you on whatever device you are on. And once you do have Node.js installed, you are ready to run this command in your terminal or command prompt. Here I'm in my terminal, and in there, I'll just paste in this command, and I'm on macOS where I must add a sudo in front of this command You might not need to do this, you definitely don't need because this is not a Windows command. On Windows, you just execute but on macOS and Linux, especially if you are getting some permissions error otherwise. With that, I will install this by also entering my password here and this will now download and install this Expo CLI tool globally, that's what -g does, on my system here. I will be back once this finished. Here it finished for me. You can ignore any warnings It did finish successfully if you can run the Expo command thereafter and you don't get an error Now this, by the way, you can then execute with Expo. There are a lot. And the official Expo documentation is the place to go if you You do find that but we don't need to take a closer look at those commands right now because there's only one and that is expo init, which But since I'm already on as always, you might in addition to this course, simply because in there you the philosophy behind Expo, how you could switch to a though we will take a look at this later in the course, as This is a great backup resource Now, here we did now install Expo. Now we can create a new For this, I switched to another the folder where I wanna I switched to it here in the which you can also use on to switch folders and pops. And then, in the place where I wanna create I will run expo init, and then I'll name my This will be the name of the and the default name of the in that project folder. If we now hit enter, we where we can choose which kind The options and the text Right now, I can choose a blank project, a blank project with TypeScript support, a project that already has which we will take a look or a bare workflow project, which is actually a project But again, we will take a look Right now, we wanna have such where we fully embrace Expo and I don't wanna use TypeScript, I also don't wanna use We will add it later. Hence, I'll just use blank here. And this will now create a new blank Expo React Native project in a folder named RNCourse since that is the name I chose here. Now, this did now create and it shows us some commands to start the Expo Development Server, which will basically watch our code and create a development app bundle whenever we change the code. And we can then also run on iOS and Android, and even for the web, though that's not the If you wanna build React web apps, then my React Complete Here we'll focus on Android and IOS. Nonetheless, I'll not execute Instead, I wanna open so that we can see what was - So we created this before we run it now, I wanna open the created project in an editor that allows in a convenient way. Now you can use any code editor you want, My recommendation is Visuals Studio Code, which is an amazing free code editor, That's very extensible and fun to use. You can download it for all platforms. And I already do have Now with vscode installed, you can open it and you If you installed it for the first time, you can simply close that screen. And then you should see where you can open a new folder. Alternatively, you can and find open on Windows, or open folder on Mac OS still. And then if you click that, it will open such a file picker, where you can now select that project folder you just created. So here I'm selecting this RNCOURSE folder which I created before, and So here I got this expo and you can of course the way vscode looks, however you want. by going to view appearance, you can hide or show the sidebar, the and you can also go to preferences and then choose a color theme, that suits your needs. I'm using the dark plus theme here. so you can configure this but what was created for us here? Well, we see actually not too much. We got two folders, expo-shared and vscode which we can ignore, vscode just holds some settings i configured for this workspace here, And expo-shared simply just holds some internally used information. The assets folder will because we can store images there. For example, the icon of our app but also images which And we got the node modules folder which holds all the third party packages that are used under the hood. We got a package, Json file which lists all the dependencies of our project here. And here For example, we see expo because expo is not just It's all so a JavaScript and which we will use heavily as you see because it gives us many that make writing But you also see we're using react, react-dom, react-native, though again, that's not You could build web apps with react-native but support is a bit clunky. And yeah, we're simply not focusing on that because you could If you want to do that React-dom of course because of react-native web. So that's what we have here. We also got a couple of script commands which we could execute with NPM but overall there's nothing fancy in here. And you know, these kinds of files if you worked with react before, which you should have because this course assumes that you have react and So that's the package, Json file . Package-lock is related to that. And the babbleconfigjs how code is trans piled under the hood, and unless you know what you're doing you also shouldn't change Now we do have the app Json file, which will become important later because here we can and behaviors of our react-native app. And this is a file that When our app is built for preview or for the actual app stores. We can set the name here. We can set some background colors here and we will come back to this file occasionally So this is a file, which we And then we got App js. This is the only real code file we have in this starter project. The exact content could change over time to make sure that we're I attached my App js file to this lecture so that you can download it so that you have the Because we'll build up on this This in here is a regular react component which uses special components special js x elements, That's what I mentioned before. And then we got some styling but I'll come back to how styling works in react-native apps later. So for the moment, this is our app code, and now it would be nice For this, we need some device - [Maximilian] So we got We created this project with Expo. Now it would be nice to preview whilst we're working on we want to constantly preview it so that we can see our changes and tweak the app as required. It would basically be nice to or a comparable workflow as we have it with the when we're building React Web apps. There, we can also create a React project and preview it in the browser. Now thankfully, since we're using Expo, previewing our app on a You just need an Android In my case, I have an iPhone here, but the same is true for Android, and you visit the app store there. And in the app store, Now, you should find a Expo Go app. This is an app provided by the and this Expo package, which So you can now download This app is available for the iPhone and for Android devices. And once downloaded, you can open it. Now in here, you can that are built on your local computer. To do that, you should or command prompt. Here, I'm using the one You can open this by and opening a new terminal. And this is the default system into your VS Code. And then in here you can run npm-start. Now, what this will do, is it will actually start which watches and builds our code and which builds our code, basically such that we can preview it. And it also gives us a QR code here. You can scan this QR code not on iOS. I'll come back to this in a second, but on Android, you will a button that allows in your Expo Go app which you downloaded. In addition, you also that opened up where you and where you will find log as your app is running. Now on the iPhone, the into the Expo app. Instead, there you need and then scan this barcode here And then once you tap to open the link that is sent by that barcode, which opens the Expo Go app. Then you should grant any permissions the app might be asking for. And now you see here that is being built. So the Expo app is being built. The React Native app and it opens up in this simulator So in this Expo Go app here. We can close this info screen. And now here, we see our on our local machine Now we can tell that this is If I remove all the text &quot;Hello, World,&quot; good old and I then save this file, you will see that it on your phone as well in this Expo Go app which we use for previewing. And this is how simple it is to build and test those Expo with the Expo Go app and to use this Expo workflow. It simply makes building and testing React Native apps much easier. And this still is a React Native app here. We're just using Expo to - [Maximilian] So, this is with Expo and React Native. You can easily create an app and with help of the Expo Go App, you can easily preview it. And you might not need more for now. You can now follow along and preview your app But maybe you don't want Maybe you also have an iPhone and you wanna also but you don't have an Android device. For those reasons, you might want to install a simulator which is an extra piece on your local machine that or an Android device. Now, for this, you can to download Android of software that allows you on your local machine. On developer.android.com/studio. You will find a download to download Android studio And this can be downloaded Now the download can take a while but make sure you do download to be able to run emulators Now for iOS, it's different. There you must open and search for Xcode and which is Apple's developer environment for building iOS apps. Unfortunately, this is not available for Windows or Linux devices. So if you are on a Windows you can't run iOS This is a limitation applied by Apple. So unfortunately on Windows or Linux you can only build and test for Android. Actually, you will be able to through some Cloud build service about which I'll talk a little bit later but when it comes to if you don't own a real iPhone on which you can use the Expo go app or a Mac Os device on you have to focus on Android instead. It is what it is. Now, once you did install Android studio, you can open it and you that looks something like some more actions button. And in there you will find You can use this manager so to build emulators. So here I already have an emulator but you can click on create And here you can select from like the pixel five, for example, here. Click next, then choose an Android version that will run on this emulator. And here I'll choose the API 32 version which is the latest version keep all the default settings And now this will create And then you can click the play button to launch this emulator. And this will now launch So on your Windows or I'll just increase it a little bit here. So that's now an Android phone so to say running on our computer. Of course just a dummy phone, an emulator, but a real phone when it Now I will show you how to run this app on this emulator in just a second. First, I wanna show you how it would work for Xcode and Mac OS. Which as mentioned only works on Mac OS. Here in Xcode you wanna open this as well. You don't have to open a project. You just need to open Xcode, and then you should go In the preferences make and here under command line tools make sure you have a By default no version is selected and you should do that Once this is done, you can close it. And then we can go back here Now I used the terminal to And this process is still running. You should by the way as long as you are working on your code. If you quit this process, your Preview builds are not built anymore and they are not pushed to your connected real You can always quit this and you can then restart it But as long as your writing code you should keep it running. Now in there, we have this QR code which we could scan to use the but we can also press or I to run it on iOS and it will pick those running simulators or Nonetheless it doesn't hurt to already start an Android simulator as I did it here so And now this is opening this on Android. So this app is now built and previewed on this Android emulator. Now, in case you're getting an error like this that is most likely related to the emulator you created. You might wanna create a new emulator and make sure that you create one or that you pick a template Because Expo needs to be able So the play store must be part of the emulator in order to which is used for previewing So use an emulator then still the latest and create this emulator So now I'm launching a new emulator based on this new template here. And once this finish starting, we can again restart NPM-Start maybe, and then press A again it will be found automatically by Expo and then it will install this Expo go app onto this emulator and We get this info screen, We get this debug screen here which we can use to reload or turn on certain debugging tools. But I will we'll come We can close this for So that's Android. Now for iOS development you should go to your applications and locate Xcode and show the package contents off that. Because in there in contents, you will find this simulator app. And you can double click on Now, in this case, it's You can change this by to the menu and then you can choose all kinds of devices. But I'll go with iPhone 13 here, and we can all increase this in size to make that a bit easier to view. And now we can press I here. You don't even need to restart NPM start. You can serve the preview on So I just served it on Android. Now I will press I to also which also should be And now Expo will also on that simulator and open this app in that Expo go app on our simulator. So here it's opening up and it only takes that long initially when this is all first of course, after a short while we will see our app preview on this device as well. Here we go, it's loading up now and now we see Hello World here as well. So now we can preview on a real device as I of minutes ago, and on And this process here and running as long as your writing code. So we'll just make it smaller. And now we can change our code add a couple of exclamation marks. And if we save this file, this is automatically on those apps without us doing anything. You can still manually reload in this running terminal here this will then manually reload those apps. And that's the development environment we will use for this course. This is now what we need to And this course here. - [Tutor] So let's dive into React Native and let's of course start with the basics. In this course section, we are going to explore the This means that we'll dive into the core React Native Components, and we will start building user interfaces with those Components, but we will of course also dive into styling React Native apps. We will learn how we can style those apps and those Components, such that we can really we wanna build. And last but definitely not least, we will explore how we can and how we can manage state, how we can make sure that there, for example are buttons and that something meaningful happens when a button is clicked. Now for this, in this course section, we are going to build this demo app here. It's a first simple React Native app which allows you to track your goals. For example, your goals for this course, what you wanna achieve or as you are taking this course. In this app, we got a list of goals and we can open a model and overly to add new goals. And once a goal was added, we can also tap the This is maybe not the but it's a great first app to learn about many core about React Native. - [Instructor] So, let's For this, I'm back in this project we created in the first course section. In case you did not create it there or you did remove it thereafter, just make sure you got the development environment and then you can download the attached starting project. Once you did that, you as I have it here. Just make sure that you open your terminal or command prompt. Here, I'm using the one and that you install all the dependencies this project needs, by And once that completed, to this Expo process that watches the code and serves it on our emulators. I'll then press a and i to start and run this app on my running Android and iPhone emulators and simulators. Here you go. These are my two preview devices. Now, and actually as we on which we worked in the and what we have in here in the end is a React component, a And indeed, in this course, we will only work with and React hooks. We will not use class based components. So this is a regular functional component. We also got this Styles constant, this SyleSheet object down there. And I will come back to At the top of this file, and we're importing one component from an Expo related package. And the other components, as well as this SyleSheet object here, from React Native. And Text and View are two of those built in components, actually two of the most important built in components, React Native exposes to you, to use in your JSX code. Because in here, you or anything like this. These are HTML elements, when you have a DOM to work with, but they won't work because Native devices are not browsers. They don't have that DOM, and they don't support Keep this slide from the that is how React Native into different Native elements for Android and iOS. And that's why these by React Native. Now, if you visit the then there, you will find various guides which you can definitely take a look at but you will also find the components tab where you get a list of the components provided by React Native. And as you can tell, we actually don't have because it turns out that with a couple of core components, you can build any kind of user interface. For example, we got a Button here and Image and Text and View. And especially View are super important components which you will use all the time. And as you will learn from this course, you can build very complex user interfaces with those core components Now, React Native is all about working with those core components You build your overall app UI and your custom components that might make up that UI, by simply combining those core components. Because these core are translated into Native UI widgets, Native UI elements for Android and iOS by a React Native. That's why we work with that are provided by React Native. And we can combine them in our React Code, in our JSX code, to and ultimately our own user interface. So in the end, we just by combining those core opponents. And if you think about it, that's the same for React for the web. HTML happens to have more elements. There are h1, h2 elements, there are many HTML elements. But in the end, you also just combine those HTML elements to build It's the same here for Native apps. So that's what we do Of course, another important aspect of building user interfaces in general is that you wanna style those apps. And when using React You can't write CSS code, because again, it's not a browser, so the CSS language doesn't exist here. Instead, you can, of but you do this either in line, essentially by using props on those core components that are provided or with help of these SyleSheet objects or this SyleSheet object which you already saw in the code before. You therefore. write your And hence, you have no It's all JavaScript, but gives you a lot of JavaScript properties which you can set and pass which are similar to the CSS properties. But it's only a subset of the overall CSS But in the end, as you will learn throughout this Course, you get all the important CSS properties and features that you need to build powerful and But back here in our component code, we can see how these core components that are provided by React Native are combined to build a new component, in this case, the only and how we then get which is used to set various styles which if you take a look look similar to what you know from CSS. And then actually this to this View component But we will take a closer look at styling and at building our own throughout the next minutes Now, just one final note At the moment, this is And indeed the app has a special purpose. This is the root component that is rendered in your app. Expo will automatically export it in this app JS file, and render this as the root component. So, any other user interface must go into this app component or into children or descendants But again, that is also in greater details soon. - [Maximilian] So let's into core components like Text and View. And for this I'll actually and also this import. If I save that, this is and not much change here, so I also will delete this Text so that for now we have a blank screen. And now let's try re &quot;Hello World&quot; between the View, without the surrounding text. If we do that, we notice that We get an error that &quot;Text strengths must be rendered which is actually a quite which tells us in a pretty And before we fix this, let's also take a look at those devices, those simulators, and here we also get And this is actually something important which is why I'm showing this. It's different than what you might know from web development. If you would build a web app, and this would be react for the web and this would maybe be then this kind of code would be fine. We could put text inside of a div there. React Native and native are stricter than that. You can't put a Text into a View which is pretty much because it's not meant for that. Instead Views, so the of Views are meant to generally build boxes and containers that hold other content. A View could hold some text It could also hold a TextInput or a button or an image, or anything like this, but you have to put the content into an element that And the View is only able It's not able to display text, and that is something really If you wanna display a text, for example, you have to use this Text component and wrap the text opening and And if you do this and and works again, but that's even though we can kind of And even though it looks kind of similar, there are important differences. Now, what you will often do is you will build more that don't just have one And what's important to understand then is that those different core components have different roles. The Text is a component Displaying text. The View is a component and lay out other components. Now, we will learn more with help of styling but the idea behind the you typically have multiple For example, another text, &quot;Another piece of text&quot;. In a Text component, as you learned, but now we got two of them. And we grouped them together in a View just as we might group if this would be for the web. Now, in the web, we also have or article, here in React Native world, it's just the View. This is our container component that we use for holding our components. And of course, those other We could have another View which actually holds this inner text. So this is all something something you will typically more complex user interfaces The View then makes it into which we'll dive where which of its child Of course, we don't just have If you take a look at the official React you'll learn that there are more React Native core components and those components We got View and Text, which and commonly used components, but we also could display a something will do later as well, or add a TextInput which allows We could also add a button, and indeed, that is what I'll do here. Below this text, I'll add a button, but for this, we need to import it. And that is also important and an important difference With react for the web, the HTL elements you might be using, with React Native, you do. If you wanna display a button, you have to import this core and then you can add your button. And number important difference you don't build a button like this by adding the caption between Instead, it's a self-closing element where you add a title prop, and then you add your title here. This would now display a button as well with the kind of default styling and tap effects you would expect for the different platforms. And you see that the look adjusts to the underlying platform. It looks like an iOS button on iOS, and like an Android button on Android. But of course the button because I have added any listener. Now, we will add interactivity, and learn how that works later. For the moment, let's and let's understand that we always work with core components like this where every component has and you build your overall UI But of course a UI is not just it's also about styling them, and that's therefore - [Instructor] So let's dive into styling. And here you learned before that there is no CSS so we don't add CSS files or use the CSS language in general, but you learned that we have by either adding styles in line, by passing a style object to props or by defining a separate object which is then also passed through props. Now we do define our but the JavaScript properties we can set are inspired by the CSS language though it's only a and features supported by CSS and not all the names are exactly But let's now see how For that, we can use the style prop, which is not supported on all elements, but on some elements, but also on the text. For example, here on we can add the style prop. And then as a value, you can And in this object you can set all the supported style properties which properties are supported. And these are the to the CSS properties, For example, here on this And as you see, as I start typing, we get this nice auto We get this automatically which kind of properties that is passed to the style prop. Now, here we could add a margin either in one specific direction by combining multiple properties or in all directions by setting margin. Now different style properties need different kinds of values. And you will see many examples and learn which kind of value throughout this course. Margin, for example, and this number will then which are automatically adjusted to the device pixel density. For example, here we could enter 16 to have a margin of 16 pixels. If we save this, we got Now it's not super good to see because we don't know exactly To make this a bit more Now in Vanilla CSS, like this for example. This would add a red around an element in Vanilla CSS. But if I type this kind of code and saved this here in React Native, we actually got no effect here, and I got a error here in the terminal and a warning here on my simulator. We can click on this to get more details and we see that this is an Actually the key border So it's not even the value but border is not a supported key. The reason for this is simply that this border property doesn't exist. I mentioned that the styling and close to CSS, but Instead, as we type border, we see that various properties For example, we can set and this again wants a number to set a certain border width in or two or whatever you want. And then we can also set a bordered color. Now this does not want a and in this string, you Or you provide one of like red or blue or And here I will go for red. And this will now add a two around this text. Now I'll press the auto format shortcut to make this a bit easier And with this, we now got The border is pretty close to the text but thankfully we can padding just as in the browser, is the spacing inside of an element. So here we could add a 16 pixels, just as for the margin. And if we save this and auto format again to improve readability, now Now definitely feel with those style properties. And of course also take a to learn more about but you will see plenty throughout the course. These style properties the element itself that holds We will later also learn that help us with laying and with achieving a certain overall look. But again, that is something For the moment, I wanna leave this in-line This approach of defining as we define this component. Because whilst this is it's rarely the best So typically we should go The reason for this, is that this allows us to clearly separate our JSX code and our styling code and it also makes our styles reusable. If we define styles in line and I want the same styling on this text, I have to copy and paste this, so that I can add my style prop here and add the same styling, and I'll auto format this So now I had to copy and And that is typically What you should instead do is create a new style sheet object. Or if you already have you go to this object and We already have the container property, now on the same level, I'm The name is up to you and Again, this is totally up to you. What's not up to you is what The value should be an object, as we see it here for a container. And then in this object, you So here I could now set So I can set margin 16, border I'll set this to red. And I will all set my padding I just group margin and since they're both about spacing, but we could also add padding here, and it wouldn't matter. Of course I could have my object from up here. Now with such a style we can use it here in our JSX code as this container is being used. It is defined down here, in JSX because this only gets executed after the entire code file So here we can now replace this object by referring to styles.dummytext and I get nice auto And I'll do this here as well. And now, yes, we had to but of course it's way less to copy. And if we ever adjust the style, for example we changed the color to blue, we don't have to do this in two places because the name didn't change, we just had to do it in one place instead. So if I save this, we And that's how we use Now, why is it a style sheet object? So an object created with which is a built-in method which is imported from React Native. Well, we could have also created a styles object like this, but using such a style sheet that we get convenient auto completion as we type our style properties here. And that makes our In addition, React Native style sheet creation and and pick up style sheet objects like this. This is not done right now though, so for the moment, the main But with that, we now learn and some important basics I would say, as a next step, we should take a closer and positioning multiple elements because typically you don't just want a couple of centered Typically you are going and we need to know how we can create such layouts therefore. - [Maximilian] So let's real layouts where we centered texts and buttons. And for this, I will actually and I will remove this style prop here on the outer view for the moment and remove all the styling but I will keep the style sheet object. And now here in my view, I actually wanna add a neverview and below that a neverview. Now I'm doing this because I wanna start building that allows us to manage goals. And the first view, the first nested view here I should say, should actually hold the input area where users can enter and click a button to add that goal. And the second view should that are rendered. And I'm using two views as rappers to have a clear separation and because data will So for this, I'll then therefore start by adding a text input component This is a component that and like all components, we need to import it from react-native. Now text input is a And here we can, for example, as you could add it to a and say, your course goal. Then, next to it I want to add a button with the title of add goal. And then here in this view, where I say, list of goals and later this will become a real list. Now, if we save all of that, we see that everything is We also see that it goes and there would be different For the moment, I'll fix it by giving this outer view a style prop and defining a style, which And in there I'll add a padding And then here we can refer to add to this padding to Now, if you save this, we can see that there's Again, later, we will of making sure that we don't interfere with those native status bars and so on. Now, still, this is not the layout I want. For example, I want the button not beneath it. I also want to have more space and maybe this area where we add a goal should take up a quarter and the list should take up the rest. And that's where we need Styling properties about which Specifically, we need flex box. - [Instructor] When it in React Native apps, And you might know Flexbox And then the next lecture, into Flexbox and how to use it. But Flexbox is a key which is basically a that you use to control And the Flexbox implemented which can be set with all is very similar to what In the end Flexbox is all about or a couple of styling that are about positioning You can control how much space and if they are to the left or right, or bottom or top of other elements. And the positioning is then controlled with the style settings that that holds other elements, Now Flexbox is all about Q-axis which you have on a container. For example, the styles which flex one, flex-direction: would be applied to the container that holds the three boxes inside of it. Now the flex one instruction would tell the container to occupy all available space, this is seen in relation that might also take up space. And then flex-direction are laid out in a column or in a row as you see it here. So that all works. Basically, flex-direction as it's called, is top to With column, it's top to bottom, with row, it's left to right. And then you also got other or align items that allow you to control how the elements are So if there is some space between them, if there are crunched together and so on. - [Teacher] So back in our code, this means that we can which is the container to control how these two because you learned flex box is a concept that is applied to container elements to control how much space That's something we'll do in a second. And then how the elements inside of the container are positioned. That is what we'll do right now. For this, I'll add a in my style sheet object, and I will name it Input Container. Now on this element, we can and then we can apply this to this view. So here we add the style prop, and then refer to styles If we save that, you will see the button is So this already utilizes flex box is enabled on all those views. You can start using those The default setting was that which is why the elements But if we switched to row, as I just did, they sit next to each which hopefully makes sense. Now we might want to control and for this, we can add another property and that is the justify content property. You will learn more about in depth in the next lecture, but justify content basically controls how these elements are depending on what the value So here, for example, space between is one and as you set this to space between, you see there now is more Now we can also still control For example, here, we could in our style sheet object, and I will add this to And here I then wanna add a and a border color of CCCCCC, By the way, I get a color picker here because of an extra You don't need that though. And now, in addition, I will give this text input And this is all the new. Now in most places where you so as numbers, you can also though you need to wrap that in quotes so you set a string in the end. But then you add the percentage sign and your percentage number And with this, I'm saying which has this style, to take up 80% off the available width. The available width will in which the element sits, but then the element will take 80% of that container's width. So therefore, now I want to on this text input element, and we do this by adding the style prop and then its styles, text input. If we do this and save that, now we got this border, and Maybe we also want a little so that there is some spacing here. There is no spacing right now, because this takes 80% of the width and the button automatically And therefore to add some spacing here, we'll add a margin to the of, let's say, eight pixels. With that, there is some spacing again. We could also add a little so that the text isn't So, therefore, I'll also on the text input object. So with that, we get some padding as well. Now that's it for this basic This is an not all we'll do. This is not the finished layout. I do see that the on the right and the left. I do see that the button here on Android. And we will work on this, but first let's dive a little and the different things we can do with it before we then continue - [Maximilian] In this lecture, I wanna dive a bit deeper into how you use it in React Native apps. If you know all about that already, you can of course skip this lecture. So for this, I prepared a and of course, you find data attached. It's a normal React Native And in the App.js file here, what I have in the end, is in there where each view then has a text with text one, two, three. This simply creates some boxes with different colors, And now we'll use Flexbox so that you can get a feeling because it's so important. Now, first things first, by default, every view in React Native, even if you assign no And that's different to There, if you have a div, to a view kind of, it doesn't use Flexbox by default. In React Native, it does. Every view by default with the help of this Flexbox thing. Flexbox simply is, is a term, It's simply a concept from CSS that is all about in a one dimensional space. So here, for example, in a column. That's also in every default, not only does every view it also by default organizes so from top to bottom. That's all the difference to the web and I don't wanna emphasize because of course you don't to build React Native apps. But I think a lot of people do know a CSS Flexbox, and to all the talk about the differences. So in the web, when you use Flexbox not only is it not turned on by default, in addition if you do turn it on, the default is to organize And here, the default is to You can change that default though. So in this case, on the by adding flexDirection here, and setting this to row, for example. Now, you will see that these in a row from left to right. Now besides row and column, you also have row reverse And this simply also, well now we still have a row, but the first element, the red and not on the left anymore. So that's also something you can do. Let me go back to row view. So that's the first thing you can do. Another important thing about Flexbox is how child elements are sized. Here, I gave every child element a width and a height of 100. Now, if we would remove on every child element, then you will see that now we have a very, because every box now is only as wide as its child requires it to be. And only as tall as its So every box here which holds a number is only as wide and tall as Now, you can change that with the surrounding Flexbox container 2. Let's give that width or of 80% of the parent width. So in this case, since it's the root element and let's give it a If we do that, and now really important, I'm doing this on the view, I'm not doing it on the boxes themselves. So if we assign this width and height on the surrounding box, you The height is assumed Now, all the views in the Flexbox take the The width has no impact here. That's also a default obviously since we The default behavior here indeed, in a Flexbox, so in this outer view here, are organized such that along the cross axis by stretching. Okay, that were a lot of terms, what does this mean? Now, when working with Flexbox, we have two important axis. The main axis depends For row, which we have the main axis is from left to right. For a row reverse, it For column, it would be top to bottom and for column reverse it So that's the main axis. And then you also have a cross axis and that's simply the So for a row where the main the cross axis would If the main axis is from right to left which would be the case for row reverse then the cross axis would Okay, so that's the main Now, you can organize your child elements. So in this view where as child elements, you can organize these child You use justifyContent along the main axis. And you have alignItems around the cross axis. Now you see the values you If you add these quotes or if you place your cursor in there and you hit control+space. You see you can center at the end or at the or you can add some space in between. For example, if we use space between here and we use alignItems center, Now, you will see they're taking the width of the surrounding container, every box itself still is pretty small but they're split or they're distributed across the width of the parent container. And they're no longer taking the height because along the cross axis, we're aligning them with align items. And there I set this to center. The default here is stretch. And if I set it back to stretch, then unsurprisingly they do Now, if you want to make sure that they take the available width, you can set stretch which is your main axis So you can set stretch here. So what can you do regarding that then? Well, that is something you now configure on every child item itself. You can tell a child item off the space it's potentially getting. Stretch here is kind of a special case, there you set this up on the parent item. Normally, you set this So for example, if I so that the parent doesn't tell the child how much space it should take. then we can fully control by going to the child style. And there you can add The flex property is applied to items that are inside of a Flexbox, so that are inside of a And that can be a view itself but that could also be another component like a text, for example. So now here you can add flex and you can set this to a So flex needs to be a number. If you set this to one, what you will see is that where I did set flex to one, takes all the available width it can get just so much that it leaves enough space for the blue and the green container so that they can squeeze their content into the surrounding Flexbox. Now, we can't see the boundaries of the surrounding container but the boundaries would the red item starts and the green item ends on So now flex 1 makes sure that the red item gets So it takes as much space as it can get. but default views only take as much space as their child elements require. So as this one character required, but with flex one you change this and they now take as much So along the width here, as they can get. For the cross axis, again, You have to do this on the parent. For the main axis, and the main axis is a horizontal you do this with the Now, of course you can add flex to other child elements as well. Like to the second, to the blue container, with the two in there. You can add flex 1 there as well. So now I have flex 1 on the red container and flex 1 on the blue container. And what now happens is that both of them take the available free space, the space is distributed evenly. And that's what this This number is a relative number. All items in the same Flexbox with the flex property by considering the number you assign here. And these numbers are so if I give the blue then this means that of the in that surrounding container. After deducting the space, every element needs to The blue container will as this one, because here we have flex 1, here we have flex 2. If we had flex 3 here, then this would take three fifths of the available free space, because we have three plus two, so we have five available And here the red container blue container would take two segments. If we have one and two, then we have three available segments, and the blue container takes two of them, red takes one. So you always add up these flex numbers and then distribute or that's but then the available space So now here we'll see that the blue container is or it takes twice as much So this is how you can work with flex. You can organize how items are positioned with flex-direction, with justify content and with align items. And you can also make your items grow and shrink the help of flex. So now that's our brief in React Native. As I said, inspired by Flexbox for CSS. So if you knew that, all of what I explained here We'll work with Flexbox so there're things also and we'll work a lot with it. And you'll see you how user interfaces with Flexbox. Flexbox in the end is the tool in React Native to structure your content on a page, to organize your content. And you would typically which you also nest into each other so that you can position Because of course, and you don't just have to which uses Flexbox. You could have another view in there which also uses Flexbox. And actually, as I mentioned every view by default uses Flexbox and you can then nest so that you position And you'll also see this And actually I'm already which are in the surrounding view. So my boxes here, there and alignItems to center So that one, two and horizontally and vertically. And that works because on by default and we can't And therefore, I just use to align my content of this view along the main and the cross axis. And here, since I have set for this view, the main because the default and the cross axis is left to right. That's just a side note. - [Instructor] So now after our newly gained knowledge to One thing I will do for example, is work on this app container padding. This actually doesn't use but I need to do this to make I basically just want to have and then I wanna have so left and right of 16. So not of 50 but of 16. With that I'd say, this though we can see that this and our button here is This can be fixed by our text input has to 70% maybe. Now this looks better. What doesn't look better in this button. This is something we can on the input container though. At the moment, the problem is stretched to be as And the text is then not because the button doesn't have any styles that would center the text. Now you could think that to the button but it is a component that It might look like it some auto completion here auto completion I get here before in this code file. The proper auto completion that is supported looks like next to it. So the button doesn't have a style prop because indeed it doesn't support styling. You can always check out the an element there to see And for example, on the Whereas on the view, for example, But that's just a side note, differently and we can fix it That would be one way of achieving this. So we can set a line items and set this to center instead of stretch. With that, the button is now We could also build our own button but that is something So now this looks better. I also wanna change how much though and how much space To achieve this, I'll For example, I wanna add on this input container of let's say 24. so that there is some space the text input and the button the list of goals later. You can see that spacing here now. We also could add a little border here, so we could add a border to the bottom and give it a width by setting And then adding a border to the of let's say, maybe this gray again. But of course you can Now we got this border and But now I want to make sure takes up one fourth, so 1/4 of And this can be done as you learned. We can set this to one and to this view that holds the list of goals that takes up three quarters which can be achieved by So therefore I'll add in my style sheet here and And here I'll set flex three. As you learned, all the flex as long as the containers are siblings to each other and are part of the same surrounding parent for these two views and then the space is So one plus three is four one fourth and this will We just have to add this here, to this view and set this equal With that, it will look horrible. And the reason for this is on the outer container now. The container that holds on which we just set the flex properties. This outer container needs of the app so that the inner containers can then distribute this space. By default, without the flex property, this container will only take and that's only defined by the space the content in the container takes up. But now that we're setting in the container, this And to fix this, we need to all the available height and flex one to the app container takes all the height because So flex one will give it all the space and then the inner containers can divide that available space. So by adding flex one to the this now looks better. And now this is a quarter and Now if I look at it like this, this still doesn't look perfect is actually give that list here so that goals container will get four and the input container stays at one. And instead of setting a padding bottom, I will set a margin bottom And with that, that looks better. We could maybe even go and leave it like this. Feel free to experiment with this and choose your own values. But this will work for me and to achieve a first basic layout. Of course, this is not the final - [Instructor] So we did add some styling and a basic layout. This is nice, but of course, not all we wanna do. In most apps, no matter if we're talking about web apps or native mobile apps, we also want to allow the And we got a text input here and we also got a button but at the moment, of course, nothing happens if you type here or if you press this button, this is ignored. And this is ignored because we're not handling these events. And just as with a web app that you, of course, need to handle them if you want something to happen. The good news is that you do you would do it in web apps though. You can add event listeners and connect them to and you can manage with the useState Hook, just as you would do it Because this is just a React app, the only difference, as you learned in the first course section, compared to a React app is that we use a different platform with React Native instead of React DOM. But when it comes to React's core features like handling events or managing state, that all works in exactly the same way as you know it from React for the web. And here I got two events The first one would be but before we handle that I also wanna handle keystrokes so that I can grab the and so that we can then use this value to finally add a new goal in this list of goals as a next step. And therefore, these are the first two things I wanna do. I will add a function that could be called goalInputHandler that is responsible for as the user types. Then I'll another function addGoalHandler which should be fired when Now to connect those functions, we use special event listening props that are provided by React For example, to connect goalInputHandler to TextInput, we can add the special onChangeText prop. This is a prop exposed by React Native which wants a function as a value, a pointer at a function. In my case, I'll point at this So I'll pass that as a value here and I'll press the auto format shortcut to make this a bit easier to read. Now, please note that I don't I don't add parentheses. If you would add parentheses this function would be executed as soon as this code is And this would be too soon, because that would be the case when this user interface is rendered. I don't wanna do that. Instead, I wanna point at this function so that React can execute it for me whenever this text changes in this input and that's what will happen if we set it up like this. Now in this goalInputHandler we then receive the because keep in mind, it will be React that calls this function because it's React Native And therefore, React, or to be precise React Native, will also provide us a value as a input as a parameter to this function and that will be the enteredText. So we get the enteredText automatically. And then we could, for example, console.log this here. Like this. If we save this code and we have the npm-start we can go back here. And for example, enter Test. And as I type this here, you see the log update here in my terminal with every keystroke until So that's how this works and this works totally on its own. So that's how we can Of course, we don't want to get the value because we need it in Instead, we need it in this function. So we need it when the button is clicked. And for this, we need to connect this function to a button click as a first step. Now, if you would be building a web app and you had a HTML button here, you would add the onClick prop but with React Native, this prop doesn't exist on a button. But we have a similar prop, it's called onPress. It's called onPress instead of onClick because technically we don't have clicks in native mobile apps. Instead, we have taps or presses. So here we have onPress. And just as with onChangeText, here I point at my function In this case, addGoalHandler. So now this function will be triggered whenever the button is clicked or tapped. Now we want the value entered in this TextInput in this function. So what we need to do is we need to store it as state. We need to store it as state which is updated with every so that we can then use it in this second function. And state management works just as it works in any other React app. We can import the So not from React Native, but from React: the core React library itself. And then we can register a new state here in our App component function just as we do it in any other React app. So here I'll call useState and set this to an empty string initially, because this will be my user input state or my enteredGoalText state, which can be updated with the And then in case this syntax definitely have a look at like my React complete guide course because this is standard React and you should know syntax like this. So now we got this enteredGoalText state, which initially is an empty string, but with every keystroke in my TextInput, I will update it and set my enteredGoalText to the enteredText I'm And therefore, now, in addGoalHandler, we can access this state and do something with it. And for the moment, I will simply console.log my But of course, soon, we will update a list of goals which we then output down there. So let's save this. And now here, if I enter Test and click Add Goal, we got this Test log here. Or if we enter Some other text! to see that this is really Now we see Some other text!, here. So this is working as intended. The next step now is to make sure that we which we then can also output. - [Maximilian] So let's now For this I will again add some state here because my list of goals is also some data that changes dynamically and as it changes, the And that's a typical case for using state. And this state will be because I wanna manage a list of goals and initially I have no goal. Now I'll give this state because these are my goals And to set course goals, And now in add goal handler, instead of logging our we can call set course And in the end I wanna and append a new one. Now, there are various ways of doing that. One way would be to create a new array and use the spread which is standard JavaScript code, modern JavaScript code, to spread existing course so that I keep all the And then I add my new goal, by adding the entered goal text, let's say, as a new goal. In this case, a goal is simply a string. We could do this, but if you like my course or the that this is not the best if your new state depends Which this state here does. If your new state depends a better way of updating is to pass a function to a function which will be Q then derive the new state. And this function will automatically receive the existing state by React. So here we could turn this that gets the current course So as a parameter. And again, the value for this parameter will be provided automatically by React when it calls this updating function or this function that's passed to be precise. And now this value, current core goals, can be used inside this And now we do derive this The other approach would've worked as well but this is a recommended way, a best practice way of So now we're updating based on the old course goals The next step of course is to now output the list of goals here. And how does this work? Well, it works basically as it does in React for the web as well. We have an array of values and in React for the web we typically, to map our array of into an array of JSX elements in the JSX code returned And we can do the same thing here. Instead of outputting this I want to output something dynamic, which we do by adding curly We can now refer to and call the map method on it. A standard JavaScript method because we are writing As you learned. Now, this map method receives and here I'll pass in an arrow function, which as an argument, as a parameter, gets the individual values so my goals here, the single goals I have this function is called for So every function called And then as a return value we returned a JSX element that should be rendered And in this case, I wanna So here I will render a text JSX element, and then between the I output goal. Since my goals are just because I just add my entered goal text, which is just the text that was provided, and therefore just a string, I can simply output the goal because goal will just be a string. And with that, if we save this and we give this a try here. Learn React Native. If I click add goal, this is added but we also get a warning here. The same will be true on the iPhone here. If I learn React Native, it works. If I learn it with I still see that it works. I add another goal now as expected but we get a warning here. We get a warning that each child in a list should have a unique key prop. And this is actually a from React for the web as well, because this is a warning that has nothing to do with React Native. Instead with React in general, when outputting a list of every item in that list which uniquely identifies Under the hood this helps React update the list in an I do explain this in greater but you should always add this key prop to the individual items that you're outputting as part of a list. Now, the value you pass but it should be something unique that uniquely identifies that you're outputting here. In this case, I'm just outputting goals, which are just strings, so I'll take the goal string itself. This is actually not necessarily unique because I could enter the but it's good enough for Now with this key prop added here though. Now, if I add another goal, I And of course here, we don't have to enter the We can also learn like learn all the details, and as you see, our list So with that, we're now able store it and React to And then we do something many times with React for the web. We're outputting that data here in a list, but that's of course - [Maximilian] Outputting as we're doing it here is nice but it would also be on those list items. And therefore, that's of course feel free to and practice this on your own. Apply some styling, any to these individual list items, and then compare your solution to mine to see how I style this. Now, here's what I will do. I will create a new object that keeps or that holds the styles And I'll name it, goal item. The name is up to you though, here in this style sheet which defines the styles for any styles you want, and a little bit of margin, for example so that we have some spacing I also wanna add a border radius here so that we have rounded corners and this also wants a value, And here I'll set this to six pixels. Now to make sure that I will give this a background color so that this item has an of a specific hex code that which is five E zero A C C, I also wanna have some padding in here so I'll actually add it next to the margin not because it's required but to keep those related values together. And I'll add a padding of, So that we have some And last but not least, I and I'll set this to white and So again, you see the property to what you know from CSS. We of course have this camel because dashes are not but besides that, the Now we can assign this goal item style to our text items here. So here we can add the style prop and set this equal to styles.goalItem. And I'll reformat this to With that, if we save this, this updates and we see our items here. What you will see is that but actually on iOS, the We only have them on Android. Now, why are they missing here? And what can we do to fix This is a good time to talk about the differences The idea behind React Native with React that will actually for multiple target platforms. So you don't need to write different code to target different platforms, but one of the same code Now this is generally true, but as you will also sometimes there are differences and sometimes you need to to target all platforms in the right way. And for example, here, The rounded corners are missing on iOS because we added our styling here that applies the rounded corners directly on this text component. Now it turns out that this text component is to a fitting native widget, And the element to which it is translated in case of Android seems to be an element where corners can be rounded. But in case of iOS, it looks like the underlying does not support rounded corners. And that's why border radius has no effect on the text elements on iOS. Now to work around that, we can wrap our text here in a view. So in this more generic container element, this is also translated to a And it turns out that to which view is compiled by that supports surrounded How do I know that? From the official docs and experience and I'm explaining it so that you don't have to So what we can do now is we can grab our style assignment here and add this on this view and also add the key here on this view, because now the view is the main element that's output here in the list. The text now is a nested element. We still need the text because we still have some text to output. And as you learned before, but the styling is now applied to the more versatile view element. If we do that and we save everything we now see the rounded What we also see though is that the text is no longer white. Now we still have the but this is part of the is actually assigned to this and unlike in CSS for the That's another important learning here. We do have this CSS like if you wanna call it like that, these CSS like property It never was. So therefore core CSS characteristics like the cascading nature and descendant elements, and ancestor elements is not part of React Native's styling approach. We don't have style inheritance here. So if we assign a text color to the view, this does not affect this text or the text inside this because that's a totally It is not related to this view. It does not inherit any So setting the text color to the text inside that text element. Therefore, what we need to do is add another style object here, the goal text, that sounds And we set our text color on that and remove it from goal item on the view. We could leave it there, but it doesn't have any effect, anyways. With that, we now set our text color here and now we can add this goal So we add the style prop and set this equal to styles.goalText. And with this, if we save this now, we now have the white text back and we have the rounded corners. And this is really important. This is something you must understand about styling and about The general idea is that that targets both platforms but still there are And some differences can by adding an extra wrapper. Later in the course, you will also learn to write totally different and you will learn how that works as well. And you also learned that styling is a bit It looks like CSS, at least a bit but there is no inheritance That's why you really on the elements where of some global parent element, just as the rounded corners the text color applied to this to the internal text here. We need to set that on the And these are these tiny and over again throughout this course and which are super important with React Native. But with this, we now and hence, we can now move into how we can and should - [Maximilian] So we got our list here. Now, one thing you will is that if I add more and more items here and I just add exclamation at some point we will go Now you would expect that but it turns out you can't scroll. No matter how you try, Because by default the this view that holds is not scrollable. That's also a difference On a website, if you by default scrolling bars will appear, and you can scroll the website. This is not the case here in mobile apps. If you want to scroll, you have to explicitly tell React Native and the native platforms. Now, of course, this is a common problem and, therefore, making lists, or content in general, There is a dedicated component that helps you. And that's the ScrollView. We import ScrollView as we imported text And ScrollView does what the name implies, It gives you a view so which will be scrollable. And therefore we can around our goals here. So let's try replacing this view here with our ScrollView, simply. We add ScrollView here instead of view around our list of goals. And I leave my style on this ScrollView. Keep in mind this style here controls that this container If we save this, this This now is indeed scrollable, as you see, but the space is different we have way more space for the input and way less space for the list. The reason for that is that of making something that's scrollable is in the the container that holds the ScrollView. So what you should do here which restricts the available height, to which you then apply the style that sets the height that So that is the setup we have a ScrollView inside of that view. So the outer view, controls of the screen should take up. And the inner ScrollView space, and the items in will be scrollable inside That's how we set up such a ScrollView, and how we let it interact If we set it up like this we get the same proportions as before, but now, indeed, as you see, And that's, of course, what we want, because now we have a list where we can add more and more items and it stays scrollable as we Of course, if I force a reload, by pressing R here in the terminal. And I then go back, all the data is lost, and now you see, nothing If I add a single goal here, we do see, though, that this is indeed scrollable, but of course it's not really scrollable, It always jumps back to the top because we don't exceed the available height. So, ScrollView is super useful to make lists, or content Now you can learn more about ScrollView and the props it supports I wanna draw your attention because there is a lot you can configure, about the ScrollView. You can, for example, and you'll also see that some And others specific to Android, whilst yet others are And again, these are some of which we will encounter here and then throughout this course. For example, you will notice that in our app here, I can scroll and I have this bouncing effect. If I would want to disable this, I could set always bounce vertical, which is true by default, to false. So if I go to ScrollView, and I set always bounce vertical to false, and I then save this, you if I now try to scroll, this bouncing effect, which Now, if I add more and that I exceed the available it still is scrollable, and now it also bounces, if there was not enough content the available height here. If you do want to set this or which look and feel you be aware of the vast configuration And therefore taking a and understanding what you can set and how you can use something I would encourage you to do because every app you're and every app needs slightly And therefore the official docs are always a great place where you can find all kinds of supported configuration settings. - [Maximilian] So we got and this is implemented Now, this solution has one downside, one disadvantage though. ScrollView is great, if you wanna add scrolling For example, if you had an article, which would be too long to fit on a screen or you simply don't know which device sizes your and you wanna make sure is scrollable. In such situations, ScrollView is perfect. For lists as we have it here, The reason for that is, that lists like this Sure, you might only have And especially for such a goal list, it's very likely that or around that amount of items. But you could also have lists with hundreds or thousands of items. Now, what ScrollView does is, it always renders all the whenever the overall UI is rendered. So even if an item is not like this last list item here, this item is still even though it's not visible yet. Because ScrollView renders no matter if we're talking And for very long list, this If you have a long list with dozens or hundreds rendering them all at the beginning even though vast majority is will slow down the app. And of course, that's Therefore ScrollView is great like an article which has But for dynamic lists, which We typical don't wanna use ScrollView. We can, but we typically don't want to, to avoid possible performance issues. A better solution for such scenarios is another built-in component the FlatList component, this is another component But as the name suggests, it's specifically built And internally, it will that are actually visible. And all the items that are off screen will only be loaded and rendered lazily as they are needed because Now, internally, FlatList to make sure it already starts before they are visible. But it will only render them as he or she is scrolling the list. If you have 1000 items in your list the vast majority of and will not be rendered So how do we with FlatList then? Well, you do use it by So we replace ScrollView with FlatList. Now, regarding this this is still supported. So you can leave it there because pretty much all of the Because internally it kind of but with this optimization of only loading data when it's needed. So this is a first step, We replace ScrollView with FlatList. The next step is that mapping code here, we remove that, we no longer map our data manually. Instead, we now have to so that it can render by only rendering what's needed. FlatList is now in charge of this hence we need to let FlatList do that. And this is done by giving The first one is the data This is a prop that points at the data that should be output in this list. In our example here, that That's the data that so we pass this as a value to data. But that doesn't tell FlatList how the data should be rendered. You don't tell FlatList by between the opening and closing text, that's not how we use FlatList. Instead, we should cut this and we can turn FlatList into And we add another key prop now, and that's another required This is a prop that wants a function that will tell FlatList how to render the individual data items. Therefore it is a function that will receive the individual item as a parameter, automatically. FlatList will pass in this item whenever it calls this function, and it will call this function whenever it determines that because the user is scrolling and a new item should be made visible. And therefore, in this function, in this array function you then return to JSX code for a given item. Now, of course, we wanna and we received this item parameter value automatically by FlatList. But this item which we get here is actually an object generated An object that is wrapped we have in our data array. And therefore I will because it's actually an object that does not just contain our values, but also some metadata. Now, itemData does for example, also give us access to a index property. Again, this object with this property is generated by FlatList. And this holds the index of the different items that are rendered. First item here has an index of zero, the second item has an But itemData also holds another property that's very important for us and that's the property the item property. This will hold the actual data items, one, for each list item So with itemData.item, we get access to the different Now, with that, we can because we're no longer and hence keys are no We will come back to keys in a second but for the moment we'll remove it. And now I will reload the in the terminal with And if I now add another new item here, you will see it shows up and And if I add enough items to So if I add more and more items here, you will see that this I can scroll here. But you also see of course I did get it right from And the warning is the end, Because it's still a list and therefore we still should add keys, but we don't add them Instead when using FlatList, there are two main ways of The first approach is from primitive values like into objects that have a key property. And that's what I'll do here. When I add a new courseGoal, instead of just adding the so as a plain string, I will Where I, for example have a text property that the actual goal text, but where I actually which I set to a unique key. Now, to generate a unique key here, I will actually use Which is not really a unique key. I could generate the same number twice but it's good enough for this demo here. And now with that every item is actually an object, an object with a text property And the special thing is that FlatList will automatically look So FlatList does work in the data array as well as you saw a couple of minutes ago. But it works even better, if your data in this data So if you have a list of objects as data and every object has a key property, because then this key property will automatically be used as a key for the items that are rendered. Now, that we turned our items we have to make sure that that belongs to a single item, we dive into the text Because every item is now an object with a text property, Hence we have to access this And then with that, if we save this and again reload this and I now start adding items here, you will see that now I can and I don't get this warning anymore. And I got this strollable list. And under the hood, only the items that are and the other items will be loaded lazily as we scroll closer to them. That's how this FlatList works now. Now, if you don't have because you're maybe and you can't influence its shape, and you don't wanna transform it just because flat list You also got an alternative to setting up such a key Let's say this would be named ID, this would be a reasonable property name because this could be a unique ID. But it would be the wrong name because this list is not but for a key property. Now, of course we could transform it but if you don't wanna do that, and you can add another prop And that would be the keyExtractor prop. The keyExtractor prop wants for example, an inline arrow function. But you could also define and pass up a point or edit here. And this is a function which will automatically item and index. These two values will when it calls this function for you. And it will call this function for you, for every list item that's being rendered. Now, the renderItem function is also called for every But the renderItem function is responsible for that should be rendered for every item. KeyExtractor on the other hand, this function is simply out of every item, which then under the hood will be attached to the item by the FlatList. And therefore here you And since you get the item and since I know that every with an ID property. And since I know that the ID since it will be unique, And with that, I simply tell FlatList how it gets to a unique key So with that, if I save this and I then again, reload everything here. If I again, learn React Native And I don't get any warnings. This off course, all the if you wanna see it there. I can add multiple goals there as well and there it's also scrollable. So that's FlatList and action, whenever you have lists with dynamic data that should be scrollable. And especially if you have Then, for performance reasons FlatList is better than ScrollView. - [Maximilian] So by a lot about important and concepts in general. Our app JS file is And this is something that no matter if you're or if you're building for the web. Your components get bigger as Now, what do in such cases is and you split them into That is a common approach for keeping your code maintainable. And it's no difference Thus far we're working but this of course is the exception. The norm is that you do work And we wanna do that here as well. For this, I'll add a which I'll name &quot;components&quot; because I wanna store You don't have to use this name but it is a common convention since we will be building and And then I want to add two Goal input JS, because there I plan to store the data input related JSX And goal item JS, here I plan to store the actual JSX code and functionality that is related without putting single goal items. And of course you could split if you wanted to. Now I'll start working on In there I'll add a function goal item because I'll create a functional component and I will export this as a default. So I will build a standard Now you don't need to import You did need to do that in the past but with the modern versions you don't need to do that anymore and therefore a functional component can be created just like this. Now in this goal item component, I wanna return some JSX code and I actually wanna return the code that is responsible for So not the list of And that means I wanna use this code here. Hence, I will cut this code from app JS and return it here in goal item JS. Now, of course, here, I'm and those styles therefore For this I have to create that belongs to this component. So to this component file also and hence I will import from React Native and I will import the Which allows me to call the create method, which creates a new React which helps with auto I'll store this in a though the name is up to you, but since I'm already referring here in my code, I will keep the name here. Now as a side note, we could from app component to goal We don't have to define the styles here but it is a good practice close to your JSX code. And therefore I wanna move my styles that belong to the goal item from the app component into the And that would be these two objects with their style properties. I will cut them in app to goal item JS. And here in this object which I'll paste in these two properties. And with that, I can in my JSX code. So with that, we are We still need to take but we get our first component and then app JS we can We can now also get rid of some imports which we don't need anymore not displaying a text component in there and I'm not using scroll view anymore But I will now import goal And this works just as it we import our components we have a capital starting character because we plan on using this in JSX and we wanna make it clear to React that this is a custom component. Hence we start with a capital character. Now down here in our JSX code, where I return some markup I now return my goal item And this is how we define And of course in the end as we do it in a React for web project. There isn't really any difference here. - [Maximilian] Now of course to goal item though, because in the app component and we need it here. And this is a problem solved With props. Again, just as we do it in any react app because we are building we have a regular react component and we can use props therefore. And we can expect and because it's our component. So here for example, we could expect that on this props object, or a value property whatever you want. I will go with text here. And now we just have to make we use this component, so We pass this prop so that on goal item in the app component. And then here we have to pass in item data dot item dot text. Because again, text is the actual text and I wanna to the text prop in my goal item. And with that if we save if I go back and I learn React Because of this error, What's wrong here? Well, what's wrong is that I'm using the view and the text components but I'm not importing them. And I showed this on purpose, because this is important to understand. If you are working with you can use DVs and h2 You don't need to import them. That's different in React Native. There, all these components and you have to import So besides importing the style sheet here, we also have to import view and text, because we are using these two And once we import them, if you will see that now of course this works again. And now it's looking Because in the end we get but we're achieving this with help of another custom component. - [Maximilian] So now we But we got another custom And this component should hold the input related markup and logic. Now, definitely feel free to from App.js into GoalInput.js on your own and build your own GoalInput component, which you use in App.js. In a couple of seconds, which We will do this together. So, did you succeed? Let's try this together. Now here, I want to extract For this, I'll First of all, create a GoalInput component here, in the GoalInput.js file and export this. and then we wanna return The JSX code that should be and the Button, but I that holds these elements Because that View holds the input related container styling. And I wanna outsource this well. So here, I will add this and the Button to my GoalInput.js file. Now, just as before, we need We need to import View, and we need to bring over Now, I'll start by importing, and I will import View, from react-native, so that we And it will also import StyleSheet, because, of course, I I will create such a styles object here with StyleSheet.create, so that belong to this component And in our case, that would be the inputContainer So in App.js here, I will and TextInput style objects, and cut them, so that in App.js are now much leaner. And it will move them over into the GoalInput component file. So here in this object, and that makes sure our styles are there. But now we're not done. We also are handling some state here. We're getting the user with the main courseGoals But now the problem, of course, is that the courseGoals state is managed in the App component, whereas, the inputs are But that's a common problem in react apps and not specific to react-native, and we can solve it as we We can also talk to the parent component by passing event handler So here, for example, we can and expect a special prop which to be provided by the parent component, which actually holds a function as a value that will be executed upon a press. So now in the App component, we can use the GoalInput we can import GoalInput And we can use this where we had all the input And set this onAddGoal prop, which we expect to get here And now, since we set this prop's value as a value for the onPress prop, and that prop wants a we should pass a function to And we still pass our Now what does change though is how we handle the user input. How we fetch the user input? Because this GoalInputHandler that manages the entered input We don't do this in the Because the TextInput element What we should do therefore and cut it from the App component, and move it into the GoalInput For this, of course, we must useState from react, in So that we can use this function here. Now we got this state. We also need this which updates the state though. So that in the App component, and the addGoalHandler function is left. We will treat this function In GoalInput.js, we can now paste in that GoalInputHandler function. And therefore this is now, again, connected to onChangeText, where we point at this function. So this enteredGoalText is Now, the only problem is is eventually needed in the App component, when we add a new goal. and therefore we also need to make sure that this data arrives The easiest way of ensuring this would be to expect the enteredGoalText So that whenever addGoalHandler is called, we get this text and Now, this function is fine. But right now this text addGoalHandler is passed as a value to onAddGoal on the GoalInput, and onAddGoal is forwarded to onPress, and onPress which ultimately does not provide this enteredGoalText. To make sure that it does, we have to change For example, we can add in our GoalInput component file and name this function So now we have this function in both GoalInput and because we're in Hence, we have no name clash. Now in this function, I actually want to So I want to call this onAddGoal function, which we receive here manually And then, onPress is connected to this addGoalHandler By calling this function manually, I can now make sure that I So this state, I passed this I receive on this onAddGoal prop. And therefore, since function in the App component. That addGoalHandler function will receive the enteredGoalText because I'm passing it manually here. And again, this is nothing This is standard react. Now as extra bonus, we could also set our to clear it, whenever we added a new goal. We didn't do that before And I think it is a But of course, it's up to you whether you want to do that or not. Here, I will do it by setting the state With all of that, back in App component, this should all work. We can now get rid of which we don't need anymore. And if we now save everything, and reload the app on both devices, if I now learn react-native, Now what's not happening is that the input would be reset though. Actually internally it is. If I click add goal, you But it's not reflected The reason for that is that I'm resetting the state here in GoalInput, but I'm not binding We don't have any proper We just have one way binding. In the past, this didn't matter, because as we never changed the text besides typing into the TextInput field. But now since we're also like this by resetting it, we should add a value prop to TextInput, and bind this to the enteredGoalText. So that whenever this goal text changes, because we for example, reset it, this is reflected in the TextInput. If we now save this, I can, again, learn, react-native. Now it's reset. And I can add my goals. So this is now working. And now, we split this And in the end, as you see, here we had absolutely Splitting our app and passing that all works just as - [Maximilian] We're making good progress. We're now able to add and we're managing this Now, what we're not able to do yet though, is remove items, and it would be nice if you and they would be deleted. Now to make them tappable, all you have to do would be to the item. That's how you would do it in the web. But this is not how it Instead here, if you wanna you have to let React Native know. And you let React Native that should be pressable provided by React Native. And that would be the React native also knows a and various related components and &quot;TouchableNativeFeedback,&quot; and &quot;TouchableOpacity,&quot; but those are components that are not deprecated, but by &quot;Pressable&quot; now. So these &quot;Touchable&quot; components are the old React Native way. &quot;Pressable&quot; is the way forward. So we use &quot;Pressable&quot; by that should be pressable with it. Like This. In my &quot;GoalItem,&quot; I wrap my view with &quot;Pressable,&quot; and with that, this item becomes pressable. And whenever we press any so in this case, this view with this text, this &quot;onPress&quot; prop will that we provide to it. So we should provide a and since I plan on deleting I will define this function in App.js, because here, I'm managing and here, I will have to So I will add a &quot;deleteGoalHandler&quot; And for the moment, I'll just in this function. We will of course replace Now, &quot;deleteGoalHandler&quot; to the goal item, In the infer, I'll add a prop here, and since it's my component, it's my choice how this and I'll name it &quot;onDeleteItem&quot; and pass my &quot;deleteGoalHanlder&quot; A pointer to this is passed as a value to &quot;onDeleteItem&quot; on my &quot;GoalItem&quot; component. And now this &quot;onDeleteItem&quot; in that component. And here, I can for example, simply forward it. Like that. We might tweak it later we can just do it like this. Now, if I save this, If I tap on one of these items, but if I go back, you see to the terminal. So indeed, this already works. 'Course, some visual and we will add it in a second, but for the moment, it's - [Maximilian] As a next step, we can now make sure that an And for this, in the app component, in the deleteGoalHandler, it would be convenient if we would receive the ID Because that allows us and remove an item. So here in this function, we could then set our course goals again, to update this course goals state. And now the new state should where we wanna take the old and therefore we pass a function to this state updating function. 'Cause that's how we should update state in React if it's based So here, I again, get as I did here, when we added a goal and I return the updated state. And the updated state which I which is in Array, dot filter. Filter is a built-in method in JavaScript, just as map was built-in method, which we can call on in Array. And filter will return a new minus all the items we filtered out. Now filter itself takes a function, which has to return true or false and if this inner function if it returns false, our item is dropped. Now this inner function for every item in this it receives these items In my case, these individual goals. And I wanna return false, So I will check if the goal ID, so this ID property on my goal object is not equal to the ID I'm receiving here. This will return true which is good because I want to keep items where there is no match, if a item has the idea this will return false and then this item will be will no longer contain it. That's how we can delete a course goal. Of course, we have one problem though, the ID which we expect to get here is currently not provided. In goal item, where I'm binding on the lead item to onpress, Now to make sure that idea is provided, we could, again, define a as we did it in goal input, where we then manually called the function and passed our own parameter and that would be absolutely fine. But alternatively, we can also on the function which we get through that onDeleteItem prop. Bind is a standard JavaScript function which basically allows you for future execution. Now, the first value you pass to bind sets the this keyword in and we don't care about that here, so I'll just set it to The second value, the second will be the first parameter received by the to be called function. And in my case, that should that should be removed. So here I'll set this to props.id, so that the ID which I get through props on this goal item component queue the function that we receive on this onDeleteItem prop which is this delete Of course, for this to that we do get an ID prop on And currently that's not the case but we can update our code here and make sure at an ID and that would be itemdata.item.id. Now there would be other but this will work and if we save this now and we tap a item, it is removed. So now I can add items, multiple items and I can then tap them to remove them. By the way, you could also add validation to make sure that empty but here I will not do that to But with that, we can remove items. Now what's missing some visual feedback. At the moment, when I tap this item I get no visual feedback So let's focus on the styling next. - So let's now work on the styling of this pressable component if the item is currently pressed because at the moment we Now, adding some nice styling here is fairly easy for Android because there is a dedicated which you you can set to an object where you can set the And for example here, I could set this color to some dark gray by adding six Ds here, this hex code. And if I do that, if I set this value for the android_ripple if I add a goal and I press this, there is a slight ripple effect. Let me show this again. Here, if I then press this. You see? There is this ripple Now, if you wanna have the ripple effect inside of that item instead, what we have to do is move like this so that it instead of the view box as well. If we do that and we reload all apps to make sure these changes get applied. Now, if we do this again on Android here, you will see there is a slight Now, that ripple effect Not on the overall container. And to fix this, what we from the goal item which is the to the text because then the and the ripple effect into account as well. So now with that, if we set this up we got this ripple effect here. And of course, you can play to get the look you want. You could, for example, also And maybe choose a very and now we have this, which So, this is pretty easy on Android. Now on iOS, this doesn't Here, if I press this and keep it pressed so that we could see a potential effect, we don't see any effect at all. Now for iOS to add some styling, we can add the style prop to pressable which generally works It takes such a styling object but it also takes a And this function will be called whenever the press state changes. You will get a argument here, a parameter, with information about and you can use object of the pressed property that's You could also name the and access pressData.pressed It's up to you. Here, I will use object destructuring to directly get that pressed property. So, that's provided by pressable. And now we can return based on the pressed state. We can define them down here of course. We could have our pressed item here. And there, we could say that we wanna set the to make it slightly transparent. With that up here, we can check pressed and if it's true, we Otherwise, we return no special styling. If we save this and I now do learn react native again, you'll notice that if I press this we also get some feedback here on iOS. Now of course, you could go You could also bring this view back into the pressable component here and add another surrounding view so that you can influence and you can, for example, also Whatever you want. Here, I'll keep this simple feedback but now we also do have of this function form of - [Maximilian Schwarzmuller] So again. We made good progress here. To conclude this section. I wanna improve the overall look and feel of this application And I wanna start by actually into a modal, modals are these overlays. That typically slide up or pop up, on mobile apps that And allow you to take some action, after which they disappear. Adding such a modal, and into such a model, is thankfully pretty easy in React Native. Because it comes with a So, all you have to do in where I want to create that modal. Is, you import modal from React Native. And then you wrap that, around the content that In my case here, that's the view with the text input and the button. If you do that, we have this look here. So our list of goals seems to be gone and the styling is a bit off. And as I add goals, I don't see them. The reason for that is, that we actually see the modal here. The overlay, which we Now, of course the modal Instead it would be nice to have a button on the start screen, that allows us to open the modal when we want to add a new goal. And then to have a close this modal here Now let's start with that button that opens the modal. For this, I'll go back to App.js, and I want to add that button there. We still have the goal input component. But above that component, And for this I'll use the Though, of course we could And build our own button, as you learned it a couple of minutes ago. Because the button here uses is the &quot;pressable&quot; component components internally. But here, to save some time, I'll use the prebuilt button And I'll give this button a I'll also give the button a Because &quot;button&quot; doesn't It doesn't support it. Because it is already pre-styled. That's why you can't If you do want to style build your own button with And then some text and views inside of it. Here, with the pre-built color through the color prop though. And I will set color here to, actually to a string. And I will use the same purple, as I used here in goal item. For the background of my goals. I'll use this purple color here. And set this as a color Like this. So now we have the button. But of course, we don't see the button if we save this. Because we still have Now this button should And for this we need &quot;state&quot;, because the modal should And that's a typical So, here in the app component, we can add a new piece of &quot;state&quot;. And use, &quot;use state&quot; to false initially, because that will be my And the &quot;set modal is will allow me to change it. And initially the modal Now we wanna change this - So for this, I'll add a &quot;function&quot; here, maybe here, the exact Which I will name &quot;start at goal handler&quot;. And in this function I want to set, &quot;set modal is visible&quot; to true. Because I wanna show the modal. Now, this &quot;start at should now be connected to this button. And this button, being a built in component - Which we now use to connect Now to show the modal only We could now render goal as we would do a it in We can add curly braces around that. And then check our And if it's true, then we render goal input. Which internally contains this modal. If we do It like this Indeed we see the button here. And if I press the button, the modal appears But the model then is just there. There is no animation and nothing. And therefore that's typically not, how you would do that. Instead of just showing or A better approach is to embrace This built-in modal To be precise, this &quot;modal&quot; And if set to &quot;true&quot;, If set to &quot;false&quot;, it's not. Now, this is useful. Because in addition, modal Where you can set how it will be animated. That there maybe is no animation at all. That it should fade. Or that it should slide in. And I will go for sliding. And now I just expect to get the, &quot;should it be displayed or So here I'll access &quot;props.visible&quot;, though this prop name here is up to you. It could also be &quot;show modal&quot;. But I'll choose &quot;visible&quot;. And now we have to set in the app component. So here, I'll now add this &quot;visible&quot; prop. And set this equal to &quot;modal is visible&quot;, which is true or false. And with that, if we now saved this. And we force a reload, by pressing R here in the terminal. Now the modal slides up. Of course we can't And the styling in So, therefore let's next And let's then make sure that, we can also close this modal. - [Maximilian] So to In the end we need to go There, we have this model and in the model we have this View. Which in the end is the textInput and button are displayed. Now I wanna change the overall look. I now wanna have the button and I wanna have another button in addition to add goal. Because that other button should allow us to close that model. Now to achieve this I will And I will actually add below the textInput, and move And add another button here with a title of Cancel. So that I can add the And this should in the at the moment it won't do anything though. Now with that, we got that View in a View. But now I wanna change the which is the main View inside the model. Because it's the first The top most element in the model. And on this input container, So that it takes all the But I wanna change the And therefore we can also remove it because that is the default anyways. With this, if I save this, the buttons are now below the textInput. But they are totally stretched out, because we have space This should instead be center to make sure all the content is centered. This now looks way better. Now in addition these two buttons should be next to each other and therefore I added this and I will give this View some styling. So here, maybe at the bottom, I'll add my buttonContainer object. And actually give this So that the two buttons And then add this So here I'll add a style which is styles.buttonContainer. And with that, the buttons Now it would be nice if the buttons had maybe a fixed width and And to achieve this, since since they're built in and since I don't wanna which we could do but I'll actually wrap each Because then I can style that And therefore still influence So here I'll assign a style And setup a dedicated styling I'll name style object button. And for every button that it takes, lets say, And then we might want to So margin left and right, of eight pixels. So that we have some And it's now this button style here which I wanna add to the And that's a quick and easy way of setting my own styles to the buttons even though I can't change But you can change the you can add margins between them. You wouldn't be able to change the color or text color though, you would have to build your own button. And in general, if you you might wanna build your own button by using the pressable component. But this is good enough for now and it gives me these equal sized buttons below the textInput. I also wanna have some spacing between the textInputs and the buttons. And maybe we can shrink them a little bit. So to shrink them I'll or we set this to a fixed like this. And for the spacing between On the buttonContainer of let's say, 8 or maybe 16. So now I save this there is some distance between the buttons and the The textInput now also can become wider. So I will set the width And with that, I reloaded so I will reopen this, this is now wider. Now it would still be around that which is not occupied. And therefore on the overall container, Which is that root View in that model, I will add a little of and let's say add 16 pixels of padding. And now I'd say this doesn't look too bad. Last but not least we still have some extra of the textInput, because we had a margin to right and I wanna get rid of that as well. So now this does look quite good. And of course you can if you want to. Now I wanna make sure the model closes whenever we cancel or Because at the moment - [Maximilian] So to close the modal, whenever we click add goal or cancel, we have to react to taps on those buttons. And then in the end, we have to change the visibility because modal is visible whether the modal is shown or not. Now we already got a 'StartAddGoalHandler' which opens the modal. Now we can add a 'EndAddGoalHandler' which should set And now we just need to gets called whenever a user taps on the 'Add Goal' or 'Cancel' buttons. Now, if a user taps on 'Add Goal', the 'AddGoalHandler' is triggered which triggers the function which turns out to be this function. So in order to close the we just have to set 'ModalIsVisible' or call the 'endAddGoalHandler' Both would work. Now to also close it, If we tap the cancel button, in goal input we have to add 'onPress' to this button as well, And then expect that we get a pointer to this 'endAddGoalHandler' passed into 'GoalInput' through props. So here we could expect that we get a function on a cancel prop. It's our component, so the Now we just have to make sure in app component. Here we pass the 'onCancel' prop to the 'GoalInput' component and point at the end, so that this function is executed whenever the cancel button With that, if we save this. Indeed, if I click And if I add a goal here, like this, and I click add goal, it also closes, but the goal is there. And of course it also works on Android. Both adding and removing, - [Maximilian] Now to I wanna improve the overall look and feel, by changing some colors Which is something we haven't done yet. But which is of course, And you should therefore know how to do. Now, adding an image, thankfully is easy. Because React Native There is an &quot;image&quot; component, which you can import from React Native. And just as you have, the &quot;image&quot; element for the web, in HTML. This is a component that helps This &quot;image&quot; component And here I wanna display an image, right above the text input. So, I will add my image here. On this image, you can Which we'll do in a second. But most importantly, you And this should point at Now, when it comes to that image, you do find an example image attached. And you should download that image and move it into your &quot;assets&quot; folder. Or to be precise create an &quot;images&quot; folder in that &quot;assets&quot; folder. Because that &quot;assets&quot; folder is generally, the folder where static assets And then move that attached image, into that &quot;images&quot; folder And it's this &quot;goal image&quot;, And now when it comes to It works differently than what We won't create some link &quot;assets/images/goal.png&quot; at least not quite. It's not too wrong, but it If I save this, you see, I get a warning. I get an error, this doesn't work. Instead, you have to import the image here with a special import syntax. You should use a &quot;require&quot; function. Which you might know from Node.js, if you worked with that. And to that &quot;require&quot; function, you pass the path to the image. However, the path is a in which you're using So, seen relatively from which is that file, where this &quot;required&quot; function gets used. We have to go up one level, to leave the &quot;components&quot; folder. And then dive into images Now to go up one level we type ../, this means go to the parent folder. And then we dive into This is how we add an image. Now let's also add some styling to it. And for this, I'll add in my style sheet here. And here we could set a width And a height of 100 pixels. And give this a margin to have some spacing around the image. As always, you can play around with the styling, to find your favorite styles. Now I wanna apply that style to my image. And thankfully the &quot;image&quot; element, the &quot;image&quot; Component, does And we can set &quot;styles.image&quot;, as a value on that style prop. And with that, if we reload in the terminal. You will see nothing. As it seems. The reason for that is And we can't see that, because the background is also white. That's no problem because, I wanted to changed And since we're in the modal here. This background can be changed. By setting a different background Because that is our root And it defines the overall The modal itself does But for styling the you should use a nested view, And now here on this input container. We can add a background color. And I prepared a nice dark purple, which I'd like to use here. Which has to hex code 311b6b. And whilst we're here, I also wanna change some other styles. For example, we don't need the border at the bottom anymore. Because there is nothing below that. And that border here looks really strange. So I will remove that border. And I will also remove which I have here. So that these are the remaining And with this, now we can see the image. Because now we got this Only in the modal though. We will work on the But here in the model, we got that. Of course, we now also might want to, tweak the text color here. When we enter something And we might wanna tweak To make those look a bit prettier as well. Because currently they But most importantly, we Which was the main task for this lecture. And as you saw, adding With that &quot;image&quot; Component and So let's next improve the overall styling of those modal elements. The other elements, I mean. - [Tutor] So for improving the I wanna start by changing For this, we can go to our JSX code because you learned that you change the colors with the color prop. And again, I prepared some hex codes, which I think look quite nice. And for adding an item here, I wanna use the code 5E0acc. And for canceling, I which is F31282. If we save this, this is And it looks good on Android, but on iOS, it's a bit hard to read I would say. This is a bit hard to read. So actually, we might wanna tweak this and pick a slightly lighter purple, like B180f0, which I think looks good on iOS as well. It doesn't look as good on Android, but for the moment I don't wanna dive into writing different code We will do that later in the course, but for now let's stick to where we have the same Of course, feel free to optimize the app for one of the two platforms. For example, if you're on on iOS anyways, you can of for this button there. But we got these buttons now, let's now work on the text input styling. And for this, we got this text In there, I wanna to change and choose E4d0ff. And also give this a background color which should be the same color. So I'll just copy that as a I will now also change the to 120438, which is another prepared hex code. Since I added a border, I also wanna change the border radius, so that I have some rounded and set this to six pixels. And with that, that is And I think that doesn't look too bad. Last but not least, I a little bit though, and change it to 16, so that we got this padding here. So that's now how this model looks like. And I would say it doesn't look too bad. We can now learn React Native I just wanna switch to button order because I ended a bit more intuitive if the add button is on the right, but of course, this comes and is totally up to you. But now, this works. Last but not least, I also wanna improve the styling Because I think that isn't too pretty. Here, I prepared a little color for us. And it has the hex code 1e085a. Now, if we set it like this, this works and we got this as a background color. And this works just fine here. But if we had multiple so not just the model, which we will have later then manually setting the all the time, can become annoying. Therefore what you can do when using expo, is you can go to the app.json file. And in that file, you a special background and set this to a hex code. And this will then as a background color So if I now reload after and saving that file, we also but now it's applied by expo not to the model, but that are not overlays. Here, we only have one But this can be the if you do have multiple screens. Of course, like this, with the way this add I think it's a bit hard to see on iOS. Therefore, what I will do is in App.js, I will change the color of this button. And we could go for a And I think that looks a bit nicer. So now with the styling changed, there's one thing that The status bar is really difficult to see on both these devices. The reason for that is that it doesn't know that Now, thankfully, expo gives We can import a special And that component is the status bar. We can import it from expo-status-bar, which is a standalone package which is already part of this project. This package here. This is a component which the look of the status bar. We simply use this status here in our JSX code, in So here we can add StatusBar. And since it's now next to right at the top of I will wrap it with such a fragment, since you're not allowed at the root level of JSX code otherwise. So we add this wrapping fragment and add the StatusBar component next to our root view component. And on this StatusBar component, you can now set a style prop, And you can now set the or let it infer it automatically. Now, auto doesn't work here. So I will set it to light. And if I do that, the and is now way easier to see again. And that is definitely a so that we do have an app that looks good and that still allows the user to see crucial phone information - [Maximilian] So, that's We learned a lot about React Native. We built the first basic application here, where we can add our course goals, and whilst building this application, we learned a lot about with React Native, in general. You learned that you must use these built-in core components, for example. You are not allowed to use HTML elements like div's or anything like that. Instead, you build the and all your custom components from those built-in components. But then you can combine them as you need to, to build your You also learned how styling works, that you create such style sheet objects which hold nested objects, which you can then assign to different elements in your JSX code. In those nested objects, we which allow us to set and all these things. Now even though it looks a bit like CSS, or the names are similar, it isn't CSS. We have no inheritance and in general, it's just not CSS, it's JavaScript and under the hood, our style settings to the for the different platforms. We, for example, saw that we had problems assigning rounded corners whereas it worked and therefore, its really important to keep in mind that we and React Native just does its best to talk to both platforms and transform our instructions for them. Now, what we also of course learned, is that besides the we write regular React applications. We can still use state, those events are just not called onclick, but instead onpress. But then we can react to we can output state and and this part, works There's nothing special about this. React Native Plus React is when it comes to managing state and so on. Now, we saw differences when it came to outputting lists though. We did this with a scroll view, but then we switched to flat Which is another built-in core component. And you will see cases throughout the course, where for the Native platforms or a Native look and feel. But that's it for the basics for now. In the end it's not too complex, it's a React app, just with but of course it is something Working with those built-in components, setting up styling like this. It takes practice to get used to that. And thankfully we'll throughout this course, because this was just and just the first app. We're going to build way more and we're going to learn way more throughout the rest of this course. I hope you enjoyed this &quot;Getting Started&quot; guide with the project setup, If you liked this, for example, how to use native device how to add multiple page then my complete course on React And you'll find a link to the course, with a nice discount, And I'd of course love to welcome and continue this journey