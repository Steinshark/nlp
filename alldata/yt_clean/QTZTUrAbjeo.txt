In this video, I'm going to show you how honestly don't even need to be combined they can be used completely independently. although I would caution you that there's a right and unfortunately, many developers fall in the watch this video and you watch it until the end, and you're going to properly know how to combine actually, before that, I just want to mention complex application with React as a total beginner out Project React. It'll be the first link in the it. Now, let's get into it. All right, cool. So a simple application. This is actually even more application. And our responsibility is going to be be used for the future if we were to take this So this is a really important responsibility. And imagine that we're actually working on a job right to efficiently combine React query with Zustand concept that makes sense, that is efficient, and components across all of our application perhaps. And all that we have to do that is this totally empty. And we also have this user API over is trying to mimic a backend. It's simulating a optional filters, which can have some limit and a would do something cool with those filters, like have data, we don't have a backend, we don't have an empty promise for one second. And then it's that is going to be me. That's me. I'm ID number be of type user. And as you can see here, this property, and then has a name property. And that's Well, before thinking about that, we actually would make sense for us to set up all of the code single user or technically users, and then take it able to think a little bit more clearly about how come here inside of the app component. And we're we're going to do const data, and then that's to import this from 10 stack at react query, then is going to be an array, and then users like this. it called over here, I think it's get users, this from our API. And then over here, we're going does expect filters that are optional. So that with this, all that we have to do is come here to those users. And let's see, you can copilot figure to map over the data over here, because it is an is going to be optional. I mean, it's going to be we're going to put a question mark over here. And then for every user, we're just going to return a username. And that's it. So now if you go to our me just zoom in a little bit so that you can see a little bit for a second, actually, while it's our list of users over here, which again, just has from react query from our actual fetch request. right? Because we have react query, it's doing which is actually going to be users, how do all of those users in Zestand? Or how do we do with Zestand that would make sense over here I'm going to spoil it for you and tell you that this one is the very naive way, which is actually extra work for nothing. And then there's the right I'm going to show you both. And we're first going is wrong. So let's do it. Let's add Zestand So we're going to come here to our sidebar, we I'm going to create here a new file. And I'm we're going to create all of our Zestand state for because we're working in TypeScript, we're going So we're going to come here and do type and then object over here. And now in here, we can actually this is the user store, we're probably going to react query. So we're going to do users like this. can import from our types folder. And then because our store, we actually also need a function to be we're going to come here and do set users. And Copilot, it is not responding right now, there and then it's going to return void, we're going to So we're going to come here and then do export use over here is because this is going to get used the rules of hooks in react, which means that they keyword use. And then we're going to actually let enough that it can understand what actually it is from just stand like this. And now everything we're using here, we're giving it the actual type, have. And then we're also using the set function of state over here, we're initiating users as it just going to use the set function over here, here in the state. And there we go, we have our back here to our app component. And we can use So we can come here to the app component And then we can do const, and then users. And that import this directly from state slash user store. to want to access the set users function, because I guess the values that are returned from react So that's what we're going to use. Now to actually we do it? Well, react query in the past, and maybe to have something like this called on success, this query is actually resulted in a success, we could use that to actually update our users. this hasn't been deprecated. So we're going to we're going to come here and do use effect, we're have this be a function, we're going to pass here And then we're just going to do if data then set because our data is now into users, right, we're going to actually be able to remove the question going to be an array, it's just a question of does we don't need to have a question mark. And I mean, react query through this use effect over here to from the Zastand store to actually render out our you're going to see that it works, we still just like we had it before. And even if I we're not going to see it for a second. And then we're going to see that is over here, this that by now you realize that although this so it is working, there's no bugs in here, this way to do things. This is the wrong way to combine done here is we've duplicated a lot of code, and app that we didn't need to add at all. Because if of users are now stored in two places, we have it in this data property over here. It's not because the Zastand store that it's no longer going to be here and then do data. And then we're going to query, this is still going to work exactly in the using the actual users from the Zastand store. this to put this data from react query instead of inside of react query, doing what we did just now our data in two separate places that we have to that, and this I've actually talked about it in is that react query is not just a data fetching for that at its core, it's not a data fetching but it's not a data fetching library. It's an happens to fit well with the fact of fetching operation. But react query is more than just cache caching data that acts as an actual state function actually gets called, whatever gets gets put in the react query cache. So that if you another component or some other place, it's going making a fetch from scratch once again. That's actually is a state management solution. It's which means that we could have done all of this. without ever using Zustand. So the fact that we complexity unnecessarily. And this is not the way we want to provide to our make-believe team to do better. We need to do something else. And important piece that we have in this component we actually have two very different kinds We have something that we call server we call client state. Although technically, I our client state does not exist because everything going to explain in just a second what those two and then we have client state. So server state, state is any state that comes and belongs on the server state, right? Our database is state. It's time. And we can use that to actually read values doesn't manage our database, our front end doesn't the back end to the server, and the server manages we're returning, and this entire file, really, is the server, not on the client. And now going back that React query is a server state solution, a asynchronous operations. Zostand, on the other at and it's only good at managing client state, that lives in your React application, not that we've actually put server state inside of Zostand. we already had that by default with React query, here that lives on the server, the client doesn't client, hey, this is the user that we have. And here in React query, as we should, because React solution. But then we've also added the extra step again, we shouldn't have done this, React query Zostand was unnecessary. Zostand is only good for currently, we don't have any client state, right? state and what we can actually use to make changes state instead of server state. And that is going for the limit, we have a filter for the page. And function, and then hypothetically would be used to filters, what page are we currently on? What's right? How many per page, that state lives on the in our application, this is the only client state React query being server state, and Zostand being and really the only thing that we can do that for the client state for these filters over here. the server state with the actual users that are that we can do. And actually, now we're going to more sense when you do it this way, as opposed to let's do that. And let's update our user store to So first, we're going to remove anything that is server state. So all of this gets completely going to want to do is actually have our filters export to this type, because we're going to want have your filters. And that is going to be let's going to import this from API slash user. Now I you are probably not want to directly you would maybe want to define them here. But for can just get directly the type over here inside other complexity. And then again, because we have to set the filter. So we can do set filters. And so we have filters and then get users filters. And I'm going to make these as optional, because actually not like this, this should be optional. because chances are we're not always going to have no filters and get all of the users from the back come here and actually remove all of this code it can, there we go, we have filters, which gets we're going to have no filters. And then we but just for filters instead of user that is going in the actual state like this. And we are good make to our user store to actually now have it be state. And then inside of the app component, get rid of anything that is users related to the filters like this, right, we're just going to we actually don't need this use effect anymore, we actual users, again, are going to live exclusively function, again, optionally receives here these by doing this filters like this filters. There we right, that's why we imported the type, this to do anything else and create anything else. And we want to have its caching magic be working as we as an object. And actually, I believe we should an object. There we go. And finally, we can we no longer need it. And now we've combined using both libraries for what they're good at right? We've used here zestyne for the client only ever live on the client, the client will be limit. And when those change, they're going to query is going to use those to actually get a new using the filters. And that filtered list of users going to see it directly on the screen updated, and react query together and not the way that of doing it this way is super great. Because now and managed by the client react query doesn't do just send them over to the back end and let the focus on what it's good at and zestyne can focus we're actually not setting the filters anywhere. here and perhaps make a new component function right. And here, we're going to take this use of this component instead of filters, we're use the power of imagination. And let's imagine call the set filters function and update the maybe we put it over here filter component, why is this giving an error? Oh, because it has to can just return no, there we go, we have another this uses independently disaster and store the we'll then use that function to hypothetically inside of this component inside of this filters, is going to do the same thing that it's always managing your asynchronous state, right. And this we're following proper design patterns over everything is clear, there's no misunderstandings. we can come now. And again, with the example of to our team and say, hey, this is the way that are the problems, these are the fallbacks that you and if you explain all the server and client everything makes sense, everything works together and you're getting the best results, the best for the team and for yourself as a developer. So time as you need to really try to understand this And it's so easy to do it the wrong way and to nightmare. I mean, you saw how much even though in literally duplicated everything that we had, amount of bugs that that could have produced, think about a more complex application, where that would be a nightmare. And I don't want that. take the time to study this video and really make you can actually access the code, you can with it. They'll beIf you enjoyed this video and make sure to leave this video a big thumbs or you can click here to watch a different video really going to enjoy. And with that being said, Solutions, thank you so much for watching, and