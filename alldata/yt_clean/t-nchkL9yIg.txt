A new plug-in is out for Vite and Rollup applications that allows them Which is super cool dynamically So what are we talking about here? Well, there's two ways to share code and mostly I'm talking about Imagine that you have two applications and the product detail page, and they want to be able to share a header Now, with build time sharing, with, you have a library and then both of those applications to update that header, then you would need That's build time sharing. Now, runtime sharing The home page, for example, It could then expose that header and then the product detail page dynamically at runtime when it publishes that product detail page will get it And this is a really big architectural win in the kind of Fortune 500 space. You've got those big companies managing multiple applications, and you want to be able to have but you want to be able So in this case, when you want the header if all of those teams can get the header and runtime sharing allows for that. So what I'm gonna do this video is upgrade by showing you how to do Module Federation Then I'm gonna show you how to do shared stores Pretty cool stuff. Then we're going to bring in Webpack because Webpack is where all this module and you want to make sure that your older applications Federation are now compatible that have module federation. And finally, I'll show you how to do this so that you can get a sense of a build timesharing system This is very cool stuff Let's get right into it. So let's start off with our plug-in This is a plug in for Vite. It uses the classic micro front end image here to show you the advantages And then it talks about how to install it So really good documentation here. It also has some really great examples. If you scroll down here that show you kind of all of the different of using different frameworks, using I mean, potentially you can use dynamically a Vue component It's really cool stuff. So what we're going to do in just React talking you got a whole bunch of different All right. I'm going to go into the terminal I'll create a project called Vite Mod Fed and then into there, and then I'll bring up VS code. So to start off with, because we want to share code One of those applications because the remote app And we're going to have and that's going to be Now, an interesting little side note here an application can be both a host We're not going to do that here, but All right. Let's start off So I'm going to use pnpm create vite. Name it remote and use the React template. All right, now in remote. I'm going to go I'll do that. And development mode. Now, let's Got a basic app, src/app, all that good stuff. We've got a package.json. Really nothing exciting in here. It's got all the regular React stuff, have this new plugin federation Awesome. Now, one of the important aspects of module federation to point to where the code is and you want that So in this case, we're going to get a different port That's not great. What we really want to do so that when the host application it has a consistent port number. So we're going to go make some changes to the package So all we're doing here is we're saying and if you don't get 5001, So there you go. That's what strict port does. So now we need a component to share with Now I'm just going to use a custom button I just want to show I'm not trying to actually show off That's up to you. Okay, so let's go create our button now into this button that jsx while all of this code is available to you and a link in the description So you don't really have to type And all this button is doing is it goes up by one. Nothing too exciting. It's important that it does because you can get into a scenario where it looks like it's working, So it's important to have in your test Any kind of hook will do. Just to make sure that the React What's going to happen is that you'll get a error in the console about how And that's because for which react instances All right. We save that out. Okay. And just to check out what we've got, bring in our button. Now, clean this up a little bit. Oh, instantiate our button. But for convenience sake, which application So I'm going to put in remote application give it a try. So we got the counter that is part of the application itself So that's the local app counter. And then this is the button counter says Click me Now what we want to do is we want to create a host application So let's go build that. So I'm going to create another terminal going to do the same pnpm create, Then I go into host and again So you need this plugin on both sides in to expose that button, And then the host application needs the plugin to go So it's going to add it here. So the only thing I'm going to do in host make some changes to the app.jsx, it down the way that we did before. Okay, Looks pretty good. Now I'm going to go run that. Now, let's notice that host in this case is on port 5176, not a problem. It doesn't matter where host is. All that matters is where that remote is is going to have the manifest And it has to be at a specific URL. All right. Let's see how this looks cool. We've got our host application sitting So now we want to go and share the button So let's go All right. First thing I need to do plug in, and then we need to configure So let's start at the top here. We've got our name in this case, You can name whatever you want. Then we have the file of all of the modules And the name of that file That's pretty standard And then we're going to say, And in this case, and we need to give it the path So in this case, src/button, then we need to specify And now you need to expose any libraries In this case, button depends on react Therefore, And then finally, I'm gonna make some So now we need to go over and this is where things start to diverge To get this to work with. Vite, you actually need to build So let's do that. So we do yarn build and then have yarn build a successful looks like yarn build is successful Now one last trick that we should do is take a look So go and create a new tab and I'm going And that's supposed to go Now remoteEntry is a manifest. It tells the consuming application Host Here's what I've got react and react-dom as shared libraries that has our button implementation in it. So if you don't see this file, then And if you just run pnpm dev, So that's why it's important because this build And I also want to emphasize This is going into the assets directory and all of the bundles that are and they should be treated One of the questions is what happens to the sharing if the application that I rely on goes down. Well, nothing, because what you should do is you should go all your CSS, your JavaScript, to a static asset store, So yes, your application could go down, of your application. The static assets should never go down be deployed on something like S3, And if S3 does go down, well, it's a holiday for everybody, All right. I just get asked that question right here. Okay, let's go and configure host Then I'll go into host Vite config, and then I'll define federation. So in this case, and we are going to have a remote and then we give it Now this remoteApp key So when you want to import button You can use any name for that you want, with what it is. So in this case, it's remote app. And then of course any libraries So in this case to make sure that everybody's using the same react and react-dom multiple copies for both performance So this allows for module federation between the host and the remote and say, Great, you've got React great. Cool. There it is. Okay, cool. And then finally, some build tweaks and looks Let's go now So important, we're going to use We're going to say that we have a button on a remote app slash button Okay, let's try this again. So I'm going to hit Ctrl-C. And now in host, I'm going to build, instead of serve, we can see that I haven't actually because we didn't So let's go and do a build All right, Let's go take a look. Here we go. Port 4173. We have our host application the same component And this is actually really important Notice that I'm over here on 5001. My Click Me is now at seven. Let's say my account is at four, application where Click Me is now at 17 This is another common question why am I seeing different state when you're using the same component And the answer is because you wanted to share the state, sharing approach like, say, There's no magic here. All we're doing is just sharing code. So let's actually see the code change dynamically. So what we want to do and see the changes in the host So let's see if that actually works. So to do that, I'm going to change the CSS on button, and into src. I'll create a new file and I'll put it in our CSS. Now we've got a shared button class. Just so happens Who would have thunk it? So now I'm going to bring in our CSS. So we just defined and then rebuild and redeploy just the remote. All right, let's take a look. So if I refresh 5001, then we get this kind of dark And we should see if I refresh We should see that same dark black button. And we do. Cool. How cool is that? I did not go and redeploy 4173. Right. It automatically got that change between application is looking dynamically Not state So what module federation is or micro-fes. And one of the things you want to do with a micro front end is share and the micro frontend, for example, Now the way that that is with an atomic state manager, Both of those work well. I prefer Jotai, So what are we going to do? We're going to have a shared state for click me in the application itself eight It's pretty rudimentary, the host application, in this case And then over here So we'll see how to share state, So first we need to create some Let's go do that. Then over in remote I'm going to go and add Jotai and then I'm going to create our store. I'll call it store.js. and I'll paste in our implementation. We'll take a look at it. So we are going to define and then we will have a custom hook called We'll return a use atom that's going as well as a setter in a tuple So that will be the default output of this store, will be this useCount All right, let's go bring this in a button and then all we need to do is just replace and that all about do it now. Let's go over here to our app and replace this useState And so theoretically, because the state is shared between So let's go to try now, of course, to see any changes. I want to do that, build and serve and if I click, yeah, there it is, I click in either place But here It doesn't fail, which is good, So what do I need to do? I need to share that store and the host application. So let's go do that. So we'll go into my Vite config again. Now I'm going to go and expose that store by just changing button to store here and now I need specify because Jotai is essential All right, let's build in the play again. Now let's go over in the host Same kind of deal here. We're going to bring in useStore from the store and use it. Let's see. All right. Again, Okay. Looks happy. Let's go back over here or hit refresh. Perfect! So imagine what you can do with this. You can have your user ID, you can have all this Now, why do I recommend using something for sharing state between a host as opposed to something is, say, Well, what are we trying to accomplish We're trying to accomplish a coupling between the host application The more state that you share between those two things, If you have something just like the user that's a pretty small surface The great thing about atomic state management like this that you want to share between those two applications, Whereas with Redux or Zustand, So there's no friction to adding new data and the micro-frontend. And that's not great because the more data that you share, Now, Module Federation came out with Webpack five, So are Webpack with the module federation Let's see! To test that, I'm going to go that imports this same button. We'll see how it works. Let's create yet another terminal and into there I'm going to do my own npx create-mf-app, and we'll call this wp-host We'll say that as an application, and we'll use React and we use JavaScript. Keep the standard CSS and we'll go into that directory. Now let's go take a look at we got we've got a source directory Cool. And we've got our package JSON. Now we do need to make a few upgrades here and the applications have 18.2. Definitely want to upgrade that. And the Webpack CLI also needs an upgrade Now over in our app.jsx reactDom renderer, so it's going upgrade as well as get the react Cool and by default and since everybody is telling me a dark mode application by just Okay. I think we're good. Let's give it a try. So now I'll do my pnpm install and I'll start and here we go. Localhost 8080. Well that's beautiful. Okay, so now let's go So over and over and config we are going This is in the model generation plug in. We're going to say that we have a remote. It's going to be the same exact remote Localhost 5001. Cool. And let's go see bring in our button and let's just do a console.log now So I'm going to go and do a console.log and that's not good. So what I think is happening here is working on Ecmascript modules, of building out our application So let's bring up the Webpack config and we'll specify here that we are using a module. Let's see if that helps. Oh, okay. So now we're getting library when we have experiment output Okay, let's go do that. So let's say that and then also specify our experiment Let's give it a try. Okay, so these didn't blow up, So to complete the migration of modules, we need to have an index So let's go and create a new index. Now we're going to bring in all of our plug in files via the type module. Cool. So now let's go back over to our Webpack We'll change this to the index.ejs and then we'll say that we don't want to inject anything and let's give it a try. Okay? It looks like it's not blowing up. That's a good sign. And now that we see that, Oh, Awesome. We have a module button there. Cool. So now let's go and try that out. Let's go over to our app.jsx. So this is a little different. We're going to bring in a button module and then from that we are going to dereference button by saying that we want default So that should give us button. Let's see how we do. All right. It looks like this time we actually have our component function, So we'll go back down in our app, instantiate button, and there we go. Now we have our button all the way all the way into our Webpack So they are compatible from Vite and Rollup and Webpack. Now the last thing I want to do I'm going to bring the monorepo code so when they get have repo you'll see a new folder called This is a turborepo monorepo that has two applications in it, app I didn't name them host and remote in this case. You're not actually doing that There's no remote, there is no host. They're both sharing the components So in this case button, They're also sharing Now each one of these is a conventional In the case of this store package, and then over here in app we reference store by saying that That's how a monorepo works. We also get the UI from the workspace and then down here in the tsx file we bring in button from our UI, It is the buildtime sharing that we've The reason that I'm including it in so that you can have a look buildtime sharing and runtime sharing and think about the pros the pros are that TypeScript works really and when you build and deploy, It is a single package. There are no external runtime The big con is that you don't get that runtime sharing On the runtime sharing side, You deploy one application once on remote from that application The cons of runtime TypeScript sharing becomes from TypeScript to JavaScript, Unit testing can be a problem at the time of the unit test. And then there's the big one, Another application that gives you could make changes to that component and you wouldn't know about it issue as opposed to a build time issue Well I hope this video helps more about how module penetration works with Vite and Rollup applications as well, but I hope it helps you understand one of these architectures for your application, And in the meantime, of course, if you And if you really like the video, hit and click on that bell and be notified comes out.