Hello and welcome. My name is William and series focused on graph theory. graph theory science, we're going to see a lot of very diverse and hugely applicable to real world able to learn, love and enjoy graph theory. up the dose to introduce the topics of how a computer. By the way, this whole video series of view of graph theory rather than a mathematical on per se. Instead, we'll be looking at algorithm graph theory? In essence, it is the study which common folk or non mathematical folks and my goal with this video series is to teach situations. graphs can be used to represent because they pop up absolutely everywhere. graph theory problem might be given the constraints clothes Can I make choosing an article from and solved using only mathematics. But the us to visualize the problem using nodes to to represent relationships between them. Another is a social network of friends. A graph representation such as how many friends this person x have, between person x and person y. Now, we have are many different types of graph representations. to be able to recognize what type of graph programming and trying to solve a particular graph. It's the most simple kind of graph no orientation. That is, if there's an edge the edge from V to U. For instance, in the represent bi directional roads. Since if you retrace your steps by driving the other way. also directed graphs, sometimes called die the edges are directed. So if we have an edge to node v, not the other way around. In this because of the arrowheads on the edges between bought each other gifts. So an incoming edge edge represents giving a gift. Therefore, Person A bought themselves and Person B a and received none. So far, we've only seen contain weights to represent arbitrary values it. weighted graphs come in both directed will usually denote an edge of a graph as is coming from, where it's going to and what I also need to specify whether the graph is Next up, I just want to have a quick chat There are so many different types of graphs be most relevant for this upcoming video series. definitely the tree. A tree is simply an undirected definitions of a tree such as a graph with below are trees. Yes, even the leftmost one different type of graph is a rooted tree. has a designated root node, where every edge node. When edges point away from the root or an outreach and an anti arborescens or common than entries. From what I've observed. to a rooted tree simply as a tree instead distinction there. Next are directed acyclic and no cycles. these graphs are very important since they often are present structures with system, a compiler, maybe, or perhaps more There are several efficient algorithms that directed acyclic graphs, such as how to find ordering of nodes. A topological ordering you how to process the nodes of the graph completed all its dependencies. For example, would tell you to take intro biology and intro This next type of special graph is a bipartite into two independent groups, u and v such This is just a fancy way of saying that the odd length cycles and graph often, a problem we can create on a bipartite graph? Suppose then we can ask how many people can be matched edges in each graph. So I think the answer so easy if there are less edges, tougher constraints play a critical role in the field of network last type of graph is a complete graph is pair of nodes in the graph. A complete graph sub n, I have listed k one through k six on scales when we add more notes. Complete graphs graph you can possibly encounter, because to test your algorithm for performance, a thing we're going to have to be really cognizant graphs on the computer. This isn't just what structure it but what type of data structure are we representing on performance. The simplest way is inside cell MI j represents the edge weight of going there are four nodes. So I create a four by edge weights. If you look at the edge weight agitative to. So in a row three and column Note that is often assumed that the edge of zero, which is why the diagonal of the matrix several advantages. First, that it's very with a lot of edges, the ED Jwi lookup can nice. And lastly, I would argue that it is you can have. On the downside however, the matrix as their first pick, is because it lot of space. In practice graphs with 10,000 very quickly. The other issue with the adjacency to iterate over all the edges of your graph. edges. But it isn't so great for sparse graphs, to the adjacency matrix is the adjacency list, of nodes to list of edges. The idea is that For example, node C has three outgoing edges. from C to A with costs for the Add from C with cost to notice that, in the list of edges, we're going to and the cost to get there, from, because that's already implicitly known. it is great for sparse graphs, because it allocate additional memory that you might also means it's efficient when iterating over an adjacency list is that it is less space disadvantage is that it takes big O of E time in practice, you rarely or if ever actually The last representation I want to talk about is the edge list. an as an unordered list of edges. Basically, edges. Assume that the notation for any triplet v is W. So for this graph, the edge list is those triplets. This representation is very why it is seldomly used. advantage to the over all the edges is super easy, and the edge lookup can be slow, and you can run into going to talk about common problems in graph can often be reduced to a famous or well known to be able to familiarize ourselves with common Just before getting started falling off from graphs, I want you to think about how you the upcoming problems I'm going to describe, I'm describing directed or undirected, are is the common use case, a graph that is likely should I use an adjacency matrix and adjacency to represent my graph efficiently? So one problem in graph theory is the shortest path shortest path of edges from node A to node a road system, and were at node A and want should be able to find us a list of edges a minimal cost. Lucky for us, many algorithms including a breadth first search for unweighted a star and many more. As simple as it sounds, The problem can also be simplified to does this scenario, we don't care about the minimum reach another node? A typical solution to or do a very basic search algorithm such as Another common problem is detecting negative dealing with graphs that have negative edge exists, because if there does, it can throw and three form a negative cycle. Because if with a cost of negative one if you add up endlessly getting smaller and smaller costs. a negative cycle is like a trap that you can where negative cycles are beneficial. Suppose or multiple exchanges. Currency prices try exchanges, such as trading USD to euros or consistencies in the currency exchange prices. an arbitrage, which cycles through multiple and coming back to the original currency with a risk free gain. This is something we can negative cycles. There are two well known And those are Bellman Ford and Floyd warshall. finding strongly connected components within components of an undirected graph. But for connected components, we're looking for self vertex in a given cycle should be able to This is very useful in many algorithms as to know how to find these strongly connected algorithms to do so such as Tarzan's algorithm, science career without hearing about the traveling problem of having n cities and the distances path that visits each city and comes back example, if your graph is the one on the left, right, which has a cost of nine. The tsp problem challenging problem. This is unfortunate because applications. Some famous algorithms we can healed Karp algorithm with dynamic programming algorithm or you can use one of many many optimization. This next problem I want to which is something of a fascination to me. the number of connected components in a graph. are bridges. bridges are important in graph theory because they often in a graph, think of your graph as a telephone you can immediately see the usefulness of not the same articulation points, which are of connected components in the graph. In this points highlighted in pink. Next problem is A minimum spanning tree is a subset of the without any cycles and with minimal possible has no cycles, and it spans the graph at a minimum spanning tree. For example, in the trees is this graph with a least cost of 12. graph have the same minimal cost, but are trees are seen in lots of different applications least cost network circuit design, transportation approximation algorithms which rely on minimum If you want to find a minimum spanning tree schools prims, or beruf cause algorithm. This and it is about finding the maximum flow through a special type of graph called a flow network. represent capacities and some sense capacities cars that fit on a road, or the maximum amount even the number of boats a river can sustain types of flow networks, we often find ourselves source, that is cars, water boats, whatever, Assuming we start at some source and try and important, because at some point, there is flow graph that limits the amount of stuff it from point A to point B, the maximum flow the volume of water allowed to flow through the network and traffic or the maximum amount of boats problems, we can identify the bottlenecks edges that have lower capacities. We're moving algorithm, which plays a central role in several first search? A depth first search is a core to explore nodes and edges of a graph. So thing about a depth first search is that it's of big O of a V plus e, that is vertices plus edges, which is directly itself. A depth first search isn't all that tasks, such as count connected components, bridges and articulation points, the depth look at an example. As the name suggests, a graph without regard for which edge it selects point it backtracks and continues its exploration. node. And I'm going to start our depth first pick a node to go to some from node zero, nine, we only have one choice, which is to picking edge. So we're going to To go outwards of edges to choose from. So let's go to node So we don't want to revisit already visited So we have to backtrack to indicate backtracking, so backtrack all the way back to node seven. because there are still edges to be picked. three, I'm going to go node to node two is four, node four is also a dead end. So backtrack node threes last edge to go in Node five, seven, because we're visiting seven currently, from node eight, we still need to visit its back to node zero, we can't go to node zero, backtrack all the way to zero, which completes So this was one particular depth for search a lot of different ways. So now let's look to get a deeper understanding of how it works. these three variables, which are n the number representing the graph and visited a Boolean depending on whether or not node i has been have all false values because we have not is set up. At the bottom, I define our starting first search method to do the exploration. the current node we are at which I have conveniently the base case, which is whether we have already here and can return otherwise, let's visit all of its neighbors to explore all the neighbors and pull out all the neighbors of this node each and recursively calling the depth first search really is in a nutshell, let's look search. I want you to discuss finding connected what we mean by connected component. Sometimes components, and it's useful to be able to to identify these components might be to color coloring nodes really mean to a computer coloring nodes is equivalent to labeling each node is a component node in the purple component gets an ID of gets an ID of three, we can use a depth first make sure all the nodes are labeled from zero of nodes, the basic algorithm is to start if that node has already been visited, and the same component using the same ID. So if first search here and then every node in this eight, giving it an ID of zero, 14 gets zero like you do a depth first search, then explore exploring. That component and then move on next, then node one, so depth for search there. goes to 17, label it with a one, backtrack, finished exploring this component, then we is, then explore that component, then node node three has already been visited, and so we get to label all the components, and we So that's how we find connected components Now let's look at some pseudocode. For how we do this, first, everything from the previous code we looked G, our adjacency list, and our visited array, called count that tracks the number of connected that holds the integer value of which component method, we loop over every node and check and then execute some logic. This depth first in that we execute a depth first search for the depth first search, we visit nodes and the same node more than once we either skip for loop or start a depth for search there. the count variable and keep track of how many the depth first search method itself, the as visited, and set the current node to be count, then simply iterate over every neighboring the depth for search method to explore them simply return the number of components and about which component each node belongs to. use the depth for search for doing a simple But we can argument a depth first search to minimum spanning tree, detect and find cycles find strongly connected components topologically points find augmenting paths in the flow network So a depth research is super versatile, and Today's topic is the breadth first search first search the breadth first search algorithm algorithms used to explore nodes and edges big O of v plus e that is vertices plus edges, algorithms. It differs from a depth first The breadth first search algorithm is particularly path on an unweighted graph. A breadth first its neighbor nodes first before moving on the sense of breadth first search explores search at zero, we would visit zero first, visit all zeros neighbors, the nodes in yellow then we would visit all their neighbors and So as you saw a breadth first search expose by maintaining a queue of which node it should an example. Let's begin a breadth first search to the queue on the left. I will denote the node and we want to add Explore all zeros So we would add nine to the queue seven to no more unvisited neighbors. So we move on. all of nines unvisited neighbors to the queue. more neighbors of nine to visit. So we move seven, then we add all of sevens unvisited node 11. But note 11 is already in the queue, it, then we will add six to the queue and on and on until we run out of nodes in the And that's how you do a breadth first search we relied on a queue to help us track which new node, the algorithm adds it to the queue works like a real world queue, such as a waiting the waiting line that is get in queued or for the breadth first search. First things of nodes in our graph, and G the adjacency breadth first search function takes two arguments the search. The return value for this function I've divided the function into two methods by executing the breadth first search and So let's take a look at the solve method. first thing I do is initialize the queue data node to it. This queue should support at minimum then initialize a Boolean array with all false This array tracks whether or not node AI has then the node has either been visited or is animation this corresponds to the gray and an array called prev, which will help us reconstruct node. Initially, this array should be initialized the parent of node i was, so we can reconstruct is not empty and plot the top node from the inside the adjacency list and get all the node. Once we find a next unvisited node and keep track of the parent node of the next empty, and our breadth first search is complete, the breadth first search method take the output array and call the reconstruct path method. The first thing we do is actually reconstruct node and making our way back to the start reason the prep array had to be initialized way and checking whether or not the for loop array backwards, starting With the end node, so that the path starts at the start node we actually have to make sure the path between to reach node II from node s. If the graph return an empty path. Today we're going to find the shortest path on a grid. This is going to solve a problem. And I'm going to graph theory on grids. The motivation behind is that a surprising number of problems can a lot of the times turns into a graph theory a form of implicit graph, which means that our location within the grid. For instance, a grid problem you're trying to get from one to find a path that's a pathfinding problem. your way through obstacles such as trees, And this can be modeled using a grid, and around. A common approach to solving graph the grid to a familiar format, such as an we can easily work with them. However, this but we'll get to that. Suppose we have a grid both an adjacency list and in the adjacency label all the cells in the grid with the numbers product of the number of rows and columns. cells. So I labeled each cell with the numbers want to construct an adjacency list and an adjacency list doesn't require any setup because the adjacency matrix requires us to initialize graph, there are six rows and six columns how many nodes that are in the grid we're and cells connected left, right up and down. two, which we reflect in the adjacency list, one connects to node zero and node three, with nodes one, two, and five, and so on. And that's basically how you convert matrix. Once we have an adjacency list or run whatever specialized graph algorithm we the shortest path finding connected components, representations can usually be avoided due Let me explain. Suppose where the red ball right up and down to reach adjacent cells. at the row column coordinate r comma C, we comma one and zero comma minus one to reach trying to solve allows moving diagonally, one minus one minus 1111 and one minus one. neighboring cells from the current row column for north south east and west broken down we want to do is loop over each direction here I iterate I from zero to four non inclusive add the Row direction to the current row to our our the variable representing the new row, and column to make cc the new column position. cc is an adjacent cell. However, it might of the grid, and the new position is out of is within our grid by making sure that the equal to zero and doesn't exceed the number So if those two checks pass, then we know cell of our current position where the red technique is really nice, really easy to code So let's solve a shortest path problem on we just learned about. So here's an abridged during an interview or in a programming competition. inside a 2d dungeon and need to find the quickest which may or may not be filled with a rock. south, east, or west, you cannot move diagonally all sides. This problem statement is an easier caddis online judge see the problem link in size R by C and you start at the node with cell with an IE a cell full of rock is indicated are represented using a.in. This particular using this particular route highlighted in path to escape dungeon, not just any path, first search from the start node until we cells we traverse during that process. However, if we cannot reach the exit, so we'll have first search, we need to start by visiting Assuming we've already found the coordinate added to the queue. Then we visit the adjacent as well. And continue this process all the So I'll let the animation play And meanwhile, next. All right, after we find our end cell, the start to the end. Notice that we didn't bottom right cell is still unvisited, so it's interested in actually finding the path itself to escape the dungeon, then you'll need to for each node. Go in and re watch the last that. I want to talk a little bit about the first search. So far, we have been storing pair. This works well but requires an array values. In practice, this can require a lot from our queue. Let's look at an alternative dimensions, and in my opinion requires less I'm suggesting is to use one cue for each you would have one q for each of the x, y coordinate x one y one Zed one, then we would queues. So the x coordinate goes in the x As we need to keep in queueing different positions, way. This contrasts the approach of simply packed away inside an object. The one thing when we either end keyword dq elements, you queues all at the same time. So when I dq remove an element from each of these queues. with multi dimensional coordinates, which see if it works for you. So now that we have dungeon problem, let's look at some pseudocode. matrix into memory and did some pre processing The first two variables are the constants the input matrix following this is m, the are two variables s, r and s see the row column position of the starting node. search our Q and c q r to Q data structures will be enqueuing and D queuing elements from set of variables is to keep track of the number will actually track the number of steps taken we need to dq before taking a step and nodes in the breadth first search expansion so that In the next iteration, this will make more we have reached the N cell marked with an matrix the same size as the input grid to since we do not want to visit a cell multiple east and west direction vectors. To solve we'll need to execute our breadth first search add the start cells row and column values to mark the start cell as visited because done our breadth first search until both of the row q is greater than zero, but you can than zero since their sizes should always empty, I can dq the current position from position C, then I check if we've reached character in the grid is an eat. If it is break out early. Otherwise, we're not done neighbors of the current node to the queue, they'll do just that. Let's have a look. Here This is where we'll be using the direction Since cells have four directions we care about to four non inclusive, compute the new coordinate to the current position, make sure the new we could end up with positions like zero comma the new position is within the grid that does position might already have been visited previously, a cell that isn't traversable and full of then we can en que the new position to visit going to visit Make sure to mark it as visited multiple times in the future. Also increment we'll be needing shortly. This next block we took. Getting to the dungeon exit. Every the number of steps taken, we know how many of that in the Explore neighbors method. When zero, we know to increment the move count. we return the move count, otherwise, we return was not reached. So in summary, things we a grid as an adjacency list and an adjacency neighboring cells, we explored an alternative with multiple queues. And lastly, we looked grid to find the shortest path between two also called top source for short, we're going to discuss to find a topological ordering with some animation. world situations can be modeled as some graph have to occur before others. Some simple examples dependencies, event scheduling, assembly, Let's begin with an example. Suppose you're to take class Ah, well, before you can enroll and E. But before taking Class D, you must So in some sense, there appears to be an ordering take all the classes, the top sort algorithm which we should enroll in classes, such that have prerequisites for another canonical example build dependencies. A program cannot be built For example, consider this graph where each that one program depends on another to run. the right hand side, then we must first build need EMF. But to build those we also need programs without dependencies and then move ordering in which to build all the programs? One possible ordering might be to start by H, and then J. Notice that there are unused from time to time which is fine. So in conclusion, a topological ordering. On a directed graph. for which each edge from node A to node B. If it helps, this is just a fancy way of saying and have all the edges pointing to the right. orderings are not unique. As you can imagine courses, such that you can still graduate in a different order. Than you previously topological ordering. For example, any graph ordering. Well think of why this might be a cyclic dependency. Since there was nowhere another. So any graph with a directed cycle have valid topological orderings are called edges and no cycles. So a natural question not contain a directed cycle? One method is algorithm which can detect these cycles. Another that every tree has a topological ordering. cycles. and easy way to find a topological ordering leaf nodes. It is like you're cherry picking you do it. Once the root of a subtree has This procedure continues until there are no trees. But how about general directed a cyclic just repeat the following steps. First finding this node, do a depth first search exploring callback, add the current node to the topological Let's do an example. And things will become that we want to find one of many topological be keeping track of the call stack on the I will also be posting the current topological first step is going to be to pick in an visited Now we do a depth first search out towards where we can. Let's go to node j. Now that And so let's go to m. Now that we're at, there's nowhere left to to the topological ordering still at j and we still need to explore L. nowhere left to go. Also backtrack j and add frames getting popped off the call stack as to visit node i. So now we're at node i and then we figure out that note L is already again add AI to the ordering and mark it as as you saw selecting a random unvisited node made us this process until all nodes are visited. going to be node E in the interest of time and you can follow along. Note that if you ordering, he may not get the same values as unique. However, this does not mean you are play and try and follow along So that's it for that sub section of the graph. be node C to visit. So we start node C and Now that all nodes are visited, we have a the screen. So now that we understand how look like? Here's some pseudocode. For top first thing I do as I get the number of nodes as an adjacency list from the function, that which tracks whether a node has been visited the result that we'll be returning from this at the bottom of the screen. In the last slides index i, which tracks the insertion position As you have been seeing in the slides, we start at n minus one. Next, we're ready to in our graph. The loop variable called at processing. I then check if we're on a visit we care about. Then I started depth first an array called visited nodes, which I pass nodes as we find them. Then, after that's I look at the notes we found in our visited Now the last bit we need to look at is the first search method is very simple. All I be visited. Then for each edge going outwards node is visited, then call the method again. the callback when the method returns. This So this is where I add the current node to the output for this method. Back to the top the top sort algorithm works, there's a neat in terms of both time and space. Notice that block, we need to allocate memory for an array, we iterate over them to place them inside directly insert found node inside the orderings this additional work? Well, that's exactly the unnecessary array and modify the depth insertion position in the orderings array. orderings array so that it can be filled directly the new depth first search method, one thing value, and we're passing in some additional current node to the visit and notes array that note directly inside the orderings array. one, because the index of the current insertion one. So related to the topic of topological path. On directed a cyclic graphs, recall directed edges and no cycles. By definition, directed acyclic graphs, since they do not to you is, is this graph a directed acyclic this structure? I'll give you a moment to The answer is no. Because this graph has undirected may be a tree, but directed edges are a requirement great about working with directed acyclic path problem can be solved very efficiently. single source shortest path algorithm is dextrous negative edge weights. This algorithm I'm about positive or negative edge weights. The a topological ordering on the graph using video, and processes each node sequentially edge as it is seen. Relaxing edge simply means can be obtained using the current edge. Suppose can verify that it is in fact a directed acyclic path from node A to all other nodes in the we'll want to do is generate a topological the top sort algorithm. Below I have selected is the order we will process the nodes in best distance to each node and bond the screen, first step of the algorithm is to set the In this case, since a is the starting node, already there. From a we want to visit all update the value to be if it is better than step of the algorithm, we noticed that a value of three is better than infinity, so we update the value to see to be six. And now we've explored node node topological ordering which is B edge brings us to node E and we update its node B was three plus the edge weight to get get grayed out as they're being processed. Now, we've reached the first instance where the destination node, since a better path Now we move on to the next known or topological where we explore all the nodes trying to relax and the topological ordering. If we repeatedly will contain the shortest path from node A and you can try and determine the shortest not yet been processed. Okay, we're done processing to every note, let's verify our algorithm shortest path to node H. Indeed, if we look edges, you will find that they do indeed sum array for node H. There's a similar problem the longest path in the graph. This problem can actually be solved in linear time on a to be to multiply each edge by minus one, all the edge values by minus one again, to longest path, simply negate all the edges, answer by minus one. And there we go. That's look at some source code, you can find the Slash William is that slash algorithms. Here code for the shortest path on a directed acyclic graphs shortest path, and it returns the distance For some starting node, and as input, we give list. Of course, the starting node and lastly, we do is find the topological ordering for then initialize our distance array, and then And all we do is we loop through each node, our node index is Four Tops or so this is if that node is not equal to No, and then in our graph, and then pull out all the edges Make sure there actually are some edges. And which were the adjacent edges, then all we So we compute the new distance. So this is at plus the edge weight. So this is like the to improve upon, then we check, okay, has want to go? This is basically the equivalent give the new distance. Otherwise, we're going already there, and our new competing distance, this over here, and then we just do this over order, because we're pulling them out of the return that distance array. And we can get other node in the graph, just through a lookup algorithm. And that's all there is to shortest going to tackle Dykstra shortest path algorithm. in graph theory for finding the shortest path dive right in. The first thing to mention source shortest path algorithm for graphs. you need Specify a starting node to indicate Once you specify the starting node and execute path between that node and all other nodes on how you implement your Dykstra s and what is typically big O of E log V, which is fairly we see around. However, before we go crazy, you need to know which graphs we are allowed constraint for Dykstra is that all edges of weight. This constraint is imposed to ensure distance from the story node cannot be improved edge with a negative weight. This property the extras algorithm to act in a greedy manner note. For this slide deck. My goal is to help and also how to implement it very efficiently. implementation because it's by far the most of Dykstra has algorithm which uses an indexed operation. And lastly, I want to briefly mention the D airy heap to further boost performance the steps required in executing Dykstra algorithm. we'll need. The first is an array called dist to every node from the start node. Initially, of positive infinity, except for the index to zero. Additionally, we'll also need to the key value pairs will be node index distance next, based on a minimum sorted value. At by inserting the key value pair s comma zero the priority queue is not empty, pulling out pair as we go. After that, for each node we outwards edges and relax each edge appending the priority queue upon every successful relaxation. at which point the shortest distance to each maintaining. So that explanation may have at an example with some animation to put all assume node zero is always the starting node. in red is the distance I will be using it node to every node in the graph. In the beginning, to have the value of positive infinity. Since at the end of the algorithm, there's still we know that that node is unreachable. On pairs corresponding to a nodes index and the queue will tell us which node we should visit lowest value. Internally priority queues are going to show that visualization here. To start nodes index, which is index zero in pair zero comma zero into the priority queue zero with a best distance of zero, then the the priority queue for the first time and from node zero we can visit node one by using a best distance of four so we can update the dist array. Also add this information to the from node zero Just like the last note, we to from infinity to one. Additionally, add of one to the priority queue. So that concludes which node we should visit next day shows in the priority queue. To do this, simply priority queue. node two is the next most one from the start node, while node one has we take the upwards edge, we can improve the best distance from node two, which is one for a total cost of three, this is better time we find a better distance like this, queue, then we improve the best distance to The next most promising node is node one, by taking the edge from node one to node three node is node one with value four, but we have one. Since the disk array at index one has this entry in the priority queue. Having these is what constitutes to making this implementation we leisurely delete outdated key value pairs. to node four to be seven. We already found entry in the priority queue. Finally, visit of dynatrace. There are only a few moving keep track of is the distance array, which start node to every other node and the priority visit next, based on the best value found how this works. I'll be covering the real this pseudocode runs a Shor's algorithm from which tells us the shortest distance to every you which sequence of edges to follow. To that we will need to maintain some additional So in terms of the variables we'll need in first is G, the adjacency list of the weighted And s the index of the start node inside the to keep track of the information we'll need for visited which tracks whether node AI has the distance array which will be the output array with positive infinity except for the this initialize a priority queue that will by a minimum distance, you should be able programming language you're using. Remember a distance of zero into the priority queue why there are two sets of brackets, that's represent a tupple or an object with two values is not empty, remove the next most promising node as visited then loop over all the neighbors so that we don't visit them again. Then simply compute the distance to the new node which from the start node to the current node which cost of getting to the next node. Once you for the next node I update the value if it's pair inside the priority queue. So we visit standard priority queues do not support a You can think of a decreased key operation a key and the party cue. A way to get around pair every time we need to update the distance have duplicate node indices in the priority not ideal. But inserting a new key value pair for the key, we want to update in the priority searching for a key in a priority queue takes the keys values, not the keys themselves. unordered list for a particular element. And neat optimization we can do which ignores our priority queue is to skip them immediately. can do this by checking if the value in the the priority queue. And if it is, then we through other nodes before we got to processing bit. But this is definitely a neat optimization talk about finding the shortest path itself there. And to do that, we'll need to keep we'll want to keep track of the index of the node. The way to do this is to maintain a this array tracks the index of the node you array should be filled with a sentinel value edge relaxation operations, you want to update going to came from the node you're currently distance right also return the previous array of perhaps called find shortest path provide the end node index and execute Dykstra has array with these two bits of information, check that the end node is reachable by checking infinity, then start at the end node and loop you make it back the start node. You know value of null is reached. Since the start which came from the resulting path of node the start node to the end node will be in end node and worked backwards. Therefore, before returning the result. Now I want to talk about a few optimizations efficient. Sometimes we know the index of need to know the optimal distance to every node. So the question is do we still have out the distance of that one particular node But only in the worst case, which depending realization will need to make is that it is visiting the destination node. The main idea processes each next most promising node in been visited, its shortest distance will not terms of code, all we have to do to stop early end node and return early. This can prove on how early you encounter the end node while of dices is what we call the lazy implementation and leisurely deletes them. This is done because pair in logarithmic time into the priority value in linear time. The lazy approach works we end up with all these stale outdated key version of dank shows aims to solve this by efficient value updates in logarithmic time priority queue is a priority queue variant the priority queue in constant time, and updates This type of priority queue is extremely useful you watch my video on the index priority queue a link in the description. But in the meantime, indexed priority queue. Now we're going to algorithm where we don't have duplicate keys a distance of zero to the start node at index key value pairs zero comma zero into the priority node zero with a best distance of zero, then priority queue for the first time and we discover we can visit node one by taking the edge with so we update the best distance from infinity information to the priority queue. Next, we last node, we can update the optimal distance add node two to the priority queue with a the edges for node zero to decide which node promising node in the priority queue. So pull queue. node two is that next most promising the start node, which is better than five. to improve the best distance to node four from node two, which is one plus the edge cost of 13. We can update the best distance node to notice that I did not insert a new inside the party queue, but rather simply from five to four. This is the main difference The next most promising node is node one. to node two would discover that node two has it's already best distance. We also cannot the diagonal downwards edge since the total 13, which is already known for that note, node three by taking the edge from node one the animation play. And as it does try and will be. So that's the ingar version of Dykstra algorithm, implementing texturas algorithm. Now let's to change. First, notice that we're using priority queue. Also, notice that we no longer in an object because index partly queues have opposed to a priority queue, which you would library. The other thing that needs to change queue. If the key or note index does not yet otherwise invoke the decrease key operation pirna queue. The operation is called decrease the value if it is strictly less than the we've looked at several Dykstra optimizations I want to talk about and that is is improving using an indexed binary heap for our priority notice is that when executing dextrose, there on dense graphs than there are removal operations. node has at most D children instead of two, at the expense of more costly removals. So is a dairy heap with D equals four. Suppose we want to perform decreased key for node can do the update. And then we reposition bubble it up, and we bubble it up again. And only took a total of two operations. While root node, then we swap it with the bottom the purple node so that it's in position. the one with the least value and swap it and position. So again, we need to look at all and swapping. So that took a total of eight But remember, there are a lot more decreased removals. So this might be beneficial overall. dairy heap degree actually used to maximize the answer in general is that the value of by the number of nodes. This is the best degree key operations. In turn, This improves Dykstra base e divided by V of V, which is better, lot of decreased key operations. The last of the art when it comes to choosing the right the best heap we know of is the Fibonacci it or not a time complexity of big O of E in practice, the Fibonacci heap is very difficult amortized overhead. So it makes them slightly has to be very large, or you to see the benefit. cannot say whether they're that good, but Today we're going to have a look at some source All right, here we are in the source code in the Java programming language, let's have an edge class which represents a directed has a certain cost of taking this edge. And to the node which this edge comes from will list. So we don't need to take care of that. class, you need to specify the number of nodes the variable n. Once you know the number of create an empty graph, this simply initializes create an empty ArrayList with n nodes. And another list. So this is just an empty recency which you can do by calling this add edge graph you specify the node, the edge starts of taking that edge. Remember that the cost All right, and then there's the just this graph. If ever you want to have a look at which actually executes Dykstra is shortest I provide a start node and the end node. This node index to an end node index. Note that shortest distance to every node and not just can just remove this parameter, we don't really us to do a small optimization, which is to node. So let's keep it in for now. So in the we can use an indexed priority queue to speed what I'm doing below, I have an implementation avoid duplicate nodes in our priority queue, indexed theory per se, because I already have series, I'll make sure to have a link to that a min index theory heap, I compute the degree in the heap by dividing the edge count by that the optimal distance to the start node of zero, which makes sense, then I just initialize which is going to keep track the minimum distance a value of positive infinity, and I set that of zero, perfect. And then these are just II has been visited. And this prep array is path should we ever need to Alright, let's bulk of the Dykstra algorithm implementation. we're going to first get the ID of the node going to get the minimum value associated going to mark that this node is visited so this line right here, which says that the the priority queue is greater than the already the node we currently pulled out of the queue, found a better path of routing through another this node, which is fine. The next thing we from this node. So we can reach into our adjacency current node, then we check if the node this then we can skip that we don't want to revisit new distance of going from the current node reaching into the distance array grabbing and adding the edge cost then we try and relax is better than the distance already in the remember that originally, all the indices infinity. So the first time we visit any node, just do some housekeeping stuff. So Mark that came from the current node we're at and also distance, then we update our index priority going to a node for the first time or we try the current best distance to that node to check if we've reached our end node and if to it. So this is the optimization of returning of the algorithm, and the while loop has terminated a positive infinity. The rest of this class event that you want to actually reconstruct end node. And this is pretty straightforward, start at the end node index, then run Dykstra actually reachable from the start node, then reverse the path and return it as simple as graph theory. Bellman Ford is definitely one to trying to learn this algorithm, which is So what is the Bellman Ford algorithm? In algorithm. This means that it can find the other nodes in the graph. As you can imagine, is not ideal for single source shortest path complexity than Dykstra his algorithm. In proportional to the product of the number de show can do much better at around big O So when would we ever use the Bellman Ford fails. And this can happen when the graph negative edge weights, is possible that a it does, it is of critical importance that and we're using Dykstra is to find the shortest because the algorithm will keep finding better Ford and negative cycles is in finance and two or more markets, I'm not an expert. But are such that you can cycle through each market and end up with more profit than you originally gains. Let's look at how negative cycles can is a graph I made with directed edges, some node to be node zero. And our goal would be node in a single source shortest path context. negative cycles, I will label blue nodes as involved in a negative cycle, and yellow nodes way negative cycles can emerge is through once we reach a self loop, we can stay in before exiting. As a result, everywhere reachable which depending on your problem may either five are all reachable by node one. So they with regards to the single source shortest In this graph, a negative cycle manifests self loop. Instead, through a cycle of nodes up the edge values one four and minus six, the net change is minus one. If we look at the entire right side of the graph is affected. cycle. Now let's look at the actual steps we'll need to define a few variables. Let v be the number of vertices. let S be the short for start. And lastly, let D mean an from S to each node. The first thing we'll infinity. This is because the distance to no idea how far each node is. Next, we'll to be zero, because we're already there. The edge v minus one times relaxing edge simply the value from where the edge starts to where need to do. We loop v minus one times, then step, what we do is we look at the value of see if that's better than where we're trying path value. To actually detect negative cycles, is run the algorithm a second time, what we're nodes that update to a better value than the part of a negative cycle, and we want to mark Let's look at a full example. Here is a graph and find the shortest path to every other distance array D. Watch the values in this now, all the values in the array are set to the algorithm. In the second step, we set algorithm starts and we are on the first iteration we continue, I have an important note at the edges do not need to be processed in any particular and you process them with another ordering. on each iteration. But we will get the same I will highlight the edge currently being array whenever appropriate. Right now, the distance of five is better than a distance value updated to 25, because node one had edge from node one to node two is 20 for a to node five, and node six as well. By the been processed in this iteration. Next up, to 35. Because the best value in node two, then the edge from two to four updates to edge because it was able to update node two's in Node three, which is currently 35, adding value of 20. So this is all the algorithm operations. I'll let the animation play for So iteration one is over and there are eight I'll just play one more iteration. To give reset all the edges and start processing the updating happens in the distance array this selected the edges to be processed in a more the second iteration. If we fast forward to However, we're not done, we still need to algorithm a second time, same procedure, as able to relax edge, update the nodes value some edges until something interesting happens. two to node three, we are able to relax the than was previously there. So note three is will mark it as red. Similarly, note four indirectly, in the distance table, I do not by a negative cycle, and those which are primarily apart, feel free to add some logic in the this distinction. Continuing on, new two is also affected by the cycle is no nine on the by processing the rest of the edges. So that's it. For the first iteration, there this example, we happen to detect all cycles In general, you really need another eight cycle minus infinity values to propagate throughout on the order in which the edges are being ensures that this propagation occurs correctly. source code, you can find a link in the description fiza slash algorithms. Here we are on GitHub down and look for Bellman Ford, under the there are two different implementations, one one for a graph represented as an adjacency lists implementation. So in the edge lists a directed edge. And a directed edge simply to a node with a certain cost. Next, let's So from Bellman Ford, what we need is, well, just pass in all the edges. I'll also need starting node. And what we're returning is the distance array, and then populate it with then set dist of start to be zero. And then one time, then for each edge, just to relax here. Now this second pass of the algorithm a second time, so loop the minus one times instead of updating the edge to a value, we And this is a special value defined in Java what value you add to double dot negative Unless you add double dot positive infinity or something like that. And that's the entire array. If you look in the main method, it add some edges, and then run Bellman Ford to all other nodes in the graph. And that warshall. All pairs shortest path algorithm, how to reconstruct shortest paths, the handling So let's get started. In graph theory, the path algorithm. This means it can find the This is very important for many applications to run Floyd warshall is big O of V cubed, This makes the algorithm ideal for graphs Before we dive too deeply into the Floyd warshall and should not use this algorithm. This table and or constraints in the leftmost column, path algorithms. For example, you can see and Dykstra is can handle large graphs with warshall not so much. I suggest you pause and make sure you understand why each cell is the rightmost column since we're talking washout algorithm really shines in three places. all pair shortest path problem and detecting for other tasks, but there are likely better The optimal way to represent our graph is I will denote as the letter M. The cell m node i to node j. So in the image below, I and D into an adjacency matrix on the right. I assumed that the distance from a node to This is why the diagonal has all zero values. j, set the value in the matrix M ij. To be nodes are not directly connected to each other. programming language doesn't support a special infinity, such that infinity plus infinity infinity, then you should avoid using two If you do so, then you will likely get integer as we will see the main idea behind the Floyd you want to compute all intermediate routes Suppose our adjacency matrix tells us the Now suppose there exists a third node C, if less than a distance from A to B, then it goal is to consider all possible intermediate we can have something like this where the C, then going from C to B, but in the process, I labeled with a question mark, because we've B and I know that it involves an intermediate paths with more intermediate nodes between are also not just limited to one intermediate have several like in the graph below. Now the question comes up, how do we actually is we will use dynamic programming to cache dimensional matrix of size n by n by n, which that the cell dp at K IJ in our table gives routing through nodes zero through Kyt. What then k equals one, then k equals two and so rounding through zero, then all optimal solutions solutions writing through 01, and two, and point we have solved the all pairs shortest how to populate the DB table. In the beginning, the distance given to us in the adjacency is equal to m ij, the value of the edge from can be summed up with the following recurrence we can understand all its components. Because hand side of the recurrence simply says, reuse through nodes, zero to k minus one, it's important to k minus one is a partial solution. It is dynamic programming aspect of the Floyd warshall finds the best distance from i to j, but routing from zero to k minus one. If we analyze the it basically says, Go from itk then go from You start at I route through some notes and Currently, our algorithm uses big O of V cubed for each of k, i and j. This isn't particularly k starting from zero, then one, then two, here is that previous results build off the to compute state. Okay. That being said, it in place, saving us a dimension of memory of v squared. Now we have a new recurrence This has been replaced by the fact that we're inside our matrix. Okay, that's all the theory we need. For now, pseudocode. Below is the function that actually executes a Floyd warshall algorithm. But before variables I have defined in the global or these functions. The first variable is the 2d memo table that will contain our all pair D table that we will use to reconstruct our warshall function, you see that it takes one representing our graph. The first thing I So let's take a look at that real quick. So first thing I do is I allocate memory for same type as the input adjacency matrix. What matrix are represented as real numbers, then the next matrix will contain indexes of nodes running the Floyd warshall algorithm. It is with null values inside the four loops, all matrix. Think of this as the base case or matrix, if the distance from i to j is not want to go to from node i is node j by default. In here after the setup, loop over k on the the exterior loop. Since we want to gradually then k equals one, then k equals two and so nodes i and j. Inside the main body actually path from itj going through K and update the through K, also inside here, update the next next ik, the last thing I want to do is to is an optional step if you know that negative your graph. Although I still recommend you too far, I want to discuss negative cycles obvious. So consider the following graph. consider here. Nodes directly involved in cycles. This red node is the cause of a negative and obtain smaller and smaller costs. While cycle. This however, doesn't mean they're As we will see, negative cycles can also manifest like the following. So an important thing from node i to node j go through a red note. cycle and is compromised. For example, the infinity. Because I can go from zero to node cycle consisting of nodes, one, two and three, going to five. This is a consequence of traversing paths however, avoid red nodes altogether, This doesn't involve any red nodes, so we from four to six is indeed two. So to identify j is affected by a negative cycle, rerun the best distance is better than the already known set the value in the matrix from it j to be ij in the next matrix with a minus one to cycle. We will use this shortly. Back in the is return the matrix dp which contains the node. This is the solution to the all pairs to cover is how to reconstruct the shortest method returns the shortest path between the is a negative cycle for Check the distance infinity, if so then return an empty path. called act to track the current node. And the current node to the path as I go. During has the value minus one. If it does, then a red node and is trapped in a negative cycle. method has three key returned values, and end nodes are not connected, a null value And lastly, a non empty path or node indices Today, we're going to be looking at some source path algorithm. Here we are in the source let's get started. Let's start by looking solver class to actually find all pairs shortest thing I do is I actually initialize a graph I create our adjacency matrix by calling the here, this is the Create graph method. And size n by n, it fills the matrix with the also sets the diagonals have all zero nodes, the behavior you want. If it's not, then that's it when you add some edge values to your adjacency added some edge weights. And then what you'll give it our adjacency matrix, and then call which will return the all pair shortest path And then here, all I do is I loop over all shortest path from node i to j is. Here's there can be roughly three different kinds there does not exist the path between the a negative cycle. So that is negative infinity. this is how we're going to do it. Don't be printed on the screen. So here, I want to pairs of nodes. So I loop through all pairs again, I call reconstruct shortest path from here, I just print three different options is no, then there does not exist. Or rather, solutions. If the path has zero length, there pretty formatting of the output. And this what the path would be between all pairs of from node to our node zero to no two in our it does, it just prints all this information useful. Okay, so what is this Floyd warshall going to look at right now. So inside that class, we have for instance adjacency matrix, a boolean value called solve, all pair shortest path problem or not our to reconstruct the paths, and, oh, there's to minus one so we can identify when we've the constructor, you just pass in the input So simply allocate memory for our matrices the DP matrix with whatever is given to us the next matrix to contain j as the next value to do for the setup, nothing too complicated. provided in this class. The first one is get first method we called. And what that does path problem already, and if not a call is if we want to get the all pairs shortest path to run the solve method several times. So rather executes the Floyd warshall algorithm. all pairs of shortest paths. First, we iterate loop through all pairs of nodes, and then going from i to k and then k back to j is the value of i to j to route through that the next matrix so that we can reconstruct to go through igk than i to j. So update the This next loop is if you want to identify means that we need to propagate the value for every part of the graph that reaches a upon the already optimal solution, then we somehow, and that that particular edge is infinity. That is again one of the special the next matrix to also mark the node as being next stores integer values, we can't give double. So give it the value minus one stored done, we have fully executed the Floyd warshall of salt as true. Now if we look at reconstructing some ending node, what we want to do is if and then initialize a value called path to to reach the end node from the start node. populate the path with the current node which current node, check if we reach into a negative best value or sorry, the shortest path doesn't of shortest paths. And also make sure to check of an infinite loop and simply return the how to develop an algorithm to find bridges from a computer science perspective. For starters, bridges are sometimes also called cut edges. a connected component, a bridge is an edge connected components in the graph. The name connected components as islands, then a bridge this graph below, there would be three possible if you remove any of them, the graph is divided also called a cut vertex is very similar to an articulation point is that it needs to number of connected components. As an example, points, since removing any of these vertices to think more about bridges and articulation in graph theory. In a real world situations, at bottlenecks, or vulnerabilities or weak to be able to quickly find and detect where how to find bridges and then slightly modify In the simplest way I can explain it. This find bridges in an undirected graph. First, a depth first search traversal labeling nodes During the traversal, you will need to keep ID, which I just mentioned, and the other first search and bridges will be found. Where is less than the low link value of the node, the lowest value of a node is defined as the currently at when doing the depth first search, is an interesting concept we'll get back to Suppose we have the following graph we've all the bridges are. Let's begin our depth As we do our first search, we're going to place inside the node i will also mark nodes which are blue as unvisited. So let's finish nodes transforming undirected edges into directed as visited. So that will conclude our depth first search, all the low link values would be for these a node is defined as the smallest ID reachable values to be equal to each nodes ID. I placed of that node. If you inspect node one, you be zero because there exists a path of edges zero has an ID of zero. So we can update node two is low link value should also be zero. a path however, nodes three, four and five because there's no other node they can reach value can be a bit to five since there is sequence of edges. And we can also update same logic. So in general, when we look at the ones which form bridges in our graph are that is less than the low link value of the about why this is true. Let's look at where the idea of the node with a directed edge of the node, it's going to rephrasing that connecting back to the start of the component, is. Otherwise, if there was an edge connecting loading value of where the edge is pointing the node, you started that because it would from node eight to node two, suddenly, the a bridge, because the loading value on node highlighted in teal no longer holds. Let's of the algorithm I just presented. Right now all the nodes plus v more depth first searches v times v plus e in the worst case, if you're programming. Luckily, however, we can do much better than in one pass for a linear time complexity. this in linear time. I'll show you some actual get started. In the global or class scope, which I use to label each node with a unique G. The last is n, which is the number of nodes are three arrays, which tracked information of these arrays represents node i in the graph. The second array tracks the load link value of whether or not we have visited note I. actually finds the bridges. In the method yet been visited by our depth first search. in our graph even if our graph consists of into the depth first search method which is argument is the current node you're at, which set to minus one because there is no previous we are populating. So here we are in the depth to the method or just as I describe them to current node ID, then comes parent, the previous pairs of nodes which form bridges in a flat I simply do some housekeeping stuff which the ID value variable and assign the current Then we get into the actual depth first search from the node we're at and attempt to go to this is an undirected graph, there is bound node we were just previously at, which is So we continue on those cases. If the next recursively call the depth first search method. functions which differ ever so slightly, the what propagates the low link values, while already visited node, which has a chance of value. Then the last bit just checks if our of node IDs to the bridges array. All right, action. Suppose we have the following graph somewhere. Let's start at node zero and explore something interesting happening, we're trying two is able to reach node zero from where that was the second main statement executing. takes us downward. Now we get to explore the Again, we have in an edge which reaches out to update our loling value for the current node sevens loling value to five, on the callback instance of the first main function actually context. The red box is the line which was saw, it gets executed for every node on the And now we have the same result as before, here are all the bridges that we found. Perfect. Now let's move away from bridges points by modifying the algorithm for bridges. articulation points is that on a connected an edge UV is a bridge, then either u or V point because it allows us to easily find consider the following graph, you will notice and one, meaning that either node zero or this condition is not sufficient to capture where there is an articulation point, but the following graph, node two is an articulation graph to split into two components. So the And the short answer is that it has to do let's look at an example. Suppose you're traversing a node zero. Initially, suppose node zero any depth, Research, you would continue on ever encountered the node that started the throughout the cycle during the call back. because we're reassigning the new loling value and the ID of the node we were just visiting. of zero, acquired from the ID of node zero. say, throughout the cycle. Now, what you'll notice is that the ID of loading value of where it's going to this here is that the presence of a cycle implies is because a cycle and a graph corresponds the node which started the cycle, who is also the graph in two. However, there's just one node you choose has either no outgoing edges, edge. This is because either the node is a with zero outgoing edges, or the notice trapped edge. To be an articulation point, you need in the graph on the right, we start a node point, despite our condition of the ID equaling add another edge to our starting node, it something to watch out for and is unique to look at the changes we need to do to our finding To begin with, we'll need a way to track the has so I define a new variable called out called is art, which has true or false depending point. Ultimately, this will be the return the body of the find art points function, connected component. And after the depth first articulation point or not based on how many first search method, all I added was an if edges from the starting node. Besides that, points found via cycles and kept the less via bridges. In a real implementation, you clause. However, I want to distinguish finding from cycles. In today's video, we're going points in bridges, but this time with actual source code find bridges, we will look at shortly. So this source code is written in have a class which will find all the bridges list. But before I get into the details of code works and how we're supposed to use it. the graph. But before we even do that, I'm some of the methods used to actually create first method will create a graph with n nodes. which is basically an adjacency list with new ArrayList. And then fill that list of graph. That's our graph for now. And then add edges method to add directed edges into from a node to a node and then to that node, from into, I use from to mean the the node, the edges going to. So in this example, I have a graph with nine I create the graph and then add all my edges, the graph from the slides in the last video. to pass this graph and the number of nodes our solver. And then the solver is going to all the bridges as a list of integers. Then are going to be stored as pairs. So every are going to be bridges. So I pull those out, would expect for this graph. Alright, great. here. So let's scroll up to the constructor. variables. So we have n, which is the number number to label each node. So we're gonna keep track of well, what was the last ID, about the nodes. So low is for the low link node, we gave a node with the ID variable, or not the node was visited. And finally, get the graph and the number of nodes, it is legit. Okay, so now we've constructed the we're interested in is find the bridges. So variables. So set ID to be zero, initialize and the ID values and the visited array. It's constructor, just because if you just create you might surprise the person initializing usage, then initialize the bridges array to into the depth for search method. It gets for each node, or node ID right now, loop been visited, yet started depth first search method with eyes The first argument so the then pass in the bridges array. So some housekeeping visit the node, and then we're going to do value, and the ID of that node to just be then we visit from from the current node, the node that we were just at. So that is depth first search and then immediately returned those cases. And we'll do this because we you haven't visited the node yet, then recursively probing While if you have, if you're trying you want to take the minimum of the current to. Otherwise, on the callback of depth first statement, which differs from this one slightly now not of the idea of the node, but the low the slides, the condition for bridge is if low link of the node, we're going to this will cause the number of connected components are the node IDs of the bridge, and put them then eventually return that down here. So articulation points, which is really almost the only thing that's really different is outcoming edges from the start node or what than that, differences are that we have another instead of the bridges array to track bridges. edges for every depth first search we do. Oh, yes, we have a less than or less than two track cycles as well and mark off those are the major differences for didn't forget Oh, of course, we have to count the number important. And here's the same graph as before, articulation points. So some very subtle differences but still very important ones. Today, I want is strongly connected components, and how So what are strongly connected components contained cycles within a directed graph, can reach every other vertex in the same cycle. four strongly connected components. I've outlined each strongly connected component, you'll cycle and that for each component, there's and comes back. Because of that property, are unique within a directed graph. To understand we're going to need to understand the concept is the smallest node ID reachable from that we're going to need to label the nodes in we start at the top left corner and label exploring that graph until we visit all the Alright, now that we're done labeling the the low link value of each node. Again the ID reachable from that node including itself. should be zero since node zero is reachable node for us low link value should be three reachable from note four. So if we assign setup. From this view, you realize that all you belong to the same strongly connected strongly connected component, we can clearly values are the same. This seems too easy, catch. The flaw with this technique is that of the depth first search, which for our purposes, I rearranged the note IDs, as though the depth node. In such an event, the loling values all the low link values are the same. But components. So what is going on? Well, what's dependent on the order in which the nodes we might not end up with a correct arrangement us which nodes are in which strongly connected kicks in with its stack invariant to prevent with each other's low link values. So to cope first search, Tarzan's algorithm maintains which to update low link values from how the stack as nodes are explored for the first each time a strongly connected component is u and v are nodes in our graph, and we are low link update condition is that to update value, there has to be a path of edges from small difference we're going to make to finding of finding all the loading values after the our depth first search on the fly, if you time complexity. We'll be doing an example in the following Start out and mark each node as unvisited don't stop until all the nodes are visited. a low link value. Additionally, also mark stack. On the depth first search callback node is on a stack than men, the current nodes and value. This is essentially what will allow After visiting all nodes neighbors, if the component, then pop of all nodes from the component. You know, a node started a strongly its loling value. I'll let you think about Let's do an example. I'm going to mark unvisited search is still exploring some neighbors as has explored all of its neighbors as gray. it is on the stack and we can update its loading are on the stack in the left column. So keep start our depth first search. So just randomly unvisited nodes give each node an ID and a at node two and our only option is to now visited, we don't want to visit it again. Since node zero is on the stack, we take the and node zeros low link value. Similarly, were just at, which is node one with node returning back to node zero, we realize that component. Since we visited all the neighbors low link value. This means we need to remove component from the stack. However, we're not node at random. Let's start at node three. down. Now we're at node five, let's take the visited. So we can't go there. On the callback, at the moment. So we can't min node five is very, very good, because if we did, then we node five as part of with a lower low link go to node six. So now we have three edges right, node two is not on stack. So don't the left edge to node four, node four is on giving node six also a low link value of four one going to node zero. This is a situation can't min with its low link value. On the low and value because it is on the stack. four, we've visited all its neighbors and marks the start of a strongly connected component. in this strongly connected component from nodes. Now coming back to node three, we cannot min just removed node four from the stack. You to its loling value. So it should be the start we have not finished visiting all of node just yet. Now see the downward edge to visit On the callback, notice that node five is low link value. Now up to node three. On the since node three is on the stack. Also man the last strongly connected component, all from the stack. And that's how tyrosianse components. Very beautiful, isn't it? Let's I think it will solidify your understanding. I define a few variables that we'll need. nodes, then comes n the number of nodes in edges. Both n and g are inputs to this algorithm. an ID and s cc count to track the number of a few arrays which store auxilary information is IDs which As the ID of each node, then on stack to track whether or not a node is itself, which should at minimum support, push method. The first thing I do is assign the will be serving to track whether or not a ID is. In the following loop, I iterate through a depth first search on node i, if node AI the array lo an array of Boolean values, which Now let's look at what's happening inside where all the magic happens. So this is the input argument to the depth first search method the ID of the node we are currently at. On stuff, which is add the current node to the stack, and give an ID and a little link value where I visit all the neighbors of the current as an adjacency list and loop over a variable node we're going to the next line says that visit ID. Remember, the IDS array tracks the AI has been visited. This next slide is very important line on the slide. The first thing the recursive call to the depth first search on the call back from the depth first search is on stack, than men, the current loling what allows the loling values to propagate for loop that visited all the neighbors of at the start of a strongly connected component. connected component check if the ID of the for that node. After we have identified that connected component, pop off all the nodes the stack. As we're popping nodes from the on stack. One more critical thing we need stack is make sure that all nodes which are have the same ID. So here I just assigned node which started the strongly connected off nodes from the stack once we reach the and also increment the strongly connected number of connected components that were found. code for Tarzan's strongly connected components for Tarzan's algorithm to find strongly connected code is written in the Java programming language. constructor for the class. And you'll notice as an argument. But before we get into the show you how the algorithm actually works So if we look at the main method, you'll notice be used. You set up the graph and then you a variable called n which is the number of Then you create the graph. So this initializes, at that Create graph method up here, all the and then populates that with empty lists, directed graph. So if you want to add an edge give it the graph, give it the directed edge. will add that edge to the graph. So I believe very last graph, if I recall correctly. So to actually find the strongly connected you give it the graph, and then you run the finds the strongly connected components. And values, then what I do is I dump all of these connected component, which are the nodes associated I do is I print out which groups which nodes there are three connected components. And they belong to. So that's how you use the already went over the constructor, which passes and caches the adjacency list. as other instance tracks whether or not we have already solved number of strongly connected components and whether or not a node is on the stack, and each node and the low link values of each at the SEC count method, it runs the solver the number of strongly connected components. if it has not yet been run, and returns the solver itself. So it returns if it's already work than we need to. Inside the solve method, IDS array with the unvisited token. So we or not. Recall that the IDS array keeps track of whether or not a node has been visited. is unvisited then start a depth first search the strongly connected components for this it's almost exactly like the slides. So do the current node on the stack, mark the current node and ID and the loading value because over all the neighbors of this node, do a to is unvisited on the call back check if value with where we were just at. And back of the node, then we check if we're at the if we are we want to pop off all the nodes which are on the stack. So I start with a I return back to the start of that strongly nodes from the stack, I mark the node as no every node part of that strongly connected started the strongly connected component. nodes belong to it strongly connected component, connected components in case we are interested algorithm in a nutshell. Hello, and welcome Salesman Problem with dynamic programming. First is how to find the cost of the best All right, so let's get started. What is the it's when you're given a list of cities and and you want to find the shortest possible then returns to the city of origin. In some given a complete graph with weighted edges, A Hamiltonian cycle is simply a path which you will probably want to represent whatever simplicity, if an edge between two nodes does positive infinity. So in the graph I had, of going from A to D to C to B, and then finally, that it is entirely possible that there are will all have the same minimum cost. As it Problem is extremely difficult. In fact, the meaning it's very difficult to find an optimal approximation algorithms exists, if you want even for large inputs. So the brute force all possible tours. And this means we have which will take big O of n factorial time, listed all the permutation of nodes and highlighted The dynamic programming solution we're going to develop today is able the complexity to big O of n squared times seem like a substantial improvement. However, give or take feasible for modern home computers. to the N. At first, you notice that n factorial changes favor to n squared to the n, which factorial. You can already see that how large n equals 15 versus the n squared to the N. this problem using dynamic programming. The solution for paths of length n, we will have and minus one. But before we get started, talk about. The first thing we're going to matter which notice picked, just make sure n non inclusive. Suppose we have this graph node to be node zero. The next thing we need starting node to every other node. This will paths with exactly two notes. The optimal the input through the adjacency matrix. And if you want to look at it, we can see that to two, and finally zero to three. In the for n equals two. But what is it we really first is obvious. And that's the set of visited other is the index of the last visited node tour, we need to save which node was the last that partially completed Tor. From that node is very important. So together these two things, the last visit node forum, what I call the n possible last nodes, and to the power of by big O of n times to the n. An issue we're state is representing the set of visited nodes. is to use a single 32 bit integer. The main we flip on the eighth bit to a one in the advantage to this representation is that a for easy caching in a memo table. For example, zeroeth and first nodes, so the binary representation the right, similarly, the binary representation nine in decimal since nodes zero and three to expand on our previous state. One particular below. What we want to do from our last node, which all other unvisited nodes. These are the gray a little longer, with three notes. For this an additional two states. But we would also not just this one with zero, and three. In states four partial tours with three nodes. and longer paths until all paths are of mine. the Traveling Salesman Problem is to reconnect To do this loop over the N state in the memo the start node, and minimize the lookup value the end state is the one where the binary each node has been visited. It's finally time Salesman Problem. Just a heads up to everyone make use of advanced bit manipulation techniques. shifts ands ORS and x ORS work. Here's the Problem. It takes two inputs. The first is the input graph and s the index of the starting the matrix and stored in a variable called Then we initialize the two dimensional memo the power of n, I recommend filling the table throw runtime exceptions. Then we're going min cost and find optimal tour. Let's begin method. The setup method is very easy, it ago. by storing the optimal value from the each node skipping over the start node. And AI, which can be found in the distance matrix. I and the mask with bits s and I set to one, green node is the start node and the orange You notice now that the orange node is never a continue statement to skip that case. Now The solid method is by far the most complicated, The first line in the method loops over r as the number of nodes in a partial tour. The next line says for a subset in combinations, sets of size and with exactly our bits set When calling the combinations function with different bits sets, each distinct and with a subset of visited nodes. Moving on, notice that I enforce the node the subset of nodes is not valid since it node. Notice that this if statement calls of the slide. All it does is it checks if loop over a variable called next, which represents must be part of the current subset. This may generated by the combinations function has is why the variable state on the next line This is so we can look up in our memo table is when the next node was not yet in a subset. other partially completed tours is essential algorithm. The following variable to consider of room this variable is quite important because the scope of the inner loop, we try all possible see which end node best optimizes this partial of the start node, the next node or not be part of their current subset that we're So we compute the new distance and compare is better than the minimum distance, then Once we've considered all possible end nodes best partial tour in the memo table. And this question in this slide is how the combinations unanswered. So let's see how this gets done. might imagine, for what it does. What the up the subsets array using the second combinations does the second the combinations method do? tutorial, backtracking the power set if you rundown of what this recursive method does, is zero, you want to set r out of n bits to keep track of which index position you're position to a one and then keep moving forward, bits. But if you didn't, you backtrack flip to the next position. This is a classic backtracking is how you solve it. But I don't want to focus get back the Traveling Salesman Problem. Watch more guidance. If you're lost, I'll try to So right now in our memo table, we have the nose. So let's see how we can reuse that information is going to be to construct a bitmask for in our memo table. The end state is the bitmask by doing a bit shift and then subtracting Then what we do is look at each end node candidate at what's in our memo table, and the distance The last method we need to look at is the is our algorithm if it cannot actually find what we're going to do to find the actual and do lookups in our memo table to find the last index we were at. And the current state we loop over I from n minus one to one which actually find the next optimal node going index which will track the best note the inner candidates for the next node, we must ensure of the state meaning it has not yet been visited. variable index will be set to minus one. So values of the best distances between nodes better. Once the optimal index is found, store bit in the state which represents the index of the tour to be as the starting node because then simply return the tour. And that is how dynamic programming. Hello and welcome to with dynamic programming. Today we're going here we are in the source code for the Traveling This is the iterative implementation. If you there is also a recursive implementation if is in the Java programming language, but you to any programming language. So let's get we're going to have to create this object it has two constructors, one with a distance constructor is the distance matrix, but also I have the starting node to be zero, but you And then I simply store how many nodes are cases, I haven't supported n equals two yet, then just check some edge cases, make sure kind of stuff. And then I cache the start variables. And then here are the two methods Get a tour, and it returns a list of integers graph. And this other method called get tour that they both call the solve method if the the solve method in the constructor. But that's in the constructor. So I leave it up to the explicitly call it yourself doesn't matter. the traveling salesman person problem. So the first thing I do is I initialize a the state with all nodes visited. So all bits of size and times to the end, and it takes is filled with null values. And then I do from the starting node to every other node, first step in the slides, if you remember value in the adjacency matrix. Then we start of path that are one a longer. So R is once completed tour. Then we loop through all subsets function, which is below. I guess I'll jump this method basically generates all the bit one. And then you can see that the result So this is the combinations method and then down here. So ignoring this part, which is we've selected exactly our elements, then add it to our subsets array. Otherwise, we and then backtrack and flip off the ice bit. sure that the starting node is Inside the to create a valid tour. Next, Next, we loop over the variable called next, to be our next slide target nodes, the one we make sure that the next note is not the it is in the subset produced by the combinations in it. Then we generate the mask, which is the state or the partially completed tour off the next node and set it to zero. And table later on. So we can compute the new variable called min distance, which I initialize we're trying to minimize for the next node. end node, which is not the start node, or calculate the new distance from the end node the end node to the next node. And then if or sorry, the just the min distance we declared And finally cache that in the memo table. here. But we're not done yet. We still want minimum cost of the optimal tour. And to do over the starting node. And, and then do a and the state and state. So we finished a go from I, which we ended on back to the start minimize over this variable and update the see was one of our instance variables, which this. And this is why it gets returned on this finds the minimum tour cost. And this actual torque is, which is really useful, table at the values we've computed. So we and it initialized the starting node, because want, when we do the tour, we end up at the state. So we're working our way backwards. going to slowly, I guess, reduce our tour So in our tour, we add that starting node. And this variable i is just for, for counter. So we loop n minus one times and for this we want to to go to next. So it's the best that next best node, we need to look at where go to the next best node which is going to nodes, if you will start j at zero and loop to the start or is not in the state, because And if index is minus one, then it's the first to J. Otherwise, look at the previous distance. and then if selecting node j gives us a smaller to be J. And, and doing this for all of the backwards, then we want to add that nodes bit off, and then set the last index to be and basically starting from a fully completed the starting node again. And at the very end, and then reverse the order of the tour. This at the end state and then working our way order. So we want to reverse the tour order. And tour if we look up here was just a list when we call get tour. The only thing I did just checks if a bit or the element was not equal to zero. Today we're going to talk about science perspective. We're going to start are, how to determine their existence, how at some code to wrap things up. Let's begin is. an Euler path, also called an oil area and every edge exactly once. Suppose we have the an Euler return path. First off not every but even still, we need to be careful about begin the path at the middle rate node and began and finally left this completes the at the top node. What happens if we decide the edge going down, you'll notice that we from this node since there are no edges left that we have unvisited edges that we still to resolve or rather avoid this issue altogether path when we no one exists. Moving on let's oil arian cycles and oil arian circuit is on the same vertex. So similar to oil arian but the following graph does. If you know you can begin the circuit at any note. I'm and also end it on the orange note. And that's the full circuit if your graph may not be able to return to the start node Be able to visit all the edges of the graph. from the same node on this slightly modified So by randomly selecting edges to traverse, node. Furthermore, we also have unvisited we don't have to guess whether or not a graph circuit, we can inspect the graph we're dealing each node to determine whether or not the table. There are four flavors of or Larian those are whether the graph is directed or find an Euler in path or an ordinary circuit. So I want to have a quick look at that before means different things depending on whether undirected. In an undirected graph, the node to a particular node, the blue node in this it's degrees three in a directed graph, there degrees and out degrees. Because the edges of incoming edges to a node and the out degree from that node. So in the example on the right, out degree is one pretty simple. Coming back the constraints required for each variant problem. However, let's go over them one by an undirected graph and we want to find an is that every node in the graph has an even graph is very similar, except that in addition also have exactly two vertices which have exist, would be the start and end nodes of can have an Euler circuit if every vertex counterpart to the undirected graph version. on a directed graph for there to exist in most one vertex has an out degree minus and one vertex as an indie GRI minus out degree have equal internet degrees. So it's now Quiz paying attention. I'm going to present to whether the following graph has an oil layer So we'll start with undirected graphs, and feel free to pause the video to think things or circuit you can tell because there are this graph? Again, feel free to pause the the green nodes represent the valid Start for the oil arian path. What about this graph? an oil arian circuit. As a side question, circuit, it also has an oil arian path like is true. Any circuit is an oil arian path. circuits in this graph? This one is a bit in paths or circuits here and the additional when finding paths and circuits is that all to a single connected component and here We have an overlay or in path or circuit. Now graph. Does the following graph have any or a moment to think about it. Yes, this graph because all in and out degrees are equal. arian paths or circuits. The red nodes either an oil arian path or circuit to exist. What time because there are a lot of edges. This graph only has an Euler path, but no and end node for the path. Note that the singleton it doesn't impact whether or not we have an how to algorithmically find oil, Larian paths paths and or they're in circuits are actually undirected graphs. If you have an algorithm arian circuit comes for free, all you need in circuit into the oil area and path algorithm reason. Today we'll be looking at an algorithm graph. So the first step to finding an oil maybe it's impossible to find an oil arian graph. And it's good to know that before you that for now, or they're in path to exist, equal to one and at most one vertex has in other vertices have equal in and out degrees, of each node. By looping through all the edges, in and out to track the in and out degrees the integral of a node if a node has an incoming an outgoing edge, and so on for all the other edges. Once we've edges, or too many incoming edges, and there nodes, we can be certain that our oil arian starting node. Because we can't start the node one is the only node with exactly one starting node. Similarly, node six is the edge so it will end up being our ended node. then we have an oil arian circuit. And we which has a nonzero degree. So we have everything what happens if we try and do a naive depth possible until we get stuck. Let's begin at first search. Let's take a write another write right again, you'll notice that even though that we knew in oil arian path existed, and end node that we still did not find the valid the edges. So what's going on? Well, what's search wrong, we need to modify the depth first search to visit all the edges of our smaller graph. Suppose we start our depth an oil arian path. Suppose we take the edge takes us right. Again, this causes us to accidentally which we know will need to be part of the worry about it and keep executing our depth the current node has no unvisited outgoing to the solution. So four gets added to the just at. We are stuck again because node three So we add three to the front of the solution node has any remaining unvisited edges, that our depth first search method recursively the edge up to node two, and then there's take that one too. Now we're stuck again, what we do is we backtracking add the current we do this until we return to the start node how we forced the depth first search to take edges on the recursive call back until no previous example. Let's restart the algorithm. edges, we still have left to take at each number of outgoing edges for each node in be needing the inner array anymore once we we can ignore it. Let's begin at the starting to do slightly differently is that every time edge count for that node. Doing this will no more unvisited edges. So let's just follow stuck. So now we are where we were last time, but just yet. Instead, we're going to backtrack outgoing edges to take from node six. One is to check whether the outer array at index backtrack and add six to the front of our four has remaining unvisited edges, those take. So we call our depth first search method for note four, similar situation at node three, going to take the edge going to the right, time there are no more unvisited edges at and add four to the front of our solution. an unvisited edge since the outer array at do is we follow that unvisited edge, which has no more unvisited edges. So we backtrack node two, and we backtrack now we're at node at node three, and so on since all the edges just going to unwind the stack and add the I'll let the animation play. And that's how you find an oil arian path required to find an oil arian path, we know that the calculations we're doing to compute of edges. Think about computing the internet only take big O of a time. So the whole thing let's have a look at some pseudocode. To find of the variables we're going to need. The which are n, the number of nodes in the graph, g the graph itself stored as an adjacency talked about earlier to track the in and out called path, which is a linked list which You can also use an array or some other data that a linked list simplifies the code to G we're going to call the find oil arian path that an oil arian path exists. To do that, of each node. And once we know that, we can for nor Larian path. So here we are looking degrees of each node. And verifies that Euler method is very simple. Simply loop over all degree arrays for incoming and outgoing edges. all the preconditions for an oil arian path start nodes and n nodes that we encounter. edge and an end node is a node with one extra a node which either has more than one extra edge, we know that this graph is not oil, because of symmetry I believe you only need put both conditions there. Next up, I check end node, you cannot be a start node and an The last thing to do is check if we have a for our path either there are no designated circuit case which is also an Euler path, and nodes. Coming back to the main method. and perform a depth first search to actually finding the starting node. We're going to zero, although this will likely change in our graph is an Euler area and graph. This extra outgoing edge that this node must be that nodes index immediately. Otherwise, we with an outgoing edge, our default node node this check prevents us from starting the depth the start node after the loop. The depth first interesting. This depth first search method node. We're at the while loop in the depth still has outgoing unvisited edges. It does current node and checking if there are still next unvisited outgoing edge from the current the number of outgoing unvisited edges from on already, the outer array is currently serving or not there are still outgoing edges and to select the next outgoing edge. This assumes structure that is indexable and constant time an adjacency list composed of linked lists, For all the edges once we've selected the calling the depth first search method recursively. node to the front of the solution. Returning need to do is check that we have actually arian path. It might be the case that our arian path on one of the many connected components to actually have an oil arian path so we return our path Today we're going to look at some Awesome. Here we are in the source code for by first instantiating this oil Larian path fetch the oil arian path itself should it class constructor in the constructor, what the algorithm as input and then the constructor that's not know and it also initializes a in the graph and the path linked list. Before the instance variables for this class. We in the graph. Next we have edge count which graph followed by in and out which are integer arrays to track have path which is the oil arian path solution, So once you create an instance of this class, get or Larian path, which does exactly what consisting of the nodes you need to traverse path exists. So there's a few things that step by step. The first thing in the get Euler have a look at that first. All this method the in and out array degrees, as well as compute being tracked by the edge count variable. next thing is to check if the edge count is edges to work with. Following this I called verifies that our graph actually has no relation has Euler and path method is also fairly simple. has too many outgoing edges or too many incoming amount of Start and End nodes for an oil arian end nodes keep track of how many nodes have one extra incoming edge for an Euler and path and end node. So when we're inside the for is to identify if the current node has too means that the difference between the in and In this case return false because the path path in such an event. The other conditions might be a start node or an end node. And and node counters respectively. The last step number of storage nodes and n nodes and return Euler and path method. The next thing in the and path now that we know what exists. To feed that as the first node to the depth first of those. We don't want to start out or they're because this doesn't ensure that we find an the fine start node method does exactly what a valid starting node, meaning a node with case of an oil arian circuit, just any node we start at a node with an outgoing edge because have no outgoing edges, but another component is where we really want to start if we are Next up is the depth first search method where for search method is really short and could Remember that when calling this method the the at variable in this method, which if you index we're currently at. In essence, what's current node still has unvisited edges, we're call the depth first search method recursively. number of outgoing edges for that note, which outgoing edges for the current node and the can add the current node to the front of the I think, is that you have to notice that the if there are any unvisited edges left at the into his adjacency list to grab the next note arian path method. Once we've finished executing do is ensure that we found an oil arian path, into multiple components, in which case the no oil arian path exists. Checking that the graph has Euler and path method verifies. to do after running the depth first search a size equal to edge count plus one. The next which is optional, is simply to empty the integer array. just for convenience. I do index an array than it is a linked list. The for creating a directed graph and adding directed one from the previous slides and another that to understand how this program works. Today And in particular, we're talking about prims spanning trees. So what is a minimum spanning tree or just MST for short is a tree, which together while minimizing the total edge cost. tree cannot contain cycles. Otherwise, it's labeled zero through six with various edges tree is the following edges highlighted in no way to connect all the nodes together and though the minimum spanning tree in this graph graph to have multiple msts of equal costs. because now it's your turn. I'm going to present is to identify any possible minimum spanning Take a moment, pause the video and find any minimum spanning tree is the following with are not unique. So there could be another all have a cost of 14. Let's do another one. I'll give you a moment. Here's one possible In green with a cost of 39. All right, one a trick question. Because there is no minimum on a single component for a spanning tree Let's change focus and start talking about minimum spanning tree algorithms because of it's a greedy algorithm, which always selects spanning tree. So it works very well on dense a few downsides to prims is that it's not parallelizable as other well known minimum harder but not impossible to find the minimum well known versions of prims I want to discuss. which runs in big O of E log e. And then there's big O of E log V, but requires a slightly a look at both, but this video is primarily start by looking at the lazy version, just Here's the general idea, maintain a priority cost. This prior queue is used to tell you is used to get there. Then the algorithm begins s as visited and iterate over all the edges this point on, while the priority queue is not been formed, dq the next best edge from outdated, which it could be if we visit the before getting to the edge we just pulled. and add the selected edge to the priority then you can simply pull again, then repeat nodes edges, adding them to the part of the not to add edges, which already point two of outdated edges in the priority queue. Let's this weighted undirected graph, and we want thing to keep in mind is that while the graph internal adjacency list representation has edges. So the actual internal representation is a lot easier to work with. Along with a edges currently in the priority queue on the containing the start node of the edge, the I will be coloring nodes as either blue for So let's begin prims on node zero. So iterate the priority. The first edge we're going to zero to one with a cost of 10. Then the edge the edge from zero to three with a cost of and we pull the next most promising edge and from zero to two with a cost of one has the gets added to the minimum spanning tree. This node two. So next we iterate through all the the priority queue while iterating over the may encounter edges which point to already to the party queue because they are of no already point to visited nodes is that either the minimum spanning tree, as is the case introduce a cycle in the minimum spanning next best edge in the priority queue is the so it gets added to the minimum spanning tree. is node three. The same process of adding smallest edge continues until the minimum play until something interesting happens. All right, notice that the next best edge which already points to a visiting node node and stale, because we found a cheaper path edge and pull again. The next edge is also So what happens when we have two edges with one gets pulled first, in practice, this doesn't pulled first because it was added first. We can now start premise because the minimum spanning tree is complete because the number number of nodes in the graph. This is precisely graph back into the undirected edge view, in the minimum spanning tree. To find the sum up the cost of all the edges which were tree and this totals to 20. Great, we now of prims. Let's have a look at some pseudocode. will need. First is n the number of nodes priority queue data structure, it stores the each edge object consists of a start node represents the graph we're working with. g in G every undirected edge is represented your graph is extremely dense, meaning it using an adjacency matrix instead of an adjacency a visited Boolean array of size n, which keeps or not. So on this slide is the whole algorithm go over it one step at a time. The function index and by default S is set to note zero. need just inside this function. M is a constant in the minimum spanning tree. Edge count is in the minimum spanning tree. This variable graph. MST cast tracks the total cost of the is an array which holds edges which we have The first actual a bit of logic we do is add queue with the Add edges method. So let's in there. Alright, here we are at the Add the current node as visited. Next, I iterate node. And if the destination node is unvisited all this method does is it goes through all queue, if appropriate. Once we've added the the algorithm really begins and we enter a empty and the minimum spanning tree is not we pull the next best edge out of the priority node index. This is a node the edge is pointing the logic that skips adding an edge to the already visited node again, edges can become the node they're pointing at becomes visited Next, actually add the edge to the minimum spanning And while adding the edge to the tree also want to do is call the Add edges method with add all the outgoing edges pointing to unvisited last thing is we make sure that we have actually entire graph. And we return the edges along finding minimum spanning trees with prims inserts edges into a priority queue. This queue to be big O of log e in the eager version, edges to the priority queue, which can later node edge key value pairs that can easily best edge we should add to the minimum spanning realization that needs to happen. And that is paired with exactly one of its incoming One way to see this is on a minimum spanning only ever one edge entering a node. Let's we have this undirected graph. The equivalent this. A possible minimum spanning tree starting in green. Now notice that on this directed edge except for the starting node. So in a can take advantage of here, which is that edge. In the eager version, we are trying we should select to include in the MST. The is that instead of adding edges to a priority we're going to relax that is to update the edge. So you might be asking yourself the update and retrieve these node edge pairs? queue, or simply IP queue for short, which pairs. You can think of an IP queue as the and a priority queue had a baby together. and pull operations in a logarithmic time. time complexity from big O of E like E to b v node edge pairs in the IP queue. If you're priority queue data structure and how it's structures video on the subject. I will link catch up, the implementation for the eager goes as follows maintain an IP queue of size on minimum edge cost of he started the algorithm all the edges of S. Relaxing this context the IP q from V old edge to V new edge. If edge, then while the index priority queue has not been formed, in dq the next best vertex visited and add edge e to the MST. Lastly, to relax any edge pointing to a node which All right, I think it's time to see an example. Suppose we have we want to find any minimum spanning tree. dealing with an undirected graph, we will graph, where each undirected edge is stored of all node edge key value pairs on the right executes. So you can think of the red box Let's begin the algorithm on node zero, start relax them during the relaxing process. Add if it does not exist yet, otherwise update than what already exists. The first node edge edge from zero to two with a cost of zero. The next best node edge pair based on the edge from node zero. Now iterate through all character ignore edges pointing to already The Edge 256 has a better cost going to node five with a cost of seven. So update the index IP q updates with a purple box around the pair is no three with the edge coming from through all the edges of node three and relax offers a better value. So I update the value the new edge. Add a new key value pair entry the index priority queue. Update the value just found. And from this point on, I will along. All right, and that's the algorithm you can consists of the edges highlighted in green. edge view it becomes clear which edges are can also get the MST cost by adding the values a cost of nine. Let's have a look at some prims. You'll notice that it's almost identical which I will highlight. First is n, which followed by the variable IP Q, which represents priority queue which stores node index edge as start node and node edge cost triplets once again our graph adjacency list of weighted edge is represented as two directed edges. we should be using an adjacency list or using when running prims. Because we know that this and did some analysis comparing the adjacency results I got were interesting. this dotted an adjacency list in blue versus an adjacency the graph edge density percentage, and the As you can see, for graphs with fewer edges, matrix. But as the edge density increases, You may be wondering why the adjacency matrix, middle point where the graph starts to become question. And my guess is that the denser need to be performed, which is an expensive iterate over all the edges of a node is constant, performance should increase as a result, but interesting. And the takeaway is that the impact the performance of your algorithm depending or dense. All right, back to the pseudocode. of size n, which tracks whether node AI has at the actual algorithm for eager prims. In that will need m the number of expected edges we currently have included in the MST, this the whole graph, then is MST cost which tracks And finally, MST edges, which is an array MST. After this, I call the relaxed edges an argument. Let's have a look at the relax happening in there. Alright, here we are, argument which is the current node we care node as visited so we don't visit again in list and get all the edges going outwards and start iterating over all the outgoing is grab a reference to the destination node at next skip edges which point at already actually relax the edge first check if the destination node. If it doesn't, then add Otherwise try and improve the cheapest edge the priority queue back inside the main method. not empty. And we have not yet completed the edge object pair From the IP queue based on as part of the MST and some over the edge node and repeat until the loop breaks outside created a spanning tree. This might not be But assuming that that is not the case, return spanning tree. And that concludes the pseudocode on the source code for prims implemented in on how to download and run the script in case Let's begin by taking a look at the main method up a graph we want to find the minimum spanning in the slides in the previous video. To create empty graph and initialize an adjacency list edges of different weights to the graph. Once tree solver and pass in the graph we just a minimum spanning tree exists, what the cost which make up the MST. The output of running you can see that this particular minimum spanning six edges. If you were curious as to how the add this to the graph, here's the code that which represents a directed edge used in the class is that it implements the comparable This simply means that edges are able to be on the minimum edge cost. This is important to know how to compare edge objects with one After the edge class is the minimum spanning happens. In this class, I store a whole bunch inputs are n the number of nodes in the graph, graph adjacency list itself. Internally I we have already computed the minimum spanning Once we've already solved the problem, the spanning tree was found in the input graph. value is false. The Boolean visited array been visited or not. And lastly is the variable queue which is a data structure I have defined minimum spanning tree costs and edges which After the constructor initialization there is the get MST method for retrieving the MST tree cost both of these methods work in the and then check whether the minimum spanning the real method we care about is the solve The solve method is only ever executed once as true the first time solve is called and The first thing I do in the solve method is some memory for the arrays we will be using. spanning tree And edge count is the number minimum spanning tree so far. Next I initialize particular index barbecue is implemented using degree for the underlying supporting heap logarithm of the number of nodes, which actually Typically, this is an implementation detail actual bit of logic we're going to do is call adds the initial set of edges to the priority look at that method, which is right here. note as visited so that we don't visit it adjacency list and get all the outgoing edges and start iterating over all the outgoing is grab a reference to the destination node at next skip edges which point to already want to process those. Now here's the bit if the index priority queue contains the key it doesn't, then add the edge to the index try and improve the cheapest edge at the destination queue by calling the decrease function. So Let's scroll back up to the main implementation of edges to the index priority queue, we enter queue is not empty and a minimum set burning out the next best node index edge pair. The which node the directed edge we just pulled add the pulled edge to the minimum spanning and sum over the edge costs. Finally, relax process continues and we keep pulling the minimum spanning tree until eventually the is set the MST exists variable to check if tree. If the edge count is equal to m, then tree Otherwise, the graph is disconnected that's all for the eager implementation of still be unclear is how the index party queue Here's the index priority queue implementation. on its own. Today we're going to start tackling what max flow is and in particular how we it, finding the maximum flow begins with having where edges have a certain maximum capacity a flow value, which is how many units of flow the flow is zero for all edges everywhere are also two special types of nodes in the usually denoted as s and t respectively. The input source, how much flow can we push through of any edge and it's not at all obvious how be used in numerous situations where edges For instance, suppose the edges are roads, current, and so on. Each of those has a certain flow on the other hand would represent the pipe. So the number of cars the roads can that your system can sustain. Effectively, the amount of traffic your network can handle. Under all those constraints. The maximum flow you can tell because after running the maximum to the sink node is seven. Running a maximum flow each edge should receive to achieve the be multiple ways of achieving the maximum but overall solutions will have the same maximum the maximum flow. To begin with, you will edges, which are also called arcs. Each directed a certain amount of flow at all times the than or equal to the capacity. This intuitively than what the capacity permits, it means something in some manner, in means that we've pushed of edges representing pipes with water it edges a wire with electric current, it means or something bad happened to it because there good. So this is why we don't allow more flow has a certain flow and capacity specified to each edge. Originally, the flow through negative value to find the maximum flow and Fulkerson method repeatedly finds augmenting the flow until no more augmenting paths can at this moment, what is an augmenting path? do you mean by augment the flow? All right, an augmenting path is a path of edges in the zero from the source s to the sink t in orange. path. The key thing to remember about an augmenting which aren't fully saturated yet. In fact, when there are no more augmenting paths left path is a detail left unspecified by the Ford let's assume that we're using a depth first augmenting path will have what I call a bottleneck path, you can find the value of the bottleneck by and the current flow of an edge. For this we can use the bottleneck value to argument simply means to update the flow values of you can see that I've increased the flow of six units. However, we're not done augmenting flow along the forward edges, but also decrease are called residual edges, the residual edges reverse order of the augmenting path. The bad choices of augmenting paths which do not know which are the best or even correct augmenting to freely find any augmenting paths without be able to achieve the maximum flow. It should edges to take when finding an augmenting path back, you can think of every edge in the original and capacity of zero, which is not usually are. The term residual graph simply means not just the original edges given and flow the flow graph, I usually mean the residual have at this point, the residual edges shown How does that work? So here's the thing. With to think of the remaining capacity of an edge the capacity and the flow of that edge. That the flow is the true remaining capacity for capacity of an edge is always non negative, in the residual edges we have right now, zero our residual edges actually have a remaining and the Ford Fulkerson method continues to path and to augment the flow until no more the QE ideation to make at this point is that acquire with each augmenting paths will result premise of this algorithm. It doesn't matter so long as you keep solving the bottleneck maximum flow. So let's keep finding augmenting whose remaining capacity is greater than zero bottleneck for this augmenting path is four capacities along this augmenting path. Here's the sink, you'll notice that we're actually earlier in this path. You'll also notice that This is just a coincidence, since both of of six, then we argument the flow as we do. I'll let the animation play for this next sum all our bottleneck values 646 and four, is 20. In terms of the time complexity, the from how we actually find those augmenting detail. If you assume that finding augmenting then the algorithm runs in a time complexity IE the number of edges in the graph. Here's Suppose that the side edges have very high has a capacity of one, you can clearly tell you can run two augmenting paths with the of the graph from the source to the sink. is essentially random. So it's possible for of one every single time. And what that'll the source the sink to be one, so one is always never going to be able to argument the flow back and forth between the same two alternating your time complexity. Luckily, much faster find the maximum flow value. One example is instead of using a depth first search, use augmenting path from the source to the sink scaling, which is the idea of picking larger you need to find overall. And this turns out tests. Then there's dynex, which uses a combination layered graph that guides edges towards the to actually find the augmenting paths. There's which were differently than the algorithms paths instead, push reliable algorithms maintain find the maximum flow of a network. Please here are very pessimistic and practice running faster. So it's very hard to compare the performance complexity today, we're taking a look at the implemented with a depth first search. The up the following flow graph and find the maximum flow algorithm, we should get a graph similar but not all of the edges and achieving the example I have lined up for you today can the description for today, I encourage you going over the source code. All right, here This program has three main supporting classes, and the Ford Focus in depth first search solver. I want to take a look at the main method where the flow problem we just saw. I know a lot which is usually somewhat of a mystery. So recommend you do every time you set up a flow the number of nodes in your graph that is then what I recommend you do is you actually them indices. And what I usually end up doing one and the sink equals and minus two, the have indices between zero and n minus three easiest way to set up your flow graph. Next, three variables n, s and t as inputs to the and which nodes are labeled the source on create the flow graph by adding edges with hook up the edges to the source, those would carefully hook up all the middle edges. And lastly, the edges leading into the sink. for most of the time, your graph is bipartite. up. After this I call the get max flow method Fulkerson max flow depth first search and expecting a maximum of 23 followed by printing edges of the residual graph. First, I get the max flow and iterate over all the edges actually run this program and see what the terminal. And for those of you who also have you can just clone the GitHub repo by typing is github.com slash William fiza slash algorithms. so I don't need to do it again. Then just So the file we're working with is called the it's in the graph theory network flow examples any dependencies yet. So we can just compile c followed by comm, Wm is the algorithms graph find that file Ford Focus, in example, that class file in that directory. So you can execute class and then pressing Enter and then you a lot of interesting information. Notably, edges plus four columns. The first column directed edge, then the amount of flow running And lastly, a boolean value indicating whether is quite handy for debugging. So let's go the code and take a look at the first of the edge class is composed of a few instance variables called from and an end node called to each of flow and capacity, the capacity of the is dynamic and adjusts. As we argument the have a start and end node plus an initial notice that the residual edge instance variable constructor. The reason is that I initialize edge and hook them up together in a helper is the is residual method, which determines because forward edges are not permitted to is residual if the capacity is zero pretty easy. There is also the remaining capacity method amount of flow that we can push through this positive or negative. Next is the augment alone. All it does is it increases the flow we found along the augmenting path and it edge. Last is the to string method which is we saw in the terminal. The next class we're solver base. This class is a generic base extend to gain access to reuse variables and task like adding an edge to a flow graph should is Edmonds Karp dynetics, some capacity scaling it makes sense to abstract that behavior and variables in this class. The first one is large constant that doesn't overflow. If you having large numbers added to it, then there of nodes in the graph is the index of the by this are two special variables I usually performance. So the rationale behind using array that tracks the visited state of a node whether via depth first search or breadth you want to use, you generally want to ensure same node twice. Otherwise, that could result check if node AI is visited is to check if equal to the visited token. This is super we yet again want to find another augmenting states of every node simultaneously by simply kind of hacky, but it's super efficient and to maintain a Boolean visitor array and you before you find an automatic path. That's order and work every time you want to find called solved, which indicates whether or solver, the solver only needs to run once, So for example, if the user calls the get only needs to run once. The next value that which is the value we're actually trying to representing the flow graph itself. Looking specify the number of nodes along with the inside this method, I also take the opportunity allocate some memory for the visited array empty flow graph method I do is initialize index so that we don't get a nullpointerexception. Talking about adding edges to the graph, let's we need to provide the start node and the a positive capacity for that edge. If the exception because that is an illegal argument, the forward edge and the residual edge, you'll a capacity of zero, then what we do is we residual edge and the residual edges residual edge, the forward edge. And finally effect, each edge is each other's inverse. a pointer that we can simply access when we remaining methods here are simply client facing graph after the solver has been executed. You'll notice that there's also this one special And this is the method that the subclass needs solves the network flow problem and actually can see that every time the client goes and max flow, he calls the execute method, and we will call this method if it hasn't been built in. Now let's take a look at the Ford can see actually extends the network flow the solve method that we need for the get a look at this. So the first thing you'll inputs and s&amp;t and all we do here is we call flow based solver which does all that nice the most important method, which is that solve can see that I actually overrides the method can see that I'm repeatedly calling the depth bottleneck value found along the augmenting the max flow by F in each iteration, because equals the max flow, we do this until the know that no more augmenting paths exist and each augmenting path you can see that increment state of every node unvisited. The depth first the node ID and the flow. Initially, the starting flow is set to be infinity. As we progress becomes the bottleneck value as we find smaller and we stopped the Alex Once the node index case right here. Afterwards since we know we do is we explore it by marking the current current index or the current node index to the interesting part. First, we get all the and then loop over them. If the remaining can push flow through that edge and the next we don't risk creating a cycle, then we can the if block. The first thing I do is call What I do is I pass in the index of the next which should equal the minimum of the current Remember that that flow parameter is trying makes sense. It's saying either keep the previously is even smaller than it should be the new until a base case is hit and the sink was augmenting path, we can then use that value However, first check that the bottleneck value that we never actually made it to the sink, the case, simply argument the flow by increasing value and decreasing the flow in the residual edge by the bottleneck value. After that, it up the stack so that all the other edges This also ensures that the bottleneck value max flow is actually calculated. So that's about everything I want to cover for the Ford for search. Today we're going to start diving to talk about unweighted bipartite graph matching, find a matching for us. Before we get started, graph is, a bipartite graph is one whose vertices u and v, such that every edge connects between the graph is too colorable, or there is a often arise when we're trying to match one of situations such as matching suitable candidates multiple candidates, but not every candidate nodes and candidates are white nodes, then the candidate is good fit. Another situation there are multiple servers and multiple surfboards. for the boards, such as color, size and so an edge between the surfer and the surfboard Generally when we're setting up a bipartite maximum cardinality bipartite. Matching. This be matched with each other. For example, we've be matched to jobs or the number of servers to bipartite graphs. However, you can also this variant is a lot harder to solve and finding a maximum matching on a weighted graph the cost of the matching. This variant is version in the unweighted version, no edge So it makes finding a matching much much easier. box which is the easiest of the four variants, of the other boxes as well. So if you want bipartite graph, you have lots of options, and push flow through it, which is what we'll find augmenting paths which maximize the matching the specialized Hopcroft Karp algorithm to are weighted, and your graph is still bipartite, a min cost max flow algorithm, or you can the more sophisticated network simplex algorithm you graph is not bipartite, but your edges algorithm. And lastly, the hardest of the And the edges are weighted. I didn't find the recommendation seems to be to use dynamic at an example. This is going to be for the the four variants. So I want you to imagine in the library and that some people express in a bipartite graph with people on one side suppose we want to find the maximum cardinality want to match as many people with as many to this matching problem. Let's start with the second book on the right side. The second with what is now book green. Next up is person book as person green, which is already matched, next choice is the third book which is unallocated, person purple, they instantly matched to an person Read, read only has one edge, meaning book. However, that book has already been cannot have it. Next up is person Brown. They cannot have it. Fortunately, they have other So person brown gets one of those. So in the of four, only four people were able to be Is this the true maximum cardinality matching. to the maximum matching problem will not work. approach to ensure that we are able to get this maximum matching problem by turning our the max flow. The first thing we're going one unit capacity to each edge. The zero slash a maximum capacity of one. Next we're going the sink and hook up edges at words from the and hook up edges from books to the sink also up, use any maxo algorithm to push flow through what edges get populated with flow with that the maximum matching. Here's a graph after some of the edges have one unit of flow. Those The most interesting edges are the middle edges which formed the maximum cardinality which have one unit of flow, you can see that and no one is left empty handed. Okay, so and how it leads to a matching. Let's play understand what all the weights here mean. from the source to each person to be one. I'll let you pause the video and think about The answer is that that capacity of one ensures no more. If we increase this number. For some up more than one book. If we rerun the max that it's now possible for one person to be we want to do is change the flow network to Pause the video and think about how we can copies of the same book in the library. I'll of a book is controlled by the capacity of this value will allow more flow to run through or controls the number of copies of a book, into the sink to allow having multiple copies we rerun the max flow algorithm. Once again people matched with the same book multiple Book Three and book five, both have two people of people to books would be as follows. I'll After the flow algorithm has ran, if you want actually given out, you can inspect the flow each person is only allowed to pick up one copies of each book. How can we modify the it, we need to modify the edge capacity between to pick up multiple copies of that book. Today, flow to actually solve a useful problem. The the mice and owls problem, which is a slightly problem, which I'll link in the description. and elegant solution, but also it's realistic Suppose there are m mice out on a field and Assume that the owl can reach every single are h holes scattered across the ground, and a number of mice they can hide in it. We also of running a distance of are in any direction asks, what is the maximum number of mice they want to give this problem a try, now's a good some code. The first step is to figure out which holes a radius of our around each mouse. And if touches a hole will assume that the mouse an edge between a mouse and a hole, if the following graph. The next step is to actually safety of the group. By doing a simple quick should be matched to any hole, for example, and run to the hole with a capacity of three, the hole behind it with a capacity of one, chance to jeopardize the maximum number of realization with this problem is that the that, it actually becomes a much simpler problem, a maximum flow algorithm to maximize the overall are the steps I would do to set the flow graph n mice nodes labeled zero through m minus create h nodes, each representing a whole, to m plus h minus one inclusive to give them I would place an edge with a capacity of one can reach that particular hole in time. After of one from the source to each mouse to indicate And lastly, connecting edge from each hole the hole. The problem has now been transformed maximum flow algorithm to get the maximum neat. And it's worth looking at some source All right, here we are in the source code. here in case you wanted to download the code This program also uses the Ford Fulkerson recommend you go and watch that video before below, just in case you haven't seen it. So is I create a mouse class, which is essentially a mouse is just the point on a plane. I also that the whole class with addition to having because we know that holes can only contain method, I create a bunch of mouse objects more or less randomly across the field. And thing I do in the main method is called the the two arrays we just created and a radius. its current position before being caught by really start to get interesting. Let's define lot easier. First is M which is just the number Following that I compute n the number of nodes, of holes plus two. The plus two is to account convention I always index s&amp;t the source and two to ensure that they are unique. After base by providing and s&amp;t the solver classes the Ford Fulkerson source code video. In short, capacities to the flow graph and then find of this video is not to explain to you how works. I already discussed that previously. is how to set up the flow graph for this problem is bipartite. Like it is in this problem. The first step is to hook up edges from the of one. Intuitively, this limits each mouse is necessary because we don't want a mouse doesn't really make sense. The next part is the flow graph. This is the middle section a mouse node and a hole if the distance from In other words, if the mouse can make it to mouse and the hole. The last step is also the edges between the holes and the sink. their capacity represents the number of mice a hole has a capacity of three. But there Well, we cannot allow more than three of those of the edge to the sink to be three, those hole, or gets scooped up by the apple. The get the max flow is to run the solver which for this configuration happens to be four, today's topic is one of my all time favorite problem. This problem is so interesting, because hit you as a flow problem to begin with. One I believe is actually identifying that a problem as so this is why I'm spending so many videos start understanding how to approach them and elementary math problem. This problem is actually the link is at the bottom of this slide and statement. Ellen is a math teacher who is question, the students have to add, subtract chosen the N pairs of numbers, all that remains three possible operations the students should Elon wants to make sure that the end correct each pair of numbers a B in the same order equation. Each equation should consist of be an equal sign and the result of the expression. If there are multiple valid solutions, output output a single line with the string impossible So Ellen goes and picks four pairs of numbers, five. And lastly minus one and minus six. minus or multiply to yield the unique answers assignment of operators might be the following. quite work because the answers are not unique of assigning operators to the pairs of numbers. are unique on the right hand side, which is we just saw that not any arbitrary assignment it's also possible for no answer to exist, this case, there can be no solution because be produced using the operators plus minus presents itself as a network flow problem, So take a moment and attempt to set up a flow It's actually a really great exercise along a few questions you should ask yourself, or did this. The first is there a way that this graph. I asked myself this because I know graph can be done very efficiently and also up, then I asked myself, how am I going to flow graph be able to handle that? Or do I actually figure that out? And lastly, I'm I handle multiple repeated input pairs? And are all super important questions you need this slide deck explains the first two. And I don't want to give away the full solution about how we're going to solve this problem that for every input pair, at most three unique pair, two and three. Well, for that pair, two and three, or multiply two and three. there may be less if there are collisions, by 00. And zero subtracted by zero is also unique solutions, and that's fine. The great up a bipartite flow graph from this because on the other side, let's see if we can set pairs, we have the pairs 1533, minus one minus to set up this bipartite graph is we're going nodes on the right side, for our first input one plus five, and one multiplied by five, answer nodes on the right hand side, then pair and the answer. Do the same thing for and attach edges to the answer nodes. However, already exists one with the value we need. three equals six, and we already have an answer three three to six do not create another answer unique. And do the same thing for the other the last input pair only produced two outgoing was a collision in particular, two plus two equals four, and this is fine. Just put one bipartite graph you're trying to find a matching sync T. And the matching is really what we're to answers. And then we've actually solved source and the sink is to actually assign Let's start on the right side, the capacities have a capacity of one since the answers need to one ensures that capacities for the input of one since only one of plus minus or multiply from the source two, the input pairs should this example, all frequencies are one. But the flow graph is set up, let's run a max its thing and some edges are filled with flow. be part of the maximum flow. From this, we we're interested in the middle edges. Those the matching. every edge in the middle with an input pair a B to its answer. For example, answer node six because there's one unit of can even deduce the operator used for each final output. This can be done by trying which results in the found matching. Basically, answers we get and then working backwards theory, we could tag each middle edge with doing that. It's, it's more work. Let's wrap do is look at the matchings and figure out is the input pair, one five matched to six. plus minus or multiply our results in one and we figure out that, hey, one plus five we move on to the next pair, and then we do If there are multiple operators that result that's basically it, we can verify that all that all our answers are unique. I didn't repeated pairs, but I'll leave that as an to probe even further into network flow. We're of the Ford Fulkerson method, which is the maximum flow algorithm, which uses a different the flow graph. Before we get started, let to do. We are trying to find the maximum flow the maximum flow is really useful for finding host of problems. So far, we've looked at which is to use the Ford Fulkerson method it says that all we want to do is repeatedly sink argument in the flow and then repeat key takeaway here is that the Ford Fulkerson these augmenting paths. So this is where we we saw that the Ford Fulkerson method can find the maximum flow. However, the pitfall depended on the capacity values of the edges search picks edges to traverse in such a way unit of flow in each iteration. This is really though it's highly unlikely to happen in practice, should it happen right now the time complexity is big O of E times f, where e is the number behind Edmonds Karp says that instead of using we should use a breadth first search instead, V times e squared may not look like a better different is that the time complexity while the capacity value of any edge in the flow that doesn't depend on the actual input values exactly what Edmonds Karp is and why it was can also be thought of as an algorithm which to t that is, in terms of the number of edges search during Edmonds Karp ensures that we of each edge being unweighted. When I say has a positive capacity, we don't distinguish than any other edge. Now, let's look at why we have this flow graph and we want to find depth first search, we might do something depth first search forwards. So after a lot of zigzagging through the flow just saw a depth first search has the chance paths are generally undesirable because the a small model neck value, which results in from s to t, again in terms of number of edges search worst case scenario and reduce the path from s to t do a breadth first search sink while exploring the flow graph. Remember capacity of that edge is greater than zero. have a remaining capacity greater than zero. when we're doing the breadth first search add all reachable neighbors to the queue and has reached the sink, so we can stop. In the of the edges reached the sink. But just for the sink, while in reality, we would stop we assume that the bottom edge made it to get the following augmenting path. But we a shortest length augmenting path. So to augment value by finding the smallest remaining capacity the flow values along the path that by the we're not done yet. Let's continue finding Recall that while exploring the flow graph, capacity of the edge to get to that node is neighbors of the source node in this case the edge from the source to the bottom left right, keep exploring until the sink is reached. So find the bottleneck value along this path. flow along the augmenting path. Don't forget not done because there still exists another one edge outwards from the source with a capacity can take. So we follow it. There's also only the other edges have a remaining capacity And now the breadth first search has reached were used. We can find the bottleneck by finding augment the flow. And now you can see that be found because all the edges leading outwards of zero. However, more generally, we know augmenting paths from s to t, because we know is the case, the maximum flow we get from values. If you recall in the first iteration, the second iteration 10 units and in the last of flow. Another way to find the maximum flow the sink, which I have circled in red. In first search on a flow graph can sometimes the sink. This is usually undesirable because value, and the longer the runtime. Edmonds the shortest length augmenting paths from search. However, more importantly, the big complexity of big O of the times e squared depend on the capacity values of the flow Today, we're going to have a look at some Alright, here we are in the source code written in the header in case you wanted to download If I scroll down, you can see that we still class, right here and the network flow base I have made since the Ford Fulkerson video. If we scroll down, you can see that three I added abstract away visiting nodes and marking done efficiently internally, through the network you don't have to worry about it also helps Alright, now let's have a look at the Edmonds in this file. First, notice that the Edmonds base. In doing so we get a whole bunch of construct a flow graph, before we push flow Karp solver, all I do is call the superclass including allocating memory for the flow graph and sink. The most important method and the here. The sole method is called just before short. All we do is repeatedly find augmenting flow we get is zero, at which point we know augmenting paths can be found line by line. before each iteration, run a breadth first some overall bottleneck values to calculate look at the breadth first search method. The data structure. Because I know that we're after the creation of the queue. What I do queue so that the breadth first search starts Then do your standard breadth first search remove the first node found in the queue. through all valid adjacent neighbors, we can visited, and the edge leading to the node before we add the node to the queue, we visit an edge in the prep array to rebuild the augmenting that the breadth first search did not actually the index of the sink in the prep array, so that there exists in augmenting path. Since find the bottleneck value that is the smallest do that by starting at the sink and reconstructing reaching into the prev array until we are the flow along the augmenting path to adjust the edges forming the augmenting path, then the flow along the forward edges and decreasing last thing to do is to return the bottleneck the solve method. And that's basically it graph. Have a look at the example right here from the previous video and pushes flow through create the solver and run the solver to get the resulting graph after the maximum flow handy to understand. So please have a look to understand it and Karp, today, we're still we're going to cover something called capacity than it is an algorithm. Capacity scaling attempt to push flow only through the largest have smaller capacities and do this to achieve we dive into capacity scaling, I want to quickly first search and the issues surrounding that. it's important that we understand the intuition were developed and why they came about. When The worst case is when we can only augment like this, we start at the source node, we than zero. And we just keep going until we sink, we find the bottle max value that is along our augmenting path, which in this case the flow by adding the bottleneck value to flow by the bottleneck value along the residual to start once again at the source and start take the edge going down, then take the residual again. And now we have found another augmenting Recall that the remaining capacity of an edge This allows residual edges with a negative Notice that yet again, the bottleneck value update or augment the flow. Do this by adding forward edges and subtracting the flow by You could imagine the depth first search algorithm value of one each time, which would ultimately network in each iteration, as shown in the we just keep alternating between the forward Capacity scaling is the idea that we should first to avoid ending up with a path with of each edge based on its capacity value, we should give more attention to the capacity But first, we need to define two variables the largest edge capacity in the initial flow of two which is less than or equal to the says that we should always take edges whose to delta in order to achieve a better runtime. The algorithm will repeatedly find augmenting remaining capacity greater than or equal to Once this criteria is no longer met, what it by two. And then we repeat this process you would want to implement capacity scaling works very, very well in practice. In terms a depth first search runs in big O of E squared the shortest augmenting path is found, which scaling, although I have found that to be for search if you are going to implement this. flow of the following flow graph using capacity of all initial capacity values. In this example, which happens to be 14. Next, compute the power of two less than or equal to u, which of delta is eight since the next power of 14. Now that we have delta, we can start finding capacity greater than or equal to eight, start there's only one edge which has a remaining with the capacity of 14 going downwards, then capacity of 10, we can take and finally an upwards, which we can also take. Now we've value which is 10. Because 10 is the smallest augment the flow along the path, I scaled much remaining capacity they have left, you no more augmenting paths from s to t which equal to eight. So the new delta is haften can take with all remaining capacities of source. Go up, sideways and sideways again, augment the flow. There is also another path four which we can take from stt, which is down to one diagonally up to node two and which we know to be four, because four is then we can augment the flow. If you now inspect a remaining capacity with all values greater the value of delta and two However, there of all two or more. So we need to have the to one, I believe there is one remaining path Let's start at the source and find it. Alright, now we found the path. And we can of one. And now the last step is to augment from s to t which have a remaining capacity of delta is zero, which terminates the algorithm, up all the bottleneck values we found in each and one for a total of 20. We can also compute going into the st highlighted in red. So in know that Ford Fulkerson implemented with a bottleneck value of one in each iteration, scaling is when we push flow only through runtime. One approach to capacity scaling which acts as a threshold for which edges based on their remaining capacity. This is that greatly speeds up finding the maximum some source code for the capacity scaling code written in Java. I've laid out some instructions to get the code play around with it and run have the familiar edge class here. This is two nodes with a certain company. If I scroll flow solver base, which acts as a template been implementing. I have already covered videos linked below. So please have a look we're really interested in is the capacity solver is an implementation of the network to find the maximum flow, you will notice in this class, which is called Delta. This it's the parameter we use to determine whether on the remaining capacity relative to the simply calls the super classes constructor some memory that will need to actually push Add edge method. The Add edge method is particularly we need to know the value of the edge with we also need to construct the flow graph to the largest capacity value as we build the method is defined in the network flow solver the functionality of. So inside this add edge I call the super classes add edge method. capacity we encounter as edges come through gets called to compute the maximum flow, the the largest value of two less than or equal this is to find the floor of the base two of two or in Java, you can simply use the for you more efficiently. Following that we source to the sink using only edges with the delta. After each iteration, we have the value being able to find more augmenting paths from fully saturated. Inside the inner loop, we a depth first search and sum over the bottleneck do this until delta is equal to zero. Now let's have a look at the depth for search two arguments the current node and the minimum initially call this method, the source node positive infinity. This method performs the we can stop searching when we have reached the sync node, then visit the current node current node. However, here's the catch though node if the remaining capacity of that edge the capacity scaling heuristic, we must also already been visited. We do this to avoid if statement we call the depth first search to as the current node and the new flow as remaining capacity, the depth for search returns path. So after the depth first search call, back to the source. This is a perfect time augmenting path since we have the bottleneck is greater than zero, this means we have found the flow, which is remember adding flow along edges. This is all done through the argument the bottleneck value. If we scroll down even right here. In here I set up an example of this is the flow graph from the slides. So and then I push some flow through it and get flow graph after the flow algorithm has been That's all I wanted to cover for capacity network flow. And in particular, we're looking efficient method of solving the unweighted is one of those extremely fast and revolutionary network flow forwards. It was one, if not new concepts like building a level graph, together and the concept of a blocking flow, next algorithm? It's a fast, strongly polynomial strongly polynomial is important, it means values of the flow graph for which all we about dynex is that not only is it fast in performance on bipartite graphs running and v times E. The importance of this cannot be bipartite graphs of a ridiculous size. If is the de facto standard algorithm to solve conceived in 69 by Ephraim Dennis and published slightly and popularized by Shaiman. Evan algorithm. Let's start by talking about the an analogy. Suppose you and a friend are planning east of where you are, you've never been to where it is, but you know, it's somewhere east. So how would Would it make sense to head south? What about East, North East and Southeast This is because that you make a positive progress towards that we continuously make progress towards So how can we apply this concept to solving the source node and the coffee shop is the is to guide augmenting paths from the source doing so greatly reducing the runtime. The towards the sink T and which do not is by levels of a graph are those obtained by doing an edge is only part of the level graph, if an edge must go from a node at level l to that edges must go from L to L plus one prunes are all the gray edges in the slide. So ask t as quickly as possible, does it make sense direction on the slide? No, taking the red so it should only be taken if a detour is omitted from the level of graph, the same sideways across the same level since no progress edges can be made part of the level graph than zero. So that's the level graph the actual construct a level graph by doing a breadth the levels of the current flow graph. Then, the level graph, you know, he can stop and using only valid edges in the level graph source to the sink until a blocking flow is of all augmenting paths calculate the maximum flow is when we cannot find any more paths edges in the level of graph have been saturated. let's use the next algorithm to find the maximum graph, we would also be able to get a maximum is to figure out which edges are part of the of the level of graph as a totally separate of the edges. So we start at the source and layer includes all the red nodes, then this the sink. Now, if we focus on the edges, which are all edges which go from L to L plus one than zero. Step two of the algorithm is to is reached. That is, we cannot find any more at the source and do a depth first search is reached. So we've found our first augmenting is five since five is the smallest remaining the path by five. If you inspect the graph, since there still exists paths from s to t. first search forwards. Now we found another So augment the flow along the path by 15 units. to t. What happens now is that we get stuck performing in the level of graph with a remaining capacity sink. So the blocking flow has been reached, Now we reset and rebuild the level graph. the remaining capacities of multiple edges taking all edges with a remaining capacity the middle edge leading us to the red node, of saturated and so is the one going downwards. graph layer by layer. Awesome. So this is time we have one extra layer to play with. again, we start at the source and probe forwards Oops, we have now reached a dead end in our go forwards. What we need to do is backtrack Perfect We made it to the sink the current the flow by 10 units. And now if you inspect flow has once again been reached. Now no more we build the level of graph, which means the the sum of all the ball and x values which flow of 30. The maximum flow can also be calculated leading into the sink highlighted in red on the current implementation of Linux algorithm dead ends during a depth first search phase. is taken multiple times during a blocking original paper denotes suggested cleaning dead ends before each blocking flow phase. pruning dead ends when backtracking during rid of dead ends on the fly as the algorithm simplifies the algorithm because that ends that's basically everything you need to know that we've learned. First, we talked about a guiding heuristic can greatly speed up our and practicality behind having a level graph we talked about the concept of a blocking depth first searches on the level graph until Afterwards, we looked at the process of rebuilding flow and doing this process repeatedly until flow is found. And lastly, we talked about which is pruning dead ends so that we do not have a look at some source code for dynex are in the source code written in Java, I in case you wanted to get the code play around as before, you can see the familiar edge class connects to nodes with a certain capacity. capacity, which returns the true remaining method, which updates the flow along this amount. A little further down is also the template for all the different flow algorithms how this class and the edge class work and spend too much time here. But what you need flow graph, it allows edges to add the flow which is somewhere down here, right here. the abstract solid method, which we need to software base. So the part that we are really you will notice that the dynex solver class flows or base gets initialized when we call t n is the number of nodes in our graph, S index of the sinking node. Just after that level to be a size and the level instance note. Now we're a level graph. Moving on the that this is the method that we need to override what we're trying to do did an algorithm begins first search that is the outer loop. And for flow by repeatedly doing multiple depth for the level graph is saturated, and the blocking the level graph and repeat the process until look at the breadth first search method. So two purposes. One is to build the level graph array. And the other purpose is captured by is to determine if we are able to reach the And if not, this means that the graph is fully first thing I do in this method is mark each the level array to be minus one. Then I initialize a queue data the breadth first search. After that I immediately we're starting the breadth first search at source node, we can mark the distance to the breadth first search loop while the queue first node index we find in the queue and that node. When building the level graph, remaining capacity of the edges We take r unvisited nodes. If both those cases hold, we're about to visit and add it to the queue. empty and the entire level graph is built. able to reach the sync node during the breadth solve method, now we understand how the breadth graph is constructed. Now let's have a look we do that, there's a key piece of information array in this method, the next array is part how we are able to prune dead ends efficiently. as an adjacency list, the list of edges going can use this to our advantage to get the next which we know lead to dead ends. Say we're adjacency list for node i suppose that this next time as in the next step, the first search not take the first edge in the adjacency list us to a dead end. The next array is a way take next, each iteration, you want to reset forbidden edges. All right, so we call the argument, the current node being the source, the path, which starts at positive infinity, sum over the bottleneck values to compute look at the depth first search method itself. arguments, the current node, the next array, the path. So far, this method performs a breadth stop searching when we have reached the sync going out of this node, the for loop loops taking each edge for the current node, the from this node at the index in the next array. we must ensure that the selected edge has that it goes up a level. Remember that we're sink and taking an edge at the next level to a dead end. But we end up pruning those well, we get to enter the inner if statement. depth for search method recursively passing node and the next array and the flow as the remaining capacity. The depth for search returns path after the this death research call, we and we're going from the sink back to the augment the flow for each edge along the augmenting value is. So if the bottleneck value is greater path augment the flow, which means to add along the residual edge. And once all that So assuming we were not able to take the selected not have enough remaining capacity, or didn't whatever reason, we need to mark the selected iterations. This is exactly what the next after the iteration of the loop. It increments node. If we scroll down to the main method, graph by initializing the flow solver and this is the flow graph from the slides last flow we get should be 31.