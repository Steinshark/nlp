What's up code squad. My name is Kyla gang. Python projects. And I'm going to walk you guys a couple of notes before we begin, here's a order from what I consider to be the easiest, They'll range from madlibs, which is a string to photo editing in Python. In addition, you might during these tutorials. The reason why I decided very important skill to know how to go back and makes mistakes. And I thought it would be when I go back, and I fix them. And of be sure to subscribe to my YouTube channel, Kylie science related topics. Follow me on Twitch Kyle and follow me on instagram and twitter at In a traditional Madlib, you would have a bunch of fill out those blanks and then read the paragraph blanks. So we're going to recreate this project talk a little bit about string concatenation. So suppose we want to create a string that says to be a YouTuber. So we can create a variable So there are a few ways to create the One way to do it is we can have the string with youtuber by just adding a plus sign. The and then have these curly braces. And what we and what this is going to do, it's going to put into where the curly braces are in that string. most straightforward is called an F string. And prepending an F in front of the string. And then And then directly in the curly braces, we can empty string, let's try running this real fast and they all turn out to be the same thing. So here we see subscribe to blank, three times. let's try with the YouTuber actually filled So let's run this again. And you'll see that say subscribe to Kylie Yang. And so for the last one the F string just because I think that's Okay, so starting this Madlib. So first we're just F string. So let's say computer programming now we have to define this variable adjective. we're going to get a user input. It makes me so excited all the time. Because And this break right here, this is just saying, on to the next line. That's all that little like you are and let's make this a famous person. example right there. And now Don't forget to famous person. So up here we're gonna say verb one verb because all we want is a user to input some thing, but instead verb to will be the name of input. So we're getting user input. And we're actually have to remove the space. And then at the So that's it though. Now we can run this verb. How about skydive, and then Captain America Okay, so our Madlib is computer all the time. Because I love to skydive, stay And so yeah, there you have it. That's Madlib in my code, which is linked somewhere below, you'll libs.py. What this is going to do is it'll choose it'll let you play that game. Alright, adjective Pretty glow bursts suddenly, across the dazzling sun appeared over the sill of the at the same time. So that Voldemort's was suddenly a flaming water bottle. What did I just First, I'm going to teach you guys how computer has a secret number. And we are trying is actually having the computer generate a secret we're going to import random. Whenever we package that comes with Python. And it says, like make these accessible in our scripts, So for example, in order to get a random number, applicable because it returns a random integer n, or equal to b. So a and b are the parameters of I'm going to define a function and I'm going I'm going to make x a parameter so that we can So first, we need to get the random number. And our random number. Well, we're going to use what we saw down here. Let's make it between one to return is a random number for us to guess. is, once the computer has a random number, we and input what our guess of the number is, and too low. Or if we've guessed the number I get the right answer, right. So that sounds don't have a predefined universe to iterate over, while in there. And now in this while And now for this expression, when do we want to number equals the random number. So that means our guess does not equal random number, then we to actually define this guest. And we're not going to initialize the variable tell Python that this later. So after a random number, I'm going to want our guests to ever accidentally equal that random numbers random dot Rand int between one So while the guests tonight equal the random guests equals input guests a number and we can so let's use an F string. And we can do x. Let's call our function guests at the bottom of our Let's see what happened when we run this. Alright, and 10. Let's do five. Okay, so we've printed the integer because I want my guesses to be integers. okay, I've gotten a random number. And now we've guess, the right number. But that's no fun, right? feedback, give us some clues into what's right to use some if statements and these statements kind of low, or, oh, maybe you've gotten it. so if our guests is less than our random number, All right, but then elsif, our guests is greater sorry, guests again, too high. And then if it's just right. It's in that Goldilocks zone, right? you have guessed that random number. And so have to do anything. Because remember this loop. it does all of this. But as soon as your guest guest, we don't hit any of these if statements. equal to number, but now your guests equals of this loop. Meaning that at the very end, I can And you know what we can even just So let's use our F string again. Yay, congrats. correctly. Alright, are we ready Let's run our script. Okay, it gets a number Okay, it was too high. So maybe two to low. is too low, it has to be three, right? Wow, look Alright, so we talked about earlier how the also do the complete inverse of that function, we the computer try to guess it. So now I'm going effects. Great, right. And in this function, So I have a secret number. And I'm not going to That basically means the computer has a range of low and a high. Okay, so that means let's set the that is without even having to loop over anything. and the high is x. Because we do have that entire until the user can provide some feedback, we high or too low, or if they've guessed correctly, variable. Alright, feedback. And at first, there too low. So just like how we initialize guests to And now basically, we want to loop over feedback expression does not equal what we're let's do c because C for correct. So Well, the first thing I need the computer to do is random, I'm going to use random dot random again. Now we don't want it to always be between one of change these bounds according to the user's too high, then anything above that we can kind anything below that we can stop considering. values into this random so that we can get a new correct. Okay, so we have a guest. And now we're guest right? Or is it wrong. So here, I'm going to So I'm going to use an F string again. So is guess, too high. And let's make that Ah, okay, that, of course, is C, the user is going to input this lowercase up here, I'm just going to make at the end is going to take whatever this string L and C are all lowercase. If we try to compare actually does not come out to be equal. So that's our different cases again. So if feedback is H, then that means we want to adjust our upper bound we're guessing out of 10, and we guess eight, the out nine and 10 cannot be the numbers, that would upper bound is actually going to be what we just eight, then we know it's between one and seven is L, we know that our low bound has to be guess, number. And of course, we can make that an LS LS can only be h, or it can be L, like it can't be we don't have to have an if statement for that. So at the very end, of course, when we the computer has guessed our number correctly. Let's put the number in there correctly. And because so that means that outside of this the last thing that the computer had guessed. then that is our secret number. All right. So is random dot Rand and will actually throw So we can do a couple of things, we could prevents this loop from continuing if low equals that means that you've narrowed it down, and your new low is nine, and then you're saying well, that means that the computer has actually too early, so if we're saying and low does not this loop. When our low is nine or higher is nine, yes, your number correctly. But the thing is, we has chosen it correctly. So that's why we can't what we want is we want to say if low does not between low and high. Otherwise, so this means equal to one of them. So let's just say whoa, I be high, because low is equal to high. Alright, into here and it prompts the user to say, hey, we're saying okay, the computer guessed your file. Oh, shoot, and you can, let's say too low. Seven. Oh, that's too high. And you know, we can even Alright, so for our secret number, let's actually 392. Okay, so Python three main.pi 640, that's Close, we're getting closer, oh 393, that's the computer guess our number correctly, look correctly. Alright, so that's it, just using some actually able to get our computer to guess our our computer's random number. So now when we're So the next beginner project idea is rock but it's a step up from the previous one. definitely want to import random, and we're we want some user input, right, because So the user is going to put an input, let's use And then the computer is also going to choose. And have our three different choices, our P and S. So of these choices. Once we know the user's choice rules in order to determine who wins. So the first same choice, then it's a tie. In this game, beats paper, and paper beats rock. So let's And here I'm going to say player versus opponent. And now we're just going to use See, so if the player is rock, and the is scissors, and the opponent, paper, or Or the player is paper. And the opponent is rock going to return true. So now we're going to ask computer so the computer is opponent and the user going to return, it's a tie up here. And then because if the computer one that we lost, here, before this last return. And the reason for that cases, and after each of these cases, the function then it ends right here. The only way that we can any of these, which is the same, it just saves or instead of saying if is when computer comma is if this is true, so we don't even need And here I'm actually going to add a Now let's see what this looks like. What's your Think I'm gonna go with scissors. So the first thing that we have to do for hanging So I actually went on Stack Overflow, and I a random English word from a list. And if you file that's linked. So I'm just going to click on And basically what this is, is it's just a very So I can copy and paste this entire list of assign it to the variable words, which we can use hang in file. And I know that I want to be able to to import random. And then also, I know that I my file words that py. So in my hangman file, I'm words. And that second words is just this in my hangman file, I would be able to get that So the first step in actually getting is the computer has to figure out a word for us into this Python file. And now we just But you'll notice if you look through this word and dashes in the middle of the word, which we So we actually have to keep choosing a word until So in order to do that, I'm going to define going to pass it a list of words. So the first word to random dot choice words. And what random something from that list. So I'm just going to make a while loop saying while dash or space is while loop does is, as long as the statement is it's not true anymore, which means that when doesn't have a space or a dash in it. And then we need to be able to keep track of which letters correctly guessed, we also need a way to keep it. So now we're going to set that up, I'm going the letters in a word as a set. And this will been guessed in the word. And then I'm going to to import this already predetermine list of like And then I'm going to have an empty set called track of what the user has guessed. Alright, So basically, what we can do is we can just And if we run this in Terminal, then the And we can use that as input. So we're going to uppercase this because I'm just going to Python is different than an uppercase A. So if you it actually won't be equal. So I'm just And basically, if I'm going to, I'm if this is a valid character in the alphabet add this to my use letters set. And then, if then I'm going to remove that letter from word then this word letters, we're just keeping track And then if this user letter that the user just that they've already used it before, and it's something saying, You literally just guessed that you know, they typed in something that's not in that they've already guessed. So that just means we're going to print an error message saying So now that we can get the user input, we want the the word. So in this case, we're going to be using you know, loop around your code and iterate. So, because I want the user to just to keep And because every single time we're removing a letters in the word that we haven't seen yet, the condition that I have to satisfy for when the length of word letters is actually equal to zero. than zero, I'm going to keep iterating through So my while condition is going to be while the iterate. So let's just add that in there. of paying man, we need two things that we what letters they've already used, so that they So we're just going to have a simple print space dot join us letters. And what the start into a string, separated by whatever the each of these letters will be in The second thing that we need to do is we need but with dashes where the characters that they first create a list where every single letter the letters that they haven't guessed, are just I'm going to join it with a space just like above In that game, I literally could have So let's make this a little bit more fun. hang and because usually and hang man, you So let's say that live, let's say you get six if the user has a letter in Word letters, But if they don't, then that's when you want to is set to six at the beginning, I'm just going to that your letter, user letter is not in the the same. Now at the very beginning, I'm going letters that they've already used, I'm gonna, I'm And then you know, they can guess the letter. as long as they still have to guess more now we have another condition, right, we have they haven't won yet, which is when the length when they haven't died yet. So up here, we're we're going to say while the like the word letters then we want them to be able to guess this means when they've guess all the letters, then they lives equals zero, they exit this while loop. So they've guessed the word correctly. But now that's We also have an aspect of lives. So if died. So we say sorry, you died, the word was yeah, you guess the word. So now let's try again Now we're going to create a command line version either a human can play, or the computer can play. against each other, or the computer can even play going to split up our player and our game into two we can create a game and then we can tell the my o player. So the first thing we're going to do going to tell you guys right away, we're probably to import them right now. We're going to have a to initialize it with the letter that the player or Oh, so that's cross are not in official like to letter. And we want all players to be able to get get move, self comma game. And I'm just going to and on top of that, we're going to build a random player here, we're going to use inheritance in human computer player that builds on top of this we have to initialize the superclass. So we're that's going to do is it's going to call this the player and define get move. So in our now. Same thing for the human player. In this we're going to initialize the same way that we did to find get move, and again, self comma game. And define the game to see exactly what we're dealing another file. Let's call this one game.py. So in And so in this class, what are we going to need, tic tac toe, it's a three by three board. Let's a list of length nine, that'll represent the can assign an index in this length nine list to our board. What I'm also going to do is I'm that will keep track of whether or not there is Who is it? Well, let's first of all be able to see like what's in this board. So for each row, So self dot board, this is indexing into our So we're doing i in range three, right? So this basically that's saying like which group of three one or third one, and that that represents the That's the second row and then 678, that's the is we're going to print and these are just going dot join row is just saying like join them in a So you guys don't have to worry too much about like, contributes much to the logic of the game. here for print board numbers, well, this is static specific board, we don't have to pass in a self. which numbers correspond to which spot. And so so our number board is going to be string, and this is a row, right? This number board might seem range three, so that's J equals 012. Here, this three. So this is the exact same range that we is, essentially, just give me what indices is going to come out to like 012, that's one sub then 678, we're going to concatenate the strings Okay, so now let's actually dig a little deeper we're representing the empty spaces with what are the available moves so we're going to return a list and this is going this out. And then I'm going to show you guys initialize moves to an empty list. And then let's enumerate is going to essentially create a comma the value at that index. So here we have in the support loop, we're going And we're assigning the first item in the tuple to Actually, let's call this spot, because that might space. And we know that this is an empty space. going to append that index, because we want to append the index of that spot to moves. And they way to write this is a list comprehension. And a spot in enumerate self dot board, if spot equals entire for loop into a single line. It's saying if the spot is space, then put AI into this list, Easy little one liner makes the code clean. Okay, get move for our players. So the square that we're while we're literally going to just choose So let's just do random dot choice, which random. And we're going to pass in game, moves. Again, it's just going to get a random the human to be able to choose a spot based on we want the user to keep iterating until they say valid square equals false. And then the value let's say while not valid square, so while valid and then self dot letter. So x or o player look at Terminal and not get confused by whose So what we're going to do is we're going to this is actually a valid number that we can put So for the tribe, we're going to say remember square is this input that the user has we can't cast this to a number, so if they input when you try to cast it to an integer and then is not in gamed out available moves in the list of And so essentially, if either one of these right? If we pass both of those, and we can say we're going to catch this value error. And we're And so this is going to repeat the loop, we're and we're going to repeat this checker. At the we're going to return that value at the end. So Okay, so we have our player. So let's now can start playing a game of tic tac toe, we have Let's, in order to get the rest of the function called play outside of this class, where and I'm going to pass in this extra variable print And if it's true, it'll print out all the steps. But later on, if we want the computer to play we don't need to see the computer print out every If we're printing the game, then we're gonna say we can see which numbers correspond to which spot I don't know if that's like, what two tackle Alright, so now while the game still has like incomplete, we're just going to keep about the winner. Because the output of this have to worry about continuing this loop, because So in order to check whether the game still has class called empty squares, pass in self. And what are any empty squares on the board. So we can and self dot board will become a Boolean, empty not there are empty spaces in the board. And we So I'm just gonna say okay, we can which will return this list. And so we are. We could also say self dot board count, and then just space. So that will count All right, so while they're empty squares, player. So if the letter equals O, then And if not, oh, that means it's x, then we're Alright, let's define a function Now that we've gotten the player to get And we say define make move. When we make a the user wants their move to be at. And then what to assign that square, if the move is valid, If it's not a valid move, then we return false. in case if self dot boards square is empty, so nothing's there yet, then we assign that letter that doesn't pass, then we return false. So if game dot make move, so if this is valid, if letter make some move to square, blank, and And we're gonna say game dot print board, because where this spot has now been claimed by this user. going to print. Okay. After we made our move, we assign letter equal to O if the old letter was x, a different way to rewrite this would just be if otherwise the newletter is x. That's exactly what Okay, but wait, we don't, we're not actually we want, if you think about it, the only time that a move, right? If you won, if you want a game, you to make move. And after we've placed the letter to the winner if there is one. So let's make So after we've made this move, if self dot winner, because that's the one that's going to be then we can assign current winner equal to that suppose that we have this checker. So then after we can check for the current winner before we which means, which means that if current winner and we can end the game because then we So in this game, we're going to and if there isn't, then we're going to And we're going to return the letter of well, it was letter, turn, so we can just Okay, so then also, let's just add in the we can say if print game, then after this while All right, now we got to go back and actually right? So we can define winner and And we know that in tic tac toe, we're a but we have to check all the possibilities, Alright, so first, let's check the row. So be whatever square that you give it, divided by what this right here is. So that double dash is row is going to be self dot board. And here we're essentially saying, given the row index, get the items in the row that we've selected. And we can like if everything in this list is true, then to false. So for all and then, within this list, every spot on the row, we're checking whether or how we're checking for three in a row. So if, and that letter, so that means that we have three If not, then we keep going right. So then let's very similar logic. So the column index is okay so that's going to tell us which column we were And here we're going to do another little indexing for every single row, so if we add the column index, and we essentially and we're going to put that in a list, and that's going to get everything in the column where we're going to use this if all checker and instead So if everything in the column is equal to the if that doesn't come out to true, we're going to see that the only way to win a diagonal is if here, we're going to check if the square that we These are the only moves possible because these So if we assigned 012 to the top row 345678, it's the middle is four, and the bottom right is four, and six. So that's why here we're So that that's basically saying it's even, then So this is the top left to bottom right diagonal. correspond to 04, and eight into this diagonal but instead, it's two, four, and six. So this And once again, we're going to use this if a letter in the diagonal, so diagonal one, if every single spot equals a letter in And at the very end, if all these checks fail, So yeah, that's our Tic Tac Toe game right there. name equals main, if name equals main, first, player and assign it the letter X. So actually, import human player and random computer player has no idea what's in player.pi. But if we add in our human player, and we get our random computer a human player, and we're gonna initialize we're going to make that our random computer is going to be tic tac toe, let's just equals an instance of tic tac toe. And we're going a player and then we're going to set Alright, so let's pull up a terminal and Alright, so first, I want to move to Okay, it's saying it's a tie. That's weird. But go fix this. It's a tie. So if we go back it's a tie is still within this while loop. actually on indented to make it fall outside no more available spots, which means that there First, we're going to go again, square four. so I actually don't like how as the computers like print out its move immediately. so for every single iteration that we switch And I can do that by calling time dot sleep. And very top, we have to import time in order to make tiny break to make things a little bit easier So we make us move to square four. l makes a move 00 goes to three and we want 908 we actually have to fix that text too, though. let's go back into the code. in a player dot pie here. We're just going to edit So we were able to actually detect that it was So yeah, that is our bare bones Alright, so we created a game And we created a human player and But can we do better? Can we make it so that but never loses? And the answer is yes. So minimax is a decision making algorithm built off you're trying to maximize your win while your Now, in a game of tic tac toe, we can step through and become victorious. In mini Max, we are trying this by trying out all the moves, and figuring called a utility function, which is basically a that tree is. Now let's take a look at an example So in this current board, it's X's turn. And want to win. So the first step is to put down You'll notice that in the middle, we actually Now let's talk about this utility Since we want to win, we want our utility to be Now, in addition, I have this factor of three, possible. So how I got this number is I took one so that if you did win, you still ended up multiplied it by either plus one or minus one, if Oh had actually won in this situation, with two times two plus one, three, which is negative out all the possible scenarios of gameplay. and then this layer until the board is filled, or function for all of these. Since Oh, one on times one plus one, since there's one In the second one, nobody wins, and Now on the right, the first one, we went again, So we're just going to multiply one by one. it's a draw again, so we have a value of we can propagate them back up to So at the very bottom level, we have a Maximizer no decision to be made in the bottom row, In the second row, it's his turn, and we assume which means that we want to minimize the value side, it's between negative two and zero. the left gets assign a value or utility value because there's no additional options after between one and zero. And since zero is less And the next stage, it's back to X's turn, and three and zero. Obviously three is a maximum, know what the most optimal solution is in order Alright, so for our implementation, we are And this of course, is going to take and here we're going to initialize it the So in our unbeatable computer player, we also the magic is gonna happen. At the very beginning, grab a random spot and just go there. So Otherwise. Alright, so now we're going to get that we described. So because of the nature of the define a function minimax, outside of our get move So self dot minimax. And we're going to need to we know that we can win enough the other player. was returned from our algorithm. And now let's and then self commerce date, comma, player. and not game was because at every single a screenshot of the game in that state. So I'm you could call it s, you could call it game, you because in my head, we're passing in states, Alright, so the max player is going to your score. So it's going to be self dot other players. So whatever the letter is not. So opener. Alright, so when we have recursion, we well, at the very end of things. Where you know, was there a winner in any of the states we have a current winner. So if the current then we should return the position. And the score things for the algorithm to work. So we're going none. And the score well, so this is the formula multiply one times the State DOT number of empty empty squares, we want to get to a win as soon as player, right? Otherwise, we're going to do the So LS negative one and then State and then plus one. Okay, so if there's no well, that means that nobody's won. So our score And the position again, will be none, because we base cases. Alright, so now here, we're going to player, then we're going to initialize a variable going to save the best position to move and the be the max player yourself, you want to maximize every single score to the score, and you're trying initialize it to the lowest possible score. So at initialize it to negative infinity, anything If the player is not the max player, then we want But the score we want to initialize infinity, point. So we're trying to decrease that. So we value. So for every single possible move in the So the first step is we're going to make So in step two, we're going to recurse using that move. So what happens, like from there on we're going to have to undo that move so that right. The fourth and final step is if necessary. So if your score from that possible then we want to replace that dictionary with so let's get into implementing these. So for step and this is going to be whatever possible And the and then our simulated score is going to be, well, the new state into mini max again. And so here, and then we're going to alternate players. Step three, we undo the move. So at that possible And then we set the state current winner back we just did, and the simulated score. Okay, so position and then not right, so we actually So here, our simulated score position actually in. Otherwise, this would kind of get messed up our fourth and final step, we say if the player greater than our best score, then we replace this Otherwise, this means that your players if it's less than your best score, we again score because we've successfully gotten a lower maximize the max player, but minimize the after we've tried every single possible step, will contain the best next possible move, and it ends up returning a dictionary of the position move for our genius computer player, and then that'll return the square the Oh, actually, this should be class. Sorry, All right. And now instead let's try playing against the genius computer Let's start a game, we're going to go to the So let's go back to our code. And where do we So we actually said we're missing So let's try rewriting this after we fix the bottom left looks pretty good. And that All right, they go to square two. So we they kind of forced our hand one. Alright, they go right? So no matter where we go, I mean, yeah, to show you how this algorithm is actually going it'll win. So it's, I'm just going to show So let's go to the left and see what happens. to take that bottom spot to win. And here, what computer player to play against a random computer print turn print game to false. And make this of number of x wins, oh wins, and ties. And then Remember that play passes back whoever wins, this time dot sleep in print game, otherwise, it down unnecessarily. So at the very end, our because that's the winner. So if the result plus equals one. If the result is Oh, then And then now if it's none, so that means x doesn't ties by one and then at the very end, we're gonna iterations, we see x wins. x wins. We see oh wins. Alright, let's try running this 1000 times. a little bit of magic called video editing. And 0x, one 793, a wins, and 207 ties. And you computer player as x or Oh, but if you're you will realize that it never loses. It loses. You can run this with like a Before we implement binary search, let's actually algorithm is a divide and conquer algorithm, faster than just scanning every single element And what I mean by dividing conquer is that assume that we have some list of ordered elements if this target is in the list, and if it is, then we're searching this list for this target. So what middle element of this list, and we can ask, Hey, middle element? If it's equal to then Well, we've know that it actually has to be on the left side searching anything greater than that element, side of that list. And now vice versa, then we only have to search the right half on that one section. So we divide and then we let's say that our target is smaller than so let's 15. So on that left hand side, what we can do middle of that left hand side, our target is less we're done, we found it. If it's less if it's greater than that, we look at the right already checked these, we're limiting ourselves that our target is actually greater than this next hand side of the array. And you can imagine how, in half every single time, because eventually, or we'll come down to like a sub array of like So in this project, I'm actually going to prove by naive search, I just mean, you're iterating does this value cool our target? What about here, basically asking every single element So now you've searched we're scanning the entire then we return the index. If not, then we return going to give it a list L and a target. So for if l at that index is a target, Otherwise, we've gone through the entire For example, our l could be one 310 then we're saying okay, for the first one that does not equal the target, keep going. keep going. Alright, so now we're at index two. to and if it's not in there, then we end Okay, so then binary search uses again, the fact that our list is sorted So let's define binary search and then Alright, so here I'm going to provide one more element in here, so it's one longer let's say we're searching for 10. Again. And so three, index three, because 10 is at index do is we have to find our midpoint. So our and then divided by two, but rounded down and this times to go into length, right, so that's going to So now, if l at this midpoint, so this list then we can return that midpoint Now, if the target is less than the value at that so this is comparing 10, less than five, right? saying like chop off half of the list, and iterate recurse. So we're going to use binary search which here would be one comma three, if this value gonna have to pass in some list, and I'm just it, we're not dividing anything right now. But well, this means that the target has to be so we only check what's to the right of it. Right. now these two, I told you guys, I would get back bit. And what we can do is, we could theoretically array, so we could index L, so that it's the to add the index back in another way is that we and these are going to be the lowest indices And then here, when we recurse, we can say the low going to be the midpoint minus one. And then for be, well, the next one after the midpoint, all the and again, low and higher indices. So these are these are just bounds on the indices. Alright, so because we want low to be the lowest possible is none, high is going to be the highest possible one. All right, and then for our midpoint, instead this to low plus high because remember, this So the average of those two would be whatever How do we know that our targets not even All right down here every single time Our we're actually subtracting one from the high. And of the midpoint, we're adding one to the midpoint than the low bound, that should never happen, the only time is when it can't find it, though the one. So that's our case of you know, it's it's then let's create a list 135 1012. Let's print naive search of this list and then the Alright, opening terminal. Let's run the script. And we see both of them return three. All right, show you guys that it actually works to not check 10,000. And so here we're going to just build a values in our sorted list, let's initialize it to is less than length, well, we're going to add some let's do something like negative three times the times the length of the list. So that gives us our algorithm to just choose a random Alright, so then after this is okay, make the sorted list into a list, and then we're going to reassign this to the variable because well, we're gonna want to time And how we're gonna do that is we're gonna say, time right now. And then we're going to call naive And let's actually say, let's iterate and try to find that item in the list. So we're going through the inherits word list running naive search on that one target. So we're And the end time is going to be again then the knife search time is actually And so we can actually do this per for each iteration, on average, it's going to be number of seconds. And again, we're gonna but make it binary search. So let's run that. Okay, we see that naive search takes approximately 443 microseconds, whereas binary search, I compare that that's like 6.8, compared to 400, if you ever have to search a sorted list, never guys how to build a command line version of We're going to be using recursion and classes I just want to say that I'm building a very because I believe that when you're learning to translate your ideas and algorithms into actually implementing the game, not figuring out important, it is somewhat secondary, to actually process that's involved with building these games. So here, our goal of this function is to play dimension size, which is going to be the size of Alright, so in step one, we're going to create we're going to show the user the board and ask well, if the location is a bomb, then we show where there was a bomb and but if the location each square is at least next to a bomb, right? So somewhere, and it's empty, and everything around to a number and that number represents that that we repeat steps two and three until there are victory. Alright, so right now we're just going to Okay, so let's take advantage of our we have in Python. And let's create a board So this is where we can say, create a new object, Let's define a class called board. And here we're and the number of boards. So let's keep track be helpful later on. So let's assign self doubt, that was passed in. And then self dot number of And then we're going to create the board. But we're going to initialize a set to keep track of we've dug in where the user has gone. So self dot let's create the board. So let's actually use a dot make new boards. And here we're going Alright, so we're going to find, make this is going to construct a new board based that we pass in. And there are a bunch of that can be like a list of lists where each we're going to generate a new board, this board then repeat that dimension size number of times, And then we're going to have dimension size a square board. And so this creates an array that be a board where it's non non non non non etc, So then next, we have to plant the bonds. So here, we're just going to use a while loop. And we can number bombs, we can pick a random location here and let's import random. And now for Rand int, and somewhere between zero and CELTA think about this logic as like, we're literally number of spots on the board, and we're assigning then this random dot Rand n is returning a random a would be zero, B would be the largest ID in that row and the column of that ID that we've chosen the location and then this double slash self it's going to say, how many times is my dimension that's going to be the row that we're indexing in. which column we have to divide by the dimension that's going to be how far into that list, we once we have the row index and the column index, if board and then row column, we're going to on the board, if it equals a bomb, so the stars then this means that we've actually planted increase bombs planted, right? Instead, we're the reason why I'm using a while loop and not a single time we skip, we're like continue, we're I only want to increment when I actually get the bomb. So yeah, that's why I'm using a counter. a bomb, if it is keep going. If not, then we're going to increment this counter bombs planted. And Alright, so that is making our new board Alright, so what other information is useful? how many bonds are around that spot that's going dig right when the user input something, well, how keep digging around it? And yes, we can implement if we did here, we're going to check all its you know, so on. But we can also just assign represents How many bonds are in the neighboring So here let's define assign Alright, so now that we have the bombs planted, for all the empty spaces that don't have how many neighboring bombs are and it'll save some effort checking what's we want to check every row and every column. for C and range self that dimension size, this is So if the item at the board, so if, at those continue, right, because we don't want to actually But if it's not, then we pass this if statement, board, let's create a new function called get num column index. And then this function is going to that row, comma, column. Alright, so let's define passing in the row and the column. Like if you're and then row comma call, these are just variable where you're actually calling them. So I'm passing it r comma C, because I've defined are variables that I've defined. And now call the parameters that get passed in whatever I to the row and the C would correspond to the neighboring positions and sum up the number of of all the neighboring positions, you can see and middle is row minus one column, you know, and and we have to make sure that we don't go out Okay, so first, we're going to initialize a variable set to zero, this And then we're gonna say for our in range row that due to the nature of the range function in And then same thing for the column for C and That should be plus. Alright, so basically, what at, we're checking below and above. And then for to the right. And so when we sum up all these three by three grid. And then we can say, if and if sequels called the column that we've is our original location, we don't actually have if self dot board at RC equal to star, so that that means that we have a neighboring bomb, right, bombs by one. And then at the very end, after going to return the total number of neighboring to make sure that we don't actually go out of what if we're checking the first row row minus one Here, we're gonna add a max statement just to make past negative one, we're going to take zero every for the upper bound, we're going to do the same then self dot dimension size, minus one because And then of course, we're gonna use the exact solve some spacing stuff. And so yeah, now the number of neighboring bonds. Alright, So step one is creating the board and planning board equals an instance of this board the dimension size. And the number of bombs And this is going to automatically, you know, it's going to initialize the board and plant the Alright, so now part two, we're going to show to dig. And then we're gonna check if the to dig recursively. So let's actually go back so that we have them, you know, handy when called dig within the board class. And we So we're digging at whatever And let's return true if it's a successful dig. it's game over and we've lost. So there are a few somewhere and we hit a bomb, and then it's game bombs. And then you know, we finish the day But we might also be digging at a spot where we want to dig its neighbors until we actually So the first thing that we want to do when to add a tuple to self dot dug to make sure that And then we're going to check the in our first scenario, if it's a bomb, Now, if we check that space, and you know, it's a we've dug out a location with neighboring bombs. because we did not take a bomb. So now if at that it's not a number greater than zero, it right? So here, we're going to use the same where we're checking for the neighbors. And let's R and C for all the neighbors. And so if r comma C is basically saying, you know, don't dig where But after that, if it's not, then we dig at into this dig function again. And there shouldn't be a way where we ever get to a at some square right before a bomb. So at So I'm just going to add one more thing to this string underscore, underscore. And so this is a board, it's going to you know, it's going returns. And so here, what we're going to want to shows a board to the player. And I'm going to go kind of just like, like, if you inspect the code, Okay, so first, we're going to create a new array call this visible board. So visible board is empty board, just as we did above, so that's going list of size, dimension size. And we're gonna now for every single row, and for every single If that row, comma column isn't self dot So visible board at that row, and that column is But if it's not dug already, then this is the user shouldn't be able to see what's at And we're going to put this entire board can do is you can just honestly return like a In this code, I'm going to make it a little bit is doing. It's just some formatting code. I'm just telling you right now, that it's just and to make it print out nice. And honestly, I is a lot more important to learn than learning how so now if we look at steps two, three, and four, and three, until there are no more places to dig. right. And here, what we're going while the length of bore dug, so all the places so there are no duplicates, while the length of squared, because that's how many spaces total we're gonna allow the user to play because it board where they can dig that are not bombs. going to print the board. And we're gonna And we're going to input this as row comma And now, here, I'm going to use a regex split. So where would you like to dig, this is going to string by this regex. And so this comma is then this parentheses slash slash s, well, this is and the star at the end is going to say, zero match any part of this string that matches, you space space, whatever the user types, we're going like zero comma 00, comma space zero, or zero have the import party. So let's go back to the top Okay, so now that we've split our input, we now dig. So we can assign row and column to the user The reason why we use negative one is sometimes of this list. And so if we know the row and then why not just take the first and I'm going to use it, because So now let's do some bounds checking if rho dimension size, or if column is less than zero we're out of bounds. So here, we're going to print continue so that we repeat this loop over again, But if the user did input something valid, board dot dig at row, comma call. And so now we've actually worry about the mechanisms of actually return true if we've dug successfully and false If whether or not our dig was safe. So whether So at the very beginning, we're actually going to we haven't done anything, you know, And so, if not safe anymore, well, this means gonna call break, because this means Game Over, we shouldn't be allowing the user to dig. So we're at the very end, there's two ways to exit this no more spaces on the board where you can dig, And yeah, rip. So let's check which one. just run out of spaces today, we've dug we've actually won let's print. Congratulations, hand, if we're not safe, that means that we've and here we can actually reveal the whole board. So we're gonna assign board dog to every single So this double for loop in this list take every single possible r comma c value of we're going to print the board. And so this Now let's call the play function And we're going to put this in a name equals main It's basically saying like if you have a massive the stuff underneath name equals main will only If you have a bunch of imports from bunch of the code under name equals main in those files, in that one file. Alright, so let's play the game. you see that we've dug at 00. It was zero. So that And so we kept digging until you know, there let's just do four comma six. And then let's try And you'll see that this actually dug a lot. So it it dug until it hits some spot that was right here, three comma seven. Well, this right? So let's dig there on purpose. So we get And it actually reveals that yes, this was a to begin with. There you have it, a next project is a Sudoku solver. In this tutorial, solve any valid Sudoku puzzle. Okay, so the first function solve Sudoku, and we want to pass in to solve Sudoku using a backtracking technique. where each enter list is actually a row in the nine by nine puzzle. And we're turning whether remember how lists are mutable. So we're actually solution exists. So the first step is I'm actually human, when we're playing Sudoku, we typically whether it's the column that's most filled out, But because we have a computer, we don't have number to any open space on the board. And then as long as it's valid. And when we see that it's let's not try three. Let's try four instead. you can essentially come up with it doesn't work from there. Okay, well, combinations there. If none of those and try all the combinations there, and so on. And So that's the technique that we're going to use somewhere on the board. To make a guess, in order called Find Next empty and pass in the puzzle. So here, I'm going to define Find Next this function is going to find the next row in our puzzle, we're representing any open spaces the next space, that equals negative one. So we're if this is a list of lists, the first index that that are empty spaces that the second value which index is it app. And then of course, board is filled, and there's no empty spaces left. common none. So keep in mind that we're actually and our last index is eight. So essentially, what hey, check each row and then check each column. just going to return the row comma column value of so I'm iterating through my nine rows. And then in range nine, so that's my zero through eight. we pick out the row. And then within that row, we this double indexing basically is returning the if that equals negative one, then basically non common none. If we've iterated through this then that means that there's no spaces in the Okay, so then the second step from there is, be implementing some validation checks of like so if we filled out this entire puzzle, then that if rho is none, so remember that above, we return assigned to grow, the second none gets assigned Now, if row is none, then we can return true But if we haven't, then we can keep if there's a place to put our guests, then and nine. And we want to actually try all of So I'm going to say for gas in range one comma 10. We start the next step, step three, Okay, so here I'm going to use And I'm going to pass in the puzzle, guess, key pieces of information that we need. In at this row and column is valid in our puzzle. And here I'm going to define the function whether the guess at that row or column of the then we consider it valid. And then we So now we have to follow Sudoku rules. If our or the column already, or even the little three by let's actually start with the row because that was puzzle represents a row. So if we have the row are equal to the puzzle index at the row. So if false. All right, now the columns, the columns which row we're indexing into, but we index at the can create a new list called column values. And nine, so that will go through all the rows, I'm at the call column. And so another way to write say take puzzle and then index into I and then for i in range nine. And then that's essentially if the guess is in those values, then we return And then now this little three by three square because we actually have to figure out where in what we're going to do is we're going to find the matrix, and then we're going to find the starting And then we're going to say for each row we're going to iterate. So what we can do in index and divide it by three, but throw away the one divided by three, that comes out 2.333. So the then five divided by three, well, the remainder So I'm going to return one. So that I can take set of three rows, the second set of three then of course, in order to get like the actual three. And then it's the exact same logic I'm trying to get the start value of these chunks, I'm getting the start value of these chunks, When I have both of the starts, I can through this. So I can say for our end range, we want to iterate through the three rows for C because we want to iterate through three columns, so that means our guess is already in this three And now at the very end, if we've passed all these means that while it is valid, and we can return Okay, now back to our code. So if is valid is on the puzzle at that row, comma column. So what index at the column is now equal to our guests. So now in step four, we're going Because if I guess one number, then that number can pass that in as my puzzle. And then the until we reach the very end. So that's We're just solving this entire thing with this new then we know that we've actually solved But of course, there's also the case where, And there's also this case of well, what if we in the row and column. So then, in this case, hey, so this guess was wrong. Let's reset it and say puzzle row call equals negative one, because So we're essentially just resetting the value at for loop is going to go over, you know, all the spot along this entire puzzle, right. So that combination for the Sudoku. So in our last step, and none of them work, then that means So this puzzle is unsolvable. And Alright, so let's actually test this to prove that that it comes out as true. And this is our board. actually view this as a board. Okay, just to make sure that like, our solution is let's do 123456789. Alright, and then this column, so that's pretty convincing that like, this of notes about my implementation. recursion is I think it might be better understood this it should be able to mutate the input puzzle, puzzle. Now, if it's not a valid input puzzle, because we've tried every single combination we can pass This new guests as a puzzle into then we know that our guests was the correct Now, if it's not solvable, well, then we know that Sudoku solution. So we can say, okay, that wasn't one. And this is how we kind of go through this we originally passed in to be the correct answer. This next project is going to deal with editing if you go to this link down below the one that's code, you can either download the zip file, or you let's take a look at what's in this code. So here so we're going to actually be editing these images So in the png.py file, this is some code copy and pasted this from online. Essentially, And what that means is while the writer is a PNG decoder in Python. So it takes a PNG image, and versa. For the writer, it takes a Python array, Alright, so now in this image class, this is some this initialization, you can either initialize And that will initialize to an empty array image will represent whatever file that you've the output path. These are just the folders have a checker to see if the user is actually So if it has, we assign those values, and then number of channels just means like, for example, RGB channels, so that's red, green, and blue. And to be using today. And then x pixels and y pixels of the image. So here, we're initializing a NumPy array of the size, x pixels, y pixels, kind of just creating a three dimensional matrix and it's initialized to all zero. That's when you pass in x pixels, wide pixels and then we actually read that image from this helper And then x pixels, y pixels and num channels will we're going to add this elf statement. Because if or if they haven't passed in file name, then we're have to input one of those options. Okay, so let's you have to pass in a filename. And this gamma, just a way to encode and decode it so that your I'm using PNG reader, this is from the PNG going to read it as a float. And then here, we're I mean, I've given you guys these functions for critical in understanding how the actual photo so this function call will write to a PNG file, and we're clipping it to between when we transform it back into the alpha file, And so we're going to do a little bit of reshaping writer. And we're going to resize this array but we want to keep it in the same representation, representation of the array. So down here, we're like import and export works. So we're going let's use the lake. And all we're going to do we're going to right image test dot png. And be identical to Lake dot png, because we haven't Okay, so test dot png, this is the same image. And this transform.py file, we're going to implement a going to implement is adjust brightness. Basically, when we adjust the brightness, we amount. factor that's a value greater than zero is the image by if the factor is less than one, then then we're brightening. So first, we have so that we can iterate through each pixel. And so remember that we've stored our values Alright, so basically, we're getting the x y and then basically, we're going to make mutate this one that we're passing in. So this y pixels equals y pixels. And then num channels same size of the array that we pass in. But now so that we don't change the original one. This it's non vectorize. If you don't know what that bit. But essentially, we're going to iterate for y pixel. And then for every single value of the matrix and you're iterating through each well, we have to adjust the brightness new image. And we're going to take the array, position that we're currently at. So x, y c. So to our original image that array at and then multiply that by the factor that we're just going to return the new image. So let's at the very bottom, I've provided already a little and load the city. So let's lighten the lake brightness lake and then some factor greater going to write this image to brightened dot png. and we get this image that's slightly brighter, these side by side, you'll notice that So let's actually try also adjust brightness. And then let's make the And now running that again. Right, we get the is darkened from our original image. And Right so the darkened image does look darker. Okay, so I mentioned earlier that this is a non this is the most intuitive like this is behind something you have to adjust every single Alright, so one faster way to do it. Is the are NumPy arrays, but the strength of this such read it as not B. But basically, the strength operations. So if you want to add a constant, you can directly just call that array, and then iterating through using a for loop. And we can just let it run on the darkened image. So let's Alright, we get this darker image two. And this Let's move on. Okay, we're going to adjust the we're going to be doing the same thing where we put new values in without modifying the original y, and z thing because even if you can vectorize what's actually going on. Here, we're going the array of the new image. So what adjust by increasing the difference from the user defined if your point is above the factor, then you and then you add back whatever the midpoint was. what you're doing is given this midpoint, greater. So we're going to take the image x comma y comma z, subtract out the midpoint, And then we're going to add the midpoint back in. Alright, and then of course, we return that vectorized version would look like, it's just new mid, which is a constant. So it's taking that single value in that array, scaling that entire mid. So it's literally taking every single item Alright, so now let's try adjusting the contrast equals adjust contrast Lake two, because remember, we have, right. And let's do the mid points 0.5, for these images. And now we're going to write the And I'm going to do the same thing, So I'm just going to do the same I'm going to pass in scaling factor 0.5. contrast. And we're going to write this to Okay, so let's compare these. So this is our So you can see that it's significantly grayer. decreased. And everything's closer to being the now this is the increased contrast, you can tell increased, the colors are a lot more drastic in we're going to implement is a blur for the image. kernel size just means how wide Do you want this when we're blurring is we're taking that pixel and if the kernel size is for example three, then that this kernel around it, so it should be taking the the four diagonal corners. For example, a kernel the seven to the right, and the seven to the Alright, so once again, we are going to create going to use a naive implementation of iterating at the end, there is a faster way to do it. But it's more straightforward to figure out what to incorporate some sort of, like memorization, would move like along the x axis, and every single we just get rid of one column, and then we add decrease the number of operations that we actually we're going to use this way for now. First, we're this is going to keep track of what the total of And, of course, we need to know how many neighbors neighbor range as how many times does to to one side do we need to look at And here, we're going to say, for each exci in neighbor range. And remember that we goes from the lowest to the highest minus It doesn't include the end of the range. So you x minus a neighbor range is actually less than we're going to add a little bit of bounds of x minus neighbor range, or zero. So for then we would say, okay, no, cut it off at we want this to be the minimum of the maximum minus one. And the reason why we do minus and we have to subtract the one because that's the into. Remember that Python, we do zero indexing. for the Y neighbors. And we're going to but instead of x pixels, we do y pixels. And then we go through a new neighbor, we want to add And then at the very end, we can say our new and then divided by the total size of the we have essentially a box of size nine, right our curl size, and then divide our us the average value over that pixel at its Okay, so I'm actually going to run it has more lines in it, it's So let's do a blur with size three, blur and then we're going to write image and call it thing with a kernel size of 15. Just so that using a kernel size three, four blur, and using Okay, so our blur of three is done. And When you compare it to the original, so our and it's still running for the 15. Again, And the higher your kernel sizes, the slower It looks like our 15 is now done. Okay, so let's noticeably much more blurred than our original. taken more pixels into account when we've Okay, so actually this blur we've actually implemented And so what that means is we're taking a matrix summing up whatever values in that matrix times So in this blur above, it's a kernel of size n by All right, let's see how we can create a function and we can apply it to our image. So we're going that we're going to do is we are going to, again, kernel size is slightly different, because we're NumPy, 2d NumPy array that represents a kernel dimension of the kernel 2d array. So we can just this iteration through the neighbor range. And the kernel corresponds to that pixel that we're which is representing you know, x So we're actually going to add that neighbor that what this does, is essentially, it's that would be the center of the entire kernel. But up to the top left corner. So that's, that's that If you draw it out, it makes a lot more sense. plus a neighbor range, and then subtracting y from Colonel and then index at x k, and YK. And we add the image at that index x i y, I see. But kernel. And so then the new image, that array sum of all of these are. And then of course, so I'm going to, so I'm going to show this It's called the sobelle. kernel. So in the 121000, negative one, negative two, negative one, will be some values or switch. So I can write this And so we're applying this over every single Alright, so you see, these are almost the same So let's call that civil x apply kernel city. going to write this to edge x dot png, we're kernel. And now you'll see why I called We go here, and we look at the city on edge x. So you can see that this edge x line right there. It's an X edge detection So you can see how this one really highlights It would be really cool if we could just put filter. And that's exactly what we're going to do. detection filter for our image. So here, we're So one thing here is the size of image one and the the arrays have to be the exact same copy this shape and create a new image. And basically what we're going to do is we're going the value from image to square it, add these two We have x y and C and index at the new image that index in image one squared plus whatever the entire quantity, square root it So this to at the end, we're going to return a new image. should actually be a image one or image two, it right? We said that, like when we sobelle, x and y. So uncomment some of this soble x, y equals combine images, so about dot right image, and let's call this edge So let's set all of these next to each other. image, then we have the x and the y filters. And the filters combined. And you can see that this try to actually like zoom in, make this a bigger I mean, you see all the edges in the image, And so yeah, using all of these implement Photoshop, in Python. Pretty cool. So the last project I have graph composer. And it's kind of like an is derived from a Markov chain. And so in a Markov and it has an arrow pointing to maybe And that one might be pointing to another and so on. So you kind of create this entire In our graph composer, what we're going to do going to transform every single word in that text to whatever words follow that specific word. So chain graph models actually work. Given a text, of the words are represented by vertices, and then that follows in the text. Now the weight of the new word follows the word that you just connected how about I am subscribed to y cubed, and I and we can make it a vertex. And now we can follows I one time so far, and then subscribed, we edge of wait one, two, y cubed. And Okay, so after this last, and it goes back to I, we already graph. And so and is going to connect directly okay, but then we have another occurrence of I we're going to increase the value the there. So instead of one, we're turning so am is already connected to subscribed. But now new vertex for the word loving and assign that it and now it gets connected to loving. So this I am subscribed to y cube, and I am loving it. So I have basically created this like huge graph of them to the words that follow. Okay, so now in a starting word by randomly choosing a starting on the edges. So these edges are kind of rules for the arrows So here's an example. What I mean And let's say that our starting word is y. So cube. So my generating is going to be y cubed. And And then of course, I because is the only thing cubed, and I am well, now we have two arrows an arrow to loving, we can actually choose either up to randomness. So that's where these weights the higher weighted an edge is, the more likely generate these sentences all stitched together, implement this in Python. First thing that we're that I've already prepared for you. What you can you can download the zip file, or if you know how look at what's actually in these files. Here. I Under songs I have, well I have a bunch of text to those a little bit later. But basically, chain model. I also have under texts, this and so we'll be able to see how we can actually well. And in lyrics.py, you guys don't really that, you know, you input some songs and then the those lyrics. Basically, it'll download this exe So graph.pi and compose up higher fd, because show you guys how to implement. Let's start with in this tutorial, I will make mistakes. I wanted know that it is very, very normal to have bugs And the important part is to actually know while you're watching this tutorial. Okay, so in to have our Markov chain representation. And, we're probably going to need randomness. So let's the graph in terms of vertices, naturally, let's we're going to do, we're going to initialize Now this value is going to represent our word equals value. So whatever the vertex value is, to be the word that it represents. And here, I'm what this adjacent dictionary is going to do, it's are connected to this vertex. And so those are node is going to be our weight, the weight of the let's create a function called add edge because we need to know which vertex we're drawing we can allow the user to manipulate the But you know, we can set it to zero initially, right, what we're going to do is we're going and the value is again going to be the weight. we're parsing our text, whenever we see a word, what we want to do is we want to increment that then we can say self, adjacent and vertex equals so this doc yet is just saying, if this vertex we're going to get the value of that vertex. going to default make it zero, and then we add an edge to the vertex that we're inputting with incrementing, the weight of the edge from give it. Alright, now that we have a bit of our in a graph. So let's create another class called this and we're just going to initialize this to why we do that is so that whenever we encounter a then get the vertex object from this dictionary. Alright, so let's define a And this is basically saying like what are the let's just return all the possible words that we return the set of self dot vertices, keys, and we've encountered so far. And then we can create a for example, whenever we encounter a new word, we we of course have to pass in a value, that's going do self dot vertices value, equal old vertex of we're putting it in this string to vertex mapping. because sometimes we'll just have a word and we So if we pass in the text, the word value, and then whatever is that that value, right, the vertex and returning that object. But what if case, what we want to do is we want to actually that value, well, it doesn't hurt to ever add we're going to add, we're going to we're just going to create And then of course, return it afterwards. And the when you're at a node, you can say, Okay, get next we can create a function called get next word, going to do, it's going to first find whatever So we can say self dot vertices, and And now let's create a function called Next we're going to do is we're going to randomly Alright, so if we actually go to look at the function called random dot choices where and it will actually choose randomly, but based on Let's return random dot choices and pass in self. in? Right? Let's introduce this concept of word to its probability, but put them in separate comma weight, and self dot adjacent dot is a dictionary that has each vertex and Let's create two new lists to keep track of And so here, for every single vertex, we're going to append the vertex to self dot to self dot neighbor weights. And so then we So here, we can do random dot choices, self All right, we actually see that random dot choices you know, there's it's a list of size one, but So we have to index zero. Now we can get our probability maps. Under graph, we can create a That'll get all the probability mappings of for every vertex in self dot vertices dot values. call that vertex and we're going to say, Hey, as we call that function, every single vertex And that is our graph representation. So now let's what we actually need to do here. Well, we need to create a graph where the values of the vertices in of words that's defined by the user, we need to results to the user. So let's put all of these getting the word from the text, we can create a and pass in the path to whatever text that we're command with open text path, comm R. R stands for text, if we call F dot read and assign that to a And now what we want to do is we kind of and then join it with one single whitespace. if there's like multiple lines, like, you it gets rid of all those and So text, that split is going to split all of that, you know, whitespace, whatever it is, tabs, So for example, text that looks like this would Right? And then what we're going to do because it's easier to compare everything let's not try to deal with punctuation because There are cases where you might want to add the sentence might be an abbreviation. Like, for the end of the sentence. So what we're going to punctuation. And we can do that by calling string we can import string, that's the Python package, know, any of the punctuation that you can see in a with empty strings. So here's something like, And then, of course, we want to split all splitting on spaces again. So we can call text dot words. So return words. So under step one, we can pass in the path to for example, let's use Harry the name of the text file dot txt. That's step one make a graph using those words. So let's define Here, we have to import the graph and So up here from graph, import graph, comma vertex, And for each word, in words, we're going to check then we add it. And so when we're going through then we want to check the previous word, if it very first word in the full paragraph. So if if it didn't already exist in the graph. existing edge by one. And then we set our So now remember that like, in order to get mappings. And so this is a great place to do in our make graph function. So let's start we're going to check that the word is in the So let's drag graph.pi over here, so Okay, so you'll see that in get vertex, we need to do is we can say word vertex equals graph previous word, then we add an edge if it doesn't weight by one. So here let's actually create because at the very beginning, there is a previous then previous word dot increment edge, word. it's going to increment that edge between And here the increment edge already does that in our vertex already. Now here, all whatever this word is. So that in our next And we keep doing that for all words. And at the mappings generate all the probability mappings G equals make graph. And then we pass in the Now step three, we want to get the next word Let's create a function compose, given a let's just say 50. For now, we're going to going to be an empty list every single time that it into this list composition. And what we can let's just get some random word from this words this is where we're starting. So for however has defined, we're just going to iterate and here, we can say composition dot append, and we're going to append the value of that vertex, the vertex and have that legible, we have to And then now our next word is going to be g So here, we can say word and word. And what we're going to do is replace At the very end, we're just Right. Now down here in our main function, we can pass in G, we can pass in words. And override that we can say 100. for the heck let's actually return a string. So we can join going to return a string where all the words So now let's run this function and generate. Okay, and because we're returning this Let's print whatever Maine returns. And Alrighty, so first, we can try running. And look that. So I go back up here, and I'm going to Alright, so now, none type has no attribute word is somehow none. So how in the world do we And take a look at what's going on. It could one of those is probably returning And if we look at, get next word, okay, here, never actually returning a value. And so that's And let's try running this again. And there we off of our Harry Potter text. Do you are They were going to let her to squeeze has always Maroon tailcoats orange eyes away. else is very well, no answer. Professor Clairol Alright, so this is kind of cool. But clearly reason for that is just because our implementation right? We're kind of just randomly choosing given make it better and more slightly like English, maybe choose like the previous like three words, previous three words, and so on just so that it as much. But now, maybe you're interested in Can and I'm going to show you exactly how to but keep most of the logic the same. If we go you'll see that we have this like chorus verse part of the song. So we're going to remove like do that with a regex again. So what we're going and then this funky expression, which I'm going a space anywhere in the text, it's saying this and here, this dot plus, so the dot means any means if there's one or more characters inside with the space in the text. And so here, our UI. And let's reformat some of this stuff, because we still want to get rid of whitespace, But instead of just, you know, one file name, And one way that we can like just have Python every single file name. If we import LS, and we folder and find all the file names within Okay, so for song file, in here, we're going to songs, and then we're gonna pass in an artist passing the artist. And then in Maine, this is going to do is, if you pass in this artist Billy underscore Eilish, then, we're going to And here, you know, for Green Day, you have and so on. Alright, so after I get all the song in this path songs, dash artists dash, So here, I'm going to put that in here song file. So this is just going to get every single words from that. And up here, I'm going And then every single time we get a song's list. So we can extend by whatever we want to input the artist. So let's Okay, so we're getting an error. And usually I one that I'm super familiar with. Let's actually out which one it failed at. And so here, if we run called dot d s store. And so this is just some actually a song file itself. And so we can just continue because we're just going to keep going look, there's our Taylor Swift masterpiece. they're you breathless, huh? Or it's time you need again, even if it's such a chance to paper looked back together, who, etc. Again, this intelligent. But for now, as a beginner project, based off of some vocabulary that you're If you enjoy this video be sure to subscribe to at Kylie y Yang if you guys are interested in pre planned like these tutorials, you should Alright, hope to see you guys around. I hope you