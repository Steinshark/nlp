So we're doing this series Graham - thank you most important thing in computing, or one of something for us? Yeah, I think so. So maybe one of the most interesting, and one of Science, and that is the Y combinator. The video we did an introduction to the a lot of discussion and comments, which top comment was &quot;can we have more on the to do today. So what the Y combinator in a language which doesn't have any all. So what we'll start off with is a actually is. So recursion is the idea of and a simple example of this is the have a little look at this. The way like 3, and it's going to count down from in between. So for example, factorial of 3 would give us the result 6. And then we function? And it turns out that the a very natural definition, using itself. So let's see how we can do that. number n, it's going to make a choice number you give it is already 1, which is down to, then there's nothing to do. So if the result 1. Otherwise, what we're going given, and we'll multiply it by the example, if n was 3 we would take 3 recursive function because we're the factorial of any number n is defined So you can see the way that this is like 3, it's going to loop round - two, gets to one, and then it will stop and do example of this running, to see that we factorial of 3 - so factorial of any number times the factorial so we'll take 3 times the factorial of 2. do the same thing again. We've worked out work out what factorial of 2 is, and recursively. So we copy down what we had 2 times factorial of 1. And then the where the recursion stops - because definition, was just 1. So we're going that's a simple example of a recursive we were looking at in the last video was language for defining functions. And it's variables, like X, Y and Z; it's got a lambda notation that we saw last day; that's just putting two things next to Lambda Calculus is encoded in terms of which we did last day was the logical refresh your memory about how we did True and False, and how do you represent Calculus? You do it very simply as two as the function that takes two things, x one, x. And then False is the opposite - it you back the second one. And these other function which you'd like on the looked at Not, and we looked at And, and can be defined in terms of these two natural - they express the True and False are often used to choose thing is True, you do something; and if And these two definitions just encode or another thing. What we're thinking yourself, if we have our definition like thing in the definition is that it's function in terms of itself, recursively. Lambda Calculus, which doesn't have any So let's start off by reducing the simplest recursive definition which I recursive definition is just a program So here would be the program. So I just about running this thing, we say what's loop? Well, you just go to the right-hand go back to the left-hand side, and it's forever - it's just going to kind of spin all. So this is the simplest recursive how could I encode this behavior in the something called self application - it's the in this case, applying a function to loop. So the way this works is we will the first thing to observe is that we two copies of the same function. If we look here, they're both exactly the same. So this function to itself - it's the idea occurs at another level as well. If we actually does, it takes an input called x, this is the idea of self application - we're applying it to itself, and the And it turns out that this idea of self looping, or recursion, in a for that feature. So let's actually behavior that we'd like - check that it down the same thing again, we have lambda x, think about how we can actually run this function actually does. So a function you what to do with it - so in makes two copies of it side by side. And this is the argument, or the input, to the what's going to happen is that this substituted, for x and then we'll just So that's how you would run the function. get two copies of the box, and inside the what you see here, is that in going from where we started. We started with this of loop, and we've ended up with exactly the same thing again, if we say this is a in, in the two places where we see x, then So this thing is just going to go around every time you run one step of it, it so it encodes the idea of looping. So more general example of recursion. So going to define a function called rec, another function as an input, and what to rec of f. So what does this definition that it's recursive, because rec of f is not just looping around all the time - the way. So if you think about unwinding f of f, forever. If you run this recursive function f infinitely often. And this called general recursion in Computer Science - recursion you can have, and any other terms of this one. So if we can encode any recursive function. But let me set Using the definition of rec, which is or redefine, loop to be rec of some what function to apply rec to here. It's it's probably the simplest, or it is the in the Lambda Calculus, so don't try and simplest function you can here, work see that it actually has the looping exercise, and a bit more challenging, is rec? And I'll give you a bit of a hint on lambda f, lambda n, and then you need to question mark here, okay. And what you'll in here is not recursive - it's the non- Okay, so that's a bit of a challenging this one's a little bit more challenging, recursion works in the Lambda Calculus we've reached now is the point where, recursion - any other recursive function defined in terms of that - if we because that lets us do everything. So tried to memorise it - I've just got definition, or one possible definition, what's known as the Y combinator. And if jumble of symbols, but it's actually very the definition of loop, it had the idea function to itself. And the function we when you run that, it will actually at the definition of the Y combinator, the same structure. Here we have a function, same function, so it's exactly the same difference here, we haven't got lambda x, the f which we're going to be kind of recursion. So this is the Y combinator. recursion. And this is a very simple but most programming languages, unless you would stop you from doing this. This language which doesn't have any where it comes from, it was invented by Haskell Curry, and this is the Haskell programming language. So if anyone asks it is. If you want to know a bit more course look online, and there's a very can find more details about these kind calculations and proofs of some of the actually, it's interesting that the top this stuff. It's actually a company which why would anyone call their company Y web page, they've got a frequently asked is - why did you choose the name Y a number of things here - so Y combinator Science, and of course I'm going to agree very interesting, fundamental idea which doesn't have recursion. And it's does. So the Y combinator is a other programs, and in this case it's a which doesn't have recursion. And that's they're a company that helps start Silicon Valley, and it's the same kind to help someone to make a company, want to have programs that run other of the coolest ideas in Computer Science. This is Alonzo Church, who was a mathematician States, and he was the person who was interested in, is what