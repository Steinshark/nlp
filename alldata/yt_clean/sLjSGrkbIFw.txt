Hi, my name is Dave Farley. I'm and a big fan of test-driven development. I'm here today talking to Saleem Siddiqui, who's which is a smashing book, which I've got here. If it's a great book. If you've tried it, and And so, we're going to be talking about that here Thanks, Dave, for the kind words. I'm going of your introduction. I'm also a practitioner, I've written also an avid practitioner and Dave and I share, I guess, some part of ThoughtWorks in both of our pasts, where philosophies that bind us together. I was really came kind of to my doorstep, and of course, in about. So, I look forward to talking to So, one of the interesting things...well, there one of the interesting things about your book languages. So, who's the audience? Why did Yeah, so good question. One of the things that I a complaint against adopting TDD in practice, work in my language. I understand that. I have Kent Beck, who with all deference, calls himself not the inventor, he didn't just rediscover book on it, he also created JUnit. And of course, it's also given people, developers, well-meaning the ability to use that as an excuse. Oh, or in the JVM, at most, it doesn't work in my look, there are three different languages. Of Python have some similarities, by its own admission, is not really TDD. languages which I do address directly in the And to your question, who is it targeted at, developers, people I work with. As I mentioned writing this was my own personal experience across the spectrum of their experience developers who are otherwise, frankly, more proverbially &quot;out of a paper bag.&quot; sad state of affairs, frankly, for the industry could overcome. So, I wrote it for all of those I think the effort would not have gone in vain. similar kind of pushback when helping people development, which is continuous delivery, which I often get the pushback, oh, it couldn't work whatever else. I've yet to find a technology or a as a fair bit of TDD with stuff built writing one way or another. One of my colleagues wrote were doing infrastructure as code, and we were those. We were even mocking out some of the TDD. So, I think it's interesting. One of the just comparing and contrasting the differences in as I was looking through the book. about having done it in different contexts. I make my own past. I would not normally associate COBOL I used it, I demonstrated it. And I would invite where he talks about having learned test-driven if punchcard developers in, I don't know, have some empathy, but I would say not a lot of argument that it doesn't work in my stack. If Yes. So for my book, &quot;Modern Software history of software development and software software engineering was a conference that to for the first time, to try and define what one of the things that I read was a treaty by Alan absolutely describing test-driven development. Fortran and those sorts of things, So, I think Kent is right, that that's where it reinventing it, but it's partly true. then. I think Kent Beck wrote JUnit It's interesting, some of these stories not that we want to take opposite sides on if it was to be a debate or a confrontation, it is traditional. Like, if you're not doing there's nothing that's more traditional than NATO think of big government agencies saying this I guess that's pretty much the mainstream. about the flight control systems for the Mercury were written using test-driven development in their software sometime later, which people like So, interesting stuff during, you know, I have a theory, and I want to hear your feedback in a sense, might have become less mainstream or development over the decades. It's all about fast development, feedback was measured automatically somebody else's stack of punchcards, you could so you wanted fast feedback, so there was this run faster? Of course, that's what it's all about. of magnitude faster, some of that emphasis that so now the question is between what we would the order of a few seconds, at the speed of the right? Minutes, we try to shy away from comparing yourself for, well, those people had next day, so we are not waiting 'til the next development isn't all that relevant today. Versus could always work at a pace where feedback is as really in the order of seconds, if that's how you should demand it. And your process is just as lobby for those kinds of architectural mechanisms I think some of that dilution of emphasis gotten awfully faster, and developers are, about how fast feedback could be in the modern To some degree, certainly. I think that the increasing sophistication of our software of computing, predating me, and I've been doing realized that this was incredibly difficult. The were, PhD geniuses, dedicated. This was an What we've done, by making computers and software technology is we've kind of lowered to write software anymore. And I'm not one of the things that I think with software incredibly deep, complex, difficult problems, are immediately into a world of concurrency and places, and how you manage that, and all that kind you're into the same game. Our equivalent We don't think, because of the the ease with which we can get started with I don't think we often think about that, and of the software systems that we build. So in systems that they were building because they knew This feeling of always teetering on the edge of drive us towards discipline like TDD, and of but it doesn't. At least not as We're all prone to that. At the it feels faster not to write a test. The trouble you're going to spend more time debugging it in productivity when you write the tests, but you when you're typing. Actually, you're getting me which is, in your preface, you say and abandoned readily. So, why is it It's a bit of that, right? I mean, thanks for discipline, right? I mean, so many trying to become a healthier individual, right? enjoyable process, whether you're giving up or whatever it is, you're trying to do that, at it, right? The act of living, becoming better in we were, before the recording started, we were music. The act of creating music, I'm tone-deaf, in itself, there might be some but it's also a frustrating aspect, right? The act If people were asking me, hey, how it's a labor of love, and I'm still not sure I think that applies to anything worthwhile, the effort at that moment can lead to frustration just chuck it. I don't want to do this, right? I I can just visualize the code I'm going to write, manager breathing down my neck, wanting to have I have empathy for that feeling of frustration and people in the software business field. mentioned music, and I like lean less cutting-edge things. This is an example I my manager won't like it if I spend time writing I can go into any restaurant, and let's say I As a customer, as somebody who's paying for it, it's me, I can order it...if I'm having linguini, if I'm allergic to butter, I can tell them, control over it. What I don't get to do in any that delivers food is say, look, I'm going to go over your chef, and I'm going to see how many the linguini, and I'm going to basically tell them I don't get to tell the waiter, I'm not going to to put it on, just slap it on some old newspaper, do that, right? There are some parts of the tied to the safe, healthy, and tasteful no matter how high end or how pedestrian it Yet in the software world, we are very ready, if they're not necessary. Some of it is upon our be like any chef or any food manufacturer who we should say I can't make software like this. It is do you want to do it, or do you not, right? So, that question, as I'm sure you do as well, that asked to not do it anyways, we should, frankly, We're in danger of too violently agreeing conversation. For people that don't I did a video on almost exactly this topic a said is when somebody asks me to estimate some 3,000 letter Es, how many Es would you like me of the time say, well, I can do it for this if I cut corners and don't do any good design, or I So, why do we do that? You know, we are complicit. that I work with, oh, we'd really like to do our business or whoever is telling us that we've that is that the data in the &quot;Accelerate&quot; book says definitively that teams that work the spend 44% more time on new features than build more features, the answer is yes, that more good design, I need to focus on the I agree 100% with what you said, we have to responsibility that that's our job, that's what we going to hire you, but you're not allowed to wash Then the next question, obviously, might the collective we, the developer community kind sensitive, and apologies to those developer I include myself in that. The other aspect that harder to adopt and easy to abandon, as I It is that process of I don't know probably have a good first step in my mind, I but I'm not sure about the second one, and I If you're a senior developer, let's say you're practices also reinforce each other, right, or to utilize test-driven development alongside for a seasoned programmer to admit to this is going to turn out. So, there's that I think there's a lot of healthy growth iterative nature of all of software development, ratchets you up that ladder. There's nothing wrong big gulp of your own kind of ego at first and say, my head, which is just going to come out of At some level, I think...and I hope I'm at some level, I think there's the expectation, that they don't make, can't or won't make publicly and vociferously say the whole business, the thing about software development is we never That's where it differs from widgets, I think. and engineering have had hundreds of years to make the same thing twice. It's not like making all the time. We're solving unsolved problems I think one of the profound mistakes that we've as a production problem. And it's not, for exactly in the fact that the cost of production is free, We just copy the bytes, a million times if creation. And I don't think we think about it, we software engineering these days because that's the people, when you use the term engineering, But actually, it's fundamentally a creative would argue for other types of engineering, too, hugely creative discipline, and primarily a you were saying earlier about, thinking about ideas off each other, it's one of the reasons that little bounce of ideas back and forth, the ideas. The sum of you and I working together is either one of us would produce alone There's a deeper kind of the point, and I our software interests, but somebody reminded were when they were together. careers after that, more so Paul McCartney argued based on numbers and sales and popularity, right? So, I don't know, maybe...and I'll if we try to tie ourselves to the fact that prima facie is true, right, it's not about copying more or less zero cost. That's not what we're repository in the first place. If you accept that is always by fits and starts. And I think and you are as well, to all aspects of creation primarily, in fact exclusively worried about software is really a solved problem if there ever tools, those techniques, those practices, and and not worry about the production semantics. connotations with another traditional engineering, creates a production model in our head, which Copying bytes has never been the problem. but then we'd be talking about my book, not yours. with which we grow our understanding of a problem, of the problem over time is a cornerstone of so important. Because it gives us that ability, and make change more safely, and, and proceed. between the...or on some precipice, it's good to exploring this unexplored territory, whatever it's good to have the design kind of unfold in broad leaps of imagination, untested broad And of course the feedback. I think that's the hear a good argument against it. Like if you had a Like, isn't fast feedback an awesome thing? I'm talking about my book again. But if you could work out, you could calculate the center the handle of the broom, and figure out where of contact precisely. You could, with great skill, was perfectly balanced. There's one solution to balancing a broom, you'd put the broom on your And that's feedback. That's the power of the thrust of their motors. This is a profoundly an infinite number of solutions to that problem. I've got to know to cope with it. But you know, we're talking about, I can make tiny little moves, I think it's that realization that we're always creating any code beyond Hello World, right? Hello World in a new language, that's] because I wouldn't say necessarily one way to get it set of ways to get it right. You're better off you have a failing test, or some manner thing, with enough detail telling you how and lobby and kind of make sure that is the case. Make all of the creation of software is really I would encourage my software developers to or they feel that they are being dictated to, this is the only way we're going to explore this Yes and we're the experts in software So, getting back to your book, rather test-driven development. One of the you kind of really reinforced the idea of Could you just talk a little bit about and why you saw that as kind of the Just real quick, I actually love that we're absolutely does not, I hope, doesn't philosophize preface that says why I believe in it, and but then it says in that section, and so the as you mentioned. But the reason I wanted to focus operationalizing the act of test-driven we can talk about it, and again, I do love talking development, but I suspect most of my colleagues how do I do it? And the how is very much rooted in chapter one, is focused on RGR. I make those each section, in the beginning, there's a section then getting it to refactor. Of course, the book in sequence always, so the sequence The reason I wanted to dwell on it is just to, get over the inner restraints or skepticism that development, then when they overcome that, then me how to do it, right? I mean, and I say that you have to learn it. Nobody's born with it, so we can learn, you can learn, all of and then slowing things down when you need to, is fundamental to learning test-driven kind of this overarching thing that and you and I are of one mind on this, that it's set that aside for a minute, how do I learn that triad is, I think, the best learn test-driven development as a practice. Even when, in chapter six, we write a very small paid homage Kent Beck's book where he builds, I didn't build it for all three languages, but I reasons given in the book. Primarily because with the node ecosystem has so many testing and then, again, open myself to the argument and not in my framework of choice. So, we There we see a slightly different incarnation as a metaphor for this fast feedback thing, but scaffold, if you will, to kind of always be settings. One is, of course, building the a small test harness that is built using and hopefully, my readers do as well. use the accidental miss...wrong implementation to demonstrate the importance of running them and Yes, that was important to me, Dave, this book didn't come out fully formed from under that mistaken assumption. So obviously, the heavy with code is itself an iterative process. opportunity to improve the code, and of course, I would say, I would admit, frankly, and without manuscript of the book, the opportunity to and I took it. But I didn't know it when I was aspiring authors out there, hey, test-driven When Jez Humble and I wrote &quot;Continuous Delivery,&quot; We do literally eat our own dogwood, We do. without the kind of making it sound too of life as far as the creative process goes. O'Reilly, of course, they have, obviously, all the book that you're writing, incremental the PDFs and the pubs and all of that, you can see right? I mean, this is not like we live in and then we go do our kind of snarky little things about fast feedback, it does encompass all aspects are concerned with creating stuff. that creating this book was in itself an There's no unit test that I wrote for the book, which sometimes means soliciting feedback but very much so also in the realm of software. relates to creating software versus I also liked the way that you kind of the importance of refactoring. My experience often miss the refactoring step, and they tried to try and get the test passing, and spend too the early chapters go quite slowly, and you're refactoring steps that get you to it. So, I think become comfortable with test-driven development you know, shrink to you. I'm sure that you and I, tiny little steps, one at a time, and getting that were working. It's certainly the way that I work, to you, that it's the way that you work, too. said, there are so many ways to go wrong, right? G state green that you also can do refactoring. I you if you can visualize doing that, and then of by your pair, or you can, maybe when you write done hastily or not will become more apparent. helpful to me to focus on the green when I'm in that I have the refactoring part coming up right of mend back all the corners that I cut during is a place for everything helps. Go ahead. refactor cycle. We're kind of doing, essentially, minimum changes to get back to safety in green, our design, and making it perfect in refactor.I you know, move really quickly. I get to green, to refactor, because I have prettify my code, or if there's, of course, extra loop or nested loop, that I can now unroll I can always revert, and go back to the previous those two phases too much is actually an act I then have the license to do as much necessary like, it just requires a little bit I also liked that in the book, throughout the continuous integration, committing your things to step back, you know? If you do screw up, you can Thanks for spotting that, obviously. So about continuous integration, and hopefully, we But one of the things I wanted to mention is integration wasn't as big a thing 20 years Certainly, continuous development wasn't a thing deployment and delivery. So certainly, there Again, it's not about TDD, I understand chapter much in harmony, and it would have been, I think, the book, that I wanted to talk about continuous and test-driven development, it would be a of this decade, that I didn't talk about CI. of actually committing everything to get in each got to about writing chapter seven, I'm like, this if we commit all of the code at once, and then add everything to Git, and then introduce GitHub was a bit of an epiphany for me as I got the way it turned out, and feedback tells me so. people find that useful, that it is not just software that the test-driven approach helps always malleable on those tests, and of course, I hope that people find that added benefit and it reifies the whole concept of I was already sold, but yes, I had that in place. Sorry, there was something So I think one of the pushbacks that I see they would do test-driven development I think this kind of completely misses the point that test-driven development is much more a design you do too, from reading your book. So how do the design process? And how would you respond to development because I don't know the answer yet&quot;? in vulnerability. I would say, &quot;I don't know &quot;I doubt anybody does.&quot; I mean, if it's an act some mystique who knows this fully formed solution and ask that person, right? I mean, they can we can rid ourselves of all of this tedium right? But, of course, that's a little bit of all seriousness. If somebody says, &quot;I don't know I'd make a stronger statement, &quot;Nobody does.&quot; So that does not exist, we are better off using and that we craft in a way that this false notion of some fully kind of getting access to, right? There's this formed solution out there. We're crafting it we have better server processes that The second thing I would say to your point, countering this argument, would be to say accept for a second that there is a solution as unlikely as that is, complex problems don't said earlier in your example as well, wouldn't it small steps, knowing that we're working towards from it, right? Even if there's a point solution progress towards it and not going on a tangent. I would, again, start by saying that I don't don't believe anybody has that solution in a very fair sense, stumbling towards that. steps that our stumbles are less catastrophic, a solution, not the solution, then it's better to falling headfirst into something, and that you're metaphors there, but that's the approach or in the act of creating light out of the small incremental steps of fast feedback rather There's another aspect that I think it's the testing word. And I think part of test-driven development, and people start thinking people will think about testing after because that's a natural thing to think about And so, what that means is that they're looking in mind in order to be able to imagine what it you get much worse tests. Even if you'd I think that one of the ideas that it seems that you've got nice, just implicitly in the that really drives the design is you want your not the implementation. So you want to focus them code, even at a fine-grained level, and not care form of specification, even at this fine-grained to drive certain design techniques and things talk about in the book like dependency injection. point that you, in one of your recent videos, testing something like a web server, which in a localhost fashion. Even that test, the outside in test that you because there was so much scaffolding, so really couldn't have been written in TDD. This somewhat facetiously, that I wish it wasn't called design would be a better thing. Whatever it still focused on design and testing is really a cover both in the beginning and 14, coding can be direct. In a very literal paid for writing better quality production code. that it's an end unto itself, it's a means to an Then the whole notion of design is central, front, you said, it is very outcome-based, even at that TDD is about writing unit tests first.&quot; Unit tests tests can you write?&quot; It becomes an implementation be. In fact, it shouldn't be well-written TDD.&quot; you into finding an incremental, simpler, the fulfill that outcome. When you kind of do that do decouple, even at that level of granularity, code. Of course, that comes very starkly in your full license to change the implementation or the production code, as long as your tests So that does separate, as you say, the test-driven tests. Really, it should be written, implementation at the end of the day, or at a couple. The tests shouldn't suppose that the have you. That's up to you to decide in the latter the test should test the outcomes. I think that's one of the superpowers that is that when you really buy into that kind of idea on the design of the code that we produce. I'm a but my code looks different since I've been doing was writing my book, where I tried to write bad separation, and concerns, all of that and I couldn't. It wasn't possible for me to write that I was trying to. Test-driven development just And there's not much else that's like that. when people say, &quot;Well, how does it work? there's really no secret sauce to it.&quot; Or if there your YouTube videos as well if you were gonna end up with spaghetti production code, and you have written first? A test. And how do you think Yes. would write a really bad spaghetti test, unit test subject themselves to that kind of torture. So, you just wouldn't. Therefore, you don't end up way before you ever were done with that &quot;Wait a minute, this test shouldn't have You wouldn't do that, right? So therein lies the was readable, manageable by you, comprehensible when you're about to make that test go green, code. Really, that forcing function, that is it, you to write tests first, it prevents you from because you would have had way before then, the wouldn't tolerate as a self-respecting developer. wanna type that much stuff when It really turns that laziness into something hundreds of lines of unit tests before turning wouldn't do that. If for no other reason, the right? So there are those built-in mechanisms that to use TDD to write bad code intentionally, as you right? The discipline made into their Well, I think we're probably coming to the end to you. I got one more question that we can kind are the most important ideas that you So number one, I hope they give shot. I hope they can rise above some of their own within themselves and amongst their teams create book clubs after a fashion, after that. I would be really honored and elated if somebody or following your book,&quot; as I call it. &quot;Which and then we'll give you feedback.&quot; That would is the best way to learn it. Like any skill, you it to you. You can't imbibe it. You can't put a TDD expert. It just doesn't work like that. So The second thing that I do hope, that engineering which I think they should also encourage their book, is seeing this as an integral and, frankly, So this is a non-negotiable thing, right? And the book, but elsewhere as well in other talks of the cloud, not just of course, as a deployment and low code, coding environments, is even those who might have practiced TDD in more that. When you're writing lambdas or serverless So I hope that engineering managers and senior keep encouraging their teammates, to keep learning test-driven development in So how do you unit test and test drive your had this right before we started. This is directly it says, &quot;You should ensure your state machine adversely by multiple concurrent executions of the are test driving their state machines, who are from Amazon directly, it's almost a direct... but I wonder how many of them are out there I might be wrong. Like, this whole adoption wrongly in my opinion, diverting people away from places of influence and power read my book new development paradigms that are upon us. that I think that one of the ways in which we is we keep forgetting some of the principles for whatever purpose, you need to verify that it if we've written any software, ever, have had the I know how that works.&quot; Then it doesn't, it Now, all we're talking about is how you do that most efficient way of testing these sorts as we've already alluded to, you know, even way of doing it, I've tried to struggle I did some stuff relatively early on with that really supported TDD and JavaScript in a away the browser in order for...We gave a facade If you believe in this sort of stuff, then you're it's similar to continuous delivery. I was and applying some of those ideas. We learn often, maybe even frequently, more generally tied to a single technology... ...or a family of technologies. about decluttering your code. Software is forever not just in physics and software. Unless we change upon us to adopt. It's upon us as practitioners something akin to that in the book. It's not than test-driven development comes up, I would be anything as good and the need hasn't gone away. sure that software, to your point, is fit for I suspect it does the right thing, but wholly does And to my knowledge and to the knowledge the most effective technique to crafting software. end. If a better means shows up, we'll adopt it. But we don't have one yet? Well, that's probably a great place to finish up. I'd like to thank you for chatting with me about if you're interested in the stuff that we've practice some of the exercises. GOTO for facilitating this. for writing the book, and it's been Likewise, the pleasure is mutual. Thank you.