Minecraft is NOT an 8-bit game, neither is this, designed for systems that had 8-bit processors, units of 8-bits as opposed to today's 64-bit stylistic choice, but was a result of hardware modern Game like Minecraft ever run on one of Rendering a complex 3D environment is simply too can create something similar, without resorting to one else has attempted to do this yet. If I were to a Ricoh 2A03 (6502 core) running at 1.79 MHz, and 2KB of Cartridge storage. For context this better option: The newly released Commander but it runs at 8MHz, has 512KB of on-board RAM, for data storage. But while this is a powerful capable of running Minecraft. Meaning that I'll with no rendering engines, and no libraries. from the blocks up. Just like regular Minecraft, But because of limited memory I have to cap the chunk. Each block is a piece of data that has two are a lot of blocks in Minecraft, I settled on like is the wheat grown, or not, and 7 bits for each block exactly one byte long and a chunk 4KB. a bunch of basic chunks that can function as a file in the world folder. This is because the X16 wants the whole thing, or nothing at all. Not very few chunks will ever be loaded in at once. Let's the VERA, has two modes, tile mode, like the NES and bitmap mode, like modern systems where each it has two separate graphics layers, but the sprites, double that of the NES. That's a is Video RAM. I can't even produce a single let alone try to include the graphical data for to save memory I can use tile mode instead, and bits per pixel to 16 colors at 4 bits per pixel, blocks are usually pretty one note. Using tiles, each block will be represented by 6 tiles. like we're looking at the blocks head on from a squished look. I can also get away with using less to either the ~Gameboy sized 160x120 or a 3DS the chunk so that's what I decided to go with. layer 1 for the HUD and crafting stuff and then between the two layers. But before I can process have to create the block tile data. At 4bpp, each being a number from 0 to 15. This tells the VERA use, while the row number is set by a separate X16 color Palette, but I can replace it with my block texture and threw it through a program rank how often they occur and give me the 256 most honestly, it's kind of ugly. Even a few tweaks of so I decided it just replace old colors with new But unlike designing tiles for the NES, which winning the claw game in Kirby, the X16 doesn't This is my X16 4bpp tile editor. You can create a tile you'd like to edit, and then from a range of color display changes for palette index selection, you want to change, direct export and import from as much as I like as everything is also backed best parts of being a programmer is being able to all this. Yeah, it's not every block I planned just get to the programming. I can now take my into the computer's RAM, and then convert it address bus allows it to access 2^16 or 65,536 reveals it only has access to around 36KB of free and that's without considering any program code two memory addresses [$A000 and $C000) allows setting a certain value I can tell the X16 which that I want placed in this memory area, allowing mind, I can place each 4K chunk into a different where they need to load in new chunks, I can three old ones were, and as long as I don't perfectly fine. Now to process this chunk, I have of tile numbers to copy to the layer 0 tile map in a 256x384 area, that's 32x48 tiles, and since that's another 3KB of data that describes how this what it looks like continuously when rendering, chunk into memory, I can process it and then store RAM bank, that way it's accessible when I need it the map. As for the chunk rendering algorithm, my across the row, and then continue to the next row, one below that, and so on. But without reading the will overwrite blocks on the top. Instead, if I draw every block, I still do a bit of overwriting, tile over and over, so it winds up being faster. came up with, in reality it was a couple days hard to this, to this. 9 chunks completely rendered. the chunks, and things are literally coming vast amounts of data, like 9 chunks worth of it comes to shifting the chunks over in VRAM, it in some graphical errors, especially since I'm not The solution I came up with was twofold. 1. to modify the graphical data in the CPU's directly through the proper registers to store it in video small section right around where the player will render the outer edges, even in a buffer, so I cut visible. And with that, walking around and even But from experimenting with different block I ran into another problem: I... don't like how it on in Minecraft you can still tell different you can see the sides of other blocks. My sufficient distance away until the edges were no with static tiles is that things at different which layers are which since the tiles all blend stacked blocks look especially strange, to the looks like a complete mess. I should've seen this I should've done more testing before spending, But it's only a waste if I give up. Already and a competent tile maker. All I need to change flatten everything out, doing something that I could have trees and stuff in the overworld, that this would remove a whole axis of movement, I'm going to go full axonometric. Think games like are tilted at an isometric viewing angle that give isometric blocks, then I can't do it using tile tile, so I either have to create thousands of tile into bitmap mode. As mentioned before, bitmap mode screen. Meaning that bitmaps take up much more that's without considering that I would have to same color diversity as before, which would also well. So I did some serious number crunching. reduce the memory foot print. I reduced the block then back to 8. Screen size had to be reduced from and zoom in on the new smaller blocks. I'm going rendering. Essentially for each block in the chunk a subroutine that draws an 8x8 block on screen. data as if it were an 8x8 tile sheet, meaning that to allow for 8bpp tile designing, I produced being only 1/6 the size and with minimal details experience in chunk rendering, programming a mostly. And because I knew what I was expecting I made sure that it would take minimal efforts And this isometric view makes it so much easier each block. But speed wise, if scrolling tiles then scrolling the bitmap is glacial. And while sacrificing huge swaths of video memory, there the first time, ladies and mostly gentlemen Stanley, please show us how this is going to work. Breaking it down, there's a ring around the at Stanley's foot, whenever this pixel hits the and reloads the screen accordingly. This wrote before meaning that nothing turned out I haven't even reached the alpha stage of this what do you want to see from this 8-Bit mining updated next, then hit that subscribe button,