Hi everyone, and I welcome you to this session on Artificial Intelligence full course. In this video, I'll be covering all the domains and the concepts involved under the umbrella and I will also be showing and practical implementations So there's a lot to cover in this session, and let me quickly run you So we're gonna begin the session by understanding the history and how it cam into existence. We'll follow this by looking at why we're talking about why has it gotten so famous right now. Then we'll look at what exactly We'll discuss the applications after which we'll discuss the basics of AI where in we'll understand the different types of We'll follow this by understanding the different programming languages that can be used to study AI. And we'll understand why Alright, I'll introduce you to Python. And then we'll move on and Here we'll discuss the different the different algorithms which include classification algorithms, regression algorithms, clustering, and association algorithms. To make you understand we'll run a couple of demos wherein we'll see how are used to solve real world problems. After that, we'll discuss the limitations of machine learning and why deep learning is needed. I'll introduce you to the what are neurons, perceptrons, multiple layer perceptrons and so on. We'll discuss the different and we'll also look at what Apart from this, we'll be running a demo to understand deep learning in more depth. And finally we'll move which is natural language processing. On the natural language processing, we'll try to understand the difference between text mining in NLP, what are the different and we'll end the session by looking at the practical implementation So guys, there's a lot to Also, if you want to stay updated about the recent technologies, and would like to learn more make sure you subscribe to never miss out on such sessions. So let's move ahead and take which is history of So guys, the concept of goes back to the classical ages. Under Greek mythology, the concept of machines and mechanical men were well thought of. So, an example of this is Talos. I don't know how many of Talos was a giant animated bronze warrior who was programmed to Now these are just ideas. Nobody knows if this was but machine learning and AI Now let's get back to the 19th century. Now 1950 was speculated to be one of the most important years for the introduction of In 1950, Alan Turing published a paper in which he speculated of creating machines that think. So he created what is This test is basically used to determine whether or not a computer like a human being. He noted that thinking and devised his famous Turing test. So, basically, if a machine that was indistinguishable from a conversation with a human being, it was reasonable to say meaning that the machine Now, unfortunately, up to this date, we haven't found a machine the Turing test. So, the Turing test was actually in the philosophy of Followed by this was the era of 1951. This was also known as the game AI. So in 1951, by using the of the University of Manchester, a computer scientist known wrote a checkers program. And at the same time, a program was written for chess as well. Now, these programs were but this was the first attempt at creating programs that could play chess or that would compete with This is followed by the year 1956. Now, this is probably in the invention of AI. Because in 1956, for the firs time, the term artificial Alright. So the term artificial intelligence was coined by John McCarthy at the Dartmouth Conference in 1956. Coming to the year 1959, the first AI laboratory was established. This period marked the So the first AI lab where is the MIT lab, which is still running til date. In 1960, the first robot was introduced to the General Motors assembly line. In 1961, the first chatbot was invented. Now we have Siri, we have Alexa. But in 1961, there was a chatbot known as Eliza, which was introduced. This is followed by the In 1997, the news broke down that IBM's Deep Blue Garry Kasparov, in the game of chess. So this was kind of the It was able to beat the So in 2005, when the DARPA a robotic car named Stanley, which was built by Stanford's racing team, won the DARPA Grand Challenge. That was another big accomplish of AI. In 2011, IBM's question defeated the two greatest Brad Rutter and Ken Jennings. So guys, this was how AI evolved. It started off as a Right now it's the most in today's world. If you look around every where, everything around us is run or machine learning. So since the emergence of AI in the 1950s, we have actually seen and its potential. So AI covers domains deep learning, neural networks, natural language processing, knowledge based, expert systems and so on. It is also made its way and image processing. Now the question here for over half a century, why has it suddenly Why are we talking about Let me tell you the main The first reason is what we have more computation power now. So, artificial intelligence requires a lot of computing power. Recently, many advances have been made and complex deep learning And one of the greatest technology that made this possible are GPUs. Since we have more it is possible for us to implement AI in our daily aspects. Second most important reason is that we have a lot of data at present. We're generating data We are generating data through IoT devices. Every possible way, there's a lot of data. So we need to find a method or a solution that can help us process this much data, and help us derive useful insight, so that we can grow business Alright, so, that process is basically artificial intelligence. So, in order to have a useful AI agent to make smart decisions like telling which item to recommend next when you shop online, or how to classify an AI are trained on large data sets, and big data enables us to Next reason is now we Right now we have very which are based on the Neural networks is nothing but the concept behind deep learning. Since we have better algorithms which can do better computations and quicker computations the demand for AI has increased. Another reason is that startup, and tech giants Okay, so companies like Google, Amazon, Facebook, Microsoft, all of these companies in artificial intelligence because they believe So AI is rapidly growing and also as an economy. So, actually, this is the right time for you to understand what So let's move on and understand what exactly artificial intelligence is. The term artificial intelligence was first coined in the at the Dartmouth Conference. I already mentioned this before. It was the birth of AI in the 1956. Now, how did he define John McCarthy defined AI as of making intelligent machines. In other words, artificial intelligence is the theory and development able to perform task that normally require human intelligence, such as visual perception, decision making, and So guys, in a sense, AI is a to work and behave like humans. In the rest past, artificial intelligence has been able to accomplish this by creating machines and robots that have been used in including healthcare, robotics, marketing, business analytics, and many more. With this in mind, let's discuss a couple of so that you understand how is in today's world. Now, one of the most famous applications of artificial intelligence is the Google predictive search engine. When you begin typing a search term and Google makes recommendations that is artificial intelligence in action. So predictive searches are based on data that Google collects about you, such as your browser your age, and other personal details. So by using artificial intelligence, Google attempts to guess what Now behind this, there's a lot of natural deep learning, and We'll be discussing all of those concepts in the further slides. It's not very simple to but the logic behind Google search engine is artificial intelligence. Moving on, in the finance sector, JP Morgan Chase's Contract uses machine learning, and image recognition software to analyze legal documents. Now let me tell you around 12,000 agreements That's a lot of time. But as soon as this task it was able to do this So that's the difference and manual or human work. Even though AI cannot think but their computational compared to humans, because the machine learning algorithm, deep learning concepts, and AI has reach a stage the most complex of complex problems in a matter of seconds. Coming to healthcare, IBM that has developed AI software, specifically for medicine. Let me tell you that more than use IBM AI technology, which is basically IBM Watson. In 2016, IBM Watson technology 20 million oncology records quickly and correctly diagnose a rare leukemia condition in a patient. So, it basically went which it probably did in a max to max. And then it correctly diagnosed a patient with a rare leukemia. Knowing that machines are now used in medical fields as well, it shows how important AI has become. It has reached every domains of our lives. Let me give you another example. The Google's AI Eye Doctor is another initiative, where they're working with to develop artificial intelligence system which can examine retinal scans and identify a condition called diabetic retinopathy Now in social media artificial intelligence is wherein you make use of machine learning and deep learning concept in order to detect facial All the auto tagging feature behind that there's machine learning, deep learning, neural networks. There's only AI behind it. So we're actually unaware that we use AI very regularly in our life. All the social media platforms like Instagram, Facebook, Twitter, they heavily rely on Another such example is Twitter's AI which is being used to identify and terroristic languages in tweets. So again, it makes use of machine leaning, deep learning, natural language processing in order to filter out any offensive or any reportable content. Now recently, the company discovered around 300,000 terroristic link accounts and 95% of these were found by non-human artificially intelligent machines. Coming to virtual assistants, we have virtual assistants Let me tell you about Google's virtual assistant which has astonished millions Not only can it respond to calls and book appointments for you, it also adds a human touch. So it adds human filters and all of that. It makes it sound very realistic. It's actually very hard human and the AI speaking over the phone. Another famous application So, artificial intelligence image detection, deep learning, in order to build cars that can automatically detect and drive around without So these are fully Also, Elon Musk talks a lot in Tesla's self-driving cars. He quoted that Tesla will ready by the end of the year, and robo taxi version without anyone behind the wheel. So if you look at it, AI is actually used by the tech giants. A lot of tech giant companies all of these data-driven companies. In fact, Netflix also makes use of AI,. So, coming to Netflix. So with the help of and machine learning, Netflix has developed a for each of its users. So if each of you opened up Netflix and if you look at the type of movies that are recommended to This is because Netflix studies each user's personal details, and tries to understand what and what sort of movie and then it recommends movies to them. So Netflix uses the watching with similar taste to recommend what you may be most so that you can stay engaged and continue your monthly subscription. Also, there's a known fact is recommended by Netflix. So their recommendation And the logic behind their is machine learning and Apart from Netflix, Gmail also If you open up your inbox right now, you will notice that there For example, we have primary section, social section, and all of that. Gmail has a separate section So, what Gmail does is it makes use of concepts of artificial intelligence and machine learning algorithms to classify emails as spam and non-spam. Many times certain words or phrases are frequently used in spam emails. If notice your spam emails, they have words like All of this denotes that the email is more likely to be a spam one. So such words and by using machine learning and and a few other aspects of So, guys, these were of artificial intelligence. Now let's discuss the So, AI is divided into three or you can say that there are three stages of artificial intelligence. Of course, we have artificial followed by artificial and that is followed by Artificial narrow intelligence, which is also known as weak AI, it involves applying only to specific task. So, many currently existing systems that claim to use artificial intelligence are actually operating as weak AI focused on a narrowly Let me give you an example of artificial narrow intelligence. Alexa is a very good example of weak AI. It operates within unlimited There's no genuine intelligence or there is no self awareness, despite being a sophisticated The Google search engine, self-driving cars, and fall under the category of weak AI. So guys, right now we're at the stage of artificial narrow We actually haven't reached or artificial super intelligence, but let's look at what if we reach artificial Now artificial general intelligence which is also known as strong AI, it involves machines to perform any intelligent Now this is actually something that a lot of people don't realize. Machines don't posses They have a very strong processing unit that can perform high-level computations, but they're not yet and the most reasonable If you tell a machine to process it'll probably do that in or a minute, or even 10 minutes. But if you ask a machine to and switch on the TV, a machine will take forever to learn that, because machines don't have They have a very strong processing unit, but they're not yet capable of thinking and reasoning So that's exactly why we're still stuck on artificial narrow intelligence. So far we haven't developed any machine that can fully be called strong AI, even though there are which defeated AlphaGo in the game of Go. AlphaGo Zero basically learned It learned on its own without But even then, it was not classified as a fully strong artificial intelligence, because it cannot reason Moving onto artificial super intelligence. Now this is a term referring to the time when the capabilities of a computer will surpass that of a human being. In all actuality, I'll take a while for us to achieve artificial super intelligence. Presently, it's seen as as depicted in movies and wherein machines have movies like Terminator and all of that depict artificial super intelligence. These don't exist yet, which we should be thankful for, but there are a lot of people who speculate that will take over the world by the year 2040. So guys, these were the different types or different stages of To summarize everything, narrow intelligence is the We have only weak AI or weak All the major AI technologies that you see are artificial narrow intelligence. We don't have any machines like human beings or Now let's move on and discuss the different programming language for AI. So there are actually N number of language that can be used for I'm gonna mention a few of them. So, first, we have Python. Python is probably the for artificial intelligence. It's also known as the most because a lot of developers And a lot of scientists with the Python language. This is partly because the syntaxes which belong to Python are very simple and they can be learned very easily. It's considered to be one of the most easiest language to learn. And also many other AI algorithms and machine learning algorithms can be easily implemented in Python, because there are a lot of libraries which are predefined functions So all you have to do is you You don't actually have So, Python is considered the best choice for artificial intelligence. With Python stands R, which is a statistical Now R is one of the and environment for analyzing for statistical purpose. It is a statistical programming language. So using R we can easily produce well designed publication quality plots, including mathematical symbol If you ask me, I think easiest programming language to learn. The syntax is very similar and it also has N number of libraries that support statistics, data science, AI, machine learning, and so on. It also has predefined functions for machine learning algorithms, natural language processing, and so on. So R is also a very good choice if you want to get started for machine learning or AI. Apart from this, we have Java. Now Java can also be for AI development. Artificial intelligence has a lot to do with search algorithms, artificial neural networks, and Java provides many benefits. It's easy to use. Debugging is very easy, package services. There is simplified work There's a good user interaction, and graphical representation of data. It has something known as which can be used for making So, graphic virtualization is actually a very important part of AI, or data science, or machine Let me list out a few more languages. We also have something known as Lisp. Now shockingly, a lot of this language. This is actually the oldest for the development of It is considered to be a language which is very suited for the development of artificial intelligence. Now let me tell you that this language was invented by John McCarthy who's also known as the father He was the person who coined the term artificial intelligence. It has the capability of It has excellent prototyping capabilities. It is easy, and it creates dynamic There's automatic garbage But over the years, many of these features have migrated into many other languages. And that's why a lot of There are a lot of new languages which have more effective features or which have better packages you can see. Another language I like Prolog is frequently and expert systems. The features provided by Prolog include pattern matching, automatic back tracking and so on. All of these features provide a very powerful and flexible Prolog is actually widely and also for designing expert AI systems. Apart from this, we also have C++, we have SaaS, we have JavaScript which can also be used for AI. We have MATLAB, we have Julia. All of these languages pretty good languages for But for now, if you ask me which programming I would say Python. Python has all the possible packages, and it is very easy to So let's look at a couple We can see why we should go for Python. First of all, Python was created in the year 1989. It is actually a very That's one of the reasons why a lot of people prefer Python. It's very easy to understand. It's very easy to grasp this language. So Python is an interpreted, high-level programming language, and it can be very easily implemented. Now let me tell you a It's very simple and easy to learn. Like I mentioned, it is one of the easiest and it also free and open source. Apart from that, it is You don't have to worry about anything like memory allocation. It is portable, meaning that you can like Linux, Windows, It support different programming paradigms like object-oriented and and it is extensible, meaning that it can invoke Apart from this, let is actually gaining unbelievable The language is used to develop machine learning algorithms, The other advantages to Python also, the fact that you don't have to code much when it comes to Python This is because there There are predefined packages that have all the function For example, there is which can be used for machine learning, NumPy which can be used Pandas and so on. There are N number of libraries in Python. So guys, I'm now going to I'm now going to explain Python to you, since this session is about So, those of you who don't or who are new to Python, I will leave a couple of You all can get started with programming and any other concepts or any other doubts that you have on Python. We have a lot of content or Python for machine learning and so on. Now let's move on and talk about one of the most important aspects of artificial intelligence, which is machine learning. Now a lot of people always Is machine learning and the same thing? Well, both of them are not the same thing. The difference between is that machine learning is Machine learning is a method through which you can feed and make it learn. Now AI is a vast of field. Under AI, we have machine we have expert systems, object detection, and so on. We have deep learning also. So, AI is sort of a process in which you make machines mimic the behavior of human beings. Machine learning is a way in which you feed a lot so that it can make it's own decisions. Let's get into depth So first, we'll understand or why machine learning Now the need for machine learning begins since the technical So, guys, since technology we've been generating an As per research, we generate around 2.5 quintillion bytes of every single day. And it is estimated 1.7 mb of data will be for every person on earth. So as I'm speaking to you right now, I'm generating a lot of data. Now your watching this video on YouTube also accounts for data generation. So there's data everywhere. So with the availability of so much data, it is finally possible to that can study and analyze complex data to find useful insights and So, top tier companies build such machine learning models by using tons of data in order to identify any and avoid any unwanted risk. So guys, one thing you the most important thing is data. For artificial intelligence or whether it's machine it's always data. And now that we have a lot of data, we can find a way to analyze, process, and draw useful insights from this data in order to help us grow businesses or to find solutions to some problems. Data is the solution. We just need to know And the way to handle data is through machine and artificial intelligence. A few reasons why machine is, number one, due to So due to excessive production of data, we need to find a method that can be used to structure, analyze, and this is where machine learning comes in. It is used to solve through the most complex Apart form this, we also needed So by making use of various algorithms, machine learning can be used to make better business decisions. For example, machine learning It is used to predict any or identify any sort Other reasons include that uncover patterns and trends in data. So finding hidden patterns and extracting key insights fro data is the most important So by building predictive models and using statistical techniques, machine learning allows you and explode the data at a minute scale. Understanding data and takes a lot of time. It'll take several days for us to extract any useful But if you use machine you can perform similar Another reason is we need So from detecting the genes linked to the deadly ALS disease, to building self-driving cars, machine learning can be used to solve the most complex problems. At present, we also which are 2,400 light Okay, all of this is possible through AI, machine learning, deep So to sum it up, machine learning is very because we're facing a We're generating a lot of data, and we have to handle this data in such a way that in benefits us. So that's why machine learning comes in. Moving on, what exactly So let me give you a short So machine learning was in the year 1959, which is just three years from when artificial intelligence was coined. So, looking back, that year was probably the most significant in terms because most of the technologies today are based on the concept Most of the AI technologies itself are based on the concept of machine learning and deep learning. Don't get confused about machine learning and deep learning. We'll discuss about deep where we'll also see the difference between AI, machine So coming back to what if we browse through the internet, you'll find a lot of definitions about what exactly machine learning is. One of the definitions I found was a computer program is said with respect to some class of task T and performance measure P if as measured by P, improves That's very confusing, so let In simple terms, machine of artificial intelligence which provides machines the ability to learn automatically and without being explicitly In the sense, it is the practice of getting machines to solve problems by gaining the ability to think. But now you might be thinking how can a machine think or make decisions. Now machines are very similar to humans. Okay, if you feed a machine it will learn how to interpret, process, and analyze this data by using and it will help you solve world problems. So what happens here is a lot of data is fed to the machine. The machine will train on this data and it'll build a predictive model with the help of machine in order to predict some outcome or in order to find some So it involves data. You're gonna train the machine and build a model by using in order to predict some outcome or to find a solution to a problem. So that is a simple way of understanding what exactly machine learning is. I'll be going into more so don't worry if you have Now let's discuss a couple terms which are frequently So, the first definition that is an algorithm. So, basically, a machine is a set of rules and that is used to learn patterns from data and draw significant information from it. Okay. So, guys, the logic behind is basically the machine Okay, an example of a is linear regression, or decision All of these are machine We'll define the logic behind a machine learning model. Now what is a machine learning model? A model is actually the main component of a machine learning process. Okay, so a model is trained by using the machine learning algorithm. The difference between an an algorithm maps all the decisions that a model is supposed to take based on the given input in order to get the correct output. So the model will use the machine learning algorithm in order to draw useful and give you an outcome That's the machine learning model. The next definition we Now a predictor variable that can be used to predict the output. Okay, let me give you an example to make you understand what Let's say you're trying to depending on his weight. So here your predictor because you're using to predict the person's height. So your predictor variable The next definition is response variable. Now in the same example, height would be the response variable. Response variable is also known as the target variable or This is the variable that by using the predictor variables. So a response variable is the feature or the output variable by using the predictor variables. Next, we have something Now training and testing that you'll come across very often in a machine learning process. So training data is basically to create the machine learning model. So, basically in a when you feed data into the machine, it'll be divided into two parts. So splitting the data into two parts is also known as data splicing. So you'll take your input data, you'll divide it into two sections. One you'll call the training data, and the other you'll So then you have something The training data is basically used to create the machine learning model. The training data helps key trends and patterns which are essential to predict the output. Now the testing data is, it must be tested in order it can predict an outcome. Now this is done by So, basically, the training The testing data is used to test the efficiency of the model. Now let's move on and get our next topic, which is machine learning process. So what is the machine learning process? Now the machine learning process involves building a predictive model that can be used to find a solution for a problem statement. Now in order to solve any there are a couple of steps Let's look at the steps. The first step is you define And the second step is data gathering, which is followed by preparing your data, data exploration, building a model, model evaluation, and Now, in order to understand let's assume that you've that needs to be solved So the problem that you need to solve is we need to predict the occurrence of rain in your local area by So, basically, you need to predict the possibility of rain by So what we did here is we basically looked at step number one, which is define the Now here you need to what are we trying to predict. Is that output going to or is it going to be a discreet variable? These are the kinds of questions in the first page, which is defining the objective So yeah, exactly what So here you need to understand which is your target variable and what are the different that you need in order So here our target a variable that can tell us whether it's going to rain or not. Input data is we'll the temperature on a particular day or the humidity level, the So you need to define the So basically, you have to at this storage. Another question that is what kind of problem are you solving. Is this a binary classification problem, or is this a clustering problem, or is this a regression problem? Now, a lo of you might not be familiar with the terms classification clustering and regression in terms Don't worry, I'll explain in the upcoming slides. All you need to understand at step one is you need to define how you're You need to understand what sort of data you need to solve the problem, how you're going to approach the problem, what are you trying to predict, what variables you'll need in and so on. Let's move on and look at step number two, which is data gather. Now in this stage, you must what kind of data is needed And is this data available? And if it is available, from and how can I get the data? Data gathering is one of steps in machine learning process. If you have to go manually it's going to take a lot of time. But lucky for us, there are which were wide data sets. All you need to do is web scraping where you just have to go One of the websites I can So if you're a beginner don't worry about data All you have to do is go and just download the data set. So coming back to the problem which is predicting the weather, the data needed for weather forecasting includes measures like humidity level, the temperature, the whether or not you live in a hill station, such data has to be collected So all the data is collected during the data gathering stage. This step is followed by data preparation, or also known as data cleaning. So if you're going around collecting data, it's almost never in the right format. And eve if you are taking data from online resources from any website, even then, the data will require The data is never in the right format. You have to do some sort of preparation and some sort of cleaning in order to make the So what you'll encounter is you'll encounter a in the data set, like you'll encounter som missing values, redundant variables, duplicate So removing such inconsistencies because they might lead to any wrongful computations and predictions. Okay, so at this stage for any inconsistencies, and you can fix them then and there. Now let me give you a small So there was a survey that I'm not sure. And a lot of data scientists were asked which step was the most annoying and time-consuming of all. And 80% of the data scientist said it was data cleaning. Data cleaning takes up 80% of their time. So it's not very easy to and corrupted data. And even if you get rid of missing values, sometimes your data It might get biased has too many missing values, and this will affect your outcome. So you'll have to fix such issue, we'll have to deal with and corrupted data. So data cleaning is actually in machine learning process. Okay, now let's move on which is exploratory data analysis. So here what you do is basically become a detective in the stage. So this stage, which is EDA is like the brainstorming Data exploration involves and the trends in your data. So at this stage, all the and any correlations between are understood. What do I mean by trends and Now let's consider our example which is we have to predict the rainfall on a particular day. So we know that there is a if the temperature has fallen law. So we know that our output will depend on variables such as temperature, Now to what level it we'll have to find out that. We'll have to find out the patterns, and we'll find out the correlations between such variables. So such patterns and trends and mapped at this stage. So this is what exploratory It's the most important This is where you'll understand what exactly your data is and how you can form the The next step in a is building a machine learning module. So all the insights and the patterns that you derive during are used to build a So this stage always begins into two parts, which is I've already discussed with you that the data that you used is always split into two parts. We have the training data Now when you're building a model, you always use the training data. So you always make use in order to build the model. Now a lot of you might be Is it different from the input data that you're feeding with the machine or is it different from the testing data? Now training data is the same input data that you're feeding to the machine. The only difference is that you're splitting the data set into two. You're randomly picking 80% of your data and you're assigning for training purpose. And the rest 20%, probably, you'll assign it for testing purpose. So guys, always remember the training data is always much more than your testing data, obviously because you need And the more data you feed the machine during the training phase, the better it will be Obviously, it'll predict better outcomes if it is being trained on more data. Correct? So the model is basically using the machine learning algorithm by using the data fed to it. Now in the case of predicting rainfall, the output will be a categorical variable, because we'll be predicting whether it's going to rain or not. Okay, so let's say we have an The two possible values is yes it's going to rain Correct, so that is out come. Our outcome is a classification So for such cases where your outcome is a categorical variable, you'll be using classification algorithms. Again, example of a is logistic regression or you can also support vector machines, you can use K nearest neighbor, and you can also use Now don't worry about these terms, I'll be discussing all But just remember that a machine learning model, you'll make use of the training data. You'll train the model by and the machine learning algorithm. Now like I said, choosing the depends on the problem statement that you're trying to solve because of N number of We'll have to choose the algorithm that is the most suitable So step number six is model evaluation and optimization. Now after you've done building a model by using the training data set, it is finally time to The testing data set is used to check the efficiency of the model and how accurately it So once the accuracy is calculated, any further improvements in the model can be implemented during this stage. The various methods that can help you improve the performance of the model, like you can use parameter tuning and cross validation methods in order to improve the Now the main things you need to remember during model evaluation and optimization is that model evaluation is nothing but you're testing how well your So at this stage, you will be In the previous stage, you'll be using the training data set. But in the model evaluation stage, you'll be using the testing data set. Now once you've tested your model, you need to calculate the accuracy. You need to calculate how accurately your model is predicting the outcome. After that, if you find that you need to improve your model in because the accuracy is not very good, then you'll use methods Don't worry about these terms, I'll discuss all of this with you, but I'm just trying to make sure that you're understanding the concept behind each of the phases It's very important you Okay, now let's move on and look at the last stage of machine Now, once a model is evaluated and once you've improved it, it is finally used to make predictions. The final output can either or a continuous variable. Now all of this depends Don't get confused about categorical variables. I'll be discussing all of this. Now in our case, because we're predicting the occurrence of rainfall, the output will be categorical variable. It's obvious because we're predicting whether it's going to rain or not. The result, we understand that this is a classification problem because we have a categorical variable. So that was the entire Now it's time to learn in which machines can learn. So let's move ahead and look at the types of machine learning. Now this is one of the most interesting concepts in machine learning, the three different ways There is something known unsupervised learning, and So we'll go through this one by one. We'll understand what and then we'll look at So defined supervised learning, it is basically a or train the machine by using the data, which is well labeled. Now, in order to understand let's consider a small example. So, as kids, we all needed A lot of us had trouble So our teachers always help an dhow it is done. Similarly, you can think as a type of machine learning that involves a guide. The label data set is a teacher that will train you to understand So the label data set is nothing I'll explain more about this in a while. So, to understand let's look at the figure on the screen. Right here we're feeding the machine image of Tom and Jerry, and the goal is for and classify the images into two classes. One will contain images of Tom and the the other will Now the main thing that you need to note in supervised learning The training data set is Now what do I mean when I say that training data set is labeled. Basically, what we're doing this how Tom looks and By doing this, you're training the machine by using label data. So the main thing that you're every input data that So, basically, you're entire Whenever you're giving an image of Tom, there's gonna be a label And when you're giving an image of Jerry, you're saying that this So, basically, you're guiding the machine and you're telling that, &quot;this is how Jerry looks, &quot;and now you need to classify them &quot;into two different classes.&quot; That's how supervised learning works. Apart from that, it's After getting the input data, you're gonna perform data cleaning. Then there's exploratory data analysis, followed by creating the model by using the machine learning algorithm, and then this is followed and finally, your predictions. Now, one more thing to note here is that the output that you get by is also labeled output. So, basically, you'll of name Tom and one of name Jerry, and you'll get them labeled. That is how supervised learning works. The most important thing is that you're training the model by using labeled data set. Now let's move on and look We look at the same example and understand how unsupervised learning works. So what exactly is unsupervised learning? Now this involves training and allowing the model to without any guidance. Alright. Like the name suggest itself, there is no supervision here. It's unsupervised learning. So think of unsupervised that learns without any guidance. Okay, in this type of machine learning, the model is not fed with any label data, as in the model has no clue that this is the image of Tom and this is Jerry. It figures out patterns and the difference between by taking in tons and tons of data. Now how do you think the and then finally gives us the output like yes this is Tom, this is Jerry. For example, it identifies such as pointy ears, to understand that this Similarly, it finds out features in Jerry, and knows that this image is of type two, meaning that the first image is different from the second image. So what the unsupervised or the model does is it'll It'll form one cluster and the other cluster from the first cluster. That's how unsupervised learning works. So the important things in unsupervised learning is that you're gonna feed The machine has to understand the patterns and discover the output on its own. And finally, the machine based on feature similarity. Now let's move on and locate the last type of machine learning, which is reinforcement learning. Reinforcement learning is quite different when compared to supervised What exactly is reinforcement learning? It is a part of machine is put in an environment, and he learns to behave by performing certain actions, and observing the rewards which To understand what imagine that you were dropped What would you do? Now panic. Yes, of course, initially, But as time passes by, you will learn how to live on the island. You will explode the environment, you will understand the type of food that grows there, the dangers of the island so on. This is exactly how It basically involves an agent, which is you stuck on the island, that is put in an unknown where he must learn by actions that result in rewards. So reinforcement learning is mainly used in advanced machine learning areas such as self-driving cars and AlphaGo. I'm sure a lot of you So, the logic behind AlphaGo is nothing but reinforcement And in reinforcement learning, there is not really any input All he has to do is he has to explore everything from scratch it's like a newborn baby with He has to go around and getting rewards, and which results in either rewards or in some sort of punishment. Okay. So that sums up the types Before we move ahead, I'd like to discuss the difference between the three types just to make the concept clear to you all. So let's start by looking In supervised learning, the machine will learn In unsupervised learning, and the machine has to learn In reinforcement learning, which interacts with the environment by producing actions and based on his actions. Now what are the type of problems that can be solved by using and reinforcement learning. When it comes to supervised learning, the two main types of is regression problems and When it comes to unsupervised learning, it is association and clustering problems. When it comes to reinforcement learning, it's reward-based problems. I'll be discussing clustering, and all of this so don't worry if you Now the type of data which is is labeled data. In unsupervised learning, it unlabeled. And in reinforcement learning, we have no predefined data set. The agent has to do Now the type of training involved in each of these learnings. In supervised learning, there as in there is the labeled data set which acts as a guide In unsupervised learning, Again, in reinforcement learning, there's no supervision at all. Now what is the approach to solve problems by using supervised, unsupervised, and reinforcement learning? In supervised learning, it is simple. You have to mal the labeled The machine knows what So you're just labeling In unsupervised learning, you're going to understand the patterns and discover the output. Here you have no clue It's not labeled. You just have to understand the patterns and you'll have to form clusters In reinforcement learning, You'll have to follow the You'll have to go around your environment. You'll have to explore the environment, and you'll have to try some actions. And only once you perform those actions, you'll know that whether or whether this is a So, reinforcement on the concept of trial and error. Okay. A popular algorithm on the linear regression, logistic regressions, support vector machines naive Bayes, and so on. Under unsupervised learning, we have the famous K-means and all of that. Under reinforcement learning, we have the famous learning I'll be discussing these So let's move on and which is the types of problems solved using machine learning. Now this is what we were when I said regression, classification, and clustering problems. Okay, so let's discuss what In machine learning, classified into three types. Every problem that is can be put interest one Okay, so the first type then we have classification So, first, let's look at So in this type problem, the output is always For example, if you want to predict the speed of a car, given the distance, it is a regression problem. Now a lot of you might not be very aware of what exactly a continuous quantity is. A continuous quantity is an infinite range of values. For example, The weight of a person, it is a continuous quantity, because our weight can be 50, 50.1, 50.001, 5.0021, 50.0321 and so on. It can have an infinite So the type of problem a continuous quantity to make So, regression problems can be solved by using supervised learning algorithms like linear regression. Next, we have classification. Now in this type of problem, the output is always a categorical value. Now when I say categorical value, it can be value such as the gender of a person Now classifying emails like spam and non-spam is that can be solved by using supervised learning like support vector machines, naive Bayes, logistic regression, K So, again, the main aim in classification is to compute the category of the data. Coming to clustering problems. This type of problem involves assigned input into two or more clusters based on feature similarity. Thus when I read this sentence, you should understand that because you don't have and the only option that Categories are formed your data is of two type. Your input data is labeled so it's gonna be a classification problem. But when a clustering problem happens, when you don't have much all you have to do is and you have to understand that data points which are similar are clustered into one group, and data points which are are clustered into another group. That's what clustering is. An example is in Netflix what happens is Netflix clusters their based on their interest, geography, and so on. This can be done by using like K-means. Okay. So guys, there were the that can be solved by So, basically, what I'm trying to say is all the problems will fall So any problem that you give it'll fall into one of these categories. Okay. Now to make things a I have collected real world data sets from online resources. And what we're gonna do is we're if this is a regression problem, or a clustering problem, or Okay. Now the problem statement in here is to study the house sales data set, and build a machine learning model that predicts the house pricing index. Now the most important when you read a problem statement is you need to understand what are the possible predictor The first thing you should If you want to understand regression, or clustering problem, look at your target variable that you're supposed to predict. Here you're supposed to predict Our house pricing index is obviously a continuous quantity. So as soon as you understand that, you'll know that this So for this, you can make use of the linear regression algorithm, and you can predict the Linear regression is the It is a supervised learning algorithm. We'll discuss more about Let's look at our next problem statement. Here you have to study and make a decision about whether to approve the loan of an applicant based on his profile. Now what is your output Your output variable is approve the loan of a applicant or not. So, obviously, your output It's either going to be yes or no. Yes is basically approved loan. No is reject loan. So here, you understand that this is a classification problem. Okay. So you can make use of or you can make use of in order to do this. So, support vector machine and KNN which is K nearest neighbor algorithms are basically supervised We'll talk more about that Moving on to our next problem statement. Here the problem statement is to cluster a set of movies as either good or average based on the social media outreach. Now if you look properly, your clue is in the question itself. The first line it says is as either good or average. Now guys, whenever you that is asking you to group the data set into different groups or to form different, different clusters, it's obviously a clustering problem. Right here you can make use of the K-means clustering algorithm, and you can form two clusters. One will contain the popular movies and the other will contain These alright small machine learning to the regression, and The key is you need to identify Now let's move on and of machine learning algorithms. So we're gonna start by supervised learning algorithms. So to give you a quick overview, we'll be discussing the linear regression, logistic regression, and decision tree, random forest, naive Bayes classifier, support vector machines, We'll be discussing So without any further delay, let's look at linear regression first. Now what exactly is a So guys, linear regression is basically a supervised learning algorithm that is used to predict a based on the values of Okay. The important thing to note here is that the dependent variable y, the variable that you're is always going to be But the independent variable x, which is basically the these are the variables to predict your output variable, which is nothing but So your independent variables can either be continuous or discreet. Okay, there is not such Okay, they can be either or they can be discreet variables. Now, again, I'll tell you in case you've forgotten. It is a vary that has infinite So I'll give you an example It can be 160 pounds, or or 160.1134 pounds and so on. So the number of possibilities and this is exactly what Now in order to understand let's assume that you want to predict the price of a stock over a period of time. Okay. For such a problem, you can by starting the relationship between the dependent variable, which is the stock price, and the independent You're trying to predict the stock price over a period of time. So basically, you're gonna varies over a period of time. So your stock price is going to be your dependent variable and the time is going to or your independent variable. Let's not confuse it anymore. Your dependent variable Okay, your independent or your predictor variable. So in our case, the a continuous quantity, because the stock price can have an infinite number of values. Now the first step in linear regression is always to draw out a relationship between your dependent and by using the best fitting linear length. We make an assumption that your dependent and independent variable is linearly related to each other. We call it linear regression because both the variables vary linearly, which means that by between these two variables, we'll get more of a straight Let's discuss the math So, this equation over here, it denotes the relationship between your independent variable x, which is here, and your dependent variable y. This is the variable Hopefully, we all know that the equation for a linear line in math I hope all of you remember math. So the equation for a linear line in math is y equals to mx plus c. Similarly, the linear regression equation is represented along the same line. Okay, y equals to mx plus c. There's just a little bit of changes, which I'll tell you what they are. Let's understand this equation properly. So y basically stands for that you're going to predict. B naught is the y intercept. Now y intercept is nothing Now in this graph, you're basically showing the relationship between and your independent variable x. Now this is the linear relationship between these two variables. Okay, now your y intercept is basically the point on the line which starts at the y-axis. This is y interceptor, which is represented by B naught. Now B one or beta is now the slope can either depending on the relationship and independent variable. The next variable that we have is x. X here represents the independent variable that is used to predict our Basically, x is used to Okay. E here denotes the error For example, this is the actual line, and these dots here represent Now the distance between these two is denoted by the error So this is the entire equation. It's quite simple, right? Linear regression will basically draw a relationship between your That's how simple linear regression was. Now to better understand I'll be running a demo in Python. So guys, before I get started I'm assuming that most of you have a good understanding of Python, because explaining Python is going to be out of the scope of today's session. But if some of you are not familiar with the Python language, I'll leave a couple of links Those will be related You can go through those and then maybe try to understand the demo. But I'd be explaining the logic So the main thing that is try and understand linear regression. So it's okay if you do not I'll try to explain as much as I can. But if you still want to I'll leave a couple of you can go to those videos. Let me just zoom in for you. I hope all of you can see the screen. Now in this linear regression demo, what we're going to do is we're going to form a linear relationship between the maximum temperature and minimum temperature We're just going to do So our task is to predict taking input feature So I'm just going to try linear regression through this demo. Okay, we'll see how it Before I get started with the demo, let me tell you something Our data set is stored The name of the data set is weather.csv. Okay, now, this contains recorded on each day at various weather Okay, the information snowfall, temperatures, wind speeds, and whether the day or other poor weather conditions. So our first step in will be to import all the So we're gonna begin our demo by importing all the required libraries. After that, we're going Our data will be stored in this variable called data set, and we're going to use a read.csv function since our data set is in the CSV format. After that, I'll be showing you how the data set looks. We'll also look at the data set in depth. Now let me just show you the output first. Let's run this demo and see first. We're getting a couple of plots which I'll talk about in a while. So we can ignore this warning. It has nothing to do with... So, first of all, we're printing So, when we print the This is the output that we get. So, basically, this 12,000 rows and 31 The 31 columns basically represent the predictor variables. So you can say that we in order to protect the weather conditions on a particular date. So guys, the main aim is weather forecast. We're going to predict the weather by using a set of predictor variables. So these are the different types of predictor variables that we have. Okay, we have something So this is what our data set looks like. Now what I'm doing in What we're doing is we're on a 2D graph in order to and see if we can manually between the variables. Here we've taken minimum temperature and maximum temperature So let's just look at this plot. Before that, let me just comment so that you see on either So, when you look at this graph, this is basically the graph and your maximum temperature. Maximum temperature are dependent variable that you're going to predict. This is y. And your minim temperature is your x. It's basically your independent variable. So if you look at this graph, you can see that there is a sort of linear relationship between the two, except there are a little bit There are a few data points But apart from that, there is between your minimum temperature and your maximum temperature. So by this graphic, you can understand that you can easily solve this problem using linear regression, because our data is very linear. I can see a clear straight line over here. This is our first graph. Next, what I'm doing is I'm just checking the average and maximum I'm just looking at the Okay. So guys, what we're doing here right now is just exploratory data analysis. We're trying to understand our data. We're trying to see the relationship between our input variable We're trying to see of the output variable. All of this is necessary So, this is what our average So if we try to understand so our average maximum temperature is somewhere between 28 28 and 32, somewhere there. So you can say that lies between 25 and 35. And so that is our average Now that you know a little you know that there is a between your input variable Now what you're going perform something known as data splicing. Let me just comment that for you. This section is nothing but data splicing. So for those of you who know that data splicing is nothing but splitting your data set into Now before we do that, I mentioned earlier that we'll because we're trying to understand the minimum temperature I'm doing this because linear regression in the So guys, in order to make I have just derived only two Even though when we check we had around 31 features, meaning that we had 31 variables which include my predictor So, basically, we had and we had one target variable, which is your maximum temperature. So, what I'm doing here these two variables, because I want to show you exactly how linear regression works. So, here what I'm doing is I'm basically extracting only these two variables from our data set, storing it in x and y. After that, I'm performing data splicing. So here, I'm basically splitting the data into training and testing data, and remember one point that I am assigning 20% of the data to our testing data set, and the remaining 80% is That's how training works. We assign maximum data set for training. We do this because we want or the machine learning algorithm We wanted to take as so that it can predict So, to repeat it again for you, so here we're just splitting the data into training and testing data set. So, one more thing to note here is that we're splitting 80% of and we're assigning the 20% The test size variable, is what is used to specify the proportion of the test set. Now after splitting the data finally, the time is For that, we need to import We need to instantiate it and call the fit method This is our linear regression class, and we're just creating an instance of the linear regression class. So guys, a good thing about Python is that you have pre-defined and you don't have call your algorithms. Instead, all you have to do, is you call this class and you have to create an instance of it. Here I'm basically creating And all you have to do is you along with your training data. So this is my training contains my training data, and I'm calling our linear which is regressor, So here, basically, We're doing nothing Now, one of the major things that linear regression model does is it finds the best value for which results in a line I've discussed what So if you want to see the calculated by our linear regression model, we just have to run this line of code. And let's looks at the output for that. So, our intercept is around 10.66 and our coefficient, these are also known as beta coefficients, coefficient are nothing but These are beta values. Now this will just help you understand the significance of your input variables. Now what this coefficient value means is, see, the coefficient value is around 0.92. This means that for every one unit changed of your minimum temperature, the change in the maximum This will just show you how significant your input variable is. So, for every one unit change the change in the maximum temperature will be around 0.92. I hope you've understood this part. Now that we've trained our algorithm, it's trying to make some predictions. To do so, what we'll use is and we'll see how accurately our algorithm predicts the percentage score. Now to make predictions, we have this line of code. Predict is basically a And all you're going to your testing data set to this. Now what you'll do is you'll compare the actual output values, which is basically stored in your y test. And you'll compare these which is in y prediction. And you'll store these called df. And all I'm doing here is So if you look at the output, These are your actual values and these are the values by building that model. So, if your actual value is 28, you predicted around 33, here your actual value is 31, meaning that your maximum And you predicted a Now, these values are I feel like the accuracy Now in some cases, you see Here it's 15. Right here it's 22. Here it's 11. But such cases are very often. And the best way to improve is by training a model with more data. Alright. You can also view this Let's see how that looks. So, basically, this is a bar graph that shows our actual values Blue is represented by your actual values, and orange is represented At places you can see that we've predicted pretty well, like the predictions are pretty close to the actual values. In some cases, the predictions So in a few places, it but all of this depends on When we saw the input data, also we saw a lot of variation. We saw a couple of outliers. So, all that also might But then this is how you Initially, you're never going to get a really good accuracy. What you should do is you have to improve your training process. That's the best way either you use a lot of data, train your model with a lot of data, or you use other methods or basically you try and find that'll help you more in To me, this looks pretty good. Now let me show you another plot. What we're doing is we're Okay, let's see how it looks. So guys, this straight line represents a linear relationship. Now let's say you get a new data point. Okay, let's say the So by using this line, you can predict that four a your maximum temperature or something like that. So, we basically drew between our input and And the final step is to evaluate the performance of the algorithm. This step is particularly how well different algorithms perform on a particular data set. Now for regression algorithms, three evaluation metrics are used. We have something known mean squared error, and Now mean absolute error is nothing but the absolute value of the errors. Your mean squared error is a That's all. It's basically you read what the error means. A root mean squared of the mean of the squared errors. Okay. So these are pretty simple to understand your mean absolute error, your root mean squared error. Now, luckily, we don't calculations manually. We don't have to code each The cycle on library comes that can be used to find out these values. Okay. So, when you run this code, you will get these values for each of the errors. You'll get around 3.19 as Your mean squared error is around 17.63. Your root mean squared Now these error values basically show that our model accuracy is not very precise, but it's still able to We can draw a good linear relationship. Now in order to improve there are a lot of methods like this, parameter tuning and all of that, or basically you can train your Apart from that, you can use or maybe you can study other predictor variables and your maximum temperature variable. There area lot of ways to improve the efficiency of the model. But for now, I just wanted how linear regression works, and I hope all of you have I hope all of you have of how linear regression works. This is a small demo about it. If any of you still have any doubts, regarding linear regression, please leave that in the comment section. We'll try and solve all your errors. So, if you look at this equation, we calculated everything here. we drew a relationship between y and x, which is basically x was y was our maximum temperature. We also calculated the And we also calculated We calculated mean squared error we calculated the root mean squared error. We also calculate the mean absolute error. So that was everything This was a simple linear regression model. Now let's move on and look which is a logistic regression. Now, in order to understand let's consider a small scenarios. Let's say that your little sister is trying to get into grad school and you want to predict in her dream school or not. Okay, so based on her you can use logistic regression to foresee the outcome. So logistic regression the set of variables and Since here we need to get into a school or not, which is a classification problem, logistic regression will be used. Now I know the first why are we not using linear The reason is that linear regression is used to predict a continuous quantity, rather than a categorical one. Here we're going to predict whether or not your sister is So that is clearly a categorical outcome. So when the result in outcome can take only classes of values, like two classes of values, it is sensible to have a as either zero or one, or in a probability form that Okay. So linear regression does If you use linear regression to model a binary outcome, the resulting model will in the range of zero and one, because linear regression works on continuous dependent variables, and not on categorical variables. That's why we make use So understand that linear to predict continuous quantities, and logistic regression is used to predict categorical quantities. Okay, now one major is people keep asking me why is logistic regression when it is used for classification. The reason it is named logistic regression is because its primary technique is very similar to logistic regression. There's no other reason behind the naming. It belongs to the general linear models. It belongs to the same but that is not the other reason behind the name logistic regression. Logistic regression is mainly used for classification purpose, because here you'll have to which is categorical in nature. So this is mainly used for classification. So, to define logistic regression for you, logistic regression is a dependent variable y, given an independent variable x, such that the dependent meaning that your output So, obviously, this is So guys, again, to clear your confusion, when I say categorical variable, I mean that it can hold yes or no, true or false, and so on. So, basically, in logistic regression, the outcome is always categorical. Now, how does logistic regression work? So guys, before I tell you take a look at this graph. Now I told you that the outcome in a logistic regression is categorical. Your outcome will either be zero or one, or it'll be a probability that So, that's why we have this S curve. Now some of you might think We can obviously have a straight line. We have something known because we can have values which will basically show the probability. So, maybe your output will be 0.7, which is a probability value. If it is 0.7, it means that your So that's why we have this Okay. Now I'll explain more about this in depth in a while. Now, in order to understand first, let's take a look at the linear regression equation. This was the logistic regression equation that we discussed. Y here stands for the dependent variable that needs to be predicted beta naught is nothing by the y intercept. Beta one is nothing but the slope. And X here represents that is used to predict y. That E denotes the error So, given the fact that x and y is the dependent variable, how can we represent a so that y ranges only Here this value basically denotes probably of y equal to one, given some value of x. So here, because this and this value basically of y equal to one, given some value of x, this is what we need to find out. Now, if you wanted to using the linear regression model, then the probability P of X equal to beta naught plus beta one into X. P of X will be equal to beta where P of X nothing but your probability of given some value of x. So the logistic regression equation is derived from the same equation, except we need to make a few alterations, because the output is only categorical. So, logistic regression does the outcome as zero or one. I mentioned this before. Instead, it calculates the falling in the class zero or class one. So that's how we can conclude that the resulting variable must be positive, and it should lie between zero and one, which means that it must be less than one. So to meet these conditions, we have to do two things. First, we can take the because taking an exponential of any value will make sure that you Correct? Secondly, you have to make sure that your output is less than one. So, a number divided by itself plus one will always be less than one. So that's how we get this formula First, we take the beta naught plus beta one plus x and then we divide it So this is how we get this formula. Now the next step is to calculate something known as a logic function. Now the logic function is nothing, but it is a link function that is represented as an S curve or as a sigmoid curve that ranges between It basically calculates the probability of the output variable. So if you look at this What we have done here and take each of our beta naught plus beta one into x as common. The RHS denotes the linear equation for the independent variables. The LHS represents the odd ratio. So if you compute this entire thing, you'll get this final value, which is basically your Your RHS here denotes the linear equation for independent variables, and your LHS represents the odd ratio which is also known as the logic function. So I told you that logic function is basically a function that bring zero and one. this will make sure that our value ranges between zero and one. So in logistic regression, on increasing this X by one measure, it changes the logic by It's the same thing as I showed So guys, that's how you derive the logistic regression equation. So if you have any doubts please leave them in the comment section, and I'll get back to you, So to sum it up, logistic for classification. The output variable will always We also saw how you derive the And one more important thing is that the relationship between the variables and a logistic regression is denoted as an S curve which is also and also the outcome does not necessarily have to be It can be calculate as a probability that the output lies in So your output can be a probability ranging between zero and one. That's why we have a sigmoid curve. So I hope all of you are clear Now I won't be showing I'll explain a couple of more Then I'll show you a practical demo where we'll use multiple to solve the same problem. Again, we'll also calculate the accuracy and se which classification Now the next algorithm is decision tree. Decision tree is one of because it's very simple to understand how a decision tree works. So guys, before this, we which was a regression algorithm. Then we discussed logistic regression, which is a classification algorithm. Remember, don't get confused just because it has the name logistic regression. Okay, it is a classification algorithm. Now we're discussing decision tree, which is again a classification algorithm. Okay. So what exactly is a decision tree? Now a decision tree is, again, a supervised machine learning algorithm which looks like an inverted tree wherein each node represents and the link between the and each leaf node represents an outcome. Now I know that's a little confusing, so let me make you understand with the help of an example. Let's say that you hosted a huge party, and you want to know are non-vegetarians. So to solve this problem, you can create a simple decision tree. Now if you look at this figure over here, I've created a decision as either vegetarian or non-vegetarian. Our last outcome here is non-veg or veg. So here you understand that this is a classification algorithm, because here you're predicting Each node over here represents So eat chicken is one variable, eat mutton is one variable, seafood is another variable. So each node represents that will help you conclude whether or not a guest is a non-vegetarian. Now as you traverse down the tree, you'll make decisions that each node until you reach the dead end. Okay, that's how it works. So, let's say we got a new data point. Now we'll pass it through The first variable is did the guest eat the chicken? If yes, then he's a non-vegetarian. If no, then you'll pass which is did the guest eat mutton? If yes, then he's a non-vegetarian. If no, then you'll pass which is seafood. If he ate seafood, then If no, then he's a vegetarian. this is how a decision tree works. It's a very simple algorithm that you can easily understand. It has drawn out letters, which Now let's understand the I just showed you an example of how the decision tree works. Now let me take the same example and tell you the structure So, first of all, we have Okay. The root node is the starting point of a decision tree. Here you'll perform the first split and split it into two other nodes or three other nodes, depending So the top most node is Now guys, about the root node, the root node is assigned to a variable that is very significant, meaning that that in predicting the output. Okay, so you assign a variable that you think is the most After that, we have something So each internal node that eventually leads to the output. Internal nodes will have Each of these are nothing I just made it into a question otherwise these are just Those are internal nodes. Terminal nodes, also represent the final class because these are basically your outcomes, non-veg and vegetarian. Branches are nothing but Okay, these connections are links between each node is known as a branch, and they're represented by arrows. So each branch will have either yes or no, true or Okay. So, guys, this is the It's pretty understandable. Now let's move on and we'll understand how the Now there are many ways but I'll be focusing on something known as the ID3 algorithm. Okay, this is something That is one of the ways the decision tree. ID3 stands for Iterative which is one of the most used to build a decision tree. It uses the concepts of in order to build a decision tree. Now you don't have to know what exactly the ID3 algorithm is. It's just a concept behind Now the ID3 algorithm has in order to build a decision tree. So the first step is you will Now what do you mean So, attribute is nothing but the predictor variable over here. So you'll select the Let's call it A. After that, you'll assign this A as a decision variable for the root node. Basically, you'll assign at the root node. Next, what you'll do you'll build a descendant of the node. Now these three steps, let's look at it with the previous example. Now here the best Okay, this is my best So I selected that attribute. And what is the next step? Step two was assigned that So I assigned eat chick at the root node. Now you might be wondering how do I know which is the best attribute. I'll explain all of that in a while. So what we did is we assigned After that, step number three build a descendant of the node. So for each value of this variable, build a descendant node. So this variable can take So for each of these values, I build a descendant node. Step number four, assign to the leaf node. To your leaf node, I have assigned classification one as That is step number four. Step number five is if data then you stop at that. However, if it is not, then you keep iterating over the tree, and keep changing the position of the predictor variables in the tree, or you change the root node also in order to get the correct output. So now let me answer this question. What is the best attribute? What do you mean by the best attribute or the best predictor variable? Now the best attribute is the one that separates the data most effectively, or it is basically a feature that best splits the data set. Now the next question in your which variable or which To do this, there are There's something known and there's something known as entropy. Now guys, in order to understand information gain and entropy, we look at a simple problem statement. This data represents the speed of a car based on certain parameters. So our problem statement and create a decision tree that classifies the speed of the car So our predictor variables obstruction, and speed limit, and or response variable, or So we'll be building a decision in order to predict the speed of car. Now like I mentioned earlier, we must first begin by deciding a variable that best splits the data set and assign that particular and repeat the same thing So step one, like we discussed earlier, is to select the best attribute A. Now, how do you know which The variable with the best derives the data into First of all, we'll We'll calculate the entropy Now this is where it ell and what exactly information gain is. Now entropy is basically used to measure the impurity or the uncertainty It is used to decide how a Information gain, on the other hand, is the most significant measure which is used to build a decision tree. It indicates how much gives us a bout the final outcome. So information gain is important, because it is used to choose a variable that best splits the data at each node for a decision tree. Now the variable with the will be used to split the Now in our data set, there So what we're gonna do is the entropy and information gain for each of the predictor variable. So we're gonna start by and entropy for the road type variable. In our data set, you can see that there are four observations. There are four observations which corresponds to the four So we're gonna begin by of the parent node. The parent node is nothing but This is our output variable, correct? It'll be used to show is slow or fast. So to find out the information gain of the speed of the car variable, we'll go through a couple of steps. Now we know that there in this parent node. First, we have slow. Then again we have slow, fast, and fast. Now, out of these four So two observations and two observations So that's how you calculate P slow is nothing by the fraction of slow outcomes in the parent node, and P fast is the in the parent node. And the formula to calculate P slow is the number of slow divided by the total number of outcomes. So the number of slow outcomes and the total number of outcomes is four. We have four observations in total. So that's how we get P of slow as 0.5. Similarly, for P of fast, you'll calculate the number of fast outcomes divided by the total number of outcomes. So again, two by four, you'll get 0.5. The next thing you'll the entropy of this node. So to calculate the entropy, All you have to do is you you'll have to substitute So P of slow we're substituting as 0.5. Similarly, P of fast as 0.5. Now when you substitute the value, you'll get a answer of one. So the entropy of your parent node is one. So after calculating the we'll calculate the information Now guys, remember that of the road type variable is of all the other predictor variables, only then the root node the road type variable. So, to calculate the information we first need to split the root node by sing the road type variable. We're just doing this in order to check if the road type variable is giving us maximum Okay, so if you notice that it has two values, either steep or flat. Now go back to our data set. So here what you can notice is whenever the road type is steep, so first what we'll do is we'll check the value of speed that we get when the road type is steep. So, first, observation. You see that whenever you're getting a speed of slow. Similarly, in the second observation, when the road type is steep, you'll get a value of slow again. If the road type is flat, you'll And again, if it is steep, So for three steep values, we have slow, slow, and fast. And when the road type is flat, we'll get an output of fast. That's exactly what I've So whenever the road type is steep, you'll get slow, slow or fast. And whenever the road type is flat, you'll get fast. Now the entropy of the Entropy is nothing but the uncertainty. There's no uncertainty over here. Because as soon as you see your output is fast. So there's no uncertainty. But when the road type is steep, you can have any one of either your speed will be slow or it can be fast. So you'll start by calculating the entropy of both RHS and LHS of the decision tree. So the entropy for the right because there's no uncertainty here. Immediately, if you see your speed of the car will be fast. Okay, so there's no uncertainty here, and therefore your entropy becomes zero. Now entropy for the left-hand side is we'll again have to calculate the fraction of P slow and So out of three observations, in two observations we have slow. That's why we have two by three over here. Similarly for P fast, we have one P fast divided by the total number of So out of these three, we When you calculate P slow and P fast, you'll get these two values. And then when you substitute you'll get the entropy as 0.9 I hope you all are understanding this. I'll go through this again. So, basically, here we are calculating the information gain and Whenever you consider road type variable, there are two values, steep and flat. And whenever the value you'll get anyone of these three outcomes, either you'll get slow, slow, or fast. And when the road type is flat, your outcome will be fast. Now because there is no uncertainty whenever the road type is flat, you'll always get an outcome of fast. This means that the entropy here is zero, or the uncertainty value here is zero. But here, there is a lot of uncertainty. So whenever your road type is steep, your output can either be So, finally, you get the Python as 0.9. So in order to calculate of the road type variable. You need to calculate I'll tell you why. In order to calculate you need to know the which we calculate as one, minus the weighted of the children. Okay. So for this formula, you need to calculate all of these values. So, first of all, you need of the weighted average. Now the total number of we saw were four. The total number of outcomes in the left child node were three. And the total number of was one. Correct? In order to verify this with you, the total number of outcomes One, two, three, and four. Coming to the child node, the total number of outcomes of the child node is one. And the total number of outcomes on the left-hand side of That's exactly what Alright, I hope you all After that, all you have to do is you have to substitute these So when you do that, you'll get the entropy of the children will be around 0.675. Now just substitute the So if you calculate the information gain of the road type variable, you'll get a value of 0.325. Now by using the same method, you're going to calculate for each of the predictor variable, for road type, for obstruction, Now when you follow the same method and you calculate the information gain, you'll get these values. Now what does this equal to 0.325 denote? Now the value 0.325 for we're getting very little information gain from this road type variable. And for obstruction, we literally have information gain of zero. Similarly, information gained This is the highest value This means that we'll have to at our root node in order So guys, don't get gives you the maximum information gain. That variable has to be So that's why we have the So if you've maintained the speed limit, then you're going to go slow. But if you haven't then the speed of your Your entropy is literally zero, and your information is one, meaning that you can use this in order to split the data set, because speed limit gives you So guys, I hope this use To sum everything up, I'll just repeat the entire So basically, here you were in order to create a decision tree that classifies the speed of So you were given three and this was your output variable. Information gained in entropy that are used to decide which variable will be assigned to the root Okay. So guys, as soon as you if you compare these two columns, that is speed limit and speed, you'll get an output easily. Meaning that if you're you're going to go slow. But if you aren't maintaining speed limit, you're going to a fast. So here itself we can has no uncertainty. So every time you've you will be going slow, and every time your you will be going fast. It's as simple as that. So how did you start? So you started by calculating the entropy of the parent node. You calculated the entropy which came down to one. Okay. After that, you calculated of each of the child nodes. In order to calculate the information gain of the child node, you stat by calculating the entropy of the right-hand side of the decision tree. Okay. Then you calculate the entropy along with the weighted average. You substitute these values in and you get the information gain for each of the predictor variables. So after you get the information gain of each of the predictor variables, you check which variable gives you the maximum information gain, and you assign that It's as simple as that. So guys, that was all Now let's look at our next which is random forest. Now first of all, what is a random forest? Random forest basically and glues them together and stable prediction. Now if already have decision trees and random forest is nothing but a collection of decision tree, why do we have to use a random forest when we already have decision tree? There are three main reasons Now even though decision and easily implemented, they are not as accurate as random forest. Decision trees work very effectively with the training data, backup they're not flexible when it comes to classifying anew sample. Now this happens because of Now overfitting is a problem that is seen with decision trees. It's something that commonly occurs when we use decision trees. Now overfitting occurs a training data to such an extent that it negatively influences the performance of the Now this means that the disturbance in the training data is recorded, and it is learned as concept by the model. If there's any disturbance or any thought of noise or any error in the training data, that is also studied by the model. The problem here is that these concepts do not apply to the testing data, and it negatively impacts to classify new data. So to sum it up, overfitting occurs whenever your model learns the training data, along with all the disturbance So it basically memorized And whenever a new data it will not predict the now this is a problem Okay. But in random forest, there's Now the basic idea behind bagging is to reduce the variations by combining the result on different samples of the data set. So your data set will be and you'll be building a decision tree on each of these samples. This way, each decision one subset of your data. So this way over fitting will get reduced because one decision tree is not studying the entire data set. Now let's focus on random forest. Now in order to understand random forest, we look at a small example. We can consider this data set. In this data, we have We have blood flow, blocked arteries, chest pain, and weight. Now these variables are used to predict whether or not a person So we're going to use this data set to create a random forest that predicts if a person has a heart disease or not. Now the first step in is that you create a bootstrap data set. Now in bootstrapping, all you have to do is you have to randomly select samples from your original data set. Okay. And a point to note is that more than once. So if you look at the original data set, we have a abnormal, normal, Look at the blood flow section. Now here I've randomly selected samples, normal, abnormal, and I've selected one sample twice. You can do this in a bootstrap data set. Now all I did here is I created a bootstrap data set. Boot strapping is nothing used to make predictions on a data by re-sampling the data. This is a bootstrap data set. Now even though this seems very simple, in real world problems, you'll never get such small data set. Okay, so bootstrapping is actually a little Usually in real world problems, you'll have a huge data set, and bootstrapping that a pretty complex problem. I'm here because I'm making you understand how random forest works, so that's why I've Now you're going to use that you created, and you're going to build Now one more thing to you will not be using Okay, so you'll only be at each node. So, for example, we'll at each step. So if you begin at the root node here, we will randomly select two variables as candidates for the root node. Okay, let's say that and blocked arteries. Out of these two variables we that best separates the sample. Okay. So for the sake of this example, let's say that blocked arteries is the most significant predictor, and that's why we'll Now our next step is to for each of these upcoming branch nodes. Here we'll again select as candidates for each and then choose a variable that best separates the samples, right? So let me just repeat this entire process. So you know that you start by selecting the root node. In random forest, you'll randomly select a couple of variables for each node, and then you'll calculate which variable best splits the data at that node. So for each node, we'll randomly select two or three variables. And out of those two, three variables, we'll see which variable Okay, so at each node, we'll because calculating Basically, that's what I mean. At every node, you'll and entropy of two or three variables, and you'll see which variable has the highest information gain, and you'll keep descending downwards. That's how you create a decision tree. So we just created our Now what you do is you'll and you'll repeat the entire process. So each decision tree will based on the predictor variables that you've assigned Now let's say for this decision tree, you've assigned blood flow. Here we have blocked Here we might have blood flow So your output will depend is at the root node. So each decision tree will based on the predictor variable that you assigned in that tree. Now what you do is you'll you'll create a new bootstrap data set, and then again you'll And for that decision tree, you'll consider only and you'll choose the by calculating the information gain. So you will keep repeating this process. So you just keep repeating Okay. And you'll keep creating Okay. So having a variety of decision is what makes it more effective than an individual decision tree. So instead of having an which is created using all the features, you can build a random forest that uses multiple decision trees wherein each decision of predictor variables. Now step number four is of a new data point. So now that you've let's see how it can be used to predict whether a new patient Okay, now this diagram about the new patient. Okay, this is the data He doesn't have blocked arteries. He has chest pain, and his Now all you have to do is down each of the decision So, the first decision tree shows that yes, this person has heart disease. Similarly, you'll run the through every decision Then depending on how many you'll classify that patient as either having heart disease or not. All you have to do is you have to run the information of the new patient through all the decision in the previous step, and the final output is each of the class is getting. Okay, let's say that three decision trees said that yes the patient and one decision tree said So this means you will obviously classify the patient as having a heart disease because three of them voted for yes. It's based on majority. So guys, I hope the concept is understandable. Now the next step is you will evaluate the efficiency of the model. Now earlier when we created we left out one entry sample. This is the entry sample we left out, because we repeated one sample twice. If you'll remember in here we repeated an entry twice, and we missed out on one of the entries. We missed out on one of the entries. So what we're gonna do is... So for evaluating the model, we'll be using the data Now in a real world problem, about 1/3 of the original in the bootstrap dataset. Because there's a huge amount of data in a real world problem, so 1/3 of the original data set is not included in the bootstrap data set. So guys, the sample data set which is not there in is known as out-of-bag data set, because basically this is Now the out-of-bag data set is used to check the Because the model was not created by using the out-of-bag data set, it will give us a good understanding of whether the model is effective or not. Now the out-of-bag data set is nothing but your testing data set. Remember, in machine and testing data set. So your out-of-bag data set is nothing but your testing data set. This is used to evaluate the So eventually, you can of a random forest by the proportion of out-of-bag samples that because the out-of-bag data set is used to evaluate the So you can calculate the accuracy by understanding how many samples or was this out-of-bag data set correctly able to classify it. So guys, that was an explanation about how random forest works. To give you an overview, let me just run you through So basically, this was our data set, and all we have to do whether a patient has So, our first step was to A bootstrap data set is observations from your original data set, and you can also have duplicate values in your bootstrap data set. Okay. The next step is you're going by considering a random for each decision tree. Okay. So, the third step is create a bootstrap data set. Again, create a decision tree. So this iteration is until you are multiple decision trees. Now that you've created a random forest, you'll use this random forest So if you're given a new data point and you have to classify it into one of the two classes, we'll just run this new information through all the decision trees. And you'll just take the majority of the output that you're as your outcome. Now in order to evaluate you'll use the out of Now the out-of-bag sample that was not included in but this sample is coming from your original data set, guys. This is not something This data set was there but it was just not mentioned in your bootstrap data set. So you'll use your out-of-bag sample in order to calculate the accuracy of your random forest. So the proportion of out-of-bag samples that are correctly classified of your model. So that is all for random forest. So guys, I'll discuss other classification algorithms with you, and only then I'll show you a demo on the classification algorithms. Now our next algorithm is Naive Bayes is, again, a supervised classification algorithm, which is based on the Bayes Theorem. Now the Bayes Theorem basically follows a probabilistic approach. The main idea behind naive Bayes is that the predictor variables in are independent of each other, meaning that the outcome of a model depends on a set of independent variables that have nothing to do with each other. Now a lot of you might called naive. Now usually, when I tell they keep asking me why is So in real world problems aren't always independent of each other. There is always some correlation between the independent variables. Now because naive Bayes to be independent of any it is called naive. This is an assumption Now let's understand the math behind the naive Bayes algorithm. So like I mentioned, the is the Bayes Theorem, which is also known as the Bayes Rule. The Bayes Theorem is used to calculate the conditional probability, which is nothing but the based on information about This is the mathematical Now, in this equation, the LHS is nothing but the conditional probability given the event B. P of A is nothing but P of B is probability of event B. And PB of A is nothing but of event B occurring, given the event A. Now let's try to understand Now consider this data set of around thousand 500 observations. Okay, here we have the We have either cat, parrot, or turtle. These are our output classes, and the predictor variables are swim, wings, green color, and sharp teeth. Okay. So, basically, your type and swim, wings, green, and sharp teeth are your predictor variables. Your output variables has three classes, cat, parrot, and turtle. Okay. Now I've summarized this table The first thing you can see shows that out of 500 cats, 450 can swim, meaning that 90% of them can. And zero number of cats have wings, and zero number of cats and 500 out of 500 cats have sharp teeth. Okay. Now, coming to parrot, it have true value for swim. Now guys, obviously, in real world. I don't think there are but I've just created this data set so that we can understand naive Bayes. So, meaning that 10% of parrots Now all 500 parrots have wings, and 400 out of 500 parrots and zero parrots have sharp teeth. Coming to the turtle class, all 500 turtles can swim. Zero number of turtles have wings. And out of 500, hundred meaning that 20% of the And 50 out of 500 So that's what we understand Now the problem here is we are given our observation over here, given some value for swim, What we need to do is we need to predict whether the animal is a based on these values. So the goal here to predict parrot, or a turtle based on all these defined parameters. Okay. Based on the value of swim, we'll understand whether or is it a parrot, or is it a turtle. So, if you look at the observation, the variables swim and and the outcome can be It can either be a cat, or it can be a turtle. So in order to check all you have to do is the conditional probability at each step. So here what we're doing is we need to calculate the probability that this is a cat, given that it can swim First, we'll calculate the given that it's a cat. And two, the probability that it is green and the probability of it being green, given that it is a cat, and then we'll multiply it with the probability of it being a cat divided by the probability Okay. So, guys, I know you all can It's quite simple. So once you calculate you'll get a direct value of zero. Okay, you'll get a value of zero, meaning that this animal Similarly, if you do this for parrots, you calculate a conditional probability, you'll get a value of 0.0264 divided by probability We don't know this probability. Similarly, if you check you'll get a probability of 0.066 divided by P swim comma green. Okay. Now for these calculations, The value of the denominator is the same, and the value of and the probability of it being a turtle is greater So that's how we can correctly predict that the animal is actually a turtle. So guys, this is how naive Bayes works. You basically calculate the conditional probability at each step. Whatever classification needs to be done, that has to be calculated There's a lot of statistic that comes into naive Bayes. And if you all want to and probability, I'll leave a link in the description. You all can watch that video as well. There I've explain exactly what conditional probability is, and the Bayes Theorem is So you all can check out that video also. And apart from this, if regarding any of the algorithms, please leave them in the comment section. Okay, I'll solve your doubts. And apart from that, I'll for each of the algorithms Because if you want more of each of the algorithms, you can check out that content. Since this is a full course video, I have to cover all the topics, and it is hard for me in-depth of each topic. So I'll leave a couple of You can watch those videos as well. Make sure you checkout the probability and statistics video. So now let's move on and which is the K nearest neighbor algorithm. Now KNN, which basically is, again, a supervised that classifies a new data or the output class, of its neighboring data points. That's why it's called K nearest neighbor. So let's try to understand Okay, let's say that we want a machine to distinguish between the So to do this, we must input our data set of cat and dog images, and we have to train our based on certain features. For example, features such as pointy ears can be used to identify cats. Similarly, we can identify dogs based on their long ears. So after starting the data set during the training phase, when a new image is given to the model, the KNN algorithm will classify it into either cats or dogs, depending on the similarity Okay, let's say that a it will classify that image as cat, because it is similar to the cat images, because it's similar to its neighbors. In this manner, the KNN the data point based to their neighboring data points. So this is a small example. We'll discuss more about Now let me tell you a couple of features of KNN algorithm. So, first of all, we know that it is a supervised learning algorithm. It uses labeled input data set to predict the output of the data points. Then it is also one of the simplest machine learning algorithms, and it can be easily implemented for a varied set of problems. Another feature is that meaning that it does not For example, naive Bayes because it assumes that all are in no way related to each other. It has assumptions about the model. K nearest neighbor has That's why it's considered Another feature is that Now, lazy algorithm that memorizes the training set, instead of learning a from the training data. Now, even though KNN is mainly it can also be used for regression cases. So KNN is actually both a classification and a regression algorithm. But mostly, you'll see that it'll be used on the four classification problems. The most important feature about a K nearest neighbor is that it's based on feature similarity with its neighboring data points. You'll understand this in the example that I'm gonna tell you. Now, in this image, we We have class A which is squares and class B which are triangles. Now the problem statement is to assign the new input data point to one of the two classes by using the KNN algorithm. So the first step in the KNN algorithm is to define the value of K. But what is the K in the Now the K stands for the and that's why it's got the Now, in this image, I've This means that the algorithm will consider the three neighbors that are closest to the new data point in order to decide the So the closest between the data point is calculated by using measure such as Euclidean distance which I'll be explaining in a while. So our K is equal to three. The neighbors include two So, if I were to classify based on K equal to three, then it should be assigned It should be assigned to squares. But what if the K value is set to seven. Here I'm basically telling my algorithm to look for the seven nearest neighbors and classify the new data point into the class it is most similar to. So our K equal to seven. The neighbors include three So if I were to classify based on K equal to seven, then it would be assigned to class B, since majority of its Now this is where a So how do we know which K for K nearest neighbor. Now there are a couple methods used to calculate the K value. One of them is known as the elbow method. We'll be discussing the elbow method in the upcoming slides. So for now let me just show you the measures that are involved behind KNN. Okay, there's very simple math behind the K nearest neighbor algorithm. So I'll be discussing the Now in this figure, we have between P one and P two by I'm sure a lot of you already know what Euclidean distance is. It is something that we learned I'm not sure. So all you're doing is So the formula is the whole square plus y two minus y one the whole square, and the root of that is It's as simple as that. So Euclidean distance is used as a measure to check the So basically, KNN uses to check the closeness of a new data point with its neighbors. So guys, it's as simple as that. KNN makes use of simple measures in order to solve very complex problems. Okay, and this is one of the reasons why KNN is such a commonly used algorithm. Coming to support vector machine. Now, this is our last algorithm under classification algorithms. Now guys, don't get paranoid Support vector machine actually is one of the simplest algorithms Okay, it is basically into different classes. It's a classification algorithm. Now unlike most algorithms, SVM makes use of something which acts like a decision boundary between the separate classes. Okay. Now SVM can be used to generate multiple separating hyperplane, such that the data is and each segment contains So, a few features of SVM include that it is a supervised learning algorithm, meaning that it's going to Another feature is that it is again a regression and a Even though SVM is mainly there is something known as That is useful regression problems. Now, SVM can also be used by using kernel tricks. Non-linear data is basically data that cannot be separated by using a single linear line. I'll be talking more about this in the upcoming slides. Now let's move on and Now again, in order to make you understand how support vector machine works, you look at a small scenario. For a second, pretend that you own a farm and you have a problem. You need to set up a fence to protect your rabbits Okay, now, you need to decide where you want to build your fence. So one way to solve support vector machines. So if I do that and if I try between the rabbits and the wolves, it looks something like this. Now you can clearly build So in simple terms, this is exactly how your support vector machines work. It draws a decision boundary, which is nothing but a hyperplane between any two classes or classify them. Now I know that you're where to draw a hyperplane. The basic principle behind SVM is to draw a hyperplane that best separates the two classes. In our case, the two classes are the rabbits and the wolves. Now before we move any further, let's discuss the different terminologies that are there in support vector machine. So that is basically a hyperplane. It is a decision boundary the two classes. Now, support vectors, what So when you start with the you start by drawing a random hyperplane. And then you check the distance between the hyperplane from each of the class. These closest data are known as support vectors. Now these two data points are the closest to your hyperplane. So these are known as support vectors, and that's where the name comes from, support vector machines. Now the hyperplane is drawn based on these support vectors. And optimum hyperplane will be the one which has a maximum distance from each of the support vectors, meaning that the distance and the support vectors has to be maximum. So, to sum it up, SVM by using a hyperplane, such that the distance and the support vector is maximum. Now this distance is Now let's try to solve a problem. Let's say that I input a new data point and I want to draw a hyperplane such that it best separates So what do I do? I start out by drawing a hyperplane, and then I check the distance and the support vectors. So, basically here, I'm trying to check if the margin is maximum But what if I drew the The margin for this hyperplane than the previous one. So this is my optimal hyperplane. This is exactly how you understand which hyperplane needs to be chosen, because you can draw multiple hyperplanes. Now, the best hyperplane is the one that has a maximum module. So, this is my optimal hyperplane. Now so far it was quite easy. Our data was linearly separable, which means that you to separate the two classes. But what will you do if You possibly cannot draw You possibly cannot draw It doesn't separate the two classes. We can clearly see rabbits and wolves in both of the classes. Now this is exactly where non-linear SVM comes into the picture. Okay, this is what the Now, kernel is basically to transform data into another dimension that has a clear dividing So, basically the kernel function offers the user the option of transforming non-linear spaces into linear ones. Until this point, if you notice that we were plotting our data We had x and y-axis. A simple trick is transforming x and y, into a new feature space, which involves a new variable z. So, basically, what we're doing is we're visualizing the data on a three dimensional space. So when you transform the you can clearly see a dividing margin between the two classes of data. You can clearly draw a line in the middle that separates these two data sets. So guys, this sums up support vector machines. Support vector machines are Now, this was all for our supervised learning algorithms. Now, before I move on to I'll be running a demo. We'll be running a demo in order to understand all that we studied so far. Earlier in the session, we ran a demo for the regression algorithms. Now we'll run for the So, enough of theory. Let's open up Python, and let's start looking at how these classification algorithms work. Now, here what we'll be doing is we'll implement multiple by using the scikit-learn. Okay, it's one of the most popular machine learning tool for Python. Now we'll be using a simple data set for the task of training a between the different types of fruits. The purpose of this demo is to implement multiple classification algorithms for the same set of problem. So as usual, you start by importing all your libraries in Python. Again, guys, if you don't know Python, check the description box, I'll leave a link there. You can go through that video as well. Next, what we're doing is in the form of table. You stored it in a variable called fruits. Now if you wanna see the let's print the first few So, this is our data set. These are the fruit labels. So we have around four We have apple, we have mandarin, orange, and lemon. Okay. Now, fruit label denotes of apple, which is one. Mandarin has two. Similarly, orange is labeled as three. And lemon is labeled as four. Then a fruit subtype is basically the family of fruit it belongs to. Mass is the mass of the fruit, width, height, and color score. These are all our predictor variables. We have to identify the type of fruit, depending on these predictor variables. So, first, we saw a couple Next, if you want to see this is what it looks like. There are around 59 observations with seven predictor variables, which is one, two, three, We have seven variables in total. Sorry, not predictor variables. This seven denotes both your predictor and your target variable. Next, I'm just showing you in our data set, which is apple, mandarin, Next, I'm just grouping Okay. So we have 19 apples in our data set. We have 16 lemons. We have only five mandarins, and we have 19 oranges. Even though the number of we'll have to work with it, because right now I'm understand the classification algorithms. The main aim for me is so that you understand how classification algorithms work. Now what you can do is in order to see the frequency Okay, I'll show you what The number of apples We have I think around And similarly, this is Okay. So this is a small visualization. Guys, visualization is when it comes to machine learning, because you can see most of the relations and correlations by plotting graphs. You can't see those correlations by just running code and all of that. Only when you plot different you'll understand how they are related. One of the main task in machine learning is to visualize data. It ensures that you understand the correlation between data. Next, what we're gonna do is we'll graph something known as a box plot. Okay, a box plot basically the distribution of your data. Let me run the box plot, and I'll show you what exactly I mean. So this is our box plot. So, box plot will basically give you a clearer idea of the distribution of your input variables. It is mainly used in and it represents the and its variability. Now, the box plot contains upper quartile and lower quartile. So the box plot basically or something known as IQR. IQR is nothing but your third quartile subtracted from your first quartile. Now again, this involves So I'll be leaving a link You can go through that video. I've explained statistics range, and all of that in there. So, one of the main reasons is to detect any sort Since the box plot spans the IQR, it detects the data point that lie outside the average range. So if you see in the colored space, most of the data is whereas here the data are Height also is not very well distributed, but color space is This is what the box plot shows you. So guys, this involves a lot of math. ALl of these, each and every involves a lot of math. So you know it's necessary of statistics, probability, Now, next, what we'll do Histogram will basically show you the frequency of occurrence. Let me just plot this, and So here you can understand Okay, some pairs of these For example, mass and width, they're somehow correlated So this suggests a high correlation and a predictable relationship. Like if you look at the So for each of the predictor variables, I've drawn a histogram. For each of that input data, Now guys, again, like i said, plotting graphs is very important because you understand that you cannot understand by just looking at your data, or just running operations on your data. Repeat, or just running code on your data. Okay. Now, next, what we're dividing the data set into So, basically, I've created which has your predictor variables. It has mass, width, height, color space. And you have assigned that as X, since this is your input, and y is your output That'll show whether it is an apple, orange, lemon, and so on. Now, the next step that is pretty evident. Again, this is data splicing. So data splicing, by now, I'm sure all of you know what it is. It is splitting your data into So that's what we've done over here. Next, we're importing something Scaling or normalizing your data is very important in machine learning. Now, I'm seeing this because your raw data can be very biased. So it's very important Now when I say normalize your data, so if you look at the value of mass and if you look at the you see that mass is ranging whereas height is in single digit, and color score is not So, if some of your variables you know they have a very high scale, like they're in two whereas other variables are then your output is It's obvious that it's That's why you have to scale your data in such a way that all of these values will have a similar range. So that's exactly what Okay. Now since we have already divided our data into training and testing data, our next step is to build the model. So, first, we're gonna be using the logistic regression algorithm. I've already discussed logistic It's a classification algorithm, which is basically used of a categorical variable. So we already have the logistic All you have to do is you have to give an instance for this function, which is logreg over here. And I'm fitting this instance meaning that I'm running the algorithm with the training data set. Once you do that, you can calculate the accuracy by using this function. So here I'm calculate the accuracy on the training data set and on the testing data set. Okay, so let's look at the output of this. Now guys, ignore this future warning. Warnings are ignored in Python. Now, accuracy of the logistic on the training data set is around 70%. It was pretty good on But when it comes to classifying it's only 40%, which is not that good for a classifier. Now again, this can depend for which problem statement is logistic regression more suitable. Next, we'll do the same thing So again, we just call the and we'll fit it with and we'll calculate the accuracy of the decision tree on the training, and the testing data set. So if you do that for a decision tree on the training data set, you get 100% accuracy. But on the testing data set, you have around 87% of accuracy. This is something that I that this is decision trees are very good with training data set, because of a process known as overfitting. But when it comes to classifying the outcome on the testing data set, the accuracy reduces. Now, this is very good compared For this problem statement, decision trees works better that logistic regression. Coming to KNN classifier. Again, all you have to do is you have to call the K neighbor And you have to fit this If you calculate the accuracy we get a good accuracy actually. On the training data set, we get an accuracy of 95%. And on the testing data set, it's 100%. That is really good, actually achieved more of an accuracy than on a training data set. Now all of this depends on the value of K that you've chosen for KNN. Now, I mentioned that to choose the K value in I'll be discussing the elbow So, don't worry if you Now, we're also using a Here we're using a Gaussian Gaussian is basically a type I'm not going to go into depth of this, because it'll just extend our Okay. And if you want to know more about this, I'll leave a link in the description box. You can read all about the Now, the math behind this is the same. It uses naive Bayes, it uses Now again, we're gonna call this class, and then we're going to run our data, training data on it. So using the naive Bayes classifier, we're getting an accuracy of 0.86 on the training data set. And on the testing data set, Okay. Now let's do the same thing Importing the support vector classifier. And we are fitting the training We're getting an accuracy of around 61% on the training data set and Now guys, this accuracy and all depends also on the problem statement. It depends on the type of data that support vector machines get. Usually, SVM is very Now since we have a very it's sort of obvious by So guys, these were a couple that I showed you here. Now, because our KNN classifier classified our data set more accurately we'll look at the predictions Okay Now we're storing all our predicted values in the predict variable. now in order to show you the accuracy of the KNN model, we're going to us something So, a confusion matrix is a table that is often used to describe the performance of a classification model. So, confusion matrix actually represents a tabular representation of actual versus predicted values. So when you draw a confusion matrix on the actual versus predicted values for the KNN classifier, this is what the confusion Now, we have four rows over here. If you see, we have four rows. The first row represents apples, second, mandarin, third represents lemons, and fourth, oranges. So this four value corresponds meaning that it was all the four apples. Okay. This one value represents one comma one, meaning that our classifier this as mandarins. This matrix is drawn on actual values versus predicted values. Now, if you look at the summary we'll get something known f1-score and support. Precision is basically the ratio of the correctly predicted to the total predicted So the correctly predicted and there are total of four apples in the testing data set. So that's where I get a precision of one. Okay. Recall on the other hand is the ratio of correctly to all the observations in the class. Again, we've correctly and there are a total of four apples. F1-score is nothing but of your precision and your recall. Okay, and your support basically denotes the number of data points that were correctly classified. So, in our KNN algorithm, all our data points were So, 15 out of 15 were correctly classified because we have 100% accuracy. So that's how you read a confusion matrix. Okay, you have four important measures, precision, recall, f1-score, and support. F1-score is just the ratio of your precision and your recall. So precision is basically positive observations positive observations. Recall is a ratio of the predicted positive observations to So guys, that was it for the demo of classification algorithms, we discuss regression algorithms and we discussed Now it's time to talk about unsupervised learning algorithms. Under unsupervised learning algorithms may try to solve clustering problems. And the most important known as K-means clustering. So we're going to discuss and also show you a demo the clustering algorithm, and you're seeing how it Now, the main aim of the K-means algorithm is to group similar elements So it is basically the process by which objects are classified interest a predefined number of groups, so that they are much from one group to another group, but as much similar as Now what I mean is let's this population into such that each group has people within a specified range of age. Let's say group one is of people Similarly, group two is between 23 and 35. Group three is 36 and 39 So let's say you're trying to cluster people into different So for such problems, you can make use of the K-means clustering algorithm. One of the major applications is seen in targeted marketing. I don't know how many of you are aware of targeted marketing. Targeted marketing is all about to a specific audience. Let's say you're trying or a fancy set of bags and all of that. And the perfect audience for such product would be teenagers. It would be people around So that is what target Your product is marketed that might be interested in it. That is what targeted marketing is. So K means clustering is use A lot of eCommerce websites All of these make use in order to target the right audience. Now let's see how the Now the K in K-means denotes Let's say I give you a data and you want to cluster this That means your K will be equal to four. So K basically stands for in your data set, or the number of clusters You start by defining the number K. Now for each of these clusters, you're going to choose a centroid. So for every cluster, there are four cluster in our data set. For each of these clusters, you'll randomly select as a centroid. Now what you'll do is you'll start computing the distance from that centroid to every other point in that cluster. As you keep computing the centroid and the distance between the centroid and other data points in that cluster, your centroid keep shifting, because you're trying to get Whenever you're trying to get the centroid keeps shifting, because the centroid keeps Let's try to understand how K-means works. Let's say that this data Let's say if you're given and you're asked to us So your first step will be to decide the number of So let's say I wanna create So my K value will be equal to three. The next step will be to provide centroids of all the clusters. What you'll do is initially three data points as your centroids for your three different clusters. So basically, this red denotes Blue denotes a centroid And this green dot denotes the centroid for another cluster. Now what happens in K-means, the algorithm will calculate the Euclidean distance of and assign the points Now since we had three centroids here, now what you're gonna do is you're going to calculate the distance from each and every data point to all the centroids, and you're going to check which data point is closest to which centroid. So let's say your data point A is closest to the blue centroid. So you're going to assign the data point A to the blue cluster. So based on the distance between the centroid and the cluster, you're going to form Now again, you're going and you're going to form a new cluster which is from better clusters, because you're recomputing Basically, your centroids represent the mean of each of your cluster. So you need to make sure that your mean is actually So you'll keep recomputing this centroids until the position of your That means that your or the average of that particular cluster. So that's how K-means works. It's very simple. All you have to do is you have to start by defining the K value. After that, you have to randomly pick the number of case centroids. Then you're going to of each of the data and you're going to assign a data point to the centroid it is closest to. That's how K-means works. It's a very simple process. All you have to do is us and you have to recompute until the centroid value does not change, until you get a constant centroid value. Now guys, again, in K-means, you make use of distance I've already discussed what So, to summarize how K-means works, you start by picking Then you pick a centroid. After that, you calculate the distance of the objects to the centroid. Then you group the data based on their distance. You have to keep computing the centroid until each data point is so that's how K-means works. Now let's look at the elbow method. The elbow method is basically the most optimum k value So the elbow method is You start off by computing for some values of K. Now sum of squared error is basically the sum of the squared distance between each member of the So you basically calculate for different values of K. For example, you can consider K value as two, four, six, eight, 10, 12. Consider all these values, compute the sum of squared Now if you plot your K value against your sum of squared errors, you will see that the error This is because the number If the number of clusters increases, it means that the distortion gets smaller. The distortion keeps decreasing as the number of clusters increase. That's because the more clusters you have, the closer each centroid So as you keep increasing your distortion will also decrease. So the idea of the elbow at which the distortion So if you look at this the distortion is abruptly decreasing. So this is how you find the value of K. When your distortion drops abruptly, that is the most optimal K value you should be choosing for So let me repeat the idea You're just going to graph the versus the squared sum of errors. This graph will basically Now the distortion if you increase the number of clusters, and there is gonna be wherein the distortion Now for that point, you need and that'll be your most optimal K value. That's how you choose your K-means K value and your KNN K value as well. So guys, this is how the elbow method is. It's very simple and it Now we're gonna look at a small demo which involves K-means. This is actually a very interesting demo. Now guys, one interesting application of clustering is in color For example, imagine you have an image with millions of colors in it. In most images, a large number and many of the pixels in the image will have similar or Now having too many colors in your image makes it very hard for image So this is one area where It's applied in image image compression, and so on. So what we're gonna do in this demo is we are going to use an image from the scikit-learn data set. Okay, it is a prebuilt image, and you will require to install We're going to use an image form the scikit-learn data set module. So we'll begin by importing and we'll be loading our image as china. The image is china.jpg, and we'll be loading this So if you wanna look at you can run this command. So we're gonna get a So we're getting 427 Now this is basically a of size, height, width, and RGB. It contains red, blue, as integers from zero to 255. So, your pixel values and I think zero stands for your black, and 255 represents white if I'm not wrong. And basically, that's what Now one way we can view this set of pixels is as a cloud of points in a So what we'll do is we and rescale the color, so that they lie between zero and one. So the output of this will be So basically, we can in this color space. Now what we're gonna do is we're gonna try and plot our pixels. We have a really huge data set which contains around 16 So this denotes a very, So, let me show you what it looks like. We have red against green These are our RGB value, and we can have around 16 million possible combination of colors. The data set is way too So what we'll do is we will to just 16 colors. We can do that by using because we can cluster similar So this is exactly where Now, one thing to note here is because we're dealing with we will use the MinibatchKMeans. This operates on subsets of the data to compute the results more just like the K-means algorithm, because I told you this Even though this is a single image, the number of pixel combinations which is a lot. Now each pixel is when you've taken image When you have data points and data values, that's different. When you're starting an image or image segmentation, each and every pixel is considered. So, basically, you're building matrices of all of these pixel values. So having 16 million pixels So, for that reason, we'll It's very similar to K-means. The only difference is that it'll operate on subsets of the data. Because the data set is too So, basically, we're making use of K-means in order to cluster these 16 million color combinations into just 16 colors. So basically, we're gonna form 16 clusters in this data set. Now, the result is the where every pixel is assigned the color of its closest cluster center. Let's say that there which are very close to green. So we're going to cluster into one cluster. We'll keep doing this So, obviously, to do this, we'll be using the clustering method, K-means. Let me show you what So, basically, this was the original image from the scikit data set, and this is the 16-color segmented image. Basically, we have only 16 colors here. Here we can have around 16 million colors. Here there are only 16 colors. If you can't also, you can Now obviously there's a lot but this is how you study an image. Remove all the extra contrast You try to reduce the pixel to a smaller set of data as possible. The more varied pixels you have, the harder it is going to be for you to study the image for analysis. Now, obviously, there are some details which are lost in this. But overall, the image So here, basically, we've compressed this with a compression factor because each cluster will have around one million data points in it, or pixel values in it, or pixels in it. Now this is an interesting There are actually better ways you can compress information on image. So, basically, I showed you this example because I want you to understand the power of K-means algorithm. You can cluster a data into just 16 colors. Initially, there were 16 million, and now you can cluster it to 16 colors. So guys, K-means plays a very huge role in computer vision image processing, object detection, and so on. It's a very important algorithm when it comes to detecting objects. So in self-driving cars and all can make use of such algorithms. So guys, that was all and supervised learning. Now it's the last type which is reinforcement learning. Now this is actually a very interesting part and it is quite difference from So we'll be discussing all the concepts that are involved in And also reinforcement learning is a little more advanced. When I say advanced, I in applications such as self-driving cars and is also a part of a lot of deep learning applications, such as AlphaGo and so on. So, reinforcement learning has a different concept to it itself. So we'll be discussing So just to brush up your information about reinforcement learning, reinforcement learning is where an agent is put in and he learns how to by performing certain actions which it gets from these actions. Reinforcement learning is all about taking an appropriate action in in a particular situation. Now let's understand with an analogy. Let's consider a scenario wherein a baby is learning how to walk. This scenario can go about The first is baby starts walking and it makes it to the candy. And since the candy is the end goal, the baby is very happy and it's positive. Meaning, the baby is happy and it received a positive reward. Now, the second way this can go in is that the baby starts walking, but it falls due to some hurdle between. That's really cute. So the baby gets hurt and It's negative because the baby is sad and it receives a negative reward. So just like how we humans by trial and error, reinforcement learning is also similar. Here we have an agent, and in this case, the agent is the baby, and the reward is the candy with many hurdles in between. The agent is supposed to find the best possible path That is the main goal of Now the reinforcement learning process has two important components. It has something known as an agent and something known as an environment. Now the environment is the setting that the agent is acting on, and the agent represents the reinforcement learning algorithm. The whole reinforcement The environment is the setting in which you place the agent, and it is the setting wherein the agent takes various action. The reinforcement learning process starts when the environment Now the agent, based on it takes an action in Now, in turn, the environment and the respective Now the agent will update its knowledge with the reward returned to evaluate its last actions. The loop continues until the environment sends a terminal state which means that the all of its task. To understand this better, let's suppose that our agent The reinforcement learning process can be broken down into a couple of steps. The first step is the which is basically the player, he collects a state, S So whenever you're playing Counter Strike, you start off with You start off from the first level. Now based on this state, S naught, the reinforcement learning agent will take an action, A naught. So guys, action can be Now if the agent moves that is also considered as an action. So initially, the action will be random, because the agent has no Let's suppose that you're for the first time. You have no idea about how to play it, so you'll just start randomly. You'll just go with whatever, whichever action you think is right. Now the environment is now in a stage one. After passing stage zero, the environment will go into stage one. Once the environment updates the reinforcement learning agent will get a reward R one This reward can be anything or you'll get additional weapons when you're playing Counter Strike. Now this reinforcement until the agent is dead or and it continuously outputs a sequence of state action and rewards. This exactly how It starts with the agent and the agent will randomly take some action in state zero. After taking an action, he'll either get a reward and move on to state number one, or he will either die and So this will keep happening until the agent reaches the last stage, or he dies or reaches his destination. That's exactly how Now reinforcement learning is the logic behind a lot of games these days. It's being implemented in A lot of you who play Now let's talk about a couple of reinforcement learning So, first, we have something Like I mentioned, an agent is the reinforcement learning algorithm that learns from trial and error. An agent is the one for example, a solider in Counter Strike navigating through the game, going right, left, and all of that. Is the agent taking some action? The environment is because the world through which the agent moves. Now the environment, basically, takes the agent's current and returns the agent's reward and its next state as the output. Next, we have something known as action. All the possible steps is considered as an action. Next, we have something known as state. Now the current condition is known as a state. Reward is an instant to apprise the last action of the reinforcement learning agent. All of these terms are Next, we have something known as policy. Now, policy is the approach to determine the next action based on the current state. Policy is basically the approach with which you go around Next, we have something known as value. Now, the expected long-term as opposed to the short-term rewards R, is known as value. Now, terms like discount and value, I'll be discussing in the upcoming slides. Action-value is also very except it takes an extra parameter known as the current action. Don't worry about action and Q value. We'll talk about all of So make yourself familiar because we'll be seeing a So, before we move any further, let's discuss a couple of more reinforcement learning concepts. Now we have something known So if you haven't realized it already, the basic aim of is to maximize the report. How does this happen? Let's try to understand this So, basically the agent of reward maximization. Now that's exactly why in such a way that he so that the reward is maximal. Now let me explain a reward maximization with a small example. Now in this figure, you there is some meat, and there is a tiger. Our reinforcement His end goal is to eat before being eaten by the tiger. Now because the fox is a very clever guy, he eats the meat that is closer to him, rather than the meat which because the closer he gets to the tiger, the higher are his That's pretty obvious. Even if the reward near the that'll be discounted. This is exactly what discount is. We just discussed it This is done because of that the tiger might Now the next thing to of a reward works. Now, in order to understand discounting, we define a discount rate called gamma. The value of gamma is And the smaller the gamma, the larger the discount and so on. Now don't worry about these concepts, gamma and all of that. We'll be seeing that in So let's move on and known as exploration and Now guys, before that, I reward maximization. Basically, the main aim is to maximize the rewards Now, one of the most important concepts in reinforcement learning is the exploration and Now, exploration, like the name suggests, it's about exploring and capturing more information about an environment. On the other hand, exploitation is about using the already known to heighten your reward. Now consider the same example that we saw previously. So here the fox eats only the meat chunks which are close to him. He doesn't eat the bigger meat chunks which are at the top, even though the bigger meat chunks would get him more reward. So if the fox only focuses he will never reach This process is known as exploitation. But if the fox decide to explore a bit, it can find the bigger reward, which is the big chunk of meat. This is known as exploration. So this is the difference and exploration. It's always best if the agent tries to figure out a the maximum number of rewards. Now let's discuss in reinforcement learning, which is known as the Basically, the mathematical a solution in reinforcement learning is called Markov's decision process. It's the mathematics behind Now, in a way, the purpose is to solve a Markov's decision process. Now in order to get a solution, there are a set of parameters in a Markov's decision process. There's a set of actions A, there's a set of states S, a reward R, policy pi, and value V. Also, this image represents how a reinforcement learning works. There's an agent. The agent take some The environment, in turn, and it will give him the next state. That's how reinforcement learning works so to sum everything up, what happens in Markov's decision process and reinforcement learning is the agent has to take an action A to transition from the start state to the end state S. While doing so, the agent for each action he takes. Now the series of action define the policy and to find the value. The main goal here is by choosing the optimum policy. So you're gonna choose in order to maximize the rewards. That's the main aim of To understand Markov's decision process, let's look at a small example. I'm sure all of you already know about the shortest path problem. We all had such problems to find the shortest path. Now consider this representation Here, our goal is to between two nodes. Let's say we're trying to find the shortest path between Now each edge, as you can see, has a number linked with it. This number denotes the cost to traverse through that edge. So we need to choose a in such a way that our cost is minimum. So in this problem, the set of states are denoted by the nodes A, B, C, D. The action is to traverse For example, if you're going from to A C, there is an action. C to B is an action. B to D is another action. The reward is the cost Policy is the path taken So we need to make sure in such a way that our cost is minimal. So what you can do is you and you can take baby steps Initially, only the next So from A, you can either go to B or you can go to C. So if you follow the greedy approach and take the most optimum step, which is choosing A to C, instead of choosing A to B to C. Now you're at node C and you want to traverse to node D. Again, you must choose So if you traverse from A to C, and C to B, and B to D, your cost is the lest. But if you traverse from A to C to D, your cost will actually increase. Now you need to choose a policy that will minimize your cost over here. So let's say, for example, the agent chose A to C to D. It came to node C, and Now the policy followed by is exploitation type, because we didn't explore the other notes. We just selected three nodes And the policy we followed is not actually an optimal policy. We must always explore more to find out the optimal policy. Even if the other nodes are or is actually increasing our cost, we still have to explore and find out if those paths are actually better. That policy is actually better. The method that we implemented here is known as the policy-based learning. Now the aim here is to among all the possible policies. So guys, apart from policy-based, we also have value-based approach and action-based approach. Value based emphasizes on And in action base, we emphasize on each action taken by the agent. Now a point to note is that all of these learning approaches The end goal is to through the environment, and acquire the most number of rewards. So this was very simple to understand Markov's decision process, exploitation and exploration trade-off, and we also discussed the different reinforcement I hope all of this was understandable. Now let's move on and understand an algorithm known as So guys, Q-learning is one of in reinforcement learning. And we'll discuss this algorithm with the help of a small example. We'll study this example, and then we'll implement the and we'll see how it works. So this is how our Now the problem statement in any one of the rooms numbered zero, one, two, three, and four. And the goal is for the agent to reach outside the building, which is room number five. So, basically, this zero, represents the building, and five represents a room Now all these rooms Now these gaps that you are basically those, and each room is numbered The outside of the building can be taught of as a big room which is room number five. Now if you've noticed this diagram, the door number one and door number four lead directly to room number five. From one, you can directly go to five, and from four, also, you But if you want to go to then you'll first have to room number one, and So these are indirect links. Direct links are from room So I hope all of you are clear You're basically going to have a reinforcement learning agent, and than agent has to in such a way that he To solve this problem, first, what we'll do is on a graph. Now each room is denoted as anode, and the links that are connecting Alright, so we have node one to five, and the links between each of these nodes represent the doors. So, for example, if you look you can see that there from one to five, meaning that you can directly to your goal, which is room number five. So if you want to go from you can either go to room number one, and then go to five, or you can go from room and then to five. So guys, remember, end goal Now to set the room number what we'll do is we'll to each door. The doors that lead will have an instant reward of 100. So, basically, one to five and four to five will also Now other doors that are not directly connected to the target room will have a zero reward, because they do not directly So let's say you placed the So to go from room number three to one, the agent will get a reward of zero. And to go from one to five, the agent will get a reward of hundred. Now because the doors are two-way, the two arrows are assigned to each room. You can see an arrow and one coming from the room. So each arrow contains an instant reward as shown in this figure. Now of course room number five will loop back to itself and all other direct will carry a reward of hundred. Now in Q-learning, the with the highest reward. So that if the agent arrives at the goal, it will remain there forever. So I hope all of you are Now, the terminologies in Q-learning include two terms, state and action. Okay, your room basically So if you're in state two, it basically means that Now the action is basically from one room to the other room. Let's say you're going to room number three. That is basically an action. Now let's consider some more example. Let's say you place the and he has to get to the goal. So your initial state or room number two. Then from room number two, which is state three. Then from state three, you can or go to state one or state four. If you go to state four, from your goal room, which is five. This is how the agent Now in order to depict the we're going to create a matrix Okay, this is represented by R or also known as the R matrix. Now the minus one in this That is basically where there isn't a link between the nodes that is Now there is no link That's why it's minus one. Now if you look at this diagram, there is no direct link from zero to one. That's why I've put minus But if you look at zero comma four, we have a value of zero over here, which means that you can but your reward is going to be zero, because four is not your goal state. However, if you look at the matrix, look at one comma five. In one comma five, we have This is because you can directly go from room number one to five, and five is the end goal. That's why we've assigned Similarly, for four comma five, we have a reward of hundred. And for five comma five, we have a reward of hundred. Zeroes basically represent other links, but they are zero because they So I hope you all understood It's very simple. Now before we move any further, we'll be creating another matrix known as the equitable Q matrix. Now the Q matrix basically of what the agent has The rules of the Q matrix will represent the current The columns will represent leading to the next state, and the formula to calculate the Q matrix is this formula, right? Here we have Q state comma action, R state comma action, which is nothing but the reward matrix. Then we have a parameter which I'll explain shortly. And then we are multiplying of Q next state comma all actions. Now don't worry if you haven't I'll explain this with a small example. For now, let's understand So, basically, the value of Gamma will be between zero and one. If Gamma is closer to zero, it means that the agent only immediate rewards. Now, if the Gamma is closer to one, it means that the agent with greater weight. Now what exactly I'm trying to say is if Gamma is closer to one, then we'll be performing I hope you all remember what exploitation and exploration trade-off is. So, if your gamma is closer to zero, it means that the agent is not going to explore the environment. Instead, it'll just and it'll just traverse But if your gamma it means that the agent will traverse through all possible states, meaning that it'll perform exploration, not exploitation. So the closer your gamma the more your agent will explore. This is exactly what Gamma parameter is. If you want to get the best policy, it's always practical that which is closer to one. We want the agent to as much as possible so that it can get the best I hope this is clear. Now let me just tell you what a Q-learning So you begin the Q-learning algorithm by setting the Gamma parameter and the environment rewards in matrix R. Okay, so, first, you'll We've already calculated We need to set the Gamma parameter. Next, you'll initialize Now why do you do this? Now, if you remember, I said that Q matrix is basically Initially, obviously, the agent has no memory It's new to the environment and you're placing it randomly anywhere. So it has zero memory. That's why you initialize After that, you'll select and you place your agent Then you'll set this initial Now from the current state, that will lead you to the next state. Then you'll basically for this next state, based on all the possible Then you'll keep computing the skew value until you reach the goals state. Now that might be a little bit confusing, so let's look at this entire Let's say that first, you're gonna begin with setting your Gamma parameter. So I'm setting my Gamma parameter to 0.8 which is pretty close to one. This means that our agent as much as possible. And also, I'm setting the Meaning, I'm in state So basically, your agent is The next step is to initialize So this is a Q matrix. You can see that because the agent has no memory at all. He hasn't traversed to any node, so he has no memory. Now since the agent is in room one he can either go to room number three or he can go to room number five. Let's randomly select room number five. So, from room number five, you're going to calculate for the next state based So all the possible actions is one, four, and five. So, basically, the traversing that's why I put one comma five over here, state comma action. Your reward matrix will Now R one comma five is basically hundred. That's why I put hundred over here. Now your comma parameter is 0.8. So, guys, what I'm doing here is I'm just substituting So let me just repeat this whole thing. Q state comma action. So you're in state number one, correct? And your action is you're So your Q state comma Again, your reward matrix R So here's you're gonna put hundred, plus your Gamma parameter. Your Gamma parameter is 0.8. Then you're going to for the next state based So let's look at the next state. From room number five, You can go to four or you can go to five. So your actions are five and five comma five. That's exactly what I mentioned over here. Q five comma one, Q five comma You're basically putting all from state number five. From here, you'll calculate the maximum Q value that you're Now your Q value is zero, because, initially, your So you're going to get five comma four, and five comma five. So that's why you'll get 0.8 and zero, and hence your Q one comma This hundred comes from R one comma five. I hope all of you understood this. So next, what you'll do is you'll update this one comma five because you just calculated So I've updated it over here. Now for the next episode, we'll start with a randomly Again, let's say that we randomly Now from room number three, you can either go to room Let's randomly select room number one. Now, from room number five, you'll calculate the maximum Q value for the next possible actions. So let's calculate the Q formula for this. So your Q state comma action because you're in state number three and your action is you're So your R three comma one, let's see what R three comma one is. R three comma one is zero. So you're going to put zero over here, plus your Gamma parameter, which is 0.8, and then you're going to check from room number one, and you're going to from these two. So Q one comma three and Q one comma five denote your next possible So Q one comma three is zero, but Q one comma five is hundred. So we just calculated this So, out of zero and hundred, hundred is your maximum value, so you're going to choose hundred. Now 0.8 into hundred is nothing but 80. So again, your Q matrix gets updated. You see an 80 over here. So, basically what you're doing you're updating your Q value, you're just calculating you're putting it in your Q matrix so that your agent remembers that, okay, when I went from room I had a Q value of hundred. Similarly, three to one So basically, this Q matrix represents the memory of your agent. I hope all of you are clear with this. So basically, what we're gonna do is we're gonna keep until we've gone through and reach the goal state, which is five. Also, our main aim here is to to get to room number five. Now let's implement the exact So that was a lot of theory. Now let's understand how Alright, so we begin by We're gonna be using the After that, we'll import the R matrix. We've already created the R matrix. This is the exact matrix that I showed you a couple of minutes ago. So I've created a matrix called R and I've basically stored If you want to see the R So, basically, this is your R matrix. If you remember, node one to five, you have a reward of hundred. Node four to five, you and five to five, you because all of these nodes Correct? Next, what we're doing is which is basically a six into six matrix. Which represents all the And this matrix is basically zero. After, that we're setting Now guys, you can play and you know you can to 0.7 or 0.9 and see how much more or whether you perform exploitation. Here I've set the Gamma parameter 0.8 which is a pretty good number. Now what I'm doing is I'm You can randomly choose this state according to your needs. I've set the initial state as one. Now, this function will basically give me all the available actions Since I've set my initial state as one, It'll give me all the possible actions. Here what I'm doing is since I'm checking in my row number one, which value is equal to Those denote my available actions. So look at our row number one. Here we have one zero and This is one comma four and So if you look at the row number one, since I've selected the we'll consider row number one. Okay, what I'm doing is in row number one, I have two numbers which or greater than zero. These denote my possible actions. One comma three has the value of zero and one comma five has which means that the agent can either go to room number three or it can go to room number five. What I'm trying to say you can basically go to room number three or room number five. This is exactly what I've coded over here. If you remember the reward matrix, from one you can traverse to and room number five directly. Okay, that's exactly what I've mentioned in my code over here. So this will basically give from my current state. Now once I've moved to me next state, I need to check the available What I'm doing over If you're remember, from room number one, we can And from three and five, I'll randomly select the state. And from that state, I need to find out all possible actions. That's exactly what I've done over here. Okay. Now this will randomly from all my available actions. Next, we need to update our Q matrix, depending on the actions that we took, if you remember. So that's exactly what this Now guys, this entire is I hope all of you remember the formula, which is Q state comma action, R state comma action plus Max value will basically out of the all possible actions. I'm basically computing this formula. Now this will just update the Q matrix. Coming to the training phase, what we're gonna do is we Here I've set a range of 10,000, meaning that my agent will You can set this depending and 10,000 iteration is So, basically, my agent 10,000 possible iterations in order to find the best policy. Now this is the exact same We're setting the current state, and then we're choosing from the current state. The from there, we'll Here we'll calculate a Q value and we'll update the Alright. And here I'm doing nothing, but I'm printing the trained Q matrix. This was the training phase. Now the testing phase, basically, you're going to randomly You're gonna choose a current state, and you're going to keep looping through this entire code, until you reach the goal state, That's exactly what I'm Also, in the end, I'm That is basically the to reach room number five. Now if I set the current state as one, it should give me the best policy to reach to room number Alright, let's run this code, and let's see if it's giving us that. Now before that happens, I which is the best possible way to get from room number It's obviously directly like this. One to five is the best policy to room number five. So we should get an That's exactly what we're getting this is a Q matrix with all the Q values, and here we are getting the selected path. So if your current state is one, your best policy is to Now, if you want to let's say we set the current state to two. And before we run the code, let's see which is the best possible way to get to room number From room number two, you can go to three, then you can go to one, and This will give you a reward of hundred, or you can go to room number three, then go to four, and then go to five. This will also give you Our path should be something like that. Let's save it and let's run the file. So, basically, from stage two, you're going to say three, then to four, and then to five. This is our best possible path from two to room number five. So, guys, this is exactly how the Q learning algorithm works, and this was a simple implementation of the entire example Now if any of you still have doubts regarding Q learning or make sure you comment them and I'll try to answer all of your doubts. No we're done with machine learning. We've completed the whole We've understood reinforcement learning, supervised learning, Before I'll get to deep learning, I want to clear a very A lot of people get confused between AI machine because, you know, machine learning and deep learning are very common applications. For example, Siri is an application of artificial intelligence, machine learning, and deep learning. So how are these three connected? Are they the same thing or how exactly is the relationship between machine learning, and deep learning? This is what I'll be discussing. now artificial intelligence of getting machines to mimic But when it comes to machine learning, machine learning is a subset that focuses on getting by feeding them data. That's exactly what machine learning is. It is a subset of artificial intelligence. Deep learning, on the other hand, is a subset of machine learning that uses the concept of neural networks to solve complex problems. So, to sum it up, artificial intelligence, machine learning, and deep learning, are interconnected fields. Machine learning and deep learning aids artificial intelligence by providing a set of to solve data-driven problems. That's how AI, machine are related. I hope all of you have and doubts about AI, Now let's look at our next topic, which is limitations of machine learning. Now the first limitation is not capable enough to This is where the input and So handling and processing becomes very complex and it takes up a lot of resources. This is also sometimes known So, to understand this in simpler terms, look at the image shown on this slide. Consider a line of hundred yards and let's say that you dropped Now it's quite convenient by simply walking along the line. This is very simple because as single dimensional entity. Now next, you consider that you have a square of hundred yards, and let's say you dropped a Now it's quite evident that to find the coin within that square as compared to the previous scenario. The square is, let's say, Let's take it a step ahead Okay, let's say there's and you have dropped a coin Now it becomes even more difficult for you to find the coin this time, because this is a three So, as your dimension increases, the problem becomes more complex. So if you observe that the complexity is increasing the increase and in real life, the that we're talking about that makes it very complex and a high dimensional data can easily be found in used natural language processing, Now in K-means itself, we saw that we had 16 That is a lot of data. So this is why machine It cannot be used in the because image recognition and and they have a lot of That's why machine learning when it comes to such uses cases. Now the second major challenge what are the features it should look for that will play an important role in predicted the outcome and Now this process is something Now feeding raw data to and this is the reason is a critical part of Now the challenge for the because the effectiveness of the algorithm depends on how insightful As a programmer, you have to tell the machine And depending on these features, you have to predict the outcome. That's how machine learning works. So far, in all our demos, we saw that we were providing we were providing input variables that will help us predict the outcome. We were trying to find and we're trying to find out the variable that is very important in So this becomes a challenge That's why it's very difficult to apply machine learning model to complex problems like object recognition, natural language processing, and so on. Now all these problems and all these limitations led to the introduction of deep learning. Now we're gonna discuss Now deep learning is by which we can overcome the challenges of feature extraction. This is because deep learning models are capable of learning to focus on the right features by themselves, which requires very little Basically, deep learning mimics That is it learns from experience. So in deep learning, what happens is feature extraction happens automatically. You need very little So deep learning will learn the model, and it will understand which is important in predicting the outcome. Let's say you have millions for a particular problem statement. How are you going to sit down and understand the significance of each of these predictor variables it's going to be almost impossible to sit down with so many features. That's why we have deep learning. Whenever there's high dimensionality data or whenever the data is really large and it has a lot of features and a lot of predictor Deep learning will extract and understand which in predicting your output. So that's the main idea Let me give you a small example also. Suppose we want to make a system that can recognize the in an image. Okay, so, basically, that can identify the faces of If we solve this by using the typical machine learning algorithms, we'll have to define nose, ears, et cetera. Okay, and then the system will identify which features are more Now, if you consider deep deep learning will automatically which are important for classification, because it uses the whereas in machine learning we have to manually define these features on our own. That's the main difference and machine learning. Now the next question is Now when people started their main aim was to Okay, deep learning studies called the brain cell or a neuron. All of you biology students will know what I'm talking about. So, basically, deep learning is inspired from our brain structure. Okay, in our brains, we have and these neurons are as artificial neurons, which are also called perceptrons. Now, before we understand how or artificial neurons work, let's understand how these because I'm not sure how many of you are bio students over here. So let's understand the and how we can mimic this functionality in a perceptron or in So, guys, if you loo at this image, this is basically an image If you focus on the structure it has something known dendrites. These dendrites are basically Now the inputs are basically and it's passed on the So, through dendrites, you're from other neurons, basically, input. Then the cell body will and the axon will transmit The axon will fire up and it will get passed So similar to this, a perceptron receives multiple inputs, and applies various and provides us an output. These multiple inputs are or your predictor variables. You're feeding input data or to a perceptron, and this perceptron will apply various functions and transformations, and it will give you an output. Now just like our brain consists of multiple connected neurons we also build something known as a network of artificial neurons called artificial neural networks. So that's the basic concept To sum it up, what Now deep learning is a collection of statistical machine learning techniques used to learn feature of artificial neural networks. So the main idea behind deep learning is artificial neural networks which work exactly like Now in this diagram, you can see that there are a couple of layers. The first layer is known This is where you'll The last layer is known which provides your desired output. Now, all the layers which are and your output layer are Now, they can be any thanks to all the resources So you can have hundreds of Now, the number of hidden layers and the number of perceptrons will entirely depend on the problem or on the use case that So this is basically So let's look at the Here what we want to do image recognition using deep networks. First, what we're gonna this high dimensional To mach the dimensionality the input layer will contain multiple sub layers of perceptrons so that it consume the entire input. Okay, so you'll have multiple Now, the output received will contain patterns and the edges of the images, This output will then be fed where it'll be able to like your eyes, nose, Now from here, the output will be fed to hidden layer number two, where it will be able to form entire faces it'll go deeper into face recognition, and this output of the hidden layer will be sent to the output layer or any other hidden layer that is there before the output layer. Now, finally, the output layer based on the result that you'd get from your previous layers. So, this is exactly how This is a small analogy that I use to make you understand Now let's understand what a So like I said, perceptron is basically an artificial neuron. For something known as single layer and multiple layer perceptron, we'll first focus on Now before I explain what you should known that perceptrons A single layer perceptron is a linear or a binary classifier. It is used mainly in supervised learning, and it helps to classify into separate classes. So this diagram basically A perceptron has multiple inputs. It has a set of inputs until X n. Now each of these input is Okay, so W one represents W two represents the weight Now how you assign these weights is a different thing altogether. But for now, you need is assigned a particular weightage. Now what a perceptron does on these weighted inputs, and So, basically, these weighted inputs go through something known as summation. Okay, summation is nothing but the product of each of your input with Now after the summation is done, this passed onto transfer function. A transfer function is nothing I'll be discussing more The activation function. And from the activation function, you'll get the outputs So guys, you need to in a perceptron. So, firstly, you have the input values. You have X one, X two, X three. You have something known and then you have something and finally the activation function. Now, all the inputs X are multiplied with So, X one will be multiplied with W one. This is known as the summation. After this, you'll add and we'll call them as the weighted sum. This is done using the summation function. Now we'll apply the weighted sum to a correct activation function. Now, a lot of people have a confusion about activation function. Activation function is also Now, in order to understand this word stems from the way neurons in a human brain work. The neuron becomes activate only after a certain potential is reached. That threshold is known as Therefore, mathematically, it can be represented by a function that reaches saturation after a threshold. Okay, we have a lot of like signum, sigmoid, You can think of activation function as a function that maps the input to the respective output. And now I also spoke Now why do we assign weights What weights do is they show a strength of a particular input, or how important a particular input is for predicting the final output. So, basically, the weightage of an input denotes the importance of that input. Now, our bias basically allows us to shift the activation function in order to get a precise output. So that was all about perceptrons. Now in order to make you let's look at a small analogy. Suppose that you wanna go to a party happening near your hose. Now your decision will First is how is the weather. Second probably is your or your boyfriend going with you. And third, is there any Let's say these are the three factors that you're going to consider So, depending on these predictor variables or these features, you're going to decide whether or go and party. Now, how is the weather is We'll represent this with a value X one. Is your wife going with Any public transport is available is your another input X three. Now, X one will have two One represents that the weather is good. Zero represents weather is bad. Similarly, one represents and zero represents that And in X three, again, one represents that there is public transport, and zero represents that Now your output will One means you are going to the party, and zero means you will Now in order to understand weightage, let's say that the most is your weather. If the weather is good, it means that you will Now if you weather is not good, you've decided that you'll sit at home. So the maximum weightage is So if your weather is really good, you will go to the party. It is a very important whether you're going to sit at home or you're going to go to the party. So, basically, if X one equal to one, your output will be one. Meaning that if your weather is good, you'll go to the party. Now let's randomly assign W one is the weight W two is the weight with X two and W three is the weight Let's say that your W one is six, your W two is two, and W three is two. Now by using the activation function, you're going to set a threshold of five. Now this means that it will fire when the weather is good and won't fire if the weather is bad, irrespective of the other inputs. Now here, because your weightage is six, so, basically, if you which has a weightage of six, that means you're 100% going to go. Let's say you're considering This means that you're not going to go, because your weightage is two So if your weightage is it means that you're not going to go. Now let's consider another scenario where our threshold is three. This means that it'll fire when either X one is high or the other two inputs are high. Now W two is associated with Let's say the weather is bad and you have no public transportation, meaning that your x one and only your x two is one. Now if your x two is one, your weightage is going to be two. If your weightage is two, you will not go because the The threshold value is if X two and X three only then you'll go, or only if x one is true, then you'll go. So you're assigning you will go for sure This is how you assign threshold. This is nothing but your So guys, I hope all of you understood, the most amount of weightage is associated with the in predicting your output. This is exactly how a perceptron works. Now let's look at the Now in a perceptron, there There's only an input layer, and there is an output layer. We have no hidden layers in between. And because of this, you cannot classify non-linearly separable data points. Okay, if you have data, how will you separate this. You cannot use a perceptron to do this. Alright, so complex problems that involve a lot of parameters cannot be solved by a single layer perceptron. That's why we need something known as multiple layer perceptron. So now we'll discuss something known as multilayer perceptron. A multilayer perceptron of a single layer perceptron, but with one or more hidden layer. Okay, and that's why it's So in a single layer perceptron, we had only input layer, output layer. We didn't have any hidden layer. Now when it comes to there are hidden layers in between, and then there is the output layer. It was in this similar first, you'll have the and so on. And each of these inputs W one, W two, W three, and so on. Then you'll calculate of each of these inputs and their weights. After that, you'll send or the activation function, and you'll finally get the output. Now, the only thing is hidden layers in between, one or more than one hidden layers. So, guys, this is how a It works on the concept of Feed forward means or each layer is connected So that's what feed forward networks are. Now when it comes to assigning weights, what we do is we randomly assign weights. Initially we have input We randomly assign some and so on. Now it's always necessary we assign to our input, those weights are actually correct, meaning that those weights in predicting your output. So how a multilayer perceptron works is a set of inputs are passed Now the activations from through the next layer. And from that layer, it's until you reach the output layer. From the output layer, class one and class two. Basically, you'll classify your input into one of the two classes. So that's how a multilayer A very important concept the is back propagation. Now what is back propagation. Back propagation algorithm is a supervised learning method Okay, now why do we need back propagation? So guys, when we are in the beginning, we initialize weights with some random values, or Now, obviously, we need to actually are correct, meaning that these weights of each predictor variable. These weights have to fit our model in such a way that our So let's say that we randomly selected some weights in the beginning, but our model output than our actual output, meaning that our error value is very huge. So how will you reduce this error. Basically, what you need to do is we need to somehow explain to the model that we need to change the weight in such a way that the So the main thing is the is very highly related. The weightage that you give to each input will show how much error because the most significant variables will have the highest weightage. And if the weightage is not correct, then your output is also not correct. Now, back propagation is a in such a way that your outcome is precise and your error is reduced. So, in short back a multilayer perceptron. It's basically use to update your weights in such a way that your and that your error is reduced. So training a neural network So the most common deep learning algorithm for supervised training of is known as back propagation. So, after calculating the and passing them through we propagate backwards to reduce the error. It's as simple as that. So in the beginning, you're to each of your input. Now these inputs will go and it'll go through all the hidden layers and give us an output. Now when you get the output, the output is not very precise, or it is not the desired output. So what you'll do is and you start updating your weights in such a way that your error is as minimum as possible. So, I'm going to repeat this once more. So the idea behind back propagation is to choose weights in such a way that your error gets minimized. To understand this, we'll Let's say that we have a data Okay, your input is zero, one, two, but your desired output now the output of your model when W equal to three is like this. Notice the difference and your desired output. So, your model output is three, but your desired output is two. Similarly, when your model output is six, your desired output is Now let's calculate the error The error is zero over here because your desired output is zero, and your model output is also zero. Now the error in the second case is one. Basically, your model output Three minus two, your error is one. Similarly, your error for which is six minus four. When you take the square, this is actually a very huge difference, your error becomes larger. Now what we need to do is we need to update the weight value in such a way that our error decreases. Now here we've considered So when you consider the weight as four, your model output becomes Your desired output is So your model output becomes which is a lot. So guys, I hope you all know how to calculate the output over here. What I'm doing is I'm with your weightage. The weightage is four, so zero into four will give me zero. One into four will give me four, and two into four will give me eight. That's how I'm getting my For now, this is how I'm That's how you calculate your weightage. Now, here, if you see is supposed to be zero, two, and four, but we're getting an output So our error is actually increasing as we increase our weight. Our error four W equal to four have become zero, four, and 16, whereas the error for W equal to three, zero, one, and four. I mean the square error. So if you look at this, as our error is increasing. So, obviously, we know that there is no point in increasing But if we decrease the value of W, our error actually decreases. Alright, if we give a weightage of two, our error decreases. If we can find a relationship basically, if you increase the weight, your error also increases. If you decrease the weight, Now what we did here some random value to W, and then we propagated forward. Then we notice that there is some error. And to reduce that error, and increase the value of W. After that, we notice that and we came to know that we Obviously, if your error is increasing with increasing your weight, you will not increase the weight. So again, we propagated backwards, and we decreased the W value. So, after that, we noticed So what we're trying the value of weight in such a way that the error becomes so we need to figure out whether we need to increase or decrease thew eight value. Once we know that, we keep in that direction, until the error becomes minimum. Now you might reach a point where if you further update the weight, the error will again increase. At that point, you need to stop. Okay, at that point is where your final weight value is there. So, basically, this Now this point is nothing If you update the weights further, your error will also increase. Now you need to find out where and that is where your So let me summarize the steps for you. First, you'll calculate the error. This is how far your model output is from your actual output. Then you'll check whether the error is minimized or not. After that, if the error is very huge, then you'll update the weight, and you'll check the error again. You'll repeat the process now once you reach the you'll stop updating the weights, and we'll finalize your weight value. This is exactly how Now in order to tell you is we're using a method Okay, this method is used to adjust all the weights in the network with an aim of reducing the So how gradient descent the first step is you by considering the below equation. Here you're subtracting the from your network output. Step two is based on the error you get, you will calculate the with respect to the change in the weight. The learning rate is in the beginning itself. Step three is based on you will calculate the new weight. Alright, your updated plus the rate of change of weight. So guys, that was all about back propagation and weight update. Now let's look at the limitations So far, we were discussing which uses the feed forward network. Let's discuss the limitations of these feed forward networks. Now let's consider an example Okay, let's say you've to classify images of various animals. Now let's consider an example. Here the first output is an elephant. We have an elephant. And this output will have nothing to do with the previous output, which is a dog. This means that the output at time T is independent of the Now consider this scenario where you will require the use of previously obtained output. Okay, the concept is very As you turn every page, you need an understanding of the previous pages if you want to make then you need to know That's exactly what In order to understand deep learning, you have to understand machine learning. So, basically, with the the new output at time T plus one has nothing to do with or T minus one, or T minus two. So feed forward networks cannot be used while predicting a word in a sentence, as it will have absolutely no relationship with the previous set of words. So, a feed forward use cases wherein you have based on your previous outcome. So, in a lot of use cases, your previous output will also So, for such cases, you may not make use of feed forward network. Now, what modification can you make so that your network can learn from your previous mistakes. For this, we have solution. So, a solution to this is So, basically, let's say you have an input at time T minus one, and you'll get some output when Now, some information from is fed to the next input, which is input at time T. Some information from this output is fed into the next input, which is input at T plus one. So, basically, you keep from the previous input to the next input. That's how recurrent neural So recurrent networks are a type of artificial neural networks designed to recognize such as text, genomes, time series data, sensors, stock markets, and government agencies. So, guys, recurrent neural a very important part of deep learning, because recurring neural networks have applications in a lot of domains. Okay, in time series and in stock markets, the main network that I use are recurrent neural networks, because each of your inputs are correlated now to better understand let's consider a small example let's say that you go and the trainer has given you a schedule for your workout. So basically, the exercises are repeated after every third day. Okay, this is what your So, make a note that all in a proper order or in first, let us use a feedforward network to try and predict the type of exercises that we're going to do. The inputs here are Day and your health status. Okay, so, neural network has to be trained using these inputs to provide of the exercise that we should do. Now let's try and understand recurrent neural networks. In recurrent neural networks, what we'll do is we'll consider the inputs of the previous day. Okay, so if you did a then you can do a bicep exercise today, and this goes on for the rest of the week. However, if you happen the data from the previously can be considered. It can be done like this. So, if a model is it can obtain from the previous exercise, the output on the model In such cases, if you at T minus one in order to In such cases, recurrent neural So, basically, I'm feeding some inputs through the neural networks. You'll go through a few functions, and you'll get the output. So, basically, you're based on past information So that's how recurrent Now let's look at another known as convolutional neural network. To understand why we need let's look at an analogy. How do you think a Consider this image. This is a New York skyline image. On the first glance, you'll see a lot of buildings How does a computer process this image? The image is actually broken which is the red, green, and blue. It reads in the form of RGB values. Now each of these color with the image's pixel then the computer will recognize the value associated with each pixel, and determine the size of the image. Now for the black and white images, there is only one channel, but the concept is still the same. The thing is we cannot make use of fully connected networks when it comes to convolutional neural networks. I'll tell you why. Now consider the first input image. Okay, first image has size about 28 into 28 into three pixels. And if we input this to a neural network, we'll get about 2,352 weights in the first hidden layer itself. Now consider another example. Okay, let's say we have an image of 200 into 200 into three pixels. So the size of your first hidden layer becomes around 120,000. Now if this is just imagine the number of to process an entire complex image set. This leads to something because all of the hidden They're massively connected. There's connection between Because of this, we face overfitting. We have way too much of data. We have to use way too many neurons, which is not practical. So that's why we have something known as convolutional neural networks. Now convolutional neural networks, like any other neural network are made up of neurons with So each neuron receives several input. It takes a weighted sum over them, and it gets passed on through and finally responds with an output. So, the concept in is that the neuron in a particular layer will only be connected to a small region of the layer before it. Not all the neurons will be connected in a fully-connected manner, which leads to overfitting because we need way too many neurons to solve this problem. Only the regions, which are significant are connected to each other. There is no full connection in convolutional neural networks. So gus, what we did so far is we discussed what a perceptron is. We discussed the different types of neural networks that are there. We discussed a feedforward neural network. We discuss multi layer perceptrons we discussed recurrent neural networks, and convolutional neural networks. I'm not going to go too much in depth with these concepts now I'll be executing a demo. If you you haven't understood any theoretical concept of deep learning, please let me know in the comment section. Apart from this, I'll also leave a couple of links in the description box, so that you understand the Okay, if you want a more I'll leave a couple of links For now, what I'm gonna a practical demonstration to show you what exactly download does so, basically, what we're is we're going to predict stock prices. Like I said, stock price prediction is one of the very good applications of deep neural networks. You can easily predict the stock price of a particular stock for the next minute or the next day by using So that's exactly what now, before I discuss the code, let me tell you a few The data set contains of data ranging from April to August 2017 on 500 stocks, as well as the total S&amp;P 500 Index price. So the index and stocks are arranged in a wide format. So, this is my data set, data_stocks. It's in the CSV format. So what I'm gonna do is I'm going to use the read CSV function in This is just the part of This data set was actually meaning that we don't and index prices. So the file does not Now what we're gonna do first is we'll drop the data valuable we have a variable known as date, which is not really necessary in predicting our outcome over here. So that's exactly what I'm doing here. I'm just dropping the date variable. So here, I'm checking the This is pretty understandable, using the shape function to do that. Now, always you make the This makes computation much easier. The next process is the data splicing. I've already discussed data Here we're just preparing the training and the testing data. So the training data will contain 80% of the total data set. Okay, and also we are not We're just slicing the That's why we have a test start start and the test end variable. In sequence, I'll be selecting the data. There's no need of These are stock prices it does not make sense Now in the next step, we're going to do is we're going to scale the data now, scaling data and data normalization is one of the most important steps. You cannot miss this step I already mentioned earlier what normalization and scaling is. Now most neural networks benefit from scaling inputs. This is because most of the networks neuron such Tan, hedge, and sigmoid are and these are defined in the or zero and one. So that's why scaling in deep neural networks for scaling, again, we'll So we're just importing And also one point to note is that you have to be very cautious about what part of data you're scaling and when you're doing it. A very common mistake is before training and test So before data splicing itself, you shouldn't be scaling your data. Now this is a mistake because scaling invokes the For example, minimum or gets affected. So when performing time series you do not have information at the time of forecasting. That's why calculation has to be conducted on training data, and only then it has to be Otherwise, you're basically at the time of forecasting, which obviously going to lead to biasness so that's why you need to make sure you do scaling very accurately. So, basically, what we're in the training data are stored in a variable known as n stocks. After this, we'll import So guys, TensorFlow is piece of software and it deep learning and neural It is based on a C++ low-level backend, but it's usually So TensorFlow actually operates as a graphical representation And this is important are actually graphs of data So that's why TensorFlow is just perfect for neural networks and deep learning. So the next thing after is something known as placeholders. Placeholders are used to We need two placeholders So basically, X will which is the stock at time T equal to T. And y will contain the network's output, which is the stock price at Now the shape of the X placeholder means that the inputs are And the outputs are a So guys, basically, the that at this point we do not yet know the number of observations that'll flow through the neural network. We just keep it as a We'll later define the variable batch size that controls the number of observations in each training batch. Now, apart form this, we also have something know as initializers. Now, before I tell you what you need to understand that there's something known as variables that are used as flexible containers that are allowed to change Weights and bias are in order to adapt during training. I already discuss weights Now weights and bias is something that you need to initialize That's how we discussed it neural networks to you. So here, basically, we make variant scaling initializer and for bias initializer, we make use of zeros initializers. These are some predefined We'll not get into the Now let's look at our model So the next thing we have to discuss is the model architecture parameters. Now the model that we build, it consists of four hidden layers. For the first layer, we've which is likely more than The subsequent hidden layers are always half the size of the previous layer, which means that in the we'll have 512 neurons. Hidden layer three will have 256. And similarly, hidden layer number four will have 128 neurons. Now why do we keep reducing as we go through each hidden layer. We do this because the number of neurons for each subsequent layer that the network identifies Of course there are other that you can apply for but I'm trying to keep because I'm introducing So I can't build a model architecture that's very complex and hard to explain. And of course, we have output over here which will be assigned a single neuron. Now it is very important to understand that variable dimensions hidden, and output layers. So, as a rule of thumb in the second dimension of the previous layer is the first dimension So the second dimension is going to be my first dimension Now the reason behind It's because the output is passed on as an input That's why the second is the same as the first dimension of the next layer or the current layer. I hope this is understandable. Now coming to the bias the bias dimension is always equal to the second dimension meaning that you're just going to pass the number of neurons in as your dimension in your bias. So here, the number of neurons, 1,024, you're passing the same number Similarly, even for if you see a second dimension here is n_neurons_2. I'm passing the same Similarly, for hidden layer three and hidden layer number four. Alright, I hope this is understandable now we come to the output layer. The output layer will obviously have the output from hidden layer number four. This is our output from hidden layer four that's passed as the first and it'll finally have your n target, which is set to one over here. This is our output. Your bias will basically have which is n target. You're passing that same Now after you define the required weight and the bias variables, the architecture of the What you do is placeholders and variables need to be combined into a system of sequential matrix multiplication. So that's exactly what's Apart from this, all the hidden layers need to be transformed by So, activation functions are important components of the network because they introduce This means that high dimensional data can be dealt with with the help Obviously, we have very when it comes to neural networks. We don't have a single dimension or we don't have two or three inputs. We have thousands and thousands of inputs. So, in order for a that much of high dimensional data, we need something known That's why we make use Now, there are dozens and one of the most common one is the rectified linear unit, rectified linear unit. RELU is nothing but rectified linear unit, which is what we're gonna So, after, you applied the to your hidden layer, you your output is transposed. This is followed by a very cost function. So the cost function of a network is used to generate a measure of deviation between the network's prediction and the actual observed training targets. So this is basically your actual output minus your model output. It basically calculates the and your predicted output. So, for regression problems, is commonly used. I have discussed MSC, mean So, basically, we are just measuring the deviation over here. MSC is nothing bot your deviation from your actual output. That's exactly what we're doing here. So after you've computed your error, the next step is obviously to update your weight and your bias. So, we have something They basically take care of that are needed to adapt and bias variables during That's exactly what's happening over here. Now the main function of it invoke something known as a gradient. Now if you all remember, we it basically indicates the direction in which the weights and the bias has to be changed during the training in order to minimize the or the network's error. So you need to figure out the weight and the bias in or is it the other way around? You need to understand the relationship between your error and That's exactly what the optimizer does. It invokes the gradient. We will give you the and the bias have to be changed. So now that you know in our model, we'll be using something known as the AdamOptimizer. This is one of the in deep learning. Adam basically stands for and it can be considered very two popular optimizers Now let's not get into the The main agenda here is for you to understand the We don't have to go into the functions. I know these are predefined functions which TensorFlow takes care of. Next we have something Now, initializers are used to initialize the network's variables before training. We already discussed this before. I'll define the initializer here again. I've already done it Initializers are already defined. So I just removed that line of code. Next step would be fitting So after we've defined the variables which are the initializers, the cost functions, and the optimizers of the network, the model has to be trained. Now, this is usually done by using the mini batch training method, because we have very huge data set. So it's always best to use the Now what happens during is random data samples of any batch size are drawn from the training data, and they are fed into the network. So the training data set gets divided into N divided by your batch size batches that are sequentially So, one after the other, each of these batches will At this point, the placeholder they come into play. They store the input and the target data and present them to the That's the main functionality What they do is they store and they provide this to the network as inputs and targets. That's exactly what your placeholders do. So let's say that a Now this data batch until it reaches the output layer. There the TensorFlow compares against the actual observed targets, which is stored in Y. If you all remember, we stored our actual After this, TensorFlow will conduct something known as optimization step, and it'll update the network's parameters like the weight of the So after having update the next batch is sampled and So this procedure will continue until all the batches have And one full sweep over all batches is known as an epoch. So I've defined this So we're gonna go through 10 epochs, meaning that all the batches are going to go through training, meaning you're going to and it'll flow through the network until it reaches the output layer. There what happens is TensorFlow will compare your predictions. That is basically what against the actual observed targets which is stored in Y. After this, TensorFlow wherein it'll update the network paramters like your weight and your bias. After you update the weight and the bias, the next batch will get sampled and the process will keep repeating. This happens until all the batches are implemented in the network. So what I just told you was one epoch. We're going to repeat this 10 times. So a batch size is 256, meaning that we have 256 batches. So here we're going to assign x and y, what I just spoke to you about. The mini batch training starts over here so, basically, your first batch will start flowing through the network until it reaches the output layer. After this, TensorFlow will This is where predictions happen. It'll compare your model's prediction to the actual observed targets which is stored in y. Then TensorFlow will and it'll update the network paramters like your weight and your bias. So after you update the the next batch will get and this process will keep repeating. This process will repeat 10 times because we've defined 10 epochs. Now, also during the training, we evaluate the network's which is basically the data but this data is set aside and this is visualized. So in our problem statement, what a network is going to do is it's going to predict the stock price continuously over a time We're feeding it data about It's going to give us an Now let me run this code and let's see how close to the actual values. We're going to visualize and we've also exported this in order to combine it I'll show you what the video looks like. So now let's look at our visualization. We'll look at our output. So the orange basically So the model quickly learns the shape and the location of the and showing us an accurate prediction. It's pretty close to Now as I'm explaining this to you, each batch is running here. We are at epoch two. We have 10 epochs to go over here. So you can see that the to the basic shape of the time series, and it's learning finer You see it keeps learning patterns and the production is after every epoch. So let just wait til we reach epoch 10 and we complete the entire process. So guys, I think the like the pattern and the by our neural network. It is actually mimicking this network. The only deviation is in the values. Apart from that, it's learning the shape of the time series data The shape is exactly the same. It looks very similar to me. Now, also remember that of improving your result. You can change the design of your layers or you can change the number of neurons. You can choose different and activation functions. You can introduce something which basically help you and there's also something Early stopping helps you understand where you must stop your batch training. That's also another method for improving your model. Now there are also different that you can use for this problem. Here we use the feedforward network, which basically means that the batches will flow from left to right. Okay, so our 10 epochs are over. Now the final thing that's MSC or mean squared error. So guys, don't worry about this warning. It's just a warning. So our mean square error which is pretty low because And this means that our So guys, like I mentioned, if you want to improve you can use different schemes, you can use different or you can try out different You can use something and early stopping in order even more better. So guys, that was the end I hope all of you understood For those of you who are just learning deep learning for the first time, it might be a little confusing. So if you have any doubts let me know in the comment section. I'll also leave a couple of so that you can understand deep learning in a little more depth. Now let's look at our which is natural language processing. Now before we understand and what natural language processing is, we have to understand and natural language processing. So guys, the number one reason why we need text mining and natural is because of the amount of data that we're generating during this time. Like I mentioned earlier, there are around 2.5 that is created every day, and this number is only going to grow. With the evolution of communication through social media, we generate tons and tons of data. The numbers are on your screen. These numbers are On Instagram, every minute, 1.7 Okay, 1.7 or more than 1.7 Similarly, we have tweets. We have around 347,000 tweets This is actually a lot and lot of data. So, every time we're using a phone, we're generating way too much data. Just watching a video on YouTube is generating a lot of data. When sending text messages from WhatsApp, that is also generating Now the only problem is The problem is that out of all the data that we're generating, is structured and well-formatted. The remaining of the data is unstructured, and the major source of text messages from comments on Instagram, bulk emails that we send out ever single day. All of this accounts for that we have today. Now the question here is what can be done with so much data. Now the data that we generate can be used to grow businesses. By analyzing and mining the data, we can add more value to a business. This exactly what text So text mining or text analytics is the analysis of data available to us in a day-to-day spoken It is amazing so much can actually be used in text mining. We have data from word Word documents, PowerPoints, chat messages, emails. All of this is used to now the data that we get from sources like social media, IoT, they are mainly unstructured, and unstructured data cannot be used to draw useful insights That's exactly why we need to text mining. Text mining or text analytics is the process of deriving from natural language text. So, all the data that we emails, documents, files, are written in natural language text. And we are going to use text mining and natural language processing to draw useful insights or Now let's look at a few examples to show you how natural and text mining is used. So now before I move any further, I want to compare text mining and NLP. A lot of you might be confused about what exactly text mining is and how is it related to A lot of people have also asked me why is NLP and text mining considered as one and the same and are they the same thing. So, basically, text mining is a vast field that makes use of natural to derive high quality So, basically, text mining is a process, and natural language used to carry out text mining. So, in a way, you can say that text mining is a vast field which uses and NLP in order perform text So, NLP is a part of text mining. Now let's understand what exactly natural language processing is. Now, natural language processing is a component of text mining which basically helps a Obviously, machines don't they interpret data in the So this is where natural NLP is what computers and smart phones use to understand our language, both spoken and written language. Now because use language to NLP became an integral part of our life. NLP uses concepts of computer science and artificial intelligence to study the data and derive Now before we move any further, let's look at a few applications Now we all spend a lot Have you ever notice that if you start typing a word on Google, you immediately get These feature is also It'll basically suggest the And we also have something Here is an example of the misspelling Netflix and shows results for keywords So, the spam detection is also based on the concepts of text mining and natural language processing. Next we have predictive Features like auto correct, are all applications Now we look at a couple of natural language processing. We have something known Sentimental analysis is extremely useful in social media monitoring, because it allows us to gain an overview of the wider public opinion So, basically, sentimental analysis is used to understand the public's opinion or customer's opinion on a certain product or on a certain topic. Sentimental analysis is of a lot of social media platforms like Twitter, Facebook. They use sentimental Then we have something known as chatbot. Chatbots are basically the solutions for all the consumer frustration, regarding customer call assistance. So we have companies like Pizza Hut, Uber who have started using chatbots to provide good customer service, apart form that speech recognition. NLP has widely been used We're all aware of Alexa, and Cortana. These are all applications of Machine translation is another An example of this is that uses NLP to process and translate one language to the other. Other application include spell checkers, keywords search, information extraction, and NLP can be used to from various website, from word documents, from files, and et cetera. It can also be used in This basically means a based on your history. So now that you have a natural language processing is used and what exactly it is, let's take a look at So, firstly, we're gonna Now tokenization is the mos Tokenization basically into smaller chunks or tokens so that they can be easily analyzed. Now how tokenization works is it works by breaking a So you're breaking a You'll understand the with respect to the whole sentence, after which will produce a description on an input sentence. So, for example, let's tokens are simple. If we apply tokenization on this sentence, what we get is this. We're just breaking a sentence into words. Then we're understanding the importance of each of these words. We'll perform NLP process to understand how important each word is in this entire sentence. For me, I think tokens and are is basically another stop word. We'll be discussing about stop But for now, you eed to is a very simple process that involves breaking sentences into words. Next, we have something known as stemming. Stemming is basically normalizing words into its base form or into its root form. Take a look at this example. We have words like detection, detecting, detected, and detections. Now we all know that the root word for all these words is detect. Basically, all these words mean detect. So the stemming algorithm or the beginning of the word and taking into account and suffixes that can So guys, stemming can be but not always. That is why a lot of people affirm that stemming has a lot of limitations. So, in order to overcome we have something known as lemmatization. Now what lemmatization does is it takes into consideration of the words. To do so, it is necessary to which the algorithm can look back to its lemma. So, basically lemmatization is also quite similar to stemming. It maps different words Sometimes what happens in stemming is that most of the words gets cut off. Let's say we wanted to Sometimes it becomes or something like that. So because of this, the grammar or the importance of the word goes away. You don't know what Due to the indiscriminate sometimes the grammar the is not there anymore. So that's why lemmatization The output of lemmatization a proper word. Okay, it's not going to be or anything like that. You're going to understand and then only you're going An example of a lemmatizer is you're going to convert All the three words anyway So you're going to convert it into go. We are not removing the first What we're doing is we're understanding the grammar behind the word. We're understanding the English or the morphological analysis of the word, and only then we're going That's what lemmatization is all about. Now stop words are basically a set of commonly used words in any Now the reason why stop words are critical to many applications is that if we remove the words in a given language, we can finally focus For example, in the let's say you open up Google and you try how to make What the search engine is going to do is it's going to find a lot more pages that contain the terms how to make, rather than pages which contain the recipe for your strawberry milkshake. That's why you have to The search engine can actually focus on the strawberry milkshake recipe, instead of looking for pages So that's why you need to Stop words are how to, begin, all of these are stop words. They are not necessarily important to understand the So you get rid of these so that you can focus Another term you need to understand is document term matrix. A document term matrix with documents designated by So if your document one has or has these word, this is fun, then you're going to get In document two, if you see but we do not have fun. So that's what a document term matrix is. It is basically to understand contains each of these words. It is a frequency matrix. That is what a document term matrix is. Now let's move on and look at a natural language processing demo. So what we're gonna do sentimental analysis. Now like I said, sentimental analysis is one of the most popular applications of natural language processing. It refers to the processing of determining whether a given piece of text is positive or negative. So, in some variations, we consider a sentence to also be neutral. That's a third option. And this technique is how people feel about a particular topic or what are people's opinion So this is mainly used to in various forms, such as in marketing in e-commerce websites, and so on. So now we'll be performing using Python. So we are going to perform by using the NaiveBayesClassifier. That's why we are importing So guys, Python provides a library known as natural language toolkit. This library contains all to perform natural language processing. Also in this library, we have a predefined data What we're gonna do is from our NLTK, which is We're basically going to run our analysis on this movie review data set. And that's exactly what Now what we're doing is in order to extract features. So this is our function. It's just going to extract all our words. Now that we've extracted the data, we need to train it, so we'll do that by using that we just downloaded. We're going to understand the positive words and the negative words. So what we're doing here is and our negative reviews. We're loading both of them. After that, we'll separate each of these into positive features This is pretty understandable. Next, we'll split the data into our training and testing set. Now this is something for all our demos. This is also known as data splicing. We've also set a threshold factor of 0.8 which basically means will belong to your training, and 20% will be for your testing. You're going to do this and your negative words. After that, you're just and you're just printing the number of training You're just printing the length and you're printing the length of your testing features. We can see the output, So if you see that we're getting the number of training and your number of testing there's an 80 to 20% ration over here. After this, we'll be using and we'll define the object for the NaiveBayesClassifier and we'll train this using We'll also look at the The accuracy of our which is a really good number. Now this classifier object the most informative words that are obtained during analysis. These words are basically which word is classified as positive and which is classified as negative. What we're doing here is We're going to see which or which movie review is negative. Now this classifier will basically have all the informative words which is a positive review Then we're just printing these and we have outstanding, insulting, vulnerable, ludicrous, uninvolving, avoids, fascination, and so on. These are the most Now what we're gonna do is I've randomly given some reviews. If you want, let's add another review. We'll say I loved the movie. So I've added another review over here. Here we're just printing the review, and we're checking if or a negative review. Now let's look at our predictions. We'll save this and... I forgot to put a comma over here. Save it and let's run the file again. So these were our randomly The predicted sentiment is positive. Our probability score was 0.61. It's pretty accurate here. This is a dull movie and I is a negative sentiment. The cinematography is pretty great, that's a positive review. The movie is pathetic is The direction was terrible, and the story was all over the place. This is also considered Similarly, I love the movie and I've got a positive review on that. So our classifier actually It's giving us good accuracy and it's classifying the So, guys, this was all Here we basically saw if a movie review was positive or negative. So guys, that was all for our NLP demo. I hope all of you understood this. It was a simple sentimental analysis that we saw through Python. So again, if you have doubts, please leave them in the comment section, and I'll help you with all of the queries. So guys, that was our last module, which was on natural language processing. Now before I end today's session, I would like to discuss with you the machine learning engineers program that we have Edureka. So we all are aware of the demand of the machine So, at Edureka, we have a master's program that involves 200-plus hours So the machine learning has around nine modules and 200-plus hours of interactive learning. So let me tell you the curriculum that this course provides. So your first module will basically cover Python programming. It'll have all the basics and your GUI programming, your functions, and your object-oriented concepts. The second module will cover So you'll supervise algorithms and unsupervised algorithms along with statistics and time series in Python will be covered Your third module will This is quite important when Here you'll be taught graph theory, inference, and and module number four will cover reinforcement learning in depth. Here you'll understanding temporal difference, Bellman equations, all the concepts of All the detail in advance concepts of reinforcement learning. So, module number five You'll understand tokenization, syntax, tree parsing, and so on. And module number six will artificial intelligence and This module is a very advanced version of all your machine learning and reinforcement learning Deep learning will be in depth over here. You'll be using TensorFlow throughout. They'll cover all the concepts it'll cover the various like convolutional neural networks, recurrent neural networks, long, short-term memory, neural networks, and auto encoders and so on. The seventh module is all about PySpark. It'll show you how Spark SQL works and all the features and And the last module will finally cover about Python Spark using PySpark. Appropriate from this seven modules, you'll also get two Let's actually take a look at the course. So this is your machine learning engineer master's program. You'll have nine courses, 200-plus hours of interactive learning. This is the whole course curriculum, which we just discussed. Here there are seven modules. Apart from these seven modules, you'll be given two which I'll discuss shortly. You can also get to know for a machine learning engineer, which is over $134,000. And there are also a lot of job openings in the field of machine So the job titles that you might get are machine learning data scientist, data and analytics manger, NLP engineer, and data engineer. So this is basically the curriculum. Your first will by Python machine learning graphical modeling, natural language processing, AI and deep learning with TensorFlow. Python Spark certification If you want to learn more you can just go and view the curriculum. They'll explain each and every concept that they'll be showing in this module. All of this is going to be covered here. This is just the first module. Now at the end of this project, you will be given a verified with your name on it, and these are the free elective courses that you're going to get. One is your Python scripting And the other is your Python Statistics for Data Science Course. Both of these courses The second course on statistics will explain all the concepts of statistics probability, inferential statistics, time series, testing data, data clustering, regression So each of the module is you'll have a practical demo or a practical implementation after each and every model. So all the concept that I will be explained through practical demos. This way you'll get a the entire machine So, if any of you are interested in enrolling for this program or if you want to learn more about the machine learning please leave your email and we'll get back to you with all the details of the course. So guys, with this, we come to the end of this AI full course session. I hope all of you have and the idea behind AI machine and natural language processing. So if you still have doubts regarding any of these topics, mention them in the comment section, and I'll try to answer all your queries. So guys, thank you so much for Have a great day. I hope you have enjoyed Please be kind enough to like it, and you can comment any of and we will reply them at the earliest. Do look out for more and subscribe to Edureka Happy learning.