Michael Thiessen: Welcome to Alexander Lichter: It's your don't know it yet, or maybe you 30-somethingsth episode, and, Thiessen. Michael, how are you Michael Thiessen: I'm doing Alex, who's got an interesting subscriber special around this seen it on his on his channel. the way. Alexander Lichter: Thank you so year and, I don't know, a month to to grow that fast. I'm very the number than, like, people podcast here, of course, the I post once a year or something. that. And, I'm I'm super curious if if but also for the channel has should we talk about? I've seen, More like enterprise and Vue about linting? Or is that just to us on on Blue Sky, on Right? I mean, nowadays, every it seems, so get an account k. Looking looking forward to come out in in the future just much time to prepare it yet. But we recorded a few things, so Michael Thiessen: Yeah. You've flying around and all of that. Alexander Lichter: Yes. But I'm home for a little bit. I'm livestream here and there. It's like to do more just because I'm workshops and conferences. It's especially, like, having a really possible with, like, It's a bit easier. You can So yeah. But, I mean, that's Sometimes you should do things your data. Right? Yeah. Which is the topic DejaVue, data fetching in in Michael Thiessen: Yeah. There's we're gonna cover cover how that more focused with Vue, and then, server side bit with with Nuxt. side with just Vue, but, you in that way because it's kind of data fetching, that's like one do in applications is fetch performance because the network our for whatever we're doing. And it can get really big app that has, you know, one fetching data in one way and fetching other kind of data and and, like, organizing at all. management piece that goes along the network calls and that data? Should we cache that It's a whole lot of a whole lot think about. Alexander Lichter: Yeah. Also, fetch the same data twice? it? Right? The the caching part there as state management, waterfalls, parallel, or does data a have to that's that's all complex. And performance episode, like and as framework is rarely the API calls, which take way longer don't know, list of 1,000 shouldn't do anyway in most But, yeah, that's the case. So I mean, we all did data fetching there is almost no application data, be it even from things state from somewhere, but third party or own APIs. Michael Thiessen: Yeah. Exactly. we've got basically, like, 2 And so the first one is that caching of of your your HTTP different headers and and things And so, you know, you've seen resources that get fetched. If automatically handles that, and we we can make sure that we're multiple times if it hasn't basic layer, and we don't really don't need to, and that's really use this sometimes, but I'm implement this more. Is that session and local storage Mhmm. Where you have, like, a bit more things to to the browser itself. like, I don't know, like drawing you you know, they often do don't even there are some apps a database, and it's all locally really interesting pattern. I that tangent of, like, you know, a a database somewhere in the But, yeah, that's that that's we've got. Alexander Lichter: Absolutely. headers, just as long as server then we don't have to do consuming the API. But, of if it's a 3rd party API or if we some random content and we just refetch it, then we, of course, if you refresh the page, it's storage is is the way to go But maybe we can even go and data fetching, in a very simple entail? Like, how do we do that Vue as a framework doesn't now it's maybe weird so luckily isn't that that a good thing or Well, you have the freedom to you wanna use. Right? We have in the browser. That's nowadays, Probably not, vanilla. I mean, you can do that, but the response okay? Still have, maybe convert it to JSON, so on like, ofetch or also in Nuxt.js, any other fetch API wrapper, And that's basically just the overhead. It's usually, like, that, will will simply work by methods that make your code your code also a bit more to do these always low level automatically throw in an error You might wonder, oh, why it's there there are good reasons for the helpers allow it to just do course, in the past, people have but I wouldn't recommend it for, or the good old XML HTTP Back in times where we didn't Jake very abstraction around it. like that, or even a server 10 stack, for example, you can as in other frameworks like there because that's the way to think that's quite important. Okay. And coming from fetching about async state and Vue and is an experimental feature, hopefully will be stabilized more about, about that. Michael Thiessen: Yeah. And in of features, which I haven't while. I did write, like, this years ago. And it's funny things where if I'm googling for work? Then I'm probably end up article and and be like, wow. At one point, I knew this, but because I've been, you know, kinda handles that under the is that components, you don't always want them to render until they need. And so if you put in setup and you return that, from this setup function, then your Vue app won't render that ready to be rendered. Because get this, you know, data is you're waiting for that data to you have to check with flags or oh, is this data there? Oh, it's not there. Okay. Then me show the loading spinner. But handles that all for you. You And while that's being, you and it's the promise is still onto your loading state, whether or something else like that. Alexander Lichter: Yeah. And it Right? You can just provide us, component there if you want to pretty nice. But, like, I think you said, if you have some, you need to do before rendering But I also think in a lot of necessarily needed and can be example, if you just have, like, okay, I wanna render some data I can be like way after component okay, how's the best way to way is just use, VueUse's good old VueUse recommendation. Or Yeah. Build build your own ref. That value is initially whenever the data is fetched, newly value. Ideally that ref because if you only use it for use case. And we also talked about it in whenever something happens to You can watch it. You can render ref. And then, for example, pass that's only rendered when the So in a lot of cases, you might plus data loaders, which are a router, unplug in. It's also stable by now, made by Eduardo, all because it has some that suspense is a great way of state, but also just a regular easier. Michael Thiessen: Yeah. And we and how that works with Eduardo episode 31, but that's gonna be take a look at that. It's pretty think it's gonna solve a lot of with with data fetching. One very willing to be challenged it's more of those, like, things where you probably will something like that, and it's dealing with day to day, like, working on. It should be shouldn't have to worry about If you set it up in your Vue to worry about it as you're just sort of like just like with like that. It's just sort of full page error or something up, and then there's the thing ago that that handles it. And so maybe not something that you about constantly. Alexander Lichter: Yeah. At as I said, you have, like, your component that the Vue router is if Nuxt is just out of the box set it up once and and you're this pen for, like, more fan have, let's say, you have, 5 and you don't want a loading separately, but you want a there because they all have together, let's say, or just, and you don't want to show the one that's fetching the data, both and say, okay, whenever finished and show them both loading state. So sometimes this can also be the the cluttering on the pop something up and there, but resolving together and is a bit terms of, appearance. While, of loading times for the user, but performance can can even be Michael Thiessen: Yeah. Yeah. organized instead of having a everywhere. Alexander Lichter: Yes. Exactly. And, I mean, then from that super important. So, like, with solve that, we all talked about slowly in terms of performance. And there has been a lot in not even fetching data but which, in a way, is also Right? And them being not on the web worker. So, for example, that you can use to run all blocking the the main threat, UI that's usable and also better Roe, from the Nuxt team worked allows you to use web workers usually, like, heavy operations thread clean and simple, let's manipulation or whatnot. Mhmm. Michael Thiessen: Yeah. Service something I haven't really dug a such a useful feature. And, mock service worker for for thing that take advantage of nice way. If I was doing an gotta put that in the don't to to do all of that kind of lifting. I'm sure there's a lot that, that are out there. Alexander Lichter: Yeah. the the heavy operations. And a Some might note it also like you just have, like, your, image compress and minify JPEG, SVGs, And you can do that easily. always use the app heavy work done in a worker to smooth and interactive. So, if you have that kind of case. of course, about performance of Partytown is an option or also do very different things in with the web workers, Nuxt let's load the script at a later a later time point. And we just have a proxy in don't know, collect some data then we just replay everything the script is loaded and do lots basically want to do. Michael Thiessen: Yeah. And as fascinating to see all the being built with all the people are doing, like photo games and things like that, and interesting to see the the web closer to to native, and it's you know, what what can be done be done on native is is getting a whole, other podcast, though. Alexander Lichter: Yeah. Also, like, it's amazing to see that browser and stuff just, like, let's let's see what it brings a nice, extra episode. If you're comment and and let us know. Right? So we'll we'll get experience and see see how that Michael Thiessen: Yeah. So the so Nuxt has a few extra things data fetching because we are rendering that then gets So it's a bit more complicated, deal with the data fetching side important one here is to fetch methods, composables that that So we've got use async data, got the lazy versions of those. that, Alex mentioned before, gets auto imported for you. And the hood here for for the for the the hydration life cycle for fetch the data, and then it'll client, and we don't have to once once that gets to your because, obviously, that's extra that. And so, yeah, these things sort you. They then with server side issue of cross state request the exact wording. I think I got Alexander Lichter: Yeah. That's Michael Thiessen: Yeah. The one basically, if you've got data server, while if 10 people come and those requests are being don't want someone else's data vice versa. And so we have to do we isolate every single Alexander Lichter: Exactly. Michael Thiessen: Doesn't happen wanna have that to happen. And composables will handle that for hydration thing, and so you can have to know that this is these already and don't realize the hood. Alexander Lichter: Yeah. Mostly thing. Right? That's why I also there, it's it's obviously Like, useAsyncData and useFetch. from the cross state request from hydration errors because have your initial request, like, know, coming from Google or, happening. On the server side, reused. We also have a whole episode on as well. Dollar fetch is very There is a difference between use async data, and dollar something you can use, I don't back end, like in Nitro, even in by just using OFetch or in your don't need, a Vue or Nuxt While the composables are, of in there, which also means the simple rules for that. Right? setup function or in another fetch, of course, you can use a handler for an atclick event, one of the most common mistakes I made a video about this, like, fetch wrong, then, like, in I hope you don't. I think it's so far on the channel. Because a aware of the the difference accidentally like in, a click leaks. It could use, like with composables, it could lead request on every button push. So you're not aware of that. So definitely, worth checking it in general in your Vue application. Michael Thiessen: Yeah. The and the composables are are for when that component initially just supposed to react to that composable in the click that data fetch every single then that's that causes issues. Alexander Lichter: Exactly. And the other thing. Right? Like, Like, usually, if you call them is is being unmounted. It's Goodbye. But if it's in a in a When will this ever end? It leak until, like, precise the maybe accidentally doing weird submitting a a fetch request all your password per letter. Yeah. You you don't want all of solve it there. But, yeah, they would say it's very similar to it's with form submissions and said, when you have, like, the server side as well, so also composables. You can even use just saying, like, server false, But usually they're there to they're reactive. So I set it up from that URL based on these change, please refetch data with don't know. I click on a filter parameter in the URL, and then these change. So that all works very, very use async data. Michael Thiessen: One point out about the dollar sign trick where it will know it the server. And so instead of if your app, instead of doing the do a post to this endpoint, handler, well, it it's all part just call that event handler bypass that whole, HTTP layer. in the browser on the client, it course, makes that full request server is not running locally in this, like, neat little pretty cool. Alexander Lichter: Yeah. That's engine where it just, as you part of me anyway. I'll just run function Michael Thiessen: Yeah. Alexander Lichter: With the and, and then we're good. good in terms of performance, so without doing anything, which is Michael Thiessen: Yeah. So then I believe that you have a whole maybe you, you wanna take this Alexander Lichter: Sure. Yeah. I yeah, there are there are, like, like, caching on the I'll start on the server to have like these the client. Well, all the things the client side, they apply as Like, make sure your server is to just say like, okay, we have That's all valid. But there is random data that you can do and call again with use fetch and do is use a low level function And in there, you can basically already and you can read it out, return, null or undefined right null, and undefined is is the data will be refreshed okay. Fine. There is no data. Now that we talk about it, it's where, oh, there is my API undefined. And then use async because, well, oh, the data is don't do that. But, yeah, that's be improved because right now can even, like, set a TTL to that in memory cache for, like, whatnot and then refetch it. But we plan on having some kind you can just write, I don't cache 1000 or something like code is not duplicate. It's not reusing that composable utility, I use that type of caching. Lots that's, that's work in progress. And let's see when it will But it's definitely neat if you client side. So it works for the server benefits, of course, actual server. Otherwise, yeah, in all cases. Michael Thiessen: Yeah. And you pass as an option to the the Alexander Lichter: Yeah. To use Both both support that. Correct. use async data is more or less to have a little bit about the data and use fetch, you can So you can use axios there, you whatnot. And usefetch is more or use async data with dollar fetch together anyway, then usefetch top of that and, like, watching a big video about what's, the maybe just good to know if you one or the other? And the answer dollarfetch anyway, then just If you wanna do a few more async data is the way. Michael Thiessen: Yeah. Use function. It just needs a Alexander Lichter: Exactly. You promise that resolve if you want course, not not that helpful And on the server side, we have can do, thanks to Nitro, so So we have let let's start with to the whole application. So okay, this path should be just path should be cached until the be incrementally generated be cached, and then the cash user noticing. So SWR, style by and so on. And you can do this for your API endpoints if you them. There is one thing why I with, the Nuxt pages themselves introduce, let's say, a that initial request because page. Right? So if you refresh the hit. But if you then navigate to that API response has to come So if you don't cache your API server on its side, you might and then when you refresh to the So that's a bit tricky. So you cache nicely when the API responses too, which I would And then if we come to your API so basically, whatever you write have a few more options. You can that. But then for caching, you can you can use define cache event things you can pass in the route what's the cache key name? How should I cache that? Like, cache? You can also do it in in okay. This page should be cached KVKB or Vercel whatsoever, I don't know. Really up to you. Michael Thiessen: And that gives rules does. Right? Alexander Lichter: It it does for example, for the naming, config, and also Nitro config plain Nitro, The config always can't pass in a function or have, like, a get key function should bypass cache, you can't There the the problem with that just said, like, your API that you cache. We still have an fine grained control to say, Before you render all that, sure this is cached return a sure that's actually possible. in progress once again. But, cached event handler, you can something called defined cached wanna cache a part of my event utility, which is very common oh, this user is authenticated. whole request, but maybe he's GitHub repositories that he Then you can just say, okay, I as key. I use the user ID. So I and the path, or the user just resource, and you can just cache all users. You can use define way as the event handler, but smaller part of that. And once again, you have full really, really useful, grained caching when you still actually coming in. So one user activity, then you can say, everything that's happening to still happen. And in the end, function called even after the even after response is sent, part, and then you're good. Michael Thiessen: So the the unstorage, I'm guessing? Alexander Lichter: Correct. So Michael Thiessen: Yeah. So configurability of store it in store it Correct. Wherever whatever kind of, storage thing Alexander Lichter: Yes. And it works very well, and, of also to store arbitrary data. I application I built for one of some some plain information, in which is, super useful, end. And even, like, whole So it's, it's really versatile. Michael Thiessen: Yeah. And on, with Harlan, he where we talked in a week with Nuxt. He used basically store all the application. So instead of, you doing all that kind of stuff, code to just say set, and then you know, a get call as well. Yes. Really simple. It's really Alexander Lichter: Exactly. Also number 2, I think it was, with for SSR. And 3 was, I think, the way back after the episode because it's super interesting. experience there. So, yeah, worth worth checking the end, there there are quite might wonder, how do I need, because, well, there is a lot. don't. Like, it depends really I would always suggest if you up your API endpoints and cache data allows to do just because, time for that? Like, why don't know the answer to the to the tiers out there for kv stores or only doesn't work if you have, because then memory is just one like, yeah, just do that. And there's a lot of caching Also, once again, where you to fetch, and maybe the API is can't see the headers right. So cache it there. But as usual, I say, the hot parts of your very slow parts and optimize like, I don't know, a 30 25 one, it doesn't really matter don't know, 200. It's a bigger difference. So slows your application down, that and cache that. Maybe even end, if you have, like, an API take the data, transform it, little back end for an API. And, well. Michael Thiessen: I have a data. So we've got this the data that you state and fetch, use async data that caching that we we talked about data? Like, would you use it for Or, like, how does that fit into and and all that? Alexander Lichter: Yeah. We using Nuxt data yet. As I said, data that's already, let's say, You need a key for that. I caching as the first use case. I think more common is something you say, like, okay, I have the like, I change something in the return value just to have the things go through. Right? We're don't know, plus 1 on your vote and then actually process the comes in. So that's one thing perceive the app as fast. And if if it doesn't work, roll Everything broke. Sorry. But I I caching. Maybe for reusing data, to say, like, okay. I use it on a different spot. use, a use fetch or use some doesn't trigger straight away depends a lot on on the use degree for caching, especially a data in some cases, but I I in in that context. Yeah. So Michael Thiessen: Yeah. The use with the immediate false, and execute command, or was that API Alexander Lichter: recently do the same with just Okay. Just different context. Yeah. Michael Thiessen: Okay. Yeah. I Refresh, execute. Well, I guess execute, and then if you're if switch to refresh. Alexander Lichter: I mean, it literally the same function. I about just creating an issue to we just rename it on the spot if context? But Yeah. Like, it's say, like, okay. I just call it once whenever the just call execute because it do something like, oh, when I refresh the data. But yeah. Michael Thiessen: Yeah. Yeah. I yeah, you if it's the first time confusing. Alexander Lichter: But Yeah. Michael Thiessen: Yeah. So, you Alexander Lichter: Anything is the code and you don't know that Maybe it's I think it should somewhere, but who reads who it might be something to sneak But on the other hand, I mean, code. I'll think about it. I other team members what their maybe when an episode is out, issue about that. It is Michael Thiessen: it is named differently because you things that they do different Alexander Lichter: Exactly. I depending on the on the stops you from, in that case, just, like, destructure it and Michael Thiessen: Yeah. Yeah. term that you could use, like like Alexander Lichter: Yeah. That's introducing these changes, I these that's, like, less Because then if you introduce migration. It's just it's a bit it's definitely something maybe how they feel about it if that gonna be something that I will I discuss. But, yeah, in in the end, for less what what caching is there. more, in-depth, as I said use these things, how to build Nuxt scripts as well, which is fetching, but for the 3rd party image, of course, as well, Nuxt packages, so to say, really Michael Thiessen: It's a lot more to talk about when it and caching because Nuxt gives that's, like, the point of these if you gives us a bunch of stuff data fetching, it doesn't do way it should be. But then next these extra things to make our of us are on the the Nuxt train, anytime soon. So Alexander Lichter: That's that's the other the other part is that complexity as well, as in, like, great and some more complexity. turn it off. It's also totally Or, like Michael Thiessen: Yeah. Alexander Lichter: You can even like, hey, my app and dashboard totally true. But performance beneficial because then you can oh, cache stuff, get all the API send out data and cache them. So no choice, other than, hey. I I can transform things on the the data. So, that's always a start, like, okay. I can build have a different API service and And in a way, that's also fine. that API call, and then it again with, like, okay. The user that's not ideal, and so on and merits, but surely not every Michael Thiessen: Yeah. Yeah. I good point that, there there are Alexander Lichter: And so 100%. Michael Thiessen: You introduce stuff to handle that complexity. Alexander Lichter: But I'm I'm Nars, you can just start without technically any feature can you can say, okay. I use my up my own routes. I ignore everything around it. application, what, finally, recently, also linked to that, notes. And I for everyone your phone's description, you definitely something to take a like, oh, yeah. All this is it really worth moving over? And it's difficult. And and what you wanna use, but, still an SPA is not that tricky. changing things, it might be a possible. Michael Thiessen: Yeah. And one is that sometimes it can feel you think, oh, I only wanna use this big heavy framework that's that I don't actually need? But the stuff you need. And so if won't include the router. And if you don't need, you know, not gonna include that in there things and, you know, getting that's one of the the things so you can just, like, add in Nuxt will just, like, happily you don't have to worry as much Alexander Lichter: 100%. I don't fetching and that, if you'd like could just use all of fetch in You don't need to migrate to use because, okay, all fine. You But if you then consider using it's helpful to have that. And ergonomies that are really nice. But if you said, okay, I have a you're good. Right? That's, once again, the beauty These features, I don't need just don't have time to migration stuff. So, yeah, Michael Thiessen: I think that, episode then. Alexander Lichter: Absolutely. like, REST APIs and GraphQL and also a bit of beyond the the Vue could be very interesting for a that's, once again, could be the WASM one we we talked about. Michael Thiessen: I have a lot Vue. So Alexander Lichter: Good or bad Michael Thiessen: Yeah. Bad episode. Or maybe I I should be Alexander Lichter: Like, have a yeah. Michael Thiessen: It'd be, you talk it out. Alexander Lichter: Yeah. Let's, someone on who's using GraphQL really but I know quite a few So, if also, once again, if you us. Let us know. And, of course, check out the many. Link the link on the show listen for all of them again. website, and stay tuned for next in in European time and 1st day else. So, yeah, go for it. Michael Thiessen: Alright. Well,