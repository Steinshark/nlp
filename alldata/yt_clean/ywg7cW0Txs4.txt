[REEL-TO-REEL PLAYER STARTING] [MUSIC PLAYING] DAVID J. MALAN: All right, this is CS50. And this is week 1, wherein but we do it in a different language focused on this graphical But we use Scratch, not only because but because it allows us to explore namely functions, and conditionals, and more. And so, indeed, even if today's syntax, called C, feels a little bit cryptic, and you don't quite see all beyond the syntax itself, realize going to be the same. In fact, as we transition a Hello World program that looked a of course, it's going to now It's going to look a And now even if you what all of the various it turns out that at indeed going to do what you expect. It's just going to say, just like we did in Scratch. So let's start to apply some So what we're about to see, what we're going to start Code that you the human programmer write Doesn't matter if it's Scratch. Doesn't matter if it's C. Doesn't Source code is the what you and I as human Of course, computers don't Computers don't understand Scratch like we're about to see. They only understand this, AUDIENCE: Zeros and ones. DAVID J. MALAN: Yeah. So this is binary, zeros and ones. But really, it's just information And in fact, the technical term that a computer not only understands or colors, or images, or more, but is going to be called machine code So whereas you and I, the it's the computer that ultimately And even though we won't get into of symbols means what, you'll see and ones, there's going to be numbers. There's going to be letters. But there's also going to be are really good at doing things-- in and out of memory. And suffice it to say that the Macs, the have just decided as a society what mean when it comes to operations but instructions. But those patterns are going to focus on in a class like this. We're going to focus on the higher simply assuming that we need So it turns out, then, have to solve getting from actually fits into the But the input in this case is going That's what you and I don't have to write zeros and ones. But we need to somehow because that's what are actually going to understand. Well, it turns out there are special to do exactly this conversion-- and I write to the machine code that And that type of program is So indeed today, we'll introduce And these come in many forms. We'll use a popular one here that to machine code in zeros and ones. Now, you didn't have to In the world of Scratch, it was as because essentially MIT did all of how to convert these graphical puzzle But now starting today, as we begin to proper, now that power moves to you. And it's up to you now to But thankfully, the fact means that you and I in machine code like our be it virtually or with like pieces of paper with holes in them. You and I get to focus But it's not just going to be It's going to be a onward of writing good code as well. And this is the kind of thing that It takes time. It takes practice. Just like writing an might take time, and practice, But in a programming going to aspire to evaluate the generally. Is it correct, first and foremost? Does the code do what After all, if it doesn't, of writing it in the first place? So it goes without saying that you And it's obviously not always. Again, anytime your Mac, or some human somewhere wrote buggy-- that is code with mistakes. But code correctness is going to But then there's a more subjective And we saw a little when I proposed that we could maybe by using loops instead the same blocks again and again. So design is more subjective. It's more of a learned art whereby disagree as to which version of But we'll give you building blocks so that you can have a if your own code is well designed. And why is that valuable? Well, the better designed your code the more maintainable it's if you're working with So good design is a good thing. It helps you communicate your ideas, And then lastly, we'll talk And this is really just the It turns out that computers often don't where in the world of code, it to indent things in a beautiful way. You don't need to paginate The computer generally does The teaching assistant does. You will care the next day to understand what your code does. So we'll focus lastly on style, that you're writing. So where are we going to write code? Where are we going to compile code? So for this class, not only with C, in the term, we're editor that is program called It's super popular nowadays, not and Java, and any number It's a text editor in the sense And that's all code is going to be. Now, strictly speaking, you In fact, in high school you might have done that one or You can't run it on paper, of course, You could use something or Notepad.exe, or Text Edit on the Mac. But none of those programs to format the code in nor are they designed to let So VS Code is going to be a tool and more-- write the code, So that you all don't have to headaches at the beginning of the course on your Macs or PCs, we'll use at code.cs50.io. And that's going to be And the goal, then, is by to migrate you off of that cloud-based so that even if CS50 is the you're 100% equipped to continue not something that's even standard, at least for some time. So what's this program VS Code going PC, or initially in your browser? It's going to look a And there's going to be several And pictured here is keep proposing as the simplest And what are these different Well, there's essentially So first, highlighted up top is you're going to actually write code. So much like in Google you can have tabs open with files. Similarly in VS Code-- or, really, you generally nowadays And this is going to be a tab containing And that's going to be the very Down here, though, is going to might not know. This is what's called a terminal window. And a terminal window provides what's Interface, or CLI. And this is in contrast with a Now, you and I, every day, are using And a GUI is literally graphical-- And you generally use or a mouse or something like But it turns out that saying most programmers, at not a GUI, but a CLI, a where you actually do everything Why? Well, it turns out, there's just more if you can access them with a keyboard. It turns out, most of us can type And so that ends up being an So in time, will you get window to do things like compile as well as run it. So you won't be in the habit initially like we do in our typical real world. You'll do it the programmer's way. But it's not to the exclusion of adding On the left-hand side going to be a somewhat some kind of hierarchical tree, see all of the files in your account. Pictured here, for which I'll create myself in a moment. And then far away on the left and this is where you just get a lot So VS Code itself gives But it's within the CLI, the terminal that we're actually going to And in general in class, I'm going to just not of all that much interest. So with that said, let to a live version of VS Code. And I've indeed hidden I've indeed hidden the File Explorer. So what I have here for visibility for writing code and a really big You'll see in the terminal And this doesn't mean This is just the standard symbol So the fact that there's means, eventually, that's where But first, I'm going to So how might I program using or in this cloud-based environment that go about writing my first file? Well, perhaps the easiest way is this. Literally run the command code you want to create. Notice that I deliberately end Notice that I've deliberately And these are just conventions. You could use a capital H. You kind of could use a capital Follow best practices so that it's else would do. When I hit Enter, I just like the screenshot a moment ago. And it's in this tab where I can now Unfortunately, it's not quite where you drag and drop a couple of So I'm going to do this for memory. But this, too, will become I'm going to include I'm going to type int On a new line, I'm going to insert And then I'm going to parentheses, and then in quotes, hello, a lowercase n, then a close at the very end of the line. So all I've done is recreate, just In a little bit, we'll make But for now, let's just And just like I clicked the green let's actually compile If it were your Mac or PC and had made the software, at we'd be double clicking an icon. But we can't do that yet. This is still source code. So I'm going to click back Notice I have a second dollar means it's ready for a second command. And now the command via which to make from source code to machine code and then the name of the Slight subtlety-- I'm omitting want to make, I just want to call hello. Don't write make hello.c. Just write make hello. And this program make is Technically speaking, it's the compilation of my program for me. But it is going to see that It's going to automatically look now for and convert it from source code in So if I didn't make any typos, And that's a good thing. Almost always, if nothing gets You didn't make any mistakes. You didn't get yelled at. There's no error messages. So this is actually a good thing. How do I now run this program? Well, notice I've got a means I'm ready for a third command. And now I'm going to go And this is admittedly a little But for now just take how you run a program called in your current directory in All right, crossing my And voila. My very first program And now let me go ahead and reveal exists earlier. I'm just going to use the And generally, I keep it closed because files are in my account. But you'll see now in the File Explorer, but graphically a little It's highlighted because But now there's a second That's the name of my program. So if you were on a Mac or PC, you You can't do that in a You have to run it down here. But that's all we've done. We've created a file called made the program from that. Let me pause here and see if a lot of magical phrases. Yeah? Yeah. So if you're currently following and you're getting some kind will be for me to deliberately For now let me just propose that you must have made a typo somewhere. And notice that it's indeed Maybe you typed studio.h? OK, super common mistake, It is not studio.h. It is stdio.h-- so common. But this is exactly representative you're going to run into this probably, honestly, for a few years. But you start to see past these and it just gets easier and going to be so regimented. It will only do what you tell it to do. And if you say because it's it's not going to know what the file is. So actually, thank you for That's super common to happen. Yeah? AUDIENCE: Why do you DAVID J. MALAN: Why do AUDIENCE: Yes. DAVID J. MALAN: So why One is the one I created as and it's pictured right here. But then when I ran make hello, into machine code. So this second file just contains all of those zeros and ones All right, so yeah, question? AUDIENCE: The access to DAVID J. MALAN: If you try you'll see in this quote/unquote, The file is because it is either binary-- AKA zeros and ones-- or uses In this case, it's binary. It's zeros and ones. Now, you could use software It won't be intellectually So VS Code just takes the choice So that would be a common mistake too, But the source code is indeed All right, so I've written this program. It seems to magically work, if you get every single keystroke right. Well, what is it that's going on? And how is this working? Well, first of all, notice that or choosing buttons for menus, And yet, I wasn't highlighting changing the color, certainly. Well, it turns out, what VS Code nowadays do for you automatically So syntax highlighting is just this nowadays that analyzes the And when it notices certain things that represent functions, or a lot of the vocab from last week-- it for you. So main, for instance, which Int, and void, and include are in red. Hello, world is in blue. My parentheses are in green. This will totally vary In fact, if you do want to change for your own environment, VS Code Settings via the gear icon. You can change to a Syntax highlighting isn't some specific It just generally is to each But that's all that's of syntax highlighting at the moment. Well, what more is going on in this code Well, it looks a little something like And then just for discussion's and color it a little more like Scratch. Recall that our very that just said hello, world on the puzzle piece, roughly in orange, and So whereas this is the C version, this was the same program in Scratch. But what's happening So if you think back got some function, like that might take one or more influences what it says on the screen. And then functions, have side effects, like the speech So last week when we passed in an argument we got this visual side effect on in the speech bubble. And that's exactly what just happened in And let's look a little Let me wave my hand at green flag clicked part of on the say block in Scratch and So if I step through this we did last week with I would first use the print a bit of a white lie. It's actually the printf function. Printf means formatted. And it's just a function that allows There is no say function in What MIT did down the road years ago as printf, and they simplified by just calling it But notice that now if I want to convert it right, it's the same shape. So MIT deliberately if only because it conjures this So on the right, if I want to to the printf function, I use an open In those parentheses, it is I want to print on the screen-- in this case, hello, comma, world. But notice I've because you need some extra Any time you type out some text-- otherwise known as a string of text, you need to quote it, in Double quote at the left, And notice too I'm going to include here too-- backslash n, which I also and then one last nuisance at the So suffice it to say, this This, drag and drop, you're good to go. In a language like C, printf, you want, backslash n, There's just so much syntactic overhead. But at the end of the And you'll get used to these nuisances the semicolon, and the like. But things can very easily you go wrong, even with lines of code like this. So let me do this. Let me go back to VS Code where Notice that on line 5 is So this is the equivalent And let's consider what mistakes 20 years later after learning this Suppose I forget the semicolon there. So easy to do. You will do this eventually. Let's see what happens now when and try to compile my code again. Just to keep things tidy, But that's just for lecture's on the most recent command. But I'm going to go ahead This will ensure that my And this is a manual process. I changed my code. The zeros and ones on the I need to recompile it to So here we go. I'm going to hit Enter, But again, I remove the Oh, my god. There's more lines of errors now And this, too, takes The programs we're using with the least comfortable but, really, professional But through practice, and through you'll start to notice So here's what I typed. Make hello after the sign prompt. Now I get yelled at as follows, Well, what's that referring to? I've screwed up somewhere-- on line Generally, the specific unless you actually But line 5 is a good clue. Why? It means I screwed up All right. Well, what is the error? Expected a semicolon after expression. And this error is now that I see it and I All right, here's my line of code. Here in sort of ASCII art, so to speak-- it wants me to put in green here the 1 error generated, builtin-- so some esoteric stuff there. But my program did not compile. When you see an error like So what's the fix? Well, obviously, the fix is to go And now if I recompile I won't clear my screen just yet it just worked. So we're back in business as before. All right, let me pause here, any questions about what I just did. These error messages will Yeah? AUDIENCE: So do you need a semicolon DAVID J. MALAN: Really good question. Do you need a semicolon after It turns out, just some. This is something you'll learn through and examples today. Generally, you put a semicolon And this is the technical It's a statement. And think of it as it's the code So the semicolon in code when you're done with You don't need semicolons And we'll see examples of But it usually is at the that isn't purely syntactic Other questions on the mistake I Yeah? AUDIENCE: [INAUDIBLE] DAVID J. MALAN: Correct. So line 5 is where the Character 29 means it's And then it's actually, in this The compiler won't always especially if I've made But often, it will do its best Yeah? AUDIENCE: How come you DAVID J. MALAN: Ah, so how come I and now I'm typing make hello? Two different processes. So when I typed code, was because I wanted to open VS Code It's like going to File, Thereafter, though, once the file and it does autosave, you don't need the time-- I can now compile it with So theoretically, I should never again unless I want to create a All right, so what about this Let me clear my terminal window here. You can also hit Control-L away just to clean it up aesthetically. Suppose that I omit whatever is, backslash n, since I'm not why that's even there. Does anyone want to if you've never programmed before, and rerun this version of the program? I left the semicolon, but I Any instincts? All right, well-- yeah? AUDIENCE: Will the straight after your hello, world? DAVID J. MALAN: It will. The next dollar sign will appear But what makes you think that? AUDIENCE: Because the DAVID J. MALAN: Exactly. Backslash n is actually of symbols that creates a new line. And so, to your point, if I recompile no syntax error, so it So you don't need the backslash n. You do need the semicolon. But if you don't have the backslash n, this time. Now, indeed, I see hello, comma, And this is still a prompt. I can still type commands at it, like But it just looks kind of stupid. If I run it again here with ./hello, It is convention that when you should ideally clean to the next line for the user. And so the backslash n is otherwise known as an means move the cursor to the next line. In other languages, Python among them, Now, if I go back to the I try to do this differently. Suppose I don't put the backslash n. I just hit Enter like a normal person Let me go ahead and try And this, you would You would hope this would print out because I move the But no. If I run make hello now and try to Now I get a different this time starting at character 12-- error, missing terminating some other esoteric stuff. And then this does not sound too many errors emitted, stopping now. So I really screwed up here. So why can't I do this? Just because. The humans who designed C decided it must stay on the same line. It can get really long. It can soft wrap-- that is, But you can't hit Enter If you deliberately want a new line, escape character. So let me go ahead and do this. Let me put it back. Let me go back to my terminal window. I'll clear the screen again. Let me go ahead now and do make hello And voila. We're back in business with hello. All right, so now let's tease of this code because there's a lot world on the screen. For today, we're largely main(void) and these curly braces here. We'll come back to that before But for now just think of int here as really being the C equivalent Why? You just need it there. That's how you get your program going. And main is indeed going to be some another time. But why do I have this The correct spelling is indeed And they're angled brackets this There's a hash and then If you don't know what not really that much harm in just So let me delete that line. Let me go back to my terminal and then run make hello again. And let's try compiling this Why? I don't understand it, so All right, here's yet another hello.c, line 5, character error, implicitly declaring library and then dot, dot, dot. So implicitly declaring so this is very cryptic sounding. You'll get better at But apparently, I do need But why? Based on this symptom, be for what that first line of code Why intuitively must it be there? AUDIENCE: It's how the DAVID J. MALAN: Exactly. It's like importing a library so that out on the screen. Now, in Scratch, you didn't have to But you might recall that I went to the Extensions button at and I imported some extra to speech that gave us the creepy of the cat's mouth. Well, that was like adding a library-- code that someone else wrote. In that case, it was a third party. But I gave myself access to it. Same here. Turns out that you don't really You have to include a declares that function to exist. Now, the reason for this Back in the day when computers were you don't want to just give yourself sink of functionality. You only want to include only the Nowadays, it's a copy/paste want to print something at least when writing But these so-called header about all of the functions in what's And standard I/O just means And that's appropriate, right? Because printing is pretty basic output. Turns out, there's other functions keyboard-- more on that in a bit. But any time you want to print you indeed need to include this And that's going to essentially I want to use functionality including printf in this case. And if you omit the it's just not going to work because It's some unrecognized All right, questions, then, about this or what these header files are? All right, you might wonder, well, How do you know what files you Well, it turns out that C and it has ample documentation. A caveat is that its documentation isn't But what we have for the of the official documentation for So in the world of C, there are what are called manual pages. And these are just that, honestly, is that you have to be an experienced So what we've done in this is we've imported all of the but we've added less comfortable for a lot of the functionality to help onboard you. So at the end of the day, you don't But just to get started, we'll that you might appreciate for instance, as opposed to the And so, for instance, if you on what functions exist you could go to a URL like this, or you That would show you a list of all of and print if indeed And then you could click like this that's going to give you to use printf. It turns out, you can do even more And we'll scratch the But it turns out that the be your authoritative source ultimately and how can I do it? Meanwhile, it turns out that and accessible via header It turns out in C that pretty easy, relatively get used to all the curly braces, But input is a little more difficult. And if you have programmed before, It's not that hard to do in Java. It's more difficult to do in C. And But for the first couple we actually provide you of sorts, whereby we have that are declared in this file, cs50.h. It lives its documentation And in a moment, we'll You'll see that CS50 provides you for get a single character get_int to get an integer get_string to get a sequence of text of others as well. So let's actually use some of by revisiting, really, wrote in Scratch last time, which So first version of Scratch Said the same thing every Version 2, recall, though, did this. It asked the user, what's your name? And then that somehow gave it And we then joined hello and that interesting on the screen. So what did that model look like? Same thing as before. We've got a function in the middle implementation of our algorithm. That takes in one or more want to say on the screen ultimately? And return value, in this case, is going So in the case of getting input, we like last week. The input to it is whatever words And then it returns a value. And this was called by But we'll see in C, you can call you want ultimately in variables. But this is different A side effect is just something visual like the speech bubble or hello, world. A return value is actually a that you can use or reuse. So how do we convert this Scratch block Well, if you want to ask the user you can do this. You use a CS50 function And you use the parentheses to represent You can then put the sentence quote/unquote, what's your name? But you do indeed need So I'll go ahead and add those as well. Subtle, but I've deliberately included but before the double quote, moves one step over we're not going to get a special It's just going to leave the cursor aesthetically, that just space after the sentence on the screen. All right, but the we just automatically got in a special variable called answer. In C, you're going to have In C, If you want to get back a return you have to use an equal sign and then The choice of variables is up to you. I could have called I'm going to more descriptively MIT did with Scratch. But notice that this doesn't This is assignment in this case. So in C, when you use that means copy the value on on the left-- from right to left. So what does this do for us? Well, if get_string is a function quote/unquote, what's your name, that means it hands me back some value. But it's up to me in C to do So if I want to copy that value into I use an equal sign, and I invent on any variable name I want. There are certain rules. There are certain conventions. But generally if you use a you're in good shape. But C's a little more And those of you who might not be used to this, is a world we'll get to in a few weeks. You also have to tell C what So if I do want a string of text from a single character. I want a whole string of text, in this case-- I have to tell C that this So it's a little wordy, And you just have to be precise. You're informing the computer what type All right, it's so but I have omitted something What's missing still? Yeah? AUDIENCE: Semicolon? DAVID J. MALAN: So semicolon. This is a statement. This is like a full In Code, I do need to end it ultimately All right, so this was but let's try using this in now my code. Let me go back to VS Code where Let me go ahead and include one namely include cs50.h so to get_string and anything Now let me go ahead and add a line of And let me go ahead and do this-- string answer equals get_string, question mark. I'm going to add an extra I'm going to indeed end my And now let me deliberately make a Let me now try changing hello, Now, perhaps, even though this you can see where I've errored already. But let me try making this program now. So far, so good. So no error messages. So that's a good thing. Let me go ahead and run ./hello, What's your name, question mark. And notice, the cursor is just because I thought to put a little blank space it right after the question mark. Let me type my name. But even if you've never programmed What are we going to see on AUDIENCE: Hello, answer. DAVID J. MALAN: Yeah. Hello, answer, most likely. Why? Because the computer is And if I say, quote/unquote, That is the string of text going to be outputted to the screen. So we need some way of actually It's not quite as you could just grab a second say block We actually need a new syntax. And it's going to look weird in software nowadays, especially in the So let me go ahead and propose Well, back when we did this in Scratch, was this here. We used the say block still, which is But I use the join puzzle piece and and then the name of the human. So how do we translate this code to C? Well, it's going to look I'm going to start with printf with representing the say block. But how do I now do this joining? This is where the puzzle pieces This would be the way to do this. You put hello, comma, So this is what's known as a format And it just means this is Again, a string is just text. So this means, hey, computer, print and then not literally %s. %s is treated here. All right, so what else do I still need? Well, this is still going to surround the whole I'm still going to include to keep things tidy and move So the last step here in C is to somehow And the way you do this is with printf, is what I keep doing. I keep passing it one string I'm going to now add a comma and then printf to go back and plug into that %s. And printf is just smart about this. If you have one %s and one additional from right to left, it plugs it in. If you have two %s's and two variables If you separate them with commas, and the second variable So it's just left to It's not as pretty or as simple as All right, let me pause because Any questions on this technique here? Yeah? AUDIENCE: Why did you exclude the DAVID J. MALAN: Yeah, Why did I exclude the Really, just my sense of No good reason beyond that. So if I look back at my notice that I didn't That's just because, for whatever I wanted the name to be typed I totally could have added a That would have just allowed Totally fine. Just wanted to show you Good catch. Yeah? AUDIENCE: Can you show DAVID J. MALAN: Can I show Surely. So let me in VS Code do this. Let me clear my terminal And let me do this. Instead of calling the variable let me call it first. And I'll ask two questions. What's your first name? And now let me do string whoops, capitalization matters, there-- quote/unquote, What's your And now we'll plug in And now I'm going to plug in first And now I'm going to go Make hello-- crossing my Here's my first question, David. Here's my second question, Malan. And again? Hello, David Malan. So it just inserts them left to right. All I was doing for parity and let me go ahead and undo this again. I'll go back to answer, like this. I'll go back to just asking I'm going to delete mention of last. I'm going to delete And now if I recompile oh, I did screw up-- didn't intend it. What did I do wrong? AUDIENCE: You forgot to DAVID J. MALAN: Yeah, So I changed my variable back to answer but I didn't change it here. So I have an use of It's undeclared in the sense that I didn't declare first. So indeed, intuitively, I want Let me now do make hello again, ./hello, And there it is-- hello, David. Questions on this then Yeah? AUDIENCE: [INAUDIBLE] DAVID J. MALAN: Ah, the placeholder-- I'll zoom in-- is just a So inside of my string here is %s, and and then the name of the variable whose And now notice there's of these parentheses on line 7. And yet, I claim that is only taking in two arguments. Why is there then two commas If there were two there would be three arguments, right? AUDIENCE: The comma so it counts as a comma [INAUDIBLE] DAVID J. MALAN: Exactly. The comma in between the quotes It's separating the hello from the name. So that's why indeed that's also why programs like VS a little differently just so that even though, in this case, it's a little but indeed, it's trying its best. Other questions now on this placeholder? Yeah? AUDIENCE: If you wanted to put would you put a comma and would that put it [INAUDIBLE],, DAVID J. MALAN: Ah, good question. If I wanted to add an would I have to add another I could actually do I can just put the exclamation I don't need an additional If I zoom out now and run and type in just my name-- now you'll see more excitedly, So printf is smart. It will figure out where the %s Now, let me propose that a is that as soon as we make a we often paint ourselves into Can anyone think of a problem that in this string to printf? What could go wrong if we're AUDIENCE: [INAUDIBLE] DAVID J. MALAN: Yeah. If you literally want to say, %s on the screen-- or It turns out that a specially inside of printf strings. So what's the solution here? There's different patterns of But suppose you wanted to Let me go ahead and So I got 100% on your test or whatever. All right, let me go ahead All right, so invalid I mean, I have no idea what the percent sign as problematic. Well, it turns out that humans years We already used %. Well, two percent signs So now if I rerun make hello, So there's going to be things like that, you have to Google, you have to But there's always a solution And thankfully, they don't Yeah? Oh, just pointing. Other questions? Yeah? AUDIENCE: So if you have DAVID J. MALAN: If you it is in the left-right order. So printf will analyze that you pass in between quotes. And whatever the first % is, the first gets plugged in there. And then the second gets plugged into and so forth. So it's just based on left to right. Yeah? AUDIENCE: This more of a What exactly does the %s mean? DAVID J. MALAN: It's just a placeholder. It's called a format code, and it just here. And printf-- the humans who wrote special. Why? Just because. They needed some placeholder. They decided that, eh, no one's ever And if they do, they can just do %%s. So they decided to implement printf analyzes whatever text and then somehow plugs in the And just the-- ah, question? Sorry? AUDIENCE: What if we wanted to DAVID J. MALAN: Ah, so what if you like initials, like D M or D J M And that, too, is a perfect segue from are going to be called data types in C. So it turns out, in C, there's And we'll see in more detail over a string really is underneath the hood. But strings of text are not the They can indeed output single They can output integers as well. Turns out that printf has for all sorts of different data types. And just some of the data types will be this list here, almost perfectly lines up that I rattled off earlier, like The reason we called those functions is designed to return to you We've used get_string We'll soon see get_int, and we'll But these indeed are the types plus others-- can use when writing a program in C. The onus, therefore, is on do I want to store an int in or, heck, when writing fancier code, Those can all be different But for now we'll focus really That was a lot. Let's go ahead and take No cookies yet. But in five minutes, we'll come On our second break All right, we are back. And so if you have been but hitting some bumps in the And indeed, the goals will be to give you a sense, be going during the course of the week. But it's indeed through the that you'll really have an to work through some of But for today, let me give you And these two will translate Namely, like conditionals, after knowing now how at least get_string and printf-- and we can use variables like how can I now add to the mix things at that? Well, with conditionals in Scratch, we Here in Scratch is how you might have this relationship. If x is less than y, then say Well, let me translate that So in C, the corresponding code assuming x and y already exist-- more on that later. And notice a pattern we're There is going to be parentheses around around the Boolean expression, recall. The Boolean expression is the a question that you're trying whether or not to do something. So you use parentheses there. So similar in functions where we use for get_string, and this is just a When using the keyword if, you put a space after the word if. When using a function like printf Both will work, but you'll find that that most people adhere to-- All right, now inside is where the actual code goes that So if you want to print only if x is actually use this open curly brace-- you've probably rarely and the closed curly brace down here. And those are hugging, if you of code underneath the to how the orange block here hugs So there's no graphics So you can think of those curly braces As a side note, if you only have condition, if you will, you strictly, But as a matter of good It will make more obvious How about in Scratch if you two ways in the road that you might Well, if x is less than y, I Else, I want to say the opposite, So I'm making a decision based In C, It's almost the same, but you're so MIT borrowed for Scratch and a second pair of curly braces, And you might guess now Well, you print out x is less than y, All right, what if there is In Scratch, this actually gets a little But notice that in Scratch, this is how say x is less than y. Else if x is greater than Else if x equals y, then Now, minor inconsistency here. Just a little bit ago, I represents what operation? AUDIENCE: Assignment. DAVID J. MALAN: Assignment Insofar as Scratch is and they didn't really want to get into equal sign in Scratch means equality. However, we're going to need to In C, equal sign means In Scratch, it literally All right, let's translate this this code would And you can perhaps see, somewhat not unlike the %% solution earlier other corner. You say if, you say else and how did we resolve the use In C, when you want is the thing on the left equal you literally use two equal signs in between them. But now this code would be correct whether you're doing this in But now we can nitpick our code, Logically, can anyone critique either in Scratch or C? I feel like we could do better. How about in back? AUDIENCE: The only option after than is [INAUDIBLE]. DAVID J. MALAN: Perfect. Logically, it's got to be the or x is greater than y, or by So why are you wasting my asking a third question? You don't need to ask this final else it should go without saying. So it's a minor tweak. You're doing extra work potentially So we can just refine that. And just like in Scratch, you could could we simplify this code to just that just handles the reality to be the final situation instead. All right, so we have this ability with Boolean expressions. Let's actually do something So let me go back to VS Code. I've closed hello.c, and I for the sake of some demos now. Recall that you can create a new the name of the file you want to create. For instance, I might do compare.c. I want to write a program some values for demonstration's sake. But before I do that, by opening the File Explorer at to a Mac or PC. You can go up here and click on an icon, and you'll get a blue box. And I can type in compare.c, and I Notice that opens the tab even So again, on the left, you have a albeit a simplistic one. On the right and at the bottom here, but they're one in the same. What's nice, though, is that if I close whatnot, I can reopen a new one by just running that same So code is a VS Code thing. It's just a user-friendly shortcut. But it's just creating a file or I'm going to hide the File Explorer And let's go ahead and do this. Let's write a program that compares but not strings this time. Let's use some actual integers. All right, I'm going to go ahead and file at top-- cs50.h. I'm going to also include stdio.h. Why? One gives me user-friendly input via One gives me user-friendly output Now I'm just going to blindly type this in future weeks. But for now, that's green flag clicked code in Scratch. And now let's go ahead and do this. Let me go ahead and and ask the user, I'm not going to bother with a new line. I want to keep it all in one But when I get back and int, I get back a return value. So if I want to store the I had better put it in a variable. And I can call the Previously, I used Now I'm going to use x. But there's still two things left haven't technically done this yet. What I still need to do? AUDIENCE: A semicolon. DAVID J. MALAN: So I need AUDIENCE: And the int first. DAVID J. MALAN: And the You the programmer, starting going to be storing in your variables. And you just need to tell the Now, as a teaser for languages turns out, humans realized, Why can't the computer just figure Why do I have to tell it proactively? So in some languages will get rid of some of this syntax, But for now we're looking at, really, All right, so I've done this Let me do one other. And let me get a second int asking So almost identical but different And let me just ask simply in parentheses, then some curly quote/unquote, x is And now just as a side note-- I seem to be typing fast. Some of that is because Let me go back to this first And now I'm only on my keyboard This is a feature of many It finishes part of your thought. Why? Just to save yourself a you don't accidentally So you'll notice sometimes that things It's just VS Code or future programs I'll go ahead and manually x is less than y backslash So let me go ahead now and try let's see. So make-- not hello-- but make called compare.c, hitting Enter. No output is good because it Let me ./compare instead What's x? How about 1? What's y? How about 2? X is less than y. Well, let's try it again. And here, I'll save you Let me clear my screen. Instead of constantly you can also use your keyboard's arrow time. So if I hit Up once, there's If I do it Up twice, there's the So sometimes if you see it's just because I'm cheating and All right, let me go ahead, Let's reverse it this time-- 2 for x, 1 for y. And now, of course, there's no output. All right, well, that's because we didn't have an else here. So let's add that. Else-- now let's open my curly for me-- printf, quote/unquote, x is Let me go ahead and try this Again, 2 for x, 1 for y. And we should see-- huh. What did I do wrong? Why am I not seeing any else output? Yeah? AUDIENCE: You changed your You need to compile it. DAVID J. MALAN: Exactly. You got to get into the habit after Or otherwise, the zeros are the old ones until So let's fix this-- make compare, Enter. No error messages. That's good. ./compare, 2, 1. And now I get back the output. So x is not less than y. How about if I go and add Well, we can do this either Let me go ahead and refine this. So else if x is greater than y, let's And now I could do x else But I think we already claimed that So let's just have our catchall. And here I'm going to x is equal to y backslash So I think now with this code, Let me go ahead and recompile it And now 1 and 2-- is less than y. Let me run it again. 2 and 1-- x is greater than y. And lastly, 1 and 1, So for the most part, our We're up to 21 lines of are just single Almost everything else is the same. I'm using the CS50 library's header for my printf function, is just now new syntax Questions, then, on of just some basic Any questions? Yeah? AUDIENCE: Just a syntax brackets need to be on a separate line? DAVID J. MALAN: Good question. Do the opening brackets need In CS50, yes. What you'll see is that as we compare your code against a style A company would have its own sense of And there's generally automated that help give feedback on the There are alternative styles We deliberately keep the curly braces on because it rather resembles like the and just makes clear that they're However, another common paradigm in is to do something like So you have the opening curly We do not recommend this. This is en vogue in the But ultimately in the real world, and/or the company they're to decide on those things. All right, so beyond, what if we want to do something So almost every piece of software has you agree to some terms and Y for Yes and N for No. So how could we implement Well, let me do this. Let me create a new program, So I'm going to write code agree.c I'm going to start, as Let's include stdio.h. And then let me do my int main(void)-- we'll take at face value And if I just want to get Y or N, we can just use a simpler variable here. How about just a char, a So I can use get_char to do you agree, question mark. But as before, I need So I don't want a string I don't want an int. I just want a char. And it's literally C-H-A-R. And then It's conventional if you have a simple and it's of type char, call it c. If it's an int, call it i. If it's a string, call it s. For now I'm just going to And now I'm going to ask a question. So if c equals equals, how let me go ahead and print as though they agreed to Otherwise, let's see. Else if the character equals equals, and print out, say, Not agreed, as And let's leave it at that, Now, you'll notice one curiosity, Does anyone want to call it out, I've done something ever so slightly Do you see it? AUDIENCE: The single quotation mark. DAVID J. MALAN: Yeah. So I've suddenly used single quotation and double quotes for my This is a necessity in C. When you're of text, like someone's name, a really more than one character, And indeed, you must. When dealing with deliberately single you must use single quotes instead. Why? Because that makes knows that it's indeed So double quotes are for strings. Single quotes are for chars. So with that said, let Let me go ahead in my terminal Seems to work OK so let me Let me go ahead now and type in y. Here we go. Enter. Huh. Let me try that again. Rerun ./agree. How about no? Enter. Why is it not behaving AUDIENCE: Because you entered DAVID J. MALAN: Yeah, I and I hit the Caps Lock key just Why? Because I deliberately wanted to type which is kind of reasonable. It's a little obnoxious if you force key on or off when you That's not the best But it would work if I cooperated. Let me run this again y lowercase for yes. Ah, that worked. n lowercase for no. That worked. But how could I get it to work for both? Well, how about this? Let me go ahead and just So else if c equals equals then also do printf agreed backslash n. And down here, else if c equals then go ahead and print This, I will claim now, is correct. And I'll do make agree And I'll use capital. It now works. I'll use capital. It again works. But this is perhaps not the best design. Let me hide the terminal window and Why might this arguably not be the There's another term of art we can smells kind of funky about this code. This is an actual term of art. There's code smell here. Something smells a little off. Why? What do you think? AUDIENCE: [INAUDIBLE] DAVID J. MALAN: Yeah. There's the same output again and again. I mean, I manually typed it. But honestly, I might as well most of my original code to do it again So if line 10 and 14 are the same AND the rest of these if and [SNIFFS] there's some code smell there. It's not well designed. Why? Because if I want to change things I might have to change my code is never a good thing. And god forbid I want to add support it's really going to get long. So how can we solve this? Well, it turns out, we can So let me try to It turns out, if I delete that clause, In Scratch, there's a couple of puzzle that literally have the and on them, which allow you So that either this or this is In C, you can't just say the word or. You instead use two vertical bars. And vertical bars together And so I can say, c equals equals And now I can get rid And let me go ahead and equals quote/unquote N in all caps. And now my program's roughly a There's less redundancy. And if I reopen my terminal window, now I can type little y or big Y and N. Any questions then on this syntax, and just tighten things up? And there'll be other such tricks too. Yeah? AUDIENCE: Is there not a DAVID J. MALAN: A really good question. Is there not a function Short answer, there is. And we'll see how to do that in, And in other languages, to just canonicalize the user's input, they might have accidentally hit, In C, It's going to be a little But in fact, as early as next But for now we're comparing Other questions? AUDIENCE: So we're assuming the user's How do you handle if they DAVID J. MALAN: Really good question. So we are assuming, with this that the human's cooperating and when I and not 123, or, in this case, they a full word. So this is one of the features So for instance, if I run agree again, it rejects it altogether. Why? Because s, u, r, e is It's not a single character. Now, I could just say something like But it tolerates that because But built in to CS50's library of inputs that's not expected. So if you use get_int and the user but cat, C-A-T, it will just prompt And this is where, too, if you you end up writing this much code That's why we use these just to make the code more robust. But in a few weeks' time, And you'll see and understand All right, so how about this. Let's now transition to something a by creating how about another so meow.c. We won't have any audio We'll just rely on print. And suppose that I and see that just So I don't need any user input just yet. So I'm just going to use stdio.h. I'm going to do my usual And then I'm just going to go ahead And let's have this cat meow So I'm going to do meow, meow, meow. Notice as an aside whenever you'll see little dots appear. This is just a visual cue how many spaces you've indented. VS Code, like a lot of editors, will I've not been hitting the space I've not even been hitting Tab. However, in C, the convention where appropriate by four spaces-- so not three, not five. And these dots help you see line up as a matter of good style. All right, so this program, I'm is indeed going to work. Make meow-- which is kind There, three times. Correct. It's meowing three times. But of course, this It wasn't well designed Why? What should I be doing differently? Yeah? AUDIENCE: A loop? AUDIENCE: This could be a loop. DAVID J. MALAN: Yeah. It's a perfect opportunity for a loop. Why? Because if you wanted to change maybe or you wanted to change the sound you'd have to change it And that's just kind of stupid, right? In code, you should ideally So how might I do that? Well, we could introduce a loop, yes. But we're going to need another building namely those things called variables. So recall that a variable, y, z, whatever-- can And a variable in Scratch You use this orange puzzle piece not just x, y, or z. But you could call it something and you can set it equal to some value. In C, the way to do this is similar we've seen thus far. You start by saying the name a single equal sign, and then the value. You want to initialize it too, Why? Because the equal sign denotes, This isn't enough though. You might have the intuition already. What's missing probably from this line AUDIENCE: Int. DAVID J. MALAN: So we need int that this is indeed an int. And then lastly, semicolon as well. And that now completes the thought. So a little more annoying starting to see patterns here. So not every piece of All right, if you want to Scratch uses the verb change, and So if I want to increment an this syntax is a little It turns out the code looks like this, How can counter equal counter plus 1? That's not how math works. But again, a single equal sign So this is saying, take whatever the and copy that value from right You still need the you do not need to mention the keyword So only when you create a variable in C int, or any of the see-- only when creating it or Thereafter if you want to It's the word you gave it. The computer is smart enough to So this line is now complete Turns out, in code, as we'll see, it's together, increment things by one. So there's actually different The term of art here is syntactic sugar. There's often in code many even though, at the end of the day, So for instance, if, after a few days to keep typing in some program, This is the syntactic sugar. You can use plus equals and only mention and it just knows that It's just slightly more succinct. This, too, is such a common And it doesn't have to be 1. But in this case, it is. But if it is indeed 1, you can further counter++. So any time in C you see ++, it means variable. There's other ways to do If you want to subtract you can use any of the previous syntax or you can more succinctly do counter--. This is the way a typical All right, so if we go and solve the meowing with loop. So in Scratch, we saw loops like this. This, of course, had the How do we do this in C? Now, this is where things get a but if you understand we'll follow logically what's going on. So here, I claim, is a loop that iterates three times in C. We went from two super simple it's 1, 2, 3, 4, 5, 6 lines of code, So that escalated quickly. But what's each line doing? And we'll see other ways So we're initializing a variable Why? Well, what does it mean to loop or Well, it's like doing and then do it, and then do it, and then count down, and then So this is declaring a variable Then I'm inducing a loop in C, which but you have to do more So I'm asking the while count is greater than Well, per the indentation inside the And then, to be clear, what's If counter starts off at three, this Then what happens? By nature of the loop, just like in even though there's a nice, pretty C knows to do this again, and again, and and then updating this value at the end. So if I highlight just a few of these And actually, let me simplify 2. I claimed earlier that when people very often just call or s for string unless you So let me tighten the code up. And this already makes it Let me actually tighten it up So now this is about as you can make this code at the moment. So what's actually going to happen here? Well, the first line of code Then we check the condition. While i is greater than Well, per my three fingers, obviously. So we print out meow on the screen. Then we subtract 1 from i, at which Then the code goes And notice, the condition That's another Boolean expression. So loops can use Boolean expressions, Boolean expressions to make decisions. The loop, though, is deciding not but whether to do the same thing And as it ticks through the it's ultimately going to get down So put another way-- came with some is your variable, and you initialize you can do something three times, right? If I want to give out here's your chance for free stress balls OK, there we go. So here we go, subtracting I'm left with two. Oh my god. All right, don't tell Sanders. [GRUNTS] Oh, I'm sorry. Oh. [LAUGHTER] OK, that ended poorly. Apologies. All right. But now the educational that my variable has been decrement I'm not throwing that far again. I can't do this. Here we go. All right, here we go. And one final subtraction. And now our variable is left empty. So we had three stress balls there, It's some kind of storage. It's actually, of course, But metaphorically, it's really And every time you or, you're just changing the And then the code, meanwhile, of course, is the bowl empty? Is the bowl empty? Is the bowl empty? AKA, is i greater than 0 or not? Any questions on how we've And I owe you a stress ball after class. Questions on loops? All right, so it turns And this really starts of programming when you have to So it turns out, there's But first, let's see, you might express this because it's a So the one other way to do this You could absolutely start with And then you could ask the question, And notice a bit of new syntax here. On your typical keyboard, or equal sign or greater like you would write in math And so in C, you use two characters, or, if appropriate, greater And that logically captures that idea. So notice that I'm I'm initializing i to 1, and then to 2 and then 3. But because I'm doing it's still going to go from 1, 2, 3. So that works too. We could similarly do We could initialize i to 0, and then and keep incrementing it. And I showed this last form is It might be the most human-like It might be the most stressball-like counting down. But typically, the go-to once you get comfortable counting from and count up to less than the So it would be incorrect, why, to change What would happen if I changed the AUDIENCE: It'll only meow twice. DAVID J. MALAN: Yeah, it'll meow an right? Because you'll start at And less than or equal to 3-- sorry-- 3 will give you the fourth time. So we do want indeed to be All right, so now that let me just give you one other. And this one takes a little but it's probably the more Let me go ahead and propose that Let me go back to my code here. Let me go into my several printfs, ultimately. And let's implement this in code. So let's do int i get 0, how then let's go ahead and say melow-- meow backslash n. And then we have to do i AUDIENCE: Plus plus. DAVID J. MALAN: So plus plus and going up to but not through 3. So let me go ahead now and make meow and it's still just as correct. But it's a little more-- it's a little better designed. Why? Because now if I want to change it I can change it there. I can recompile my code. I can do ./meow, and done. I don't have to copy and paste it And I can even change what the word is But it turns out, there's And let me propose that we introduce So if you want to repeat you can absolutely take the while or you can do this. And this one takes a little but it kind of consolidates into So notice, we have the keyword for here. And for is just a preposition in here comes a loop. Inside of parentheses here is And this is where things There's three things-- to in the middle of the two semicolons, This is really the only other context Normally, it's been at Now it's two of them in but this is the way humans So what is this doing? Almost the same thing. It is going to initialize It's going to then check. If it's less than 3, it's then going and it's lastly going to So just highlighting is initialized to 0, just like before. Then this condition is checked. This is a Boolean expression. Yes or no, true or false And if i is less than 3, which well, then we're going to Then i is going to get incremented. So it starts at 0. It goes now to 1. At that point, the Boolean So you don't keep changing i back to 0. That first step happens only once. But now you repeat through I check if i is less than 3. It is. So I print out meow. It then increments i. I check if i, now 2, is less than 3. It is. I print out meow. i gets incremented. I now check. Is i less than 3? No, it's not, because And so the whole thing stops. And whatever code is below starts executing instead. Just like in Scratch, you break out being hugged. Questions, then, about this alternative AUDIENCE: Can you explain again DAVID J. MALAN: Sorry, say again? AUDIENCE: Can you explain again DAVID J. MALAN: Yeah. Can I explain again why Honestly, just because. This was the syntax they chose. This first part before is only executed once just because. That's how it's designed. Everything else cycles again and again. And this is just an the slightly more lines of code. It was, like, six lines of Logically, it's the same thing. Programmers, once they tend to prefer this because it just more succinctly. That's all. Yeah? AUDIENCE: That was my question. DAVID J. MALAN: OK. So let's just work this Let me go back to the code here. And notice, indeed, if I I think we can tighten this up. Let me get rid of all of those And I'm saying equals. Most programmers would say gets. So int i gets 0 means Now I'm going to do Now in here I'm going to do my printf And so it's indeed a little tighter. I mean, two of the lines There's really only two Let me go ahead and And again, we're back in business All right, there's one last just because it's sometimes useful. This was a forever block. And this would be a to just say meow forever, But there is indeed a forever block in forever. And I proposed, I think, verbally where this is useful. Meowing forever, a little annoying. But can you think of might want to write code or use Yeah? AUDIENCE: Playing music DAVID J. MALAN: Yeah, playing music. Like Spotify playlists, just would be some kind of loop. AUDIENCE: Checking for collisions. DAVID J. MALAN: Checking so seeing if something's bouncing Yeah? AUDIENCE: Oh, checking for input. DAVID J. MALAN: Checking for input. So yeah, get_string is essentially for me to type in some input until I do. AUDIENCE: Checking the time. DAVID J. MALAN: Checking maintaining human time, Behind you? Is that the same? AUDIENCE: I was going to DAVID J. MALAN: OK, checking the time. And one more? Detecting a key press too. Like in Scratch, just waiting just like on a phone or a browser. And so there's so many might want to do something forever-- just so you've seen the It's a little weird, but this is to do it in C. If you want which would be a little crazy because your computer printing forever meow-- you would generally do it like this. Why? Well, a while loop expects in and a Boolean expression is, again, But if you want the answer to or really, always to be true, turns will then just say true because true-- T-R-U-E-- is never going to I mean, it's just a special word So by saying while true, it just Another common paradigm became commonplace would change while 1. You might see in online while 1 is really the same thing. Any value that is 0 is generally Any value that is 1 or is generally interpreted as true. And so this, too, would have the same Generally speaking, while true is Now, meowing forever But suppose I did that Well, let's try this. So here I'll go into my code. I'm going to get rid of for loop and true. And in this case here, well, Make meow, Enter. And you'll see this, use of This is actually hinting at my Nowadays, you could say true or false. But true and false are themselves And it turns out, if you want to use there's another header file we haven't creates true and false as keywords. Alternatively, CS50 So it's more common in CS50 Now if I clear my terminal window and Enter, well, unfortunately, this isn't you're in the cloud using a browser. This is indeed a browser, This means I'm sending millions of meows So this will happen to you at some But you'll lose control Why? Because you screwed up. And you have an infinite loop. You didn't really intend it. Or maybe you did. You were curious to see what happens. What do you do? When does the meowing stop? What recourse do we have here? Well, Control-C will be your friend. Sometimes you have to hit it a But Control-C for cancel will And I promise that almost accidentally introduce an infinite When in doubt, click in the sometimes multiple times-- and that will indeed cancel In this case, I might have intended it. But sometimes it's All right, so we've been taking for interface for some time and, and the buttons on I'm clicking. And let me just give you it is we are using underneath namely an operating system called Linux. So I keep alluding verbally, because almost all of us are running or laptops nowadays. But there's lots of other and one of the most popular And Linux is very often used that host email, companies that host Certain computer scientists often like to brag that they run But it is really just an that provides you with but also an especially a Now, fun fact-- Windows and macOS do thereof. And eventually, you might use it on your But Linux is really known for, its command line environment, which, as a Command Line Interface, or CLI. And that refers, really, So if I go back to VS Code here, and let and focus entirely on this terminal window is really to your very own server in the cloud. The term of art here your own container in the cloud, running somewhere on the internet to which you have access and your own home folder that has And it's only accessible to you unless So when you're typing like you're typing them, of But they're actually being to some server in the cloud where your own account therein. So it turns out that there are other And we'll give you just And over the coming weeks to play with others as well. But these are some of the basics. And they're all incredibly succinct typing at the command line, wanted to type out long commands. So a lot of these are Now, perhaps the most common is ls, a lowercase l and a lowercase So if I go to my terminal I've only typed code, which is a VS Code and make, which triggers the compilation This will list all of the my hard drive in the cloud, if you will. So if I hit Enter, you'll Now, they're color coded too. The white ones here end in .c. Those are the source during class today-- agree.c, And you can perhaps guess, the green have an asterisk on the end to denote One of the four others. Yeah? AUDIENCE: The machine code? DAVID J. MALAN: Yeah, the machine code. So those are my actual programs that extension. And the asterisk means That is in the world of macOS or But in the world of a that means you do ./ and then the name the code therein. So if I open up my File Explorer-- and here just as a keyboard shortcut-- So ls is the command line interface But here, because I'm using VS I also get a graphical So it's just two different places to be. You're welcome to use whatever But over time will you and capable with the Well, what else is on this list here? Well, during the break, I saw for instance, had created a file So you were in a situation where you And then you went ahead and typed And then down in your were trying to do make hello, Enter. And this now didn't I can't-- I'm hitting-- I'm trying to run the command. I got permission denied, Now, why is that? Well, let's just do a quick check. If I do ls, I see now no asterisk next to it, which That's my code. Why? Well, notice the top of my tab I didn't name my file hello.c, So what do you do? Well, you could very hackishly copy Or no, no, no. We know how to rename things now here Let me do this. Let me do mv for move, hello, You'll see the tab closes But if I now type ls, you'll And if I open that file now, And now if I do make hello-- make hello-- now I do get an executable So mv, it's just a command not just eventually for moving files as well. You can also create So for instance, if I go into I hover over here and click not on I can create a folder called, set 1 in the class. And you'll see now that it's empty are in the default folder of my account. But I could also go in there like this. And I could click on File, and now I which is one of the first But you'll notice now that mario.c So if I zoom out and I type I won't see mario.c anywhere. But I do see a pset1 folder. And it's in light blue followed by a It just indicates that's a folder. Now, I can visually at top left But if I try to do something no rule to make target mario. It just doesn't seem to exist. And that's because you're So in a command line interface, as just clicking on a You have to change into And cd is going to be the command there. So if I want to actually I can do cd, space, pset1, Enter. And now you'll see my prompt changes. And this is just a common convention, Now I still have a dollar sign, which But before it, I see a reminder And we put that there deliberately, do just to remind themselves where they where you have a nice, big at the command line, you need But now if I type ls and hit AUDIENCE: Mario.c DAVID J. MALAN: Yeah, mario.c. And now if I want to open it-- if I want to actually compile it, I once I actually type Rest assured that in we'll almost always-- certainly, give you exactly the commands to type. Odds are because it's you will accidentally No big deal. Just remember that you have different You've got the graphical should feel a little more familiar. But in time you'll start probably prefer commands like cp for copy a file, ls for list, create a new folder at the command mv for move or rename, rm for-- AUDIENCE: Remove. DAVID J. MALAN: Remove. So be careful with that one. Rmdir, remove directory. And there's dozens, You won't need many of to scratch the surface But ultimately, this is going to be a more powerful and ultimately, a more for writing code, running commands, generally, even though to be some growing pains probably so new for many of you. So with that said, we have but we promised cookies today. So let's go ahead and Cookies are now served in the transept. And we'll be back here in 10. All right, we are back. And up until now, each of the have been designed to But we thought we'd try to take a step and give you a sense of when given a programming problem more and how you go about approaching what the point of the exercise is. So one of my favorite is this one here, &quot;Super Mario different forms since. But in this original there was a lot of artwork like this. So for instance, up here in the And we'll find that in C and a lot it's a lot easier, a lot more accessible interactive programs to full-fledged graphics on the more graphical acoustic But for now let me go try to just implement in ASCII art-- ASCII, again, being the to letters, at least for English, into marks in the sky. So for this, let me go over to VS Code. I'll create my own will be different from the one you're Indeed, in problem set to build a little something for ASCII art instead of graphics. And in mario.c, I want to just So it's all involving output. So I'll do include stdio.h I'll do my int main(void)-- more on And I'm just going to do like 1, 2, 3, 4, backslash n. This is about the simplest way marks in the sky like these So let me go ahead and do make We have those four question marks. But we've seen, of course, that And if you wanted to generalize 60 different question marks, for not repeating ourselves. So maybe I should rewrite this a little like this, for in i get And then inside of a for loop, now I but I don't think what Any one spot the aesthetic bug already? Yeah, why is this wrong if I Yeah? AUDIENCE: The backslash n, you DAVID J. MALAN: Yeah. So I don't think I want a backslash because the goal is, again, this So if I now recompile this, make But now I have that regression to where So I think I need a new line, because that was not going to end well. Where do I want to instead? Any instinct? Yeah? Yeah, so outside for loop. So indeed, I can just go below line 8 And now it's totally fine to You don't have to print It's indeed a character unto itself. So let's do make mario OK, so now we're back in business there. Well, what if we wanted to do some other here where there's a lot of vertical If I wanted to print out now and I'll use hashtags for these I think we're almost there, right? I think I can now-- it's almost maybe a little easier. I can go back here, to something that looks more like And I think now I do want the new line mario, ./mario, OK, Oh, but wait. I didn't want four. I wanted to be consistent just so I just want three. So I can still change it in one place. And here, again, is that paradigm. Even whether you're into the habit of you go on up to but not through So that's why I'm using less than So this would be the common like we saw earlier in different ways. But what if things And when you're in the underground there's a lot of these including grids of bricks like this. And let me conjecture that if you by 3 grid of bricks that all big, large brick like this. So if I want to print out a 3 by 3 grid, interesting because up until now, I've or one column vertically. But we haven't really I'm printing or living in two different But let me propose Let me go ahead and say, all by 3 grid of bricks. It's really that I want to print, A grid is three rows. So if I take the high-level to something a little Well, let me get rid of the And let me just stipulate even though it doesn't will do something how All right, three times. This for loop is good to go. It will do something three times All right, well, if I want to print on the same line, that's we did earlier when I four question marks in the sky. So we've seen a solution there. And I daresay we can So if I want to print I could just do this for in and then inside of this let me print out a And then I don't like where this is and I've combined them. But what might be problematic What might be bad here? Yeah, in back? AUDIENCE: You used the same integer i. DAVID J. MALAN: Yeah, I'm I feel like could get me into trouble. If I'm trying to count but then I'm hijacking this variable I feel like I should avoid And so what's a good alternative to i? Well, a programmer, if would pretty commonly go with j. You could certainly change if you want more descriptive variables. But i and j is pretty canonical. So I'm going to go ahead and do And let me try compiling this. So make mario, Enter, ./mario. OK, so a couple of This is not a 3 by 3 grid. But if you count these things, how You can probably just guess logically. AUDIENCE: Nine. DAVID J. MALAN: Yeah, Unfortunately, they're instead of on three different lines. So where logically can I fix this? I'm definitely printing all the bricks. They're just not on the right levels. Yeah? AUDIENCE: If you put a new then you'll get three separate lines. DAVID J. MALAN: Yeah. So put a new line after the first the nested loop, if you will. So let me go ahead and print And what's this doing? Well, I think that's moving the cursor to the next So let me go ahead and do and now we're in business. So it's a very simplistic but I'm leveraging two or the same idea twice rather now. I'm using one loop to control my But then within that loop, dot, dot, dot, dot, each of these individual Now, there's a little If I want this to always be what it looks like in the game, well, square by doing this or a 5 by 5 grid-- whoops-- by doing this. Why is this perhaps not the best design I want to change the size? Where could this go awry? Yeah? AUDIENCE: If it's a square, [INAUDIBLE] DAVID J. MALAN: Yeah. If it's always going to is going to be the same as width, I'm Eventually, I'm going to screw up. I'm going to change Then it's going to come out to be a So I should probably solve So let me do that. At the top of my main function here, a variable called maybe n for the and vertically. And I'll just initialize And instead of putting 3 here, But I'll do it in both places if I ever want to change this and I'm all done. It's better designed because there's But I could technically I could technically accidentally or I could just change the value of that to ever change. And maybe it's because I'm a bad I'm working with someone who I can defend myself and my like that by going up here to line 5. And instead of just declaring a simple I can further harden by declaring it to be a constant Now, this is just a feature to protect you against n is a constant, specifically the You cannot accidentally write The computer will throw an So it's just a way of programming Some languages have this. Some languages don't. But in general, it's a good practice. It makes your code better as less vulnerable to mistakes by using the code. So let me change this back But now I'm using n in both places. And if I do make mario, ./mario, we're But the code is a little And let me note this too. All this time, I've been mentioning Design is important. There is also this matter of style. I've been very deliberately if you will-- not just the syntax But notice that I keep Any time I have curly braces, everything is indented one level. When I have additional curly everything is nicely indented as well. Technically speaking, the computer does so to speak. And you could really like this because you have or just because you're But this code is actually still correct. If I recompile it-- let me make mario, no errors, ./mario, But you can imagine just is to read, certainly for a TA, certainly for a colleague This is just bad style. It still works, and it's well defensively, you're using a constant. But, my god, the style is atrocious. Now, you'll often find that can help you in a manner consistent with a But this is the kind of muscle memory Take these VS Code suggestions as because it's trying to format And, oh, my god, if and when and things aren't even there's no way you the human are going what's happening and where. You're just making the So do get into this habit too of All right, well, let me propose that We want this to be a So suppose we moved away from a constant And let's ask the user as by prompting them with And I'll store it in n here. And then I can go ahead run make mario to compile it-- whoops. Oh, I screwed up accidentally. What is it suggesting I AUDIENCE: You have to DAVID J. MALAN: Yeah, I forgot to And that's why it doesn't know So that's an easy fix. I'm just going to go up Now I'm going to clear my Now we're good-- ./mario. And now notice I'm prompted for size. So if I type in 3, it's If I type in 10, it's even bigger, But there are some things For instance, suppose I type in cat. Well, that's handled by the get_int That's one of the features You don't have to deal But we only designed a function We don't know if you want it or some combination thereof. And it's kind of weird to allow for the size of the grid or And indeed, your code does nothing, But that's kind of stupid, right? It'd be nice to force a grid to give us a positive value. So how could we do this? Well, I could go up here and I could so if it's 0 or negative, which Well, I could say, well, prompt And now notice, I'm not declaring you don't have to mention We said that earlier. But this is kind of stupid. Why? Because now when you've given the I'll do-- all right, if this let's just go and prompt I mean, you can see where This can't be the right solution the same thing again and again. Where would it stop? You'd have to give them a or just make a mess of your code. So what would be intuitively AUDIENCE: A while loop. DAVID J. MALAN: Yeah, We've seen a while loop. We've seen a for loop, So let me try this. Let me delete this messiness and And let me do this. So while n is less than 1-- so while the number let's just prompt the user in a Now, here too, this is better because But clearly, lines 6 and 9 are pretty And if I went in and add this, if I change the wording here, I have to change it in two places. That's bad. Copy/paste, bad. So what might be better? Well, it turns out, there's that you can use that gets around this It would be much nicer if And I can do that using a third So it turns out, in C, you can do this. If you want to get the first just to create the variable So int n semicolon means we don't But that's OK. We're going to add a Then I'm going to say I'm going to open my curly braces. And what do I want to do? I want to assign to n the prompting the user for size. Well, when do you want to do that? I want to do that And this code now achieves but by never repeating myself. Why? Well, notice on these lines of code give me a variable It doesn't have a value You can do that. Line 7 says, do the following. What do you want to do? get_int, and just store that value in n. But because C code runs top now it's reasonable on line 11 the current value of n, which it And if the user didn't cooperate-- or negative 3-- what's going to happen? It's going to go back up here and in the do while loop. So a do while loop in C-- which is not something Python, if you know it, does This is perhaps the cleanest even though it's a little weird that create your variable up top, But otherwise, it's It just flips the order in which Any questions on this construct? And do while, in general, you want to get input sure it meets certain requirements. So all right, so now that we have this How can I go about And then let's conclude by taking a or can't do very well or correctly. Let me propose that in a let me just add what are So it turns out, in code what are called comments, Some of you discovered these in Scratch. There's little yellow use to add citations or explanations. In C, there's a couple of And in general, comments are for your colleague as to what It's a little explanatory or whatever your human So for instance, what I might of this version of mario, I might I might first make a note to above this first block of It's just an explanatory that generally explains the next or block of code, if you will. It would be a little excessive At some point, the programmer should But it's nice to be able to that starts with two slashes, because of syntax highlighting. It's not logic. It's just a note to self. It generally gives me as to what the following lines of And then down here, well, that's a bunch of lines. But together, this just, And so it's another just makes it a little these 20-some-odd lines of some English explanations thereof. But now that I have if I could abstract these pieces getting of the size and In other words, suppose that you didn't And the problem at hand a program that prints a grid of 3, or 4, or 5, or whatever If you have really no comments are actually started because comments can be an pseudocode. Pseudocode is terse English that gets book searching like last time. So if you didn't really you could do something like this. I could, for instance, just say, and then Print grid of And that's it for my program thus far. This is now implemented in pseudocode. I have some massive placeholders there. I still have work to be done. But at least I have a high-level And now I can even go this far. I could say, well, let's suppose that exists called get size. I could do something like this. I could do int n equals get_size. And now I just have to that some abstraction It doesn't. This does not come But I could invent it, I bet. How else might I proceed? Well, let's just assume for a function called print_grid that So here too is an abstraction. These puzzle pieces don't exist. These functions don't yet exist. But in C, just like in Scratch, How do I do that? Well, let me go down later in the file. And by convention, you generally want Why? Because it's the main the human eye is going to look to And let me do this. I want to create a function of my own is to get the size that the user wants. I want this function And the syntax for doing similar to a variable, the data I don't need this function And so I'm going to use a new keyword far-- more on it another void, which just means this get_size It does have an output. It outputs an int. And this is just the weird You write the output format, the name if any, inside of parentheses. And now I can implement get_size. But I've already implemented get_size. Or at least now at this I at least know concretely what to do. And I could figure out eventually, perhaps, all right, if and I do the following n equals and I keep doing that while n is is done, here is a new keyword in C So I keep referring to these values that In C, there's literally that will hand back to that function the value in question. So in a nutshell, between here is some code identical to our n from the user that is positive. It's 1, or 2, or higher. It's not 0, or it's not less than 1. And as soon as we've got that value, Notice how I'm using Just like with get_int, I'm calling the function-- nothing But then I'm using the to copy whatever its return And so now I have a to exist called get_size that gets And now for the grid, how do I do this? How do I invent a that takes a single argument, a Well, let's go down here. I'm going to write the name This function just needs to print. It has a side effect, as we keep saying. So I'm just going to say It's just void. It doesn't have an output, per se. It's just an aesthetic side effect. But it does take in an argument. An argument is an input, is to name the type of the input it And I could call this anything I want. I'll call it size. I could call it n. And it's OK to use the same but I'll call it size And then in this to copy from memory the same i less than size-- instead of 3-- i++, inside of this, for and inside of that, print out print out after that loop a Now, I did this fast, admittedly. But it's the same code But now, just like I me just arbitrarily hit to move the code out Now I have abstractions. I have puzzle pieces that now exist syntax for which takes some getting Except I do need to do one thing. Because C is a little naive, if I try implicit declaration of And we've seen that before When I hadn't included CS50 But that's not the issue here I just invented this. C takes you literally. And if you define these functions they don't exist on line 7 or 10. So I could do this. I could, all right, fine, well, cut to my clipboard, This would solve the problem. I could just move all of those That's annoying because now main It's going to take longer to find it. That's not a clean solution. So let me put it back And let me do this. This is the only time in CS50 where copy/paste is reasonable. If you copy and paste the first and then end it with a semicolon, by giving it just enough of that, OK, these functions But here's a hint that they will exist. This is how you can convince So those other functions can still But now when I do make mario-- oh, damn it. Oh, I said print instead of printf. That's my bad-- printf. So if I do make mario, and we're back in business. Now, this was a very to get to a much more But this solution, in some Why? Because now, especially I mean, look how short my code is. My main function is Why? Well, I factored out the juicy And now, especially if I'm you could imagine splitting up having different people so long as you all agree in advance actually are. All right, so let's now consider what C indeed supports a whole bunch via which we can do addition, and and even calculate the remainder when In fact, why don't we go ahead and and make our very own calculator? So let me go over here to VS Code. Let me go ahead and create a And in this file, let's a couple of now familiar header Let's go ahead then and declare And then inside of main, let's Let's declare an int it equal to whatever the prompting the user for a value for x. Let's then give ourselves We'll call it, say, y. Set that equal to the return prompting the user this And then let's very simply and just print out, say, the sum of So I'll use printf, backslash n to give me the new line. Then I'm going to go ahead and do x Let me go down to my Let me do make calculator in No error messages, so that's good. Let me do ./calculator. And let's do something like 2 plus And it does. But it turns out that sometimes that we bump up against. And let me get a little Let me clear my terminal window. And let me go ahead and And this time, let's, oh, 2 billion for And, of course, now the answer should, of course, be 4 billion. And yet, it's not. So curiously, we see, of all here, which suggests that somehow work as well as we might like. Now, why might this actually be? Well, it turns out that inside of your Random Access Memory. And depending on the size of your it might very well look a a little circuit board with that actually contain all of the Unfortunately, you and I of this memory inside means no matter how there's ultimately going to can count because we only have We don't have an infinite number We have to actually So what's the implication of this? Well, it turns out that as many as 32 bits in zeros like an integer, or in C, in int. So for instance, the represent using 32 ints, of would be zero-- 32 zeros like this here. And the biggest number is by changing all of those zeros will ideally give us a number that It's actually 4,294,967,295 maximally and then do out the actual math. The catch, though, is that we also sometimes want to and need to be So if you want to represent negative in 0, you can't really and go all the way up You've got to split the allocate half of those patterns of and the other half roughly So in fact, in practice, when you're the highest most computers could count, using an int, would That is 2,147,483,647. But the flip side of that using different patterns of bits, as negative 2 billion, give or take. But the implication then, of have a finite number of bits and can we're going to run out In other words, we encounter what's where you want to use more And as a result, you What does this mean, Well, let's suppose that but I'm going to gray to convey where we'd like to put If this of course, is 0, this is 1, 2, 3, 4, 5, 6, 7. Now, ideally, in binary, if you want you're going to have to and that would ideally give 1000. But if you don't have four bits and your to have three bits, the implication is that you're but rather, 000. There's just no room to that I've grayed out here, which is to And as soon as you get to 7, is actually going to be 0, in my code, a negative value instead. So what could we do to perhaps Well, C does not have It also has longs, which, are just longer integers, which means So let me go back into my code here. I'll clear the terminal window. And let me go ahead and literally long here, long here. I'm going to have to change to be not get_int, but get_long. And that's indeed another function Let me change this get_int I'll keep my variable names the same, It turns out that printf also so not just %i for integers or %s %li for a long integer, as well as decimals. So with that said, let's go ahead and but %li. Now let me go ahead and do no apparent errors now-- ./calculator. And 2 plus 2 still equals 4 as before. But now if I do calculator again as well as 2 billion overflowed the size of an integer because the pattern was misinterpreted, instead. But a long, instead of using uses 64 bits, which means we to go when we add 2 And now, in fact, we get the which does fit inside Now, a long can count up quite high. And, in fact, it can count as And so that will give us But, of course, it too is So if you have numbers that you might still very Now, there's another problem And we can see it in the context Computers also suffer from where especially when you're doing math is numbers with decimals-- you might the value-- that is lose So in fact, let me go I'll clear my terminal window. And let's still use longs, division instead of addition here. So let me change this Let me go ahead and recompile the Let me go ahead and run ./calculator, like 1 for x and 3 for y. And we'll see that-- well, wait a minute. 1 divided by 3, I But in a floating-point value, with a little line over but, really, an infinite And yet, we seem to have lost even one because the answer is So why might that be? Well, if I know that two integers, is supposed to give me a with a decimal point, I can't in this case, longs, which do not So let me go ahead and change this which is, again, going to represent a integer or even an integer. And let me go ahead further and define itself. So I'll give myself a variable And now rather than print x divided So now I'm operating in a because I proactively that by another such value, if needs to be stored in a floating-point Well, let me go down to my of calculator-- seems to and let's do 1 divided by 3 again. And still here, we see all zeros. So we do at least see a decimal point, to the %f and the float. But it seems that we've already So how do we actually Well, if you the dealing in a world that's going values with decimal need to use what's as typecasting-- that is convert one telling the compiler Now, how do I do this? Well, let's go back to my code here. And if the issue fundamentally treating x and y as longs with no decimal point-- therefore has no room, so to speak, why don't I proactively do this? Let me, using a slightly specify that I want to convert x Let me specify proactively that I want as well. And now let me go should be the result of dividing not but rather, a float by a float. Let me clear my terminal window, seems to work OK-- ./calculator. And now 1, 3, and hopefully that my code has outputted 0.333333. And I think if we kept showing more we'd theoretically see as many But there is still one more catch. And especially when we're in this way in a computer using another challenge we might run overflow, besides truncation-- is this Just as we can't represent as big or long alone because there there's similarly going to be a bound And indeed, let's go I'll clear my terminal window yet again. And this time, let me use some slightly don't want to see the default number which %f gives us automatically. Let's go ahead and show me 20 decimal And the weird syntax for but %.20 to indicate to see not the default after, Let me rerun make calculator. Let me do ./calculator again. And let's do 1, let's do 3. And now this is even weirder, right? From grade school, you presumably is, of course, 1/3. But that should be 0.33333, with a little line over it. But the computer is doing It's a whole bunch of 3's Well, what's really well, again, is this issue of If you only have a finite a finite amount of memory, be so precise intuitively. Equivalently, the computer of representing floating-point values. But the catch is, per an infinite number of numbers of floating-point values because you can want. So the computer, given the way it's values, is essentially giving us the Now, how can we go about Well, there is one alternative. Instead of using float, called a double, which, uses twice as many bits as a float. So instead of 32 And that's just like the difference which gave us more bits. But in this case, this will Let's go ahead and cast x to a double. Let's cast y to a double. And now let's go ahead and, %.20f is still OK for doubles. Let me do make calculator. Let me do ./calculator. And now let me do 1 divided by 3. And we still have some And it's even more of it if we But now we have more threes So it's at least more, and more, and But it's at least more precise. So these kinds of to be necessary to keep do something numerically, with a language C where against these real-world limitations Now, later in the semester, we'll And that's actually going to solve for us by just automatically so to speak, as we need But even the issue of floating-point Now, just how real-world Well, back in the year of this when the world realized in that it might not have been the and software therein by storing Like, instead of storing 1999 a lot of computers, for were in the habit of cutting two digits to keep track of the year. The problem with that is that if systems to support the year 2000, 2001, and with integer overflow, add 1 to the year in their memory, '99. It should be the year using two digits to might mistake the year-- as some for the year 1900 a big step backwards, if you will. Now, you'd like to is behind us, especially all the more about the But we're actually going to run up again in just a few years. On January 19 in the year 2038, we will right now to keep track of time. It turns out, years ago, humans to keep track of how many They chose a somewhat January 1, 1970-- And they just started counting And so if a computer stores that tells the computer passed since that particular Unfortunately, using a seen, you can only count you overflow the size of that variable. And so potentially, if we don't get as computer scientists, on that bit might flip over, thereby bringing us back computationally So this is to say now, with all of comes a responsibility to Next week, we'll peel But for now, this was week 1, and [APPLAUSE] [MUSIC PLAYING]