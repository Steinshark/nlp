Hello and welcome to mCoding where And your download speed. But mostly your imagination. In this episode, we're talking including the yield keyword, And how all You define a generator function in using the def keyword and they The only thing different that is the presence of one of these Generators act like normal functions. Except Every time you pause you in this case, &quot;hello&quot; that Unlike with functions, calling Instead printing out the generator, The way you actually run a which is what the next It will run the generator And return the value at With every next call, it resumes the or until the function ends. If you resume the generator and the you'll get a stop iteration Returning a value from But it doesn't appear as the The return value of the as an attribute on the stop This is mainly for a very niche purpose While Ariana Grande might prefer to thank you in Python, it's more common to This works because under the hood a for-loop will until it finds a stop iteration Check out my video on what if you haven't seen it already. In any case, here we see the items printed out hello world123. So what are generators good for? The most common use case for a For a simple example, Just pretend you don't know And you're building In the spirit of being lazy our ranges are all going to We don't support start or step. So just like the built-in range which range of 5 is the numbers 0, 1, 2, 3, 4. But when we create the Range, we don't We just store the start on the stop. But if all we have is a how do we iterate over the elements of The answer is the highly Start at the starting value. And then continually yield the We can now iterate over our Range just the same And just like the built-in range because we're not all the numbers in between, we There's no way a list of numbers from 0 all Yet we can construct the Range And to reiterate it's this laziness where until we ask to see them So, while generators can be slightly slower if you're just processing them like here we're then a generator can be And here's a little history for you. The built-in range in Python 2 actually That turned out to be And for Python 3, it was changed to be It's not actually using a generator. But it's the same idea. Another very common and useful place that Once again, this is a situation where you might not want to read If you can process things line then even if the file is gigabytes big, You'll only need as much memory So for example, I have In this case, it's just xyz points. My file just looks like this. I just have floating point I don't know what's up with pycharm thinks I have a Feel free to free associate about In any case, we define a generator What I mean by that is, the file In a very generator like fashion, We strip off the trailing new line and Then we convert everything to floats. Create one of our custom data And then we just print out the rows. Of course, you The next very common use case for generators is You can loop over them So you can think about those as whether it be a mathematical sequence like in this And you just don't compute the next So, here's a `collatz` sequence. Take a positive integer n. If it's even, divided by 2. Otherwise, multiply by 3 and add 1. Then repeat. If you ever got to 1 then the sequence it would start to go 1, 4, 2, 1, 4, 2 and so on. As of 2022, it's one of the world's Starting at any number do Or could there be a sequence Or maybe some other cycle Well I'm here to announce that to be independent of Just kidding. Anyway, here's what a It does some unpredictable stuff. And then eventually, you hit This showcases another very Imagine, if instead of a Well, besides the fact that this because we don't know what if I didn't care about For instance, what if I just If you're wondering, it's 111 elements. But if I return to list in this case, Why allocate all that memory and If I wanted to be more efficient, I'd that calculates the But that length function would be Just instead of appending into a list, if only there was a way to have one that I can do whatever I want with. Once again, generators to the rescue. If I want the length of the sequence, then Once again, we see 111. And if I did actually want the whole list of Generators can even be used to represent We can only ever use finitely But we're able to compute as many So, you could represent all the powers of two all the or all the prime numbers. All you need is an algorithm Defining a generator is as simple as But you can go even simpler This is a list comprehension which And it creates a list whose elements are Replace those brackets with parentheses. This is really just shorthand notation Meaning this code and the elements until you try to actually iterate And once again this can be which creates all the If you happen to be immediately passing you can also do it this way. This creates a generator just And passes it to the sum function. Basically, it just lets you leave And now that we know about another great feature of generators is You can build pipelines of data Suppose, you want to be It has data in it that you want But you also want to allow nans, infinities and blank lines. No need to write a fancy parser. Generators are plenty expressive We start by opening the file and Remember each row is Strip off the new line. And remove anything after a hash in Then Define another generator that All it does is filter out empty lines. Each lines should now contain So, we use float to convert it Then we do another filter operation to Then let's just pretend that And just for something to do, This was very simple to write and easy to read like a step-by-step instruction And once again all this happens lazily. We've completely defined our pipeline At this line in the code, we haven't Each next call inside the sum triggers That triggers this generator to compute which triggers this generator until it finds a finite one. Which triggers this one to compute Which triggers this one So, we're able to process And we don't even need more And now we get to the advanced A yield statement is not It's also an expression. And that's because generators are Generators are Just like a generator can yield Its caller can send a value And it's these sent values that So, here's how we read this. We have a worker generator. The worker has a collection Initially, we yield none because we Our caller is expected to send The idea being that we're using the arguments that If the caller passes some new tasks, Otherwise, we assume that So, if there's a task available, Evaluate the function with those which then gets yielded And here's how a caller would So, our worker is just going to convert We use the send method to send However, when we just create the The very first value that we send because the function is going There's no yield statement there. So, first we just send none to Just like a call to next, until yield or until the After the send none, So now, we'll send in three tasks: These are wrapped as single because we're processing them Now, if we call next three times, When use the next call, We can send in more values And that's part of the I can add tasks or evaluate I don't need to have everything And I don't need to compute And another thing you can do is, use the As you can see, the exception acts So, you could surround this in a try-except if you There's also the close method that except it throws a This exception gets special treatment. And it's basically a way for you to cancel So at this point, this should feel We're basically submitting tasks And then something drives And the worker decides how and when to actually call the Doesn't that sound I don't expect you to already know Don't worry, I've got But just the general idea of and continuing later when Well, it's no coincidence. As it happens, under the hood in Python, async So, once again, being lazy is The lazy machinery of generators is powerful And that's not even the because we still have one `yield from` `yield from` allows one generator In most cases, you could use it exactly like you And that's totally fine. Using `yield from` is going to And it's going to avoid However, that's not the intended And it's not why it was introduced Just think about it. Do you think they would really just to have a shortened for-loop. The true purpose of `yield from` in order to facilitate the Remember a caller can receive But they can also send values But what if a generator wants to take and pass them to a sub-generator. For instance, here's a quiet worker. It's another generator because it And all it does is it creates And then yield from allows the worker to pass And likewise whatever the worker If a task causes an error, And then creates a new worker This is of course very bad practice because the task queue of But we're throwing it out and creating In any case, the `yield from` is what allows It essentially acts as a pass-through. Taking whatever messages from our And taking whatever messages from That is the true purpose of `yield from`. The fact that you can use them to write one Oh yeah. And just like yield, it's the return value of That thing inside the stop iteration from This is its real purpose. So, there you have it. I hope you learned something. Let me know in the comments how If you really enjoy my channel, please do subscribe and consider As always, don't forget to slap that like See you next time.