Welcome back, friends. My name is Dan VMware, and today is an exciting day. This is a video I've been now, and it's finally here. This is my Spring Boot Crash Course. So I started with Spring? Spring does so many So we're going to talk about that today. Spring Boot that sits on top of spring? Why are there two different talk through that and then answer. the question, how do I get started with building web applications, that's what we're going to do here today, learn to get up and running with that. So we'll talk through what is Spring, what is Spring Blue. We'll talk to build here today. And we'll go through what you're going to some code. So there's a lot to do. What are we so here I am in one of my favorite tools, Excaladra. And this and talk through some of the things that the prerequisites. What do you need to take this Spring Boot with Java. We're using the Java programming intermediate experience with Java. Experience with Java build tools. Maven today, at least understanding what Maven is and what it Software. We're going to use Java 17 So you should have Java 17 installed. You need an IDEE or text editor for Java I'm going to be using Intelli Idea You can get a 30 -day free trial, or you Use Visual Studio Code, which is free. is free. So any of those will work fine. You need an API testing tool, something a very popular tool that's free. You can use curl from the command line or HTTP. I never know how to say that today, there is a built -in HTTP client, which totally required. There are, we're going to use H2 for an over to Postgres. And instead of installing a Postgres Compose to spin a container up really quickly. In effect, when we get back and use postgrass as well in our development We'll see when we get to that. Those are kind of the prerequisite. So if you fit that mold and you want to in the right place. So let's kind of slide over here, maybe into spring and spring boot here. The first thing we start with is a spring The spring framework is used. It's a pretty massive project that's used of applications. So we can build web applications connected to any data store. These are, traditionally an imperative style programming using reactive stack. So if you want some asynchronous, non something called Spring WebFlux. You can use Spring to production grade features with if you have these services that often change and you want service, you can do that with Spring. Spring Cloud any cloud, we've got you covered. And there's a Cloud that allow you to help, help allow you to build cloud is a big thing these days. And if you want to build functions, we Function, which is really great. It allows you to programming paradigm, but not for a specific platform. But if AWS Lambda or Azure, you can. But you get to keep that same move your serverless functions too. You can do things like event -driven integrate with Enterprise, React to data in real time. You can use it for batching. So I want to some offline processing of data at a time to suit you. that. And something I've been getting into build some command line interface, CLI applications, using the Spring, Spring, Spring, Shell is a really great project for this massive framework that allows you to applications. That's great. So what do we need Spring Boot for then? little bit further and says, okay, we're going to help you simplify a lot of different ways, but there are three kind Spring Boot starters, auto configuration, So in Spring Boot starters, when you want something in your palm .xm. So traditionally in the past, you would dependencies that your project needed. So you'd have to list them all out, list versions played right together. Now what you do is you list out a Starter Web. and Spring Boot Starter Web goes, oh, I web application. You need SpringC., you need some logging You need an embedded version of Tomcat might need. So that's Spring Boot Starters, kind of together and using the correct versions. Auto configuration is a way for us to starter web, if you're building a web database. So I'm going to connect to a database. source configuration configured for you. Why would you want to We know that you put a database driver on configure a data source configuration for you so you don't have defaults, but we also based on the type of application. you're building, we auto -configured some that configuration looks, but we're going to and that gets you half the way there. So instead of having it's already there. You're connected to a database. need to worry about to build out the requirements of your production ready. So we start with the actuator. The spring of Spring Boots production ready we have a bunch of endpoints that can give us some of the beans in our application? We'll learn more about beans application? Is it up and running? Is the connection to the database metrics, mappings, and so much more through Spring Boots actuator. In Spring observability. which is the combination of logging, The spring boot actuator kickstarts all And with some settings, you get a whole Finally, the ability to build something We have a bunch of different ways that wherever you're going to host your So if you want to create an executable Anywhere that has a JVM, this jar will go What about where we don't have a JBM? We could build a container using Docker BuildPacks to build an OCI -compliant Finally, in Spring Boot 3, we have this really, really exciting, some really cool So that's a little bit about Spring Boot. I want to talk about what we're building So we're going to build a traditional that makes a request to a Rest API. This is really what we're building here. We'll build a simple front end for one of we're just going to use a tool like some API. This RIST API that's built in spring, At first, we'll just start off with this because we haven't talked to a database build on those concepts. Then we'll move to a database. We'll use some different approaches to querying data from a database. So we'll and spring data, all of which are going to return JSON Of course, using Java. All of the project GitHub. You can find out more about it in the So we're building a content calendar. I I have a lot of content that I'm building calendar of things that I have built or this calendar. It's a very simple domain. It has a description. What is the status? It could be an idea. completed, or already published. What is the type? video, a course, or a conference talk. When was it updated? And what is the URL to it? So what we're not a seem pretty simplistic, but there's a lot this out. So we're going to start at start. Start .Spring .io, which is this really bootstrap a new Spring Boot application From there, we'll talk about should we go about selecting them, what if we need to create some later? We'll examine the project that gets those Spring Boot starters that we and diving into how our dependency the main application class, look at the annotation start our application. How do we start it from the command line? Finally, we'll get into how do we structure our rein on how to structure our code. What are some different Once we've done that, we're going to go into a whole bunch of Spring Corps. What are the core kind of fundamental concepts developing spring applications, things like inversion of control, the injection. These seem like terms when you first hear them, at all. They're very approachable. We're going to talk about how we build our MVC apps, our model view control. This is our web of the annotations that you see when you're building this out. We're out at CRUD Rest API. We're going to test to talk about cores. So when you're calling an API from something called cores that you need to think about. And comes in. Next, we'll move over to the data world. traditionally we use JDBC to connect to a database and query or get about how to configure a data source, how to populate JDBC templates, spring data, and production ready. So we've built our application out. We've production. We'll learn a few more kind of core configuration, how do we inject values using the at value configuration properties, what do profiles do, and when boot actuator that we just heard about a moving this into production. We're not just going to talk about it. but we're going to take this and actually move this to a sign up for an account for. It's going to be free. It's not one nice app called Railway that allows us to just get our most important part here is you're going to I want you to take what you've learned say that you're very interested in maybe starting your domain. Or maybe you want to create a place where you can are interesting to you, go ahead and take these concepts, apply some of the the real learning will come in, not only your own projects using the concepts that we will try and include this in the resources for this project. spring framework? What is spring boot? What are we today? So with that, what are we waiting for? Let's just jump a new spring boot project, you should head over to start .spring .io. This is the spring spring boot project. This is a website spring initializer is built in to a lot of the IDs and the using today is an IntelliJ. If you're on the community on the ultimate edition, it is. If you are in a clips, using something like Visual Studio code. It's built into there editor are using, you can always start here at start way to bootstrap an application. And the way that we do that application that we're going to build. So we've already gone build. We know what things that we might potentially need in this come over here. So the first thing we have to select is Grado or Maven? I'm going to go ahead and choose Maven. selecting, keeping Java as the selected Then you have to pick your version of time of this recording, the latest version If you're watching this in the future, Just take the current version. You should where we're on fourth, then we might have metadata. This is data that describes your project. is kind of the default package, right? So this is for me, that is Dan dev .com. Danvega because my personal ABCcompanney .com you could say com .abst company. The artifact is the thing that we're today is a content calendar. And then you can go ahead and describe So let's say content calendar And then we have our full package name The packaging is going to be JAR. The Java 17. then what we can do is we can start to dependencies, the way that I like to think about this is before I go shopping idea of what I need to get, right? I know what meals I'm making know kind of what ingredients I'm going to need. So I write go to the supermarket, I know what I need to get. We've already. We've kind of done that with our we're going to build today. We kind of know what we're going to be for the foreseeable future, for right now, we know this is really a Rest API. So what I'm going to do is go into my Spring Web. Now, if you go in there and look, there are all kinds of things. FQL or Spring Data or Oath 2 or anything list. This is really just a starting point. use a lot more than Spring MVC, but that's okay. We can always add start with this and then we'll go ahead and add some dependencies as we here, you can actually go in and explore. This is what your starting also share this if you want to share a similar project click generate. And what this is going to do is download a zip Now what you can do is open this up in your favorite ID or text Ultimate. So what I'm going to do is go ahead and say, show me unzip this. And that gives me a directory with all of go ahead and open this up in IntelliJ. So one way that I can do my IDE. And there goes, it opens up and it's ready to go. want to take a look at our palm .xml. If you're not familiar part of the maven build tool. When we .I .O and filled in that metadata, it kind of builds this file out, right? Boot, which is 3 .0 .2. Here's our group ID, our artifact, the then name and description. We're using Java 17. And then here in the dependent. that we are going to be using in this was web. So we got this dependency. And whenever we build a starter test to give us testing support Then there's the spring boot maven application via maven, build it, compile, We'll take a look at that in a second. So boot. starters. So if you haven't done a ton of I have, there was a time when you had to kind of libraries or classes that you would need in an a lib folder and hope to God everything worked. Those days are long and it allows us to say, hey, go ahead and pull this particular I'm using. And then you declare a version. You say, 2 .19 .2, right? Here we don't do that. We're just what a starter is is comprised of all of So if you remember back from the about being able to say, hey, I want this one thing. Go ahead and pull this starter is. We can command click into this here in starter is. And you'll see it's nothing more than in So the Spring Web includes the Spring Boot starter. If we were to dependencies. It also includes Jack JSON support. So that JSON support the Jackson data binding, the data types Jackson module here. So as we dive into these, we're going to Tomcat. So this is how we get our embedded There's Spring Web, so this is going to the WebMVC stuff is going to allow us to work with today. So just by declaring that one thing, this versions that all work well together and build a web application. So these starters are really, really The official Spring Boot starters start something else. So we'll see some more of those later. But as you can see here, Spring Boot that's an official starters. The other thing we want to talk about is here, there's a spring boot starter parent. If dependencies. If you look in here, there is a bunch of go to use something like the DB2, JDBC version, we have versions numbers associated with them. And this is when you go ahead and include them. We know that the things that are in this particular version of Spring started. If you need to override that and declare nothing stopping you from doing that. But this is just what we know less thing you have to worry about figuring out which versions So we're done with the palm. The next folder structure here and what is included. So if I go in IntelliJ idea. There's a dot maven folder. This is to have maven installed to be able to run this because of the maven wrapper. There is a source of that in a second. There's a Gitignore stuff already in it, which is really great. There's just a the palm .xml. So if we look at source, this is a normal and source test. So main is where our main code is going then we have that main package generated for us based on data that we filled in. So we have dev have this content calendar application. This name is a in here and just rename it. I'm just going to name this application. me. So now I have just this main application class. This is to have a mean class with a public static void main. main takes in some arguments. And what it does is it passes in this class as the class to run. So we say if we look at Run, this is a application context. Even though we aren't really returning about this when we get into application context and beans and so But this is the magic that makes it application. Now, this main application is annotated annotation. I don't want to go too far into this, but application or using Spring Framework, you're going to see a lot at first, but it is way better than the contrary, XML. So you have these huge blocks of XML. defining how your application works, Now we just have these annotations. So we just annotate a particular class or cool things. In this case, we are annotating this with And what this does is it does a whole more annotations that are on top of that annotation. So this is just a way to go through and other things that we're not going to get into right It doesn't really matter for this point. I just wanted to point that out that your the main at Spring Boot application annotation on And then you can always come down here wanted to. And we will do that at some point. But right now, this is enough. So now that we know what the kind of probably want to know how to run it. So there are a few. ways that we can run our application. The ID. So within our IDE, we have these little We can run the main application. We can here and click this play button to run it. We can also right click, you can go to debug or run application Intelog's profiler. So I'm going to go ahead and just click application. And as it starts up, you'll see some We got this awesome ask -y art here, So Spring Boot, and it displays the And then there'll just be some logging So this is logging by the system. You haven't done any logging yet. This is the system kind of logging some letting you know what's happening in your So we see that we have. are starting our application using Java We have no active profile set. So we're following back to a default We'll talk about profiles at some point And then we can see that Tomcat was So that is the default port as you'll everything in Spring Boot is Well, not everything, mostly everything. But we provide sensible defaults. Like we have defaults so that you don't configure everything to just get We provide some defaults, and you can So if you wanted to change the default So we start on 8080. That's using Tomcat. We are on the latest and greatest here, This is as of Spring Boot 3. We have moved to Jakarta EE10. So again, we'll talk more about that as So now that we could see the Apple, has started on 80 and this is how long it Now if I want to stop this, I'll just go our application is stopped. So how else can we run our application? If we go to a terminal, we can open up a Again, we are using this maven wrapper. So if we go maven wrapper, there are some commands that we can run So if we look at, In Intelli, there's this nice maven tool So we have different profiles, we have So we have a spring boot plugin. And these are all the commands that we So we could do things like build an So what I'm interested in is this spring So what I want to say is spring. boot colon run and it's going to do its running. This is the same application that started You can just see here in the terminal exactly how it was. Now if I want to stop it on Mac here I'm that process. So I'm going to go ahead and close that window. And I'm going to start it up one more And with it running, I'm going to head Host 80. And this is the default page that you're This application has no explicit mapping So you are seeing this as a fallback so We can see the error. There was an unexpected error type not status 404. So there is just nothing available at the So at the root context, there's nothing And that's true. We have not done anything yet in our So there is nothing available. So I just wanted to point that out you might think, well, something's not It's just because we haven't done And we can also do that via the command So we have different. So if you view it in a browser or you we see that as a different context, So we have this idea of context and we based on where you're coming from. So here I'm using a tool called HTTP. And so what I'm going to do here is just And as you can see, we are getting some So we see that it's a. a 404 error. So we're in the context of a back JSON. We're not going to send you to a the content type application JSON. Here's the response. You're getting an error. The path is this and that is not found. I just want to talk about structuring your code. So start writing your own code. So remember, this main package. The first kind of advice that I will give code within this particular package. You don't want to you create something in the Java folder, it will basically be And you don't want that. It's not going to find it. It's going to really hard to use here inside of our things a bit messy. So kind of tip number one is whenever you you create it underneath this package. You can create create a new package called controller. And you can so on. But this is the root package. Try and keep all of thing I want to talk about is kind of how nice thing here is that spring doesn't really care. This is up to everything inside of this main package and not, you know, whole bunch of classes in there if you wanted to. Probably not the it's it's going to be just the same. It'll work. So there are a could structure your application. So you could structure them. of demos where I'm structuring them by the for my controller. I might have a package for model. I might and repository and all that. And then no matter all the like a content. So when we get into this, type, a tag type, type. Those will all go in the controller and a status controller, et cetera. So that's how I'm course. But you could come in here and say, I want to kind of by the different resources in my system. So I may say, you like, I'm going to have a content and I'm And inside a user, all of the things are controller, the service, the repository, all of the things that particular package. So again, there are some pros and cons to somebody can come along and tell me otherwise. I don't think here, it doesn't really matter. So I think the thing to just take you how to structure your project, but the one thing you want main package. Okay, so with that, we know how to run going to go. Let's go ahead and talk about some of the fundamental core start writing some code. I think there's, we need to take concepts in spring. Now, we could talk about a lot of the fundamentals of Spring Boot, but I just want to cover a code. I don't want this to be too much theory. I want us to learn a code. So I'm over at spring .io. If you go under projects and learn, there is the reference stock. So let's go ahead and click on the 6 .0 .4 is the latest. That is GA. When you select Spring Boot 3 are pulling in whatever the current is, most of the time Spring Boot 3. So we go over to the documentation and I So we're going to talk about the Spring and beans. And again, we're going to spend a long time doing this, but I want to be more practical with this you can take the chance to go through this documentation, mainly the IOC container and what that means. And when it comes to in spring. And so these are two terms that you're going to hear that scare you off because you're like, what the heck is that? What And I want to take the chance to kind of go through there. the application context. To do so, I'm going to head back and on the Mac option command O. There's a way to get up here here. I'm going to type Command O here. I'm going to look for something called And we're looking for the one here in So if I go ahead and click on that and we can see that this is a interface and interfaces. So let's kind of scroll up here and take And this is a central interface to This is a read only. while the application is running, but may this. And then here are the different things of which is a bean factory. So we can think of kind of the application. I like to think of it as this bin. Let's say I had a bin in my the bin. Each of the books have titles on the side, but the bin is to store all of these books, right? So I bookshelf. And when I want to get a particular book, book on Spring Boot 3 in action, right? Give container or the IOC container or the application context is a them. And we can get them by name, we can get them by type, we can do the day, the container is just this bin that holds at any time, we can go ahead and ask that bin for a action. This application context extends a whole bunch of other the functionality that the application context has. So if we look at in this application context, we can do things like get the lot here at this level. But then if we go into something like the like find out all the beans in my application or get all of the So there's some more functionality here. And then as you go on there's a whole bunch of functionality that we can get out of So that's where I want to start. What is reason I bring that up, if we go back to this run method, actually returns application context.! Configurable application context extends looking at. So what that tells me is if I come back here a variable. So I could say here, here's right? I have this context that I could So one of the things I can do is remember names. So what is this? This is going to an array of strings and this is all the So hey, this is great. I can get all the And one thing that I might want to do stream. So we're going to use arrays dot stream. We're going to have all of the beans, at And then all we're going to do is say, for each. I want you to go ahead and print them. And again, this isn't something you'll want to kind of show this off so we can see what's going on here. So if see a whole bunch of things were printed to the council in our application. I say, Dan, I didn't, I didn't write going on in the background here? And that's exactly what they are. They're in the background. These are beans that the type of application that we are With one exception, there is one here application. So that is also a bean. So these are all the things that are Again, you won't need to do this. This is And I wanted to point that out because I hearing the word being. What is a being, Dan? So I want can't see you, but go ahead and raise your hand if class. Okay. I'm looking out virtually over the entire audience right hands. That's great. That most of us have done that, right? we're doing. We're creating instances of classes. A spring bean is nothing more than an configuration metadata around it. Things like what is the name? What is the And if you want to go back through the So now the question becomes, okay, this create our own beans then? How do we do So let's go ahead and. take this for a test run. Let's create a call this message. So if I go ahead and create this class a method in here. Maybe we have just a public string get Yeah, that's fine. And then we're going to So this class does nothing more than have get message, which returns hello world. application here and I look for something called message. here, but that's not the bean that I just class. Why isn't Spring adding this to this big container context? And that's because Spring needs to be that's because Spring needs to be told the classes that you want it to manage There are a couple different ways to do There is at a class level, we can use So the generic annotation that you'll see And if we go ahead and dig into this, annotated class is a component in such classes are detection when using annotation -based configuration and class path scanning, which we are using. the wild, you may see a bunch of old examples where don't do that anymore. We use annotations and Java -based what this is saying. This is saying, okay, if you add this to know about it. The application will know about it, the a its container. So let's go ahead and run you see there is a bean called message. Now the takes this class and uses camel casing. So it'll start with source, it would be lowercase M capital S, right? So that don't want to get too far under the weeds. There are ways to By default, this is a singleton. There'll only be one ways to kind of customize that. Again, look good just to kind of get this over review and then you can dig There are specialized versions of this, which we're going to one called a service. There is one for a rest controller, which on today, which is nothing more than a these specialized annotations, they are just end of the day, they're all components. So if you wanted wanted to use the specialized versions of these, handful of them. So that's it. So now I'm going to go I'm going to revert this because we anymore. And I just want to show you one other output all the bean names, which you probably don't want to, you can IntelliJidea Ultimate Edition, you can come down to our spring tab here. beans tab. So we can click on content on the application, and these are all the beans in this app. how it was configured. So if we go down to something like the simple cache configuration. And then the bean is coming from that dig into kind of the internals of what's happening here. But these out to a council, which you won't want to do, there is this these beans. Okay, so now there's one more instance. component, controller, service, repository. Those will all work at a have a class? What if you are creating an instance of a control over? Maybe you can't just slap an annotation Let's look at an example. So I'm going to call this config. And inside this config, I'm just going to So in here, in my web config, I may Templet. So Rest Templet is something that the client that you can used to say call out to a public API or And so what I want to do is create an would say return new rest template builder. Builder. That build and that will return a new method is the name at the end of the day will be the name of a beam? So we can't use that component. Like I So it's going to tell us that that we So we have a method level annotation and So the bean annotation, if we go ahead produces a bean to be managed by the Again, there's some really good You may want to dig into that. But that is the bean. The name of the bean is going to be the will be rest template. And if we go ahead and were to run this When you want to define a bean, you need So you need to mark this class with at and say, okay, I'm going to look for bean going to to go ahead and use that and put that in So if you were to run this again, look at You would now see an instance of rest And again, why this is important is of a rest template before we had our message class, for us. So we can just get an instance of it. And to show that off, let's go back to And let's say that we want to create a Let's do this again. Context. And what I could say is context. Get bean and get it by the name. So I might say arrest. Oh, whoops. I'm sorry. Rest template. And that is going to be, so it's going to We can go ahead and cast it to that. If we wanted to, say rest template. because we know that's what it is. And let's just go ahead and do that. And we'll run this. And you see that we just get that But then we can go ahead and use this if So one of the methods in a rest template So we could call a URL and get a. response type of type, whatever. So yeah, just an example of using bean. So at the at bean annotation is used when returns some class. So again, I think you can take some time go through some of this stuff. I wanted you to kind of get this high We'll write some code that will help kind it and then, you know, after this crash documentation and really go through and take a look at are. There's some really, really great It can just be a little inundated if you All right, so let's start writing some The first thing that we're going to focus application is kind of built around. As we talked about, this, the idea here calendar. So I'm going to start with content. And to do so, again, you can kind of your application. I'm creating a model package here. I'm going to create a class inside of Not just a class, I'm going to create a So we're going to create a record around So that is going to be our main type. Now when you define a record, you don't you define these components of a record. And as you can see, I'm getting really good at this. Let's go ahead and turn GitHub Copilot this. So I'm going to start with an ID. We are going to have a title. So what is the title of this piece of We're going to have a description to I want to have a status for the content. So this is going to be an enum. We'll go ahead and create this in a I also want a type. We'll call this content type. This is like, is this an article or a We'll create that in a second as well. That should just be an enum as well. And then I have a local date time for and a local dates time for when this So this could be null to begin with. Then we'll have a URL where this content So cool, that is pretty good. Then what we're going to need is a So in IntelliJ, I'm control clicking, We're going to create an enum for this So this is going to be, let's talk about So status, I want to start with an idea. So I have an idea. Then after it's an idea and maybe a work Then when it's done, I'll say it's And then after it's completed, it's now So those are some good statuses to start Next, I'll go ahead and create a type. This is also going to be an enum. And we will go ahead from here. And these could be, we could have a whole I'm going to start with article, video, course and then maybe a conference talk. Those are some good ones. We could expand on this later, but that's So there it is. That's our record. We have an ID title, description status, URL. We may add the something in the future So if we wanted to like tag this graph QL or whatever we're the topic. or categories that we're kind of talking But we'll revisit that later. So I think this is a good start. With our model in place, we can now start piece of piece of content in our system. All right. So with our content model in place, we So I'm going to, in a package called class. Now, the convention for this is the resource that we're working on. So controller. This is not a hard role. You do not have this in a lot of spring applications. So in this case, this is a class. That's what I'm going to stick with here. nothing special. It's just a class in the system right this with the at -rest controller annotation. So we've already that this is a specialized stereotype, which is really just saying, hey, I want to go ahead and I want you to pick this up and me and stick it in the application context. The next is request mapping. So request mapping is, hey, What is the path to this controller? How case, we'll just be API slash content. So now, what is a controller? A going to accept requests. So I'm accepting a request and I'm going the CRUD methods in here. So, hey, I want to list all the pieces of it's stored in memory or in a data. base. Hey, I want to find one particular update, delete, filter, sort, page, you around a particular domain like content So that's the first two kind of we're building out an NBC application. Now, before we go further in here, I want So we're going to create a new pack. in here. I'm going to call this going to create one called, let's create a Content Collection Repository. So I'm not because we're going to call that one repository. So this is not a Spring Data repository. going to mark with that repository because again, that that component. So now our spring application context And what we're using this for because just keep a collection of pieces of So that we can work with them in our So to do so, I'm going to create a call this. content and this is just going to be a initialize this array list here. We're going to have a couple methods. Let's just start with one to list all of that's just going to return content. Then we need a way to going to have this return an optional. So if you're not familiar with optionals value may or may not contain a non -nall So it's just a way to kind of not have to pointer exceptions. So there are methods around this to say If so, then I can go ahead and get the And so the reason I'm doing this is this. is this is what ultimately the spring I want to keep this kind of similar. So we're just going to say fine by ID, is this an integer? Because our content has an integer ID. So of content, we're asking for it by its ID. So I'm to get that list of content. I'll just I'll filter on that. And now I can say, hey, go ahead and give And I want you to see if it equals the ID If so, go ahead and find the first. And that returns an optional. So if we look at that, that will return Okay. So with that in place, now we can come about dependency injection. So we've learned a lot of the leave a link to a video that I've done on injection in spring. I don't want to go too far in this too long. So we'll just cover this very But let's say that we had a, actually, say we had a constructor here. And we need an instance of this content repository, right? We need that because to use it in our controller. When someone going to delegate to that content ahead and find me all the pieces of So one way you might do that is you might create private content content. repository and call this repository. And repository is equal to new content collection kind of take on how to accomplish this. But anytime you see the raise your eyebrows, right? Because we've talked about this which is responsible for managing all of the instances of our it's also called inversion of control. We are no longer our classes. We are putting that onus on the framework. The we no longer should be doing this. And we know, based marking it with an component, there should be an instance of So ultimately what I'm doing now is application when I only need one. So we want to get to inject any dependencies that this controller has dependency injection. So we are dependent on this class for our dependency. So there are ways to get this only going to mention the one because it's video that I'm going to link to if you So what we're going to do is make this an this content collect. repository and now we can say this dot repository. Now an easier way that I like Intel .J, we are going to make this final because to have to change that. We don't want to recreate it. This is a done. When you do that, IntelJ will put this you want me to add a constructor perimeter for you? Yes, I do. me. So now I have that constructor. This little icon over that we have a auto -wired bean being injected into this as saying at auto -wired on the constructor. At auto -wired is This is something I want injected. So But when you only have one public implicit. So you actually don't need it on It's the same thing. The framework will happening. So now I have an instance of the content an instance of the content collection So now I want to create something that all the pieces of content in the system, we write a method. We're going to write a eerily similar to that one we created you're at. where you're at. There you are. And we're going to call this one find Again, you can name this whatever you But how am I going to get all of the I'm going to use that repository that we And there's a method called find all. And I know because we just wrote it. That also returns a list of content. So I'm going to do that. So now I have my method. Now I need to make this available. to the outside somehow. So there is an annotation called request But there are also specialized versions One of which is Git mapping. So Git mapping says, I want to go ahead And what is the path? I'm going to leave this as an empty path. Because we've got a request mapping on class itself. So the path for this is That means once we start up the Local Host 80 slash API slash content, we should get system. So if we do that and we go to generate a If we look at that, everything is fine. we got a 200. We just got an empty array system yet, which is fine. We can go ahead and create a couple different ways. We could go ahead and do You can also use something called a post construct. So method that is not going to return anything. I'm going to call this a called after this, let's just double check with like after the post -construct annotation is used on our dependency injection is done to perform any initialization. So again, let's create a piece of content. So content C is equal to new content. So all of the information for this. So I may call this my first blog post. And I'm going to see if I this is going to get pretty long. So I have a title. I now same thing. My first blog post. Then I'm that this is an idea. The type is an article. updated yet. And the URL is just an empty string for content. So now what I can do is say on content. This is the list of content. I add that particular piece of content. So restart the application. We can see that in there. And again, I just assumed that we did. So let me go back to the browser. And remember, local host 80 is going to created anything there, but we did at API slash content. I'll show you the, , the HTTP client in Intel .J and in would have gotten this empty array. Now we have a with that in place, we have a way to kind of list all of the of content in the system. We really want create, read, update, delete. And we won't get to any other methods that need to be in this controller. So if you some like paging and sorting or whatever else you out the rest of that in the controller now. All right. So next and get a particular piece of content by its ID. So this time we're going to want to use an ID. So I might say, okay, at slash one, go ahead and get me the But this doesn't scale very well, right? Like we would Oops. And we'd have to do this like 27 content we had. So what Spring does is gives us the And we could say, okay, ID is there. I want to look for be dynamic. And then we can reference this in our an optional piece of content. And we'll call this fine by ID. And now And how are we going to map this thing to variable annotation is used for. So it's going to assign whatever's in the right. So now that we have that, we can go in return. Let's think about this. So if we just Find by ID and pass the ID. That may going to restart our application. We're going to go over to the browser. now we're going to say, give me one by its So if I do slash one, great. We get that This is great. So at this point, you'd going to go wrong. So like if I ask for something that is at So what we could do is say, we're not we're not actually getting that. or else throw. Let's throw a new status exception. So we're going to throw want to say that the status is not found. So that's message and say content not found. Okay. Um, this is complaining why. Uh, we provided was content. So I think this Find first. Right. So we're actually optional. Okay. That makes sense. So let's and check this out as well. And so now if can't find that one. And if we ask for So so far, so good. This is looking good. Now we need the ahead and say public void. We'll call this content. Right. Then what we can do is we can use our just call this save and we'll pass in our here. So we need to go ahead and create So here all we're going to do is we're Oops. So we don't want to call this Because our collection here, we should This is a terrible name, Dan. Let's call this content list, right? So now I can say content here. Call this content if I wanted to. And I like this to be last. Okay, so content list. Add this piece of So this is almost going to work, but we which is okay. We can create like an atomic integer here for now this should work okay. So now the question becomes, okay, well, right? When we're creating a new resource and a request. So the way that we handle this is by, so Git. So as you can imagine, we have a this post mapping. Now this can take in whatever the path we've already set that at the class level. So we can just do the same have, have an empty mapping here. So now this post mapping is going to slash content. Now, the only other thing here is we have Spring that this is going to be sent as right? So the way that we do that is by using And so if we dig into this and download annotation is going to indicate that a body of the web request. And so we'll see what that looks like in So now we can't really use the browser So we've done some initial testing. I'm using testing lightly and in air The testing is just, hey, let's make a But we've done that in a browser because We can't do a post request just by We need a tool for this. So there are some great ways to do this. You can do this from the command line favorite, HTTPIE, which is just a better version of curl things like this. There's a tool called Postman, which if I'm sure you've seen or used. I like that one as well. The one I kind of showed you already was And I really like that because I don't something. So I'm going to do that. So I'm going to go to, well, you could client, but I'm also going to show you a trick in your project. And I'm going to just call this Content dot HTTP. So anything that ends in dot HTTP will be that the HTTP client can use. So we've already seen we can do something where is this one? Let's just show what this one looked So let's copy these back to our one. So the triple pound sign here is find all content. I can say get content create a new, create new content. And so what we want to do is we want to right? So we want to do a post to this particular URL. Oops, to this URL. So how Well, the first thing that we need to do application slash JSON. And then down here, we can just is going to look like. So one trick I have here is let's just piece of content. And all I'm going to do is copy that now. And this is like. So I'm going to say this is my second blog post. is also an article. We'll just keep that same day created, to be blank. So if I do this, I'm going to go ahead take into account the new mapping that we have. I'm going to try slash API slash content that would create a new I have no response body because in fact, if you look at my going to return nothing for this. So the only way to kind of out all of our content, we should see that we have two in there. second. So this is great. But one thing I want to resource in a system, the caller who's making this request something was actually created. And to do so, we can use the response return an HTT. status HTTP status. Dot created. And that will create a 201. So now when we restart our application, that's all that loaded up. I'm going to go ahead and create that So at least we have some indication that All right. So we have our lists. We have update and a delete. So let's work on the pretty similar here. We're going to have a public void. We'll the request body of content, content. We are also need to figure out exactly update. So we may say integer ID. Let's just return null for a second. So actually, we don't even need to do here. So this should be an integer, Dan. And now we're going to use, so whenever we are not performing a post. We're performing a put. And so we also mapping. And again, this is going to be similar to dynamic ID. So we're going to say slash path variable to get that idea out of the first thing I want to do is make sure that that ID the repository, let's create a method called And we'll pass in the ID. So if it doesn't exist by ID, then we're We're just going to say, row, new found. And then we're not going to do this in We'll probably jump to this in more of a custom exception for this. Like my content not found exception. You can go ahead and do a search for And it's fairly, fairly trivial to do. So if you want to replace this later, you If we don't throw that exception, no, I'm That save method and pass in that So we've already created the save method. So I just want to create a method called And this is going to return a Boolean. So this is going to look. pretty similar to this, except we're not We are going to say, we can go ahead and And we can say, does that equal one? So if it does, it's going to return true. If it doesn't, it should return false. So let's go back here. That looks good. Sure. Let's go ahead and test this out. So I'm going to do something similar to And I'm going to say update existing So I'll pass in a one. We'll say that we are calling slash one. We'll just say my, let's just do this all We'll do the same. This is how we know it'll be kind of And then what I want is, oh yeah, that is create like an updated timestamp as well. I'll just pass this in here. This is all the same. And then maybe we have a URL now. We'll host 8080 slash some or my first Okay, so let's see. We are going to create a put. So we are sending a put request to Locos the ID of the one we are trying to update. So we'll test this out first and then throws that 404. We are sending some JSON. Here's the payload. This is the request body. The ID is one title description. Yep. Okay. This looks good. Let's go this. I don't think I did yet. And then I'll go I think that is good. Let's go ahead and just list out all of there we go. So we have, oh, nope, we've Oh, and I know why that is. Okay. So we've created a second one, but actually created one, which is good. The update part worked in our controller, write the logic to say, hey, if this in there, go ahead and just replace that If it doesn't, then go ahead. and add it. So we can go ahead and do the content. If it, yeah, so let's say, oh, actually, Yeah, so I probably would have created an update and a create, but to something. So there is a, if we look at content predicate. And so So basically we could just say, hey, if content. Dot ID, then go ahead and, oops, content. That ID, then go ahead and remove it. So we're just removing it and then we're Again, this is kind of arbitrary because collection in a real world application. We're going to move to a repository that But I just want to. wanted to put this in place so we can on to the database stuff. So let's go ahead and try that now. I'm application. I'm going to go ahead and put. So we're going to call content, we see there's only one in there now and information. So conversely, if we will go ahead and do this and we ID. Let's just go ahead and do this at 99 and And we do get a 404. All right. So we're getting there. Create, read, update. We just need a delete. Actually, I'm going to do one more thing We, I forgot about this. On the create, we use the response to say, hey, basically this is being I like the idea I'm going to put sending Like, yes, you got a 200, but I want to everything's okay. You just didn't get back anything because one. We don't need to. You already have all that info. So I'm going to use the at response content. So that will just give us back a And actually, I'm going to do the same So let's do that. And then we are going to public void So delete is just going to take in the to delete. And then we will say repository delete by Or we can just call it. delete for now. So we'll pass in the ID. variable. And again, if you've been following mapping is going to be. Yes, it is a delete mapping. And so assign it to this argument, and then we will call delete on here. Now So we will need to go ahead and delete So we'll just say our content list. That remove if. And again, we just did this up here. So this should look pretty similar to So c .d .0 .0 equals. And then we'll just say ID. Okay. So let's go ahead and restart And let's go back to our HTTP client. And all I'm going to do is copy this and we'll say this is a delete two. Let's create that second one and then So we'll need one in there now. Let's create that second one. Where's our post? So let's create that. Now we should have two. So we have two in here. So now let's should return no content. So, , did we?! 204? Good. Now if we go back to find all, So this is great. Um, that is all of our crud operations. We knock those out. And again, what I really file in here is in the repository. This is something You can take a look at it. And you can run your test straight, right to a separate application. So I'm a big fan of this. I'm a big fan kind of using an in -memory representation of all the move this over to a database soon. But or two other things here in the NBC world. All right. So I but to do so, I have to create a little bit of a front end, and one we can take a look at. I'm using Vite. VET is this really great create a bunch of different front ends in, whether it's React, whatever you're using. you can use VET4. So check out ViteJS This is a vanilla JS project. All it has .js. In main .j .js, I am fetching. I'm using local host 80 slash API slash content. That is that URL pieces of content in the system. When you get that back, turn we are returning JSON from our the council. Pretty simple. In here I can, I have a extension to basically run this application. Again, the browser. It goes to 5500 and I don't see anything. problem. This is a problem you're going to run into if you're kind API on the back So it says access to fetch at local host origin. So origin is local, basically local host Has been blocked by Corps policy. The no president on the requested resource. So ultimately what this is saying is this helping us security saying you have two different different ports or domains or both. I'm not going to allow our server side code, so in our spring boot application, we can the, these are the resources that I'm going to allow to talk let's go back to IntelJ, we're going to do this at the this as well that goes in depth into this on how you the method level and hey, what happens when spring security my YouTube channel for that. If I haven't mentioned that resources there. YouTube .com slash at Dan Vega. So what I cores. And so this is the cross origin define some different parameters in here. So let's look at the can have different origins. So a list of all the origins for So this could be like a specific domain and port. So in I think it was. You can get very specific on what headers So possibly star to allow all headers. Methods. So maybe I only want to allow Maybe I don't want to allow anyone to do And then you can have credentials and To keep this very simple, I'm just going annotation here, which by defaults, so if requests on specific handler classes, , it says the default values are applied apply permit default values. Um, so let's go ahead and do that. So I'm going to do that. Restart our application, go back to the application. And now you can see that the blog post, the one blog post that we have in our application. So that is now something that we could We could turn that into, like, say, an And then just write a normal front end pieces of content and display them or And this is, I do a lot of this in my Actually, I do it via GraphQL, but that's So just a simple front end example. talking to our API to bring up this idea If you're getting this error, that error cores error. That is something that you need to handle Okay. One final thing that I want to talk about validation. So we talked about building out our methods in here, right? Two of which are the ability to, , create a new resource, so create a new content. But what we haven't talked about is the someone, so whoever's calling our API, this format. If it's not, then our save method may not So at some point, we need to do some to us, right? We don't want to just blindly accept comes into us. So I'm going to go back to my palm, and adding a new dependency that we haven't thought about. That's okay. As you start to build out your I need this particular dependency or that one. How can I go ahead and add it? So right here in IntelliJ, I'm going to And the dependency that we need is the validation. So as we type validation, We, of course, want that from org, And then we don't need to provide the boot starter. All of that's kind of been figured out After you add a dependency, you've got to Maven. If you didn't do that when you came over something from that validation dependency, it would not work. So what I want to do on this record now valid piece of content. Okay, so the first thing is I don't want title. Like, why would you give me an empty You must have a title if we want to move So what we can do is use these validation So, this is coming from Jakarta. dot validation. dot constraints. And you'll see we have one called not So if we look at not empty, we can basically see that this must not So you can use not empty on say a string, a collection, a map, or an array if you So this is really nice. So you can say not empty. You can also use blank. So hey, I'd, Not only do I want this to be empty, but It must have at least one non -white So I like that. Now again, here are the constraints. If we go ahead and look at them. And if we dig down into constraints, we Hey, I want to make sure that this is an Or there is a min or a max or a null or or present. You know, there are a whole of right out of the box if you want. So for me, not blank is good. I like that well. I may put the date created or the date updated as, you know, create this in the past or update this in the past. So those are put on as well. You can also create There are a whole bunch of things you can show you this tiny one just so you have an idea of constraint in place, if we just did nothing else, that we have a create here, we need to mark this with the at valid says, okay, we see that we're taking in content via the request body, but hey, not, we won't even go into this section of will automatically kick back and say, hey, this is a bad something that I want to work with. All right, so this is a our dot HTTP. Actually, I'm going to restart the application so my post, I'm going to go ahead and try to send a ahead and submit this request, you'll see that we validation is work. You could start to stack validation. So had another class and say like a list of tags, for earlier, you can go ahead and validate that on the content class to of tags. or that inside of that tag, you know, all as well. So you can do a lot with validation. It forget that you need to add the Spring Boot starter validation to go the heart of any application is the data that drives it. a data source, reading and persisting a little bit verbose and complex. While on the other hand, Spring Boot and process and simplifies each step of it so you can focus on Spring Boot integrates with a number of I want to start this discussion by taking What I want to look at is an example that stands for Java database, connect, activity to connect to a database in Java So here we are in an example application. I don't have this up for you. Just kind of follow along and we'll talk So in here, I have a Docker file to go a Postgres database. And it also has some volumes here so it So once it does this, now we can get into application. Our Java application is just need to talk about how we can connect to a This is a convention. This is a string that looks like, has starts with JDBC, colon, and then the database type, which in this we're connecting to the port, and then the database name. So all of these things together comprise Then there are different ways that we can right? One of the easier ones is to use a driver So that driver manager takes in the JDB the username and password for the And when you're doing this in Java, we're basically say, if anything happens, go ahead and throw So if we do have a connection, then we sure that that connection is valid. We can make sure that we connected to the So we say if the connection is valid or out and exit. Now that we have to be able to the a connection to a database, we need a way And we use this class called the prepared If we look at prepared statement, this is This has been around since Java 1 .1, And you could see if you look at this, implementations of prepared statement. In Postgres we have and PG prepared statement. So once you have that prepared statement, you can pass in something, you can pass So I'm saying, hey, go ahead and select And then what happens is you need to use and get back a result set. So again, the result set is an interface time, time, time. And as you can see, we have some So if you go down, we have things like in And there are some other implementations So once you have a result set, now you value, while there's a next row, let's go ahead right? Out of that result set. So I'm going to, for each row, say, give title, the way that you do that is you you're working with, you say, okay, get me a string, get me an get a little bit quirky when you start working with times, you know, the things that are kind of out of the buoyant, float, et cetera. Once you do that, I So I'm not going to run this, but there are a lot of things that of when you're working with databases. connection in more of a traditional web application like the one create a connection for every request that comes connection pool. We have these different pool of makes a request, we just kind of use that connection and that type of connection is set up a little bit to get out here is, again, this is a making a simple select statement here. You can imagine as operations from a database, this is going to get a lot more simplify our lives when it comes to not only connecting to a to make that connection and how to get a connection pool and scenes. And then it's also going to help us with kind of giving where we're kind of doing this low level the database. So that's what we're going to look at in at a couple things and talk about some different abstraction from there. And again, we're going to replace our in of content. with something that is now stored in the Okay, so the first thing I want to talk provides a starter that gives us database may connect and query a database. To get started, we would head over to dependencies, you can select JDBC API. Now, it's important to you've heard the word spring data before. cover that a little bit later. I'm giving you these abstraction layers choose which one fits into your So the JDBC API will define some things core functionality out of the box. We'll also need a database. One option is And this is a fast in -memory database that What's nice is it's very small, it's very council application that you can kind of look at the contents So we wouldn't generate a new application that if you're starting a new one, that's what you would didn't choose maven let's choose maven we can also dependencies that I need. So I'm going to go ahead and grab this and head back to our application, our And here I'm going to just copy these So we have spring boot starter jdbc and So I'm going to go ahead and refresh dependencies back. All right. So I'm and open up application properties. Remember, this is where we application. I want to enable one thing. There is the H2 we don't, we don't want to just expose this view into your database specifically enable this. So we're going to go ahead and enable us. enable a database council. With that, I'm going to go ahead take a look at what's going on here. So there's a lot has started on 8080. And now you can see down here, Hikari were talking about before. We've added a connection pool for Jdbc we know what this this J2 URL looks like. It's an H2 and file -based database as well. And then the name of the user is S -A. So it says it's completed starting up and oh, the H2 And this is the particular database that you can check try this. Let's go back to the browser. have our error page. But now if we go to slash H2 that has some settings. So what are we logging into? paste in that JDBC URL that we saw before, the username connection and we can go ahead and connect to it. tables. Now, we don't have any tables because we can run select, you know, you can run queries. So if I could do that if I had something set up. What I want to point connect to this database. You saw how much trouble that we had to application to connect to a Well, we don't have to do that. This goes when we started this crash course, which One of the things it does is auto are using spring boot starter, Jdbc, and So it put these two together. There's configuration class behind the scene that well, if you have this JDBC stuff and you data source connection created for you. Of course, if you need you can or override it, sure. But out of the box, you've done nothing and you have this connection to a database, trivial things that you as a developer don't want to really deal requirements of your application, and with the database in place, I am going to change a couple properties. and that's okay for a test, but I don't want to do that unique name equals false, and I'm actually going to set a this content. So now if I go ahead and restart this application. You now content is starting. So JDBC H2M, the database name is now and reload this, instead of all of this, it's just going connect to it. Same thing. No actual tables yet because gotten to that yet. Now, at this point, I said it before. I hear it in the comments all the time. database. This isn't a real database. I'm using quotations in to a real database. So I'm going to show you quickly that of revert back to the H2 because it's great for prototyping and Docker. to stand up like this new Postgres that you bring down. So I like it for kind of portability and that works out great. But what if I want to connect to a real here. Again, I don't want to go through the local machine and connect to it and make I'm going to use Docker to basically spin So let's say 3 .8 and then we want to So services DB, we'll call this DB. This DB is going to have an image of Postgres is called Alpine. Yeah. So we're going to use like a lightweight We'll set the ports. So we're going to map ports, which is 5, 4, 3, 2, 254, 3, 2. That looks good. Environment. Oops, environment. We will set Postgres username. And again, I'm just pulling this from the So you can find those in there. Postgres password is password. And what are we complaining Sorry. Okay. So that's it. That's my start this up and run this, let's see if it starts. It looks like it's is up and ready for connections. So in my to comment this out. Oh, actually, we're So I'm going to comment out the H2 for So let's say that. We're going to need a Postgres database Again, you can grab this. If you select it from start .spring .aO, what I'm going to use. So let's reload this and go back to our is to do. So I'm going to set a data source URL. So again, the URL is going to need to be Jdbc, Postgres, SQL. And this is going to be Local Host, 5 ,4, And the name of the database, since we be Postgres. So we're going to set a username. This was Postgres and a password of So let's go ahead and restart And that's all there is to it. You know, if we have, we're going to get And once you have some data, then you can correctly. But for now, just kind of take it out my database. And if we had some data in there, we can So again, you can use this going forward installed and you want to run a real For prototyping, though, this H2 database I really like it. So if you want to stick with me, go ahead quote -unquote real database later. So I'm going to go ahead and refresh And now we can move on to how do we Now that we have a connection to our We need to populate it. We need to create some tap. We can insert some data. And there are a We could use a ddl script. So a schema structure and a SQL script to insert the various rows into Number two, programmatically, we could into our database. And number three, a database migration as we are creating databases and making deleting rows, we can use something like a flyway, which changes to a database scriptable. So we can kind of commit those to get, if So we're not going to look at the third and programmatically as we start to move throughout this So let's talk about the. first one, which is that DDL script. Let source, main resources, and application dot in there. Now what I want to do is talk about two change, but I just want you to know that they are .SQL, there's an init mode. So a nip mode by default, when an embedded one, in memory one, is going This means that it's going to look for a ahead and execute so that we have this schema that can get If you are not using H2, if you're using you would need to set this to always database, this is not going to act in this mode. So let me keep that up for a second. The other is spring .seql .net schema So by default, we are going to look in schema. SQL. If you wanted to change that, you So we can come in here and set a bunch of populated from. So I just wanted to point those out. We're not actually going to set those We're using an embedded database and here. And this is going to be schema .seq. All right. So I'm going to pace in some SQL. I don't think we need to watch me type This is basically the structure of the So we have an ID that's going to be an We have a title, description, status, URL, the primary key is going to be the So, That is our table structure. So all that we've done there is added SQL. We've added the structure for our table. If we go ahead and run our main we don't see anything else here in the So we're not quite sure if anything We don't know did anything like take So for that, I'm going to go over to my that properties once again. And I'm going to set logger. level for a specific logger. So I'm going to say org. That spring framework .jdbc. And we're going to set this to debug. So we haven't really talked about logging I'm not sure how far we're going to go but this property is just setting this to this specific log level. There are different levels of logging, and the default is not to output this So you have to have to. to be specific on what you want to output So we're just changing it for everything So if we go ahead and run this again, I'm and it's going to tell us some things that happened. So we see we have a JDBC connection, and from, we see that schema .seql, zero So I went ahead and created that table. and we see the executed SQL script from So now if we go back to the browser and test and log in, now we see our table. So There were no actual rows in here, so So back in our schema file, I'm going to So back in our schema file, I can just do an insert. So I'm basically to insert into, and we're going to have title, description, title, description, status, content type, and date created, into data updated or URL. So what we're going to insert into there And this is is The content type is going to be article current timestamp. So let's see if that works. Let's go application. Look in our council. We did do an insert. So let's go back to And connect. And now if we look at select all we see our row in here. So ahead and manipulate the data in the database that In this case, we need some schema to be So if it does not exist, I'm creating a Again, the H2 is going to get wiped the out every time. So every time I start this application getting run. And then, yeah, it's not just for schema. as well. Or we could just do this here and then if we wanted to. We're going to have to come back to the have a way to talk to the database. We've looked at how to connect to the insert, to read, to delete? How can we use some code? code, some Java code in our Spring And that's what we'll take a look at now. All right. So when we're at start .Spring H2 database that we ultimately ended up putting into our in, what we get are Springs JDBC template and These classes are auto -configured for So they're automatically in that means we can ask for them as dependencies So what are the JDBC template and named So if we look at here and we go down, we So we have a JDBC template here. This is package. It simplifies as a use. of JDBC and helps you to avoid common So this is our first level of abstraction working with in, say, Java to get information in and If you look through here, there are a ton methods, meaning they have different parameters Because there are a ton of different things you may want to do with the JDBC But this is essentially one class that get a list of things back. And so this makes it much easier to do the database. Now there is a difference. If you looked, there's a named parameter This is a This is the same thing, but when you're template, you use these placeholders, these As this says, instead of using question named parameters. So you could say instead of question then provide a name later on. So you can use either. them. The API is identical. Again, it's parameters, whether you want to use a question mark working with today. That's the first level of abstraction. class in here. So in my repository, we have this content with a new Java class. And let's call this Content, Jdbc, And actually, let's be specific, JDBC again, we're not going to be using these. I'm just kind of using these as examples of abstraction. If you're going to go with the JDBC repository and be done with it. So what I wanted to talk about before is path, we're automatically getting that So we don't need to like figure out how construct one. It's already been created template, JDBC template. And now IntelliJ is going to say, oh, you So we now know after going through this ourselves that this is repository is dependent on the JDBC template to work. I need this. I can't do automatically auto -wire one in for us. So now we have a JDBC template Okay. So now we need a bunch of methods we would need to do for our crud operations of, you know, and persist them. I'm going to paste some things in here we could talk to this code for probably 30 to 40 minutes I just want to talk about what you can do all content. So I create a SQL string that says, hey, From the JDBC template now, we can now say, go ahead and query the SQL I just gave you. And then we're going repository. Map row. And is that right? This is a list of content. So now we can just say, here's the query. a, , let's look, a row mapper of type T. mapper is really, just how do I translate that particular each row? How do I translate that into an object content object. So this row mapper will go through and do Java side when we're getting that result set and description status, and we do all the things that we need to So this is going to be pretty much the you know, for creating, for updating, for is, we've got to change this one to content, But again, if you like to write SQL and being written, this is a great start. This is the abstraction on top of the So now what you can do. is if you wanted to use this, and I think What is this one? Status string, content type string. Oh yeah, it's probably because those are Okay, but I'll go through and fix this This is the JDBC template. So now what you want to do is if you controller. and say instead of using that in -memory something like private, final, content, JDBC template Right? And now you just have to adjust these template code looks like. Again, not going to do that here. We're going to focus in on the spring I just wanted to show this as an option you get an instance of this JDBC template And now if you just want to start off by everything and not having some of the don't have control over or that you don't it, this is a great start. Again, this is kind of level one So I'll leave this code in here. I'll fix look at Spring Data. Okay, so the JDBC template was really still a lot of SQL that we got to write So we're going to talk about Spring Data. familiar and consistent spring -based still retaining the special traits of the Here we are on spring .io. If we head over to projects and we go to that I just read to you right here under And it lists out a lot of the powerful Things like a powerful repository and We'll see that in action. You get some awesome dynamic query Being able to have the. the implementation for the domain -based things like auditing, custom repository So again, we get some out -of -the -box So if you're using MySQL, Postgres, good. If you're using Redis or MongoDB or So Spring Data is broken down into So we have these main modules, like the underlying spring data module. There are things like Spring Data, JDBC, favorite, which will talk about one of There are things for working with like And then there are a whole bunch of ones So if you're working with, say, Couchbase or YugabyteDB. So all of these are community modules So then you really have to ask yourself, with? What are you trying to do? And then kind of go from there. So I think by far the most popular one is JPA is the Java persistence API. And underneath the hood, by default, So this is an ORM. or an object relational mapper. And this is really great if you have If you knew ORMs, there's a little bit of You got to kind of learn how to map works underneath the hood, because that's important when you're So JPA is great, but there's a little bit Another one I really love is Spring Data You get a lot of the benefits of using spring data without the overhead of, say, So I'm a big fan of that. So I think we're going to use this today, popular one out there. So go ahead and check that out if you If you're over at Spring Initializer and saw the JDBC API. But if you type Spring Data, you'll see are available. So things like Spring Data JPA, R2DBC, if of relational databases. And then my favorite spring data, JDBC. So we're going to go ahead and choose And then you're going to pick a database, Again, we're not going to generate a I'm just going to go ahead and look at And we're in Grado again. And if we dive into here, we can see that spring boot starter data JDBC. So I'm going to head back to my Intelli, I'm going to open up my palm I'm going to keep my H2 database. I'm going to get rid of this and now just Palm. And now I should get everything that I So I talked about Spring Data JDBC being Well, why is that? What is it? So if we dive into that, you can learn project. if you want. You can go into the Learn docs or the API docs, the reference docs, do a really of the things we're going to go through here today. talked about, I could probably spend an hour or two just on to. I'm going to try and keep this concise. I do have another Data, JDBC, and a little bit more in depth into some today. So Spring Data JDBC aims at being In order to achieve this, it doesn't do a JPA does, like caching, lazy loading, right behind, JPA. This makes Spring Data JDBC simple, All right? And it all starts with this idea of an So I'm not going to go into this. Again, watch the other video, go through that, and we should be okay. So back in our application, I want to of all starts with the model, this idea of domain -driven design. Before we jump in here, I want to talk You'll hear different terms like DTO, And I want to give a very very terms. a big shout out to Greg Turnquist, who I book Learning Spring Boot 3. So if you haven't that out. I'll leave a link in the description for whose purpose it is to transfer data, usually from the server the other hand, is a class whose purpose is to store and a class that doesn't extend any of the framework baked into it. So if we're looking at this content content record now is going to be to store So this is an entity. And as such, there this record about. We need to like say, hey, this is an to know about. what is it what's the difference between Well, in the case of this particular properties that we're working with here in kind of deal with on the client server Like when I create a new piece of If I wanted to create a DTO that just It was, you know, blank content was the You know, I could maybe make the of the data for that request. So I'd create a new DTO based on this to worried about. I hope that makes sense. If it doesn't, please let me know in the ahead and answer that for you. So this is an entity. We need to tell Spring Data. at JDBC that this ID right here is an ID And the way that we do that and we say at Datatation .ID. And if we look at the sources, not much This is an identifier, right? So that's all we need to do there. Now, we could do some other things. We could come up here. mark this with at table and we could say So we could say that the value is my, and the table name was content, right? We could do that if we wanted to. I'm not going to. You can also come in here and say this is And inside of column. you could say that the particular column I don't know. Whatever you want to customize this So that is the at column annotation. Those are really the only three I'm particular project. But right now, all I need is this ID manage. And I want you to go ahead and manage. that manages for me. And this is the identifier of this. So with that in place, we can create some We've created these repositories before, very, these were classes that we had to We had to make all of the code to create and save and update and delete and list. find one. We had to do that for all of have to do that anymore thanks to spring data. So what I'm going a new Java class. I'm going to call this one just content to be an interface. Say, what, an interface? How are we going way that we're going to do that is we're going to extend one of the few. There is, one called a repository. And if we look here. So this just says, hey, this is a our own methods in here. There is one called a crud repository. functionality out of the box. In the latest version of Spring Data repository. And this is the one we're Once you have a list credit repository, What type am I managing? This is content. What is this type's ID? That is an Right? So once you have this in place, write. If we look at this list, cred repository, the credit repository returns iterables. And we're not used to working with So when I call find all, give me a list But the CRUD repository contains the rest saving, deleting, delete by ID, find by So just by extending this, what happens repository marker here because this is an And what happens is at runtime, Spring base repositories and basically turn. this into an implementation. So now you working with called content repository that has all of use this? So let's go back to our content collection repository, let's replace this with just this called repository. Now we're going to have to change this up a little. Let's say good. This looks okay. This looks okay. This change we may have here is delete by ID. Okay. So now I did this collection repository to look similar to we can just flip over. But again, we have repository. So when you start, you could That's going to get all of the methods, right? So this is your crud operations up running. Now let's see if this application. And I'm going to go over to now we don't we're not going to have any, we're not because, remember when we added one, we collection repository. So let's back up a want to talk about programmatically have one, right? We do this schema. It does have one. Let's scratch that and list out content. And we do. So that is in the database. And most of our content controller should work. I do want to talk though. Let's go ahead and take this out. in, but just comment out in case you want But now if we were to rerun this, we'd So how can we do that? Well, we can come really any configuration class. Let's Let's do it the long way so it makes way. So I'm going to create a new, and actually this really create a new Java class and we'll call this a data loader, called the command line runner. And if we look at interface used to indicate that a bean should be run when it's contained multiple command line runners. The important part dependency injection happens as the application has started some type of, you know, bootstrapping or data loading. we're going to implement that. And if you're paying attention, this is marked with that functional interface. So we'll talk about could create a class and hello and wave. I'm going to run my application, rerun my to work yet. So this isn't going to work because we spring doesn't know that this is a class that it should controller, now it's going to pick this up and then see our hello output it after everything to go. So this is one way to do it. Again, I'll leave this in here. I'll just Another way to do it is it's a functional So what we could do, remember if you want at component on a class. If you want to create an can mark it with at bean. So I'm going to mark this as at runner. The name of this method is called command line lambda expression. Now this particular run method takes a vargs of and here's our lambda expression or in wanted to say hello Dan right so let's go And there's hello Dan. So this is a great am trying to get to. So we can go ahead and into the database. Now, what we need to repository. We need this content repository because things like save a new piece of content. So how can we get this this is just an argument, right? So we can say content We'll call this repository and because spring is managing application context, it will see that when we create an on this and it will wire this in for us. So now what we can do is let's of replicate that. We can say content is equal to that. Let's just write something else so we I wrote a new thing on chat GPT earlier. Let's say all about chat GPT. And maybe this was a video. So now what we can do is we can use that that content, and we can save it to the database. So the only difference here is that we So we are not supplying that ID. This is actually going to be null, right? So with that, let's go ahead and try and And there we go. So if we run back to this and say lists of our content, we can see that we get So now we have the ability to the really nice interfaces that Spring provides us with the command So again, just a really nice way to kind All right, so there's one more thing I then we'll kind of move on from this section. But what we've looked at. looked at so far with the content great methods out of the box. We get these list methods. We get all these crud methods. You can see in here. We got a whole bunch of stuff out of the I don't like writing boilerplate, dumb, So awesome. Don't have to do that anymore. But what if we have something that we So let's say that we had a request from Hey, I want you to write a method that content that contain some keyword in their So find by title, right? And it's going to take in a keyword. So how are we going to do this? So first off, this is going to be a Git So we're going to respond to a Git So it's going to be at at Slip. slash API slash content slash maybe So that's the keyword. We're going to accept that as the path So how can we add something to the requirement? So if we go back to the content here, we can go ahead. Well, let's back up. There are kind of two ways that we can We can do it from the query name. So we can do it by query derivation, or by using a manually defined query. So let's talk about query derivation Let's say that I wanted to get a list of So what I want to do is I want to get all kind of criteria, right? I'm going to start typing here. And as I start typing, you can see that I content by, find by, find distinct by, all of these really great query So what we're going to do is we're going And then when this thing gets. implemented at runtime, it will turn what that will get sent to the database and we I want to find all by title. And now we can start to like figure out We could say like the title is this or I want to say where find all where the the title contains, and then you can So if I wanted to find all by title this year, and the status was not an idea, maybe it You can start to chain all of these I'm going to keep this simple and just whatever this keyword is. So again, this is not. an actual implementation. This is just an abstract method here. We're defining the signature. It will get turned into the bits that for us to actually work at runtime. So let's go ahead and go back to our and say return repository. Findall by Title contains and then our So let's see if that works. Let's go to run our application and let's go to the browser all the content we have one in here we have a keyword let's say gpt and you can see that's not found so like data and as you can see we really great way to quickly add some new queries to your repository. Now this is one way. Okay, so I want to get a list of content status. And so we'll take in an argument of And instead of doing the query derivation I'm going to use the at query annotation. Because I'm on Java 17, I can now use text blocks and I'm going to say select we go back to our schema I just want to remember this where where status is equal to And then we need a way to say the status So we can use a name parameter here and And then we go ahead and use the app So now we're actually writing out our own So let's go back to the content We'll call this a get mapping. We'll say filter by status and then the and then we will get a list of content We'll say find by status. And then we'll use a path variable to Right. And then what I want to do is use the and pass in the status. Okay, so we're passing that. Let's go ahead and run this and see if So again, I have just that works. So I'm going to say a status of idea. So I'm going to say filter by status and then idea and we see that we Um, another status is in our completed So just a couple of different ways you here in a repository. You can use query derivation. There's a whole lot to learn about query can construct these queries. So check out the documentation. for that. And then you can use the query queries here if you want a little bit more control database. All right. You've learned a lot so far. I There's a lot to learn here, but you've learned a lot. And sticking with me through this. But the ultimate goal is not to local laptop, right? We want to get this out to the great to be able to show our moms and friends built, even though it's just returning JSON. So get prepared for the promised land of production, and more fundamental concepts. So what are we waiting for? Let's do it. configuration so that you can work with the same environments. You can use a variety of external configuration sources, files, environment, variables and command line arguments. So property sources here in a second, but I just want to talk seen this in action. If you open up source main resources and we've got to configure some things in here already, the data source name, and the logging level. So this is where our application. These are all the things that are built into whatever application. So for web example, there's a bunch of how the web application acts. Remember, this is, you know, Spring you, but always giving you the ability to one of those that we've already seen is the port, the starts on. And that is a setting. So if you go in .port, you can see that its default is We can always change that. So if we want Let's rerun our application. And if we that now we have started on port 8085. So now what I want to do is go over to boot docs, there's a section for externalized stuff that we just went through. We're going to get into this. Properties can, property values can be using the at value annotation. So we'll talk about that. Or we can use structured objects using annotation, which we'll talk to as well. But this is what I want you to pay particular property source order that is values. Later properties in this list can the values defined in earlier ones. So always come back to the docs because there's so many different override the other. And so if you ever have a question, a look. But what this is saying is anything later So if we had a config data such as then we go ahead and set an operating system environment variable, Properties. And this becomes very important when you So I may not want to, you know, expose a That's where I can expose a secret key as production environment. So there are a bunch of different ways. Again, the application not properties, whether it's dot properties or dot yamil, And then we also have variants of that. We'll talk about this in a minute when we different property files for different profiles. So we'll talk about that. So just understand that there's a pecking So here's our properties file. We've set 8085. So what I'm going to do is just doing a my run and go to edit configurations. So we're going to go to edit And in my application, I am going to set So let's say environment variable here. And I'm going to set server. That port equal to 8081. So this is different than the default This is different than the 8085 that is properties file. So if we go ahead and run this now, we Because, again, that property source therefore, that takes precedent. So that's just a little bit on sources. These, again, are important to note as So I'm going to go ahead and remove this, values. using your code using add value and All right. So to demonstrate this, I'm going to We're going to call this our home So let's say home controller. This is a class. We're going to mark this as a rest And we're going to have a single method for now. We'll call this home. We'll return hello world. And actually, let's just return hello an emoji in some code. Let's take it. So this is going to endpoint, that should call this. And if we go ahead the browser. And we get local host 8080 and we get our good. Now what if we wanted to get a value from into this controller. Um, well, first off, we might set up a We can call this string. We can call this And then we might want to return that message. So we'll say welcome message and great. If we do this, we have a null value right So we're not going to display anything. So what we can do is we can use the at let's go ahead and grab something from, that application dot properties or really Now that we understand kind of property So we're going to use something called that value. So we're going to, we can name this So I'm going to start this with CC for And we're going to say welcome message. Now we have not defined this yet. So what do you think is going to happen application. You're right, it's going to Could not resolve placeholder CC welcome So we could go to find that, but we also maybe somebody didn't define this in their app. So we can actually set a default value So I'm going to say default welcome And now if we go ahead and restart this, And if you went over here and refresh So so far, so good. Now, what if I do want to define this? If I go back to application. Properties and I say cc. whoops, welcome message is equal to, hello, what are we, let's say, welcome to Okay, so let's go ahead and use that. and refresh and there is our new message. So so far, so good. But what happens if we wanted to add some So let's come back here and what if we Like what is this, what is this all about? So maybe we had a string about. We could do something similar here. We could say, , c dot about and then we can pull that in. Now how do we display two things here? Well, at this point, we're not displaying Maybe we want to display some JSON data. So what I could say is I'm going to Okay, that's what I'm going to return. So how do I do that? I'm going to return map. Dot of and I'll say my first key is And that's welcome message. And that's welcome message. and then my second key is about and that So that looks good. We need an about in here. So let's go ahead and do this. Okay, so let's go ahead and refresh. Now, if I go back over here, now I'm and my welcome message, my about. Okay, so this works, but we, you notice that when we start typing this here, we don't can't I see what those properties are? I want, I want to be able here and to be able to get some intelligence here. Two, if we whatever we want in here. So a welcome message, I'm going to say I'm going to say that this is a list of And it doesn't really care. So it's going to go ahead and run this and, okay, we have those things. It didn't really do any kind of type Like these are strings. I would want the user to input some So how can we get around this? So let's go ahead and delete this. Let's go in here and and delete this. Let's say string for now. And I'm going to remove these. So anytime you have a single value, this But when I start having a collection of other and you maybe want some types around it, this is configuration properties. So I'm going to go into config here. I'm going to create a new Java class. And I'm going to call this content And this is just going to be a, actually We should probably make this a record Let's say record. And then the components of this record message string and the about. So all we're going to do to turn this use is we're going to mark this with at configuration prefix. So what is the prefix that someone types in for each of This is going to pop up in IntelliJ right configuration annotation processor is not configured. at the documentation, it'll tell you, hey, generating your own all you need to do is include this or Gradle. So to do that, I'm going to I'm going to include that dependency, okay. But we have one more thing that we need And that is in our application, we need So we need to say, actually I'll put it configuration properties. Which one, which classes do you want to Why only have one? I'm going to point to it, content, that class. Okay, so at this point, we should be Everything looks good. Now, once you do this, you got to run a So I'm going to run a build. Let's go ahead and build our project, and And if we look under classes and under we now see the spring configuration And as you'll see in here, we have some So we have some metadata. have. This is the kind of type where it's These are the two properties, the welcome So once this files in place, now I know and I type CC, I'm going to get some more help about So you could see that this is a string. This is a string. So now if I go ahead and type, and now I we said, welcome. Welcome to Dan's content calendar. And then we say cc. About. This is a collection of my content. Okay. So now we have that in place. Now we can come back over to the home And this is just a bean, right? Now the spring application context is So, as you can guess, we are going to say We'll call this properties. And Intel J is going to say, hey, you for that. I do, I do. We can change the type of this because, send this info back. So we can say that this is a And let's go ahead and return properties. Right. All right. So now, if we go ahead and restart Okay, everything's working still. Let's go back to Local Host 8080. And there we go.! We have our welcome message and our about. now we have them nicely packaged in this again, if we think of other things that to be. We want to add to this later. We can just add that here and everything So that's a little bit about injecting annotation and the configuration properties. All right. So we've talked about configuration. I want to move on to profiles. Spring profiles provide a way to configuration and make it available only in certain This is going to be really important environments. like production. So any component configuration or with app profile to limit when it's loaded. So let's take a look at an example of And to do so, I want to first start our may have seen in our council, but haven't really So here we get this nice askie art. This first line up here says we are using The second line says no act. profile set falling back to one default So by default, if you don't set an active called default. If you want to set an active profile, you profiles. And if you saw it real quick in the hint profile or a list of them. So I can either say devs, or local or maybe this is local and dev. We're just going to start with say dev. So now if we restart this, that is the If we look up here, we can see that our So we have this app profile annotation. Let's look at an example of where we So I have this data loader class. And again, we made a mistake on this We used that controller. We should have used ad component. I just got excited. So we have that component here. And if we run this, it will go ahead and And there's our hello output. But what if we only wanted this to run Let's say we did not want this to run in What we could do is add an app profile. And we could say what profile we want We could do, we could say, hey, I want in production. Or I don't want this to So you could do like matches or negative You can do a whole bunch of things when profile this should be used for. So here I'm saying don't run this in dev. So now if I run this again, we should not So that's cool. That allows us to kind of limit where So that's one example. I'm going to remove that. And let's take this off so this doesn't So we're still using profile as dev. The next thing I want to look at is So we have this application dot no matter what environment we are in. But what if we had environment or what if environment we're in? This is very possible. This is something that we're in. happen a lot, right? So I'm going to create a new file here now you can use whatever profile you are going to be in. So let's say we had a profile called So I'm going to say application dash Now these will always get loaded into the profile specific properties will only get loaded that particular profile. So let's take these two properties that the production. And let's just say this is production. And we'll say production about message. All right. So now we're still in dev. If we go ahead and run this, we should be state 80 and see our original ones. So let's go ahead and change this active profile. And to. Spring. Dot profiles .active or let's override know how these things work now. So spring. Dot profiles. .active is going to be equal to So let's hit apply. Okay. Rerun this. And if we go back over here, we refresh properties from our production So this is really cool. I like the slot. Profiles allow us to do some really cool One of which I could see an example of, have this data source for, for our our local development, right? Maybe when that Postgres, that real database, right? So production properties and define our Postgres JDBC connection we go to production. And in fact, that is what we production. I'm not going to do that yet because we're going to that production environment, get those properties, and this. So that is a little bit about properties. I also just want to point out that we've They are interchangeable with something So you can go ahead and create YAML files So let's say application. YAML. And some people like YAML better, because if you have like lots of that name dot username that password right this can be a little yamel file you can see we can start we can type spring dot data source we can say password Oops, password. And this could be password. And then we can do driver, class name, So you could see that we get a little bit We have some kind of cleaner structure to verbose because we're not repeating spring. Datasource every single time. So you could use YAML, you could use If you use them both, they'll actually and there is an order to like which one But I just wanted to point that out in They are kind of the same thing as Top creating our, configuring our application. All right. So we're getting ready to push our I want to talk a little bit more about So Spring Boot includes a number of and manager your application when you It's not just a number. to push your application into production, working. You don't want to rely on your users You need to be able to monitor this and So you can choose to manage it and endpoints or with JMX if you want. You get auditing health and metrics applied in your application. So what we want to first do is enable the spring boot actuators. So like with a lot of things in Spring actuator that we want to go ahead and add So if we go ahead and do this, I'm going I'm going to go back to my palm. And in here, I'm going to add this And let's tell Maven to reload. And we should be okay. So now when I go back to my application everything looks like it's working okay. All right. So the first production feature, really today is endpoints. So actuator endpoints let you monitor and Spring Boot includes a number of built And you can always define your own. For example, the health endpoint provides Here's the important part. You can enable or disable each individual expose, you know, a whole bunch of them The way that you get to them, most where the ID of the endpoint starts with slash actuator and And here's a list of all the different a description of what it gets. So we know what beans are, right? There's actually an endpoint that beans in your application. So this is really nice to be application as it's being used in are available there? So let's go ahead and take a look at one, we can enable all of them. I'm going to management. endpoints. That web. Exposure. Exposure. dot include and I want to include star. I want to include all of them. I also want to set one other property. I'm going to say management. Dot endpoint. So end point. Endpoint. Dot health. That show details. I'm just going to turn this on to always. So I want to go ahead and restart this And let's go back to. the browser. I'm going to go to local I get a whole bunch of endpoints in here. So we can see endpoints. So like beans, caches, health. And if we go ahead These are all the beans in the application context. So we it content, calendar properties. So if we search for There's no alaces. The scope is dependencies. So pretty cool stuff. You can kind of see all of the different Another one that I really like is the config props. So I can everything is. more importantly where it's coming from. that about, and that welcome message. And we look at the input, it's coming from application. different property sources and we weren't quite sure which one was going to tell us exactly where that particular configuration is well. We can go into the health and we get some details about Here's the components. Hey, we do have a DB. In this go. What is our disk space? And we can even configure information. Say in the info, we can get some JBM info, the operating environment that shows us all the environments that is happening. loggers are all the loggers that are currently configured post request to this if it's enabled to change change a logging level at runtime and I had the actuator important as we start to try to figure out what is going on in our from a JVM standpoint, let's just figure out what is the max grab this key and then say from metrics, what is this, particular metrics. So just with the actuator on, we are now application. Let's take a look at some mappings. So we have are all the mappings that are set up for our wanted to show the actuator. It's important. You get a lot start. You need to include this to do some other things. So around observability. So if we include this, we can now do some really is kind of the idea of logging metrics and just by including that actuator in Spring we can start to collect a lot of metrics So that's pretty cool as well. So that is the single little dependency starter in here. So we have this spring which endpoints we want to expose or how we want to there. So that is the spring boot actuator. All right. And wrap this up and get ready to move to production. I do need a way to kind of load some sample data so that we Whoops, did I delete too much there? Nope. Let's go here. And so I'm going to revisit this data loader here, which we're going to use to So let's talk about that. What I first GitHub repository. I'm going to create a data directory here to create something called content .json. And this is just a and three videos that I've worked on. And this will application. I thought this would be a really fun some JSON data. How could I use this command we're going to need a couple things. We're going to need that the database. So I'm going to say repository. And we're going injection. I'm also going to need an object mapper. So an object Jackson. Jackson is, let's make this final. Jackson is the way that we can deserialize them to, you know, JSON from an object. So that is the application context. So we're just asking for that instance. repository, we have everything we need. So let's go and read from that content .json. This is going to be fairly resources because I'm going to read from something So what I'm reading from is an input stream. So I'm then I'm let me use something here called a type resource as a stream. So what does get resource as a stream do? says, hey, I want to find a resource with So that seems pretty, pretty useful here. So what I'm going to do is say data jason. All right. So now we are in here. And this is not liking us try to resolve. I don't know why it's not finding type We want it from core. Yes. So, okay. Resolve. So now, once we have that, I can use the So I'm going to save a bunch of list And we're going to use that object mapper So it's basically reading the JSON. And for each one of those, it's creating What type is it? For this one, so actually we need to read What type is it? In this case, we're going to use this to get a list of content. So content. And that looks good. Let's go ahead and try that. So I'm going to rerun this application In application, we've taken that out. So the only data loading should come from We should have six values. We should have six values. looks like no airs. Let's go back to our Locust 80 and go to We'll go ahead and connect. We'll go ahead and run Select Star from And there is our six values. So cool. So we were able to just provide a little for this application that we're going to That way we can go ahead and make sure when we move to production and we have All right. In the report, for this particular project that we're There's a docs folder. I'm going to include this production good info in here. And I thought we just walked through We're going to talk about how to build an And then we're actually going to go in could see it live and out on the web. So production, it's the greatest place on We should all want to go there. But it can be a very scary place. So I picture, I always use this picture and my colleague Josh Long as Buzz Light Year saying It's the greatest place on earth. So here's Josh just telling us, reminding there as soon and as often as possible. So there are a few ways that you can production. We're going to talk through just kind of really quickly all three of these and But I wanted to leave this information explore all of your options. So the first is an Uber jar. So the spring boot loader modules let files. We're using the maven plugins. We can get this executable jar To do so, you can create an executable So remember, you don't have to have Maven wrapper. So this means that we can go down to And if we see the command here, we can Oops. And we want to type Clean and Package. So Clean deletes the target folder. Package will invoke Maven's package compile, and test phases to be invoked in the So let's go ahead. and run that. And you see it runs some tests. It's doing some things. Build success. So you see it build a jar in the target the version as defined in the palms. If we look under target and we see this That jar. So to run that, you can use Java. So now this is a executable jar that will So we could say, Java dash, Target, content calendar. And if we go ahead and run that, it Cool. So just seeing that as we're preparing to one thing. We have some logging in there that we So let's say application dot properties. Let's just go ahead and remove that. Okay. So that is an Uberjar. This is a really, what I love about the is JBM. So as we're moving to production, a lot jar and use it. So that's really great. So the other thing is, okay, this is JVM. But what about an environment where there This is where container. and specifically Docker containers in You've already seen some examples of generate that data that run that Postgres database But what you can do is you can create a application using Docker files or by using cloud So I would encourage you to go into the about this. We'll talk about. resources to kind of follow up this crash One of them is going to be spring office Deshaun and I always talk, you know, one friends write Docker files. And you really shouldn't be writing these And that's why we're going to use this So to do so, I want to make sure Docker Let's make sure Docker is running on my I believe it is. All right. And we're started.! Let's go back here. And, Now what we can do is go back to the Let's clear this out. And now we can run, let's get rid of Build Image. So if we run Build Image, this is going So we're going to have a container file So this is really great. So, as we run this, it's building this OCI And it does some really interesting So we're using Piquetto build packs Again, read more about it in the but it does this really nice way of using different layers. And again, this is not something you want Leave this up to the people who are doing I don't do this every day. So I don't want to have to manage this. That's why I kind of lean on the cloud So once this is done, all we're going to We want to see that we have that So we see saving Docker I .O. Library, content calendar, snapshot, and So if we say Docker image, LS, oops, alice dash a. We can see a bunch in there, one of which content calendar snapshot. So now what I should be able to do is use We need to map port 80 to 80 to 8080. We're going to call this content Oh, oh. dot one, or 0 .0 .0 .1 dash snapshot. snapshot Dan. And as you can see, it's starting up our So this is really great for any host that Anywhere that can run a container image, You can just pass this container to them So I'm going to go.! up that. That's our container image. And using Spring Boot 3, there is a way to compile down to really great for different workloads. Some of the like serverless functions or even serverless like CLIs. I did a video lately on my channel about building a CLI using, built one using Spring Shell. So then you can turn image and it just runs on your fast. And the smaller memory footprint and faster startup. So that's that here. This takes a little while to run. So I'm not going to of this is leading up to how can I get my application into of a list here. Here are some places that you can host your spring just a short list of places that I really enjoy. And of different videos on deploying to these different of these so far, and I'll continue to work on these resources for this. Again, we talk about this a lot on spring I've already done for Azure Spring Apps, Heroku. and so what we're going to do today is because there's a free option. So if you don't want to of see how you can get this particular application into to do that. So what are we doing? Let's take what we've learned today and right. So before we head over to railway, I want to talk a little the H2 database in our project. And again, this is great for that we were doing. As we're getting ready to go to because currently we're using H2 in our development. And then we would production. And typically you don't want to do this, whatever database you are using in production, should be in tech environment, should be in your test environment. If you haven't had a containers, that will allow you to spin up a Postgres great. So I think what we should do is make a Postgres in our local environment. And to do so, we need to go over to my palm. I'm going to get rid of my H2 I'm going to include the Postgres driver. screen. It will look something like this. We did familiar. So with that in place, now in my some Postgres properties, right? Now, what are the properties? So I have a So you will need Docker to do this. locally, if you haven't already set that Postgres as a local instance. I'm just not going to walk much time. So if you have a local Postgres instance running, no need for parameters. So I have this running on port 5432. Postgres is the spring. datasource. JDB, Postgres, SQL, Local host, 5432, and We need a username of Postgres and a going to need that SQL init mode to be always. Cool. So let's, run this application. And we have an error. Oh, So again, this is kind of why you want to production and test, right? This schema file is using something kind increment. In the world of Postgres, we're just we'll say this is this is primary key. So now with that in place, application. And air syntax at our near descript. Oh, that is. should be description. So now we don't changing where that gets stored. So I'm going to ahead and rerun that. And cool, no errors. So I think I think consistent there will help us kind of catch some of those deploy them to production. So with that, now I think we can go over Railway. Dot app. If you want to go over to there is. I think I'm logged in. That's why it's go here. So if you get a pricing trial, you get a of RAM, a gigabod on disk, $5 or 500 hours So again, this is really great for your. kind of side projects or something you use. Now, there's a developer tier as well. Ditch stay under free, it's still $5, but none of the limits. As you'll have to pay a little bit more. So pretty nice, like a team for $20 a seat. So I'm a big fan of Railway. I'm going to And what we need to do is create a new So when you create a new project, you can you can deploy a project from GitHub, They have a ton of templates. You can provision a database. What I want to do is actually create an a couple services in here. One is going to be that Postgres One is going to be my project from So let's create a new service. I'm going to create a database. I'm going to add Postgres. And it's going to come in here and provision it. And once it's ready, I can go in here. So from the data tab, I can go ahead and Again, we're going to kind of let Spring You can come in here at query tables, There's some connection info. So if you wanted to connect straight Here's the URL connection. We have logs in here. These are our variables. So these are the different variables that And I think this one, yeah, I'm going to use this. You have metrics and then settings for So once this is up, now we can go ahead So I'm going to go up here and say new If you don't see this in here, you need either access to this specific GitHub or to all of your repos. I only give it access to specific repos. So it has access to these two. I'm going to go ahead and select this And then as this goes, it's going to it to build yet. We can just abort this if we want. Oh, no, we'll just leave it. It's probably going to not work. So we need to set some. environment variables, but we need to this Postgres database that we just So I'm going to head back over and we're We're going to create a new file. We're going to call this application dash Right. So in here, I'm going to copy this thing And I want to copy these because these So what we need is we need the host. So the host is PG host. So let's go ahead and do this. PG host. The port is going to be PG port. And the database is going to be PG Cool. The username is going to be PG user. And the password is going to be. P password. So the reason we're doing this is you values for this, but this isn't something you want to get because then somebody can grab your Pg username database. So this is why we're using these property replaced by an environment variable So with that in place, before I commit here. And so we want to set the end. active profiles. So we're going to say this to production so that it uses our production to go ahead and commit this and say updating for commit. And then as we go back to our deployments So this one started. This is the one we care about. And it is going to go through and build. So it's doing its first thing, It's actually going to use another way to You, as you'll see in the settings, you But I'm going to use. fine leaving it at the default. So it's it for us. So you can see US West 1, Docker PG, seconds. Now it's going to publish that image and then try and right. So we have a success. If you drill into there, you can see the our Hikarii people. Tomcat started on 5970 and our So if there was an issue and you didn't some output here that could kind of point you in the right You see that we are following, the That's a good sign. So if we go into here, we can go over to We can actually generate a domain name. So let's generate a domain name. And this is a going to give us this content calendar this. And it's going to open up in a new tab. deployment should be live soon. So let's go ahead and just wait a second now. We remember our home endpoint is displaying our go over to API slash content, there is a list of all of our content in the database. So this is pulling from the database. And it looks like we may have run this So that's a good thing to note. If this got deployed once and then we are running that command line runner Because remember, we only ran this in And in development mode, we had the H2. And every time. that restarted, we had a fresh database So now every time this starts up, it's So you may just want to add a quick check So we'll come back here. I'm not going to run this again, but in you could do something like if repository then go ahead and do this. If not, we don't want to go ahead and insert this Okay. So cool. So if we go back over to railway and we we can see that we have this table. We can see all of the rows in there. We can also query from here. So we can say select star from content, run our query. And cool, we get all our rows in here. So really, just that easy to get something up and The biggest thing you have to worry about the active profile, and then make sure variables that Railway has set up for the database. If not, you would have to set up new So cool. Again, just a nice a really nice, easy way to get an app out you know, just kind of playing around or There's that free tier. There's also a generous developer tier. Big fan of Railway. But there are other options. So make sure you look in the under Production. There is a bunch of hosts that I can Again, some I've done videos on, some I this list. So go ahead and check those Wow. First off, I just want to say thank entire crash course. You made it through it. I hope you course. This was not a full masterclass on how to learn everything know I'm going to get a lot of comments like, why didn't you cover to draw the line somewhere. There are a lot more things couldn't do today. So that's that. This is a crash course. I said this at learned today and apply it to a different I think that's where a lot of the real what's next? First off, spring office If you guys aren't aware of it, it's this over on Tanzu TV. Go ahead and check that out. I will leave the resources in the docks folder for the there is a resources. This file contains documentation to a lot of the things that covered today, those links are in there. podcasts, YouTube channels, yours truly, of course, find me. So, again, there is so much more to friends. I hope you will follow me on in for more content. I really, really This was a lot of fun to put together. I hope you had fun going friends. Give me a thumbs up on this Subscribe to the channel. And as always,