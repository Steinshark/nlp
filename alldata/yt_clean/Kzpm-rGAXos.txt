[Music] Greetings Linux fans! In this video we're going to go over System D. [Screams] Now calm down, it's okay. System D isn't all that bad. There's some unfair stigma against it within the Linux community, but you know putting that toxicity aside and being unbiased, it really is a good solution. There's a lot of features that you should be aware of and by learning System D, you'll know how to manage resources on a variety of Linux distributions because it's well the most common init system when it comes to Linux nowadays. Now if you don't already know what an init system is, the init system of your Linux installation is the most important process. It's the very first process that starts on your system and its job is to schedule all other processes on that system. So as you can imagine, System D has a very critical part in any server or Linux installation that it's a part of. And in this video I'm going to teach you everything that you need to know to be up and running with System D. The way that this particular video will be structured is that I'll start out with some general information and beginner focused examples when it comes to System D, examples such as starting and stopping services. From there we'll move on to intermediate and then later more advanced topics. Now the thing is, System D is a very large topic so it's impossible for me to cover everything in one video without it being something ridiculous like five hours long. Now sure the runtime of this video is going to be larger than most, but what I wanted to do is focus on the most common use cases of System D, the things that most Linux administrators will need to know how to do. And you'll know how to do those things by the end of this video. What I'll start with is some basic examples of starting stopping and restarting services, you know, the bare minimum things that you'll need to know when it comes to System D. And then from there we're going to look at more complex topics as the video goes on. Anyway with all of that out of the way let's just dive right in and check out System D. So in this section we'll go over some basic information around System D so you can better understand what its purpose is and how it helps us. In this section after this one we'll start with some hands-on activities so you can start learning it, but let's get some basic information out of the way first. So going all the way back to the beginning, what exactly is System D? Well I mentioned earlier that System D is an init system so let's make sure that we fully understand what that is first. The init system of a Linux distribution is a type of process. A process is any task that runs in the background, something you don't regularly see but does its work quietly behind the scenes. But an init system isn't just any process on your Linux system, it's the most important process of all. In fact it's so important that the init system is always the very first process that runs when you start up your Linux instance. For this reason init systems are also referred to as PID 1 short for process id number 1. And that's the case because the init system literally always has process id 1 since it's the first to start. The reason why your distributions init system is so important is because its job is to manage all other processes. When you start a process on a Linux server such as Apache or nginx in the case of a web server, the request to start that process is sent to the init system which then starts it up. When you stop a process, reload a process, restart a process or so on, the init system is what does all of that for you. And to see what I'm talking about let's open up Htop. And Htop if you haven't seen it before is a Linux program that you can use to get a look at what's going on behind the scenes. It's something that I've covered in its own video and I'll leave a card for that video right about here. Anyway Htop is what you're seeing on the screen right now and as you can see we have a list of processes. We can see that on the right hand side. And if I click right here to sort by the PID, notice that system D is literally PID1 just like I was saying earlier. System D itself is a newer init system debuting back in 2010. It differentiates itself from its ancestors in that it has a much more modern approach to process management. And these features give system D the ability to enable the administrator to schedule tasks to only run when specific criteria is met and also to ensure a process is always running. It allows you to configure logging, how DNS is resolved, and much more. So yeah there's a lot to it but don't let that scare you. We're going to make this look very easy. Let's get started with some hands-on examples and you'll be familiar with system D in no time. So let's get started. The first examples that we'll take a look at are very basic and beginner level but are also extremely important to know. In particular the first examples will show you how to work with system D units. Units in system D refer to anything that it's able to manage for you. Units include but aren't limited to services, timers, mounts, auto mounts, and so on. To keep it simple in this entire first section we're going to focus primarily on services. And the reason why I'm mentioning this right now is because this is something that I recommend you commit to memory in order to save confusion later. So in summary units are things that system D can manage for you and a service is a type of unit. And I'm going to repeat that. Units are things that system D can manage for you and a service is a type of unit. And again we'll be working only with services in this section but I just wanted to make sure that you know this because this is something that confuses newcomers. You'll hear of terms such as units and services and you might not know the difference. Well unit again is something that system D can manage for you and a service is just one of those types of units. And managing services is just one of the things that system D does for us so let's start working with services right now. We can use any package that contains a service file as an example but to save time let's install Apache. And how you go about doing that depends on the distribution that you're running. If you're running Debian Ubuntu or anything based on one of those distributions then what you'll do is run sudo apt install and then Apache 2. What that'll do for us is install Apache. Apache again is a popular web server service and by having this installed your server becomes a web server. It's serving a web page. Now if you're running something like Fedora, CentOS, Red Hat or a flavor of enterprise Linux then what you'll do is change app to dnf. And then in that case you'll change the name of the package to htpd because the package name is different on other distributions. So you're going to run one of those commands to get Apache installed and then once you have it installed we can continue. Now for those of you that are running a distribution of Linux other than one of the ones that I've mentioned then you're probably an intermediate or advanced Linux user and you're only watching this video to prepare constructive criticism. If that's you how am I doing so far? Now in my case the dnf command is what I'm going to run because this particular computer is currently running Fedora. So I'll press enter. And actually I already installed Apache before I hit the record button. I forgot to remove it but you get the idea. I have Apache installed right here in my footage pc and what that means is that I should be able to access it. If I switch over to a browser what I could do is just navigate to localhost right here in the address bar. And what that's going to enable me to do is view the sample Apache web page which doesn't work for some reason. And why is that? Well that brings us to our very first systemctl command which is how we interact with system d for the most part. So what we're going to do is check the status of Apache. Now on your end it might have already been running especially if you use Debian or Ubuntu. If that's you then the previous step probably worked. But distributions based on enterprise Linux and that includes Fedora, CentOS, and a number of others in the process won't be started automatically when you install Apache. To find out what we could do is run systemctl and that's the command that we're going to use primarily when it comes to using system d. We want to check the status of something and what we want to check the status of is either going to be HTTP D and that's going to be the case if your package manager is DNF. Otherwise if you are using a Debian or Ubuntu based distro then the service is going to be called Apache 2. It doesn't matter what yours is called you just have to know. In my case I installed HTTP D so the service name will be the same as the package name. Anyway I'll press enter and there you go. We've just checked the status of a unit with system d. The systemctl command or system control command is what we use to inspect running services. In this case I just ran status against it because I wanted to find out is it running and as we can see here it's not running. In fact you can see that it's inactive that's what it shows right there. We also see that it's currently disabled. Now when a service is disabled that means it's not going to start up when the server starts up you have to start the service manually. We can always enable it if we want to go ahead and do that but what we're going to do right now is well start Apache. So we'll use sudo systemctl and then start and then the name of the service. In my case httpd just like that. So now let's check the status again and we can see that it's running. So now we've seen two variations of systemctl already. So what I'll do is press Q to break out of the status window here and return to the command line. So far what you've seen is systemctl and then status and then we'll type the service name right after that to check the status of that service. And you also saw an example of me starting a service in this case it was httpd but it really doesn't matter what the name of the service is because you're going to go about this the same way regardless. So you now know how to check the status of a service and you also know how to start a service. And considering that I started the service if I go back to my browser and what I'll do is refresh the page. Actually it's not going to work because I have https and a name here so I need to just drop that out of here. This is not a secure site at least not yet. But anyway we see the Fedora test page here and this is going to look different for you depending on what your distribution is. But as you just saw after I installed Apache I was able to start it up and now it's running. Now what I'm going to do is show you an example of stopping a service with systemd. So again I'll type sudo and then systemctl I want to stop a service and I'll stop the Apache service. Now if I go back to my browser and then I attempt to refresh the page watch what happens. The test page is no longer available and that makes sense. We need a web server to serve a web page and the web server that I installed is Apache and I stopped the service so now there's nothing on the server to serve this web page. So I'm unable to connect. So of course I can go ahead and start it and as soon as I do that it's available again. Now in addition to stopping starting and checking the status of a service it could also restart a service as well. This is useful if you've changed a configuration file and perhaps the application needs to be restarted for the changes to take effect. Pretty self-explanatory but what it's going to do is stop the service and then start it up again. In my case there's going to be no difference here. The restart process happens very quickly so as you can see the test page still works and believe it or not that's the majority of the commands that you'll need to know when it comes to systemd. systemd runs in the background and is completely self-sufficient. It manages things for you. The only time you'll interact with it is anytime you want to check the status of something or alter the status of something. So those are four of the six most important commands that you'll need to know. But what are the other two? Well let's take a look at that right now. Back in the terminal let's see how we can take care of the fact that Apache isn't going to start up when this particular computer starts up. Again here's the status page. You can see that Apache is disabled. It's currently running which is great but it's well disabled. So if I restart the computer then Apache will not be running. Now correcting this situation is really easy to do. Back on the command line what I could do is run sudo and then systemctl enable and then the name of the service. So again httpd in my case it might be Apache 2 for you but you get the idea. And now it's telling me that it created a sim link which is what happens when you enable a service. And if I check the status again you can see that it's not only running but it's also enabled. Now the preset of disabled means that the distribution has configured systemd such that well new services will be disabled by default. It doesn't really mean a whole lot though. You can always enable the service if you want to start it automatically but in the case of well Debian and Ubuntu it's typical that they'll enable the service for you. The idea being you wouldn't have installed it unless it's something that you wanted to use. Whereas when it comes to Red Hat based distributions you know Fedora, CentOS and the others they're not going to make any assumptions at all. They're going to disable a newly started service. A service comes from the package itself so here it's going to be disabled but we can always enable it if that's what we want to do. Now before we move on one thing that I do want to point out is if I scroll through the output right here we have some log entries down here at the bottom. You're not always going to see that when you check the status of something but if you have permission to see the information it's going to be shown right here. Again you're not always going to see that but if you're having problems it might be useful to see this because you might see the error message right here in the output. Anyway I'll use Q to quit out of here and let's continue. Now at this point what we're going to do is take a look at how to disable something. You could probably already guess the syntax for that. We used sudo systemctl enable and then the name of the process to enable it but if we wanted to make sure that it does not start when the system starts we can disable the service. So if I check the status again as you can see it's now disabled. So at this point you've learned the six most important commands when it comes to systemctl or systemd in general. Systemctl start, stop, restart, status, and also enable or disable and this will be the majority of your use of systemd. Sure every now and then you'll have to go deeper than this but these are the commands that you should know at an absolute minimum. Now I hope you'll continue on because everything in this video was curated as things that you should probably know for your career but these six commands are the bare minimum that you should know when it comes to systemd. Now from here what we're going to do is dive in even deeper and take a look at how systemd is structured, how it's laid out, or specifically we're going to look at directories where the unit files are stored in the first place. So earlier I mentioned that systemd uses unit files. A unit file pertains to anything that it can manage and when I say file I mean file. systemd is looking at files or unit files to understand how it needs to interact with processes. But where exactly are these unit files stored? Well let's take a look at that. And on the screen right now is an example of a service file. Don't worry so much about the contents right now, we'll get to that later. But anyway service files are just text files that contain instructions that tell systemd how it needs to manage that particular service. So what I've done here is I've pulled up the service file for Apache. Now service files can be found in any of several directories and these will have a file extension of .service. At the top of the window right now we can see the full path and the name of the file for this particular service right here. So if you wanted to take a look at the contents on your end you could do that. Now on Debian or Ubuntu it's going to be Apache2.service but you get the idea. Anyway let's go ahead and close out of here and take a look at the directories that are most common for service files. In fact there's going to be three different directories that we'll be paying attention to. And the first one will be slash etc slash systemd slash system. This is going to be the most common directory that you'll find in the majority of how-tos that you'll see out there that go over service files. Now we'll look inside these directories shortly but let's go through the three most important ones right now so that way you'll know which ones we're going to focus on. The second one is going to be slash run systemd and then system and the third one is going to be slash lib slash systemd slash system. Now again each of the directories that I just gave you are going to have systemd unit file saved inside them. Anyway let's go ahead and take a look at the contents of one of those directories. And randomly what I'll do is choose the slash lib slash systemd slash system directory and take a look at this. We have a number of service files here but we actually have more than just service files. We have a mount file, we have a target file, we have a service right here as you can see we have a socket file. There's a number of different types of units here or unit files that are inside this directory and this might make the relationship a bit more clear. I mentioned that we're going to be focusing on service files but that service files weren't the only kind of unit file. Again a service is a type of unit so a timer is a unit and then scrolling up of course we have a socket unit, we have a target and so on. But anyway I just wanted to mention that so the relationship will be more clear. Service files are going to be the majority of what you'll work with but just keep in mind that there's different types of unit files. But why is it that we have several different directories where these unit files might be stored in? Well each one of these has a very specific purpose. Now the one that I just showed you was slash live slash system d slash system. Now if I take a look at that again and then I'll scroll up what you'll notice we have hdpd dot service right here. When we installed Apache that particular service file was installed for us. So typically you don't have to create your own service files although you can most of the time the service file will be provided by the application that you install. So generally speaking there won't be too many situations in which you'll need to customize this but we will see that process. But anyway we can see the hdpd dot service file that came with Apache right here. So when I had the service file on the screen that's the one that I had on the screen. So what we can glean from that is the slash live slash system d slash system directory is the directory that installed service files will go into. So when you install a package and it includes a service file it's going to be found inside that directory. Now similarly we also have slash run slash system d slash system which is going to store runtime system d units. I don't have any on my system right now. This directory in particular is going to be the one you'll look at the least. Now another directory that I mentioned was the etc system d system directory and I also mentioned that this is going to be the most common one that you'll work with. What I'll do on the screen is show you the three directories ordered from the highest priority down to the lowest. So as you can see the lowest priority is slash live slash system d slash system. Any service file or configuration that's stored in a directory of a higher priority is going to well take priority. That means that any service files or configurations that you might have in slash run slash system d slash system those are going to take priority over slash live slash system d slash system. The biggest priority of all is slash etc slash system d slash system. No matter what anything you put inside that directory will have the ultimate priority. It's the directory that system d favors more than any other. So if you want to make sure that your configuration takes effect you'll want to make sure that you add the changes to the directory with a higher priority. So the way this works is when you first start up your linux system it'll start system d and system d will go into these directories looking for unit files. If it finds any and it will it's going to load those into memory. Now due to this priority if you were to ever create your very own service files manually you'll definitely want to save them in slash s e slash system d slash system. Since it has the higher priority again you can make sure that the service file is taken into account. In fact you can create an override file which we'll see later in this video that will allow you to override configuration that's found in a lower priority directory. That also saves you from having to type everything manually. Now again slash live slash system d slash system is a directory with the lowest priority but it's also the directory where installed services go. Now the reason why the package manager is going to install service files into the lowest priority directory is because you have an opportunity to override the settings. Again we'll see that later. When you install a package that contains a unit file you'll find the unit file in that directory. Although you can create your own unit files and store them in that directory as well it's recommended not to do that and to use slash etc slash system d slash system not just because that directory has a higher priority although that is part of the reason. The thing is unit files that are stored in slash live slash system d slash system might be overwritten if a package is updated. Now the slash run slash system d slash system directory contains what are known as runtime units something we won't be looking at during this video in particular but I mention it just so you can be aware of the fact that it exists. Anyway now that we know which directories contain unit files for system d and we also know the priority order let's take a closer look at an actual system d unit file. All right so in this section we're going to take a look at a system d unit file specifically a service so that way we can better understand how they're set up. There's going to be many different examples of different fields and configurations so there's no way that I can cover every possibility that you might find in one of these files but what I'll do is cover an example right now that will give you a general idea. Earlier we installed Apache so let's take a look at that right now. So what I'll do is just use nano and then I'll edit slash live slash system d slash system and inside there since I've installed Apache here on this particular system it's going to be called httpd.service just like that. Again the name will be different on other distributions you get the idea and here we have the service file. Now we can ignore the error down there that's telling us that this particular service file is unwritable. That just means that I didn't use sudo which was intentional. I really don't want to modify this particular file at this time but I did want to bring this up in an editor so we can go through some of the commonalities that you'll find here when it comes to system d unit files. Oh sorry I was just consulting my own book actually. You know that's something that I do from time to time because unlike what many of you might think I don't memorize everything that I teach you guys sometimes I actually look at my own book if I want to remember how to do something that I don't do every day. But since I'm on the subject of this book check it out Mastering Ubuntu Server Fourth Edition written by yours truly it's available right now and I think you're going to love it. So if you're looking for an Ubuntu book to teach you everything that you need to know when it comes to managing real Ubuntu servers check it out. So definitely check out the book I would really appreciate it. Anyway let's get back to the video. Now for the most part we have three primary sections here. We have a section down here called install which goes off the edge of the screen but anyway we see unit service and install and each of these sections is designated by brackets and the name of each section will have its first letter capitalized and it's important that you don't change the syntax as the file is well case sensitive. Unit with a lowercase u for example doesn't factor in. Again system D is expecting the first letter to be capital and you put the different sections and brackets like you see right here. Underneath each section we have configuration for that section. Some of these fields are required while others are optional. But first let's understand the purpose of each of these three sections before we look at what's underneath. The unit section contains more general information about the unit. For example a description which describes what the unit is for. The description here is just identifying that the unit file pertains to Apache which is a web or HTTP server. Next in this example we have wants that may not show up for you Debian or Ubuntu users because again not every field is required. Anyway wants identifies a sort of prerequisite unit that must be started first. In this case we have httpdinit.service and that's not going to be found on the Debian version. Again there's differences from one distribution to another but let's not focus so much on the differences themselves. Let's focus on the unit file. Now what wants does is outline that something else is required and it must happen before this unit file can start up. It's quite common that you might have something like network.target and we see that here underneath after but that could be under wants as well. That's a prerequisite and network.target means that we want to wait until the network is available before the process starts. I mean it wouldn't make sense to start up Apache before the network. Nobody can access it anyway. We may as well start it up after the network comes online so that way people can access it as soon as the network is available. Now we also have before as well as after. Here we have after network.target we have some other unit files there as well and these are similar to wants but focus on a specific order. When it comes to before and after you can have multiple units separated by spaces which is exactly what we have here. So that way if you have more than one requirement you can not only specify that but also specify in which order things start up if that matters. In addition we also have a documentation field. In this field you can configure what it lists as the documentation source for the unit and this one right here is referring you to the man page. Now you might see something like a url here on your end if you're using a different distribution but regardless whoever packaged this particular service file has decided that the documentation should be set to the man page which is what you see right here. Under the service section we have configuration options that are specific to service files and these options configure how the unit is treated when it starts up and the first option underneath this section is the type. When it comes to CentOS the type is set to notify. Now this option is almost exactly identical to another type known as simple. The simple service type is the default and as such it's quite common. The simple type causes system d to consider the service to be started up as soon as you start it. In contrast notify is the same except it's not configured to be running until the process tells system d that it's ready. Whereas with the simple type it's not going to take that into account if you start it it's going to go ahead and assume that it's running. Now on the Debian and Ubuntu side you probably have this set to forking. This means that the process is considered to be started when other processes are spawned from a parent process and then that parent process stops to where the children are the only processes that are running. That's why we have a different type on two different distributions for the same application comes down to design decisions by the team that maintains the distribution and it's best that we don't change this unless we have a very specific reason to do so. Now other things we have here is exec start and also exec reload. We go ahead and scroll down here and center that for us. We can also have exec stop as well and the meaning is going to be similar between the three. For example exec start is what happens when the process is started up. That's the application that's going to be started along with the service. So in this case slash user slash sbin slash hdbd is going to be the process that starts up when we start the service file. When it comes to exec stop that's the opposite. When the service stops it's going to execute that command and we don't have that here in the case of sentos so it doesn't even have exec stop. Again some of these fields are optional. You're only going to include the ones that matter for your use case. But what exactly is up with reload? I mean we've started a service file, we've stopped a service file, we've checked the status of it, we've restarted it, but what's reload and how does that differ from restart? Well similar to how we restarted a service and as a refresher it would look something like this. So do systemctl restart and then the process name but instead of restart we could type reload. Now reload is similar to restart but it's not a full restart of the service. Reload will cause the process to reload its configuration files which enables a setting to take effect without users getting disconnected. In the case of a web server like Apache this is preferred since we'd rather not disconnect users from our website if we don't have to. Now not every configuration change supports reload over restart and not every service file will contain this. It's something that the developer of the service will add if there's a functional reason for this to exist. Of course there's additional values that could be here as well but I'm going to skip those as the deeper we get into systemd at this point the more we're getting into distribution design choices that go beyond the scope of this video. Anyway continuing let's look at the install section and this section isn't required but if it is present it will configure what happens when a unit file is enabled or disabled. And as we went over earlier a unit that's enabled will start up when the server starts up and disabled is the exact opposite of that. But when a service is enabled we can use this section right here to set up how that's handled. When it comes to wanted by which is what you see right here that has to do with dependency relationships similar to after and before which is what we found in the unit section above. And what that means goes beyond the scope of this video but I will give you a summary. With Linux systems we have different run levels that define various operating stages. MultiUser.target defines that the system must have reached a state where multiple users can use the system at the same time so in this case Apache will not start until that stage has been reached. Now what I just went over is a very basic overview of systemd service files and I'd love to go over every possible detail that might be within these files but in that case the video would be over an hour or two longer than it is right now. But with what I've gone over that should give you a basic idea of how these files are structured and then depending on the scope of your project you'll add configuration items as necessary. But what do you do if you want to alter one of these service files? Well that's exactly what we're going to explore next. All right so at this point as we continue along our journey we're going to start looking into customizing unit files. In most cases unit files that your distribution provides are typically adequate but as you advance your linux skills you'll likely run into situations where you'll need to either edit an existing unit file or maybe even create your own. So first let's take a look at editing or overriding an existing service file and you know what there's a dedicated command that you could use within systemd for this purpose. That command is systemctl and then edit. So to edit a service file you can run systemctl edit like you see here and then you give it the name of a service file. I'm going to type a ctbd.service. I don't have to type the path to it because systemd knows where to find its own service file so I only need to give it the name. So I'll press enter and let's see what happens. And actually I'm going to need sudo here I almost forgot. See even I forget to do that sometimes. Anyway what we have right here is a service file or well what is this exactly? But what we have right here is a very special override.conf file a config file that's being created as a part of the systemd edit command. As you can see at the top the path is going to be slash etc slash systemd slash system slash actbd.service.d and then it's going to create an override file underneath that directory. But why exactly is it going to create an override file in that directory instead of the directory where that unit file actually resides in? Well the reason why has to do with priority. Like I mentioned earlier the etc systemd system directory has the highest priority. So when you use system ctl edit that's where it's going to save the file. Again anything in that file takes priority. Now what we have here is the original unit file but everything is commented out. And this is here for your reference. I mean you might be tempted if you wanted to make a change and the change we're going to make in this video spoiler alert is going to be here in the unit section. And we're going to edit the description. That's a fairly inconsequential change very easy to make. I'll just add something here. So what should happen is when you save the file then the changes right here in this editor will be merged with the existing file. That's not going to happen though and I'll show you why. Anyway ctrl o and then enter to save it. It said it wrote 57 lines. Keep that in mind. Anyway I'll exit out and let's take a look at it. Now the original file is going to be unchanged. You see right here description and it's the original description. But it saved the changes or at least it said it saved the changes in the etc system d system directory. Let's take a look at it. Now unless I'm blind I'm not seeing anything regarding ht dpd inside this directory. And here's why. Let's run that previous command again to edit the service file. So again that sudo systemctl edit and then the name of the service file. But anyway why did our changes not get saved? Well this is a situation that a lot of people run into. Even I've run into this myself the first time that I've done this. You might think that going down here and uncommenting something that you want to change. For example in the units section you might want to change the documentation or the description but that's not how you do it. For some reason it's easy to miss but it tells you right here that edits below this comment will be discarded. So that means any changes you make down here will not be saved. They will not be taken into account. So following the instructions here any changes we want to make should be made here underneath the second line and above that notice line that tells you that anything below it won't be saved. So if we want to alter something in the unit section you need to type the name of the section right here in the proper format that contains the feature that we want to change. And what I'll do is scroll down let's see what we could change. I think description is probably easy enough. So what I'll do is just type description right here. I'll set it equal to Apache is Awesome. Let's save the file and close out. Now it says that it installed it and it tells us that it did so in that directory right there. So let's just take a look at it. So we have a directory that has the same name as the service with a file extension of .service.d and then underneath that directory we should have an override .config file. And we do. It contains only the changes that we've made with the systemctl edit command. It doesn't contain the entirety of the systemd unit file. It only contains what's changed because again anything in slash etc slash system d slash system is going to take priority. So any conflicting settings that you might have here are going to take priority. So we already have the unit section in that unit file and then within that we have a description. But here in the override file we're setting that to be equal to something else. If we wanted to undo the change we could simply remove the override file. Which is what I'll do right now. And what I'll do as well is show you another method of editing service files. Just like before we're going to use systemctl and we'll use edit. But what I want to do is use the option dash dash full. I'll give it the same service name. And let's see how this differs. And check this out. If I scroll down we have the entire service file here. So the difference is when we run systemctl edit we're going to create an override file. That gives us the option to add only the sections or settings that we want to override and have it stored in an override file rather than having the entirety of the system D unit all over again. But when we use the dash dash full option what that's telling system D is is that we want to start with an entire config file an entire service file and use that as the base. Now notice that I haven't made any changes here. I'm just going to save the file and then I'll exit out. So we've ran that command we didn't make any changes so what exactly happened? Well if I list the storage of slash etc slash system D slash system you can see that we have an http D service file right there. So now at this point we have one here in etc system D system and we also have the original at slash live slash system D slash system. But what's the difference between these two files? There shouldn't be anything different because I didn't make any changes but let's verify that. I'll use the diff command and the first file is slash etc slash system D slash system and then the file name of course is http D dot service and the original is located at slash live slash system D slash system with the same name. Let's see what's different. Nothing. If there was a difference between the two files we would see output here with the diff command that says there wasn't any output that means these files are identical. So what you can glean from this is that when you run the systemctl edit dash dash full command against a service file that's going to make a copy of the entire service file and save it in etc system D system. So any changes that I make to that file are going to take priority and the other benefit is the service file underneath slash live slash system D slash system might be overwritten at some point if the package gets updated but the files underneath the etc system D system directory will not be altered. That way I don't have to worry about the package manager making changes or overriding my customizations. Anything in etc system D system is going to be retained regardless of the package manager so it's a safer directory in which to make your changes. Now there's another command that I need to make sure that you guys are aware of and I'll go ahead and type it out right now. It's going to be sudo systemctl and then daemon reload just like that. But what does that command actually do? Well in this section we are making changes to system D unit files. The first command created an override file and the second command created a copy of the original unit file. This command right here will reload system D to make sure that it takes into account all the changes that we've made. If we don't do this it's possible that the changes just won't take effect. But with this command right here we're basically telling system D to take a look at its directories, have a look for anything that's changed or is unique in any kind of way and just load everything into memory. So that way everything we change regardless of which unit files we change will all be taken into account. That's what this command does right here. So anytime you do make changes to a service file or basically any unit file you'll want to make sure to run this command right here. But what about creating unit files from scratch? How do you go about doing that? Well the thing is it varies depending on the application. Every application will need custom parameters so there's no way I can give you a template that'll go over everything but there are some well things that you could do to make the process a lot easier. So what I'll do is switch over to a browser and I'll give you an example. So right here we have our Fedora test page. What I'll do is just navigate to a completely different website. And I'll make the text a little larger so that way you can see everything right here. Anyway this URL just takes you to a file that's stored on a GitHub repository. This one in particular is for the application known as SyncThing. And I wanted to give you guys this particular unit file right here as an example of a real world scenario where you might need to create your own service file. In this case this particular service file pertains to SyncThing. SyncThing is an awesome application that allows you to sync data between Linux installations. So if you wanted to save a file and then have that file be accessible from all of your servers then SyncThing is a way you could do that. Now this tutorial isn't about SyncThing. I'm just using this as an example. But SyncThing is something that you can install via your distributions package manager. If you do that you'll get a service file automatically. You don't have to create one. But what if you wanted to use a version of SyncThing that's newer than what your distribution provides? In that case you might have to manually install it. If you manually install it then how are you going to know what to add to a service file? Well in this case we have a service file that's provided to us from the developer. So we don't have to guess or look into this. Right here we have a working example. And this is a common use case when it comes to systemd. If you're installing something manually chances are the developer has prepared a sample unit file like the one right here. So what you'll do is just grab the example and use it as a starting point. Of course you want to customize this to make sure that everything matches. So if your path to SyncThing is not slash user slash bin slash syncThing then you'll want to change that. So if you've installed that somewhere else then you'll just adjust that line. But otherwise anything that is fine to be the default you just leave alone. And then what you'll do is save this file into the etc. systemd system directory and then run your daemon reload command to make sure that systemd is aware of this new file. From that point on you can enable restart stop or do whatever you want when it comes to this particular service. And that'll make sure that you're able to work with that application similar to any other applications that you might have installed. Okay so I'm going to stop the tutorial right about here. This is one of my longer tutorials and I can always create a follow-up because there's more things that you could probably know about systemd that will be worthwhile. In this video we went over the foundational concepts. The things that I think everyone should know about systemd so that was our focus this time around. But if you guys want additional content around systemd then make sure you click that like button. And well I might consider doing a follow-up at some point in the future. Now other examples of systemd that we can go over in a future video include but aren't limited to systemd mounts, automounts, timers, and so on. Mounts are a way of making sure that something is mounted similar to the etcfs tab file. And when it comes to timers those can actually replace cron believe it or not. Not that there's anything wrong with cron but there's additional features with systemd timers that you can benefit from. And those are all some of the topics that we might go over in a related video in the future. Anyway I hope this video has helped you guys out and I'll see you in another video sometime soon. I'm working on a ton of Linux content for you guys that I can't wait for you to see so be sure to subscribe to Learn Linux TV for the latest at Linux and I'll see you in the next video. [Music]