So I wanted to start out with an introduction this is much storied territory, but I have as a stepping off point for us to go through as hitting some of the key libraries along know is that go is created by a small team Robert griesemer, Rob Pike, and Ken Thompson. industry for a little while, for example, operating system, as well as had a key role guys got together and decided that they wanted in the room as soon as these guys got together. is, why create a new language at all? Well, languages that are common inside of Google. there were really three languages that were C and c++. Now, each of these languages in go designers started to recognize that there into, that might not be able to be fixed, languages. So for example, when we look at an interpreted language. And so it can be at Google scale that are based on Python, the challenges that you can run into in very quick, but its type system has become increasingly trend that a lot of languages go through. use cases and additional features are layered more difficult to navigate things C and c++ a complex type system. And additionally, its type system has been receiving a lot of attention they still have the burden of needing to manage it's very difficult for them to move past written 10 years ago still need to compile legacy issue that C and c++ have inherited had nowhere near as much memory as they do the compilers to use a minimum amount of memory. about was the compile times can be a little languages were created in a time where multi Almost every application that was created a time. So concurrency patterns built into so working in highly parallel, highly concurrent be a little bit challenging when working in go bring to the party in order to address that we need to understand is gozi, strong that same feature set from Java and c++. So with strong typing means that the type of you declare a variable a to hold an integer, can't put a Boolean in it, you can't put a all of those variables have to be defined that? Yes, go does have features that allow of the time, you're going to be living in And getting all the benefits that come with as Java, then you might be a little concerned tend to be a little bit verbose. Well, we'll been a lot of effort taken to make the compiler talking about with a variable. So you don't what your variable types and things like that In addition, go like a lot of recent languages it. Just because go is an excellent language are so many languages out there, that it can up in any one. As a result, there's a strong focused on making sure that the go language have an easier time as possible ramping up key features of the language itself? One of features that go has is a recognition that and start learning about the go language, you're going to ask yourself, Well, why doesn't And a lot of the reasons Come back to this go language recognizes simplicity is important, decide to leave out some other features that to the language. Additionally, go focuses development environments to write code fast feedback back to the developer as quick as compile time, it breaks that cycle. And developers build test loop. And so go focuses on keeping going to yield us fully compiled binaries which means that you're not going to have your own memory. But by and large, the go the reason for that gets back to this simplicity collected language does have challenges when real time trading systems for stock market dealing with garbage collection. However, to manage their own memory all the time, were mean that the delays that a garbage collector you go back through the history of the go versions have had a huge emphasis on reducing to pause during a garbage collection cycle. fast, almost to the point that you don't know to address that concern of concurrency go into the language. And we'll talk about that instead of having a library that we're going we're going to be able to do concurrent development go compiles down to a standalone library, everything is going to be bundled into that itself. So the go runtime is going to be bundled on, they're going to be compiled in there. out to external libraries and DLLs, and things work. And what that gives you is version management have one binary, you deploy that binary, you Now keep in mind, when I say dependencies, to build a web application that has HTML, along with the binary, but the binary itself next thing that I'd like to do is show you you, as you start to explore the go language. One of the most useful resources that you're ramping up on go, is goes website here@golang.org. a minute to think about a language called search results in Google or Bing. So go lang.org that you see go mentioned, you're gonna see that makes it a little bit more unique when first thing that you might notice, as we go laid out like a lot of traditional home pages. homepage. So instead of a lot of design aesthetic, and shows you how to start working with the going to be your entry point for your first this run button, you see that we almost instantly it gets compiled, and it gets run for us. without installing anything on our local machines. of that through this first few videos. As here, so maybe if I will say, Hello, YouTube hello to y'all, so Hi. So it's as simple as Beside that window, we see this download GO that you're going to be able to use in order as download older versions of the runtime. example, at the time I'm recording this go that install that and check that for bugs If we come across at the top, we see this be another critical resource as you're starting you're going to refer back to this page quite on the website, a tour of the go languages, Started link. This is going to get you started and tools and things like that. And you can you the different architectures that you're quite a few and how to get started on each tour of go is kind of an introduction to the introduction. So it's going to start out with and more and more and help you understand like that. Effective go is a very useful article, understanding of the language, and really I would encourage you to go into that it's read. But you should consider this required building non trivial go applications. But now. We got plenty ways to go before we need down here at the bottom is some reference that you're probably not going to need right gives you a lot of information about the go development with go, there's a lot of things to help you understand how to navigate that. the most time on gos website. And this gives that are built into go. So when you install you're going to get all of these libraries can see that we've got different libraries we've got some cryptography libraries, database some things for working with HTML, and network missing here are we don't have any GUI libraries. focused on the use case of client application servers and web applications. And so that's be focused on. There are some projects that as well as client side applications using this point. If we come over to the project about history of the project, what releases to mailing lists and resources that you can of the development of go as a language as you can see some information here on how to Help link here. And this is going to be one here because this is going to be your on ramp in my experience are the go forum, which is post your questions and get people to answer more real time then the gopher slack is a development. And there's multiple sub channels Even a lot of the NGO meetup groups have their you want to get on the gopher slack that I website called go Lang bridge. And this is Because NGO Lang bridge is specifically there sure that the community is healthy and strong. language is a focus on having an excellent and the awesome people that support it, that a little bit, you can see some links to the Slack channel, you do have to receive an invite. the forum that's going to allow you to get the invitation, the only thing that they asked is a code of conduct that just make sure that in the community, just to make sure that we're the last thing that I want to show you on link just flies out an editor. And this is the site. So if I come to the packages, and and I'm learning about some network function, I can create a real quick proof of concept I understand how that's working. And again, run that I can go ahead and execute that. this application is sent to the back end. gonna be able to read the file system at the But a lot of the things that you want to play online environment. Now another place to get golang.org. And this is the last thing I want this is going to be the environment that we're that a little bit bigger. So maybe it's a going to be the environment that we're going So we're going to learn the basics of go application with how we're going to work with variables Now, eventually, we'll get to installing a advantage of the other resources on go Lang create a video on it. But I think that there's a commitment to setting up a local development here. So if we take a second look at this of any go program. And the first thing that main. Every go application is structured into to have is going to have to declare what package because main is going to be the entry point that we have an import statement. And this order to import additional libraries. So this actually say that in the NGO community, I that FMT, I hope that you'll forgive me. But this called thumped. And this is the package you see down below here and our main function, so the main function in the main package is And this is going to be where we're going run in go. So we're going to call into the print ln function, and that print ln function case is a string. So we're going to print run this, then down below at the bottom of gets printed out. And then it says program say if I delete this quotation mark and run, printed out at the bottom, that's going to environments going to be very good for you you through understanding what's going on. it got an unexpected semi colon or new line, parenthesis. And the reason for that is because of the string. So the line terminated early, call. So if we go ahead and re add the quotation got our first start in a go application. So bit of background in a language that you're bit valuable, it helps to understand the motivations features, in order to understand what problems how it's going to go about trying to solve started setting up your own local development in the last video, I showed you this website to use. That is the website it played@golang.org. want to use in order to show you a lot of with with the go language. And that's still that it doesn't really make sense to force a really good place for me to demonstrate available to you to set up your own local around with creating your own applications So the first thing that we're going to need install the go language in the go tools itself. we're going to start over here@golang.org. go link here. Now this link is going to take you to all general, if you're getting started, just pick for you, and it's not going to steer you wrong. encourage you to click this MSI link, it's to be put on your system automatically. However, recommend that you go to this installation here. Now, you're still going to need to download a little bit, you're going to see this command command that you're going to need to use in it onto your system. So I've already done a terminal here. And the default location local and then in a folder called go. So if there, I see that I have all the go tools all it's going to do is it's going to place strongly encourage you if you can accept these that because it's going to make setting up Now after we get go installed, we have a little order to be able to use go effectively. So here. And I'm going to make a change to my to be in my bash RC file. If you're an LS you're in Windows, basically what we're doing if I open that up and come down to the bottom, bash script. I'm not going to really worry that we're going to need to set. Hello, everybody, and make an important announcement. So as Dave cainy came in within a couple of minutes things that I'm about to talk about. Now I'm variables here and showing you how they work. And setting go route has been shown to cause Go, especially if you've got multiple versions want more information about that Dave has go to to learn more information about it. able to install go at its default locations, user slash local slash go in on Windows is able to do that, please do that. And then will need to set the PATH variable to go roots And you will need to set go path which we're can avoid setting the go route environment heartache. So well, I'm going to show you it please avoid that if at all possible. Okay, and continue talking about the environment going to need to know about is called go route. location, you're not going to need to worry go somewhere else, for example, maybe you've you can go ahead and set go route. And that'll go binaries. Now the next thing that we want to the go binaries themselves. So I'm going that'll Of course, start with my existing go route. And then I'm going to whack on the that we're going to be using on a regular so you're going to want to make sure that let me go ahead and save this. And then I my shell to reread the bash RC file. And then available by typing go and version. And you candidate three. Okay, now there's one more thing that we need set up. And I'm going to go back into my bash setting of a second environment variable. the environment where goes installed. But packages as we work with go, because we're that other people have published in order applications as well as our own source code they're going to be located in a path that called go path. Now go path is either one things about go because it gives you this are located. However, it does kind of push of all these binaries and your applications of a hint on how to work with that. But for in my home directory. And then I will call we might have some executable binaries that going to go ahead and export on our path again. then I want to add on go path slash bin. That executables, and we will be installing libraries be able to track that. Now just to show you go ahead and save this out resource, my bash this folder here called go live. Now if I of that it's currently empty. But I can change I get a library that's at github.com slash library that people use to provide autocomplete if I go ahead and hit Enter, and wait a second, now I've got some content here. So if I look executable. And if I come back to the source comm folder. And inside of that is NSF. And here, here's all of the source code for the go code, it actually downloads the source for me. And that's what that go path is going run into is that this use of gopath tends you're going to have go code, you're going all sorts of other libraries, all put into that creates a lot of visual clutter. And I use. What I do is coming back into my bash gopath to create a compound gopath. So instead to re export go path and I'm going to add to add Home mic and code. Now a lot of times go pants. And so I've got go live. And that's go. And then I'm going to have another folder, location. So let's go ahead and write this got the full gopath. So if I come into my now it's empty again. So if I go ahead and NSF slash go code. And now you see that it come into my code folder, which I also created segment of your go path is going to be used all of the segments of your go path are going going to really help us as we're setting up the next thing that I want to do. So a workspace that you need in order to create a workspace it. So if I add a directory called SRC into Now SRC, as you might expect, is where you're set go path to slash home slash Mike slash in order to find my source code. Now, there in a workspace that are interesting. And we code library. And that's been. So anytime is created, it's going to be put into that that bin segment to our path, the last directory that you might find in compiling something, and it's going to generate going to be a fully compiled application, for example, if we're taking a third party application, then the pkg directory is where stored. And the reason those are created is time. So when you compile your go application, source files in that directory have changed hasn't, then it's not going to recompile that them into the binary that it's creating for out. Because that's getting a little bit cluttered. go code. Now, there's a lot of editors that you is just one, but feel free to explore there's probably a go plugin for it. And all So I'm going to show you the one that I've code, now might be a little bit surprising this really awesome stuff for the open source best development experiences that you're likely product running on Linux. So I've already installed can come here to code Visual Studio Comm. It's going to give you the binaries. In this this.db file and install that onto my system. by simply typing code in my application launcher, in my taskbar. So as soon as I run that, I'm see I've already opened up a folder here, by simply file open, and then pick your folder going to be working with code. But there is Visual Studio code is quite ready to go. And going to allow us to work with go code. And extensions, then I have a list of all sorts Studio code. Now, right here is the go extension but I would strongly recommend you use this It offers a lot of capability, it really makes for developing go, okay, and as fast as that because it's been cashed from earlier. And go application. So let me go ahead into this a folder that's going to contain my source just plug in your source code right here in that the standard structure that you're going your application is going to be in source in this case, if I was going to keep this github.com. And then underneath that, my GitHub about why I called it that. And then I would this maybe first app, and that's the folder And the reason for that is if you think about called first app, when I go get that, it's want to create your applications following my first file, and I will call that main go. So the first thing that I'm going to add is it looks like I expected something to happen because yeah, he told me that I needed to to go ahead and do that. So I'm going to exit right back off, but it has to initialize the to see. And that is that the NGO plugin has that it needs in order to provide me all the for Visual Studio code is actually like a takes advantage of these language services, go lint isn't available on my system. And capabilities. So basically, the go plugin, nice thing about that is if you decide to is pretty much the same, because they're all to provide you the capabilities that you have something go ahead and install all. And you libraries that it's installing for me. Okay, about a minute to install all those dependencies. experience in your own environment. Now, before put some quotation marks around this package, ready to start actually building out my program. here. And we haven't talked too much about about packages, packages, or how code is organized if I want to build a web application, then you see here, in order to set up my web request simple Hello, go example. And so I'm just that the NGO plugin for Visual Studio Code available on my go path is going to be found function called main. And inside of that, that I get autocomplete functionality here. print ln function, and it gives me the signature that in here. And the I just want to say hello, of Visual Studio code, you do have the ability a terminal right here inside of the editor. that I have in order to run my application. use gos run command, as you see here, and my source code. So if I come and I just keep slash github.com, slash vianne, si MKE slash then it will compile that temporarily, and third party libraries. So the FMT package good way to get a really quick run. Another go build and go build takes the actual package the first app package. Now, if it finds a going to compile that as an executable, like I can go ahead and run that. Now the last go install is actually expecting to be pointed it's going to install that into your bin folder. go to github.com, my username for GitHub, the package address, I'm not using the folder in my main directory. But if I come into this here. So if I come back to my terminal, bin printed out again. Okay, so the last thing to the terminal, so you see how we have all over here in this code directory. If I come is go lib, and look at that, you'll see that here. Because now I've got three source folders. that I've got quite a few packages. So now cluttering up my main workspace. They're all on my development in my code folder. Now the is over in the NGO installation directory. that I have this directory called source. a valid go workspace. So if I come in here are exactly the go standard library. So here's bit the net package, if I go into the net HTTP package. If I come into the HTTP package, source codes for all of the modules that you I follow that through, over here, scroll down that are available in here? Well, all of those if you have any questions about how any one configured, you can jump right into the source the last couple of videos, we've laid some the features of go and working through setting today is the day that we're going to start by discussing how to work with variables. variables, there's several topics that we're by learning how to declare variables. Then considers read declaration variables. And talk about visibility, where we're going to learn how we can control what aspects of then we'll talk about naming conventions. about how to convert variables from one type started. So I'm going to be using the playground you can follow along whether you've set up to follow along online. So as you can see, got this one statement program, which is just the bottom of the screen, when I click this ever do one thing because we're passing in in the number, say 42, and run it, then we this print ln function, it's only going to a little bit more flexibility to our application, actually three different ways to declare variables one of those. And then we'll talk a little So the first thing that we can do is actually done using this kind of a statement. So we're we're going to have the name of the variable from another strongly typed language, this you might be expecting to see something like And if you think about it, the way gos structures, it. So I'm going to declare a variable called way you declare variables and go, it's pretty might look a little bit odd when you first becomes intuitive. Now that we have our variable to it. And we'll do that simply with the equals go ahead and replace this with an AI, run variables in go can vary, we can go ahead we run again, we get the value 27 printed only ever do one thing at a time, the program actually influence the value that's printed and get rid of this, and then explore another of the things that we trying to do and go need multiple lines, then we'll go ahead and more verbose than we have to. So we can actually So we can initialize the variable i as an line. So if we go ahead and run this, then out. Now, this is actually still making us Because since we're assigning the value 42 out what data type it needs to have. So we for us by replacing all this text with this this colon equal operator and the value 42, concise way of setting things up. Now, where let me go ahead and add them back in so we i equals 42. And then we'll use var j integer going to be equal to 99. So we have these three different formats. of these? Well, the nice thing about this when you want to declare a variable but you're if you want to declare variable in the scope loop or something like that, that sets up variable is actually going to be assigned, The second syntax is valuable, if go doesn't the type that you really want assign to it. print statement here. And I'm going to need to make things happy for us. So let me go F. And what this is going to do is it's going and print things out that way. So we'll print type of the variable, and then I'll pass in the value 27. And no big surprise, it's an example, a floating point number? Well, with this to float 32. When we run this, then go point number. Now, if we tried that with K, this over to use K and run, then you see that And we can influence that a little bit by give a hint, making that a float 64. But there's initialize a float 32. For example, go is or it's a float 64 type. So if you need a syntax is going to be valuable for you. Now how we can declare variables. Now we've been of a function. Well, another way that you level. Now when you're doing it at the package you actually have to use the full declaration integer set equal to 42. So that works, come this with I. And you see that we have the like we have before, we can go ahead and tell compiler recognizes, well, I can make 42 a be a problem at all. Now, of course, if you no idea how to convert the string food to to fail on you. Another thing that we can create a block of variables that are declared Let me just drop in some variables that we see, I've got a little bit of Doctor Who has that's going to print out some information got a variable actor name, that's going to name, which doctor she worked with, and what like this, things are actually a little bit go to be as clear and concise as possible. things up a little bit. So what we can do section with a VAR block. And then we can And now all of these variables are going to var block. And we can actually show that they're related. That's a design decision. But we that were related to a different context. that was going to be an integer initialized blocks at the package level. And that's just a little better, and keep your code a little to show you and let me just drop in some code to read Eclair them. So you can see in this application, we're scope, then I'm declaring it here inside of it here on line 11. Now, if I try and run And the error comes on line 11 here, because the value of i 13. But I can't declare a new already declared on line 10. And you can't However, if I get rid of this line, notice the value 42. So even though I is declared level, and once inside of the main function, variable with the innermost scope actually So the package level is still available, but it's being hidden by the declaration in that by copying this line up here and running this. And now you see I get 27, the shadow Variable setting equal to 42. And value of i. Now another interesting thing have to be used. So let me just drop in this I'm declaring a variable, I'm setting it equal j, setting it equal to 13. But I'm only using if I do, I actually get yelled at, because of the things that's going to keep your go local variable that's declared and not used, And the reason that's really valuable is as features are added and old features are deprecated, code hanging around inside of your functions. and those variables are no longer used, then see that you can make sure that you can clean know about when you're working with variables two sets of rules that you're going to need visibility of the variable and go. And the So notice that I've been creating lowercase the case in NGO, because if I'm declaring package level, and I declared as an integer, that, then that lowercase variable name actually package. Now, this is a main package. And when we get into working with packages, this variables are scoped to the package, which can't see it and can't work with it. But if what's going to trigger the go compiler to So it's a very simple naming convention. And for variables in go. If you have it at the to the package, so any file in the same package at the package level, then it's export at And the third scope is block scope. So when establishing a block scope. So when we declare variable is scoped to the block. And so that's Now beyond that, it's important to understand a couple rules that we need to follow. The should reflect the life of the variable. So a variable i, and we're using it right away. acceptable. And this is going to be especially loops and things like that, it's very common names, because the lifespan of that variable you have to keep the meaning of that variable if you're declaring a variable that you use to use a longer name. So for example, if this our companion was on, so say, season 11. And then we'd want to use a name something like a package level variable, and that package a few other places, then that's where you're name. Now, you still shouldn't get crazy, names if you can avoid it. So keep your names names of those exported or package level variables of that source file understands the meaning is how to work with acronyms, because in other URL, and then maybe this is http google.com. You might see a variables name like this. to keep these acronyms as all uppercase. So URL, the URL should be all uppercase. Similarly, you see an acronym, make sure that that's it's very clear, we're used to seeing URL this variable, it's very clear that you're about an HTTP request that reads a little those lowercase. So just some rules to keep the next example that I want to show you is type to another. So notice that I have two eight, and then I'm declaring as an integer variable j, that's going to be a floating to actually treat it as a floating point number I do that is using this conversion operator. is being used as a function. And in fact, So when I run this program, you see that the 42, as an integer, the second print statement been coerced into being a floating point number, Because if you go the other way, so for example, then I convert that and run it, it looks like point number can have a decimal on it. So conversion. So the important thing about this I just tried to do this, then I'm actually go is not going to risk the possibility of So you have to do an explicit conversion, your responsibility to understand if you're thing that's important to know is if I decide case, to try and convert an integer into a it out to a log file. Well, if I run this, prints out Okay, 42. And that's an integer, of type string, what the heck happened there? to understand how strings work with go, a So what happens when we asked the application it looks for what Unicode character is set asterisk. So if you want to convert back and actually going to need to pull in the string go Lang under packages. If you scroll down And this is going to expose all sorts of functions convert back and forth between strings and want to do is use the string conversion packages that's the I two, that's the two and then run that, now you see that it properly converts it out for us. So if you need to work with go ahead and use that string conversion package. just keep in mind, you can't implicitly do it. And if you need to do that, then you can so we just covered quite a bit of ground. talked about throughout this video. Okay, there's quite a few things to keep in go through and review what we talked about. three different ways to declare variables. and then initialize it later, we saw that same time. And then we also saw that we can version of declaring and initializing a variable. to assign to that. Now normally, you're going really going to use the second version is And then the first version is sometimes useful. scope than you're actually going to initialize declare a variable. So within the same scope, we can continue to reassign values to it, variable in a package scope, for example, and that's going to shadow the variable at be used in a go application. So if you declare used in the scope that it's declared or one trigger a compiler error. And you're going your application is going to run. And again, evolves, and it continues to be refactored you don't have all these old variables hanging when they're not being used for anything anymore. The first thing that you need to know is when a lowercase first letter means that it's scoped files that are in the same package have access first letter, then it's going to be exported variable at that point. There is no private the source code itself. However, you can scope the block instead of declaring it at the package And there are really two naming conventions means you uppercase, the first letter, and you don't want to separate the words in the to have them all in lowercase, you don't want Pascal or camel casing rules. The only exception all of the letters in the acronym should be be as short as you reasonably can get them. variable, say, for example, a counter in a name is perfectly acceptable. However, if lifespan, say, for example, it's used in a from the package, then having a longer more that you should consider. However, please and concise as possible. And the last thing how these work a little bit differently than you would have to put the type in params, it acts more like a function. If we want to number, then we use float 32 as a function, going to do the type conversion for us, we type conversion. So if you try and take a integer, goes going to throw a compile time possibility of losing information through to do a type conversion that might lose information, that you're making the decision. And then in order to make sure that information hasn't we're working with strings, then type conversions order to handle the conversion between integers we can use that string conversion package sure that the conversions happen the way that I want to do is introduce the primitive types Now, we're not going to be talking about every certainly collections and some more complicated bit later. Today, I want to focus on three and go. We'll start by talking about the Boolean And in that category, we have integers, floating we'll move on to the text types. Okay, so to cover. So let's go ahead and get started data in go. boolean data is probably the simplest And it represents two states, you either have you a simple example of working with Boolean make it of type bool. So that's the data type a Boolean. And we can set it equal to A values. and then we can go ahead and print out using fancy printf statement here, we can print if we run that, we see that the Boolean true type is Boolean. So we can also initialize false is also a Boolean. Now there's a couple perhaps one of the most common is to use them creating an application and you want to store when a report is generated. Well, you can if they want that report or false if they common case for using Boolean and go is as ready to talk about logical tests quite yet. in those tests. So if we create a simple variable if one equals one, and then create another two. Now, the double equals operator is called checking to see if the item on the left is obviously equals the number one, and one, two. So if we print out the value of those see that a Boolean is actually generated as we get into talking about logical tests, we'll logical tests that we can use. But this is see looks like I need to add a new line operator in fact, generate the Boolean true and the Now the other thing that's important to know initialize a variable, Ingo, it actually has of n and m in this example here, but what the value of that, well, in some languages, would have no control over what printed out, it has a zero value in the zero value for to worry about initializing variables every you can certainly leave it like that. So Boolean to get into are the numeric types. And these of all of the different types of numbers that a rich array of numeric types to choose from. about is the zero value. And the zero value or the equivalent of zero for that numeric types. So the first type of integers that And those have several different data types. of unspecified size. And I say unspecified it as a different size. Now, the one thing environment, and it will be at least 32 bits, on the system that you're running on. And So if we do something like n equals 42, and see that we get the value 42. And it's of So we can have eight bit integers, which can 16 bit integers, which can go from negative which can go from approximately negative to really big number, you can go with 64 bit and minus nine quintillion. So if you need a very large application that you're working to look into the big package from the math numbers. So you can't get a number big enough Although working with numbers at large, you're the numbers aren't going to be quite as easy that we're talking about here. Now related So we have the value 42 here, and just so And I'll just pick at you and 16 and assign and run that. And you see that now we have unsigned integer for every signed integer, eight bit integer which can go from zero to a 32 bit unsigned integer. Now, what we don't But we do have a type byte. And a byte is And the reason we have that is because the because that's what a lot of data streams these integer types, and again, unsigned unsigned got several different arithmetic operations language. So if I just dropped in this example, set equal to 10. And we've got another integer basic arithmetic operations that are available us. So we can add, we can subtract, we can multiply, here is actually used for the remainder. So three is 1310, minus three is seven, and so then the one that you might not expect is is three, remainder one. And so we get the an integer by an integer, you have to get during the operation. So when we do this, and we dropped the remainder. Now, if the remainder operator is for. And then we can just like when we're doing division, we can't an integer can't give us a floating point to add to two integers of different types. the integer, a set equal to 10, and an eight try and add those together, we're actually be able to do that, theoretically, it's very, across types without your consent. So in order to do a type conversion on one of the variables So just like we talked about in the last video, data conversion. This is another example. go is not going to make that assumption for Now a couple of other operations that we have in this example, we see the full Bit operators we've got the OR operator, we've got the exclusive Now what's going to happen when we run this? results. So you see that if we take a and get 11. And these might not make a lot of bit, let me put in the binary representation these are doing. So 10 is 1010, in binary operation, that's going to look for what bits number. So as we can see, we've got four bits Actually, these are 32, or 64 bits long, but of these numbers. So let's look at the four then we see actually, if we add these together, is two, so 10, and three equals two. Now if is set, so we get one, because a has the first both have the third bits set, so we're going set. So we'll have that. So now we end up which equals 11. Exclusive OR means either not both. So in that case, we're going to and the OR operation is that third bit where not going to include that. Now in the end within not, it's going to be set true only set. So since the first bit is set in a, we're second bit set, so we're going to include not going to include that. And B has the fourth So we get 0100, which is equivalent to the work. The last example that I have to show So when we have this example here, the first three places. And the second is going a bit and see what that's going to do. And so we understand that, let me go ahead and put in going on. So eight is really two to the third basically adding to that exponent, as long really, what we're going to do is we're going it by two to the third, which is equivalent 248 1632 64. So that's how we get the 64. going to take our original number, and we're we're shifting, so we're going to divide it going to get two raised to the zero power. the zero power is one. And so that's how those operations work. The the floating point types. So we have a lot a lot of different size numbers. But with so they can be positive or negative integers So in order to store decimal numbers in go, Now the floating point numbers in go follow we're going to pull out two of the types. and 64 bit floating point numbers. So if you're you can store numbers between plus or minus way up to 3.4 times 10 to the 38. So from If you need even more precision than that, go from plus or minus 2.23 times 10 to the 10 to the 308. So how do we create floating of how we can do that. So line eight here flooding point literals almost all the time. it equal to 3.14. And away we go. This next notation. So we can use 13.7 times 10 to the short form iE 72nd to stand for that 10 to going to get the final result here, of 2.1 But notice we didn't get any errors. So all okay, so that's how we can work with floating declare these We can use, let me just do var that. And that's how you're going to declare this number is a little big, because we can I comment that line out, things are going this a floating point 64, then we can restore important. If you're going to use the initializer be initialized to a float 64. So keep in mind, float 64 and float 30 twos. So if you're just to want to make sure that everything's working about it, the compiler will complain at you, that everything's working properly. Okay. me jump in a couple of those. And you can with floating point numbers. So if I run this, multiplying dividing two numbers together. we divided A by B, we did in fact get a decimal floating point numbers on both sides, we can fact, we have to get a floating point result. remainder operator available that is only don't have the bitwise operators or the bit with those, you're going to have to work with primitive that we have available in go is of exciting because this is fairly rare in complex numbers are actually treated as a be used as a very powerful language for data you can see a very basic declaration of a complex numbers. There's complex 64, and complex basically taking a float 64 plus a float 64, and imaginary parts. Now here, I've got a two I, if I go ahead and run that, you see I and that's complex 64. So goes parser understands it uses that when you're creating your variable. because AI is considered special. And we can plus two I down here and the result. Now what can do addition, subtraction, multiplication, numbers defined here. If I run this, then parts are added together, and the imaginary divide whatever operation we're applying. this down. So if I come back to our first I, not every operation that I'm going to do work as a complex number. So what happens part? Well, in order to do that, we actually So let me wrap this in here with a call to follow that up with its partner, which is to do is those are going to look at the complex to pull out the real part or the imaginary 64 and complex 128. So if you run this on function are going to give you float 30 twos going to give you float 64 is out because So if we run this, we see that we get float run this again, then we're going to get float complex number into the real and imaginary need to know the complement of these two functions along in your program, and all of a sudden you do that, because you can't use this literal another function. And that's the complex function. is the real part. And the second number is wipe out this line. Get rid of these real see that we can take two floating point numbers. point 60 fours because we're making a complex the last data type that I want to talk about two basic categories. One, I can talk a lot on. So the first text type that we have available any UTF eight character, so that makes it cannot encode every type of character that's type which we'll talk about in a second. But here. So here I've got a string literal, this and its type. So if I go ahead and run this, it's of type string. No big surprise here. is I can actually treat it sort of like an yet. But I can actually treat this string I do something like this, I'm actually going and go are zero based. So I'm going to look string, which is the letter II. So if I run value 105. And that's a un eight. So what is that strings and go are actually aliases this guy back, since a byte is just an alias back. Now, strings are generally immutable. I can't do something like this, if I tried the full string here and run this, then I few things wrong with this. The first thing I'd have to do a conversion. The second thing Now with the numeric types, I should do that can perform with it, there is one arithmetic do with strings, and that is string concatenation. So in this example, I've got the string s in the printf statement, I'm adding s&amp;s two the value in the type. So if I run this, you and it gives us the result. Now another thing convert them to collections of bytes, which example, I'm starting with a string, this to this collection of bytes. And I'm going that, we actually get this as a string comes for each character in that string. And then UN eights, which is a type alias for bytes. good question. A lot of the functions that byte slices. And that makes them much more work with hard coded strings. So for example, service call, if you want to send a string of bytes. But if you want to send a file back, of bytes, too. So you can work with those line endings and things like that. So while with strings a lot as strings. When you're applications or to other services, you're ability to just convert it to a byte slice. have to work with is called a rune. Now a type in go. Because we're a string type represent any UTF 32 character. Now, UTF 32 is a little in UTF, 32, can be up to 32 bits long, it any UTF eight character, which is eight bits all sorts of tricks that they have to do in know whether the character is one, two or bit tricky to work with and go. Now we're we're just going to talk a little bit about you to some things that you can refer to if application. So if we look at this example, the difference here, if we were declaring we're declaring a single room, we use single an interesting result. Notice I get the value a little weird. And the reason for this is 30. twos. So we're strings can be converted Rooms are a true type alias. So when you talk talking about an integer 32 name, I think, implicit initialization here, we're using and explicitly declare this as a rune and And again, that's because a rune is an integer here. So if I've got a UTF 32 characters at comes from the go API's. So if I jump out let me just jump to the strings package. And here, read rune. So if you're working with you have special functions that you're going to return those values out. So if we do read then we're going to get a bite out and a potential at the byte stream, it's going to pull off size of that room, and then a potential error. you need in order to re encode that integer UTF 32 character. So things are a little bit And you're going to have to read into the with, in order to understand how to work with the primitive data types that you have to and review what we've talked about in this We covered a lot of ground in this video, bit of time to process this and really understand primitive data types and go. Now before we know that a lot of times the default data fine. So if you're working with Boolean, you're with integers, you're going to get that signed give you a floating point, 64, and so on. data type. If you need a specific data type, in order to find out what's available for talked about. The first thing that we talked out that it can take two values true or false. in some languages, a Boolean is actually an negative one for true and zero for false when back and forth between integers and things Boolean as their own type. We also talked value of false. And so if you initialize a going to receive the value false. Then we type that we talked about were the integer types with the signed integers. And there the sign integer type. There's the INT type, bits. And this is going to be the most common in your applications. But if you need a little resolution, or control over how much memory all the way from int eight, which is an eight we also have the unsigned integers where the they can't store numbers quite so large because unsigned integers can store larger numbers, have all the way through an eight bit which four, all the way through 32 bit unsigned operations that we can perform on both integer multiplication, division, and that remainder is going to give you an integer result. So So if you need that, you can use that remainder operators. So we can do and or Exclusive OR, for any integer type is going to be the literal type, and don't assign a value to it, that's you're not just going to get whatever was and you cannot mix types in the same family. of the numeric types. If you have a un 16, those together, you're going to get a compile talked about where the floating point numbers, so they follow the I triple E 754. Standard, types, the value is zero. And we have two and 64 bit versions that we can work with. that we can use to initialize them. So we exponential notation, for example, 13 e 18, e is upper or lowercase, or you can do mixed. way to initialize that. We do have addition, we can do with floating point numbers. Now the division operation is going to give us going to lose our decimal portion. The final complex numbers. The zero value of a complex 64 and 28 bit versions and the reason for imaginary component are either going to be when you add those together, that's where Some built in functions that we can work with. to create a complex number, we can use the And we can use the match function in order number. Now what the data type that comes number going in. So complex 64 is going to match function and a complex 128 is going the match function, we have the same arithmetic we can do addition, subtraction, multiplication data that we talked about, or the text types, text types. The most common one that you're Strings are represented as a collection of cannot change the value of a string after strings together with the plus operator. And a collection of bytes with this square bracket convert it to a collection of bytes. And you a string by using the string conversion. The rune represents any UTF 32 character. Now work with because of the multi step process into the UTF 32 character set. So when we're all we're working with is an alias for an and how you can use them in your NGO applications. to talk about with constants. So like we've several categories. The first thing that I constants in our NGO applications. Then we'll about untyped constants. And we'll talk about options that each one gives us. And then we'll that are called enumerated constants. And about enumeration expressions, which are going to talk about in that first enumeration discussion. is how we're going to name our constants. with the const keyword, that's going to let to work with. Now, if you've come from other going to name our constants, something like letters and separate the words with underscores. go, then the first letter is going to be uppercase. variables, if we've got an uppercase first is going to be exported. And we don't always going to name our constants the same way that So if we had a variable that we wanted to it, then we would start with a lowercase first casing. And if we did want to export this character to uppercase. Now assuming that constant, then we're going to switch this let's talk about how we can create what's is created very similarly to a typed variable. the name of our constant, and then we're going we can set it equal to a value, then if we we expected it to, then we can go ahead and And we will do that by using this printf statement the constant is in fact created. It's got the type that we assigned to it. Now the reason to remain constant. So if we tried to do something the compiler throws an error, because we're Another characteristic of a constant is that for example, if I wanted to have a constant then I might be tempted to do something like I'll set it equal to the result of the sine in 1.57, which is approximately pi over two. with that is in order to determine the sine function to execute, which is not allowable constants equal to something that has to be like setting it equal to flags that you pass going to do that you can't use a constant made up of any of the primitive types that have this example, here, we've got an integer point constant and a Boolean constant. And exactly the way that we expect. We've got value and the boolean value. Now in an upcoming types and the collection types. are inherently an array and declare that to be a constant types. Now another characteristic that constants be shadowed. So if we create a constant at an integer 16, and set it equal to the value these guys. Now we've got a constant called integer 16. And then we got a constant in it's an integer type. So if we update This we see that the looks like I need to print of the constant wins. So not only can we change change the type because the inner constant that by commenting this line out, running wins. So you want to be a little careful here, it's going to feel like those values are changing. of this. But if you do get into a situation that you expect them to, this is one possible they work very similar to variables when we're line back, and set it equal to 42, and then we'll declare a variable b as an integer, we can do a plus b. And let's see what happens fact, get the ability to add a constant to a variable. And so since the constant and perform the addition operation on there. Now, if we made variable b in 16, and run this, we get when we try and add two variables of we've been talking about are these type constants, type. But we don't have to do that, we can for us. So let's just go ahead and do that we see that the constant a is inferred to that, given that the compiler is inferring happen? If we do something like this, if we going to add this constant to an integer 16? succeeds, which might be a little bit confusing. the compiler is actually doing, when it sees every instance. So the way the compiler sees we're taking a literal 42, and adding an int an integer 16. So the compiler doesn't say, and always an integer. Instead, the compiler the symbol a, and it's going to replace that can do these implicit conversions when we're that we can't really do when we're working to talk about are what are called enumerated conversation out by wiping out what we have And then I'm going to do this at the package most commonly applied, you could do these your application. So I'm going to declare an untyped constant. And I'm going to set So when I run this, you see that a is evaluated to have the type integer. So what is Iota? we're creating what are called enumerated constant isn't terribly valuable. But one is I can actually work with them in a constant can create another constant set that equal equal to it, let's go ahead and clean up this to be. So we don't need to be printing that two more times, switching to B, and C. So we get the result we actually see Iota is evaluated. So the first constant that's assigned know another special feature that we can take assign the value of a constant after the first the pattern of assignments. So in this example, and C don't have a value assigned. But since the constants in this block, when we run, because the compiler is going to apply the Iota and C equals Iota for us. Now that value So we create another constant block. And in and set that equal to Iota, copy this line, a two, then what we're gonna find is Iota block. And what that lets you do is you can ensure that they have different values. And you can start another constant block and ensure between the values in one constant block in use this? Well, let me just drop in this simple we're setting up a constant block, where maybe in a veterinarian clinic so that our narine or maybe we can take his neck specialist to. setting the cat specialist equal to Iota. variable and setting its value equal to cat type is a cat specialist, then I in fact, And this also works if I, for example, use to be a dog specialist run that, then that's looks really good here, right? And this is However, one thing that I would warn you about is what happens it to a type? Well, if I check to see if it's But remember, what is the initial value of the zero value for an integer. And so in fact, type, it does show up as the value can't specialist. couple of approaches that we can take here. constant as an error value. So we can set statement anymore. And now when we check to we get the value false because cat specialists is no longer the zero value of the integer. to check to see if a value hasn't been assigned specialist. And then you can check to see of that constant. And if it is, you can handle because presumably, you expect that to be initialized against that, and there's no reasonable way of this underscore symbol, which is goes one value of a write only variable? Well, with have to start with zero. But if we don't care to assign the memory to it. So we can use in quite a few places in our go applications. is yes, I know you're going to generate a ahead and throw that away. So if we run our fine. But in this case, we can't actually Now the ability to create it lists of enumerated things don't actually stop there. And the has to be able to be determined at compile is going to allow us to do for example, we then we get false again. But what happens if we do that, and we're going to have to got evaluated. So the first line line eight plus five, the next line cat specialist, Iota specialist is equal to the value six, dog is eight. So this can be valuable if you need use case for this is to use the bit shifting to our primitive type, we can apply here as we can do addition, subtraction, multiplication we can do the bitwise operations. And we can interesting use cases that we can take advantage the ability to raise two powers because raising package. So we can't do that in our constant things to the power of two, because every actually multiplying it by two. So we have from the effect of go article on golang.org. of a constant block that's giving you constants gigabyte, terabyte, petabyte, and so on. So done is initialize the file size to some arbitrary And this is basically going to format a result literal string GB afterward. So this string format a floating point number, and I'm going a literal GB, that's going to be printed in going to be used to fill this in. And that's Now you notice this constant block is set shift that value 10 times Iota. So the first so we're basically going to multiply this multiply by two to the hundreds for the megabyte, on. So when we run this, we get a really convenient a human readable format. And in the effective a switch block, which we haven't talked about. you're going to use based on the size of the way to format this relatively difficult number Now another thing that can be very valuable Boolean flags inside of a single byte. So example of that. So let's just say that we've users and those users have certain roles. defining various roles that we can have. So be at the headquarters or out in the field or see the monetary values. And then there properties in Africa, can you see properties So in order to define these constants, what bit shifted biota. So the first constant is a literal one, the second one is one bit shifted then eight, and then 16, and so on. So what I have is each one of these constants So down here in the main program, I'm defining together is admin can see financials and can going to be set to true if one of the values the binary representation of 0000001. I think by one can see financials is going to end up with the value 100000. And so when we order byte that has these three flags set to true. eight access roles for user into a single information extremely efficiently. So if I admin, I can go ahead and print his admin, order to determine if that's valid or not, here. So I can take the constant is admin, to do is that's going to apply what's called in the is admin constant, and our roles are an admin, we're going to have the value one that to the is admin constant. So when I run going to get the value true. Now, if I check me go ahead and copy this down. And then let's we'll put that in here. And it's exactly the our mask. If we run this, we see that is headquarters return here, and then run this again. And So we can very quickly and very efficiently what roles and access rights a user might defined with a numeration expression makes clear in our application. Okay, so let's go about in this video. constants are another going to be a part of almost every application that we learned about with constants is that So we can create a constant, we cannot assign on an inner scope from an existing constant, we can even change the type, because that constant, they have to be replaceable by the be calculable. So we're not gonna be able in order to determine the value of the constants able to do simple expressions like we talked named like variables. So if you want to export package, then you're going to use Pascal casing. value to the package, then you're going to constants work just like immutable variables. you can pass them into functions, but they constants have a little bit more flexibility. you replace that constant throughout your constant, that's how it's going to work. So similar types. So we had the value 42 defined to an integer 16, we could add that to an those would work, because the literal 42 will the enumeration types that we can work with. That allows us to start with as values zero it inside the same const block. Now the one constant values that match the zero values application, because you might have logic of the constant. And if something happens you're going to be working with zero value, that you're evaluating against. Using that Iota operator, we can expressions. So we can define the value of with any arithmetic bitwise operation, or the primitive type that the constant and representing, types that we have available and go arrays slices. So I want to start a discussion with going to talk about how to create them the what's going on with our arrays. And then and see how we can use those in our applications, but we're going to switch over to slices. create slices, we'll learn the built in functions on with our slices. And then we'll do some go ahead and get started by learning how to want to discuss about arrays is the use case they used for? So let me just drop in an example, that's going to work with the grades of students to end up with an application something like grade two, grade three, and then we can print this. And we see that we get the scores 9785 But we got a lot of problems here, because many grades we have to work with, at the time working with these grades as a collection and that's going to solve all of our problems. let's go ahead and delete this code here. to hold the grades for us. Now the way we the size of the array. So we're going to use an index that's going to be the number of the type of data that the array is going to store one type of data. So in this case, we're up to three elements. If we wanted to hold an array of strings, then we would type this at the time that you're declaring the array, then we can use this initializer syntax To put in the same scores that we had before print statement here, and add our grades as we have all of the grades printed out together now, that's a convenient collector. As we things like that, we're going to really find slices and the other collection types is a data. Now, another advantage that we have laid out in memory. So if you declare three it's impossible to know how they're going However, we know by the design of the language which means accessing the various elements our data together in arrays, not only is it applications generally a little bit faster. here is if you look at it, we're actually we have this syntax here, where we're saying array, but then we're adding three elements you're going to be initializing an array literal replace the size with these three dots here. that's just large enough to hold the data syntax. So in this case, we're going to get that's implied by the fact that in this literal we can also declare an array that has a certain something like this, if we declare an array element array that's going to hold strings. array. So if we print out, students, make run this, then we see that we have an array element array that can hold strings. But obviously, in order to specify a value in the array, to call upon the array, and then we're going within the array. So in this case, we're working And then let's just assign the name Lisa to then we can go ahead and print out our array have, I always forget to add this line return of students that's full of empty strings. that first element. Now you may be wondering the reason is related to how arrays are made we talk about students as the name of the to have a pointer or it's going to remember And then the index that we pass in this case to walk forward. So it knows that when it And so it's going to walk that many strings. head of the students array moved forward zero the first element of our array. So we can in here, we can see what it would take to the zeroeth element to Lisa, the first element So if we print that out, we see the expected And it doesn't matter what order we work with that they do flip around in the array, we Now if we want to get add a specific element bracket syntax again, and dereference the and then change our label again. So we're which is index one, then we can go ahead and element has the value of Arnold. So we can assign values to the array, as well as to Now another thing that we can do is we can we created the array up on line eight. So this, but there may be a situation where you array that you're working with. And the way length function. So if I drop in another print we can get the number of students in array in the array. So if we run this, then we see three and that's going to print out the size the array to say five then the results of but the size of the array does. Now one thing can be made up of any type, it just always So we've been working with arrays of integers with primitives. But this example here shows else. So in this case, we've got an array with some linear algebra. And we need the used pretty often in linear algebra. So this matrix. So the first row is going to hold hold 010. And the third row is going to hold then we see that we do in fact, get those a little bit easier to see is using this way of arrays, and then we're going to initialize reads a little bit cleaner, and might be a going on. And if we run this, we get the exact to talk about with arrays is something that's than in other languages. And that is that in a lot of languages, when you create an in that array. So if you pass things around, data. But in go, that's not true. When you here, you're actually creating a literal copy. data is pointing to a different set of data, length of the array. So if I run this, you'll eight, I assigned an array on line nine, I to a, and then on line 10, I changed the second what you see is that when I print out the B has the new values of 153. So when you're careful, because copying arrays, especially arrays into a function, go is going to copy with a three element array, that's not a big your array that could slow your program down want to have this behavior? Well, we haven't a hint right now in order to cover this completely. And that is this idea of pointers. So the is that the value B is assigned to a copy operation, which is this character here, then the same data that he has. Now we'll get into the long and the short of it is if I run this, So A is the array itself, and B is pointing 10, we're actually changing the same underlying we see that the array has changed, as well they happen to be exactly the same array. a lot of use cases where you can use arrays have a fixed size that has to be known at So in go, the most common use case for using So let's take a look at a slice. So the first more items in this example here. So we'll And then we'll change this over to slice syntax. by eliminating these three dots here. So a using the square brackets, the type of data we can pass in the initialized data. So we the values 123, it looks exactly like an array. do with an array we can do with a slice as to illustrate that, we have the length function we have the length function with a slice as get the length of three. So we initialize so the length function gives us a value of that we have available with slices, and that of elements in the slice doesn't necessarily the slice is really a projection of that underlying only be looking at a small piece of it. Now function returns the value three. So the underlying But as we go along here, we'll see how we capacity are different, and why that's a very Now unlike Like arrays, where we have this syntax here, and order to point to the same data slices are So they refer to the same underlying data. when we ran this with an array, we saw that done. So if we run this, we see that A and array. And so when we change the value in is one thing that you're going to have to If you got multiple slices pointing to the mind, if one of those slices changes the underlying in your application. Now, so far, we've only a slice. And that's what we're seeing here ways that we can create slices. And that is see on line eight, we're creating a slice on line nine, we're creating a slice B, and between. And what that's going to do is, it's elements of what it's referring to. So it's of a online 10, we're creating a slight C, of the parent, and copy all the values after with index three, which is, of course, the so this is going to copy four through 10, going to do the other syntax, and that's going the sixth element. And that's the literal sixth element, the sixth element, which is going to have see an inner slice. So we're going to copy into our new slice. So let's go ahead and the first line printed out is the original copy of that slice that's copying all of the the fourth element on so we see the number up to the sixth element, so we get the values out is a slice from three to six. And so we're printed out. So that can be a little bit confusing, meaning than the second number. So basically, number is XClusive. So for example, if we from index three, up to but not including can look at it. Now one thing to keep in mind, point at the same underlying data. So if we the a slice and run this again, notice all to the same underlying array. So each one in their results. And each one of those gets to know about these slicing operations is here, but they can also work with arrays. in here, it's actually going to turn a into result. And that's because slicing operations So whatever type of data you're working with, use these slicing operations. Now the last a slice is using what's called the make function. to work with. So if I delete all this, and built in make function. And this takes two arguments. So the first thing we're going to create. So you can use make for several going to be talking about making slices. So a slice of integers. The second argument is this case, I want to start with three elements. the slice that we created here. And we'll So we'll print out the values of the slice, the slice. So they run this, no big surprise gets set to the zero value, which is what we initialize a variable, we expect it to true for slices just like it's true for primitives. three, when we ask for the capacity, that's third argument to the make function, and that's the slice has an underlying array, and they this, we see that we've created a slice of but the underlying array has 100 elements reason is because unlike arrays, slices don't we can actually add elements and remove elements of that, let me drop in another example here. integers that starts with no elements in it. we expect, we see an empty slice length of an element to this slice, I can use the built arguments, the first is going to be the source So I'm going to start with a and I'm going all I want to do is add the number one to the value of the slice the length of the slice I go ahead and run this, we see that in the in there, we have the length of one, and notice What happened here is when we initialize a location for the slice. And since it didn't an underlying array of zero elements for us. it couldn't fit in a zero element array. So go does is it copies all of the existing elements, got a larger size. So when we reassigned, has a capacity of two, and then it put the value one into that slices like this, things are pretty cheap array quite a few times. However, as things very expensive. And that's why we have that we know the capacity is going to be somewhere start there. And that way, as you're appending not constantly copying the underlying array the append function can take two or more arguments. a variadic function. So everything after the as a value to append to the slice passed in here, we're actually going to append the values if we run this guy, we see that we get the the length is five, like we might expect. in stone, how go resize of the arrays. But it fills up the underlying array with a slice, to create a new array, and it's actually going So if we start with an empty slice, we see zero, then we'll go to 248 1632, and 64 elements. you're just over one of those powers of two, consumed that you're never going to be using. up with a decent first estimate, then that's situation that you're going to run into is slice of elements, and you want to concatenate slice created that has all of the elements of the second slice. So you might want to over to a literal slice, you might want to unfortunately, is not going to work. If I going to get go complaining to us. And that's function has to have the type of the slice. accept a slice of integers. But we do have called an NGO in JavaScript, they would call three dots after the slice, it's actually arguments. So if we run this, this is going if this weren't a slice at all, it's basically into looking something like this. So these feature to know about if you have slices and some other common operations that you might just say that we're treating our slices a onto the stack and pop elements off of the function is going to allow us to push elements off? Well, we have a couple of different ways what's called a shift operation, which means slice, then we can do this operation here. to create a new slice that starts at index and takes everything else from that. So if we'll see that that has the elements two through of the end, then you're going to have to use the initial elements. So we're going to start operation, figure out the length of the slice. that's too large, we actually want to remove minus one. And this will have the values one remove an element from the beginning of the if you want to remove an element from the Well, here, things get a little bit hairy. have to concatenate two slices together, the up to where we want to remove the element. elements, by doing a slice of a, and passing create, then we have to concatenate to that to remove. So in this case, we're removing on and then we have to use this spread operation append function is happy. So let's go ahead here. And now we see that we've got the elements an element from the slice, they have to be mind, we're working with references to the slicing operations, there's one underlying underlying array. So just to show you the and print the value of a out here, and then ahead and run that. And you see we start out we do our slicing operation, removing the was what we might expect. But then when we we have that slice that V represents which five is duplicated. So this is something to be removing elements from the inside of a 10, make sure that you don't have any other you're going to get some unexpected behavior. like this, and you really, really need a to B to change? Well, unfortunately, we don't Because what we're going to need to do is that doesn't point to the same underlying So when we get to the looping section, we'll have all the tools that you need in order thing I can say is be aware of this behavior. understand that you're going to have to do sure that your application responds correctly. with the raising of slices. Let's head into arrays and slices are very common in NGO applications. the place as you start to work more and more has really helped you understand what arrays can work with them. We started our discussion there are collections of items with the same strings and integers and things like that does collect them all together. And as we and things like that, we're going to find can work with, when we're basing our data So when you create an array, you have to specify it can never change. So you can't make them are three different ways that we can declare you see on this first line, where we're going we use a literal that's going to initialize notation that uses three dots instead of that bit more robust in your application design. you need to add another literal, you don't array, it's going to update automatically. declare a zero data array. In this case, we're each one of those integers is going to start how arrays are zero based. So we're going So the first element in the array has the one, and so on. So in this example, if we to get the value three out, we have the Len the array in case you need to know that some to have a way to be able to handle that robustly. at design time how big that array is, you size of the array. Anytime you're moving the data. So if you have a three element array, three elements are going to be copied to a be working with an independent copy. So that if you change that copied array unexpected array, that won't happen. And it can be very allocated a second time. Then we moved on to discuss slices and how of fact, they're backed by an array. So every an array that's holding all of that data for saw that we can create a slice by slicing the literal style that we can use, which is for we just leave those three dots out, because can be determined at runtime, we also saw pass two arguments to the make function, the we want to create. So in this example, we're second parameter is going to determine the If we need a capacity that's different than parameter into the make function. And that's of that initial length, the Len function returns capacity function returns the length of the you want to control the resizing of the slice, capacity to function to understand when you're use the append function to add an element is it's going to take in a parent slice, and to add to that slice. Now through the course that exceeds the capacity of the underlying to trigger a copy operation. And all of those a new location. So be aware of that. If you're end up resizing, a lot of times your application think about using that three parameter make the slice close to where you need it to be. application. Keep in mind that assigning a to the same underlying array. So if you manipulate to affect all the other slices that are pointing about an example where we created a slice And we saw how that actually affected the that we weren't expecting. I want to complete by talking about the two remaining collection types are mapped in structs. So we'll start talk about what they are, how we can create within the maps, then we'll move on to the are, how we can create them, then we'll move to have to be aware of as we're working with embedding, and how we can use that to have of functionality from a base struct, then talking about a concept called tags, and how information about the fields within our structs the struct get additional information about so let's begin our discussion by talking about the first thing that we're going to need to maps is what exactly a map is. And I think is by showing you a map. So we have an example And this represents a map of US state names So what we see here is a map is going to take names, and it's going to map that over to of that state. So what this provides us is to map one key type over to one value type. Now there's a couple of constraints we're see up in the Declaration on line eight, we're So all of the keys in this map have to be to be of type integer. Now we can use a lot use any type for the value. But when we declare every key value pair within the map. So if a map looks like when we print it. And it's get an idea of what's going on. So we see So we get California, Texas, Florida, New one thing that I just alluded to is that we we don't have an infinite number of options. creating a map is they have to be able to that we're working with can do that. So Boolean types, strings, pointers, interfaces, structs called channels. All of those can be tested a string variable is equivalent to another cannot be used for equivalency checking. And So for example, if we create a map called to map slices of integers over two strings. and then we print that out, then you would get an error because we've got an invalid a map. However, if we had an index here, then a successful printout, of course, the map see this empty map right here. But we were an array is a valid key type, but a slice we can create a map? Well, you see, the first this is going to probably be the most common just need to declare the type of map. And we see here on line eight, where we're going we're going to list the type of the key, and to list the type of the value. Another way in make function again. Now we first saw the But we can use that once again here. So if equal to the result of calling the make function, we want to make. So we're going to use the the value is type integer. And now we can run this, we have to remove our m again from get the same value printed out. So this is if you don't have at the time that you're going to want to put in it. So for example, you might use this syntax. Now another option a second parameter. So if I run that like to find the intention for this. So this is length of the map that's created, the map of elements in it, but it might have some what that's for, please leave a comment down know, let me go ahead and remove this because seen that very commonly used and run this our map used to be. Now how are we going to first thing that we can do is we can pull the square brackets and typing in the value as a variable or as I'm doing here as a literal. we get the population of Ohio is 11 point values of our map. Using this syntax here. very similar syntax. So we call on the state this case, let me add the next largest state, population of 10,310,371. Now I can pull that we get that value printed out of our map. here, Georgia gets added in here. Now, something going to copy this print line here, put it notice the ordering is different. And this in mind as you're iterating through maps later the return order of a map is not guaranteed. Florida, New York, Pennsylvania, Illinois, like a slice, a slice or an array would return provided them. In a map, everything is stored returning. So even though we just added one was organized within the map, and we get it thing that I want to show you is that we can that using the built in delete function. The and then we need to provide the key that we Georgia back out, it wasn't there very long. my s here. Now if we run it, we see that ga by just calling on the map providing a new in delete function, and we can interrogate Now, an interesting thing about deleting is what do you think I'm going to get? So we part of the map. So you might expect some if I run this We get the value zero out. Now does Georgia have a population of zero? Or the key? What's going on? So for example, and run this, I get a value zero. Well, did What with what we know right now, there's way that we can interrogate our map. And that So with doing what we know, right now, we're populations. And we're asking for the key, And then we're printing out the value of that zero. Well, we can also add an optional comma, ahead and add that okay, variable to the output that this prints out the value false. So the our map, but if we add the eye back in and value true out. So if you're in a situation map or not, then you can use this comma, okay, to check for presence, then we can use that away the actual value. And then we just get nothing magic about the variable name, okay. go programs when you're using it for this to show you about maps is we can in fact, we can do that using the built in Le n function. we get the value seven, and we have let's in our map right now. So if we added another return eight. The other thing that's interesting have multiple assignments to a map, which maps into functions, the underlying data is one variable that points to a map is going demonstrate that by creating another variable And then let's go ahead and delete poor Ohio And then we can print out SP and print out that in our first result, we don't have the print statement, which is the original map, So if you start passing maps around and you keep in mind, you can have side effects on that map is referred to. Because manipulating on every other place to use. So the final today is called a struct. Now at first, you type. But go with me on this, if I drop in Now I'm in kind of a doctor who frame of mind that's talking about some information about I go ahead and run this, we can see that we're actor's name is john Pertwee, we see some reason I call this a collection type is look through 11. What we have here is a list of and companions as field names, and then a number is an integer, the actor name is a So what the struct type does is it gathers concept, in this case, a doctor. And it does have to have any constraints on the types we can mix any type of data together. And all of the other collection types we've talked arrays always have to store the same type we just talked about maps and how their keys values always have to have the same type within fields describe any type of data that we want. structs, anything that we want. So while in of collection that we're going to be talking So we see down here in the main function, declaration syntax, where I'm using named called a doctor. And we're going to use this struct doctor, we use the curly braces like And then I have a list of the field names after name colon, john Pertwee, and then campaign notice that when I'm setting something equal what kind of collection type, I'm initializing go ahead and print the entire value of the printed out, I see three, john Pertwee, and had, in his time as the doctor. Now if we then we're going to use what's called the of this struct, then we're going to put a name. And when we run this, we see that we the struct as a whole, or we can start drilling through the structure. So if we ask for the But this is a slice like any other slice. I can get Joe grant out by interrogating the companions field. Now another way that we called a positional syntax. So here, I'm listing if I go ahead and take these out, and take then I get exactly the same result as I got I would encourage you not to use it, though. maintenance problem. So for example, let's is checked into source control, and everybody's a change request Comm. And we're going to appeared in. So that's going to be another here. Well, if we use the positional syntax and go doesn't know how to map the fields that there's three values provided in the initializer. we have to find every place that we have one And we have to add, for example, a placeholder and run this and everything's working again. along, and somebody does this? Now they've this, everything looks fine. But when I asked an empty slice, because the positional syntax correct order, much better for us to go ahead those in real fast here. Now when I run this, what the field names syntax, I don't even declared in the struct go is going to figure over into the object that's created by using I have is, if I don't have any information I actually can ignore the fact that that field underlying struct without changing the usage bit more robust and change proof. So while syntax, I would strongly recommend you do lived struct. We'll talk about anonymous structs positional declaration might make sense because long. However, I would strongly recommend a type, like we're doing here on line seven, by using field names explicitly instead of I want to talk about are naming conventions. declared as Doctor with a capital D, and the in this situation, follow the rules for any capital letter, it's going to be exported letter, it's going to be internal to the package. fields, because I'm declaring the doctor type which is also in the main package has access would have access to this. So it would be but it wouldn't see any field names. So if can use them, I would have to go ahead and have to capitalize them in my declaration same result that I got before. So I forgot run that, and I get the expected result out. convention as we do with any other variable. going to import, you should use Pascal casing and things like that in your field names or on line seven, I have explicitly created a be a very common way that you're going to define a type and then everywhere you need it by its type. But we don't have to do that. see a program like this. So on line eight, struct. So instead of setting up a type, and and that's going to have a single field called condensing all of that into this single declaration else, because it's anonymous. And so it doesn't to it. But I can certainly use this just fine. notice I'm using the initializer syntax right it's very important to remember what each is paired to the struct keyword. And it's second is the initializer. And it's what's if we run this application, we see that we printed out and everything's gonna work just this is going to be used in relatively few this in situations where you need to structure a formal type. But it's normally only going if you have a data model that's coming back a projection or a subset of that data down struct in order to organize that information. So you don't have to create a formal type package for something that might be used only Now, unlike maps, structs are value types. just use the same basic manipulation that so I'm going to create another struct, and current struct, and then I'm going to manipulate to create another doctor called Tom Baker. both of these doctors out. So as you can see, doctor, and change the value, the values remain john Pertwee, another doctor has the name are referring to independent datasets. So you're actually passing copies of the same are very, very large, keep in mind, you're this. Now, just like with arrays, if we do we can use that address of operator. And when pointing to the same underlying data. A doctor pointer to the struct. So when we manipulate the Name field of the a doctor struct. The in go is a concept called embedding. Now, go language that go doesn't support traditional we don't have inheritance, and oh, my goodness, have inheritance available? Well, let me show model. It uses a model that's similar to inheritance trying to establish the is a relationship. in a traditional object oriented language, animal, and therefore a bird has a name a like its speed, and if it can fly or not, it supports composition through what's called and bird are definitely independent structs, I can say that a bird has animal like characteristics this. So I've just embedded the struct itself, like this, then how to have a named field that I'm doing this. So I'm just saying embed Now how can I use this? Well, let me drop can see, so I'm creating an instance of a So name is going to be E mu origin is going an hour, and it cannot fly. So if I print of a strange syntax with that inner type, it's a matter of fact, I can come in here And everything worked exactly like I would is inheriting the properties of animal. But syntactic sugar go is handling the delegation to the embedded animal type for you. So if see if the bird is a type of animal, it is that has no relationship to an animal other a traditional inheritance relationship where relationship, which is answering the question like characteristics is how we would say it as an animal, they cannot be used interchangeably. going to have to use something called interfaces, Now we can see in this example, that if we afterward, everything's pretty clear, we can owned by the bird struct. And we don't have struct. And that's very intentional. However, we do have to know a little bit about the this code here, clean up our formatting a So this is declaring exactly the same object, the speed is actually going to be 48 kilometers But notice what I have to do here, I have struct. So when I'm working with the literal embedding. But if I just declare the object have to be aware of it at all. Now, when should if you're talking about modeling behavior, to use. When we get into methods, we will methods to carry through into the type that we can't use them interchangeably, is a very to use interfaces when you want to describe idea? Well, if you're offering a library, a web framework, and you've got a very sophisticated to use consumers of your library to embed so that they can get useful functionality about polymorphism. And the ability to interchangeably base behavior into a custom type. And in that that I want to talk about with structs is in another example program here that we can we had before, because we don't need to structs to have a simple animal struct with the name to do is I want to add what's called a tag about this name field. So let's say for example, So let's just say that I'm working within out a form and two of the fields are providing sure that the name is required and doesn't with a tag that looks something like this. as the delimiters of the tag, and then we So my first field is going to be required. required. And then I've got a max length argument, So the value of the tag is arbitrary, you in here, but this is the conventional use sub tags. And then if you do need a key value to separate the key and the value. And then So now that we have this, how do we get at at it is using gos reflection package. So to get at the tags of a field, you have to go makes this pretty easy. So the first thing of an object that I'm working with. So I get And I have to pass in an object to this. So get them that and then I can grab a field method, and then passing in the name. In this get at the tag by asking for the tag property I do in fact, get that tag out. Now, what to my validation framework to figure out all else has to figure out what to do with that. we're then going to have to have some sort to parse this figure out that yes, required have to decide well, if required is there sure the string is non empty or whatever makes up what I have to talk about with maps and what we've talked about. In this video we types that are available and go, we talked when we talked about maps, we learned that be accessed by keys, they can be created as are accessed via the square bracket key syntax, within a map using this comma, okay syntax. and what the map is going to return is the to indicate if the value was found or not. variable is going to be the zero value of if you've got a map of strings to strings, to get an empty string returned out, if you've you're going to get the value zero. If you they all point to the same underlying data. which means that if you manipulate the data that are pointing to that same map are going to talk about the struct type, and how they're arrays and slices and maps are all collecting in that it collects any type of data together. fields can point to any valid data structure generally follow the syntax of any valid variable, if you capitalize the name of the field, then If you leave it lowercase, then that's going normally created as types. But we can create common use cases for this are very short lived to a web service call, that's only used one a variable to an existing struct, then all over to create a brand new struct. So if I not going to affect any other variables in system within go. But we can use composition want to embed one struct within another, we give it a field name. Go is then going to any calls for fields or methods in the containing top level struct doesn't contain a member also learned a little bit about tags and how that field in some way. So there's a lot of uses this to provide ways to map field names uppercase to follow JSON conventions, which we can use this, for example, to pass information could generate errors. If we need fields to or things like that, I want to start a discussion control the flow of execution in our applications. two of these tools, the if statement and the by talking about if statements. And we'll we can use them in our applications. And we're operators that are often associated with working those are and how you can use them. And then And those are the if else statement. And the talk about switch statements. And we'll start for switch statements. We'll then talk about through from one case to another in our switch special version of a switch called a type start learning about if statements. In order I want to start as simply as we can. So if just about the simplest if statement that with the if keyword as you see here on line that generates some kind of a Boolean result. a lot of time when we're talking about if results. In this case, I'm just using the result that we can come up with. And then the code that's going to execute if that Boolean we're using a literal true, then the test application, I see that I get this test is change this to a literal false, and we see because the code inside of the curly braces mind if you're coming to go from another language, Well, if we try and run this, we actually of the design decisions that was made with single line block evaluated as the result use curly braces, even if you only have one has the Boolean test right here. And that's actually another style that's very commonly would call the initializer syntax. So as you a map that's pulling out the value from a And then notice I've got this semi colon, this part here, this first part of the if allows us to run a statement and generate to work within the F block. So in this case, the map. And then I'm using that as the test execute or not, I also have access to the inside of the F test, and that variable is this, you see that I get the population of I try and work with that variable outside to get an undefined error, because the pop of that if statement. The next thing that the comparison operators that we have. I mean, Boolean values, things are going to be pretty because in a lot of applications, we need determine if the branch should execute or And let's just say that we're building some things as simple as possible. This is going because we're going to hard code the value to hard code our guests. So we're not going all. And we're not going to randomly generate the application is doing. So right now what going to try and guess we've got our guests of tests. So in line 10, we're checking to So this is the first comparison operator that we also have the greater than operator and the guests of 30, and a number of 50, we're because this first test evaluates to true. false. If I change my guest to 70, and run, the first and third evaluate to false. And 50, and run this, then I finally got it. So all you need to do is wrap this in loops, add a little bit of a user interface and you've Now there's some other operators that we have getting them into this example. So I'm just then we can take a look at them. So this first So it's going to check to see if number is the greater than or equal to operator. And I go ahead and run this, you see that we are on the number we are also greater than or So we get true true false printed here, if true true. And if we go with 70, we're going different comparison operators that you're And these work with all numeric types. They types. So if you're going to work with string with is the equality operator or the non equality type as well. Now the next thing that I want of simple validation. So if you imagine that where the user is asked to enter a number that as our guests, then we're going to need that for example, they don't enter negative test. But we can also combine multiple tests So let me drop this code in here. And you code here is conducting two tests, it's checking the guest is greater than 100. And if it is, we can also put a guard around our actual greater than or equal to one. And this is So this first test case is going to execute negative five, for example, then we're going be within one and 100. If we enter a number like we expect it to and this code on line is called the OR operator. And this is checking the test on the right is true. So obviously, greater than 100 at the same time, but one those is true, then we're going to have an out a message to the user saying that this the AND operator. And it evaluates to true on the right evaluate to true. So if we had is gonna evaluate to true because it is greater because 105 is not less than or equal to 100. true, unlike an or test, we're only one of is going to print out our error message. And this if statement here. The other logical And what that's going to do is it's going it to the other side. So if I take and just value true out, then we're going to get the our program. If I put the NOT operator, which then the true becomes false. Similarly, if becomes true. And I can just prove that false by taking that away, and false is false. So we have. We've got the OR operator, which 10. We've got the and operation which is the 13. And then we have the knot operation, which simply using the exclamation point. The other logical operators, is a concept called short I'm actually going to have to jump ahead and talked about this. So let me just give you I've got a function down here between line return a Boolean result. Now in order to make out returning true here, and then I am returning this function is it's just going to be replaced Now, up here in line 10, I've changed our doesn't make sense in our demo example. But So in this case, we're ordering three tests is going to evaluate these guys, it's going that result, and it's going to order it against all of them. And only one of those has to message. So as you might expect, if we run true because the guest is not less than one. true. And so we're going to evaluate if it's or or statement fails. And then we're going code down here. Like we might expect, if we negative five, then well, let's just run it we get the validation message. The guests But what happened to our return true? If you returning true out, and it didn't. So what called short circuiting. So as soon as one need to execute any more code, it already So it does what's called short circuiting, any other part of the or test, it's just going and therefore everything works. So in this no reason for go to evaluate these two tests it doesn't even execute that function. Now, high, then this is going to return false. it's hard coded. And actually go isn't even to return true. However, this value is going we see that now we get returning true printed Go is going to lazily evaluate the logical it negative five, since it doesn't need to doesn't. So any function executions are not for an and test. If one of the parameters circuiting here. So if we get into a situation this test here. So for example, with the negative that the guest is not greater than or equal both sides of an ant test have to return true early It's not going to execute this code. about, I want to actually drop back into our talk a little bit about these two if tests. little bit ugly, right? Because we have this is greater than 100. And then we have this So this is basically saying, Well, if it's do this other thing. So while this code is a maintenance nightmare, because really, our code or this code. So the way we can do that out all of this and just putting in the keyword is it's going to evaluate the logical tests. we're going to print this. Otherwise, we're case, if we run this, we see that we get the here in line 21. Execute. If we put in the the same behavior that we had before. But clear as to our intent. Now related to that tests that we want to chain together. And our little game. And in this case, I've actually to check if it's less than one, I want to 100, I want to print out another message. do that, I'm using this else if clause. So an IF test, and then it's chaining on another going to do is the first logical test that it's going to drop down to the else clause. our else clause to fire. So if we run, we of negative five, then we would expect this we put in a value that's too high, then we printed out. And those are the three different So we've got the simple if statement, that's the statements inside of the curly braces we're either going to execute the first set we have the if elsif, which we can chain together branching, so that we can have multiple code tests execute. Now one thing to keep in mind able to have more than one code path execute. we did elsif guess is less than one or the test will pass with a value of negative five, branch that has a succeeding test. So we get one because this test passed. And so this went in and executed this branch of code and Now another thing to keep in mind when you're isn't specific to if checks, but it is something So if I take a look at this example, here, I'm going to check to see if that number is going to take the square root of it. So if to take point one squared, which is going take the square root of that, which is going evaluate to true. If we run this, we see that of decimal places here and run this, now go fact is that if you square a number and take So what's going on here? Well, the thing is and floating point numbers are approximations of decimal values. And so we have to be very operations with decimal values, this is generally generate some kind of an error value and then a certain threshold. So in this case, since it to a floating point number, what we can one. And now what we have is a value that's value of that, so we'll use the ABS function, then check that to see if it's less than, is saying divide these two numbers, and if other, then we're going to consider them to that the results are the same and we We can now. And the errors that are associated with in our way. Now, this isn't a perfect solution, truly the same, and get them to pass this parameter here, making sure that it's sufficiently large, so that the errors introduced with results. Okay, so the next thing that I want me start that conversation by dropping in So a switch statement is a kind of special has a logical test and runs a block of code an elsif to run a second test and another lot of times in application development, we are very similar to one another. So a lot instead of an if statement. So we have a simple keyword as you might expect. And in this example, And that's called a tag when we're working going to compare everything against, then you can see here we got case one, and we got to happen is the value here is going to be the statements after the case are going to execute. And just like with if statements, the one that executes, we also have this default if none of our other test cases passed. So get to print it out. If we add the value one if we have three, then we get the default to compare one variable to multiple possible languages, if you want to compare against this, you'd have case two, you'd have case through in order to compare multiple cases through as a default behavior and go, but ability to have multiple tests in a single and I say this is going to test one, five, and six, then I'm going to say this is going print two, four, or six, and then I put in message to this is going to say another number. case is going to pass because I matched this I have the value one, five, or 10. So I can the value of one, if I pass in the value of have the second case, evaluate. And naturally, to have the default case execute, just like we have to be aware of is the test cases do where I'm going to have five in the first a syntax error, because you can't have overlapping just like with if statements, we don't have we can use an initializer, just like you're doesn't have to generate a Boolean result, our switch statement up here, the Boolean the switch statement to our cases. So in this value. So I'm doing some simple math here, that's going to be five, then I've got the be testing against. So as you might expect, two plus three is five, five is matched by printed out. Now another syntax that we have tankless syntax. So both of the styles that a value that we're comparing to our test cases, tag list syntax. And this is arguably more is a little bit more verbose. So in this case, which is going to come from some other logic statement that standing all alone and immediately have a tag here. However, my case statements I can use the comparison operators, I can the cases are standing in for the logical doing exactly the same job. So in our first to 10. And if it is, I'm going to print that to check if i is less than or equal to 20. case. If The value falls through. So if I which is an interesting thing. And it executes Well, if you notice the first case, in the or equal to 10. It's also less than or equal multiple test cases. And I said they cannot they are allowed to overlap. And if they do, is going to execute. Now another thing that that we don't have curly braces around this, the next case is going to be part of the block many statements as I want here. The delimiters, the default keyword, or the closing brace, in a case statement. Now again, if you're might be looking a little weird, because you And we'll have to add this word here. And So you might be wondering where the heck are is actually implied, because so many use cases a break is the cause of innumerable errors decision was made to have an implicit break fall through which most other c based languages your case to fall through. So in this example, that we're less than or equal to 10, and that that if we pass this first case, we're going we can actually use the keyword fall through. print out. So I'm going to get less than or Now one thing to keep in mind here is fall through to the next case, it will do that. than or equal to, then we know that I fails because fall through means that you are taking And you intentionally want the statements don't use follow through very often, because tests per case. And so a lot of the use cases However, if you do have a use case where you to you. The next thing that I want to talk use of a switch statement called a type switch. And this should be pretty familiar except we are switching on a tag. But the tag variable any type of data that we have in a go application. integer like we're seeing here, we can assign to a struct to a collection, anything we want So then in go, we can use this syntax here. that, put in params with the word type in tell go to pull the actual underlying type we're doing next. Now, you don't just use use case for it. So in this case, I'm going as we know is going to type I to be an integer. cases, because this is going to return a type, my cases. So if I run this, knowing that one I see the first case passes, and the other zero here, then that's going to turn this go recognizes that. Similarly, if I put one that go understand that. And I can even make, initialize any values here. But if we see And if I want to have a case to catch that, of three integers. And then I can print that that and this is different than two. So if that those are different types. Arrays are to have the same data type and the same array the same type. Okay, the last thing that I example here. Now in this example we're extending notice that I've got these two print statements I see that I is an integer and this will print to leave a case early. So maybe inside of logical test, and you find out that there to execute in certain situations. Well, if out of the switch statement early by using then I have a way to break out of the switch below that break statement. So you can wrap got a validation error. For example, on some that data to the database. And then you can that save operation. Okay, so that pretty if and switch statements. Let's go into a In this video, we started our discussion about available to us in our NGO applications. And we started and how we can use a boolean variable to determine We then talked about the initializer syntax, that's going to set up variables that we can within the statements of our if tests. We and we talked about how there are six of them, or equal to and greater than or equal to, as well as the double equals operator and to be used more generally, we talked about OR operator and the non operator that allows as reverse the result of a Boolean operation. about short circuiting and how when you're for example, if any one of those logical tests are not executed. So any side effects or any those are not going to be executed. Similarly, to return a false result is going to halt effects you might be relying on afterward the two different variants of if tests, we can use that to execute one of two branches we're going to execute the first block of the second block of statements. Related to case, instead of determining between one of one of those, you can add additional logical But if all of your F tests fail, then you I took a minute to talk about equality operations, numbers. And how equality and floats don't to do some kind of inequality operation with to want to turn that into some kind of a comparison example, we were checking to see if two floats they're actually equal, and we divided them that against an error parameter. So we decided, were going to be considered the same, you your operations. But in general, you should are equivalent to one another. We then moved various ways that we can use those in our how to switch on a tag or tag is just another a special significance in a switch statement, be compared back to that tag. We talked about our case statements. And by doing that, we in other languages where we need to fall through go, we can just add those multiple tests in that following through. We also do have initializers of the initializer, generally generating a initializer is going to generate the tag that's cases, we talked about switches with no tags switch statement. But it is a little bit more compared for equivalency with the tag, we're ourselves. So we can use more than just equivalency or any other comparison function, including operators. We talked about how we have the and how that replaces the break keyword in implicit fall through an explicit breaking breaks. But if you do need one case to fall fall through keyword. Now one thing to keep falling through, any additional case logic any case logic that you have. And so the next case would normally pass or not. We also talked special syntax by adding a dot perenne type get the underlying type of that empty interface. that's holding an integer, then we can use integer value. Then in our switches, we can make a decision based on the data that we out early, when we've passed into a case in in the middle of the case, we need to exit analysis. And we've decided that we should we've got a switch statement. And inside of the data before we save it to the database, we should not proceed to save it to the database. break out of the case and continue execution our discussion of the control flow structures by talking about looping. Now in the last have to introduce branching logic into our Well, when we talk about looping and go, things because we only have one type of statement statement is the for statement. Now we're down into three different parts, we're going talk about how we can exit a loop early. And loop through collections. Okay, so let's go some simple loops in go. So in order to start our discussion about perhaps the most basic for loop that we can keyword as you might expect. And then we're statements, the first statement is going to an initializer. And if statements and switch that we want here. And normally, we're going when we're using a for loop like this, the to be some kind of a statement that generates by the for loop to determine if it's done is going to be the incrementer. And normally, this to increment a counter variable. So if zero through four printed out, we could also we only get three iterations of the loop, the value two, and then it has the value four, value of six, well, six is not less than five. to false and we exit out of the loop. So this see this. But the most standard way that you an increment statement. Now if you're coming to be able to do something like this. So maybe loop. And so we're going to initialize j there. loop. So if we go ahead and try and run this, we have no comma operator in the go language. this using the comma. So this is an error, that, though, we can use gos ability to initialize a comma here getting rid of this part here, treat these as individual statements, because in go the increment operation is a statement, out a way to do both of these at one time. to i plus one and j plus one. And go ahead if we have j here we see that j printout as And we see that i and j are incrementing independently. come back and revisit that increment comment to do something like this, if you just want we're actually going to get an error because increment operation is not an expression. It is a statement on its own. So when you're do this because i plus plus is a statement, anything else. We can't use it as an expression. go back to our initial example here. So we at first blush, if you just come into programming, special because it's used up in the for loop. anything else. So we can do whatever we want you that, let me drop in this cool little to do here is we're going to take the modulus zero, so basically, we're checking to see If I is an odd number, then we're going to then we're going to multiply it by two and play around with the incrementer. So let's completion. And in fact, it does. And you place. So we start with zero zeros on so divide is going to be one because we're incrementing by two and one added to it. So we print the here, two times one plus one is three, and so we're printing for four out here, four again, so we print out the value three, three is seven, seven is greater than five. And can do whatever we want with the counter. doesn't mean it's a good idea. As a matter to manipulate the counter within the for loop. you can do this is to make sure that you avoid you're inadvertently changing the counter start to act really strange, like we're seeing and restore our original example, make sure printing out the values zero through four you is that we don't actually need all three do, let's just say that I is initialized somewhere it to be set up here. And we can run with can't leave this for a semi colon out, because the wrong place. And it thinks that this is to be the comparison operator. So if we try But if we leave the semicolon in, then go in this for loop. And it executes everything I've variable ri is taken in just like we format and the previous one is in this i is this syntax here, I is scoped to the for loop. here, we're not going to get a valid value form, when we're putting it out here, then actually going to get the final value of I five is the first value that fails this test. right here. Okay, the next thing that we can also don't need the incrementer value, so now, we're actually going to get an error, to generate an infinite loop. And in the go loops. And so after it runs for a little bit on us. If we were actually running this in value zero printed out over and over and over and shut the application down. Now we can any other, we can put the incrementer in here, we have to remember to put the semicolon here, know what the heck we're asking it to do, have the first semicolon, you need the second quite a bit where we need a for loop and just does do while loops. So in a lot of languages, do keyword and the wild keyword. And normally then you have some other increment operations. of the loop, or you're pulling the next value iteration, or something like that, we'll go make sense for the designers of the language basically a special case of a for loop. So use this double semi colon syntax here. But run this way, we see that this works. And as if we have both of these semicolons here. It's exactly the same construct. It's just and it reads a little bit cleaner. So in this operation. Go is going to assume that we're comparison are coming from somewhere else. available when we're working with counters we also have a situation with do while loops to run through the loop and undetermined number actually know when to stop by an obvious logical loop in order to determine when to leave. leave off the logical test, and we run like expect, the playground is going to crash out to exit. And so it's just going to run forever. when it's done processing and when to leave. the break keyword. And then Normally, the of logical tests inside of the loop. So we to use that break keyword. And we saw the talking about switch statements, or the break of for loops, especially this kind of infinite if i is equal to five, so we're going to print I was fine, we're gonna break out. So if we same values that we had before. Now when we loop. So execution of the loop stops, and we can do is use what's called a continue shows you that. So in this case, we're looping keep incrementing as long as i is less than value is even if it is even, then we're going what this does is it basically says, exit over. So what's going to happen when we have continue, which means we're not going to hit minus two is one, so we're not going to hit one, and then two is going to hit the continue we'll only print the odd numbers out. If we happens. So continuous statements aren't used If you're looping through a large set of numbers, whether you want to process a record or not. going to do this, this is actually going to here is a pretty simple example, we're starting and we're going to run as long as i is less the same thing with J on the inside. So basically through days from one to three, then is going Again, and then inside this inner loop, we're So if we run this, we see that we get all and j go from the values 123. So we get all works the way that we expect. Now what happens get the first value that's greater than three. so we're going to multiply it times j, we're going to see if that's greater than or equal out of the loop. Now if I run this, we don't for that is as soon as i times j is greater the loop that is going to break out of is actually breaking out of this loop here. And to tell it to stop. So you might ask the question, Do we have to have more logic here and check again, and then break out? Well, the answer a label that we can add. So a label is put to start with a word and follow it with a in our code blocks. So once I have a label the break keyword. And it basically describes labels just before this for loop, we're going I run now, I get to the value three, three I break out of both the inner and the outer in this video is how we can work with collections we have a slice of integers. In this case, three. And we've seen how we can work with We run this we get no big surprise, we get But what happens if I wanted to work with we can do this, we can pull out one value But how do we work with an arbitrarily sized is going to be at runtime. I want to be able So the way that I'm going to loop through for loop called a four range loop. So I'm as you might expect. And then what I'm going current item in the collection. So I'm going And then I'm going to set that equal to this collection that I'm going to range over. So look at the collection here. And it's going the key and the value, and then we're going So inside of this, let's go ahead and just and run that. And you see that we get the get their values. So the indexes are coming are the actual values in the slice. And this using the range keyword, you're always going out. So this syntax is going to work for slices by just adding a size, here, we see that we maps. So if I pull back the state populations and loop over that, once again, pulling up map this time, then if I print the key and out and then get the state in their population a string as a source for a four range loop. here is pull each letter out of this string that we do get each position. And now we get attention over the last few videos, you're Unicode representation for that digit. So a simple conversion operation. And we see we would expect. The other type of data that a channel. Now channels are used for concurrent a future video. So I'm going to leave that parallelism and concurrency and go, I'll revisit for loops with channels, because there are aware of when you're ranging over channels. this out, you see that we have access to both is not always true, you don't always need some problems. Because if I only want to print an error, because in go, you have to use every situation where we've got this variable v, to cause us a problem with our application. to get the keys out, you can actually skipped going to ignore the value. But what happens want to print the value out. So if I restore of course, I get the same error. But I can't the keys to that. So what do I do? Well, in then you can use that underscore operator couple of times. And basically, that's going actually care about the key. But we need this value. So when we run this, we do see that so that covers what I want to talk about with and review what we've talked about. In this flow construct that we have in the go language, how we're going to use the for statement for So we don't have to remember I do keyword we use the for keyword that's going to allow We started by talking about simple loops and loop, we've got this first syntax, which is incrementer syntax, and we're going to use to set us up in our loop. Normally, by initializing that with our test, our test is normally going at a certain value that's out of range for and that incrementer. His job is to move the loop in order to move to the next case that in this first syntax, we actually can leave But if we're going to use any of this syntax, So leaving a semi colon out confuses the compiler, And so you're going to get an error in your or an incrementer, then you're going to have eliminates the need for the initializing the conditions are being managed somewhere else. test. And as soon as that test is false, you're that we have is the for loop on its own and within your four loop, the break statement early from a for loop. And we have three concepts the break keyword that will break out of the the application execution after that loop. statement, except for eight doesn't break current iteration goes back to the incrementer, the next increment. Now we can also use labels break statements in order to break out of used in go. So for example, if you have a collections, and you need to break out of label and then follow the break keyword with where to break out to. And finally, we talked the collections that we have available, there's strings and panels that we can loop over. going to use that for keyword, we're going to set that equal to the range keyword followed So the keys when working with arrays, slices that collection. So you're going to have that get the key from that map. And the values value for that current index. Now when we're very similar syntax, but channels have a little And we'll talk about those in a future module, flow constructs that we haven't go by talking that discussion by talking about deferred a function, but delay its execution to some how an application can panic. So in this conversation, a state where it can no longer continue to as well as how we can trigger that on our talk about recovery. Now when your application way to save the program so that it doesn't your application can be saved, how you can that to the rest of your application. Okay, go, application control flows from the top Now, of course, we can alter that a little we can skip some statements. And we can use to repeat certain blocks of statements multiple to start at the first line and execute through this program right here, we see that it's we print middle, and then we print end. And one of these statements is proceeded with of this print line here, then run that, you end. So the way the defer keyword works in that are passed into it after the function actually returns. So the way this main function it's printing out start, then it recognizes then it prints out end. And then the main that function exits, it looks to see if there we have one, and then goes ahead and calls end of the main function, and actually moves main function returned. Now, if we put the statements, then we'll actually see an interesting actually executed in what's called lifepo that gets deferred is actually going to be sense, because often we're going to use the it makes sense that we close resources out one resource might actually be dependent on we actually see that we've reversed the order middle and start. And just to remind you, main function they're executing after the any results to the calling function. Now, this situation, I felt it makes sense to get to look at. So for this, we're actually going we're going to need to run a program that's the HTTP package. And you can't do that in here, we're importing a couple of packages. HTTP package in order to request the robots you can actually find in gos documentation. you can use the deferred function. Now, as to get a response and an optional error. And is nil. And if it's not, then we're going If it is not nailed, and we got a good response. from the IO util package, what that'll do that out to a string of bytes for you to work here, we see that that is a string of bytes. to let the web request know that we're done Of course, the read operation can fail, so finally going to print out the value of the by invoking it with the go run command, we out, and everything worked out just fine. to the console here. Now, one thing that we're help with is handling this body close. Now, that's really being worked with between the However, in many applications, you might have needs that body to be open and continue to one character at a time, and you're doing So you can actually end up with quite a few is that you might make this request and open be dozens of lines later that you actually the possibility that you forget to close it. going to be hard to remember to close the of bugs coming into your application. So what then we can go ahead and move this up a line. closing the resource, and then we're trying we see that it works just fine. Everything if we leave the defer keyword off, then we do get an error because we closed it. So what this allows you to do, and this for using defer is it allows you to associate of the resource right next to each other. going to open resource, we're going to check the resource. And you want to check for the here, then you actually never got this resource. application to fail. But as long as you know makes sense to do a deferred call to close is this is a pretty common pattern. And you're making a lot of requests and opening a lot defer keyword to close, it might not be your statements don't execute until the function going to loop over a million resources, you're all of those get closed at the same time when working with resources in the loop, then you you might want to explicitly close those resources would be to delegate the processing of those that function, close the resource. That way, at one time and wasting memory. Now the next in the playground. So I want to do that, because that we have is this program here. So when is going to print out when I run this, now have, the first line of thought is, well, I'm going to print start out. But you might to cause this statement to print after the done, we've already changed the value to end. going to bring start or end with the fact printed out. And the reason for that is when takes the argument at the time, the defer is executed. So even though the value of a we are going to actually eagerly evaluate to be put in here, we're not going to pay the next thing that I want to talk to you Now in go, we don't have exceptions, like of cases that are considered exceptional and a go application. For example, if you try that's actually a pretty normal response. try and open a file that doesn't exist. And exceptions because that's not considered exceptional get a go application into a situation where exceptional. But instead of using the word because of its use and other languages, we're going to be panic. And that's because our so it's really starting to panic because it this example, here, I'm declaring two variables to zero. Now, obviously, the answer of one in a go application. So if I run this, we're will generate a panic for us. And the runtime And then we get a stack trace letting us know going along and writing your own program, cannot continue to execute, because of a certain for you to panic as well. So to do that, you're we see here. So we're printing out start, passing in a string, and then we're going we run this is very similar behavior to when ago, but the error message that's printed we passed into the panic function. And then do get start printing out. But of course, Now more practical example. Now this will because it probably wouldn't fail on the playground simple web application where you're going a function listener, that's going to listen this is a callback that gets called every And all this is going to do is print out the don't I go ahead and do this over in Visual program is going to do. So we'll go ahead Now there's no errors and went ahead and started, is localhost 8080, that you see that we get go an entire web development course in one that's printing out the string, hello, go. where we're writing to this response writer, access to the response to this web request. Now, what's interesting here is this error function returns an optional error object. that can happen all the time, when you're blocked. So if I open up another terminal you see that we get our application panicking. access a TCP port that's already been blocked. running the application over here. So this Now, the listening serve function doesn't or not, because he just tried to execute something. Well, that didn't work, it's reasonable to so it's not going to panic is going to return web application. And we know that if that brought down, and nothing happens. So in that passing out that error that comes from the trying to start this up, know that something pattern that you're going to see and go go an error is something that should be panicked you, hey, this didn't work the way that you developer to decide whether that's a problem is a problem, we fail to start our application. what are we going to do in the situation that ourselves to a situation where we can recover fatal. They just are, if we panic all the realizes wait doesn't know what to do with to kill it. So we come back to this application getting this panic. But something I want to is this modification here. So I've added this this was deferred. So if we run this application, We get stopped printed out. That's not a big printing out and then the panic happens. And after deferred statements are executed. So our main function, then we're going to execute to handle any panics that occur. And then there's actually quite a bit that happens curly brace here. So why is this important? that the first statements that are going to if the application panics. So if somewhere you don't have to worry about resources being left out there and left open. still going to work even if a function panics. is if I change my deferred function here to function. And we're not going to talk about is important in order to talk about this. a little bit. So what we're creating here is what's called is simply a function that doesn't have a name. at one point, and we can call it exactly one function execute. And this is an important first statement doesn't take a function itself, want to invoke that function, otherwise, things of this custom function, notice that we're the recover function is going to do is it But if it isn't nil, then it's going to return to panic. So in this logical test, we're checking that means our application is panicking. and that error out. Now, what happens in this the panic. And let me import this log package still execute. So we got the string start using the long package. But we didn't get like our application is still dead. But recovered a deeper call stack than what we're dealing in order to show you. So in this case, we've our application entry point, of course. And panikkar. And all this thing does is it's about the panic, and then it's going to panic. that panic using that deferred function that have this line here, done panicking. And then start, we're going to call the panacur. And what happens when we run this. So as you see, would expect, we see the about the panic string we go into our recover loop, because we're panic. And so our panikkar function is going any deferred functions. And inside of that that recover, we're going to log out the fact log that error message out that we see here. So in the event that you're recovering from still stops execution, because it's in a state function. And so it makes sense for it to functions higher up the call stack, those from the panic, they are still presumably you recover function said that your application Now, this is a little bit limiting as well, is, you actually have to call the recover saying that you're going to deal with it. you realize that this isn't something that you're going to do is repainting the application. just read through the error, or you can come sense for you. But in this case, inside of then we actually see that we don't get that panics because we read through that panic. panic actually happened. And we see that we're this anonymous function right here. And we out and we don't get the string and printed trying to recover from a panic, and you realize re throw that panic, and the further management so let's go into a summary and review what video, we talked about the final two control in go programming. Now, one could argue that constructs, because they're not the traditional But they definitely do alter the flow of execution together in this category. The first thing function in order to delay the execution of these are useful to group open and close functions to open up a resource, and you need to make the call to close that resource to make sure holding on to that resource any longer than though, is be careful loops. If you're opening a loop, then you probably want to explicitly Because when you're using deferred keyword, until the function finishes execution. And if you're dealing with a very large number statements inside of a function, then they the last deferred statement that you call executes. And again, this makes sense, because those resources are dependent upon one another, order that you open them, which is typically call are evaluated at the time the defer is is executed. And that's important to keep into a deferred function call. And it can value of those variables further on. And those So just keep in mind, when you call defer, be captured at the time that that defer is executes. Now, something unplanned happens that a go application can go it can return or it can panic. Now, what you generally want because in go programming, we typically don't an application to be exceptional events, or to shut down. For example, a classic example make the request and you don't get a response happens all the time, no response is a valid because you're looking for that resource, case, you're going to return an error value, panics are used when an application gets into you hand the runtime a divide by zero problem, divide a number by zero, and so has no way the application is going to panic. So just can't continue at all, don't use them when file. For example, if you're opening a template your view layer, then that might be something trying to open up a log file, and you can't for that necessarily, you just need to return the logs aren't available. Now a situation where you might want to panic up a web server, and it can't get ahold of on, then that's probably a situation where executing immediately at the point of the fire. If nothing handles that panic, then call stack, it's going to hit the go runtime, panicking situations. And so the program will that you feel that you can recover from, then function. Now that function is used to recover functions. And the reason for that is because application starts to panic, it no longer will execute deferred functions. So the proper of a deferred function, that's going to look is panicking, then it can go ahead and decide not attempt to continue. But if you do recover, continue as if nothing went wrong. Now, if you call that recover function, you look at function and you can't handle it. Remember by calling the panic function again. And then call stack, I want to talk about pointers We'll start that discussion off by learning about something called dereferencing. a pointer, at some underlying data. Then we'll talk about a special type in NGO called nil. And then built in types and go that use internal pointers. than other types that you'll work with in in and learn how to create some pointers. simply as I can. So I'm going to use this a variable a and assigning it the value 42. out. So it should be no big surprise that out. Now, if I extend this application a little it to the value of a and print both of those 42 prints out two times. Now since a and b what go is going to do is it's actually going it to be. So we're not actually pointing to changing the value of a to, for example, 27, if we run this, we see that the value of a 42. Now we can change this behavior a little called a pointer. Now in order to demonstrate syntax a little bit and go to more of a long make things a little bit more clear about you'll agree with me that this line eight we had, it's just a little bit more verbose. and use that same long form syntax, what I I'm going to declare it as a pointer to an is by preceding the type that I'm pointing B to point to a, then I'm going to use a special you see here. So at line nine is now saying I want to point it to a now what is a pointer exactly? Well, let me what we get as output. So as you see here, but B is holding this strange data here. So representation for the memory address that in memory, we actually have assigned the integer holding the memory location that's holding address of operator down here. And when we do see that the values are exactly the same. here, and B is holding that exact value. And way. Because while the address of operator in memory, we can use a different operator being stored at a memory location. And that's go ahead and remove this, and then I'm going in front of this pointer. Now you notice we're little bit different meaning here. So up here declaring a pointer to data of that type. I put the asterisk in front of a pointer, means it's going to ask the go runtime, to location that that pointer is pointing to, run this, we see that we get the value 42 the point of all of this, what the point is, Now both of these variables are actually tied again, and then print out their data, now give the value of 27. Because they're both As a matter of fact, we can even dereference So if I use the dereference, B, and assign again, then we see that once again, both values to our both teams, because it's in fact the in languages that allow you to work with pointers to do something called pointer arithmetic. to start to play around with something that's arithmetic. So I'm going to start with a variable values, one, two, and three. And then I'm in the array to this value right here. And right here. Now if I use this print statement, array and then this percent p syntax is actually BNC. So if we run this, we see that we do two memory locations printed out that B and a value that's for higher than B. And the in memory. Since this is an array of integers are four bytes long each element of an array ending with 124 is holding the first element going to hold the next element of the array this if you come from another language, if then that actually should give me the address of these should be pointing to the head of see that I get an error. And the reason for be done on pointers. Now, once again, if you've of the tremendous performance advantages that arithmetic, because you can jump around mapped substantial benefits in the performance of get into pointer arithmetic, you're typically And since go has as one of its core design to leave pointer arithmetic out of the go something like this in your application, then the go packages and come down here to the you operations that the go runtime is not to do pointer arithmetic and things like that, appropriate name is available for you for scenarios are advanced enough that what I'm you're going to learn it. But generally, you're Now the next thing that I want to show you So we've seen this address of operator and to a certain variable. So if we look at the because we're pointing to one element in the underlying type first. Well, that's actually want to work with the pointers, and you don't you just need the ability to point to it wherever can do that. Now we've seen almost exactly talking about structs, we had an example that my struct object, we were instantiating it when we print everything out, we print the a pointer to a my struct, and then use the then I actually get almost the same behavior, value of MS, I end up with this ampersand holding the address of an object that has of being able to do this, it's going to come be aware that you can do this. Now this isn't to initialize a variable to a pointer to an Now unfortunately, with the new function, we're just going to be able to initialize this, we see that we do get an initialized to their zero values, we can't initialize Now, since I mentioned zero values, it's important Because as we talked about, in a very early go has an initialization value. So right here So the question is, what is that thing? So up here, we will be able to answer that question. we see that we get the special value nil out. actually going to be an initialized for you. this is very important to check in your applications. it is best practice to see if that pointer going to have to handle that in a different and get to this foo field, but and this is exception, and our program is going to crash point, how do we actually get at this underlying way that we're going to need to do that is pointer in order to get it that struct, and to have to use something like this. Now, you Well, it turns out that the dereferencing the dot operator. So we need to print in order MS variable instead of dereferencing, Ms dot the value 42. Now in order to get at the value to have to repeat the same exercise. So we're wrap this ms variable, and then we'll print run this, we in fact, do set and get the value I hope you'll agree with me at this point use this syntax every time we dereference that a params and have this dereference operator. that are put on point Here's the compiler So in fact, we don't need this syntax at all. this from the print statement as well, and behavior. Now again, if you're coming from this is probably freaking you out. Because doesn't actually have a field foo on it. The has a field foo. So how is this working? Well, is just the compiler helping us out because the Foo field on the pointer, we're implying go is going to go ahead and interpret that So the compiler really sees this statement the same to the compiler, it's just one reads that I want to talk about today is how go to another. So let me go ahead and paste this we're initializing an array. On line nine, it in the same array as a, then I'm going to change index one of the A array to 42, done this example in the past, and hopefully B is not because b is a copy of the array of each other. However, if I remove this index, a little bit. If we run this, now we see that happened there? Well, the slice is copied copying is a little bit different. Because the array are actually considered intrinsic of the array, as well as the size of the array checking. So for example, if we asked for this array, and run, we can do bounds checking thing. However, with slices, remember, a slice array. And so the slice doesn't contain the to the first element that the slice is pointing is that when we work with slices, the internal to an array. So while line nine is still copying data that gets copied is a pointer, not the means is, when you're sharing slices in your to be pointing at that same underlying data. behavior is a map. Because maps, once again, don't actually contain the underlying data where I'm initializing a map of strings to B is assigned to a, then I print them both and print them out again, if I run this, we then when I change the key foo in the map, well. So what does that mean? Well, what it and maps in a go application, you have to times who's got access to that underlying in your application can get you into situations However, if you're working with the other or structs, then this generally isn't going it's actually going to copy the entire structure wraps up what I have to talk about with pointers. we've talked about in this video. In this use them in the go language. Now, we haven't yet. But we need to understand what pointers next couple of videos, we'll get into why of them. But for now, we're just trying to by learning how to create pointers. And we that's actually going to declare that type So for example, we have this asterisk int, We also learned how we can create pointers of an existing variable in memory. Then we we can use that asterisk operator again, but in front of a type and use that to drill through is pointing to. We also learned that when pointers to structs those pointers are automatically doesn't get cluttered up by a whole bunch then we moved on to learn how to create pointers couple of different ways. So the first thing to get access to a pointer to an object that we've got an instance of a my struct object of operator to create a pointer p to that So if we proceed an object initializer, with directly create a pointer. And we don't have that value, we can also use the new keyword the fields at the same time. So the behavior to have to use the new keyword that's going example. And then we're going to have to come last thing that we talked about was types they're treated exactly as any other variable is a little bit different. So all assignment whenever you have a variable a and you create data in a is going to be copied in order to internal pointers. And so even though they're they're pointing to the same underlying data, and how you can use them in the go language. this entire video series. But we've never there's a lot of groundwork that we've had we can understand what a function is, and So in today's video, like all of our videos down into multiple parts. We'll start by talking we'll talk about the parameters that you can Then we'll talk about the return values that talk about something called an anonymous function. are first class citizens and can be passed variable, and then we'll wrap up our discussion called a method. Okay, so let's get started To start our discussion of functions, we don't that the NGO playground gives us. So as soon with this very simple application. And right way that a go application is structured, is the application. And the entry point of go within that main package, you have to have and returns no values. So we can see that the application actually starts right here. And that's all that our application has to And we see here the most basic function that are several major parts that we need to understand with the func keyword. So as you can see here, anything else, we start with the func keyword, we're going to create. Then we have the name And this follows the same naming convention to use Pascal case or camel case for the names have an uppercase or lowercase determines with variables, and uppercase first letter so anything else can use it, and a lowercase to the package. Now after the name of the now we'll see as we get into parameters, what after the main function. So even if you don't have to have these match params. And then within these curly braces here. Now there about where these curly braces should go. put them down here, some languages like to conventions about where to put these curly any arguments because this is the convention you have to put the opening curly brace on the closing curly brace generally has to be where you can have that closing curly brace we'll talk about that a little bit later in defining a function, the closing curly brace defined like this, the execution path is static, doing from the outside, because we're not do want to pass information into it, then into the function. So let me just drop an here a main function is now calling into another message function takes in this parameter MSG, a function that takes parameters, the parameters they're described like any other variable var keyword. So you're going to have the name the type of the parameter. So then when we in the value for that parameter. And that's in the argument Hello, go. And then inside that gets passed in. And so when we run this, Now this MSG parameter isn't special in any the function, it's treated as a local variable, might create. So if we created another variable exactly the same way as our mystery variable. the MSG variable can be passed in from the was created locally. Now, you aren't constrained actually pass multiple parameters in. So if action. So here, I've extended the same message got the message parameter that's of type string. added another parameter, and that's going type integer here. So as you can see, we can just going to provide a comma delimited list So then when we call the function, we're going parameters. And they have to be in the same argument that we're going to be passing is this MSG variable. And then we're going to counter here. And that's going to be passed function, we're just going to print out the to say what index we receive. So when we run times. And we get the same message, but the in a different value every time we call the a function, you're going to pass in multiple to be tempted to have syntax like this. So function. So instead of a generic, say, Hello, And we're going to provide the greeting that it is we're going to greet. So in this case, string Stacy. So when we run this, we're gonna are the same, the go compiler actually provides this is a little bit more verbose than is the type every time, we can actually just and then the type at the end. And what the infer that every variable that's in that comma we run this, we actually get exactly the same terse syntax. Now, so far, we've been passing from our last discussion, we were talking any pointers in our function signatures right And then we can start playing around with passing in pointers. So when I have this example output that we had before. But I've got some to this function. Now, what do you think is of these variables inside the function, so to Ted, and let's go ahead and print that what do you think is going to happen if I here. So I'm passing in the name variable is going to copy the data that's in this name would expect is when we change the value of an effect. And we should print 10 out here. we actually shouldn't have any effect out that is true. So this is a safe way to pass passing by value, that the data is not going I change this to passing in pointers, by adding of these variables right here, and then dereferencing, going to happen. Actually, I need to add another pointers to our variables around in our application. the name variable, we're working with a pointer we actually see looks like I missed a dereference we have in fact, change the variable not only scope as well. So by passing in a pointer, that we passed in. Now, why would you want First of all, a lot of times our functions passed into them. And so passing in pointers reason is passing in a pointer is often much, value. Because right now we're passing in and ghost, so passing in copies versus passing same in terms of performance. However, if then passing in the value of that data structure to be copied every single time. So in that simply for a performance benefit. Now, you passing in pointers, because of course, you you can cause some issues for yourself. Now, we talked about in the pointer discussion, you don't really have this option, because to their underlying data, then they're always in. So just be careful when you're using those change the data in your calling function, function. The last thing that I want to talk about when called variadic parameters. So if I drop in of a variadic parameter. So in this case, creating here, and I'm passing in the numbers variables here, instead, I've got one variable three dots here. So what that's done is that's last arguments that are passed in, and wrap the variable that we have here. So then inside out what that values object is just so we and add up all the values in there. So since a for loop and range over those values. And that. So when we run this, we see that we sum is 15. So we got that result printed out when you're using a variadic parameter, you one. So if I, for example, want to have a and then pass that in here and then replace I couldn't, for example, put the message parameter doesn't have the ability to understand where parameters would begin. So if you're using and a half to be at the end. Okay, now, it's because now depending on the different data of the function. But it's also very useful work, and then return a result back to the we're going to use what are called return see it's basically the same as our last example. sum function, we're returning the result out. with that. So there's a change we had to make the parameter list, and before the opening type. So in this case, I'm expecting to return of my function, I'm going to use the return value of the variable that I've been building So in this case, I declare the result variable return that result back now up here in the by declaring a variable and setting it equal going to be an integer type, because that's then I can work with that integer. So if I that I had before. But now the sum function what I do with that result, it's just going to the caller. Now another feature that go languages, is the ability to return a local example, when we return that result, go actually that's what got assigned. But we can also a pointer to an integer now. And instead of of the result. And so S is now a pointer. if I run this, it works exactly the same way. that uses pointers a lot and doesn't abstract stack and working on the heap, then this might declare the result variable, it's actually which is just a special section of memory that this function is going to be working stack is destroyed, that memory is freed up. a safe operation, because now you're returning got freed. And so you've got no idea what Well, in the go language, when it recognizes on the local stack, it's automatically going the shared memory in the computer, what's have to worry about this value being cleared, returning a pointer from the local stack, fine. And that makes a lot of things more can work with this as a true value. So we and then just right at the end, we can return makes it all work for us. Another thing that done very often, but there are cases where So if I drop in this example here, notice got a set of parenthesis here. And then I've for it. So when you do this, this is basically So this variable is going to be available that value is going to be implicitly returned. here within our function. And then we don't down here in line 17, we just have to tell that once again, we get exactly the same behavior. quite a bit cleaner, because we don't have result variable. Now, this is actually not suspicion is because it can be a little bit are declared way up here at the top of the at the bottom. So if you're reading this code, function is actually going to return, you signature. So this can be a very valuable with it. Because if you've got long functions, more confusing instead of less confusing. one makes the most sense for your application. return values is the fact that we can do multiple to show you why this is valuable, let's take divide function that takes in two parameters divide them and it's going to return that Like you might expect, and everything's fine. Now when I run this, I get an unknown result, work with that in my application. So I'm going the line. So in a lot of languages, the only panic the application and go when we detect B. So I guess we could do that we could add 0.0, then we're going to panic and we're going And that would work. But keep in mind when want to panic our application as a general the application cannot continue. Now, in fact, provides the value of beat. But it's reasonable be parameter occasionally. So instead of doing an error back letting the calling function able to be done properly. So instead of doing return variable. So to do that, we're going an object of type error, and then close that values as we want from a function. But this So we're going to return the intention of then we're going to return an error object what we're going to do is, we're going to want to be doing that. And we're going to zero it out, because we can't do this operation, then we're going to return an error object. the air f function. And we can say cannot a value for that error. And then that's all to this function in the error case, then if parameters are okay. And so in that case, for the error value, we're going to pass nil is very idiomatic go, we're going to return then we're going to explicitly return nil read any amount of go code, you've seen this see if that error also Got our standard if going to put our error handling logic in here. print out the error and return from our main If we don't have that, then we're going to So again, this is a very common pattern and errors, you're going to return the expected then you're going to have a guard that's going going to return as soon as possible from your is present. And the reason for that is we're much as possible. So we don't end up with to have else checks. And we do all of our to do our error checking at the beginning if we do get past that, then we're going to out the result of a calculation and then a going to have the standard test to see if to nil, then we're going to process that error, to have to deal with. And then again, we don't moving on, we're going to make sure our error or exits onto the function. And that way, justified. So our main thread of execution and then we're going to print out the result. main line of execution to be indented. So initialize my error parameter. So let's go else I should talk about. When we're receiving actually have a common delimited list of those to match up to this float 64. And this eerr parameter here. So now if I run, everything error cannot divide by zero. So our main function that we can work with. But if we put in a of execution, and we get the return value functions as this special thing, because we're these at the top level of our application, go are actually more powerful than that. Because they can be passed around as variables, they you can get them as return values, pretty you can do with functions. So let's take a I'm actually declaring a function on the fly. Now we're going to continue to explore this is the simplest example I can come up with. keyword, I've got the params. For the parameters, but I don't have the function name here. So an anonymous function. And this is the basic with functions in this traditional scope. as types. So inside of my function body, I'm I've got accompanying my closing curly brace, basically going to invoke this function. So defining it and executing it at exactly the does execute that function, and we get the these friends, then the compiler is a little this function. It's just defined, but it's check. But if I do invoke that function immediately, you use an anonymous function like this, I anonymous function like this. I mean, there inside of here. So if I declare a message string, and then print that out, that can an isolated scope. So this message variable is only going to be inside of this anonymous might use this is if we've got a for loop. just count up to five, and increment by one, And then I come in here and I actually print here and I'll print out I, you're going to run this, this works, okay. But as we start going to start behaving a little bit oddly. because we're in the scope and the main function. of variables that are in the outer scope. executing asynchronously, then this counter actually have odd behavior here. So the best inside of here and actually pass that AI variable. to be reading from the outer scope anymore. execute And that way, even if this is running value correctly. Now, this works correctly right now, because we actually aren't doing execution. And so we are safe to use this to do that. Instead, it is best practice to that in your inner function. That way, changes inner scope. Now taking this a little bit like I said before, so in this case, I've it to this variable F. And then I can execute So if I call that, we see that we do print defined as a variable, it's free to pass around what is the signature for this function. So I get rid of the short syntax and extend this with the var keyword. And since this is a this, we have the func keyword, and then an is normally going here, I don't have any parameters type signature for this variable is simply that works just fine. Now we can go a little of that in just to show you how that's going function signature for a divide function, going to return a float and an error. And pass our parameter types in here. And then if you have just a single return type, then put the type there like that. But we do have need to include that. And then when I initialize an anonymous function that takes a and d. that we had before. And I can call that exactly has exactly the same behavior as the last now we have the divide function declared as the same way as when we declared it as a function. we had the divide function declared globally, application, notice that I get an error because declared yet, because it's declared as a variable. just something to be aware of. If you're going like this, make sure that they're defined Okay, the last thing that I want to talk about are called methods. And there's a couple of just drop in an example that shows that. And it's going to do. So in this example, I've has two fields greeting and name. And then back to this in a second. So in my main function, calling this function preceding it with the going to do method invocation. So we call except for we have the params here where we declaration down here looks a lot like a function And this is what makes this function into function that's executing in unknown context, it's very common that we can use structs. type for an integer. So maybe we have a type can add methods on to that counter type, and we're actually going to get access to that to happen when we call the greet method is the greeter object. And that's going to be So then when we print out, we can access the out the greeting and the name. So when we Hello go printed out. And that's the basics same as functions, they just have this little context that that function is executing in. Now when we use this syntax right here, notice we don't have a pointer here. So this is what's in this greet method is the value greeter. time that we're working with values, we are going to get the struct itself. So if I change I print the Name field out of here, so I say field out, then it's no big surprise that the Name field here, up here in the main function, in this method, we're operating on a copy on the greeter object itself. So again, that's be able to access the data of their parent keep in mind there is a cost with that. So struck, then we would be creating a copy of Now, as you might expect, there's another in what's called a pointer receiver. So if again, now we're actually able to manipulate out Hello ghosts. So the method operates in change the format here, because we do have working for us. But now when I change the field out up here, we do in fact, see that field. Okay, so that covers working with functions and review what we've talked about. In this use them in the go language. And we started function, and we saw that this is about as start with the func keyword, we have a name letter is uppercase, then that function is from outside of the package. But with a lowercase to the package, then we follow with a match and closed curly brace. Now the open curly keyword. And the closed curly brace has to of the function, then we moved on to talk pass data into the function to influence how some variables for the function that are passed parameters are passed in as a common delimited type of the parameter. So we see here we're the bar parameter that says type string, and parameters of the same type can be comma delimited. So in this case, we're passing in bar and going to be of type integer. When pointers are passed in the function contains going to be passing in the values themselves. that data and passing it into the function. function aren't going to be reflected in the then you are going to be able to manipulate will have an effect in the calling scope. you're working with slices and maps, since inside of the function to the underlying data the calling scope. We also talked about how list of the same types in, so it must be the received inside of the function as a slice. here. So we've got the function foo. It has then a parameter Baz, that's a very attic function, we're going to have a slice called integers that have been passed in. Once your times we want it to return a value back out. out, we're going to use return values. So need to do is list the type. So in this case, we can also specify multiple return values. parentheses around the types that we're going going to be returning an integer and an error. going to see in NGO applications where we're value, and then an error value that's going That way, the function itself doesn't have to panic, or execution can't continue. It asked to do. And then it can delegate what calling function, you can also use named return providing the types in the return last, you're So when you do that, the runtime is going value for that variable. And when you use enter return on its own go is going to find And that's what's going to be returned out of go is you can actually return the addresses those are going to be treated properly. So promoted from local memory or stack memory don't have to worry about those values being reclaimed. We then started talking about anonymous different uses for those. So we have this isn't used too often in the go language, but I could get. The only potential advantage scope. So local variables that are created to be available outside, but I haven't seen often that you're going need to use this kind we can take that anonymous function and actually we've got the variable a assigned to the value a function just like any other function. The declaration of a function is that the a function So when you declare a function using the traditional that the package is initialized. And so it's this syntax, you have to make sure that a on that discussion about the ability to assign just like any other type in go language, anytime or a map, you can use a function. So you can as arguments, they can even be returned values how since a function is a type, we have to So if you're declaring anonymous functions, colon equals syntax and declare your anonymous However, if you're using a function as a parameter a function, then you're going to need to specify here. In this case, we've got the definition to take three parameters, two strings, and an integer and an error type. So it's basically normally, the only difference is we don't those names will be provided when we actually the types that are coming in, and the types thing we talked about were methods, and how executes in the context of a type. Now a type definitely is a very common use case for methods, type. So you can create a type of an integer, When we create a method, we're going to use So before the name of the function, and after set of parentheses, we're going to provide receive that method. And then we're going that variable is what's called the receiver is what's called a value receiver, which means object. And that's going to be passed into what are called pointer receivers. So by adding the method is going to change. So instead to get a pointer to the greeter object in to the greeter object in the greet method application. Now, that's very powerful if the state of the object. It's also much more because instead of copying the entire structure, normally a much more efficient operation, of the go language. And that is interfaces. pretty humble features, and they sit in the go routines and channels, especially when argue that the way interfaces are implemented the reasons why go applications tend to be proven to be. So we're going to start this by introducing the basics. So we'll learn the language itself. Then we'll move on to Now, just like in other high level languages, make interfaces of interfaces. And we'll talk good thing to do when you're writing your Now, we've touched on this a little bit before interfaces, things changed a little bit, and way, we're going to talk about the empty interface, we're going to deal with in our programming. talked about before, and we'll revisit them Then we'll talk about how to implement interfaces. you can do that. One is by implementing with a pointer. And we'll talk about some of the into as you implement interfaces with these going to talk about some best practices that of working with the go language about how applications. Okay, so let's get started by go. So to start our discussion about interfaces, up a piece at a time now often I just drop this one step at a time so that we're working So the first thing that we're going to do So interfaces are a type, just like structs the type keyword, then we're going to enter that we're creating is a type interface. And of this interface with curly braces, just with a struct, we would add in here, the data structs are ultimately data containers. And don't describe data, interfaces describe behaviors. that we're going to be storing inside of a to be storing method definitions. So I want actually an interface from the IO package, as if we created it. But this is exactly the IO package under the writer interface. So bytes. And then it's going to return an integer the way this works is anything that implements of bytes, write it to something that something it might be the file system, we don't know, bytes to something. And then the integer and is there in case something goes wrong with the number of bytes written. So now that we and implement it. So we're going to implement and that'll be a struct. And that's all we if you come from another language, you might like that. Well, in go, we don't actually to implicitly implement the interface. And a method on our console writer that has the just drop that in. Because if I try and type I'll have bugs that I have to go through. notice what I've done here, I've got a method got the same name as my writer interface, returning an integer and an error. Now the Now, in this case, all I'm going to do is printed onto the console to keep things easy do whatever I want. So what's the value of doing this? Well, the I can actually create a variable that's of in and format it and set that equal to a console holding a writer, which is something that know the concrete type, though. So when I I know how to call that because that's defined in my main function, what's being written implementation. So I could replace this with writer, I could replace it with any other a polymorphic behavior. Why nine doesn't care before that. But then anything that's going write to it. And so it can take advantage this application, you see that I do get a I would expect. So the key takeaway here as this concept of implicit implementation. And need to wrap a concrete type, and somebody create an interface that their type implements. interface, and then we created a concrete to say we can't go the other way around. We lang.org, and go into packages, this is actually test SQL database connections. So if I come the SQL package, if we look at this, notice have an interface here. So if our go application types all over the place. So for our transactions, that we're doing sending SQL statements making So how do I test that without a database? database is you actually create an interface the DB object from the SQL package will automatically creating inner phases at design time if I of my library or whatever I'm creating can interfaces can be shaped to exactly what they that I want to talk about before I move on the name of the interface should represent you. And there is one special case, if you've common in the go language, then the convention plus er. So if we're defining an interface, the interface name should be writer, if we're on it, then the interface name should be a in the interface, things can get a little day, you should name your interface by what interface, just add er onto the end of the use the struct, which is probably one of the but you don't need to any type that can have an interface. And as we've talked about before, it. So in order to demonstrate that, let me 16, through 18, I've defined a new interface going to be a method that only returns an So whatever we're going to implement this So down here on line 20, I defined the type And then I added a method to that custom type be my implementation for the incrementer interface. it's going to return an integer. Now, in this incrementing. The type itself, since I've so I can go ahead and increment that. And of this method call. So I've actually got a type defined on an the data that the method is using. So up here and create that integer counter. And I have to do that. That's what I'm doing here on and assign that to a pointer of the my ns to be a pointer toward the end of this video. to nine. And I'm going to print out the value it. So if I go ahead and run this, I see no 10 printed out. So what's the takeaway here? interfaces, you can use any kind of custom to the entity type. Because the event type package. It's a matter of fact, that's a primitive that I do have control over that I can create, methods to it, I can implement interfaces talk about is how to compose interfaces together. in the go language, and is one of the keys mentioned a little while ago, single method in the language, because they define a very method, they don't have a lot of opinions. ways. So for example, the IO dot writer interface entire go language, because all it does is write two things all the time. So by taking make the interface very, very powerful and paste this example here. Because what happens decompose the interfaces down. So in this of other interfaces. So I've got my writer And then I've added this closer interface a closed method on it, and returns an error to call this method. Now the writer closer interface and the closer interface. And this with structs. We're just embedding interfaces is going to be implemented. If an object has then we can treat that as a writer closer. here, a buffered writer closer. Now, I'm not things. This is just an example of how you a way that runs in the playground easily. that I'm going to be implementing. And what whatever gets sent into the buffered writer console in eight increments. So that's what into the write method, it's going to store defines. And then as long as the buffer has go ahead and write that out. But it won't characters. So we're basically buffering the here in the close method, I've got to implement is we're going to flush the rest of the buffer. And I'm going to write that out to the console. Okay, up here in the main method, I simply that using the new buffered writer closer talk about it, that's down here at the bottom, returning a pointer to a buffered writer closer. this internal buffer to a new buffer. So I sure that everything has been initialized function, and look at that, then I'm going the string hello youtube listeners, this is what the right method expects. And then I'm ahead and run this, you see that I get the character chunks. And eventually I get all last method, call here, you see that I don't that's actually a partial. And so we didn't for the right method to print it out. And So I know that maybe a little bit of a complicated I just wanted to show you this is how you as you implement all of the methods on the the composed interface as well. The next example type conversion. So I'm going to go ahead code here, get rid of the extra curly brace, I guess I pulled in the whole function signature. here in line 13. So lines nine through 11 creating the new buffered writer closer or the close method on it. But on line 13, I'm this syntax here, where I've got an object, that I'm going to try and convert this variable such as this PwC variable right here. Now, And I can go ahead and work with it. Now, But I'm just printing out the variable, because just going to go ahead and print that out. same output I had before. But now I get the so that tape conversion succeeded. And therefore closer, but as a buffered writer closer. So directly, then I would be able to do that not aware of the internal fields of a specific to that data. Now there is a problem. However, this to a type that it doesn't implement. over to an IO reader, which is another interface, method on it. So if I try that now, let's put the application into a state that it can't go program does, when it can't figure out interface conversion, it can't figure out an IO reader. And so it's going to fail on about why it couldn't do that. It says it's give us a stack trace letting us know where great, because sometimes we need to try and And we're not sure if it's going to work or application to be panicking all the time, and we're going to be using that as a primary that in the go language, because panicking around it. Well, we just so happen have another that. All we need to do let me rename this a reader anymore. I'm going to paste this it to a variable called R. I'm going to do this comma, okay, syntax. So we've seen this out of a map and we weren't sure if it was with type conversion. If we add a comma, okay, then we can test against that to see if we then we're going to get an okay value back to get the zero value of whatever type we is an interface. And so it's zero value is this now, we see that our conversion failed, this back to a pointer to a buffered writer And we run that we got to drop out our package we see that we're back to having things successfully we needed to. So this is really important if you're going to get a pointer or a value to write this and have a problem because we not with the value itself. And so we can't value type. So let's go ahead and run this more thing I want to show you let me just that the reason this type assertion failed implement writer closer now that might seem writer closer has a write method, and it has So for some reason this works when I asked work when I asked it to convert it to the a second and talk about why that happens. conversions first. So stay tuned, and we'll So the next thing that I want to talk about the empty interface is exactly that. It's we describe that using this syntax here. Now, an interface that we're defining on the fly, called the empty interface. But there's nothing the empty interface exactly the same way by empty interface now, so you see it like this special about this, it's just an interface it. Now the nice thing about the empty interface has no methods on it even primitives because, can be cast to the empty interface. And so you've got multiple things that you need to with one another. And you need to apply some received. But we do have a problem with the my object variable that's defined as an empty it, because my object has no methods that So in order to do anything useful with a variable going to need to do either type conversion, reflect package in order to figure out what in this case, on line 10, I'm actually trying using the comma okay syntax to see if that the write and close methods like I saw before. that I've done that before just to keep things I forgot to re import the IO package, let And we see that everything works as normal. just keep in mind, it's almost always going to define a variable of the type empty interface. what you receive before you can do anything to talk about in the context of type conversions conversation from a few videos ago. And just So in line eight, I've got a variable i that's it equal to the integer zero. And then I'm going to use this syntax. So I've got my variable and inside of prims, I'm going to put type. a type switch. So each of the cases in this data type. So in this case, I'm looking to I've got a default case, which is going to it doesn't know what AI is. So let's go ahead So we execute this case here. If I put params to contain a string. And so if I run that, I change this, once again, maybe we can make and run that then it has no idea what it is. interface in order to list out the types that would add in the logic of how to process those we would come back and talk about that weird our writer closer into a pointer to a buffered the value itself. So now I want to go through happened. So let me just drop this code in. what we had before. I've actually not really to keep things as clean as possible for you a my writer closer, and that's down here as for the methods. But I do have the methods a writer closer, and then I'm just printing some use for that variable. So the go runtime interface for the writer closers to find exactly works out just fine. However, what happens to a pointer? Well, if I run this, now, I error is it can no longer convert my writer it gives us an interesting message here, it closer, the right method has a pointer receiver. with this. So when we define types, and we types has what's called a method set. Now the method set is all of the methods regardless type. With interfaces, however, things change with the concrete value. So notice here I'm the address of my writer closer, I'm using as holding the value my writer closer. So in the context of an interface is any method we're not implementing writer closer is because it's going to point a receiver. And so its this by using the address of operator and And the reason for that is the method set receiver methods, and all of the pointer receiver when I'm implementing an interface, if I use interface have to all have value receivers. then I just have to have the methods there, set for a value type is the set of all methods set for a pointer type is all of the methods methods with pointer receivers. So there's in this case, we don't need access to the to a value receiver. And then this is going example we had. If we have one method that's going to need to switch that over to a pointer And it continues to work. Or I can make both to work as well. So this is an important concept If any of the methods require a pointer receiver, with a pointer. If not, though, if all of go ahead and use a value type if that's what Okay, the last thing that I want to talk about in your own go applications. So let's take with interfaces, there's a couple of rules mind. And these have been developed over the generally accepted as some of the best ways applications. The first is prefer many small if you need large, monolithic ones, that's together to make those but the smaller you and powerful they're going to be. And that's language you're working in interfaces there. is preferable in the long run to having a are in the go standard library are the IO in the empty interface. Now these are arguably entire language. And if you think about it, and the empty interface has zero methods. that smaller interfaces are better that some contain one or zero methods on them. Now when coming from a language that has explicitly very tempted to create interfaces and export you don't need to export the interface yourself, to do it, go ahead and don't. So there are do that. But often, it's perfectly acceptable I'll take as an example, the database slash video, where we saw that the DB object was all sorts of methods that pointed to other that out for testing right out of the box. allows you as the consumer of that struct use for testing. And the beauty of that is, your interface doesn't have to have every that you need, however, do export interfaces going to pull a value in, go ahead and accept at all possible. So this is going to be almost consider interfaces. And the reason is that instead of explicitly doing it. So if you not do this, because you have to define the because they're explicitly implemented. But can go ahead and defer the creation of the So if you're creating a library that other the interfaces that you accept. And then they they want. Now, if your library has reasonable types as well. But make sure that you're accepting this third point is talking about. design whenever possible. Now, that's not always data fields, then certainly taking the concrete then go ahead and try and accept those as Okay, so that covers what I want to talk about and review what we've talked about. In this to use them in the go language, we started so how to create them and how to implement something like this. So we're defining an with the type keyword, the name of the interface, of curly braces, things are going to be a a struct. For example, if we were defining of the curly braces, because we're defining interfaces. we're defining behaviors, however, add method signatures. So we see here on this that accepts a slice of bytes, and returns that interface by creating a method on our have to explicitly state that we're implementing by implementing the interface by having the for the interfaces methods, then we talked and how this is a preferable approach versus you can break that interface down into smaller we did that something like this. So we're have a writer interface and a closer interface. like when we compose structs, by embedding, So we can create a writer closer interface interface. So to implement that writer closer method, because it's defined by the writer method as as defined by the closer interface. chunks of your interface around your application. it doesn't need a closer, then you can actually worked just fine versus passing the entire methods to the consumer that aren't really and how we can drill through the interface need to work with those directly. So we had closure instance, and the underlying type and how we could cast that back to a pointer syntax here, where we have a dot after the type We want to cast to know, we learned that when we did this, if the type assertion or application. So remember to use that comma, variable out that you can run tests against And then we talked about the empty interface nothing magic, it's just an interface to find it's special in that every type in go implements you want in a variable of type empty interface. with what's called a type switch. And we see to use the switch keyword, we're going to we do with a type assertion. But instead of against, we put the keyword type in there. going to put in the data type that we're asserting integers or strings, or we have a default an integer nor a string. After that, we talked And we learned about a concept called method directly, you never have to think about this methods assigned to that type. But with interfaces, set of a value is all of the methods with and implement an interface with a value type, interface, have to have value receivers. With because pointers always have access to the a pointer is all of the methods regardless receivers, as well as all of the pointer receivers. when you're implementing interfaces. Just receivers everywhere without thinking about data of that type. And so that can allow methods don't want them to. So be careful when you or value receivers. The last thing that we have evolved over the last few years about talked about use many smaller interfaces whenever go ahead and compose those together with interface that will be consumed. So if you're creating consuming a type, go ahead and publish that assuming you know how people are going to that your type will implement. That way, they in their test suite that they never even use. be consuming however. So again, these two going to think about interfaces, if you're or Java, that have explicit implementation that you're going to be consuming in your That way whoever's using your package can the interfaces that you need. So you don't just need to worry about the behaviors that define your functions and methods to receive So don't go over the top. Use common sense interfaces, for example, if you don't need and define an interface that you're going and functions more flexible. Since you can thought about at design time. And your functions those new concepts are thrown at your application, that we have available to implement concurrent Now, if you come this far in the series, or you've programming is one of the hottest topics that are learning to go language for the first of a go routine, and how that enables us to We'll start our conversation by learning how is going to be the basics of how we create a little bit. Then we'll move into a conversation two concepts, weight groups and mutexes. And to work together. Because one of the challenges is also one of the greatest advantages. Go to work on multiple things at the same time. where you need a certain bit of functionality more of those concurrent calculations is complete. primitives in order to do that. Then we'll up to this point, our conversation is going And concurrency is just the ability of the the same time, it doesn't mean it can work has multiple things that it can be doing. about how we can take our NGO applications calculations in parallel, or in other words, And finally, we're gonna wrap this video up just to talk about some of the gotchas that programming, and some of the tools that are and away from those minefields. Okay, so let's go routines. Okay, so the first thing that Studio code right now. Now, the reason for routines in the playground, when we start limited by the playground, because the playground So when we're running locally, we can use run our applications in parallel. So some going to be easier to illustrate in this environment. is how we can create our very first go routine. to do is we're going to need to have a function hello. And this is going to be a very simple hello. So we'll start with that. And that's seeing what's going to happen with our application. and call that from the main function. So we run and pointing it to that file. And of course, Now, to turn this into a go routine, all we just type the keyword go. Now what that's spin off what's called a green thread, and Now I need to take a little bit of a moment languages that you've probably heard of and system threads. And what that means is that dedicated to the execution of whatever code these tend to be very, very large. They have, take quite a bit of time for the application about how you use your threads. And that's and things like that, because the creation And so we want to avoid that in most programming in go, it follows a little bit of a different place I saw this model was used by the Erlang Green threads. So instead of creating these going to create an abstraction of a thread inside of the go runtime, we've got a scheduler these operating system threads for periods turns with every CPU thread that's available amount of processing time on those threads. level threads directly. we're interacting advantage of that is since we have this abstraction stack spaces, because they can be reallocated to create and to destroy. So it's not uncommon 1000s of go routines running at the same time. at all. Now, if you compare that to other languages have one megabyte of overhead, there's no an environment like that. So by using go routines, a thread, and we no longer have to be afraid let's go ahead and run this and see what happens. because you notice that our message doesn't main function is actually executing in a go six was we told the main function to spawn as soon as the main function is done. So as it didn't have any more work to do. So the time available to it to print out its message. using a horrible practice, but it's good enough we'll just put an arbitrary sleep calling delay a little bit Now when we run the application, out. Now, as opposed to our first run of this, executing this code. It's a go routine that And that's what's responsible for printing typical use case of go routine where we're But we don't have to do that. As a matter here, which is basically the same, except using this anonymous function here. So notice and I'm invoking it immediately. And I'm launching about it is I'm printing out the message variable here inside of the go routine. So if I run the reason that it works is go has the concept function actually does have access to the advantage of this MSG variable that we declared the go routine. Even though the go routine stack. The go runtime understands where to it for us. Now, the problem with this is that the variable in the main function and the how that can be a problem. Let me modify the the variable message and setting it equal go routine. And then right after I launched reassigning the variable to goodbye. So if in fact, get goodbye printed out in the go based on how the program is written. And the to be guaranteed to execute this way. But going to interrupt the main thread until it even though it launches another go routine it any love yet, it's still executing the line 13 and reassigns, the value of the message to print it out. And this is actually creating come back and talk about race conditions at And generally, it's something that you want via the closure, it's generally not a good what are your other options? Well, notice just a function invocation, there's nothing go keyword in front of it, it's just a function. if we add a message argument here, and then the function? What if we pass in the message in by value, so we're actually going to copy actually decoupled the message variable in now, this message that's going to print out we're invoking the function for the go routine. Hello printed out. So this is generally the into your go routines, use arguments to do to be coupled together. Now, this example practice. And the reason it's not best practice we're actually binding the applications performance world clock. And that's very unreliable. So you're typically going to have to sleep for time in order to get the performance to be in production, at least not for something Well, one of the other alternatives that we So let's go ahead and add one in. And then they are. So I'm going to create another variable. helped me here. And we'll pull that from the type weight group. So I just need to put my a weight group does is it's designed to synchronize application, we've got two go routines that executing the main function. And we've got on line 13. So what we want to do is we want go routine. So we're going to do that by telling routine that we wanted to synchronize to it going to add one because we want to tell it Right here. Now once it's done, we don't need to go ahead and exit the application. And group. And we do that by using the weight is done, then it can tell the weight group And we do that by using the done method. So going to do is it's going to decrement, the waiting on. And since we added one, and it's and then the weight method will say, Okay, our application run. So if I save this off, that our application is performing as it did to complete the execution. We're not relying Jimmy run with variables and hope that everything just synchronizing to go routines together. doing any work. The main function in this other go routines. But we can have multiple And we might need to synchronize those together. me drop in this example here, and we'll talk up here on line eight. And then I'm initializing I'm actually spawning 20 go routines, because I add two to the weight group to let it know And then I spawn a say hello, and then I spawn wait method call here on line 17, just to out too early now and say hello, all I'm going I'm going to print out the counter value. I'm just going to increment the counter by I'm going to call the done method on the weight Now notice that I've broken my own rule here, globally in this application. And that makes this object, and the weight group is safe to use concurrently like this. It's ahead and run this application and see what's we're going to print say, Hello. So it should value is zero right here. And then it's going hello, again, it's going to increment it. one, hello, number two, and so on. So let's And we see that we get a mess, we in fact, on here, we printed one twice, and then 2345. we jumped all the way to nine, we printed for some reason. And if we run this again, what's happening here is our go routines are have no synchronization between the go routines, and going as fast as they can to accomplish of what else is going on in the application. a way to synchronize these guys together. weight group on this. But we've already talked another way to do this. So we're going to a mutex. let me paste this example in here, a mutex is basically a lock that the application Now in this case, you see on line 11, I'm is a read write mutex. Now a simple mutex is locked, and something tries to manipulate is unlocked. And they can obtain the mutex we can actually protect parts of our code that code at a time. And typically what we're ensure that only one thing can access the changed things a little bit. We've basically data, but only one can write it at a time. write to it at all. So we can have an infinite so when something comes in and makes a write are done. And then the writer is going to write it until the writer is done. So in this about that line yet. We'll come back and revisit here is I'm attempting to use a mutex to synchronize here in my say, Hello, I'm just reading the what I'm trying to protect. I'm trying to reading and writing because that's what was obtained a read lock on the mutex and then that lock using the R unlock method. Now in the data. So I need to write lock. And so increment the value. And then I'm going to I actually haven't gotten quite where I want that I was seeing before. But you notice that I get Hello, one, hello, two, and then it actually can get different behaviors. But order. So I fixed part of my problem, but running. Actually, that one got pretty close. on here. With the reason that we have an issue routines. So if this say hello, function gets increment function doesn't get called in between. we actually get the same message printing to lock this mutex before we try and read this is we actually have to lock the mutex So we have a reliable execution model. So here. Now all I've done is I've moved the before each go routine executes. And then So if I run this, we actually see that I now through nine printed out. And if I run it everything is working great. So the reason the mutex is in a single context. So the main And then asynchronously, I'll unlock them Now the problem with this application is I and parallelism in this application. Because to be synchronized and run in a single threaded get from the go routines are actually gone. performs worse than one without go routines, And I'm constantly locking it and unlocking all that this application needed to do, we the go routines, and just running this with at all. However, there are often situations by running things in parallel. And so you to synchronize things together, and make sure is playing well together. Now I have this shouldn't have had that in these earlier examples. from the runtime package called go max procs. this go max procs variable, let's just go it's going to do is it's going to tell me the number out that there are four threads available me just add this carriage return in here and better. And you see that I have four threads to do is it's going to give you the number of cores that are available on the machine. cores to the VM. So I have by default four oh s threads that to anything I want. So for example, I can is running single threaded. So now I have at all. So this can be useful in situations going on. And you really need to be careful parallelism can incur. And maybe there's no an architecture problem there. But it is possible way, by setting go max procs equal to one. one does, when you invoke the go max procs threads that were previously set. And if you the values. So this go max procs, negative interrogate how many threads we have available. There's nothing stopping us from creating Now what I found in working with NGO is that to work with. So the general advice is one But a lot of times you'll actually find that go max procs beyond that value. Now if you you can run into other problems, because now you're maintaining 100 operating system threads, it's got all these different threads to manage. it starts to fall back off, because your application different threads. And so you're losing time application closer to production, I would procs greater than one because you want to But just before you release to production, a performance test suite with varying values perform the best. Now, the last thing that to keep in mind when you're working with go a look at those next. Go routines in the go easy to let them get a little bit out of hand. advice on how to work with go routines in is, if you're working in a library, be very, because generally, it's better to let the not the library itself. If you force your actually cause your consumers to have more general, keep things simple, keep things single decide when to use a go routine and when not bit, if you have a function called that's the result, then having the go routine in your consumer never really has to worry about don't really care if it's running concurrently listening for the result on a channel. But revisit that topic in the next video. But to avoid go routines, at least go routines and have them forced to work with them. When to end. Now we're gonna see how to do this But it's really easy to have a go routine So it's going to be just sitting out there going to process those messages as they arrive. go routine, that go routine is going to continue to be a drain on the resources of your application. could even cause other issues and cause your I want to give you some advice about is check want to jump back over to the editor and show and very simple to do in most environments editor and take a look at that in order to this example. Now I know this is right from in there. And it's got some bad practices. then it prints goodbye instead of the Hello could we have detected this without running it's terribly important to be able to do that. of a problem here. And all we have to do is other cases where this is very, very subtle a little bit of help. Well, fortunately, the to you. And it's as simple to invoke as just go build whatever you're using to get your and try that and see what it says about our does run the application because we invoked notice what we got up here we got this data the same area of data is being accessed by says the first one that it found was in go we're profiling, we've got no idea what goroutine on line 11. So apparently in this run, go And it was accessing the MSG variable. It on line 13, which is in our main function. all of this additional information where the and tries to determine if we have any race you if you get any kind of concurrency at to run this because it's very simple check to help you prevent very subtle bugs from Okay, so that's what I have to talk about. more. But go routines are really quite simple. which will be about channels, things get a are relatively straightforward. So let's go about in this video. In this video, we learned to create concurrent and parallel execution how to create go routines themselves. And front of a function call, we've created a There's no special semantics, there's no special function call with the keyword go in front we in general want to pass data as local variables. function and pass data into the go routine, any kind of race conditions as you try and true. We saw with weight groups that we access we truly did want that to be available in a pointer in, in order to be very clear about access to. Then we talked about the different together, one of the challenges that we have of things happening. And there's no way to going to interact with one another. Now for a problem at all, because the two might not into situations where you're relying on the needs to know the result of the work that's And you need to make sure that those go routines at the same time. So we can use weight groups So we saw that we have three methods that to inform the weight group that there are the weight method that's going to block the group is completed. And then we have the done lets the weight group know that one of the We also talked about the mutex and the rW protect data. So if you have a piece of data in your application, then you can protect To ensure that only one go routine is manipulating parallelism and how parallelism can introduce applications. We talked about how by default to the number of available cores on the computer can change that by using the go max procs talked about how more threads will generally slow it down. So in general, if you're developing one with go max procs greater than one to early on in your application development. as you get close to production and you have with. To find out what the best value for while the starting number is a very good number perform better with a value higher or lower up with a discussion of some best practices routines. We learned that if you're a library go routines that are going to be exposed to control the concurrency of your application place to know if something needs to be executed concurrently. When creating a go routine, to get into situations where go routines start up because they never quite get done with as soon as it finishes its execution. And function runs in a go routine. And that go exits. We also saw in our say hello function, the function exited. That go routine was killed when those go routines life cycle is going that are listening for messages in a continuous to shut those go routines down so that once that they're using. Also, as you're going for race conditions, it's not that hard to go command that's compiling your application. your application and try and locate places the same memory at the same time, or in an potentially very disastrous bugs where your the course of this video series, we've talked tools that are available. In order to get go language. Well, I want to wrap up that one of the features that makes go really stand to work with. And that is this concept of are out there, were originally designed with concurrency and parallelism came into play, side. And so a lot of times, you're actually and packages in order to help with data synchronization a multiprocessor world. So every computer more than one processing core. So it made consider concurrency and parallelism from about go routines, and how go abstracts the called a go routine to allow hundreds or 1000s on in your application at the same time. On channels, and how those can be used to pass that is safe, and prevents issues such as that can cause issues in your application So we're going to start this talk by talking about how to create them, how we can use them talk about how we can restrict data flow. can send data in and we can get data out. able to do with the channel. Sometimes you channel. And we'll talk about how to do that buffered channels, and how we can actually so that they can store several messages at aren't processing data at the same rate. Then once we're done with them. We'll then revisit how we can use channels with a four range by talking about SELECT statements, which designed to work in the context of a channel. the basics of working with channels. So when we're working with channels in the be working with them in the context of go are really designed to synchronize data transmission ahead and get started by creating some go that I need to do is I need to create a weight video, we use weight groups in order to synchronize the weight group to synchronize the go routines all of our other go routines to finish. And to synchronize the data flow between them. going on in this little application. The next channel. Now channels are created with the no shortcut around this. Now a lot of uses other forms. When you're creating a channel, to fire that you have to use the make function set up the channel for you. Now on the simplest channels, we're going to use the channel keyword then we're going to provide the data type Now you can pick any data type that you want, But keep in mind that this means that the integers through this channel that we're creating could only pass in strings. If you provided pointers to integer, you get the general idea. to create that channel to accept messages to receive them send messages of that type. have to go routines, I'm going to spawn so And then we'll go ahead and create those go So let me just drop in the rest of the code is an anonymous function actually both of receiving data from the channel. So this go go routine. And then this channel is actually way that we send a message into a channel arrow syntax, so we're going to use a less into the channel we list the channel first, that we want to pass in. So imagine that the want the data to flow. So we want the data is pointing toward the channel. Similarly, then we're going to put the arrow on the other than and dash, but it's going to be before data from the channel. So in this line right data from the channel and assigning it to we're going to call the done method on our the value out. So all we're doing here is value 42, this go routine is going to be receiving in this case, of course, will be 42. And it's let's go ahead and run that. And we see that doing this is since we're sending a copy of the variable assigned here. So for example, equal to 42. And we can pass in I and then matter because like with all other variable into the channel, we're actually going to it afterwards, the receiving go routine doesn't variable, it's not affected by that at all. is if you have data that's asynchronously very, very quickly, but it takes time to process that data. So you've got multiple generators, might want to have a different number of go then you have receiving. So let's take a look to the example that we just went through, once, I'm actually creating go routines inside five sets of go routines. So each one of the here, which is exactly what we had before. is again, just like we had before. So by the to spawn 10 go routines here, five senders to be using this single channel to communicate run this, we see that we do get five messages Okay, so this works out really well, well, around with this, and you decide to start asymmetrical, things won't work very well. to play with this example is take this go So you're gonna have one receiver and multiple isn't going to work right now. Because if to process, it's going to receive the message print and then it's going to exit, but then to spawn five messages into that channel. five. And if we run this, we're actually going all routines are asleep, that we have a deadlock we have these go routines down here that are But there's nothing that can process them. is the reason that this is a deadlock. And is actually going to pause the execution of a space available in the channel. So by default, means only one message can be in the channel loop gets happily spun up, it pushes a message calls this done method on the weight group. go routine here and everything's happy. However, go routine comes along and tries to push another statement. And there's nothing in our application that's why we see the go runtime. Notice that it notices that we have a problem, and it to go back to our previous example. And actually Because I want to show you that notice that this is perfectly valid code for us to write. this, we see that we get two messages printed go routine is pushing a message into the channel. this go routine and printed out this go routine then putting a message back into the channel. and this go routine, which is then printing are actually as readers and writers, now that often, you want to actually dedicate a go writing to a channel. So in order to do that, to pass in the channel with a bias on the with. So the way we're going to do that is So we'll start with this first one here. And So the way we're going to do that is we want we're using that similar syntax, we're going we're going to have this arrow coming out And so this is going to be a receive only channel, we're going to give it the variable now we put the Send only operator right here, going to be sending data into the channel from the channel. And then of course, we have arguments. So when we run this, we're actually an error is because we're trying to pass data channel. So it's invalid to send data into here on line 21, because we're trying to receive go ahead and wipe out these lines here, this works as it did before. But now it's much routine, we know that we're going to be receiving data on the other. Now something that's a passing in a bi directional channel. So this it a little bit differently. So this kind behavior. And this is a special aspect of And so it actually is going to, I'm going this bi directional channel into a unidirectional generally do in the go language. That is something problems we ran into on a previous example five messages into a channel, but we only application deadlock, well, we can get around going to show you one way to get around that problem. But I will talk about the problem channels. So if I go ahead and paste in this problem we might run into. I've simplified we ran into. So we've got our initial example we've got a send only go routine. But in our messages. But since we're only receiving one, So let's go ahead and run this. And we see the 42 out and printed it. But there's nothing channel. And so the application blows up, because it's blocked on this line. So we need to get around that is by simply adding a buffer make function up here, and provide an integer, a channel that's got an internal data store Now what that's going to do is it's actually But we do have a little bit of a problem here the panic. And I guess in one way, you could another problem in that we lost this message. are really intended to solve. But I do want store, so we can receive multiple messages do is we can just copy this line down here column right here. And if we run this, we out. Now what a buffered channel is really operate at a different frequency than the data acquisition system, and maybe we retrieve so maybe we're acquiring data from seismometers, those seismometers in order to conserve power, going to send a burst transmission, maybe get a burst transmission that maybe last five entire hours worth of data. So in that case, when that burst happens. And it's going to the receivers might take a little while to might want to do is create a buffer here of seismometer, that's going to be able to accept receivers can pull that data off, as they're smoothly, so that the channel that's receiving up, because it doesn't have a place to put go routines are designed to work with, is little bit more time to process. And so you you have a little bit of a delay there. Now situation, what is the right way? Well, the going to happen multiple times, such as passing kind of a looping construct. And that's no else. So let's paste in this example, where then having this first go routine exit, I'm notice what I'm arranging over, instead of ranging over some kind of a collection, ranging over the channel. Now the syntax changes slice, the first index that we pull back is the second variable we pulled out, if we had, be the value. Well, when you're arranging When you pull a single value, you're actually the channel. And so if we run this, we see have a deadlock condition. So what's causing this four range loop, we actually deadlocked died. We're in our new application, we're And the reason for that is because we're continuing stopped sending messages. And so now this And so this go routine is now causing the situation, we kind of move the needle where but we are still dead locking in our receiver. we're going to handle that is we have to understand using a for range, loop over a slice, how the loop once for every item in the slice. in it, you're going to run through the four are in a channel? Well, there can be an infinite can constantly push a new message into it. loop with a channel that there are no more to close the channel. So anything that has to use the built in close function. And we're here. So what we're doing on our sending side in 42, and 27. And then we're letting the So we're going to go ahead and close the channel, And when we run this, now everything runs 42, that gets processed in the for loop, we're close the channel, that gets processed by channel is closed, and it's going to exit we terminate the loop, then we call the done the go routine, all of our go routines exit deadlocks. Now we do have to be a little bit careful a channel, you really have to mean that you're the channel right here and then pushing another get a bad thing happening. So in this case, because we tried to send a message on a closed channel right here on line 21. And then on into it. So that is a no, no, you are not because the channel is closed. So you might do I reopen the channel or undo that or whatever? of fact, you can't even detect if a channel panicking. So call that a limitation of the do have to be very careful that when you close message into it. So if that is a possibility, have a deferred function and use a recover thrown because in this situation, you will it. So if in your application, that's a situation going to have to use that recover function. about using those. Now on the receiving side, here, because this issue is on the closing closed channel. And we can't detect if a channel into it. However, if we go on the receiving So you might ask the question, how does the it has to have some way of detecting it, what that you can pull back from the channel. So trying to get a value out of a map, and we syntax works for channels as well. So if I is going to do exactly the same thing as our but instead of using the four range loop, closed channel for us, we're going to process and show you so notice that I'm in a for loop on it. So this is going to execute forever. the channel, and I'm using the comma. Okay, the channel and I and I'm going to get a Boolean in the okay variable. So if the channel is channel is closed, then Okay, it's going to then I'm going to go ahead and print out my of this for loop here, because the channels any more messages from it. So this is functionally But we're explicitly seeing this comma, okay, Well, in this situation, it would make more there may be situations where you're receiving So maybe you're spinning off a new go routine And so the loop is going to contain the spinning to need this comma, okay syntax, because it loop. Now, the last thing that I want to talk statements. So let me go ahead and paste in last video, how there can be situations where obvious way to close. And that's what I want and run this, we see that we do get these simple logger implementation. So what you declaring my log level, I've got a struct for the login tree, the severity of the log to print out, then I'm creating a log channel. first thing the main function does is it spins logger. And what it's going to do is it's log entries that are coming from throughout central logger, and anything that could do about this channel. And all of my logging of those log channel messages. So the logger that's listening for messages from the log out a formatted message that's got the timestamp, from the log. So no big deal here, nothing on to exercise that a little bit, it sends it know that the application is starting another down. And then I've got a sleep call here has enough time to process that. Now you notice because I'm working with the playground, I over to Visual Studio code, you will actually the playground doesn't give you the current this is just something that we're going to problem I want you to consider is when does the logger go routine has to terminate sometime we get the results back from the playground. is shut down as soon as the last statement when we finish this sleep call here, the application all resources are reclaimed as the go runtime back to the operating system. So what that torn down forcibly. There's no graceful shutdown out because the main function has done. Now be acceptable. But there are many situations a go routine. Because remember what I said have a strategy for how your go routine is routine. Otherwise, it can be a subtle resource that it can bring your application down. So do here, right, we could of course, do a defer And inside of that, we could go ahead and to do is when the main function exits, it's then we are gracefully shutting down that no issues with that we are intentionally closing is going to close. And so this is perfectly what I want to show you. So this is certainly But I want to show you another way that very So the way that I want to show you is using go ahead and paste in that code. And we'll is basically the same, I've got the same constants have this additional channel here. And notice typed, but it's strongly typed to a struct in the go language is unique in that it requires you will see a channel set up like this. And except for the fact that a message was sent only channel. There's zero memory allocations have the ability to just let the receiving is pretty common, you might be tempted if you send a Boolean in here. But that does and copied. So it is actually better to use of memory allocations. It's a little bit minor. to use a channel as a pure message, then you use this approach. So our main function is our logger, we've got our log channel, sending sleep call here. And then inside of our logger and we're using this select block. So what is going to block until a message is received for. So in this case, we've got a case listening case listening for messages from the done channel, then we're going to print out our channel, then we're going to go ahead and us to do is at the end of our application, our dumb channel. And that is going to be that empty struct on the fly here. So this is the type signature for my struct. So I'm I'm initializing that struct using these curly you see that the application runs properly. I pass in this message into my done channel is a common situation for you to use when way to have the go routine that's monitoring often you're going to send in normally as done channel. And then whatever's ready to a message into that done channel. And it'll I do want to talk about. And I'm not going our application here. But you can have a default becomes a blocking SELECT statement. So what ready on one of the channels that are being code path. If not, it will execute a default a non blocking SELECT statement, then you you don't have the default case, then the a message does come in. Okay, so that's what go into a summary and review what we've talked and how we can use them to synchronize data out by talking about the basics of working make our channels using the built in make that we have available in the go routine to those channels are strongly typed. So we're that we wish to create a channel and then that the channel is going to be Send and Receive. be a primitive like we see here with an integer, But it does have to be strongly typed, we this arrow syntax. And the position of the the data is going to flow. So in this case, the value that we wish to send into the channel. the channel. But when we went to receive messages out of the channel. And so we're going to is going to be added after the arrow instead and receivers. As a matter of fact, it's very for one channel to be distributed among multiple data generators that are sending messages receivers. And that allows you to balance So if you can generate data 10 times as fast 10 times as many receivers. And that way you and receivers. We then talked about how to restrict data constructs, so you can send and receive data though, is our go routines to be designed So we saw that we can do that by passing in So for example, in the argument list of the that we can work with by again adding that the chain keyword. Depending on what kind a send only channel by putting the arrow after only channel by adding the arrow before it. how buffered channels contain internal data of channels that by default, a channel will available, and the receiver side will be blocked the channel. So you can actually block a go side of the channel. So if there's no position then the sending side will be blocked until no message in the channel, then the receiving becomes available for it to work with. So as a second argument to the main function. an internal buffer to decouple your senders where data is generated faster than it's received. buffered channels when sending and receiving messages faster than we can receive them, a really good way to go. We then moved on how to work with them with channels. And we way. But there are a couple of subtle differences. you're going to receive from the four range itself, not the index, like we saw when we and maps. And we saw how we can use for range as they arrive. So the four range loop is come in off the channel. And it'll process closed, the four range loop is going to detect And finally, we talked about SELECT statements, but they work only in the context of channels, several channels at the same time. Now if if there's no messages available on any channel, And then when a message comes in, it will If multiple channels receive value simultaneously, because of the highly parallel nature of many where messages arrive on two channels at virtually get the nod from the Select block, but you it. So there is no rule like in switch block to get it, it could be anyone. So the ordering doesn't matter from the standpoint of how Now if you do want a non blocking SELECT statement, in there. So if there are no messages on any case will go ahead and fire and so the select go routine will continue from there. Okay, so that wraps up what I have to talk about the end of the discussion that I have for is Mike vansickle wishing you luck in all Take care