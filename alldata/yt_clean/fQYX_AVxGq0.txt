Super Mario Bros. 3 is a game This video will be covering a TAS I 0.215948- Wait. Hold on... I can turn this into a fraction! Three hundred and eighty six thousand... Less than- Less than a quarter of a second. And in order to beat a video game you can imagine there's a lot to explain. Let's not waste any time. A Tool Assisted Speedrun is nothing more than It's like a MIDI playback, but For instance, suppose we Mario falls in the hole and dies. By using emulator tools, we can We can also use other emulator In theory, if we take enough time to put in enough effort to optimize things using we can create the &quot;perfect run&quot; of a video game. Or maybe instead of going for the fastest Or even showcase a glitch A Tool Assisted Superplay is a type of TAS For instance, I have a video explaining along with footage of DOOM, can using nothing more than a But for this video, let's talk more I also believe the context behind this How did we get here? On the TASVideos forum page for Mario 3, A user named RAT926 made an interesting discovery. They were exploring around entering Shared via a &quot;.fm2&quot; file: (A TAS file for the FCEU emulator) RAT926 entered this pipe in the wrong direction. After exiting the pipe, The cut scene returning the wand to the king! Though Mario was currently stuck in a corner of Wohoah-oh-ho ho ho ho hough! Here in the future we have as we know this trick has... other uses. Within 3 days it was discovered that this can be used to warp directly to An upoptimized proof of concept And by the end of the month, completing the game in 2 minutes, 54.98 seconds. Now, the fully understand you kinda need to know the basics And in order to know how the even faster TAS Unfortunately, this video is not But I will attempt to explain everything in such a Here's what's important. Assembly is &quot;Assembled&quot; into Machine Code. It's just a series of bytes. These bytes are processed one at a time. The Program Counter, or &quot;PC&quot; It's like how a karaoke machine tell except instead of words it's Typically, the Program Counter is pointing to ROM. Somewhere between address $8000 and $FFFF. But RAM, which is from address $0000 to They could be interpreted as instructions! In fact, there are several games that will Anyway, the point is: It can happen, and Whether intentional or not. If you are able to manipulate those bytes &quot;Arbitrary Code Execution&quot; Mario 3 has code at address prepares the victory screen of the game. If we want to move the PC to $8FE3 in order we need to execute either a JMP or JSR instruction Executing it, and winning the game. Basically, hitting this noteblock eventually underflow The Stack, and move The X positions of enemies is at address $91. So as long as those 16 bytes between address we can write assembly code using JSR $8FE3 is written as: 20 E3 8F. Which, when executed, wins the game! And that's how this TAS by Lord Tom and Tompa Anyway, now that I've explained the let's talk about the actual purpose of this video. The TAS that beats in game in Suppose we're trying to find a new We need a new method to move the PC to RAM faster. ais523 devised a new method. And then total_ used it to beat This was showcased at SGDQ 2016 so the audience could see But UH- OH! The game softlocks in the credits! In 2019, Masterjun created a version of I would like to emphasize the 2019 submission by Masterjun and ais523. Along with the efforts of Alyosha, who this run paved the way for &quot;subframe speedruns&quot;. I would also like to emphasize that their and it's easier to just explain my TAS. So, what's this new method If you've ever seen this TAS, It's the DPCM Audio Bug Workaround Exploit! And I promise I will explain The audio chip can play PCM: Pulse Code Modulation, and DPCM: Differential Pulse Code Modulation. PCM audio is done by repeated See the Bad Apple TAS explanation for an example. DPCM audio samples are played by writing to and the entire sample is played 1 byte at Whenever the audio chip needs another or, &quot;Direct Memory Access&quot;. However, this DMA, (which is the way the audio chip reads from ROM in order to prepare for the next 8 has a negative side effect. You see, typically, the way the DMC DMA works (Sometimes it's only halted From this table, you can see next sample and store it in the shift register. After that happens, the However, here's the side effect. (Simplified) If this DMA happens during an instruction this also &quot;clocks&quot; the controller. &quot;Gasp&quot; What does &quot;clocking the controller&quot; mean? Basically, here's the way controller First, the controller is &quot;Strobed&quot; which records the buttons currently pressed into a To fully read a controller, the Each time sending a single bit to the CPU. There are 8 buttons on the controller, so If the DMA happens on the wrong an extra bit is shifted, effecting Brief recap: If the NES is playing DPCM audio samples and the next byte of the sample is fetching while the controller data is corrupted. This is called the DPCM Audio Bug. This is a hardware bug of the so it would affect every game The developers of Mario 3 The music uses DPCM audio samples for the drums. So the programmers needed to solve a problem. How do they prevent data from the They need some sort of... DPCM Audio Bug Workaround. Suppose it's the 80's. You are a programmer working at Nintendo on Let's say, about 1% of the times you the data read by the CPU was incorrect. You are tasked with programming a solution. There are several ways to work around this issue. For instance, if you were incredibly savvy, you might know that the issue As the programmer, when playing DPCM This means, you know the exact number of The fastest sample rate will take and reading all 8 bits of the Here's where you, the programmer, Why should you only read the If you read the controller multiple times, If you read the controller twice you know mathematically that the This is because the 432 cycle rate of the DMA is longer than the time spent If you read the controller twice it's impossible to tell which Discard the first value read, and run Still no match? Discard the This is the DPCM Audio Bug Workaround. And yes! This does prevent the DPCM Audio Bug! However, in a world where we can press and I mean ANY moment, we could exploit this! What if, when the controller are being read, we maliciously decide to change every time the controllers are read. We're changing inputs at a Not quite feasible for a human, What does this achieve? Well this moves the PC to RAM. But, why? Let's talk about the IRQ, or, Interrupt Request. It's a way for the programmers to a precise moment in the screen rendering process. Regardless of what code is if the IRQ occurs, the PC Eventually, an RTI instruction will be executed, Mario 3 uses it primarily to keep the HUD in The level geometry is rendered But after the 192nd scanline, rendering is disabled, the VRAM address graphical banks are swapped out, Different situations in the game have different Wait for a specific scanline, For the title screen, this is floor in one place while the curtains can rise. And the cause for the PC moving IRQ's jump to the code for the checkerboard floor. The logic for the NMI routine will swap out schedule the IRQ, read the controllers, At least, that's how it's supposed to go. Banks are swapped out, the IRQ is scheduled, we maliciously press different buttons at and then before the banks are The IRQ routine's logic checks the value of address $101 and determines The PC is move to address A826, which *should* be the code that adjusts but the wrong program banks are loaded! Since the IRQ routine pushes data to the stack, when we execute this RTS instruction, the data Obviously this was never meant to happen. This pulls off 00 and 00, which And then the instruction ends, That's right! We're executing RAM! Remember the wrong warp TAS? We used the enemy X positions since the enemy X positions and those bytes get executed. Now we're in a similar situation. The contents of RAM will be Only now, instead of enemy X positions, we From here, we need to know what Address $17 and $18 are As well as address $F5 and $F7. Address $F6 and $F8 are These bytes are the total held and newly For instance, If I'm holding down the start and on this frame I press the right button, The total held is Start + Right, In a similar way to how you can write Assembly I could write 2 bytes of Assembly code by pressing a specific combination of buttons If we use the bytes at address $F5, we have a total of 4 bytes to manipulate. This could allow for some actually However, Mario 3's controller reading That means, I'm not able to The same applies for Up + Down. Unfortunately, this limits the code If you were thinking about writing a jump to And yet, not all hope is lost! There are 2 more bytes we have control When we perform the DPCM Audio Bug Workaround Exploit by pressing buttons the final buttons that we press for controller 1 I recognize that this part of I initially planned to talk Most of these details aren't even relevant to Pause the video if you want to Otherwise, let's talk about the goals. 1.) We need the Stack Pointer to be greater than $30. It is currently... 8. If this condition isn't met, the stack being used for &quot;normal stack Which is important because... 2.) Address $100 needs to be $20. In a similar way to how address Address $100 is used for the NMI routine. If it's not $20 during the And finally... 3.) We need to jump to address $B85A. Before I walk through my TAS, let's We're only going to be setting up requirement But that's okay. After all, we're just using this a better understanding of Also, for simplicity, we're only going to Let's open up Bizhawk, load Mario 3, This will allow for subframe We'll open up TAStudio. This is Let's begin with a series of alternating inputs. This is the DPCM Audio Bug Workaround Exploit. The DPCM Audio Bug Workaround Exploit The Program Counter reaches about address $0007 During the NMI routine, controllers are read. For controller 2, I'll press A + Start + Up. I won't press anything for controller 1. The NES will continue processing until VBlank, and the NMI occurs when the Program During the NMI routine, controllers are read. I will continue to hold A + Start + Up on I'll press B + Start + Left + Up 5A 20 5A B8 at address $F5 through $F8. When executed as code, this will be: NOP, JSR $B85A This will run the princess rescue the game has softlocked since You may recall the issues we had We're unable to write 8F or However, by using the the function to set up the credits Address $8FF4. This is the key ingredient to making the run work. I will now how a run of this game can satisfy all The console is booted up, and I I perform the DPCM Audio Bug Workaround Exploit, and the final inputs for Then the final inputs for This will store $20 and $90 A surprise tool that will help we're executing address $0001, so The PC reaches address For this next set of button presses, (If you need to know why, and then I press Select on controller 2. For controller 1, I press A + Select + Left + Up. This will store $AA at address Opcode $AA is for the TAX When this executes, A is equal The NES will continue processing until VBlank, and the NMI occurs when the program For this next set of button presses, I will For controller 1, I will let go of select, continue holding A + Left Address $F5 through $F8 now reads: 10 00 9A 20. When executed, this is Branch on Plus, 00 bytes. This branch *is taken*, but Then, Transfer X to Stack Then JSR $0000. Address $0000 reads: 20 00 90 since while running the first frame's This is executed as JSR $9000. This is slightly offset or ISC $A8A9, X In case you're curious, ISC but this instruction did not affect After that, executing from The value of address $100 is set to $20, satisfying requirements 2 and 3. The credits play in full, and Super Mario Well that was exciting. In case you're curious, Super Mario Bros. 3 is Many other games have a similar and so they too can be infinitely Now, the case of Mario 3 is specifically due to and it's also lucky the IRQ routine Different games have different orders of That being said, I have created The Legend of Zelda, and Gimmick! But those would definitely In the many years it took me to get around to and I found a way to beat Super Mario No really. I spent the past several months working on this, This is your queue to subscribe to And that's about it! In the meantime, if you want to talk about feel free to join my discord server. If you want to support me, I made a keyboard which is currently on sale!!! Check out the free demo while it's on sale, and I'll also be answering questions about this video I will go into ridiculous detail By the way, thank you so much I plan to start taking my youtube videos a And with that, I think I'm done here! I'm off to beat Mario 3 even faster. I hope to see you then.