In this intermediate react course about React you about hooks state context, using request Hi, I'm Jack Harrington. I'm a principal super excited to be here on Free Code Camp, react state management. And the first thing I what is state management. So state management think about it, you've got the presentation you format it. And then there is the data and to me state in state management is the beating it actually is, the only time a React app will item to a cart, when you remove an item from renders. And so state is the engine that moves to say that reacts whole job is to turn state this video, I'm going to give you a complete can manage state in your React application. And management. This is the hooks we've all come to use memo and use the fact we are going to drill in understand them because they are the foundation models are built. In the second section, we're are third party libraries like React, query, primary job to manage state, but react query, the server and it gets it back. And now it holds And perhaps the combination of native hooks, React query or application is enough for your And then in the third section of the video, we're third party libraries whose sole function is to sheEO and zouche done, and we'll talk about the select for your application. And then, at the end, with some react RFCs that are just coming out about how we might want to manage state in our recommendations about what I suggest you might technologies for your app. But it all starts with get right into it. So we're going to start off by and in particular, concentrating on the use a VT application, I'll do that using yarn, create you want, so I'm going to going to use native use web applications can take multiple templates, Alright, now I'm gonna bring that up in VS code. Alright, so here we have our And then we'll do yarn to install all the And I'll click on this link. And there you go. a little bit of interactivity, a little state in that we see here to start. So where is that And I'm going to remove pretty much all of this. But we'll keep around Eustache because we know we're gonna do is experiment with using a numeric way to do that. So we're going to basically this code is available to you on GitHub for free you can just follow along me if you please. So that we have some state associated with this And we'll start our counter off at a Now the output of use eight is an array. So let's the first item is the current value of that And then the second item is a setter that piece of state. So call that set count. And let's take a look see what it looks like. kind of hard to see a little bit. But it's got want to create an onclick. So how do we do a function. So we're gonna say add one is our So here's a mistake that I've seen people I think the idea is that well, count is just retained. So let's try that out. Let's see if that And so why is that? Well, we're seeing that we're what's outputting? That is actually console ninja, Wallaby link to that also in the description down So well, okay, we get it. This is defined as a let, and maybe that will work. All right, let's but we don't get an error. Interesting. Okay. is really critical to understanding pretty much spend a bit of time on it. And one of the things how this is actually working. So I'm going to worksheet. And what we'll do is I'm going kind of like use date, so we'll And let's say that it has some value and say 42. And then when he called get now down here, I'm gonna call get state. gonna go store that somewhere. So I need to And we'll just ask cuaca, what my value is. now my value is 22. Cool. But what happens when value again. And now my value again, is still 42. your local copy. So scalars, and that includes this case, are returned and passed by value, where reference. And there's a huge difference there. you don't get it, you get a copy of it, which Jack, you know, you got it all wrong. And Go try the same thing with array. All right, we set the local copy to 22. And then we again, of thing down here. Right, all we're doing is Now there actually is a way to kind of make JavaScript enclosures. But when you hack around React is actually managing state. And the proof is So what works is to use that set count function count plus one, or whatever you So let's go over So now I mentioned that count is associated with this component is the app, right? So we have multiple ones of these, let's go and And then we'll make a new app, then we'll just Now we have one counter down here. Let's go make And now we can click on each one of them. And mean by the state being coupled with the instance these counter components, maintains its own in independently, you take each one of these, and we talked about how to manage a scalar, a simple manage an array. So we do that a lot as well. So we're going to have an ability to add a name to And I'll create a new function, which So let's create some state Jack, Jill and John. In fact, actually, so that's good, okay, good. And now Nice, and let's go and All right, good looking list there. Alright, to that array. So we need an input field. you can have multiple pieces of state we're just going to have another, here's a And then we need an input field. Now when this text changes, we get an event. And target of that event being that input. And within be the last thing that the user typed or the last to that target value. And again, we're using the equals target value, because we know for strings, we don't get back the real thing. So we can't So now we've got our set. Let's go take a look. Cool. So now let's go and add a button so we can click handler that is going to respond to clicking Okay, so here we have ADD name. So how what we could do is good just Alright, let's go check this out. I'm gonna go hit Add name, and nothing happens. But here's the component, we'll get a rerender. So the state of the Name field, which calls It sets the name. And it also in queues a When the rerender happens, we get that same list. difference here between scalars and references. You get back the value, a copy of the value when it comes to objects and arrays, JavaScript react a reference to this particular array, it it holds a reference to that array. And then we then use an in place command push to mutate as we add more items, when we do a The problem is that react has no idea that a setter does, which is to in queue, a doesn't happen. So what if we did And we'll just give it the same list again, I is just going rerender. Okay, let's try that. So So here's the deal. When I call any it looks at the old value, and it looks at the new same, it just says I don't care. Thanks. But you we're doing in this case is where we are giving it So it's looking at those two references and just asking me to do nothing really. And so it in order to make this work is instead of in place, the contents of the old array, plus the new name. We'll give it all of the old and then we give it our new name. Now we And away we go. Even better, we can do Then after we add it, that's set to an empty React 17 with React 18. These setters are value in queues a request, set name runs, right request to rerender. The component. React says and it just ignores it. And then when the rerender Now the last thing I want to cover about is that you state also can take a function example here of a single simple string, And that function will return And there you go now is initialized is that if you've got some sort of in the creation of this use state, you can function will guaranteed only ever get run Let's continue to take a look at native state reducer, which is another way to store state in Alright, let's go and create another example reducer. And again, this is available to you in And I'll bring it up in VS code. Let's install it and then run it and bring So let's pare this down again. Okay, we're all cleaned up. But before we get into a reducer function in general. And a good way to and look at the reduce method on an array. And we want to total up those numbers. And then we'll iterate through all the numbers and what do we get? We get 6010 plus 20 plus 3060. way to do that is to use a reducer function. And that reduce function takes two which returns something, and then it takes an be the same as this total would start off at function takes two parameters, it takes the And then it takes the number at the given index out with 2010 20, and 30. So we'll call that for the next iteration. So in this case, we want and then add on each number as we go through. how cool is that? So this function right here, it takes two parameters, it takes the current the case of numbers, because we're iterating numbers as we go through. And then the output of a So this reducer pattern is going to show up in two the user reducer example that we're going to build learning how reducer is work is beneficial across with use reducer here? Well, we want to rebuild name, and build it all in one piece of state And we'll invoke it. And the first thing that's so the state is going to have a list and then it's going to have the current And that is going to be the state. So use that array has two elements to it. The that would be this object here. And then it invoke the reducer function that we're going And the reducer function takes the existing and then it'll take some sort of action, that dispatch. So we'll just call that action. and that object has a type on it. And then you mutate that state and return a new state based let's just start with setting that name. So we'll a type which comes in from that action. So when that has a type on it. And then we'll create a our first thing is we want to be able to set that And now we want to return a new version of state. have a name that comes in on a key called payload. really rename these keys all you want. But it's value that comes out of this array is dispatch. our input. So let's go create the input here. So And the value is the name that comes out of and that gives us the State DOT name. And and then we're gonna give it an object That type is going to be checked here. We're going a payload and that payload is again that target And then dot value is going to give you your go and you know what just to check it let's go All right, let's have a look. Okay, so we've got what's actually happening here. So what's actually by step is we have an input field, it has the a change event, which tells us we have some sort a type of set name and the payload that then is going to be this names as an empty array, and then an action, that action And then we just create a new object But let's talk about that whole references and So let's just say that we're not going to do And we'll just set the name to that Refresh, we type and nothing happens. And the references coming out of use reducer. reference. So it can't see it's not going to at the inside the object and say, look, the it's going to look at the reference to the object. And then just mutate the fields that we want to which mean all of names. And then we just whatever is coming in off that payload. So add an item to the array. So let's And we're going to turn another new object, that state again, that includes names and names, but that has all of the existing names in it plus the And I think actually, also, we air. So easy, there it is, we can actually It's pretty cool. Alright, let's go down Call this add name. And with an onclick And you know what, actually, we don't really even state. So let's go and just do add name. So this just stayed on in there. Yeah, that makes more right? All you're doing is basically say, hey, Add name and now we don't really at least it remove the existing name. what we have that list of names to Hey, pretty cool. So as you can see, use reducer in this case, we have an object that has two an object who have a lot of data in it a lot way to do that. And you could go and take this and then test it independently and not have to So I think it's actually a really nice way Alright, now one more trick I want to show like this one. So let's go and call this name Then we'll use namelist in there. Okay, so we're And in here we're gonna have two So let's make a div. And then within that we'll we'll just say that Our value is going and then we'll have state DOT last. Okay, so let's use a reducer for that. So our reducer function quite yet. Let's go in and And then we'll get that All right, great. Okay, cool. So let's Nicely, I have two fields there, So here's the trick. And I really love we're going to combine the state existing Just like that, it's so easy. Fact actually, How cool is that. And now what we we can just dispatch with So we send the first then first overrides the same. And the same with last. So And now you have two fields. And let's prove First is first, is a dot first, Perfect. That's sweet. So you don't have to have pattern here, you can manage very easily, large want. It's a nice pattern when it comes to use a look at two ways to observe state, use callback state using use state and use reducer, let's talk that would be use memo, use callback and I'm going to cover just use memo and use callback. actually the most simple, yet somehow the use memo as use calculated value. So let's So here, we would define some state, we and we want to total it up. And in fact, that we saw before. So how do we do that? We take numbers we call reduce on it, then we add each number in succession to that and then that gives us our total. So we But of course, I need to bring And I'll see like, oh, there we go. Total 60s if you will, if this array was monstrous, huge, want to recompute that anytime that app rerender, react re renders our component, the entire only really want to recalculate total when numbers or use calculated value, as I like to call it. a function and that function does the Alright, so far, so good. And then it And this is where a lot of folks anything that you read from should go into we are reading from numbers. And that means array and what this will do is it will only Anytime numbers changes, and in this case, case, but we don't actually add anything to it or And there we go. So there are two times when you example of one of them. The first time you want to and the process to create that value, it might that you want to do, and in this case, numbers no matter what the output is, if it's a number or that's fine, you want to use use memo, whenever want to do on every render, you you want to make sure that you only run it when memo is when you're creating an array, or an and objects by reference. And so it's important in the start of this video. So references those stable. So let me show you an example of Perfect, The Beatles, John, Paul, that's awesome. And now let's go and And you know, it would just do an in So now we've got the names, but you know what, Now let's take a look. Okay, well, that's actually Okay, all right. So we've got a good sort of names up here. So why is that the me we start with John, Okay, so what's actually happening here is that mutating, named in place. So yeah, we're getting array has been sorted. So the first thing we want And then we sort the copy. Alright, so now and we have our assorted names, and our original the code. And let's see. So this is good. But to rerun this sword. That's not particularly render the ones. So let's go and put in a use memo And so what does this depend on? Well, we want to rerun that sort. So this use of use it would be important to use use memo. First, it's have a very long list of names, and you don't want Awesome. It also falls into my second category, So this is a really good use of use memo. Let me memo and that's for very simple calculations, for So now we got count one and count two. All right, looks good. Let's go to trial. these two. So right now, that'd be around So I'm going to create a count total. And I'm an add count one to count two. And then Hey, nice. Okay, cool. I'm gonna get back to not a good use of use memo. And it's because the number or a string or Boolean, so you don't really overhead in this case. So all you need to do is That's it. So now that you know what use memo it. The first myth around us memo is it is somehow so I'm not sure how that happened. I guess somehow react memo. But it's not that it's just calculated value and react memo which memorizes in certain circumstances is just completely, I've heard about use memo is it is a performance from, I think it might come from the CS concept you memorize a function, and then that memorized that sent to it, and only if it sees a new set of it will send back a value from that cash that the potential number of parameters you can send to data in memory hit use memo doesn't do that it's doing is basically saying, hey, let's look array the same as the last time that I saw it? last value that you created. Otherwise, I'm gonna And then I'm gonna hold on to that, but it's only performance or memory hit when it comes to use So use callback is another kind of misunderstood should use it when they don't need to. Let's so we have this list of names, right, John, Paul, memo. So let's go and create a generic component We'll call it sorted list, you give it and then displays them. So first, let's grab this And so it's now the sorted list. And it will that has our sorted list joined. Cool. All this sort of names with a sorted list. And And it looks really good. And it's doing its sorting want to see how often this sort of list runs. So and just return that sword. And I'll put it in running the sword twice. But that's because we're React 18 thing. When you're in dev mode in strict So that's not a big deal. But let's go and click not getting run anymore. This component sorted list render. And now we can see that sorted list render, you can see that's 20, right, this is console ninja that's putting Really excellent extension So okay, so now let's go and say that we want want to be able to give this sort function a sort string sorting somehow slightly differently. So and we're going to send that and now we got to define that sword function. And we will say that we are going to take two and we'll pass that sort Nice and So this sorting still works. In fact, we one. And now we get the inverse, we get Ringo, because we don't have our sort function in our were to change, we were to give it a different let's go and add that to our list of dependencies. And now we can see that every single time we there? Well, what's happening there is that every click that button, because we set the state, the of the app component, that then reruns this And we create a store function. And And now the sword function is the we're not changing the implementation. But we are a new function every time that we go through this. Is there some magic in React that will make it Nope, still gets called every single time. So like this. And having it called out like that? sort function, so that when we get down here the search function is the same every single to pull this out of the function entirely. Up Give it a try. Alright, so that works, we're rendering and running that sort. But I'm not component like that. I don't think that's all that right in the component. So how do we do So you can wrap this function and use callback. And then what's the dependency right? is empty. Because we're not actually using any total or names or count or any of that this we just want to make sure that that reference use an empty dependency array there. That way we Try it again. Hit a bunch counts. And there our source function. And we will only ever call or the search function changes. But we're So that's why use callbacks important. So when use callback if the callback you're creating going on to a nested component has a property. as a property to the sorted list. And you Maybe it depends on that sword function. And if to go and update. So make sure that you stabilize you're just using a simple HTML element like something like onchange. It's overkill. The other are creating a custom hook, which we'll get to in a custom hook, you want to make sure that you use what the component that's going to use that hook make sure that the reference to that callback is thing we're gonna take a look at is everybody's use effect. Everyone's favorite hook. It's not of foot gun potential. In fact, it's the hook when it comes to infinite loops. inside of React and how to avoid those pesky infinite loops. So we it's checked into the GitHub repo in the source is our starting point. So it's just a standard VT some extra stuff in here in the public directory, then we have corresponding JSON files for each But one of the things that we use use effect do that. Let's actually use a combination of So first, we have to define our We'll start off with an empty array. Let's take a look. And now I currently have array over here. So let's go populate that be to do fetch right here. Let's go and get our And then we set the names. He's easy, there they are. Ah, oh, wait, hold on. we blew up. So here's what's happening. So a then starts a fetch, then that goes off and our names in it. Eventually, this fetch responds, the JSON out of it. That again, asynchronously then set the names, which starts the whole process from before, it sets the names a state, and it which in turn, runs app, which in turn now goes cool. Good for that. But then we start another So how do we get around this? Well, we use use hey, only go do this thing once. So what that is going to call once the Dom has rendered effect, but not going to call it right away, it wants to when the dependency array changes. for a dependency array, we'll just use an empty we're not reading anything inside of this in the dependency right? So let's save that it works. And it's rock solid, stable. How cool names dot JSON twice. So let's talk a little bit really a huge problem. So what's happening is with dev mode, with strict mode enabled, it mounts in the case of a use effects should call but we haven't defined one here, and then calls that use effect again. So we get called and wasn't very, we're very happy about it. But you can actually disable that by removing main dot JSX. Again, this only happens in dev I do got tweaked about it. So It refresh and now we only get named JSON, the not an infinite loop. This is a saw to use build on this by taking names and turning into a we'll go and load the corresponding data. And with our use effect and do it safely. So we'll We'll turn these into buttons. So now when we is our new selected name. So we need some state And we'll start off at null. And we're going to set that selected name And just to check if this works, Jack Joel Jain perfect, works great. Okay, so now when this selected name changes. So let's go and And then we fetch whatever name that And then we'll give it the selected name dot JSON. data. So we need a data for that selected person here, instead of set names with the response back And we'll just take that data cool. I'll take a look. So in the div down here, and we and react doesn't like when we just render put in our selected name details and see we get because we start off with our selected name Jill, we set the selected name to Jill, that then name, which is now Jill, is different from what with Nolan it now we have an array with Jill But here's an interesting little side note, heck's up with that? Well, what happened there is And then we came down here and react We don't know what was in that dependency right So whenever you're gonna have in here is gonna array with no one it. And so it ran you that which is not what we want. So all we need to this in a an F, and say, Well, hey, only go get So there we go. But now that this is actually the wrong way to do it. Because we're doing this onclick we have our data right right in the callback. So instead of having what we should do instead is create a And this is going to be a name. And Now we can get rid of all this use effects stuff. And over here, we will just call that And let's see how it works. Perfect, and very And this is something I see a lot where folks when in reality, they're just responding to and do the action. Right at that point. It's the do in this case. So you really want to as cool to justify things where you need it, like, so let's talk about when use effect gets a little on data that it also writes. So to experiment And what this stopwatch is going to do is So it starts off at zero and it just a div that has time with a timer on it. So far, so good. So let's There we go. Time is zero. Cool. So what do we a set interval. So now we know that we're going the time to the time plus one, and then do 1000, you're going to run into an infinite loop. Because that setting at the time is going to force which is going to get the new time, Yay, it's set enroll, which is going to create lots and lots to do that. Well, we want to go and create one And we know from before that we want to because we only want this So let's try this out and see And now we go from zero and we got a one. We stick log, and see what's up. So we'll do console dot time, because that should be going up and up and zero to one. But if we look back at our code, we console ninja, we're just getting a time at zero Well, what's happening is that we first initial component render, and at that time, was we created a closure here, and we captured time is forever going to be locked at zero. So time in there as a dependency so that when time for time. But that's going to run into the same and create interval after interval after interval secondary way to call a setter on use day. One way is you give it a function, and that function return whatever the new value is. So in this case, And now we have a working timer. And if we we would see that this number for time, the actual I can make this a little bit easier to like T to distinguish it from time, because time the current value for time. And there's one more the function that you give us effect can return we had called whenever the all these effects and the new use effect is coming in. So in this going to want to clear that interval that we've and then I'm going to return a cleanup function. a solid timer interval. I asked actually this if you were to give me this code, probably mine grade on your interview. So of course, there's but use the fact that is really important as want to use React Native state management as the use effect is the kind of thing that you're going sure that you are very comfortable with it, yes, with use effect. But in all honesty, it is an the fundamentals of JavaScript and how they work so just spend a lot of quality time with it. I mentioned early on that there was this other ref. So we'll take a look at that next. Okay, more way to associate state with a component though, is that when you change the value of a rerender. So that can be convenient in some cases. ref. So let me show you the first way, the most management side of it. After that. This is the applications. We're looking over there. So I'm gonna use it for is, I think, the most common HTML element. So in this case, we'll create an So we have this text element. And now we want to So I'm going to create a ref, a reference to that off with the initial value of No. And then I will Now let's see if this works. Okay, it looks But what we want is we want that input to be little blinking cursor in there when it starts know that the reference is defined as something and then we will have gotten a reference to that use a use effect, because use effect runs after And we want this to only happen once. So what And then within that dependency array, we just when you have a reference, you have a current just do input ref dot focus. Because input ref is the thing that you can set or read from. So that the page refreshes, we automatically nice. That is the way you get access to elements But there's another use, and that is to maintain an example here. So we're going to have a list fields to go and add a new name to our list of our use date with our empty array of names Cool. So now we need a button add this name that we just typed into And we'll assign that to the onClick. Now remember we're not using a use callback here because to this HTML element is not its own React to happen with that unclick it's not going problems like we would have with passing that on I don't know what was that on Add name. Now to the current names plus, the value of this already have a link to this input. Or we can just get the value from that component. This is called the most efficient way to manage an input. And then one last thing we can do is we can just give this a try. Oh, looks like it's blown up. We didn't bring in new state. Make sense? Cool. And there we go. All right. So Jack, and world? Well, let's say instead of having just the and Id two is Jane. So you have an ID and a name. go make names. Sing that tune. So this is going to fine. Okay, looks good. So now there we go. blow up because add name, I'm just adding the what we really need to do is have an ID with There we go. So we want to track this ID, and we So that's where something like use ref is going use use date for that ID because we don't really value. So we can just manage the ID using a ref. then starting it at one. And now down here. We can it like a value i current Boss Boss. Let's take here. Current Boss, boss. Awesome. And just to All right, so there we go. Yeah, one is John. Two one and the two. And then we have Jack, let's So you can set this value current without forcing course, we matter. In this case, since in all in turn actually still rerender the component but in a use ref like this. And it's just good to we're gonna start finishing up our look at Native and also creating your own custom state management culminate in us building our own pokimane search up React Native state management, before we get and and state managers like Redux and Joe we need to talk about context. And we also need the ways to kind of package and redistribute We also need to talk about TypeScript. So you TypeScript up until well, now. And the reason state management and learning about the reactive declaring, say, using new state and use reducer. use memo and use effect. But now it's time to probably going to want to use TypeScript when including React Native state management. TypeScript. So now the native context app that thing we've been looking at so far. Except that I So it's the TypeScript version. And I've also list of Pokemon in it, including what was or which has all these stats. And we'll be using this how to actually put all of what we learned into custom hooks. So let's go and build ourselves So what are the things we're no we're gonna need, to hold it. So let's bring in use state. And we use. And so I guess I'll just say use Pokeyman as implemented as functions. So let's create our needs to take any arguments, we just have used that it will then return. So now we have our actually, let's be nice, let's initialize it do in our use Pokemon hook is to use an effect So use a fact takes a function, we only want to load the Pokeyman once, so empty dependency array. So now let's do our which will then convert the response on and with that data. But of course, we don't And now just give it the data. So now we have which is that that type of Pokemon a never array. So what does TypeScript can't infer what this array is never can have an empty array, it has to be empty can guarantee about. So we need to define what a is going to be an array of that. So how do we do So we look over here, Pokemon JSON and got ID that corresponds to this interface, ID name, type, parameters for that book came out. And now with this is going to be a pokey Monterrey. And the and then we put in a Pokemon array. And now if we are getting back a pokimane array. But if the type of the Pokemon from Polygon JSON. I because we get Pokemon JSON at runtime. So it has we tell it what the structure of that is. So this Honestly, it doesn't get a whole lot more complex user fact, there is no typing on this use Pokeyman by just saying we're going to have a list of of Pokemon or no, but honestly, par is going to you really don't have to use TypeScript a lot so let's see what we're getting back. Let's do and the easiest way to do this and just find out and we get a whole bunch of data. Nice. Let's say that we want to go and make So it's gonna take Pokeyman as a prop, and that And you know what, let's do it a little bit div. We'll map through our Pokeyman let's try this out. So we're going to do There we go, a nice list of boogeyman a long prop drill everything, because here we're doing and we are sending it down as props. Maybe this of React components. And we don't want to have way down. And maybe we have a bunch of different want to have to shuffle that data all round is an it's context. That's what we need to do. We to anyone who wants to use it. And the way that need to create some context. So the first thing And you know what, I'm just going to start off very simple context, we'll just say like So we're going to create a theme context. Okay, so now how do we use this theme that consume the context with a context instantiate a theme context dot provider. So you get back a dot provider, and it's a React specified value by just specifying the prop for is the value the current value, it starts off this, let's just give it a try. Let's see if we can consume theme context. So we'll bring in the use context And in this case, we're just going context hook and pointing it at that theme And the theme is dark, nice. If I go light, our theme is light. And we can see that we We just have that theme context. And wherever we give it the context, and we get we don't want to do theming. Or maybe we do, what we want to do is use this pokemon data. down to the rest of the application through this And okay, so what are we gonna put in there as say that we have just a, an array of Pokemon, Pokemon here. And let's see, does that work? So generator, look at my context was given a value Looking pretty good. Now, we don't have put And now we can pick up Pokemon from the boogeyman And if I look at that, then the context But it's a little easier. This is beauty Pokeyman. And there we go. Well, we don't have a theme, was Nice. So now using context, we can see that we properly. But there's a few things that I don't So I want to make a hook that gets us access to unfortunately, use Pokeyman is kind of camping really good name for that hook. So what I'm we could do something like use Pokemon source this is going to be the source hook that has the define us Pokemon, by just returning And now down here, we can just use bogeyman. I like that. And now there's one more fix up, I mechanism, before we get into actually kind of hooks that we've seen. So the first thing we need So the way that we do that is And what are we going to have in our context, US Pokemon source function. So this is us poking that. And it's either gonna be that or undefined. Now, the problem is that the all of the cool stuff that we got from us as we use it, it's like, Ah, you could be But we know that it's always going to be valid, So one thing we could do is, we could just use an Hey, it's always gonna be not undefined. and I'm kind of torn on whether exactly this instead of allowing for undefined, so we just go object. And we can take that empty object Intel it is a return type from that use pokemons source. And then as the return type of use pokemons source TypeScript. You know, honestly, once you get this and you'll just be using it and it'll be fine. tough, you're only gonna have these a few I think we got a pretty good start. Here, we have a bunch of knowledge about these other hooks that gives us a searchable Pokemon index. That even Alright, we're starting off at exactly the directory and cloned it to native Pokemon. this is the native Pokemon app. And what we So the first thing I want to do is kind of messy. So I'm gonna go and take all of the and I'm gonna pull that out and put it in Pop that all down in there. Alright, so what do actually, we need to use boogeyman source. And we Cool. So now let's go back over And then import it from that store. Not too shabby. Let's hit save, try, refresh. Refreshing. I love it. But there's one thing I is having to maintain this connection between us And I think we can kind of hide that elegantly. By actually pretty easy. So let's go over here to called Pokeyman provider, which will take children where those children are a React node type. Now rid of the export of the Pokemon context, as Nobody else needs to know about the US. So let's And here we go. Nice. Again, let's try it out. Right. So the first thing we're going to do is tag. And tailwind, that means setting the max MX auto, kind of bring it in from the sides. Let's it's kind of in a little bit. So now we're gonna in order to bracket that, you have to have a UL we're gonna say that this is a grid. And let's And then we're gonna bring in a bunch of HTML, of course, all of this code available to it all in because there's a whole bunch of And let's take a look. Wow, that's pretty have a search box. So I'm going to create a for searching so let's go and create a And we will return input tag in there, give it whoa, that's good. Looking already. Nice. So we need to hold the search term. So let's go over because I think that's a good spot for it. Now, And in fact, actually, you don't even need But I do want to show how to type use let's see how we go. So we're And the initial type is going to be a Fair enough. Now we need to bring in user right. And that's going to take two things is to take an action. And we're gonna have that it's complaining about our lack of typing. let's first type state. And we'll So what is that? Well, that is going to be an enough, that's pretty easy. And then the action we're gonna have is like the set of the Pokemon And it's going to have a type where we say set Pokemon, and the payload need to start implementing on this, so I need So we're gonna return the existing And that's it. Yeah, pretty good. So that's how is going to be the data and the dispatch. So let's going to be that object. And from that parameter, And then we're going to grab that dispatch. Oh, okay, looking good so far, but now down here that set Pokeyman. So we need to And what is the type on that will set Pokeyman? And was this function, we're also going to return and have a look at us bogeyman and say, What are Pokemon, and that's our string. So let's go use we will grab our user schema and instead and set that as the value. So to see this all set the initial state So now we need to have a So let's uh, Add another And we'll call this one set search and give it a string as the payload. Now we need state that has the new search in it. Easy to actually dispatch that. And we're not we need a set search function. Now we need is going to take a search string So how do we define that? we can say that set search is a search with a payload of that search. But I didn't say something and custom hooks that you should always use use a function that you're returning. So let's And then down here with set search, And what do we use for the dependency array? Well, are no dependencies. There's nothing going on in and then search, which is given as a parameter. Okay, so let's go take a look over in our app. And we will do set search on that value, and So that probably works. I'm hoping we'll work on while we're here. And we'll go back up to our set of Pokemon. So we have our we need to calculate the array So when we think about using a calculated go bring in our friend use memo. And so we'll using them ml and will return a filter where that search. So what is the dependency Let's have a think about that for a second. we're reading from Pokeyman. So that's clearly from the search, because we're including what do we do with filter bogyman? Well, we can do isn't the original whole list of Boogeyman. filter Boogeyman. So now let's try and filter this How cool is that? See, that's the You're creating this connection between and that search term. And then when either of and then we get an updated filter Pokemon. So it actually is a very elegant system. Okay, so gets a little crazy, and we've got to eat 800 of Now make a little bit more efficient. make this case insensitive. So the way we do that Cool, and now if I go over here, and I it finds all sorts of case insensitive. That's do is I want to sort the Pokeball on the use for use memo. So let's go and create So we're gonna take that filter bogeyman and we'll And then locale and compare that to be dot name. thing we're reading from here is filter Pokeyman. started to bug him on. Put that in there for alpha let's see. VOB are you Oh, yeah. Okay, there you cool. We've learned all about reacts native state particular example, I certainly recommend if work through this example, get comfortable with use callback, use memo use effect, that is the 2022. Everything else kind of fits on top of that. like React, query, react form, or react with these hooks. If you're using something you're going to use a combination of that, and important to get a foundation set where you and in particular, obviously, use the fact that get into indirect state management by taking a So now that we understand the foundation of take a look at third party libraries and see we're going to take a look at two, we're gonna Let's go take a look over their websites. in our 10 stack query site. Now, react hinterlands Lee's hand stack, it's really cool. allow you to easily query data from a server can be used actually, to manage any promise. So one called SW R from versal. That's also really SBRs, 4k, so you can decide for yourself which React location is a 10 stack version of React going to turn our single page app into a multi make it a little easier on ourselves to query the at the inspector and look at the network. And getting pokeymon dot JSON twice. And this freaks of being in development mode was strict mode on in Maine, we can see that react strict mode is on. automatically when it first gets your component rebounds it and the idea is to help you look for effects that you don't close out properly. But which we use down here. If they have people believe that the empty dependency race as And what happens is use effect gets run twice actually, the contract is true use effect with on a mount. But it just happens that react on actually mounts you twice. So yeah, it's fine. Let's go and replace basically So how are we going to do that we're going to Get started. Let's see we need to install. So and then I'll bring up the site again. So now what we need to do is we need to on the as a query client Now that query client is to help us with this double problem. Because when JSON for us the first time, it's gonna it's gonna say, Hey, I've already got this that. And it's going to handle that for us. we got to bring in the Create Client provider, as And then we'll create our query client. query client provider. This is again, like This is just a context based provider that is give this a try. See if it works. Hit refresh, and over to our stored at TSX. And see how we can use from pans dat. And now down here, we're gonna as well as the Pokemon, because we're not going going to use canned stack for that. So we're gonna And initializing it cool, awesome. And we don't need to set Pokemon. Alright, looks good. So now, we can use use query. use query. So let's bring in use query. And it query identifier. So put an array which says So that uniquely identifies this particular give it a fetcher. So we're going to give it fetch JSON from that request. So we have to provide it for us, which is kind of interesting thing. But it doesn't really care what promises you throw at which is the query, that isn't the title of the is give it what the initial data is. So when actually want to put in there in the meantime, Okay, that's cool. So let's go and an object from it. That object contains But this is actually typed as any currently. And now we have an array of Pokemon. Let's give easy. Literally, how cool was that. So we don't holds that data, we don't have to have use the React query, and then let it manage the data. And is react queries primary job is to manage that the data from that promise, which it retains, and So let's go see if it's actually solved our double now we're only getting that Pokeyman JSON, just Alright, so now it's time to turn our awesome application. And in doing this, we're going to see because what I want to do here is I want to be Beedrill or blast noise or whatever it is. And And that ID is going to be part of data model for the application. So let's So go over an installation, and we see that stop server, paste that line in, start the server to bring in a few things from our React location. going to use to do the client side links or any where the content of the route is supposed to So we're going to create one of those like that, that wraps the application gives us that context. way we can get the parameter from the route. So list of routes. Now routes are listed as an array. want to render. When you go to that particular around this are as loaders, everything else, a much more robust system than what I'm showing the basics. So in this case, our current route our search box and our Pokemon list. So what our div in that router, give it that location, And we'll finish off the router. And now we can the outlet. So whatever the route is, that content of put it all together. If you had like a header, below it, all that kind of stuff. All right, you go. So we can try this out, see if that's Refresh, cool. We are on the main route. That's kind of cool. All right. Okay, And now we want our detail route. So Here. And where we want to put Like Pokemon. And then ID and the colon ID means assigned to a parameter called ID. And there's But that's pretty standard way to define routes. All right, and then the last thing you need to clickable can they currently not? So let's Give it the key, say that we're Get rid of this key and then finish off the link. And there we go. So let's see. Okay, hey, now And we have our detail page again in French, but ID from this? Well, we use that use match to get So we bring in use match, we get the ID, And then within that, we need to find the Pokemon And then we do that parts of the end, I'm I like that a little bit better. And we can just say, you know, Because we already have the data. But if And let's see, we get click on Beedrill. And do is just format it. So I'm gonna actually bring something that you can play with and have some fun this code, and we'll walk through it. So at the give us a little margin, then we're gonna have a we have a way to get back, then we're gonna have of the Pokemon, and then over in the other one change that out. Alright, and then we'll have the stats, so hitpoints, attack events, special that, we create a two column grid where we have So here's a little fun little piece of TypeScript and so forth. and Pokemon data is a type object. from that type. But we can basically tell it that going to be a key of the type of Pokemon data. which has a Pokemon. And then we're gonna get type, our HP attack, and so on and so forth. TypeScript right there. Nice, a cool looking Alright, so really, what are we talking as an indirect state manager, that in this case, ID of our Pokemon was is essential data to conjunction with all of the work that we've run that detail page and show the Pokemon that the our native state management that we've already libraries like React Router, in addition to management, I might recommend that you might look final form, because all of those will manage the lots of different fields with lots of different state of the actual form fields themselves, you And I use rakshak form and swear by it. So go this associated with this video that's linked a direct Pokemon starter folder. And this direct experiment with these different state managers. that we have for this particular application, and all of it is basically sort of unimplemented And the first direct state manager that we are it's very popular, and is a unidirectional Data Pokemon starter and create one called direct Alright, so I'm gonna go and copy recursively switched on and then bring it up in VS code. All right, now the first thing I And I just gotta I gotta show you the homepage homepage, it shows you a little bit about how to a bear. It's cool. I just love this page. So well, on the page. And we can see from it how we create give us back our own custom hook that's going setter to set it from a method. So let's try it in the store. And we'll bring in that create. So what do we want in our Pokemon we probably want a list of all the Pokemon in filtered and sorted version of it, we want a full We'll have a way to set the Pokemon. the Pokemon. And then we also need and a way to set that search. Okay, now let's which is just empty, the whole pokimane array is to take a Pokemon array and then And we'll set search to an empty string, So I'm also going to go and set pokimane filter and right away but I do want All right, so let's go over to our app and And then up here, we're going to get Now this is one way to do it. Another way to here's here's how select It works. So let's say we Pokeyman. And that will get given a function which the search. And I think that's actually the best to do is say, Hey, I only want this part of the I actually want to get updated. And that's a we have large stores that are being looked the components update on different things. They best practice to really start off by using And now we can implement on this. And this is going to call set search. With the And Cool. All right, and then down here and And we will run. Okay, nice. Let's give it a try. So, nothing, so why nothing? Well, we haven't but at least it's not blowing up. So that's a fetch the data, your mind our JSON and then get the JSON from that. And then we're hook. Seems weird, right, but it actually works. the hook. So use Pokemon. And then we got to get Pokemon, and we can use that to set that Pokemon. is showing us is that you have this externalized But you can talk to it outside of a React we look for in direct state managers, direct state test, or by code that's external to the React And that's a sign of a good direct state manager. Okay, so I think we're doing good. The only anything. So we click that and nothing. So let's a filter and sort function that takes a list of us back the list of Pokemon matches that search bogeyman, it'll take a list of the Pokemon, it will filter through that. But also, we only want to get the And there we go. Okay, cool. So Let's go down here to our set all call that set in search, we have Pokemon, but coming from? Well, our search, we gotta go get parameter, and then we'll call get, and So we're gonna do the same So we're going to set Pokeyman to be the we don't have the pokemon so we need to And let's here we go. Perfect. see why people really love swift on it is custom hook that manages data for you externally But it also integrates really well with your React things like use memo or use state or user research manage the global data, and then any local data So I've talked a little bit about how Tucson like Redux. So what is a unidirectional state in a unidirectional Data Manager only goes in one dispatch a action or call a method on the store subscribed to the store, you then get updated, and gonna look at is Val sheEO. And Val sheEO, is an actually just directly set a value and get updated bidirectional connection to the state manager. If just a little bit smaller. Okay, let's go try out into a new directory called direct Pokemon Val over and check out Val sheEO. And see what it's And it shows you that basically, we're creating we use a proxy to create that. And then inside of that proxy. So in the case of, for example, so that would include count zero. And then when the value, and automatically, this component will to count over here, it's just a really nice way our store based on our proxies and snapshots. And we'll create a couple proxies, we'll create the query string is an empty string. And then we So far, so good. And now we know we need And then get the JSON back from that. And to set that value. That's all we need to do, we And let's see, so Okay, cool. Let's go Alright, so to use our proxies, we need to from value, and that will bring in our proxies So we're going to get a snapshot of the value. And then on the change, we'll just set target value. So use snapshot is really what's connecting that proxy with React, so that when fires set some state that state has given back that's how Bauccio fits into the React rendering the value of the proxy directly. So there's a want to just call like search that query because Okay, so now here with Pokemon list, let's And now down here, we can just take the Pokemon We are, of course, we got crazy we've got all the boogeyman in So how do we fix that? Well, we fix that by derive and derive allows us to derive data from the utils. And then derive allows us to And you give it an object. And then with an Now let's do the function that takes and get other proxies. So we get the search, get we get all the Pokemon and then filter it based get rid of exporting all boogeyman and go back J that boogeyman and let's see Cool. Hit refresh. Bu lb. Oh, okay. Let's Cool. And I think we also slice and Take the first 10 and then sword. Perfect. Love it. And now we only have a 10. that is a very, very simple state management And then over here, we just do the same thing with was that, and then use that snapshot to go then this derive. I love this. So this ability some data from it dynamically, that is just that search changes or on clicking on changes, that. The another great thing that I love about another model of state management that I'm really And there's three state managers out there management, there was the original library recoil dicey carto that she caught Oh, just happen to to subscribe to somebody on Twitter, and learn he's also written a great book recently on state And also there is nano stores. So and Anna sores are excellent places to look I'm going to choose to use Joe tie, All right, so let's take a look at the Joe tie in the list of directories that is in the GitHub Pokeyman Joe tie. And this is where this code starter, and we'll just go through it one by And this is we're going to start building out let's go over to our Joe type page and see how define a piece of state and use atom, which is how you have a text atom that you've created by using that depends on that atom. So shut when text atom to do to uppercase. So again, you're creating Excel spreadsheet, or a Google Sheet, right, and then uppercase atom would be another But uppercase is it. And that's one of management system is you create this web of And then to interact with it you use use atom, And then you get back basically a value and I it's very, very simple. So the first thing we And let's declare our search, Adam. Fair enough, easy. But how do we get the list little bit cooler. And I'm going to do it a little So we're going to use this Adams with query. And it's basically react query, now connected to a and then start the server up again. And then need to create an all Pokemon atom that uses query that we are getting back a, an array of query key just like we did with us query before, in this case, Pokemon. And you give it a function, giving it that exact same fetch function to go And so let's try this out. So we got our search, get started. So let's go over here, app dot TSX. tie. And also bringing us Adam value us Adam So we'll use Adam the original, which is just because we're going to want to set and all Pokemon because all we want to do is just from that store, and then for said the value. And then here Good enough. Now with the added on the all Pokeyman atom, and we just display and Bob's your uncle. Nice, but it was that looks at both the all Pokemon atom and the updates itself. So let's go and create a boogeyman So in this case, we give it a function, we can get the current value of the search item of all Pokemon by getting the all Pokemon and we And then we'll use to lowercase in there. And now we've got our Pokemon Adam. So let's need that and go over to our app and bring Let's get out of the way. And then down Hit save. Hit refresh. Be you lb You know, I do like this cascade model. And slice and we want to sort. So let's create another So it takes the existing pokimane based on the name, and oh, we also got a slice it. Cool. And now we got to sort of put them on Bring that in instead. And depend on blast away started out. Okay, you will be cool. How cool was that. So now we can see that we have search atom, which is basically a simple piece of is in a synchronous atom that is based on 10 stack set itself. And that automatically integrates any dependent atoms get updated, which includes the search atom and also the all pokimane atom version of that data. So this is how you derive in And then we have another atom that listens to things update, like the search updates, you get really like about it is is that cascade and it is of that, because we only we kind of have that date, and use reducer, which are effectively atom. way of deriving another atom from the original of React, we have to mend the dependency raise, getting the atom, we're automatically subscribing work. And you don't have to worry about the fact not have all of the stuff in it that you actually The next and last direct statement we're So I realize getting to Redux at pretty much whole marathon and saying, Hey, here's Everest, Redux is a huge state management ecosystem. state manager, it's been around since the days of before that, and I gotta say, it can be a little use the Redux toolkit to simplify it a little bit. of Redux, that reduces a lot of the boilerplate, there's a lot of boilerplate. It also has a React pretty cool. So we will use that to go and get And I've created our app. Our app is in the direct the direct Pokeyman starter as we deal with all code. We're gonna add Redux, which is the base the couplers, basically, between react and Redux, as I said, Is this simplifying stuff, simplifying stores and slices. So we'll get into that what And then bring it up, and we got our search box. And so what are we gonna do, we're gonna create a slices in it. So now, when react first started, would have all of your data in it. And folks got because of having one big store with all the are running over each other. And so it's nice as that you can manage it better. So let's bring would be create slice, so we're going to create going to be the search me the text string of the going to create a slice that slice name, as you state of this slice is just gonna be a search with our reducers. So we talked about reducers, when it each one of which is effectively a reducer. In a state and an action. And the little difference is that in traditional Redux, you would return but the rest of the were the same, but you return whereas in this case, Redux toolkit is making it a values in the state, and then it does the merging actually fairly common. And this is actually I know, I'm not a huge Redux person, honestly, but So this search slice has gotten us a lot of stuff. and a reducer and name. So we're going to search coming out of actions. And now we're going So we're going to use the Configure a store that we're going to export. reducer from the search. So that is how we Now, if you do store dot get state, which you to Redux, you can do it inside the React tree, get the state. So that would include search dot that the search value. And so the root state state what it just looked at. So if we do Command state as he searched slice, and within that the a selector. So talking about selectors in the in take a store and get out just the data that you create selectors for everything that we need. So and that's gonna give us back the selector, the Okay, so let's go over to our app dot TSX So to do that, we bring in a couple things from are the hooks that connect Redux to react. we need to bring in a use selector. That's a data based on that selector. Use dispatch just store that you call to dispatch actions just like dispatch use dispatch exactly the same way with oh, Redux Redux became use reducers. I mean, some of these concepts are very And then the provider and the provider and then it provides that store down to from the local store. And then let's provide that. I mean, I love how Redux is so, so old, and is literally named provider. It's amazing. they have, you know, Redux, or whatever, query provider, whatever have you. This one is rename it if you want. But that's what comes so we got our store. And now we want to go value. So we need to bring in that selector And give it that Select Search. And then we use dispatch and get our dispatcher. And that just in. Okay, so this becomes the value of search and a set search with the event target value. So we actually, let's go and set this to a value for so like it's working. That's great. So we've got So now the next thing we want to do is want to in the query part of reax toolkit. So we're going query functions from the toolkit query. So that's query. So again, with redox, like everything is React. Okay, so we want to go and do is we want So we do is we invoke that create API, we give it base query. So anytime I say that everything to be off of slash. And it's only going to have And that is going to call query with you my JSON. there. Let's get rid of Yeah, that looks a little what's in pokimane API. So inside pokimane API, Pokemon. And within that we have our use query, use query for us. So let's go and actually And we'll just export that. Take a And now we can use it. And we'll give it no parameters And the output here is either a, an array that if we have data than once use it. And if we not working. Oh, I remember what it was. Okay, pokimane API needed, we'll go bring Okay, let's take a look. Oh, where it is? Yes, now we have, you know, bulb or whatever. Cool. So Well, if you look at the docs, the docs tell you one way to do it would just be to integrate this to data, and then derive data from that. And good old use memo. So we can use parts of our them with what we have from Redux, let's So we want to filter and we want to sort the the search right? In that, so we want to And it's going to rely on the data as well as the The data or an empty array, if it exists, because by that name, of course, we want to And then we want to slice it. And then we want to sort it. Nice. Okay, so or empty array, so we don't have to go check for So it's giving us 10. That's Perfect. Okay, so that is one way to do it. requests for hooking on JSON externally to the that listens for when that data is done, and the search and do the same thing, but do it over selector that's doing that kind of work for us. And then we will create a selector. And the first functions that select out parts and pieces, and the first part gives us our Pokemon. So we're get Pokemon select undefined. That's the parameter coming in through deep state and we get the data. and drop it in here. So we're and filter it on that search value. So this All right, cool. So select Pokeyman I like it. So instead of using that use memo, we are instead slight bogeyman selector Okay, and pokimane Okay, let's give it a try. So nothing to why that we did, he used to do this use playground query. So now we have to initiate the query over is pretty much anywhere, you can do store dot can talk to Redux, both in the React context, And then we want to call that pokimane where we initiate it with at undefined. All right, is externally to react, we are initiating the when the store updates, because that get Pokemon that store changing then updates any subscribers, in this case, the selector is looking at the and then using the to, to select out a mutated it and sliced it and sorted. So you can use you can actually mutate the data in the store. to do that in this model. Okay, so one more tools. So if I go here, over here, we are setting the surge, and you can see all I have the Redux Dev Tools installed in my Chrome registered those things together. So that's, the, the pending query, you can see the fulfilled and you can also do this cool, like, time travel Yeah. Nice. Okay, so there you have it. So Redux. GitHub in the link in the description below. And Pokeyman, Redux directory. Now, before we get to more technical thing, check this out. So times biggest changes has been a recent RFC or request for promises to react. And the way that you do versus the server side code. So on the client new hook called use that you give it a promise. you get the data from that promise, or I So let's try this out. Because I think it's worth it is in the experimental build of React, as well There might be some changes between now and when knowing, because it will fundamentally change how adds a lot of new functionality, but also could So I'll let you be the judge. So let's go over to And we'll call this one I'm just going to use just basic Bring it up with VS code. And now let's go over this new experimental build, I need to change and then do my yarn and my yarn Dev. And so we now have our app. Cool. All So I'm gonna go create a new file in public and what we want to do is want to go over here to our app dot j SX, and let's So how would we do this before? Well, we do this use effect. And we'd use the use effect to get the we've seen, but now we can do something really And what do you say data dot JSON. And So now we have this promise just kind of floating And then we can just get our And let's Stringify that and see how it goes. How cool is that? That's really neat. That watch this. So I mean, come on, right? Why I mean, it'd be a lot easier to get rid of that. But lots of stuffs happening in our dev tools, So why is that? Well, what's happening here? happening here is that we run app app then first And we use that promise, we get the data back And we put that out. And then finally, this fetch up on that, because added to then to it, and it renders app. And you and then we create another I know, I know, that's frustrating, because it's thing. But it's a new reference to a new promise exactly exactly the same thing. It is a different promise. Cool. All right, I'll go wait for that data to JSON resolves gets us some data. And it's react can actually get enough spare time to put even get anything on the screen, in this case. And top level here, because that means there only Now we can go back over to our localhost. that's us now on the server side of the house, we take a look over here at the first class await in Server components. The idea that is server side rendering only, in data, right in the function, you can create this is huge. This is something that we never And react will wait for this function to resolve And once it's done, then the server will render And I think there's a lot of potential here. It will change state management and react. For the next Jas 13 becomes more prominent, but it is very in summary, let me give you some advice on how when it comes to state management in React. You should endeavor to use native state use memo use callback. At the point where you about using a third party library, something libraries are going to probably do a better potentially do building it on your own. Those they've got mutations is fantastic stuff, and I think a combination of native state management, if you're in the next Jas world might be enough And then if you have additional needs, in you've got different parts of the React tree, and then you can either look at doing context, I think that's a good opportunity to move state like a Jewish dawn or Joe tie or Bauccio or Redux, options in that space. But I think I've shown you If you have any questions or comments after all down below. And if you liked the video, hit that head on over to my channel and subscribe to but I do good videos, and they come out every Certainly if you're a React dev it's worth