Big O notation is used to classify algorithms very important to understand for many types of breaking down big O notation in this course. Hey, on big O notation. And this mini series, you'll O notation and how you can use it to improve I'll use whiteboard illustrations to help you coding tutorials that you can follow along with will answer the question what is big O notation? Big O notation is used to analyze the efficiency which means that as the size of the input to the time requirements grow with it. For example, 30 minutes to treat one patient. As her line of to treat all of the patients will scale linearly This is because it always takes her a constant which is 30 minutes. This gives us a general take to treat 10 patients 20 patients or even know that the dentist takes a constant amount of we can always calculate the time it would take for the number of patients times 30 minutes. With this linear. Or as we would say in Big O terms big O the time that it takes for her to finish her number of patients, we use the same technique we can get a general idea of how functions functions efficiency the same way that Let's create an easily comprehensible So this function is in the same linear category out why. To start the input to our function For each of those items, we will log this Now don't let these large numbers for you, it will 1000 times 100,000. Therefore this line of code important point, when considering the efficiency do not matter. Well, at least for our purposes, some crazy length, like 200 million, changing this would have a negligible effect on the efficiency iterate through 200 million items in an array. we would still ignore all of these constants is big O of n. Similarly, if we think back to minutes per patient. But even if she took three her to see all of her patients will still scale but it starts to make sense over time. So in the the constants. But what exactly is a constant? A input to the function. For example, the time to input because both 101,000 are constants. That is, always results in the same value. And it always to return the same result. Just like we use big O big O name for constant algorithms, which is every line of code is actually a function in and let's reintroduce this function. So this line function is O of n because as you can see as the the for loop must traverse increases as well. But Let's for one second pretend that we have a can see, with this function, we pass in an array, The only operation within the function is constant regardless of how large of an array is passed to result. And this is the only line in the function. But wait. In this function, we have multiple the line that is O of n and ignore the O of us to our last important note, in bego, we have a Now, don't panic, you don't need to understand all the ones relevant to this video, or even an old videos for this series. This chart shows the That is to say that this first case of one is the big O notation, when determining the efficiency of So that means that the worst case where the that have better performance. So if we add the all of the lines of code that are o of the worst performing or highest order part of is why we ignore constants, because we're actually as a functions, input moves towards infinity, So to recap, when evaluating an algorithms the efficiency of each step within the algorithm, that has the worst performance, and prioritize steps that are constant, or that are over one So we always ignore them, unless the or o of one. And in that case, we would or o of one. And that Ladies and gentlemen, Okay, so to understand O of n square, we're going in the function will look something like this. So in a number in and it's going to iterate through all the way up until the number in and we're also going to loop through this is doing the exact same thing that this for loop starting with zero up until the number in and the coordinates for a sell within a matrix. But console log of the index i and j, I'm just going for every iteration of this nested for loop. So I promise it'll become clear. Okay, so let's say the number four. So that means that we're going starting from zero, and then we're going to less than four, once I becomes equal to four, only for this top for the for each iteration of through the entirety of this nested for loop and coordinates, like I said, we'll draw a square visualize this better. So let's go ahead and get equal zero, and then we move on into this nested the entirety of this nested for loop. So right So we're currently at the first iteration of this and we'll draw a square and then we move up one we'll draw another square. And then j becomes two, three, and we'll draw another square and now j is longer less than n, because n is four, and j is so will no longer iterate through this for loop. I is equal to one, so i is equal to one, and then i is equal to one is in j is equal to one one and j is equal to two. So draw a square and draw a square. And now back to this top for loop up to this top for loop again, now i is equal to so we'll draw a square and then i is equal to and i is equal to two, and j is equal to two. and j is equal to three, so we'll draw a square so will no longer iterate through this nested for loop, now, i is equal to three, i is equal to so we'll draw square is equal to three and j is two, j is equal to three. And then j is equal to for loop. And at this point, our i is now equal to iterate through this top for loop as long as r is now we stop iterating through this top four loop. the reason why I said that these are coordinates is a matrix. And these are rows. And these are columns. So we can look And then we can look at j is being row. So for iteration for row 0123. So coordinates being zero, and then zero and one are the coordinates for this this square, and so on, and so forth. So what does just one quick interruption. If you are finding type of understanding, please take the time this is a square matrix, that is each side will This is of length four, and 1234. And this is of we just need to multiply the because every side of a square is of the we would multiply the width times the height, but the width and the height will be the same we're just going to multiply four times four, four times four. And that's going within this matrix, which also happens to be the which is four times four is 16. And four So O of n square, our n is actually four. And that is why typically functions with nested within it like this function is considered Okay, so to understand all of in queue, let's take takes in an argument in which is a number. And for every iteration of this for loop is going to for every iteration of this for loop, we will need And I'm going to have to apologize ahead of But to illustrate this, I'm actually going which is not something that I'm entirely good image. For now. Let's focus on this function. iterating up until in. So to our cube function, we'll end up here to iterate starting from zero all the way up until first iteration of this top level for loop, I is adding in additional nested for loop. So there's rows, columns. And we also have this third So we have the columns that go in this direction, that go in this direction. So at this point, it's no longer a two dimensional array. And it's seems, we're going to draw it out now. So we going to start off as zero, right. And we'll say our columns. So we can actually go ahead and write we'll say that when I zero, this column is zero. When I say two, we're talking about this column, And of course, once I becomes four, we're loop because I is then no longer less than And we can say the same thing for the rows. row one would be here, row two would be here, if this is difficult for you to see, it's three but I hope that you guys can visualize what for the height, the height would be represented by I'm sorry, I should, I should actually just name function. So instead of calling this height, this this for loop is represented as representing And instead of calling this columns, we'll we'll call it J. So for every iteration of this axis. So if we were to write in what the index see right now. But it will be 012. And So let's do this step by step understanding what's happening. So for this first be equal to zero. So that means that I, this line, And then for this nested for loop, J is also going to be at zero here. So we're still going to be This x is here, we're also going to be at zero, So instead of console logging these coordinates, So this coordinate is 00, and zero, and 00, And again, you're going to have to excuse my poor square drawing prowess. And since we continue with continue to iterate through this for loop. So to write I right now is equal to zero, J right now but we just do the square for K at zero. So now K So K is now going to be equal to one. So when k i j. k is at one, then we're going to go up hard to see because I'm literally trying to and I'm just like terrible at drawing, Okay, so once we do that k increments one, i and j are still zero, so we're still going to section. So we'll draw another two dimensional me, if I call a cube square, that's definitely course, K is going to increment again. So then K we'll drill another square, I mean, cube, sorry. And then it's going to be equal to four. And because n is also four. So now k is equal move up to this for loop. And this for loop will because for each iteration of this for loop, we gone through the entirety of this for loop. So And we can't move back up to this for loop until loop. So we're still on so we're only incrementing K. So now that j is equal to one is still zero, so is the column and then I still zero, this is I and from zero to one. So now we're here. So we're back So at I being zero, J being one okay, this is K, and this is zero. Sorry, once again, I said square Yeah, we'll And then k increments, and we draw another cube. And then k increments. once k reaches four, so yeah, K, okay, we'll And now K is no longer less than in. So we go back So this one will now become two. And it's pretty throughout the entire function, and it's drawing here. But eventually, we'll is filled in, which will look something like this. So we'll get to a point where the entirety of this which are just the iterations of these and thank you cube is completely filled in. At through the entirety of this top level for loop. this out on your own. But I basically went through this video, but it's pretty much the same thing all these four loops have completed, you'll And since this is a cube, that means that are all going to be of the same length. And because if you look here we We went through iterations of AI of K. And again, I'm sorry, for my poor drawing, this is going to be four, this is going And to get the volume of this cube, to get since we know that all of these are going to And one of them to get the volume we just do And that will be the volume of this cube, which miniature cubes within this larger cube. And So o of four cube, which equals 64, which also happens to be the number of times coordinates, but in our And that is why this function is O of n cube must first understand what a logarithm is. Simply put a logarithm is the power that a number I know that doesn't make much sense out of Let's take the number eight into consideration. get a PhD. In computer science unless specified that we want to raise to sum power is two. So some power to get eight. So this same equation called the base. And let's not forget that So to find the answer to this, we With that in mind, we can see that if we get the number that we're looking for So with all of that in mind, let's move on to the be using a very bare bones recursive function to you through every step. Just stay with me. So we that you can easily see how this relates to our So this variable in we will be passing to So this functions time complexity is Oh, log let's just ignore this first line and focus So when we pass a number into this function, and then calls itself with the Let's visualize this using the graph. So we first eight is then divided by two. The function then recursively to itself as the new value for n which We then do the same thing with that four is divided by two resulting in a new n. to a recursive call to itself again, We then do the same thing with our we divide it by two and the function at this level we will stop is we can no longer Now we have arrived at the beginning of so watch closely. If you look at our graph, you If you recall from our previous slide, the in is eight and we've gone three levels to raise two to the power of three or multiply division is just the inverse of multiplication, So that means that this function has a time is eight. And in computer science, our base times or go three levels deep in our recursive reasonably have our input in, which is another way And that, ladies and gentlemen, is the secret And as a quick note, this is not only And if you're curious about that line all it does is make sure we stopped dividing in would keep dividing fraction after fraction until So we'll start with a very simple function, which value to the variable in for each iteration. And the value eight two hour in for this function. So as long as eight is greater than one. And we're going to divide our n by two and reassign iteration. So currently, our n is equal to while n is greater than one, we're going is greater than one. So we'll do this math dot which would set our n equal to eight divided by it does is it floors the result of our division. five divided by two, we would get two here, our in is now equal to four. So while do another iteration. So four is greater And n is going to equal four divided by two, equal to two. And while n is greater than one, greater than one, two is greater than one. So So in is going to equal two divided by two, which is equal to one. And we're going to go to this one, we're going to do this. But right now n is we're not going to continue with this while so our n is eight. So that means eight. And if you remember from the previous the same thing as o of log base two, eight, which to get eight. And if we write this out, what power that we need to raise two to the third power to eight. So this three is what's important, because So if we need to multiply two times two times to divide eight by two three times to get one. So when we pass in a value for n, we're always log in times before we can get one, which is into this function, we're going to log in iterations, before we get to the value two iterations, three iterations. So there's is log in iterations. Because again, oh, all log our n is a, n, log base two of eight is three, which is our n. And that is why this non there will be log in iterations 123. Before To start, we should understand that in order for searching must be an ordered array, both ascending Let's start by visualizing our array. In practice, this is much more useful as the size of an with an array containing nine elements to So let's assume that we want to check our array to The naive solution would be to iterate checking to see if the value is equal we have to iterate through every element in the What if we have to do this for an array containing This is where something like binary search So here, we're still wanting to check But this time, we'll use binary To start, we need to find the midpoint of middle of our array, our midpoint is here. we know that anything to the rate of our midpoint And everything to the left of our midpoint So we need to figure out if this number 100, which we are searching for is greater This will tell us which side of our array our less than 100, we can actually see that the side To paint a full picture, let's for one second two and not 100. In this case, two would be less left side. And this Ladies and gentlemen, is why Because without the order, there would be no way is on by comparing it to the midpoint. Now let's using for our example. So now that we know that we can completely do away with anything to the So what we're left with is this, what we've done is we've essentially cut the let's imagine that we have an array with 1 In just one step, we will have cut down the 500,000 elements as opposed to iterating through And it doesn't stop here. We will now do the Let's remember that we are searching to see if the need to find our midpoint. Now don't be confused Although there won't be an even number of elements matter because we actually just need to split to find the mid and code we will do something by two. That resulting to we would use as the of this array remembering that arrays are zero And if we take this resulting two we see that our mid is 100, which is So in that case, we would be But to prove that which one of these we choose what would happen if the mid 54 were used is the than our mid 54. Our number is greater than 54. So And what we're left with is an array is an even array. So we have no way of let's see, what would happen if we use 124 is It is greater than, so we can Now we're left with an array containing only only be this element. And this element is the So as you can see, regardless of if you as long as it is ordered, the search for And that Ladies and gentlemen, is how binary So let's just start by creating a file and we can the array that we're searching must order. So you can't just have a randomly ordered something to keep in mind throughout the rest going to take in four arguments, it's going to to contain integer values, which will need to be we'll also need to pass in the first index of our And that's just going to be zero. And we will which we'll just call end. And we can get and subtracting one from it. The reason the array is because the index is of the array the length is actually not zero based, it's just So the array length is going to be eight, but will be seven. So that's why we subtract the one. a target value, which is the value that we're for eight. And then we can start building our And it'll take in the array And this function is actually going start this function off, we need to So you'll notice that we're using a And the reason we're using this is it says that it returns the greatest integer which basically just means that if this the within our function, parentheses return something be five, because we don't want to take into because we just want to find an index, which therefore, our mid would just be five. And to see if our midpoint is actually the number So this would basically return true if the mid we're looking for. So we're returning true because exists within the array, and we would be done actually be confusing you guys by referring to mid here is actually the index of our mid which so here we can just add index as well. So when I So we actually want to return true if the value value. So if the value at our mid index is not check to see if the value at our mid index is actually, this should be made index. we have another error here. So we'll start and So yeah, let's take the time to understand So if the value at mid is greater than our target, actually in the left side of the array. Because if five is going to be our mid in this situation, five is going to be our mid. And if five is then that means number that we're searching because if five were, if the number that we're would be in the right side of the array, because check to see if the item that we're searching for what we're going to do is, we're going to pass in we're going to keep the same start, which is going and then our end is going to be mid minus one away with our actual current mid and actually, need to assign the current mid minus one to our function would have this as our end, and then this 1234, which we would then in turn find the mid for what would happen if the target value that we're let's see. So in this particular case, the target mean that the target value would be in on the left then if our target is larger than our midpoint, So we're still going to function but this time, we're going to pass in the the original start point, we're index plus one. And that's going to be our new from the midpoint to the right side of the array, in the right side of the array, and then at because the end is just the end of the array. So again, pretend that for this execution, our mid we're searching for is greater than our midpoint. because everything on the left of our midpoint in ascending order. So it's going to be on this then of course, we don't need to take five into index, and in instead of returning mid index and index plus one, which is going to be this index this value six at the index one index above searching our end and our mid plus one. And we're That's what both of these conditions cover. So left of our method, which is over here. And the for is in the right environment. And this is how is more efficient than say linear search. Because we can actually essentially eliminate half of that we're searching for is less than or greater we can actually run this function and get it we're going to try and run it twice, we're going that we know that's in the array. And we're going in the array. And you'll see that we're missing and try and run it. Now to run it. Obviously, we search. And we're going to pass in array, start So we will try and write it by And we broke it. Nice. Got to add in the target See it again. Okay, so let's see what I mean, console log the And we get true because eight what you'll see here is if we search for something to break it again. So 10 does not exist. So let's exceeded, because let me show you what it means doing is, every time we don't meet this condition which is we're calling the functions recursively searching for a number that doesn't exist within keep calling itself recursively. And there's never doesn't find the item within the array, it's still eventually we reach the maximum call stack size, memory allocated to this particular application. want to add a base condition that will stop the it's checked the entirety of the array. So we can So the reason why this works is because if the the target is larger than the largest value in value in our array. So that means our function we get to either the largest item if the target or it gets to the smallest item if the target And at that point, the start and the end values start and the end values are equal passing or this line, well, in effect, make the start again using this tin that doesn't exist within And if we even added negative here, negative And let's see, what else can we try. just tried to So let's change this back to a to get a feel for let's go ahead and create a longer array here. elements. And it's going to be kind of hard to get scales with such a small array, so we can go ahead create our own array. So let's see, the trade our less than 1024 i plus plus. And then here grade up, push high. And let's And then we'll make this less than we can console. log our array. And for now, Okay, so at this point, we have a longer guys to visualize how the input is scaling when I don't need to log this anymore. Just delete that, And it's going to be an array that has elements example, I don't want us to find the element, going to change this to something that doesn't that 100,000 does not exist within our array, from this current array. So we're going to need to So this array is empty here, and then we're then we get the end of the array. And the start, And also, we can go down here and delete till because we're going to do another execute the function here. And then here is where So for each call to binary search, like each call the first call for the first call. And each that we're searching through is looking like. which we just showed when we console logged in the rate is going to essentially be halved. So console dot log will do array dot slice. So what that does is, it's only going to show it's not going to show the full array so here we can do node, log in. Okay, and yeah, So you can see, so when I make it smaller like well, at this point there is too long to show its here. So like since the value is greater than all these lower values are going to essentially and have an halved. And here's where you here like I can see that it's the ray is To understand ovan login, we will take This function has a complexity of ovan login. that we may understand what is happening here. sake of this example will be for we then declare we will get to what this variable we have a while loop that iterates through n until in this code within the while loop is run. Let's while loop in starts off is four but we divide it this line of code which is the start of a for The reason we declared this variable before divided by two for each iteration. This in But for this inner for loop we needed to iterate So we stored the original end in a separate For each iteration of this for loop up until the Once this is finished, we move on to the next going into this iteration In is now two, we And once again, we iterate through our Now at this point, you will notice that our our while loop, we see that we only want to while loop will now terminate, and the function and with everything written out, we can And there's an inner loop for each So this is where the magic happens. So pay the top level loop, which iterates This means that this top level loop never actually in the value for n is being split in half for each level loop has a complexity of Oh login. If you log in, let's take some time to prove it by in some numbers. Now if you've watched my video the base of a logarithm is always two unless base two of four, four, because we're replacing log base two of four is two, because you need And as you can see, this makes sense, because for So for this top level loop, we have log base two what is happening in each of the two iterations we loop through the full size of y, which is each of these inner loops has a complexity of increases linearly with the size of n. Now O of n log in really just And if we plug in some numbers here, we get this. And if you look at our visualization, it makes top loop, we iterate through the entirety And that, ladies and gentlemen, is So we can start by creating a file, well then create a function, The argument to this function is going to for the first portion of this function, we'll need to make sure that the array that we will need to do this because if the array element in the array, then it is already as this merge sort function is going to be need to split our array in half. To do this, we'll So with this math dot floor here does is it makes number from the result of the division. So for I don't know, let's say 5.5, we wouldn't take point. So we would only return to the variable indexes into consideration, there is no index 5.5 five or two. So this is why we're using math dot our inputted array, we can then split the array in and a separate array for the right side. So we can and then we can set left array equal to the input be the arguments that we passed. So basically the first index of our input array. And we want that we just got. And that's because we want the the array looked like this. And we win, we went something like this three here. And then we want up until our middle index, which and then we would go ahead and do the same So we're going to actually go ahead half of the array, we'll just call it right array. we're just going to do from the middle index of the array, and the way we get the last index And this here can actually be a bit confusing, the length of the array, which is the number of index is zero based. So basically, if the length 0123, and four, there won't be an index five. So working. And it's because actually, there's an slice, but it's because this slice method slices end value, it's not included in the actual array, So for example, if we have an array the end that we would use for this array would And two, it will slice up until end not including from this because if we were to subtract one from or the end index that is passed to the slice full array, we would only get up until this able to only look like this in this slice. I And also keep in mind that with this example middle index into consideration. So for this like array dot slice, well, slice and there will Anyways, last but not least, for our actual emerge is implement the recursive portion of the and bear with me, we're going to return a And we're going to call it merge. And we're going to accept two parameters, which array. And what we're going to pass to merge is And then our left array, and we're also going to right array. This is going to seem a bit confusing how this is working. And I will try to make things this merge function, so we need to go ahead and new helper function called marriage, which will Oh, sorry, and it's not merger, it's merge. Now actually merges the two arrays. So the way that approach in which the input array is basically at that point, arrays of length one, as mentioned an array of length one is already sorted. So to there's only one element in this array, so last element in the array. So there's no need to with. What we do in this actual merge function is and compare them and then sort those individual throughout the process of writing this merge going to take in two already ordered arrays, So to start, we're going to To create a variable, and it's going to start off as an empty array. And we're also going to define our base but could index equal zero. Now Next, we'll create a while loop that's going And actually stick here, this we're going to compare each element of both the other will get added to the result array element got added to the result array because If you're a bit confused by this, just illustration for you to understand it better. Let's imagine that the rays that we want merged the right array. Now keep in mind that the so it will not work on unordered arrays. In of length three to show the entirety of the work for naturally sorted arrays of length one. So and right index need to be less than the length these indexes are incremented, every time that So if we draw this out, it looks something indexes. In this next line, we check to which is currently zero is less than the element So it's three less than one. No. So that means we right array element at its current index to the And now our right array index And then once again, we do our comparison at six? Yes. So we push three onto our result And we can move this over as well. And is 12 less than six? No. So we're going to push the right array element six to the result we will move this and now is 12 less than 15. the result array and then increment the left index Now is 16 less than 15? No. So we move on the right array to our result array Now at this point, this while loop will terminate continue if the left index is less than the than the right arrays length. At this point, our As you've probably already noticed, there's not yet been pushed to the result array. But the After the while loop, we're going to add So this return is going to return a single of three arrays the result array, a slice of So this slice function if we it will be used as the start of the slice and break this down. So if you remember from the last And we're going to add to it a slice from index that we incremented which is two which And we're going to add to that a slice of the we incremented, which is three, which results in And with all of those combined, the result being Now let's go ahead and add in the return And this completes our merge function. And our merge sort function is also complete. And now we will need to create an array. And this array, And there you have it, our sorted array. and have a look at the code, you'll see that the input array into recursively, which makes And actually, this merge function is every element within both arrays to actually sort and the actual recursive merge For every level up until the depth of this doing this merge, which is O of n. So we would just have to multiply the depth which is O of n log in because of N log N in this case will be the depth at which So let's visualize this merge sort function, we'll that we have an array that looks like this. So is the array that we're going to pass to our merge So the first portion of the code here, it just one, because an array of length one is already we're just going to return that array array is greater than length one, then we're And this portion of the code is where the divide here, we're going to split our input array. we're going to split it into two separate And these individual arrays After their split, they're going to be once Once again, we end up at this portion of the code, because this array and this array are individually So for each of these, we end up at this portion not less than length do, we have an array of So they're going to move on to this portion of approach once again. And let's go ahead and write So once again, we're going to and create a left right and a right array by So you will notice that this array, this array and we've seen here, we're going to pass these arrays these arrays in to merge sort, and then they're than length two. So we're just going to return But this right here is of is going to get to this portion of the And now, these arrays are of length So these calls to merge sort, are the same haven't called merge. And what merge is already sorted arrays, and it's going to merge And what that's going to look like these results are going to be merged together are going to be combined and returned And the same thing will be done And these two sorted arrays are going as a single sorted array. And we'll do the same here. Merge. And these and returned here as a single sorted array. And And these two sorted arrays and returned here as a single sorted array. And let's not forget our So that's how we can visualize But you're probably still wondering what So as mentioned before, this merge function combines them together into one sorted array. So as you can see, merge takes both of which are sorted, and then it will return the left array and the right array sorted. So to we'll take a array and array of So this input array will pass And what that call to merge sort will do and those halves will be passed at this point, We have our arrays of length one. understand the time complexity of merge sort, we in computer science, so log in is the same as log, our array here, which is four. So in the this divide and conquer approach that we're log base two, a four, which is our in our two to the power of two equals four, which means two levels to our recursive tree structure. and we have level two. So this is a level, and what we need to do is we need to touch every And in order to sort them, if you within this merge function, the while loop within to compare the elements and create the merged we need to merge. And this merge function So that means that each And there are log n levels. So O of n times four is our in, in is for 1234. So four is our n log base two, a four is actually just two times and the number of levels that we need to traverse, in the array, which is two times four. And that's So we'll start by examining this recursive that we pass the number four to our fib function. So after we call this function, we'll end up returns zero if n equals zero, and then we move just returns one if n equals one. So once we'll end up at this first if block. And both as we know, with recursive functions, we need continue to call itself even after we're finished. and four is not equal to zero, so we don't so we don't return one. So we end up here. And result of two more calls to the Fibonacci we're going to call with our n minus one, so four call with our n minus two, so four minus two. And as we can see, four minus one is just three. And same for here. This would we have to call to our favorite our Fibonacci and one numerator passing two is our in. So for Return at these IP blocks. So we'll end up back And again, we can just do And let me just make this a little bit smaller. Fibonacci function, we're going to reach our call. And we're going to just return zero at two calls. And we're going to just return one at These ones are done. And for this function we're and is equal to one. So at this point, we'll And now these two have reached our base cases as So now we'll get into the reason why an exponential function. First, let's start So as we can see, here, we have one, two and So we can write that out level one, level two, we're calling the fib function two times. we call our fib function four times 1234. So function in this level, we make four calls to this third level for now. And let's just focus on two to the power of one and four, here's the same our exponents correlate with our levels. So their two additional calls to recursive Fibonacci, we have two calls here, two calls here, and So let's imagine that these are also additional let's just imagine that that's the case a better understanding of why this function if we count the calls at this third level and keep in mind that these calls won't actually just writing this out so that we can get a better counted out these calls to the Fibonacci function, at this third level, and eight is the same as two once again, our exponent corresponds with our we would go three levels deep. And at each level, increases exponentially. But you might be here, when it's two to the power of three, how does that result in this function being off to in actuality, this Fibonacci function is O of you can see it's o of two to the fourth two to the third power, which is the same as right. And if you remember, in bego, we ignore O of two to the nth power minus one, and we going to ignore this minus one, which results o of two to the N. And at this point, you're function calls in here. And in actuality, I only guys a better visualization of what's happening at to be off to to the internet. Because it's easier functions that we're actually not calling. And we we're only looking for an upper bound, like we're to be very specific, we're only looking for you So as you can see here, on this left function, from n. And on this right one, we're calling So this right side of the tree is always going there's always going to be this empty space. at every level, we're subtracting at every level, we're subtracting one. But we don't need to worry about this. And regardless at the bottom most level, there's always going because we're only looking for an upper bound. is actually happening and why this function is is why recursive Fibonacci is of exponential We'll start with the function that will call F. So this first portion of the code is going pass to this function is equal to zero, And then we're just going to return but if we we will go down here to this for loop. So let's the number three to our function, what will happen in our case is equal to zero, which it's not. And for loop is going to do is, for every iteration from zero up until three, which is our end, we're this time using our n minus one. So let's, let's this function, and we end up at this for loop, up until three, but not including 3012. And the because here, I starts off at zero, and we're up until AI is no longer less than in. So So if I were to be three, then we wouldn't go And for each of these iterations, 012, And that's going to look something like this. So if you look here, we're subtracting one at each iteration of this for loop. So n is going to be equal to two because we're So these are actually going to be f two. And for that we did for the first call to But this time, we'll only iterate So each of these are their own individual calls to needs to have their own for loop, which f is two. So we're iterating up until I index zero and one that we're iterating through this and the same for this call to the recursive to do this and the same for this one. And I small. But you'll see that this recursive tree need to shrink this down a little bit. So that we're going to call the recursive the function is being called with two minus one, one. Let's make this a little I apologize. So at this point, our for each Man, this is getting really tiny. Okay, so at this point, our F is one for all and AI starts off as zero. And as long as i this code. And it's only going to be less than So for each of these calls to the recursive once for this first iteration, which is zero. Now And f one minus one is actually going to be So we're going to be passing And it's going to be a little bit difficult to see in the actual function, our base then we're just going to console So for each one of these calls to the recursive console log code. And then after we perform so it's going to be finished, this entire these are going to return, they're going to And once all of these return, this entire function So instead of writing out console log, we'll just n after the log, the function So for the last time, I'm going to need to make we're left with when this function is finished this tree structure shows how many recursive case for each of these recursive calls. And if you you can see them more clearly. If you look here, we had to perform this code, we for each of these recursive calls to the function. we had to perform this code. And if you count times we needed to perform this code passing three final recursive call to our function six times and is our key to understanding factorial here, we have oh three factorial. And the reason we're just substituting so all three factorial because to get the factorial of a number, you And if we multiply two times one, we get we get six. And, and again, we needed to execute 123456 times. And if we dig a little deeper, we'll every number up until three, which is also the until one, which we can see if we look at how it can see the first three is passed. So first three three times. So times three times two is best. and six times six times one is past. So six loop first passes to three times, so passes times times two, three times 123, passing two. two iterations, so three times two we're going to iterate through this for loop of then three times two is going to be six, because So this, these iterations plus these iterations, for each of these six iterations, we're iterations, so six times will pass one to six times one, and that is factorial So to understand space complexity, we'll And this is a recursive function, that basically minus one, it's going to do this until and then it's going to just return and at that ahead and draw with the execution of this function number five to this countdown function. So with we'll end up at this base case. And we'll see move on to this part of the code, which is just And of course, five minus one is going to and we'll call the function And we'll continue to do this until we And I will need to make this a little bit smaller. And finally, we get to the call where we're At this point, if n is equal to So to understand space complexity, it's actually function, each one of these calls exists on the we call our countdown function with five, it's point, this initial call still exists on the call two calls still exist on the call stack, and all single one of these calls still exists on the call So each one of these calls existing on the stack, an understanding of space complexity using this returning at this point, when we reach our base calls taking up space on our call stack, and five mean that this function, its space complexity is of obon. So the most important thing to remember on the call stack simultaneously. And each one of if we pass in five, two as our n, we'll have which means that our space complexity is going the size of the input. So if we increase the size function is going to scale proportionally with understanding of space complexity, we can get into And the first one being that when you first that looks like this that has two for loops. And is of all of in square time complexity, because that must mean observe in square. But actually, that for each iteration, up until the size of our an additional for loop up until the size of two for loops that aren't nested that aren't old one for loop here, and we have another this for loop would be O of n, time complexity. we have to all events, so that could easily be of two times in so two times we have all of in. ignore constants. And in this case, multiplying in just drop this constant, in which case, this just that we need to recognize here. This is all then both of these four loops. So as long as our loops the resulting complexity. But there's actually taking time complexity into consideration, And this common mistake involves having So let's first take this two inputs add function last example, we only had an input, we only had through that same input. But for this one, you can have an input a, which is loop through in this top through in this second for loop. And some people is the same as the last situation where the result Because in this particular situation, we have no these inputs, like all we know is that these are could be of either completely different sizes, analysis perspective, we have no idea. so in this separate for loop for each input, we're going So in this case, the time that it would take to B, because we need to first loop through this one to loop through this one up until we reach the be simplified any further we need to acknowledge inputs. So this would be over a plus b. And here inputs, but this Time The four loops are nested. that this a function that looks like this is O well, because what does O of n square mean over input, we're going to iterate through that when we have a, we have two separate inputs. For to iterate through the other input. So what that times V, because again, we need to inputs. And these inputs could be of that visible when we take our complexity into and some common mistakes that people make with