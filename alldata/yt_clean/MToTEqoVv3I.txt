As the great philosopher Sonic the Hedgehog once said... You know it always makes me laugh a little bit when someone calls me &quot;the LEGO Island guy&quot;, or my personal favorite, &quot;the guy that's obsessed with LEGO Island&quot;. I mean yeah I've put an ungodly amount of effort into that game, even technically flying to another country for it, but out of all of the videos on my channel, LEGO Island is the main subject of only 3 of them. And to be totally honest, I don't actually play LEGO Island, at least not as an adult. Yeah I know, blasphemy. Santa Claus isn't real either, by the way. The fact is, it's a very short game with only about 30 minutes of gameplay for the average adult, and the puzzles and races are hardly challenging beyond the age of like 10. It is nostalgic, and you can tell the developers poured a lot of love and energy into it, but I don't think I've played it casually since... well, hell probably not since my let's play from 2015 - - please don't look that up. That's right, I'm putting my foot down! I'm tired of being known as &quot;the LEGO Island guy&quot;. So I've decided to spend the next few years working on LEGO Island. Okay, so... why? Why would I want to decompile a game that I just admitted I have very little interest in regularly playing? Well, some of it is the first thing I mentioned, nostalgia, but actually a lot of it is the second. The more I've looked into the development of this game, the more I've delved into the code that comprises it, the more fascinated I've become. This was not some phoned-in hack job like a lot of branded video games we could talk about. This was a real labor of love by a group of people who were passionate about the kind of immersive experience they could make for kids with this brand new technology. And by brand new, I mean pretty revolutionary. 3D games had obviously existed before, but they'd almost always been in confined spaces. LEGO Island was one of the first to actually be open world. To let you stand on a rooftop and see an entire civilization stretching out in front of you. Which, the developers admitted, is why it's an island rather than a city. So they could have an in-universe reason to limit how much geometry had to be rendered at any given time. And it did all of this with, in retrospect, some pretty limited resources. Keep in mind, this was before the widespread adoption of 3D accelerated video cards, so the game had to be optimized enough to render entirely on the CPUs of the era. It also had to stream music, animation, video, and texture data off a measly 4x CD-ROM drive. That's only 600 KB/s, less than most peoples' internet connections today. Unless you're archive.org, of course. And there were no big name game engines back then, nearly all of this stuff was custom-written specifically for LEGO Island. For me, this game has become interesting in almost every single way... ...except actually playing it. Not that I didn't think it was fun as a kid, just that as an adult, what I find fun about it is completely different. And that fascination with the technology is why for years I've wanted a LEGO Island decompilation. What is a decompilation? Pretty much exactly what it sounds like, converting compiled machine code back into source code. If you're in these nerdy retro gaming circles, you're probably already aware of some of the high profile ones. They take a lot of time and effort, so it's usually big news when one actually finishes. In fact &quot;decompilation&quot; I think is kind of a misleading word. It makes it sound like it's just compiling in reverse, like you can just pass it through some program and the whole thing is automatic. And it would be nice if it worked that way, but no. Compiling is considered a lossy process. When you write code, you're essentially giving the compiler a lot of instructions for what you want your program to do. But your program doesn't actually need to know most of that stuff in order to run. It doesn't care about function names or structs or classes, and more importantly, machine code doesn't really have the concept of variables. All it really has are registers and memory addresses, and it's up to the compiler to use those to do whatever you told it to do with your code. Decompilation is largely about trying to restore that information through context clues or educated guesses. A common analogy is that it's like trying to unbake a cake. You can't just stick it in a de-oven and unmix it to get all the ingredients back. But you can, with enough time and effort, reverse engineer a cake using context clues and educated guesses until you arrive at a recipe that produces more or less the same thing. And that is essentially decompilation. Not really an automated process, more like hand-translating code from one language to another, where the original code happens to be heavily obfuscated with little to no documentation. As you might expect, it's definitely challenging, but more than that it's just time consuming. Most completed decomps took years, even for a team of people. This decomp of Diablo reportedly took someone 3 years unemployed to complete, It's a tremendous commitment that most people simply don't have the time to follow through with. Do I think my chances of completing a LEGO Island decomp are any higher? No, not really. Usually decomp is reserved for widely popular games with high demand for modding or porting, especially if it's stranded on an old increasingly expensive console that still isn't perfectly emulated. LEGO Island is... none of those things. Like me, most people aren't interested in playing it regularly, and since it's on PC, I've already been able to write fixes and improvements through the much simpler process of injection. So what benefit would a decomp even provide? Well to be honest, mostly just a look at one of the most interesting codebases I've ever seen. How does the game actually work? How exactly do the game's infamous streaming asset packages work? Why does the game glitch out and crash whenever you try exiting on modern PCs? These questions, and many more, are what I'm hoping to answer with this project, and while technically a decomp isn't necessary to answer those, I figure if I'm going to be putting a lot of effort into reverse engineering and investigating anyway, I may as well go all the way. If I'm successful, we'll get a codebase that we can do whatever we want with. So that's what I'm doing, and yes, I said &quot;if&quot; I'm successful. This is part 1 of a series that I have no idea how long is gonna take or if it'll even be completed at all. I just think it'll be a lot of fun and hope we can at least get somewhere with it. But don't worry, this isn't all the channel is going to be now. My mind works best if I can rotate between a few projects, so you'll be seeing some other stuff too. And it won't be another five months until the next one either. Hopefully. But no matter what happens, I hope you enjoy the journey. Let's get started. Now to begin, I should mention that this is not the first time I've tried to decompile this game. My first attempt was actually way back in 2019. Yeah, remember that? The world before the coronary virus? Doesn't that feel like an innocent and naive time now. And speaking of naive, I started that decomp around September and made the hilarious prediction that we'd be getting in-game by the end of the year. To be fair, it's not like I've been working on it consistently since then. I went through a couple bursts of productivity early on, but back then I was making it a lot harder on myself than I needed to. I was trying to decompile by looking at the game's raw assembly and hand-translating it line-by-line into C++, and this is just an incredibly difficult way to do it, and it's kinda why I gave up so early. Naturally, nobody really does it this way, at least not anymore. What they actually do is load it up into something like Ghidra, a free open source tool developed by the NSA. Yeah, your tax dollars at work! Ghidra will analyze a function in assembly and make a best effort attempt to decompile it into C. However, what you'll get at first is probably something that only vaguely resembles any C you've ever seen before. Indeed the first time I saw this years ago, I was confused and wondered what the point was. I mean, is it really *that* much more readable than x86 assembly? But what I didn't realize was this is where you come in. Ghidra figures out what it can on its own, but by giving it more information, the better of a job it can do. By specifying structs, enums, function names, and variables names, you can turn something that looks like this... into something that almost looks like it was written by a human being. While the code still may not be recompilable out of the gate, Ghidra calls it pseudocode and gives no guarantee that it can be used like regular code this at least is much more readable than x86 assembly, and you can work with it and smooth it out until it is recompilable. Congratulations you just generated source code from a compiled executable! This is why I say &quot;decompilation&quot; is a bit of a misnomer. You're not getting back the exact same code that went in, in fact, if you did recompile this code, even though it does all of the same things, it probably wouldn't result in the same machine code that you decompiled from at least, not without a lot more trial and error. Several factors from compiler and linker flags to the exact order and placement of things in the code will influence how the compiler emits machine code, despite very minimally affecting overall functionality, if at all. And that's assuming you're using the exact same compiler and version of that compiler that the original developers did too. Basically there are a lot of factors to getting perfectly matching assembly and it's up to you much you want to figure all those things out to get a perfect byte matching decomp. But how exactly do you get information to give to Ghidra so its decomp cleans up? Well, unfortunately there isn't really a definitive answer for this. As unhelpful as it is to say, you just have to do what you can to figure it out. If you can find a part of the code where you do recognize what's happening, you can probably start naming some of the variables and function names. Then if you look at the code that uses those functions and variables, you might be able to recognize what they're doing, so on and so on. And again, the more information you give you Ghidra, the better its decomps will be across the board, and eventually it'll all kind of start to make sense, at least in theory. But if this is sounding like a long and laborious process, well, now you know why decomps take so long... Unless you're getting paid to do it, you really just have to do it because you're passionate and excited about making sense of obfuscated code. I still don't know why I don't have a girlfriend. But the good news is I'm really describing the worst case scenario here. Games don't run in a vacuum, at some point they'll have to make a call to the underlying operating system or hardware. Unless you're really unlucky, a lot of this stuff will have been documented somewhere before. For game consoles, you may have to rely on legally dubious leaked development manuals but in the case of desktop operating systems, their functions are usually pretty well documented. A Windows executable will in fact usually contain information in its import table about precisely what system calls from which DLLs it needs to run, and these function names will appear in Ghidra's pseudocode automatically. For example, if you see some code calling Windows' CreateWindow function, you know that that code... ...well... ...creates a window. Stuff like this will at least give you a starting point, albeit a fairly small one. But depending on the game and how lucky you are, you may be able to get a lot more information. If you're extremely lucky, you'll be able to snag some debug symbols. Remember how I said a lot of information doesn't get included in compiled builds because it's not necessary for the program to run? That is true, unless you're a developer trying to find problems in the code. Then you pretty explicitly do want a way to relate the compiled build back to the original source code, and debug symbols are exactly that. Debug symbols will usually define global variables, function names, the source code file and line that each instruction came from, and can sometimes even define classes and their members and methods. This gives you a tremendous amount of help with decompiling because a lot of that educated guesswork becomes simply unnecessary. As such, debug symbols are almost never included with the final release of a program. Whenever they are, it's usually a grave mistake by the developer. That being said, a surprising number of PlayStation 2 games have indeed shipped with symbols, to the point where there's even an online index listing them all. Symbols can also be found on pre-release versions of games, like betas or review copies sent out for testing. Obviously these are not intended for public use and the legality of obtaining them is... ...also dubious, but they don't call it hacking for no reason. Now how does that relate to LEGO Island? It doesn't. Despite all attempts to track some down, Mindscape did a good job of not letting any leak. But we do have some luck due to the way that LEGO Island was deployed. The game was split into two separate executables, ISLE.EXE, which is the front-end, and LEGO1.DLL, which contains the vast majority of the code. An executable's import table is not just limited to calls from the OS, calls to any DLL will usually be listed here, and LEGO1 is no exception. That means a decent amount of functions are already fully documented. Not just their names, but also their return values, calling conventions, and the parameters they take. Again, this gives us a starting point we can extrapolate from. While back in 2019 I focused all of my attention on the much more important LEGO1 DLL, I decided for this attempt, I'd start with the much simpler ISLE EXE. While it isn't quite as exciting, it would still be great to know how exactly to drive the game if we wanted to make a frontend of our own. So using the process I outlined before, I went ahead and decompiled all of ISLE.EXE. Not perfectly, yet, some functions are matching some of them aren't, and while my goal is to make it as accurate as possible within reason, it will almost certainly never be completely accurate because Mindscape used an old memory allocator library called SmartHeap, which is so old its logo looks like this, and yet still sells for $5000/year. So yeah considering the cost, and the fact we'd have to track down some specific obsolete version from 1997, I think it's fine if we just leave it. It's just a memory allocator, and while it apparently takes up about half the entire size of ISLE.EXE, the default allocators are basically the same thing. SmartHeap might have been a little more efficient for older computers, but on newer ones we probably won't notice any difference at all. But anyway without further ado, I present to you a technical analysis of ISLE.EXE. Now I made a decision not to bore you with every technical detail. It's probably not super interesting to hear that the first thing ISLE.EXE does is check if another instance is already running, and then closes itself if it is. Details like that I'm probably gonna skip over. Except for the fact that I already just said it. Compared to LEGO1, ISLE is tiny. It's a mere 85KB compared to LEGO1's over 1000. But I will say that despite that ISLE does more than you'd expect. You could probably guess that ISLE creates the main window and passes along keyboard and mouse input to LEGO1, but before that it does some pretty unusual things. For example, one of those things is: nothing. Yeah, nothing. As in, one of the first things LEGO Island does, just after telling LEGO1 to initialize, is sit around for 200 frames before it actually tries to load anything. I actually discovered this a while ago. I tried skipping it and found that, not only did nothing break, it actually launched faster, so I wrote it into Rebuilder as an optional patch you can enable. So... why is it doing this at all? My guess is that it's a pretty hacky way of ensuring that LEGO1 has finished initializing before it tries to do anything. Ideally, you'd find a way to send a signal when everything was ready. That way the delay is only as long as it needs to be, and you don't have to blindly wait for the worst case scenario. In fact, LEGO1 does send some events to the main window to tell it when to change cursors, which could have been used in this scenario too, but hey if you're under a time crunch and just need to finish the game, making it wait a few seconds gets the job done. I also found some things that I think are vestigial. As in things that used to serve a purpose but don't seem to anymore, and were never removed. The most baffling of which is the fact that LEGO Island tries to read an entry from WIN.INI. To understand why this is so strange, we have to go back. Like way back. Back in the days of Windows 1... There was no registry or anything like that for apps to store configuration, but there was WIN.INI. A single configuration file that Windows stored its settings in and that apps could read and write to through the Windows API. It didn't take long for Microsoft to realize that every single app, as well as Windows itself, all meddling in the same file was perhaps not the greatest idea, so in Windows 3 they introduced new APIs that let apps create their own INI files rather than using Windows'. By Windows 95, WIN.INI was no longer being used by Windows itself. While many of its settings were still honored for backwards compatibility, Microsoft was very much discouraging its use, in favor of the newer Windows Registry, which LEGO Island uses. So why is it going anywhere near WIN.INI? To be totally honest, I don't really know. WIN.INI was essentially removed around XP-Vista-ish so I tried it on Windows 98 and found... absolutely no difference at all. Judging by the name &quot;MediaPath&quot; I thought it might be another way to point to the game's streaming asset files, in addition to the ways that already exist, but if it does do that or indeed anything at all, I can't figure out how to use it. It does pass the result to LEGO1 though so maybe as we get deeper into this we'll get to see at least what it was supposed to do. Now we're getting into some bugs. Yeah, you thought this game's code was flawless? Well... I don't know what would have given you that idea. If you've played LEGO Island full screen within the last few years, you may have run into this: this white bar across the top of the screen offsetting all of the visuals down. I've found it's a little inconsistent exactly when it occurs, but it started happening some time during the reign of Windows 10. Now it's easy to get mad at Microsoft when a Windows update breaks compatibility, but to be fair, this is LEGO Island's fault. When you create a window, you give Windows some style flags to tell it how you want that window to look. For example, when LEGO Island runs in windowed mode, it tells Windows to create a title bar, an icon/system menu which also gives it a close button, a minimize button, and a maximize button. Pretty straightforward. When it runs in full screen, it tells Windows to... ...create a title bar and an icon and close button? This is... well, there's no other word for it, wrong. You can see in this excerpt from the documentation of DirectX 5, the version this game uses, specifically saying you should use the &quot;popup&quot; style for full screen apps. And indeed if you force that value instead, which Rebuilder now does, the problem goes away. Yeah, so the white bar at the top of the screen, that's the title bar that LEGO Island specifically requested. Technically, older versions of Windows were actually less correct for not showing it. But this can be a pretty contentious topic in operating systems, is it ever permissible to break compatibility, even if it's for the greater good? If you're Apple, you say &quot;[censored] yeah! &quot;We don't care if we break an app that's only 3 years old!&quot; However, Linus Torvalds, lead developer of the Linux kernel, has famously said &quot;we don't break userspace&quot; and that &quot;If a change results in programs breaking, it's a bug in the kernel. &quot;We never EVER blame the user programs.&quot; He also swore a lot. And for the most part Microsoft seems to feel the same way. Despite a lot of talk about old games breaking on newer versions of Windows, Microsoft has put a tremendous amount of effort into maintaining backwards compatibility, in some cases all the way back to MS-DOS from the early 80s. The fact is, if a program is written correctly, it'll run just as well on Windows 95 as it will on the latest version of Windows 11. There are just a lot of programs that haven't been written correctly over the years, LEGO Island very much included. You could argue that Windows suffers by trying to stay faithful to such old and frequently broken technology. Though you could also argue that's Windows' primary selling point: a huge library of applications both new and old. You could also see it as a necessary evil. Plenty of people need to use programs that are no longer being maintained and are not open source, and old games almost always fall into that category. As an example of how bad it could be, good luck trying to play a game on macOS more than 5 years old. Actually just good luck trying to play a game at all. Meanwhile if you peruse through the 2020 leak of the Windows XP source code, you can find a section that specifically mentions fixing something for LEGO Island. Yeah, there's code in Windows, probably still to this day, solely for this game. So even though we all give Microsoft a lot of [censored], plenty of it deserved, I do think they also deserve some credit for making sure these old games are still playable at all. And those are the biggest things I learned from decompiling ISLE.EXE, but like I said, we're not even in the meat of LEGO Island yet, nor have I even talked about other discoveries I've made outside of the decomp through reverse engineering the SI format. In the next parts, we'll look at that, as well as hopefully some interesting discoveries from LEGO1. If you're interested in trying out the decomp so far, there will be a link in the description, but keep in mind it is very much incomplete and what is there is still not 100% accurate, but it's a work in progress and I'm very excited to continue working on it. If you're interested too, stay tuned for more of that, as well as some other games I've been working on too. Now you may have noticed there's no sponsor on this video and it's because last year I played the whole game of sponsors, deadlines, quantity over quality, and... I was pretty miserable! It wasn't great. I wanted to get back to just doing really interesting projects and making videos about them. And from what I can tell, I think you guys prefer it that way too. But there's a reason people play the YouTube game, and it's because it is so much more financially stable. And so if you'd like to help me out at all on that front, I would really appreciate it if you would check out my Patreon or become a member here on YouTube. And I really want to give a shout out to the people who have been Patrons or members this whole time as I've been figuring out what I want to do with this channel. It's really meant a lot to me. Finally, I've mentioned this on Twitter and on the community tab, but never in a video that for a little over a year now, I've had a second channel. It's a lot more casual content, there's a lot of me telling life stories or checking out unusual stuff on the internet, but it's fun and if you want to see more of me between these longer videos, that's the place to go. Anyways thank you so much for watching, I really hope you enjoyed this video and I'll see you all in the next one.