In this benchmark, we'll compare applications running in Kubernetes. We'll including CPU usage and memory In some tests, we'll also measure how to read a file from the local file and write metadata about that file to Now, the best way to get an accurate measurement requests through all the proxies and load approach gives you the same latency that any other In the previous benchmark, I used an older In this video, I'll be using which is optimized for Kubernetes deployments. If you visit their website, you'll see that and they claim it is Kubernetes-native. According startup time is much faster compared to The reason for this improvement to compile the code into native platform for containers and cloud deployments. And On the other hand, we'll be using the Golang Fiber frameworks available for the language. I but since we're using a framework for Java, We often use percentiles instead of latency because percentiles provide a we use the p50, p90, and p99 percentiles. If the are completed in under 100ms. For p99, it means Now, why not use average duration? and 95 of them take 100ms while 5 take 2 seconds. or a cache like Redis was unavailable for a short to time out. In this case, the average latency users would experience slow performance, Now, let's say we use the p90 percentile example, the p90 percentile might of all requests are handled quickly, By focusing on percentiles, especially higher ones and optimize the worst-case performance For the first test, we'll focus on the framework itself. We'll create a simple REST API application /health endpoint, which Kubernetes will Additionally, we'll have which will return hardcoded connected will include the device ID, MAC In Golang, we'll create a struct client sends a request to that endpoint. In Java, we'll create a class and use a Java library to We'll also have a client that sends requests to the results as Prometheus metrics. We'll use Additionally, we'll configure cAdvisor for CPU and memory usage. All these and we'll use Grafana to create a few dashboards. For the second test, we'll simulate a real request to the application on the /api/images from the local file system and upload it to we'll use Minio. After that, the application along with other metadata about the image, to the We'll also measure client latency and including how long it takes to upload the database. Metrics will be exposed for Prometheus So, we'll expose Prometheus to measure end-user performance, and internal function calls. The source code is Many companies now use public clouds like AWS, Azure, and GCP to quickly scale up when demand This helps reduce infrastructure costs by To make the most of this, you need to optimize applications should be small and have a When Kubernetes scales your application, it needs each node. In many cases, we also scale the This means you can't rely on your images being the application image is very important for how The larger the image size, the longer it takes First, let's compare the image sizes of Go SDKs for AWS, drivers for PostgreSQL, and For Go, we will use a common multi-stage compile the application into a binary and then use provided and used internally by Google, is that many applications require, such as to external services. Additionally, if you might prefer using Distroless over scratch Now, when we build it locally, the image what really matters is the compressed size of is go to your Docker Hub account, for example, small. Another way is to SSH into one of the to list all images on that particular node. In Now, let's take a look at Java. When you have a few options for building Docker but to minimize the size, we'll use the To build it, you first need to compile the you take that file and copy it to the final the final size is 127 megabytes, which is almost the compressed size of that image on one of the 41 megabytes, which is still twice as large as the it's still a fraction of traditional JVM-based with Quarkus, you get really small images, Before we run the tests, let's measure and become ready. We can use pod conditions status as the starting point and the Ready after it passes the health checks. For this Let's make sure we're not using cached one node and the Java image we can measure not only how long it takes long it takes to pull the image to the Now, let's go ahead and deploy both point, you can see that it took slightly Next, let's check the conditions scheduled at 32:56 and became ready at Now, let's see how long it took for the Java app. It became ready at 33:07, just 1 second and the results are more or less consistent. because the image is larger, so it takes longer to Alright, let's go ahead and run the first themselves. First, I'll deploy both the Go them for about 5 minutes. You can see that in an more memory than the Go application, but this I have a client that slowly increases the as shown in this graph, and it also measures we'll measure the p99 percentile latency for the the Go application is lower than that of the Java higher than Go, but what really surprised me is test and stays as low as Go's for the remainder Alright, let me open each graph for the entire duration of the test. Here Next, we have the CPU usage graph. This limit and actual usage, with CPU and Here, we have the client latency for each application. These metrics are Finally, we have the requests per there's a jump from 300 RPS configured on the client to measure how well That's all for the first test. Now, the second test focused on a with an S3 bucket and also write to redeploy both the Go and Java applications we have the same results: Java's CPU and with memory usage staying around 20% until As you can see, the Java application upload it to S3, and write to memory usage is almost identical to Next, we have the latency for S3 operations. file and uploading it to S3. You can take with the Go implementation. However, Java is actually faster than Go. This is mostly Finally, we have the overall latency measured from any end-user client would perform. In this test, any use cases or test scenarios in mind where Java and I'll create additional benchmarks to Alright, let me open the CPU usage graph. Next, we have the memory usage graph. This is the requests per second graph. And finally, we have the database latency graph. I have a playlist with a bunch of different know what I should test next--maybe projects. Thank you for watching,