Once upon a time, there lived a little junior dev, everybody called him Junior. One day, his team lead said, Go and see how your senior dev is doing. For a here has been too relaxed. Junior sat out immediately. On his way, he met a QA guy. The QA asked him where it was going. I'm going to see my senior here reply and ran off. It was not long before the QA arrived at the senior's office. He sent a slack message to trick him out and sat at his desk. Who's there? It's me, Junior. Come in. Senior, what a strange GTI you run to easily switch branches, my deal. Senior, what a slow white screen ID you run. All the better to see your code, Junior. Senior, what a bloated PG admin for reading one user ID you've got there. All the better to create more bugs for you. Junior pulled out an ERCAN and shot him in the place, the end. If it wasn't clear, users of GUI don't do very well. Here's me trying to query my project database. This is a local SQLite file on the disk. And to run one line, I need to launch the CLI type the query. Remember the fit names, remember to use a semicolon. And at the end, I just get a list that's really hard to understand. No column names, any indicator whatsoever. And that's the good case, that means I got the command right. Here's me fighting yet again with a missed semicolon at the end of the line. So the question is, can we do better? Of course we can. Have you heard of Team Pope by now? Of course you have. Well, in case you haven't, Team Pope is the father of VIN plugins. Yet another famous one he made is called that bot. In case you aren't familiar with his that bot tweet, there it is, one of the top 10 of all times for sure. Anyway, that bot, when shortened turns to a DB, is DB Explorer. It works with so many options like JQ, MongoDB, MySQL, SQLite, Postgres, even Redis. I'm going to quickly add it to Lazy, so it's installed within the of him. And let's see how it works. By the way, if you aren't familiar with Lazy, I'll leave a link to the video up here. So that bot is ready to go within Lazy. The next thing I'm going to do is type DB, and then I type the path to where the database is. In my case, it's just fact.db, a file on the disk, and then my query. In this case, select everything from the workout table. And there it is, a nice list with column names, line numbers, and everything I want to have right within the of him. By the way, I did not have to use the annoying semicolon at the end of the command. It works just as well without it. Just as easily as I can read lines from the database, I can delete lines or create new ones. Any type of query works. So if I delete from workouts wherever, I can immediately see the results within database. Just for the sake of showing off, here's the exact same thing working with Redis. I can run against Redis, which by default goes to the local IP and the local port. And if I try to get keys, I can see the keys that are currently in my cache. Okay, but can we improve that? Sure we can. Meet the VIMDAD but UI. You can add a UI within your VIMDAD. That's you do all those queries, but with a UI that shows you the tables that you have and help you navigate throughout the database or whatever type of data system you're querying. I will add that what UI to my in it Lua. And once I do that, lazy sees the addition immediately, it installs the plugin. And let's try to run the UI. This is as easy as running DBUI. I'm going to switch all the way to DBUI toggle that toggles on the UI. And there it is. I can add a connection in my cache since it's on disk. I'm going to run SQLite, colon and fat DB. And once I do that, there is a new connection. I can name it. I'll just leave it the same. And I open the new connection where you can see my entire set of tables. I can look at them, open them up, read them. And every time I go to a list or any type of other query, the query is being built for me. And once I save it, I can see the result underneath. Every time you run a query, it's being saved in a saved query is above. And every time you have a result like this one, it's being saved in a saved query is below. As someone who keeps running the same query over and over because I forgot one instance or one ID, I can tell you that this is going to be so, so powerful for me. Do you remember we looked at read this connection as well before? Let's do that and add it to the UI. So there's an option in DBUI that's called add connection. Once I do that, I can add different databases. In my case, readish slash slash slash is reading the local readies with the default port. And when I do that, I can start running queries again, my local readies. If the connection list isn't refreshing, try running question mark. It'll pop the help menu and every possible shortcut that comes with the UI. So in our case, we want to redraw. You can see that capital R will do that for us. Let's run capital R and see what happens. And so the plugin refreshes everything. And it also tells us that it's refreshing all the databases. And once I click that, it says that it's connecting to the DB readies. So we've got that bot running. We've got the UI on top of that, which makes everything nice. But you can see that tree sitter is not really happy about what we're doing. First of all, it's throwing errors. And beyond that, it's not showing me any syntax highlighting. Maybe we can overcome that and come up with something even more powerful. So last improvement for the day before jumping to tree sitter, we want to add auto completion. I want to be able to see the fields. Maybe even see what type of columns I have and use them just as I'm using any LSP for any other language that I'm typing. So let's add Vintadbot auto completion from the center developer too lazy. So it can be loaded into new Vint and yes, by the way, you can see all my configuration files within my dot files repo on GitHub. Okay, the plugins installed. Let's see it in action. Let's fire up the DBUI by running the toggle command. And now I want to start running a query doesn't matter against which database. Now catch that, not only the LSP offers me different commands to use. If I go to user.it offers me the different columns that I can use inside my query. That's kind of amazing, I think. This feature it's own is worth the entire hassle of running anything and installing plugins. I think the ability to build queries based on auto completion with column names and with the suggestions that are coming from the LSP is just an amazing experience. Just like typing any other programming language. I'm being offered both column names and available commands that I can run, union, until usage, etc, etc. Still, Triseter and the highlighter is not happy. So I'm going to run Triseter installed SQL and we can do that with another method. I'll show you that in a sec. But once the SQL is installed for Triseter, we're expecting to now also see syntax highlighting. So a quick restart, let's toggle the UI again and start a new query. Now get this, I'm running select all from users and I get syntax highlighting for my SQL queries with auto completion, all inside new of them. That not only improves the experience of running SQL queries, it improves the entire experience within new of them. That's quite amazing and I'm so happy to have that experience as opposed to running the CLI on black and white screen, never having to know what kind of columns I'm dealing with. So here's the promised configuration of my init Lua. I'm configuring Triseter languages and all I have to do is that SQL is under the insurance list to make sure that it's always part of my auto completion. One thing I have to mention is that you need to have some type of auto completion mechanism. In my case, that's going to be CMP. You can go back to the documentation of the auto completion plugin and it will tell you what it supports, other options like completion and VIMCOM, DDC, COC, Decomplete, etc, etc. You'll also note that I'm loading config.datbot when running the VIM.datbot plugin and that Lua file basically tells me what type of files should it operate on. Not to worry, I load them all into my dot files repo and you'll have all the code. So just as I spoke about work trees and said how the mental work and the mental effort that you need to put into something is the value in something like that is the exact same thing that I think about that bot. So it's done an efficiency and productivity because when you can run syntax highlighted query and get the results and or methods or types of columns or the columns themselves, it makes you more productive and not only your productive viewer and join your work, which I think in the long run kind of makes you better developer. Putting that aside, the fact that you can query the database right from within your VIM and keep list of connections and a list of saved queries and results and everything right there ready for you to go where you write your code is what take that mental effort kind of away. You don't need to invest the energy and the mental energy into working your CLI or kind of fighting with different syntaxes or remembering the semicolon stuff like that. When you bring things closer to your IDE, to your normal environment, especially when you're enjoying working with them because they're cool, they're fun, they're color nice, it makes you a better developer. So I think it's an investment in productivity for the long run. I hope this makes sense and I will see you on the next one.