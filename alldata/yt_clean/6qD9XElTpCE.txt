(contemplative electronic music) - Hi. I'll be talking about some recollections about when I discovered But first, I thought we should go back and talk about where I was when this conference was being held. So in 1981, I was a senior at Caltech, which is the same place And so obviously, Feynman was preparing his keynote address when I was studying and But I didn't hear anything or quantum computation. What I did hear from Feynman that I went to called and I'll mention it because first, he says a few things in his keynote address. And second, I think it So in this lecture, Feynman said that he had been And Bell's theorem is that shows that the EPR That really, quantum mechanics can not be local and realistic. I won't tell you what realistic means, but that disturbed a number including Feynman. So he looked very carefully that went into Bell's theorem to see if there were that he could look at. And he found one. The hidden assumption was were between zero and one. So he asked himself, suppose we let the probabilities be any real numbers less And we arrange things so that only when you to get the probability it has to be between zero and one. So this was his idea. And well, he hadn't worked And apparently, he never worked it out because he published a called negative probability. And the very interesting was that this motivation for was absent from the paper. He didn't mention anything He mentioned as motivation, well, is there any way we that appear in renormalization? And that's another big that nobody has done anything about. So I think this shows that Feynman was really careful He didn't mention the original because it would have been clear that he had been wrong about this and that he wasn't able to resolve the paradox of Bell's theorem. So he found another which didn't destroy this Feynman mystique of never making mistakes. And there's another interesting It shows that Feynman In 1964 at a set of &quot;I'm going to tell you If you will simply admit that you will find her a But do not keep saying to yourself if you can possibly avoid it, but how can it be like that because you will get down from which nobody has ever escaped. Nobody knows how it can be like that.&quot; But you know, 15 years he then disobeyed his words and started worrying about And it was a blind alley Of course, maybe the advice he was giving wasn't to professors who are tenured, but for graduate students. I mean, the only graduate who did a lot of, you know, had a successful thesis on the foundations of quantum mechanics and avoiding Bell's who proposed the many-worlds theory in his graduate PhD thesis. And he left academia after he graduated. So now, I want to skip ahead to the next. The first time I heard it was a talk that Charlie And I don't remember the exact dates, but it was obviously after And I think it must have been, or not Bell's theorem, it was after BB84 in 1984, but it must have been before Charlie built his QKD apparatus in 1991 because I don't remember the apparatus from the talk involved. Anyway, Charlie gave the BB84 and he asked an open question, which was, is there any way of proving mathematically that this is secure? So I thought about it for a while, but I gave up because I at how you would take the BB84 quantum key distribution protocol and turn it into rigorous mathematics, which is rather ironic because in 2000, John Preskill and I gave of the security of BB84. Of course, that was after we'd learned all about quantum information, and quantum computation, and quantum error correction, and all of the stuff we've learned went into that simple proof. Okay. So I gave up on worrying of quantum key distribution. But then a few years later, in 1992, Umesh Vazirani came to Bell Labs and he gave his talk on where he put quantum Turing machines into a mathematically rigorous framework and where he had a algorithm the Bernstein-Vazirani problem, which seemed to run faster Turing machine, than on So that really intrigued me and I started thinking about whether there were or any more useful or more convincing problems that could be done on a quantum computer much more efficiently than I didn't get anywhere on this question until I saw a paper of Dan Simon's. And Simon was looking at this problem, find the period on the vertices of a high dimensional cube. So here's a three-dimensional cube, in which case the problem is trivial. But if you have a 500-dimensional cube, it suddenly gets very hard. So there's a function on the vertices. And this function is the property that if you go into the screen and then move horizontally, you will see a vertex of the same color. So that means that these colors of the because if you add a binary you will get another So Simon's problem was which we only can access as an oracle, find the period. And the way he did this was by applying what is essentially a Fourier transform over a binary vector space. So I looked at Simon's problem and I knew that Fourier transformers were very good at finding periodicity. And I knew that the discrete log problem was also very much related to periodicity. And the discrete log problem is one which if you look at there are some public-key cryptosystems that the discrete log problem If you can solve the discrete log problem, you could break the cryptosystems. So a similar thing holds for factoring. If you can factor large numbers rapidly, you can break the RSA cryptosystem. But discrete log problem, you break the Diffie-Hellman cryptosystem, which is not as common, but which is still a So I started looking at whether you could solve And so for the discrete log problem, it looks very similar to Simon's problem. Now, the function is not but on a very large torus. And there is a period there. So in this example, if you move two vertices to the right and one vertex down, you see another vertex And if you can find the period of this function on a large torus where you can only query the colors of the vertices by an oracle, you can solve discrete log. I knew that the Fourier transform was very important for finding periods. So I figured out how to on a quantum computer over an And then I figured out how to apply it so I'd get a discrete log. And there's a very which is that I had seen Simon's paper when I was on the program So there's two big conferences STOC and FOCS. And papers in those conferences are treated kind of the way physicists treat Phys Rev paper. The story, which I don't think is is that people count up the And if you have enough of Anyway, we rejected Simon's And then before it actually appeared, I realized I could use the idea to find, to come up with a discrete So I called Simon and so I would have a legitimate copy. And then I went and wrote my paper. And Simon said that he never so he didn't really mind that. At least, I argued for I obviously didn't argue I should have been jumping &quot;you absolutely have to take this paper,&quot; but I did argue for it and I guess theoretical didn't think highly of quantum computation so it got rejected. Once I had solved the I gave a talk about it at Bell Labs. So before the talk, I'd only told a handful including Jeff Lagarias, who found a very minor and my boss, David Johnson. But the talk was in Henry Landau Seminar, which is an internal seminar at Bell Labs, which has a very active audience. You know, the speaker gets and there have been at when people have never more than the first two or because they got so many questions, they didn't manage to get But actually, it went very well. And then I went back to work and I managed to solve a few days later. And that weekend, so five days after my talk, I got a call from Umesh Vazirani saying, &quot;I hear you can factor Tell me how it works.&quot; So there was a couple First, the rumor mill must've spread the result very rapidly. And second, if you know the old one person whispers something to the next, who whispers something to the next, who whispers something to the next. And it's completely changed by the time it gets around Well, I had told everyone and I don't think I told anyone other than maybe one or two people that I've been able to but somehow the rumor changed Now, that's not too uncommon because there's an between the problems of They can both be used to and any time anyone has ever found an algorithm for one of them, some time later, maybe six months, maybe a couple of years, the techniques from that algorithm can be used to apply to the other one. However, it's not the case and with some kind of, you know, stick it in some kind of and get an algorithm for discrete log out of the algorithm for It's just that they are that one algorithm for one usually gives an algorithm for the other with enough thought. So yeah, when Umesh calls me, I told him that I knew how to factor large numbers on a quantum computer. And the news spread So I think the first thing was, yeah. So Umesh Vazirani called me on the phone, but the first time I talked was Charlie Bennett. There was a Columbia Theory Day, which was held twice a And there was one in late April. And Charlie Bennett, arranged to get together at the Theory Day and I could talk about the And then he explained about quantum puzzles and quantum information to me. And so that's there. The next thing was I gave a conference at the Cornell Algorithmic which I think was the And I was invited at the last minute, this was the first few days in May. And so I flew up and gave my talk. And yeah, there was who came up and asked me There was a conference at the and I couldn't go, but Umesh Vazirani talked And so a lot of people And let's see. I was deluged for my I got interviewed by a bunch of magazines. And I think the next big conference was a conference arranged And that was in August. And it was specially arranged because of the factoring algorithm. And despite the fact asked me questions at the talk at Cornell, a lot of people from the NSA didn't know anything about the, or at least have told me about the factoring result And then after this, there was a conference there was a conference in Texas, which was the Physics and which was sort of a follow up to the 1981 Endicott House Conference I think that was called Physcop '94. And then there was FOCS, which I had submitted my paper to. And both Simon's paper and and I presented the result there. So there was one big objection And Rolf Landauer apparently at the May conference at which is that you cannot correct errors on a quantum computer, or at least it looked like you could not correct errors So, why can't you? Well, it's basically, there's There are a bunch of techniques for dealing with faults One of them is checkpointing where you take your and you write it down. So if the computation after that point, you can go back to the checkpoint, and you don't have to go Another is error correcting codes. And error correcting codes So if you make one error in you can use the redundant bits to fix it. And then finally, there where you keep many copies and continually compare them and fix them by taking the majority. So it looked like none of these techniques could actually be used to correct errors on a quantum computer. I mean, checkpointing, what you do is you take your computation and you write it, the state of your computer down. That's making a copy. That's not allowed. For quantum error checking codes, you take your bits that you have in memory and you make parity check bits, which are essentially redundant copies. So that also looked so that wasn't allowed either. And the final thing, massive redundancy. Well, if you have five copies and one of them derails, now, there's only four. Now, you want to take the four good copies and turn them into five good copies. That's cloning too. You're not allowed to take four and turn it into five copies because it violates the non-cloning term. So it looks like you can not fix errors on a quantum computer. And if you can't fix errors, then you have to do your And if you have say, a billion which is what you need to factor a cryptographically important number, then you need to do each part, each step in your computation accurate to one part in a billion. And you ask experimental physicists and they'll tell you that's So if you want to get an estimate for what the state of the art was, Jeff Kimball estimated that could do one two quantum bit which is pretty pathetic if you want to do a billion gates with one part in a billion However, it turns out that don't actually need to clone things. So the simplest classical is you take zero and you You take one and you can And you can do that on quantum bits too. You can encode zero by zero, zero, zero, and one by one, one, one. And this is not cloning because so a superposition of zero and one, you don't get three copies You get the superposition and the encoded one. So this code corrects bit errors fine. So bit errors essentially behave the way that the bits in classical but it does not correct phase errors. So if you make a phase error in one qubit, you actually make a phase So that means that phase errors because if you have some in your qubits, then the error error rate and your logical qubits Now, what I realized was that takes bit errors with phase errors and phase errors to bit errors. So you can apply that And now, it will correct any phase errors, but bit errors are So, what do we do? I mean, we have the errors. It looks like you can So squeeze the encoded qubit one way, but then the other kind of So is this something that's unavoidable or can we fix this? Well, I realized that correcting any single qubit error. And it's formed just by and concatenating them. First, doing code using the And then you encode each qubit of the resulting three qubit code with the bit error correcting code, and you've encoded one and it cracks any single qubit error. So sometime after I wrote this. So it was too late to that gave the nine qubit code and I never bothered I discovered that Asher Peres had actually discovered that corrects bit errors much earlier. So in 1985, he wrote this paper called, &quot;Reversible logic and quantum computers.&quot; And in it, he started worrying about and he proposed this three qubit code. And you can see that this zero, zero, zero plus one, one, one, except he calls them he's included this code. He didn't need to worry because he was just worried about doing classical computations And if you do classical phase errors don't matter. So Perez discovered the three qubit code that corrects bit errors and actually said some much earlier than my paper. After I wrote the nine qubit paper, I started thinking about maybe there are better quantum After all, the repetition code had been known for thousands and nobody had invented the until the 1950s. So I started thinking, well, there should be some more efficient quantum error correcting but it's the analog of the very inefficient So I started looking at repetition codes. Now, the classical Hamming code encodes four bits into seven bits and corrects one error, and this is probably the simplest classical error correcting code. It was discovered by Hamming around 1950. And well, you can do a And playing around with I got the quantum Hamming code. And what this does is it encodes and corrects one error. And you can see that it's just made by superimposing states of So I showed this to Rob and was an expert on And we generalized this you can construct, which were CSS codes. And Andrew Steane discovered as well as this class at And so they're now called CSS codes after Steen, and Calderbank, and myself. And inspired by this, a bunch of groups start investigating more complicated codes. So what they did was they on trying to figure out codes. And two groups, one at discovered a code that encodes and corrects one error. And they actually discovered but it was easy to see that one could easily be And in fact, this is but a transformation that Anyway, I saw these papers and I said, well, there's obviously a lot of structure to the five qubit code, because you can look and it has a ton of symmetries. So there must be some some way of systematically So I started looking around that. And I wanted to figure out what the symmetry group of this code was. So I asked Neil Sloane, who was another mathematician how would you find the So he said, well, you should And he gave me an example Magma program that he was working on a different problem that he had just run to compute the group of So I put this code up on Magma and wrote a program. And it spit out the fact that the group has And this happened to be as Neil Sloane had found. So we looked at it more closely and not only were they same size group, they were the same group. And in fact, there was a deep connection between packings in Grassmannian space, which is what Neil Sloane was looking at, and quantum error correcting codes. And that gave us the hint to figure out how this It comes from additive codes over the field with four elements. And using this construction, we could find many, many, And this is in fact the which were discovered and the same time that we had done our work. So I believe that's all I have time for and thank you very much for listening. I'm very happy to have been part of this 40th anniversary celebration of the original Endicott House Conference on Physics and Computation. And I hope to enjoy the rest of it.