This course will help you learn what you need to solve coding challenges. Alvin's dynamic courses on our channel. And now he's back I'm Alvin from Structy. Welcome to our course to be about graphs for your technical interviews. when it comes to those technical interviews. throughout this course, is the handful of on those technical interviews. in just about all the tools you need to basically cover so what I have in store for this course, well, and algorithms, and especially your graphs to do is trace through a lot of different at a high level. And that means going through have a pretty bad rap for being a difficult very, very different narratives around a problem, based on a graph premise. So we're going to be understood as graphs. So when it comes to assume that you know nothing about graphs. going to have the expectation that you understand course, and learn about different graph patterns, some very classic interview problems about of opportunity to practice these patterns whenever you have them on a technical interview. using a handful of different algorithms, you right. For every graph problem that we cover, section one is going to be about the approach strategy and overall theory, and be sure to also going to talk about the complexity of every approach, we're also going to implement all of my code in JavaScript, you'll be able So that means occasionally I'll be switching follow along. We're also going to be sure on screen. That way you can formerly you read look at the different test cases. Alright, let's hop right into the course. Alright, course, I want to start by giving you some to go over the graph basics that you need interview. So first off, what is a graph? and edges. So with respect to nodes, you can with some data inside of them. So I'll put And when we refer to edges, that would be example, if there was a connection between right? What I can formally say is there's edges between any nodes I want within this the wild when it comes to describing nodes, right, they're really the same thing. In this edge is just a connection between a pair of a high level, where things get interesting actually solve a problem, right. So if you edges as relationships, a graph is grid describing we can say that the nodes here are cities are in a similar way, maybe our nodes here prerequisites. And so in the future, we're and frame some narrative problem. Let's talk have drawn a directed graph. And that's because would be a comparison to an undirected graph. except I don't have any arrowheads on the directionality to it right. If I look at the A, well, then I can travel to B or C, let's cannot travel to a, I can only travel to E, of the arrow heads here. By take a look at situated at the scene over here, that I do E, right? So if I traveled to a, that's all of as an undirected graph as a two way street. version. Let me also introduce some useful the nodes in our graph. If I was currently and C as neighbor nodes. Alright, so a neighbor through an edge, of course, obeying the direction situated at the sea node, that I only have you know, then I won't consider a neighbor. you should really sketch a picture that looks as circles and arrows as your edges here. this algorithm in some code, we're gonna have Right? So in my brain, I think of this image in my program, I'm going to use typically way to represent and graph information, right. choice we're going to use typically, we would an adjacency list. Really, we're looking forward data structure that has a key value pair mapping, be an object, if you're in Python, they'll Java, or C, you'll be using an unordered map. this adjacency list, the keys of this adjacency right, so I just have all of the node values if you look at the corresponding values, the right? So if I look at this very first entry, the array of populated all of the neighbors That's why I have this correspondence within entry within my adjacency lists. So for example, to the spot and make j c list where the key That's why the array for he only has be inside node has no neighbors, it should still appear if you look at the D, node D has no outgoing However, it should still at least appear as way, you can still know that the D node exists. be taking in adjacency list as the information through things on the whiteboard, we should this. Awesome. So let's actually jump into know algorithm for a graph is really going Why don't we start by talking about a depth of before, right, now we're going to talk that operates on a graph. So let's start by depth first traversal would give you. So let's choose a as my starting node, right, so I'm a depth first traversal. Now that I've, you hit B or C. Next, I'm just gonna commit to far have a comma b. And at this point, if I must go deeper to the D node. In other words, be a true depth first traversal, right. At D, D is a dead end, right? I can't travel the arrowhead. And so now I can move to that would continue, right, I go from C to E, and to double traverse some nodes like B and D I have colored the full region that a depth a notice that if you started at a it would of normal, right? That's kind of why we use whether or not you can travel between some later on. Right? So you're probably wondering, but for now, I just want to stay focused on our depth first traversal, we remember the hit the sequence of a B, D, right, that's let's compare that to the breadth first Marion. we're also going to start a traversal at the order. So I have a first and let's say, you to breadth first traversal. It doesn't matter choose, so I'm just gonna choose B. But now breadth first traversal, I must hit c next, our depth first and breadth first reversals a B, D, whereas my breadth first would start is there any importance between this nuance breadth first, or vice versa? Either a depth the same exact nodes within a graph. However, right? And this is more obvious to see when And so let's look at how he depth first traversal graph, let's take a look at this one. So I'm point, let's say I chose this node in yellow, I'm going to do is, you know, pick a direction possible before switching directions. So let's would have to continue moving toward the right, at which point, I have to choose some new keep doing that until I can't move downward now, now I'd keep chasing this single path indicative of a depth first traversal, right, before switching directions. Let's compare say start at the same node in pink, if I was look something like this. From the starting neighbors of this node, kind of in a circle So as you notice about the breadth first traversal, evenly, right, instead of just favoring One the only difference between a depth first course, I'll bring up explicit problems where but for now, what I want to do is give you build this algorithm will kind of talk about pseudocode, then, of course, we'll express it comes to actually implementing in code, that a depth first traversal uses a stack, recall that a stack is something where you well, or is it Q is something where you add it gives you two very different orderings. these two algorithms. So let's start by tracing using a stack, so I'm going to use a slightly I'm going to use this bar to represent the least I think of a stack as some vertical arbitrarily chose a as my starting node to the long run, just want to print out all different gonna do is I'm gonna take my starting node it onto my stack. So right now as the only my stack. And now I can enter the flow of stack, what I can only do is remove the top the stack, and consider the a node, my current let's say I print out a to my console. And neighbors, right. So if I look at the C node, then also push B to the stack, right. And push these neighbors. If I want it to hit right? Awesome. That would end like my first So at this point, I can look at my stack, I should do is again, pop the top of my stack. that becomes my current, I'm also going to neighbors, B has one neighbor of D and so because I have a stack D ends up on top of iteration, when I pop the top of my stack, and I can print out D. And this feels good BD, notice that I kind of pursued that single look at DS neighbors, I can take f and just my stack is still on empty. So I should do print out F, but f has no neighbors. So F of the stack. Right? At this point, I get stack. And that means C is now my current, at Sue's neighbors. And I just push e to the popped up on my stack, he is now my current I don't push anything else to the top of my state where my stack is empty. And that means explored as far as possible within your graph. case that you're able to hit every node of was possible though, awesome. So let's redo which means we just adjust things slightly. queue is a first in first out data structure, they leave from the front. And so let's say of my queue, right. And I start the algorithm Let's say I want it to begin at node A. So I start by removing the front of my queue. out a as well. And now I consider A's neighbors, to travel to B before C, then I should push the back of my queue, right. And I should And that would actually end my first iteration. on it. So I removed the front of my queue, I print out B. Now I consider B's neighbors. to the back of the queue, since D enters through really important behavior. next iteration, is now see, right, I can print out see, and I add e to the back of the queue, which means behind the my next iteration, I removed D neighbor of F to the back of my queue. next queue, print it out. Since he has no neighbors, back of the queue. And of course, finally, F, F has no neighbors, at which point now is empty, that would be the end of our algorithm. first and breadth first algorithms, they're use to solve many different graph problems. I want to do is now switch to my code editor, JavaScript, hey, programmers, here I am in how to implement those depth first and breadth depth first. And my goal is really just to my values in the graph, according to a depth this function depth first print, making an take in the graph, which is going to be given the same graph. Now last example we traced starting node here, I'll call it a source Starting at that node. Cool. And so we know to be a stack. So I'll show you how to implement explicit stack. For me in JavaScript, that's right? I'll make it empty at the start. And commit to using operations that manipulate if I just use push and pop, that will always and adding to the end of that array. What to initialize the stack with my starting node, like a node here is really just designated to designing like the main loop for the algorithm while the stack is not empty? In other words, that I have to keep running. That's very reminiscent when it comes to performing like a single to do is remove the top of my stack. So if item of an array, in this case like the top I'm going to save that to a variable, I'll actually be a great opportunity to just print current, right? So looking at, you know, this to contain just the source note of a, on the of course, pop out a, then I would print it to do is consider A's neighbors of B and C. with a, I can just key into my graph, right, I say graph, square bracket, current, right, bracket current would give me back this array. neighbor in that array. So I'm going to nest that array. So if you're familiar in JavaScript, an order through an array. So now I'm hitting want to do with those neighbors is simply will just be stacked up, push and push this push every single neighbor that has. So sometimes have one neighbor, or even no neighbors. That's baseline depth first print. Something that implement this algorithm is to consider like not when it enters the stack. In other words, after something is popped. And the thing that go ahead and give this a run, see what we order of AC e b df, which you'll notice is over here. However, this would be also a valid mind is you know, depending on like the arbitrary array, you could tend a different direction for when it comes to verifying a depth first same direction before switching directions, I go a and then to a C over here, the next what happened in my code, right. And then I can go on to my other lateral neighbor like expected here, if I just flipped this right. around. They're both valid. depth first traversals. order of A, B, D, F, C. And really think about popped out a from my stack. So I printed out there, I start iterating through the array first iteration, I iterate through C, right? the bottom my stack, by pushing on the stack, B on the stack. Now B is on top. Since B is this while loop, I would remove B and that's they're really both depth for sure Russell's. going to use a stack to implement depth reversal. ways. Right? So here I'm using like an explicit this using some iterative code, right. So do is implement depth first recursively, because stack. So let me show you how to implement having all these different tools in your arsenal, and recursive flavors. We'll see that later solve the same problem. But now recursively, going to have the same sort of arguments, list as well as a source node, consider like So if I'm at some node, maybe the first thing print out this node, so I'll do is console good just from the get because when we actually they're passing in a as the source node. So print, and then from there, I need to look at as neighbors like before, just key into right, and this would give me an array of So I'll say for let neighbor of that array. do the recursion, right, so I make a recursive that means just called depth first print, object doesn't change, but you should change in that neighbor as the source node. And you're in that array. And this would actually be version. divider run over here. Looks like really again, another type of depth first this time we chased c first, right, we went my recursion, then I would have to put in let's get that into the run. Good AB de FC. first is it has no explicit base case, meaning just like returns like you'd typically see problem I have an implicit base case when say my current source coming in is he, well, iterating through this empty array, I mean iterations, then you never make a recursive a base case, right? A base case is really call. So that's how this code still works. depth first in two ways, right, iterated and a stack. Let me now show you how to implement out some of this code. Now we'll do a nice So for a breadth first, we want to solve the iteratively, right. So I know a breadth first implement a breadth first traversal using some stack data structure, that's going to right? So for breadth first traversal, you're iterative code. So some loops, right? Let take in the full graph, adjacency list, as my queue. With that source note, again, the JavaScript. So I'll say const q equals an Awesome. And I'm going to use this queue by my arrays in JavaScript. So if I use array an array. If I do array dot push that adds those two methods in combination would give from the other end. So like before, we're while our queue is not empty. And so while And same thing as our iterative, you know, the front of your queue. So I'll say q dot as well as return it to me. So I can save just like the whiteboard, right? And from dot log, this current node. And from here, I key into my graph, using this current node, want to loop through each of those neighbors. that array. And for that neighbor, I want me, that would mean simply q dot push, I'm Awesome. So I remove from the front, and I Let's go ahead and give it a run. And actually, order of this, put the CNB. Again, doesn't I just want this exact output, and we'll talk So I get ACB EDF just like I expected ACB iteration of this breadth first print, I know initialized a on the queue, right? So my current I start iterating through this array, right. means I put c into my queue, right? And then B, that means C is at the front of the queue, C first, right? So that's how you can manipulate first print. Awesome. That's all there is want emphasizes, especially if you look at depth first or breadth first, it's almost how you access items in your array, right? harder than that the whole like structure So that's our introduction on depth first section, we're going to start to solve a problem, utilizing this code as our baseline tool. doing the analysis for bego of these algorithms. programmers, welcome back, right, and let's So in this problem, we're gonna take in an problem, and really all graph problems, you a picture. And so what we'll do is we'll interpret a distinct node. And if I look at any particular to G and I. And they do tell us in this problem to draw arrowheads on these edges here. So I'll create similar edges based on the information like this, until they tell us that this is but they also tell us that this graph is a just means No cycles, that kind of begs the cycle would be a some path through nodes, other words, if I started at the a node over I can go to C, then back to a, and so on and Sigma graph, I would get an infinite loop. is guaranteed to be directed. So it has arrowheads, any infinite cycles here. That being said, only the graph information, but also a source true or false indicating whether or not we node. In other words, is there a path that you can use either a depth first or breadth here, I'll trace through in this approach the walkthrough, I'll be sure to code it up node, I know that if I was doing a depth first say happen to choose to G next. Now I have first, I should go deeper to the H. So then different nodes, I need to ask myself if my far, that hasn't been true. At this point, any deeper. So now I can move laterally to move to a K or a G, let's say by luck, I just bring me down a path I've explored previously, be too much of a big deal. Eventually, if the graph, I would end up at a node that matches true signifying that there must be some path And as we do this depth first search, it's of your arrows. So I should never try to travel were able to find a path from source of destination. say that now, I should return false. Alright, J. And I'm trying to get to my destination here, sorry, my j node traveled to the AI G, okay, let's say I happen to hit the k, to the G. And then from there to the H. And I can go, right. So if I finish my traversal or breadth first and I never hit my destination, be the case that there is no such path from to implementing the depth first and breadth to be exactly what we're used to, you can Or you can do it iteratively. And use a queue traversal. We talked about the complexity nodes of our graph, a common thing that you e as the number of edges here and edges refers just the arrows. So if we use these two terms have a time complexity of our V o of the number through every single edge of our graph. Here, number of nodes, right? If I solved it, recursively, first stack, then the worst case, I would right? Likewise, if I saw the eternity with node on the queue. So that's just one way time and space of this graph. Typically, for analyze the time and space of your algorithm define n as the number of nodes. That's because we can also say that n squared would be the the worst case. So let's imagine the worst of ABC. Well, if I wanted to create as many a single edge? Well, an edge is just a connection draw an edge for every pair of nodes in your we can say that n squared is the number of just wanted to use n to define the complexity going to be O of n squared, and your space that these are both two valid ways for defining That being said, I think this is pretty straightforward. we're actually implement both a depth first see you there. Hey, programmers, Alvin here, for this has path problem. And so we'll jump one using a depth first traversal, which I I'll just implement that using recursion. ordering. And so I'm gonna solve this recursively, my current position during the traversal. right, if my source is equal to my destination, for. So just return true. This base case signifies exist a path. And so I return true, always us to return for this function. Let's say So what I should do is consider my current If I key into my adjacency list, I know that it using my source, that would give me an let's say it was staring at this one, if my bracket, F, I would get back an array of gi. right? So I can see over here is turned us neighbors, I want to traverse to them, which keep your graph the same, but update your at the neighbor. And the destination stays to get to solving this one recursively. So return, I know it's going to give back Boolean, there is some path between my neighbor and connecting point, or some connecting path I know that there must be some path from my is definitely next to your neighbor, right. And so what I'll do is, check if this recursive maybe it's clear. And so if there is some then I can return true, just pass that true just exit out and return that shoe all the say that this call returned false, that means to the destination. But it couldn't be the going to work out. And so what I don't want you should be able to immediately catch that no point of having a for loop then right? return, then you're never going to have a So if I don't find a path through my neighbor, okay. Just continue on to the next iteration, begs the question, Where should we return only after I searched through all of my neighbors, return false, and that'd be our nice depth Awesome. There we have it. One thing to bear in the problem, right, they tell us straight a sick like, so there are no cycles. So that's getting trapped in an infinite loop. In our to actually deal with that sick case. But While we're here, let's also do a reference iterated, right, there's no way to do like to create my own queue. So I can create a an array in JavaScript, I'm gonna initialize refer to like source and destination, they're problem, they're really just given us strings, about the information they represent. I'm So while q dot length is bigger than zero, tree algorithms. And I start a single iteration So I can say q dot shift some of the front, through. And now that something has left the can check. All right, if a thing I just visited, return true, right, I found the thing I'm connects my original source and my destination. then I need to consider its neighbors. So into your graph using the source like it's me an array of all of the neighbors, all the is iterate through every neighbor Over there. So q dot push that single neighbor, and do So you need to make things leave from one end. So this codes looking good. So you should binary tree breadth first, except now we have like a dynamic amount of neighbors here, not iterating through all those neighbors adding you guessed it, the move is after you finish empty, then you must have explored as far and now you can return false, because it must the original source and your target. So let's time and space complexity. But this would So here I'm getting a little error. Let's I timed out here. Let's see bug this one together, wrong getting trapped in an infinite loop. greater than zero. And so here it is, must through the neighbors here, I just wrote source. I'm doing this iteratively, right. So whatever nodes neighbors and add them to be visited a test run. honest mistake there. Cool. And has path problem. So what I want you to do first, like you expect, we're going to do on you know what the problem is asking sometimes other. So it's really important that you practice are relatively easy. So practice this, give in the next problem. See you there. Hey, programmers, for this undirected path problem. So we'll to be given an edge list for a undirected here, really what we're saying is every pair between two nodes. For example, if I look j, that means that there's a edge or connection graph, not only can I directly travel from i. So it really represents a connection in this problem we'll want to do is actually format, like an adjacency list. That's because they work best on an adjacency list form. And I'll actually be pretty easy to code up. I have nodes as keys, I want them to point if I wanted to convert the first edge into keys for i and j. Now that I is a neighbor going to populate those neighbors respectively. So if I look at the edge, k comma i, I need populate that with I and then for the existing So do bear in mind, the most important thing the graph is going to be undirected, whenever sure that you have the inverse connection. need to have information for it. Okay. And list of edges. And by the end of this conversion, this. And now we're ready to perform our main for this, I'll show you in depth how you can when we want to actually come up with a traversal helps if you actually visualize the shape this in terms of nodes and edges. That means If you drew out a nice picture for this graph like so. And so we'll go through the rest diagram. Something important I want to bring common case we'll have to handle is what if true for your undirected graphs. And so just going to add an additional edge just so we to add one new edge from k to J. Cool. The length three highlighting in red right now. because if we don't do any special handling So imagine I started at this keynote, and and then back to k, and then back to J, and we'll have to guard against that. And so I and you can really have a cycle of basically one. So for example, if I took a look down technically like two separate islands, but right? So I've got the small island of O and If I started traversal, at o. From there, edge between o and n is bi directional writes back to O, and then back to n. And this would out for all types of cycles in this problem. are we given a graph, we're also going to an example where I want to return true or I'm going to mark those in my graph Israel. solve this one, you can use any type of traversal. step through explicitly the depth first traversal. traversals, I want to mark my nodes as visited situate myself at this source note of I, but implement this like marking a visited pattern. up later on, we're probably going to use a for now, I'll just check them off in my diagram. next to a node, that means that I already of I want to move to its neighbors, so I'm also be sure to check it off as visited. At let's say I move to k. And I'm also going can move to a few different neighbors, I could I chose I, I once I get to this, I know, I'm oh, I visited this node previously. So what Instead, I should go back to the K, right, And that's where I actually avoid the infinite other neighbors, let's say I chose the L. If I do a quick check, I can see that this So I must have just found a path between my if I find my destination, I can just return a previous problem, the only additional criteria way, we don't get trapped in an infinite loop. cycles in our graph, which if they don't give against. So let's take a look at another example. was Oh, just looking visually in the graph, get from k to O, because they're disconnected, through the algorithm regardless, so I'm going going to visit some of Ks neighbors. So I at this point, I would move back to K and Ks visited neighbors, so I don't move back neighbor, like l market is visited, then I be this m node. And at this point, I've actually nowhere else I can go. And once I finished node, then I can just return false, right? that exists from my source node to the destination Let's talk about the complexity. If we say that he is a number of edges. Like we said to do for our graph problems. I know that of the number of edges. And my space complexity nodes. I think it's worth stepping through, you know, big O refers to the worst case. we can have. And there are a few different of, I'll just show you one example. So let's Notice that although z is kind of on its own as well as a C note. They're all members of out is there a path between A and z. So if start at a then I move to B, and then to C, I've covered all of the edges in the graph. here, because I have to travel through every time complexity in the worst case is going and here we can say the space complexity is either a depth first stack, or a breadth first add everything you visited, or that is all why we say for regular graph traversal algorithms, complexity of O of n. All right, I think we pat. At this point, I want to join me in the see how to implement these visited patterns Alan here, right. Now let's go over a JavaScript So we'll jump right in, just like we said, a two parter. First, we're going to convert way, it's easier to do a classic traversal a helper function here. That gives me back I'm going to call this helper function, we'll of my edges, I want it to do that conversion right now. And then we'll jump back to undirected just going to take in the edges, right. And form of a plain old JavaScript object. So to return it by the end just like this. And information from the edges. So I'm going to of edges, so iterating, through every single So I'm just gonna de structure out of that, call them a and b, from the edge. Nice. What as keys of this graph object. So a would be right. So what I'll do is check if A is in we better if I check if it's not in the graph. what I can do is initialize it in the graph. empty array. And I'll do the same for B over the graph if they don't exist, and once I into their their edges, right? So I can say, now I'm saying that right, B should be a neighbor graph, right? So that should be symmetric. into the neighbors of B. So it's really important graph. So your adjacency list needs to be B should also be an A's neighbors. So that's how that graph looks just with a little little snippet, get that full snippet here, I could test these little helper functions before just see the adjacency list form of these pretty good. So I'm seeing that all right, looks correct based on these edges. Awesome. right. So if i and j are over here that I it should be a two way street. Alright, now would be some sort of traversal. Now that either a breadth first or a depth first traversal. Typically for me, it's just easier to raise to pretend I had a function called has path, a start node and an end node. So I want to I'm going to assume that this function returns that function for myself. So stay organized to take in the graph as well as node A and arguments as I'm doing this recursively. Let's So over time, we're going to call recursively be a familiar pattern to some other problems case. All right, I know that I've has successfully destination node, if that's the case in return I have to keep looking. So I should be able node. So I could say graph square brackets this recursion source represents my current let's say source was I, I'd be accessing all really iterates for let neighbor and, or rather first iteration neighbor would be j, second of my neighbors, I want to travel to them. argument the same needs to change your source and your destination is fixed, or you're always gonna think about what type this returns I True or false? Is there some path from my check. All right, if that call, returns true, a path. So just return that true, right, pass that we form here is, I know that by definition, So there's definitely a path between them. my neighbor has a path to the destination, to the destination. Awesome. And so after never find that any of our neighbors make for loop without ever returning true, which the case that this source node does not have go ahead and give this code a test run. If that there's something important missing from you how to fish here. So here I'm getting wrong, line 34 months ago, line 34 over here. anymore. That's on me. Let's get that test I am expecting some sort of an infinite loop, stack size exceeded. So I got like an infinite because we didn't account for the case where to avoid that. Because if I have a cycle in base cases, I'm just gonna keep traveling make sure you watch the approach video, right. some sort of data that shows where you've this for our graph problems is to track some to this house path, I know that that is the I'm going to pass along a new argument here. if you're unfamiliar with sets, and JavaScript, And what's really great about a set is in set. And I can also check for something within our traversal. I don't want to use something or a check within an array, that would actually of one. So I'm going to make a new argument to do is all right check if my source node JavaScript I can check visited out has. So set, then I could return false here, right, anymore. Because if it's an visited then I is how I can avoid an infinite recursion can And let's say that I make it through this this node source has not been visited. But visit a dot add source. So this expression adds source to the visited set. I want to that you pass along the same visited set through you want this visited set to be like global exactly where I've been in the past. And once we need to prevent any any cycles from giving a test run. Awesome. There's a solution for things to take away here do consider this really straightforward, just converting an actually an important skill to practice. Because you'll face in the wild, they are all going they'll give you the graph and like a different format that you're comfortable with. And from doing a traversal through a graph, but also to do that, we just use some sort of a visited now want to go over the approach for this this problem we want to do is take an adjacency always, with any graph problem, you want to so if you took a picture of this information, this structure. The first thing we should multiple connected components. So for example, just the one and two nodes, I can look at nodes. And finally, a third component just say that your result for your function here three different connected components. So let's the components, we know that a general counting we'll initialize that count variable to zero. of both some standard graph traversal code, code. So I'll do along the left hand side And what I'll do is start by iterating, through to do is when I'm currently at some note of traversal at that node. So right now starting first traversal, you can really implement breadth first. So let's say I start at the continue this traversal as far as possible, one node, I can move to a neighbor of two. I want to make sure that I mark things as things as visited will also ensure that we I hit that to note, I've actually completed I can explore. So at this point, I should a new traversal on some region of the graph, I now fall back to my iterative code on the next node. So I now look at node number two. that I already have it marked as visited. at that node. So effectively skip the two I have a three, three is unvisited right now. at this three node, which means I just mark node, right, it's not connected to anyone, just on the three node. At this point, I've by one. So now I have a total count of two, from the three node to the four node. And again means I must begin a traversal from traversal. Starting at four as far as I can, so I'm going to explore the six, explore this this eight. At this point, I've completed to three. And then I have to continue and the five node, I see that the five note is traversal. And I see that the six node, same note already visited, eight nodes already the entire algorithm. And there's my final here, right, you're going to need to definitely does a traversal through some component as code just to potentially begin a traversal want to do is be sure to mark nodes as visited marked a new node as visited and complete You're probably wondering the exact details don't worry, you'll realize that it's really in the walkthrough video, but for now, we a number of edges like usual, we know that entire graph. So we can say the time complexity of n, right, depending on whether you do a to use that space, then in terms of your stack space within our set if you use a set to mark will lead to a linear time and linear space this one up. I'll see you in the walkthrough now let's go over a JavaScript solution for so we'll implement exactly the strategy we sure you watch that first, we know that this are going to need our interactive code just And we also need some traversal code to just And so what I'll do here is let me start with at every potential node. So I can say for here, because for this problem we're given for let node in graph that would give me each for every node of the graph, what I want to assume I have a function here, I'll call it graph, as well as that node. And what I want a depth first traversal, from that node as to need to add more logic into this main function. flesh out explore. So I'll choose to do this explore, it's going to take in a graph, as current, right. And then from there, I want recursion is fine. And not much to do here, iterate through every neighbor of this node. I recall that graph would be an adjacency if current was a node like eight, then on next iteration neighbor would be five. So of my current node, I just need to not traverse the same graph, that doesn't change. But now just like that, and this will perform the But we need to also mark things as visited, a really important a part of the solution. for my entire traversal. So I'm gonna have here. So I can create my constant visited, sets off for me O of one lookup, and o of my reference until all of these calls over over here now. Now I want to actually start I definitely want to use visited to prevent we always had visited to our graph traversals. visited this node, so if visited, has this maybe just return false. Later on, we'll see. false, right, actually serves two purposes. And then I need to make sure that I pass as And let's say that we have a current node false. Well, then, it seems to be that we're add it into the visited set. Nice. And then explorer function is consistent in its type, do is it's going to return true whenever it you take a look at this code, for my function be the case that it has already finished exploring that this for loop does the job of exploring all of those neighbor calls returned. Will explored this component as far as possible. I can do is now in my main function, when me boolean data, right? If it's exploring to return true. So I can check. All right, component. So I can probably increment some say 11, counts equals zero, I'm going to increment plus equals one by the end, I should of course, is, for scenarios where we, let's say iterate I make this call, I know that that call is already explored, it would have been added return values for this recursive function. at this point, we might be ready to test this tricky codes, not very long. And this is a an error, we have something wrong here. So but I gave back seven. So I'm counting way is really just maybe print out my visited. want to bring in, I think this example, I sure to do is maybe at every iteration of, log with visited associate visited changes just hitting run. And let's see what we get some of our keys, or some of our items of And other times they're actually numbers, to do with, you know, kind of just JavaScript object are going to be always converted as over here is going to be number. And sets have like two different types, it's not gonna represent the same node. For example, looking the number one, as well as the string of one, all to maybe strings. So I'll check visited node. So I'll just do the conversion for me. of the current node over here. That way, I manually, again, should just see all of our all the test cases. So that's a really important JavaScript is pretty unique in that regard. keys into strings. Awesome. All right, programmers, count problem, what you want to do is really very common interview question. And there going to do in the future. Hey, programmers, approach we can use for this largest component take in a graph, just like we've been doing probably do is think of this graph as a picture. really understand what this is asking. Our list. So it's pretty easy to draw out. So thing I should notice is it could contain of see two separate islands, two separate of each respective component. So if I look 015, and eight, I know that they have a size of nodes within that component. So I'm really not necessarily the number of edges. If I nodes, two, three, and four, that definitely really cares about the largest component, the largest component size. So when it comes some familiar patterns if you've been following recommend that you do these problems in order. I know I'm gonna need some sort of iterative components or different islands, I can probably also finds the size of a connected component. run. On the side. I'm going to list out my iterations to be In a traversal at every node at node zero. And since node zero is unvisited traversal, starting at node zero. And I'm because like usual for our undirected graphs, that you may get trapped in. And I know that this full region as far as possible. And by to implement some pattern that can count every to treat each of these nodes as just being those ones are going to return to my top level getting me a grand total of four. If this like how the heck are we going to code up pattern we've seen before. And so I'll cover now, it's actually not a big deal to get the that the size of this component is four, what largest island or component I've seen so far, considered. At this point, I should fall back of one, what I should notice is this node So there's no reason to start another traversal means I have already explored the component skip it, go on to node two in my iteration, a new traversal. Over here, I know that this that component as far as possible, it's going one. And eventually some of those counts together, component has a size of three, I need to compare obviously, the four is bigger, so the four to my iterative code, I get to my note of to start anew. traversal, four is already And of course, eight is visited as well. At node within our graph, and we must have explored the final value that we have stored in that the complexity of this algorithm, it's pretty of the algorithms we've seen so far, we see of edges, we know that the time complexity edges really just exploring through the entire is also going to be linear, really just O going to be storing all of our nodes in a on how you implement your traversal algorithm, you're also going to use a linear amount of overall, we're looking at a very efficient, I'm ready to code this one up. What I want one a shot on your own first cluster, really the past. So give it a go on your own. If video. I'll see you there. Hey, programmers, solution for this largest component problem. a spin off of our last problem. So we'll hop watch the approach video first. And we'll us start a traversal on disconnected islands we should say. And so I'll start my iterating I just iterate through the keys of my input this graph as already an adjacency list. So give me the nodes like 015, and so on. And here, right? So we're going to pretend I had if I give it the graph information, as well hopefully, it actually does a traversal through what I'm going to assume is, let me assume of that entire component. So that would be nodes in that component. And so if I have And I know I need some like max value logic create longest, initialize it to zero. And the size of the component I just found, if the longest simply longest equals size, that the longest course I need to write this explore type of depth first. So I'm going to make as well as our current node. And a few things that we have an undirected graph. And so we So we're also set up here is some classic we're going to use a set because it gives So now that I have my visited set, I can pass let's work on a base case, as well do to get So if the visited set already has this current a recursive call. But I also want a consistent function gives back a number representing I get to a node that has already been visited, treat it as zero right now, because I don't would be inaccurate here. And now beyond that, I'll call it size, I'm going to set that equal right now, right? If this condition is not this node, so I need to count it. And we'll way I don't get into a cycle into the node to make my recursive call on the neighbors say for let neighbor of graph of node. So was a key, like five, when I say, Neighbor the neighbors a five, zero, and then eight, calls, I'm gonna call the same function explore you're situated at your neighbor, and you where I do my recursive leap of faith, right, function is working. So if it was working, back a number representing the size of that whatever number I get back here, I just want would accumulate a basically a count of all And after I'm done exploring my neighbors, fully. So I can just return my final answer, important thing you need to do is make sure your size equal to one, and you add to it current node that I'm at, I know that every time, this will actually accumulate everything visited logic. And we already wrote our main up this code in a nice little helper function this, it's very similar to some previous problems let's go ahead and give this a shot. See, a few different test cases. Nice. And there, So a few things, I want to draw your eye to you have disconnected components, you're going some just iterative mechanism, usually just components, right? Because if you only had there is no edge between separate components. full graph. Otherwise, alright, programmers one. Hey, programmers, Alvin here, right. the shortest path problem. So here we have to be given as an edge list. So the first visualize this graph. And in the context of convert it into an adjacency list. Since we've problems. I'll leave that part to you. But like this. And in this problem, we're also say W and z, what I want to do is return the here I have two obvious paths, right? One x and y. And there I can see that that path going to consider the path link as the number of nodes, right? So that means how do I calculate right, three edges. That's one way to get to z would be to go through VI, which case, path line is of course two. And this problem, path length. So I should return the final is going to require us to do a graph pathfinding we take, we either can choose, of course, traversal, I'll cut to the chase here. And that works, meaning you can solve this with But maybe one of these algorithms would be possibilities. So let's say I had some large kind of just looking at an abstract example. depth first traversal. Let me say I have my target node in blue. So what I want to do distance between these two nodes, obviously, get an answer like two here, right, because these two nodes. If we did a depth first traversal, look in one direction as far as possible, So for my starting on yellow, let's say we move to the right again, two edges move to I can't move right anymore. So let's say you again, seven, eight. And at this point, we end up possibly getting to the blue target Something unfortunate here is although my a depth first traversal could be unlucky in and snake all the way through the graph until point I definitely don't have the shortest is going to be more useful here. So let's starting point. And if I did a breadth first I'm going to explore all the directions very explore all nodes one edge away from my starting to explore all nodes two edges away from my to hit my target node. And if it's the first I must have just found the shortest path, So that's my high level argument for why a in my opinion, for this problem, let's step So let's say I had my original graph. And I know that I have to use a queue right no breadth first order. And what I'll do is eyes not only the nodes, but also the distance to initialize my starting note on the queue represents the fact that all right, that note point, because it itself is the starting point. are always going to be pairs, right of node our general algorithm, I'm going to keep iterating. of breathless would remove the front end of node. At this point, I should check Alright, for? It's not, so I need to explore W's neighbors. need to add it into my queue. But when I add it with a distance. So if my current node node would have distance one, so I just increment I put an item that says x comma one. And I also a neighbor of W. And so I put v comma can go to my next iteration, or move the front I look at X's neighbors do bear in mind that really has two neighbors, right, it has w you should already know is I need to track consider its neighbors, it should really only put w back on the queue, because then I would at the Y over here. I'm going to add it to X has a distance of one y must have a distance by one. Cool. And then I carry on with this now, which would be the V note. And at this do See that one of its neighbors is actually I'm going to be sure to add z into my queue because if my v has distance one, its neighbor point, you can already see how this algorithm going to leave the queue, and that would actually into the queue that matches my target, I know represent the number of edges we took in that return that too. So for the most part, this first traversal. Using a queue on a graph, going to track the current distance. You know, path, you need some counting mechanism. And node with a distance of zero, every time something should increment that distance by one. And pretty efficient, because we don't have to So we'll see that this has a linear complexity. to code up this one, I'm sure you're wondering you want to do is possibly give this implementation you can find me in those walkthrough videos. right. Now let's go over a JavaScript solution right in, hopefully, you watch the approach edge list input into something more useful we're going to write a very classic function. it takes in the edges. And I want it to return object, I'll call it graph, by the end of return the graph and some common code, I'm basically every edge, I'll say, for left edge edge, when I want to do is unpack that edge b. And now I can start formatting my adjacency to be obviously the nodes, I want the values So what I'll do is, it's the first time encountering if it's not in the graph yet as a key, then use it as a key and initialize its value to going to have no neighbors. Likewise for B. B now definitely exist as keys within the So if I have an edge, like w comma x, I know of x. So simply put in say, graph a dot push be good to go. Cool. So that should give us our main function now. So we'll just say graph we want to do now is actually work in our approach video. So a few things I'm going we said that the key to victory here was to for every like frame inside of your queue just use like a pair of things. So the elements And I'll throw on the initial node A, and right, this node A is zero edges away from I'm going to be incrementing. This number, on here. All right, a while loop, classic is not empty, then I shall remove something front if you want to follow a true breadth that will give me back an array or give me it's always going to be a pair so I can just current node as well as the distance. Nice. removed from the queue. If that node is node I know the distance in that path, I can just then I need to keep searching through my graph. neighbors to the back of the queue. So I'm lists the entire time. So I'm going to say, So get all the neighbors of this node. And my queue. So q dot push, neighbor, try to here. Maybe as a quick little spot check, dot log, the adjacency lists, let's say we down below. And I'll just give it nice little quite yet. So we converted this edge list we say no to something like W, when we say us this array, co authored sorters, iterating, adding them to the queue, one thing we should onto the queue, we want to maintain the same pairs. So I'll make the first element of the needs to be the distance. And since it's a here. So that's how I'm growing and counting There are a few things we need to work on examples, at least until we timeout on a particular any cycle prevention, right? I know that it's I have an undirected graph, right. And so set, sort of pattern that you're used to, breathless right now. So start out with a move would be to make sure that if something as visited. So if I initialize my queue with visited set with node A, just like so. So in JavaScript, if you want to initialize it in an array containing those values. So the be the nodes write the node IDs. Cool. And loop. And so whenever I'm about to add something a neighbor into the queue, first check if if not visited has neighbor. Right, so only then I should add it to my queue. And if I'm said anything that interest, the queue should I'll say visited, add, the neighbor net should once into the queue, avoiding any cycles. give that a test run. Now. We hope to not actually returning undefined where we expect prompt, they tell us that, alright, if you should return negative one. Let's look at it out, you would see that there would be we're returning undefined right now is we're queue is going to empty out. And then we're And if I don't hit a return line by default So we know if we finish the while loop, and negative one, that must mean that there is give this a test run. Now. This should be Awesome. So be sure to practice this algorithm you understand the choice of breadth first just graph problems that require you to calculate of edges. Typically, you'll find breadth first Alvin here, right now let's go over to the in this problem, we're going to be given a here we have l characters representing land, try to visualize this. In this problem we the number of islands on the grid. We're going connected region of land. So in this particular are four different islands, we can label them for us. And we should really think about it to these style problems as a grid graph. And nodes and edges, I can still think about positions consider the indices here. So I have my row indices along the top. And I can designate row and column. So for example, if I looked this position over here. And what I should it's a node. And if I met some node, I do of the spread, I have at most four neighbors given any position of the grid, it's really are, it's really just a matter of adding or column. Let's generalize this formula. So it our see, if I want it to go upward, that keep the column the same. If you went down, if you went to the right, that would be increasing then you should just decrease the column by of our grid is going to be 00. And that's So now that we're starting to frame this grid common patterns, I know that this problem connected components or the number of islands code, probably some nested loops to just iterate traversal at that island. So when it comes loops to iterate through every row column. like this, just moving left to right. until next row. Let's actually iron out the main say we start or nested loops from the very what I want to do is check if my current position continue. On the next iteration, I do have of land, right now, what I want to do is explore using some depth first traversal. And do bear problems, we're going to need to be sure to in any infinite cycles. So for example, if can go downward. But I can also go upward two going up and down, giving me an infinite of our graph mechanics, right, just use a starting at this position, I know I'm going And what I also want to do is make sure that that I've just explored some new island fully. finished exploring something now my count to my iterative code to scan for another island. water continue. Now I have another island. through it. And of course I increment my count. when I hit the new row, I could be at a land this land position is unexplored, right. So this land has already been explored, I don't I also don't need to begin a traversal here. Wherever I have a visited piece of land, we island like this one, where I have a piece that's my criteria for starting a new depth my count, and continue business as usual until And so I visit it and increment my count. have my final count of four. So that logic variation of our classic connected component, the criteria we use for looking at neighbors, just be either above downward to the left talked about the complexity of this algorithm, the fact that it has two dimensions, right? C is a number of columns, well and the iterative going to give me r times C iterations. And first traversal I do starting at some land. Island, which is also going to be our time going to be our time See, the space complexity imagine that we mark all of these positions to add them to some set. Right, so we have end, I could add each and every one of them See also includes any traversal related data on how you implement this one. So overall, to solve this one, what you should do is probably stuck, you can find me in the walkthrough Alvin here, right now, let's go over a JavaScript So as always, make sure you watch the approach know that this is really just a spin off of except now we have a grid graph, right? I it's a graph, because if I think about any have some neighboring positions that I can down, left and right for me, let me start begin a traversal at every node or every position different islands, right. So I'm going to iterate through every possible row column equals zero, iterate up to the length of the one, and do something very similar for my some details here though, looking at the examples, get a square shaped grid square meaning like number of columns, because sometimes I'll right? If I look at this very first one, it but the height is six. So separately for the over here. So we're gonna say grid, zero length. composition, I want to begin a traversal, position. So here's where I invoke some like bit, I'll call it explore. And what's going as well as the row column I want to traverse actually hop to building this this helper some more logic within our main driver function So taking the grid and your row column, and I know that this is really a type of graph cycles, right? So consider this, let's say let's say I was at this piece of land, I know through its right neighbor. And it could be its left neighbor, so I go left and then right infinite loop, right. So whenever you have connections, then always guard with a visited up top globally, for the entire traversal, just a new set, you're probably wondering, of this set? Well, I need to designate positions, like the nodes in this grid in this graph, visit set, so I can accept it as an org over set, what you want to do is make sure you they designate your actual position. I think more of like a language thing in JavaScript, quick aside over here, let me get myself some unfamiliar with sets, and you don't kind of in the butt later on. So let's say I had a and let's say I added I don't know, like an I'm gonna say is, alright, maybe I had position, that into my set. So I do s dot add that position. If you put any like reference types, like it's actually going to check for reference on. In other words, now I can't really do this array literal is technically a different true back in this scenario, but I'm not going see what we get. So like, we say, we're gonna instead, your Fix would be to actually convert write as if you had one comma three, because be able to store that string. So whenever give me a match now, so I should get a nice pattern to our advantage. And so maybe I'll that's going to be like the string of FIDE row, maybe add a comma, and also put the column separate is, I need to have different bounds I had a row of let's say, 12. And I had a or a position, that would give me position let's say I had row one, and then column 24, one comma 24. Right, it's really important and column positions, because imagine, I didn't here, I have two totally distinct positions, a comma, they look like they have the same separate them. Common gotcha there. But now my advantage in this visited set. So if I've has this position, then I should exit, right, explorer function do something similar, like I want it to return a Boolean indicating whether So if it's visited already, that's definitely it's not a new island. If I make it past this is not in visited, that I need to mark it add this position. So now I have my core like a few other scenarios, we know that in our like neighbors. And so what I want to do is going to check, like to split this up into called row in bounds. And I'll do is just row. And that row is strictly less than will to see if my opposition is in bounds here, with zero because zero is a totally valid the length because imagine I had a grid with So I need to be strictly less than here. And in bounds, just like this. And at this point, all right, if your row is not in bounds, or So return like before I can return false, an invalid position and a balanced position Final base case I need though is, what if want to do my traversal through land. And up here, I can check. All right, if my grid also return false. No reason to count it, bounds check before you index into your grid, were out of bounds. If you write line 15 like out of bounds error. So start with your guard to because most of these conditionals they You can probably or them together. Typically remember to write them typically for like code. Alright, so if I make it past all of case, so I must be at an unvisited piece of first traversal, right. So here's where I If I wanted to go above that I decrement, along the same visited, because remember, is row zero, this is row one. So we'll lower lower column numbers mean to the left. So one over here, that would be to the left, right. Cool, and I can keep this code very of when you write recursion, for the most look before I leap. In other words, just from that row minus one is out of bounds. But that's I evaluate this call, it's going to immediately I express my logic like this, if I don't look, myself with the base case, you don't have some people write code like this, where it's of using pseudocode. Here, they would have have to write a guarding if statement around one base case. And you can catch all of these why I prefer it this way. And so I know that calls, I'm back at this segment of my code. must be finished with that traversal. And that I've just finished exploring a brand also consistent with the data type, I have the most part, this looks like really just first code. And now I want to use that boolean I can actually count my islands. So guess some counts equal to zero. And whenever you if I just have found a new island, we're going Because remember that I'm beginning a traversal, it gives me back true, then I can totally I begin a traversal on a position I've seen before. So I would return via this if statement then I don't double count that island. So code to potentially leap to different islands. from double counting any particular Island. forget to of course, return our counts at probably be the first in a series of these how we can think about still a grid as if rules for how we look at our neighbors. Right? are its four neighbors Up, down, left and practice this pattern because we're going it to you see in the next one. Hey, programmers for this minimum Island problem. So we're water inland really just some characters inside visualize this. And what I want to do in this minimum Island size, we're going to consider or horizontally connected pieces of land. be to looking at our grid, I have three separate right? sizes, a four, two and five, I just would be the two over here. So how can I actually should already know that this is just a spin where instead of doing just a count of the sizes of islands. I know to actually look nested code, but I'm also gonna need some Island. So overall, this should be a pretty attacking this we know we're going to begin if our current position is water, then we I have some land. At this point, I could begin I should be marking things as visited to avoid this traversal completes, I'm going to mark to determine the size of this entire island is land, I should treat it as one. And then I can just gather up these ones, right, just like this. And for my top level call for that four. And so if that kind of traversal algorithm, island, is pretty hand wavy, don't worry that it's just a matter of some recursion, and in past problems of the course. But any case, it's actually the first island that I've seen. so far. But I need to keep looking in case So if it's water, I do nothing, water again, begin my traversal market these as visited. course, it's going to give me two, I compare so I store two as the mid size so far. And when we get to a piece of land, we really a piece of unvisited land. So right now on should not wear I don't need to start traversal I'm going to hit some new unvisited land, at Explorer, this region, and I want to count realize that the final size of this island my current min, five is bigger, so the size returning the minimum size by the end of this of size two, the complexity of this algorithm size of our input is r times C, because we a time complexity is simply our time C, right, within the grid. And even when we begin a an island that spans the entire grid, in which our full complexities are time c space complexities is technically a linear solution in the size is exactly r times C positions. So with that, try it on your own first. And if you get stuck, See you there. Hey, programmers, Alvin here, for this minimum Island problem. So we'll video. As always, this is just a nice spin for a grid graph, right. And so let's start a traversal. Starting at every different position loops. So start by iterating through all of up to while r is less than length of the grid, loop for my column. But do make sure that you could have like a rectangular shaped grid a traversal starting at every row column. here that does that traversal, I'm going to long run, I'm interested in the size of that how big or how many positions that island information as well as the position. And I graph, traversals should probably guard against So I'm going to pass along a nice visited entire traversal because there's only a good I'll create const visited gonna make it my that. Well, for one JavaScript set, gives So it's going to be a really quick data structure add some more logic over here to actually think I'm going to switch gears and actually right. So I think the best way to build this just my go to for problem like this, it's in the column and also visited, I need some going to start by checking if this row column for that is to split up in some variables I'm going to say is my row inbounds and just check if, let's say, zero is less than or and that row should be strictly less than be true if it's in bounds, right? And something between zero and grid zero length. Nice just a nice if statement using both clauses. So is not in balance, or your column is not in So you should probably use some base case here is zero, because I want to keep a consistent is, I know that this function has a kind of islands sizes a number. So even in my base of number, returning zero to represent that, to contribute anything into the count of the other base case here. What if my position I don't want to count that as well. I only fix, what I'll do is add a new base case, equal to the water character. So a capital you can also maybe merge these into like a ORS, I kind of like them separate because of them does write a final conditional have these base cases, it might be the case that already visited. So here's why I work in my like we said in the last episode as really of my visited set. So I'm going to say position column. So just representing the position, a visited set, and then look it up later. a duplicate position that I've explored. So yet. So I must be visiting it right now. So laid down. Now I'll need my actual recursive now you should be familiar with this pattern. on the same visited. So I'm going to explore And I do my recursively buffet theory, right. they're going to give me back a number representing a part of. But if my neighbor is part of some connected right to our neighbors. And so I return values. So I'm going to create some to initialize it to one over here, it's going my current position, my row column. And whatever going to increment my size by that number, size over here. So that will do my depth first also tally up the size of this island region. size helper, let's use it in our main function this call. I'll call it my respective size. have a Island or position I've already seen for loop, then I would just return early because has already been visited, just automatically it, no reason to consider it again. But now the size of the smallest Island. And they assume that your grid contains at least one is to use positive infinity so I can set some infinity, JavaScript, if I make it positive valid Island size, it's going to be less than I can do some min logic here and check. All than the minimum size I have seen so far, island. Then after I'm done with all of these my mid size. So some classic patterns here. how to run the code, and we can debug it together. the very first example we expected to answer look at that first example, it's pretty obvious this island over here. The reason we're giving see we're on like the very first iteration, going to be zero column is going to be zero, here. When I make the recursive call, and going to immediately return zero because that Alright, is that zero, less than infinity zero. But if I think about it, zero doesn't has a size of zero, then it's not an island so I want to add some additional logic here So only do the comparison if that size is zero, of course. And we'll want to add these little, little detail over there that we need. this minimum Island problem. So we've seen island hopping logic. So when you think about graph, this should be your first kind of go wraps up our course on graphs. I hope you had a blast making it Be sure to head to Shruti more graph problems, as well as explore any see you there.