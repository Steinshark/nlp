==In this video, we'll talk about the most you're just getting started, most likely strategy. Not only does it allow you which is very important, but you can we'll talk about the 'recreate' strategy and you work in a large organization, you'll want to we frequently use blue-green deployments. we can easily switch back to the old deployment. is to use a canary deployment. With a blue-green to the new deployment and hope that we don't shift only a small percentage of the traffic we can gradually shift more and more traffic until strategies, you can use native Kubernetes objects will provide real-world examples that you can to automate all these deployment strategies with and Flagger. You can find the source code and we'll cover more advanced deployment strategies start with the default rollingUpdate deployment of deployments since it allows you to upgrade without downtime. If you don't configure the you'll get these default settings: 'Type: rolling 25%.' So, what does this mean? Well, a rolling old pods with new ones. maxUnavailable specifies default is 25%, which implies that up to 25% of have 4 pods, only 1 pod can be down at a time. If time. Next is maxSurge, which is also set to many additional pods can be created over the total number of pods at any given time cannot only 1 can be created over the desired size. If created. You can use percentages relative to For instance, if you want a very slow deployment, and only 1 pod can be created above the desired safe rollout strategy. It's also important to the rollout to successfully upgrade your explaining all the different types of health do a demo. If you want to follow along, you can specify the Docker driver. Next, run 'kubectl you can use the watch command to refresh it This is our deployment that uses the default replicas. I added a startup probe just to simulate image, which is compiled for both ARM and AMD test the version during the upgrade. Next, apply Due to the startup probe, it takes 20 seconds let's spin up a pod based on the Alpine It has curl that we can use to hit our sleep for 1 second after each try. Right now, we Let's update the deployment to the v2 version. that we have 2 new pods with the v2 version, and based on the maxUnavailable setting, we have 3 upgrade, curl can get stuck with a timeout, version. Alright, we're getting replies from the Kubernetes will complete the upgrade. I want let's update the rollingUpdate settings and use This will give us some time to play with the deployment object. Now, kubectl has a rollout It can be combined with deployments, statefulsets, the upgrade, restart, resume, and even undo to in practice. As always, let's update the version Now, if you simply get the deployments, you'll see pods and 9 pods are available for this deployment. same information but in a human-readable format. Let's say that during the upgrade we discovered a stop the upgrade. For that, you can use the upgrade, and we still have 2 running versions of we decide to complete the upgrade. For that, we upgrade and roll out the new v2 version to all testing this new version in production and finally app to the previous version, we can use the roll out our previous v1 version. In practice, I downgrade the app, I would create a new commit rest. But these built-in Kubernetes capabilities building a Kubernetes operator and can leverage Another useful command is 'restart', which I to restart and shift all the traffic to the new The next type of deployment is 'recreate'. downtime. No matter how many pods you have under all of them will be immediately terminated and is frequently used in development, when you don't a bug with a rolling upgrade, your deployment can with 'recreate', every time you build a new image, Another use case, potentially in development, you have a single node that can run a single your new pod will get stuck in a pending state With 'recreate', it will terminate that pod first think of is when you run a deployment and attach means you can attach the volume to only a single create a new pod first and try to attach the because it can only attach it to a single pod. A Now, let's quickly go over the 'recreate' object with the same image. But in this case, Let's go ahead and apply it. It also takes about the startup probe. Let's update version v1 to can see that Kubernetes immediately terminates a new set of pods with the v2 version. Like I useful in some cases. Now, in large companies, we in production. One way to minimize the risks is simply mean different versions or configurations. black-white; the terminology does not matter. Most the 'blue' could currently be serving real another one, the 'green', on standby, or vice if it's possible, you could ask your QA team version. Also, if you have automated tests, you the new 'green' version is good, we can switch you how to use native Kubernetes objects. For such as 'replica'. When we're ready to switch, green, and all traffic goes to the new deployment. time, which could be a matter of minutes, hours, deployment, we can easily switch back to if we're confident enough in the new version, we blue-green deployment is if you need to evenly If you do a rolling update, the first two and the last one will get zero, at least at the deployment, the devices in this case will connect how to perform blue-green deployment using native with two replicas, using the v1 version. This another green deployment. We also have 2 replicas new v2 version. Most importantly, each pod should this should be set to &quot;green&quot;. And, obviously, also have a service, which serves as a gateway to from the old v1 deployment. Optionally, you can to your QA team for functionality testing. In the the default namespace. In the bottom window, we'll If you immediately retrieve the endpoints, you'll the pods are not ready. If you wait until they are addresses, both of which come from the blue pods. blue pods, which is precisely what we want. You By running a curl in the loop, you should Performing a blue-green deployment is as to &quot;green&quot; in our service. Then, Kubernetes traffic to the new green deployment. Even if that ingress will redirect your traffic to and apply these changes. You'll immediately see response. That covers the basics. Up next, we we'll go through the Flagger demo. However, since to install Istio, Prometheus, Grafana, Flagger, a step-by-step installation and provide a of how all these components work together. wait for the following video. First, we need a we have a deployment, and we also need the Istio And the canary custom resource provided by the just a subset of canary. You'll see it later. we want Istio. We also need to select the and metrics section. Finally, we use a webhook the progress, you can follow the Flagger logs. Flagger folder. When you apply, Kubernetes Flagger notices the deployment and creates a active deployment. After Flagger initializes You can check the Canary custome resource. transitions to the initialized state. from the Flagger logs. Alright, and we are ready for the blue-green deployment. But before we apply, let's Run curl, but this time it's in the staging Flagger will create a new green deployment and In the logs, you'll see that it needs to go this deployment as healthy and switches where you can monitor the success rate. Flagger marks it as healthy. Flagger will shift traffic and terminate you can see the v2 version in the response. In the Next is a canary deployment. It's also one of we need to prepare a deployment and start slowly testing. So, if we discover a bug during the us minimize the affected users. However, if the version to more clients until we reach 100%. and service. Then, I'll show you If you decide to use native we would need to adjust the replica count to Let's set it to 10 replicas for now. without any additional selectors. Let's Then, apply the deployment and service objects. Now, we have 10 pods running. To start shifting we need to create another deployment pods for the v1 version and 1 pod for To shift more traffic, simply increase the number if we want to shift 50% of the traffic to the Also, we can scale down the v1 upgrade. To gradually shift traffic, we which isn't very convenient. Istio allows us to The next approach will involve Flagger and deployment. In this case, we just we might start slowly with 5% and move to 50%, we completely roll out the new version Let's proceed and apply it. First, we need to wait until Flagger initializes Then, we can update the deployment you can also monitor the logs. Flagger will then gradually start to after which it will terminate the I'll go step by step and explain each parameter deployment using Flagger. Thank you for