Herb Sutter: Hey have you enjoyed the week right. This half of the room, have you enjoyed I don't know. They might have had an extra Thank you. and also a really festival atmosphere here. and it's been a blast. We're now at our final speaker whose name happens to also be Herb. Hi. My name is Herb. You're supposed to say, Audience: Hi, Herb. Herb Sutter: It has been 1 year, 3 months Today, I want to talk about the importance would happen to me. I was introduced to complexity friend. He showed me a cool programming trick really worked on his compiler. I started using and only at home, but after a while as I got happened that the thrill faded. It didn't even though other people around me told me I started hanging out with people after work then it started eating into work time that checking it in. Some of you were at the template a picture. about complexity is people who are under the thinking more lucidly and really that's not we should remember that it's fine in moderation. C++, it's really hard to forget that you're hard to get number people who include, use million for some time and it's gradually, a bit now, but compare that to many of the How many of you use new GNU, GCC? Lots. Great. libstdc++, which has been around for quite I asked some of the maintainers, &quot;How many &quot;Well-known open source project everybody projects, how many people really have contributed have contributed something significant to in the last roughly 20 years. Xcode that's also Clang so put up your hand. of this standard library that ships with Clang, 2. They were both here at this week. One is in the audience. The answer now is about five a couple of lines, have contributed something I was not able to get a number of boost developers I figure somewhere in the order of say 300, be generous. I saw WG21 meeting attenders I didn't actually go through all the minutes more than 300 people. in the world and the smaller circle is all boost developers and anyone who's attended put a border, a line around that circle, you had to turn off the line around the circle By the way, can you see it? while still teaching the advanced tools for advanced code, but, A, not everyone needs it needs to use it all the time. That's a to Bjarne Stroustrup's wonderful keynote on slides know how many double ampersands rvalue number. The value of simple usable defaults By the way, I mentioned this on the panel you should go out and buy it at the bookstore We have lot ... I know ... I saw ... You stole out.&quot; I know so, but the good news is that will order it and ship it to you because they anyway or Amazon or anywhere. In particular, in one place what every C++ programmer should Now, that's really important. If somebody's C++ after you used C++98 they often ask, &quot;Well, to know?&quot; &quot;Well, look over here on Stack Overflow 00:06:33] longer book and there's some chapters -pages that some of you will have time to cover to cover that tells you the stuff that this book. Let people know. Help get the word that Bjarne has made that available. basic styles, and idioms. Now some experts the word default some experts treat it as the language.&quot; No. I'm not. A default is not mean, &quot;Oh, just do this blindly and don't You should know your other options too, but good reason to do something else, which does do this, unless you have a reason to do something in line with the general good advice including which are the titles of three of the first but not coincidentally right for clarity and In particular, prefer clear code over optimal Now, that's almost swearing to a C++ audience. you shouldn't. You should have good performance C++ has been about writing optimal code by not. C++ has always been about writing efficient efficient, but good efficiency code by default take control over memory layouts, over the get done, when you need to, you don't always This talk is not about don't think, it's about, We revel in complexity. How many of you, we're of your friends here will tell you. How many has described to me at least point in my coding hands up. That's good. This is good. We're to deal with it. We overcome denial, step Let's talk about range-based for loops. We that everything I want to say about range-based and here it is. Why do this when you can do be saying, &quot;Oh, shouldn't I be writing autorefref a bit more about refref at the end, but this C is constant or not this does the right thing the iterators. If you get a concentrator back the right thing. It'll be read-only for a If you are traversing every element of a collection Now, if you need early break, range for doesn't a range proposal coming for the November meeting even enable that. Certainly, if you're writing collection just write range for with autoref thanks to Stefan [inaudible 00:10:25]. Stefan, Okay. If I see one more code example checked e:c is going to be a shorthand that the Standards some compilers, once this committee will bless will already start implementing. You don't that basically says, &quot;You know what? We're it will be of type deduce whatever so the The nice thing about this is the first thing Isn't that a breaking change?&quot; How many of change that can change the meaning of valid scared. me, &quot;No. No. You can't actually write that you always have to declare a new one.&quot; We'll default will be essentially the same as before, thing. This does not mean that you can't lift a certain type or even write the naked iterator more like break partway through or skip elements. You are often influencers of people in your Stack Overflow, who participate in the community of the screen up, not the other way around. smart pointers effectively, but I still want and references. They're great. Yeah. Stunned all pointers and references. Well, why would write those. Those should be your default Let's talk about that. Now, clearly, the code that was perfectly good code in books some anymore. In fact, basically, all the red stuff Don't use owning pointers. Don't use explicit real performance need, encapsulated down deep maybe, but FYI, I believe even the entire using unique pointer. I'm not using new and We're about to try that, and so, that exception think because unique pointer is roughly free. at all over a raw pointer. Modern C++ says use make_unique. If you want to write new by default. you know the object is going to be shared you don't know, you're creating an object going to be shared, start with make_unique pointer that then can be used as a shared to be shared, use make_shared. advice we're giving people. How many of you today, at least, for new code? Looks like to follow this advice and still found some smart pointers? A few. I have a slide for a cure. Wait a few slides. says don't use owning raw pointers and references. you should be calling delete [inaudible 00:14:46] are awesome, keep writing them especially talk about structured lifetimes where one entirely within the scope of the caller because that the calling function is keeping alive Now, there is a reentrancy case. We'll talk Russian dolls all the way down where the lifetimes down to call stack unless you're going to don't need to talk about ownership. if you need to look at a widget and it say, const. We'll come to that later. Pass it by pointer. Are you ready for the modern C++ Now, if you have a unique pointer, a shared call get to pass a raw reference or a raw the win. They still are the preferred parameter convinced about that and you feel uncomfortable talking about ownership transfer, in which and I'll show that in just a second. going to participate in the ownership somehow, on earth does the callee care if you're managing pointer, whether it's global, whether it's and this is how to write that, very simple, But antipatterns hurt pain pain as STL would like this.&quot; It's viral. The antipattern here pointer even by reference. This is not just pointers or any kind of reference counted it by value, which is even worse if you don't to participate in the ownership somehow because performance of the lower-left code? on every call, which isn't the end of the there's synchronization, and it's not that Premature pessimization is when you have two is really simpler than the other. Well, you for something that is actually a little more is look at the widget, pass a reference, or A related antipattern besides passing function make copies of smart pointers and loops and things. For example, Andrei, when I was discussing that in late 2013, Facebook had an experience was passing shared-ptr by value quite a bit. reference, and observed a 4x speed improvement of their benchmarks, and other improvements asking for needless work, we'll pay for needless I wrote a [inaudible 00:18:38] the week about as well as unique pointer. Any owning pointer Only use it as a parameter type if you actually to participate in it. The callee is going registry or something so he's going to participate, counted smart pointer, but we have shared How do we pass smart pointers? If you are especially an object that's polymorphic so it's polymorphic in particular then prefer show if you know if it's going to be shared, make_shared, that's in the second half of return a unique pointer. Why? is needed like shared pointer, anybody who if they ignore the return type, it doesn't fall off the floor, it gets correctly cleaned if they're not going to look at it, but whatever, else that is a temporary expression and cleanup they can move it into that. If they have their are using in their shop that's non-standard get and move it into that. Similarly, if we're accepting, our function by unique pointer by value that shows that that with a unique pointer in the caller without ownership in. We'll come back to that one. not about changing the widgets. It's about to point to a different object. Well, that's I have no idea why you would ever legitimately why would you want to simply just look at you can do to a unique pointer except get returned, you just taken widget ref. As far is a think [inaudible 00:21:03]. is going to be shared that a factory returns going to use make_shared inside because that location instead of two and some better locality going to have a function that takes a copy by value. copy either I'm going to put it in some other and this will retain a reference count. If make it point to something else, pass it by receipt the shared pointer, and finally, if Sometimes you're going to keep a copy sometimes you take a copy then copy inside if you do to incur the cost of the reference count bump a copy so that's if you conditionally keep How many of you are thinking, &quot;Hey, wait a pointer refref?&quot; I'm curious how many people you later. How to do it right? By value prefer, unless you actually mean and references. They're still great. Express but shared pointer if you're going to share I post these slides will be available after to obscure it on top so when you print it you to print out the version two slides from I promise to tell you the pitfall with reference that if you've been using reference counted into. I know that most teams of any significant that especially that go over a boundary, and find they drop a reference count like, &quot;What's This is not unique to shared pointer, it happens reference counted pointer you might use. If with those. They're slightly different with an arch, but this principle applies in general. as a community we now know exactly how to First here's the problem. Take a second to be a problematic caller. We have some shared or it's aliased on the stack, non-stack or to a widget. by reference then call some other function to me. Oh, by the way, function g happens Maybe it's got a reference to it that's passed globally visible thing on the heap that it it, and now, in your code, if you happen to the advice I just gave you to just pass raw You're following the advice I gave you, and wrong with this code? Shout it out. [crosstalk the last reference count on the smart pointer, but if it does release the last reference actually blowing away my w object. This is but that's not obvious. That is so not obvious. there anymore. Might be the stored memory is wrong in the code? Like who do you blame? shared pointer. That should no longer pass I mean and what to write instead. want a shared pointer that's ... You can dereference problem if it's on the stack and nobody else You haven't effectively made [inaudible 00:26:04] pointer. immune to this. Why? Because you say, &quot;Before of functions deep, just once, at the top, owned by a shared pointer to passing it in it to a reference. Only there take my extra then, for the whole tree. testing for this to make sure that you only pointers, and if you do that, you will eliminate only cost you the extra add ref or the extra need it and it's an easy pattern to follow. also get a pointer and one easy way to do same thing realized there you are also converting Just in case, the member function is re-entrant object itself that you're executing the member follow this simple advice, this one simple link bait. I'll tell you the answer and you of the screen. Now, here's the summary of one green line. Remember take the unaliased the direct reference, direct dereference of That's reference counting. Write make unique of new and delete. Don't use owning pointers pointers references are ideal on function stack. They're structured case, the scoped wonderfully efficient and good for you just The only time you actually want to copy or any smart pointer is if you actually want to modify the lifetime semantics do it there. letters. How many of you have had one or more about auto? you can tell everybody else that they're wrong. ... Like even we're all going to agree, but why I'm offering the guidance, and then, it's you'll follow it yourself, but it's guidance from pitfalls. Therefore, it makes sure code is part of a broader shift in the syntax and move to a regular simpler style. That wasn't one of the options and, oh, it to the Scott Myers [inaudible 00:29:40] site write-in response, but, no, you couldn't. who has played that character on Spinal Tap. that hard. In fact, if you get Scott's book, roughly what I'm about to say. Some of the I'm about to say about using auto. declaring a local variable, this is all about you want the type to track, and I'll give it and the easiest way to do that is to have there will be times when you want to have The advice is not to use, just deduce everywhere, because auto does not always mean deduce. auto and still explicitly ask for a type. say, &quot;Well, why would I do that instead of but I hope to convince you there are at least grounds, but also on correctness grounds the you want to make a type track, which makes it, you'd be guaranteed don't get conversions do say it, but you can still use auto. What would you name the function? Anybody again. Add another. Hey, that's a good one. that's even better. Add if not there. Anyone How about append unique? We've got a container, I'm just trying to use the STL style because, value. There's a container, a value. We do find returns end, it wasn't there, and we we assert it's not empty because that's just We'll come back to this code very quickly. why you shouldn't deduce the type. This isn't I don't like type deduction. It scares me.&quot; of, at least, the ones you hear the most often. I worry.&quot; not saying it's not. Most of the time that's what is the type of something?&quot; Well, first argument because it doesn't really matter, doesn't matter because you can see the type. important to code against implementations, If you look at that example we just saw that concrete type mentioned there. Unless you to be pedantic. real type. It's void. It's nothing. There's type is container or value? &quot;Oh, Well, that's that I can call push back on and call begin can move into that containers push back. &quot;Oh, when I call dot empty what type does dot empty Well, you might say bool, well, who says? to something we will like, but who cares? know what it is. There's something testable For templates, for return values, we often we call functions and expressions. We don't I point this out as an example just maybe we're already doing this a lot, maybe that Now, let's talk about correctness. With deduction, I want a new local variable of his basic type. on it, is this a good line of code? Would that pass compilation? Why wouldn't it pass Const. Right. Well, it should be ... Well, I could do that instead, but I'd have to think type for any reason like maybe it's const to be non-const because my function also does now I've got to go through and do a ripple say const to non-const. If you just say auto, right type. It's correct including under maintenance. because it tracks the type makes your code that we can actually change our code more that need to be updated while we're updating Let's say for example that I changed the code zero, which makes the 42, instead of being this code compiles but under maintenance I've to update that variable type, maybe I didn't there because that's what will happen. The If I have a factory that returns a widget changes to return a gadget, which happens are getting that conversion and we're not a widget that's fine. If we want to stay with that's fine, very often we don't. begin on the dictionary, but then I realize heard of this nice hashish. It's got to be I'll just change my map to an unordered map a drop-in replacement for common cases and What do I do? map there because I have the maintenance ripple. avoided this silent narrowing conversion tracked case, I would have continued to use a gadget, have retained the type in its extra characteristics the container type when I've used a replacement are good features. is performance. Now, this is one of those as long as you can make a credible argument They'll like jump in a river or a lake, there they'll swim faster, they're efficient.&quot; wisp. It's a way to draw in C++ developers. you better performance by default also and conversions. If you use auto without otherwise a specific type, you are guaranteed there means no extra work being done that's invisible There's usability, so finally, yes, there That are inconvenient to spell, lambdas, binders, familiar with that whole type, and I am not Finally, I know I have to say, &quot;It's less that because people notice that, but like whole talk and say, &quot;That's why Herb is saying last least important and least interesting too, which is kind of cool. unless you have a reason to do otherwise, clarity, maintainability, performance, simplicity, worth something. It also shows you're habitually not implementation, not against concrete types, more of in C++ of the future. need to commit to a certain type. Sometimes type, then what? You can still use auto, as code, which is the old style C++98 code sometimes but it's the old style of put the type first, with auto. so auto s equals &quot;hello.&quot; Auto w equals get to commit, that's if you don't need to commit try just sticking the type, name on the right. and I think most of you will probably find it anymore, but let's talk about reasons and are pretty much equivalent. cases where they're not equivalent. Like of talk about the advantage of doing it this allocation, both old-style heap allocation, want to write anymore, and also, make unique, appears on the right because that's where heap. you of anything else? It's like new style return type last or just omit it entirely. here and it's not just that the letter A-U-T-O Everybody at this point is probably thinking, to write int i = 42; are you? Why on earth another letter.&quot; Also, you could make the that the first one, the green one, is green, Let's talk about this elephant in the room. with before and now let's add interest. Int I could make a consistency argument here. wouldn't agree. That's fine experts can disagree, going no further, but wait there's more. How the built-in types like floats and shorts? user-defined literals? How many of you have standard library user-defined literals? Okay. there are ... Kelly, you implemented them. this advice will work. side I could write float x = 42., and on the a floating-point literal. The right side is actually a conversion on the left-hand side never see. I'm not saying it's a big deal. I'm saying this is the subtle stuff that you still know exists, you're not being dumbed you're expressing the logic you actually want about the details of a language. of the others. Same principle and notice, This exists already for the built-in suffixes, C++14 if you say &quot;42&quot; s that's a std string. literal. I just used auto and it's a std string. auto one I argue is clearer. Chrono nanoseconds, more than you do. I don't mind ns at all. I throw lambdas in there too because I mentioned have a named lambda, how do you capture it? equals my lambda. The signature again is on it for named lambdas. Notice going beyond you should be using now for typedef does the It does it the same way. this, we are in the, well, through a transition well enough through it to see what's happening consistently, at least, by default. You can to, but as a default, there's a lot of consistency literals, function declarations, named lambdas. template aliases. It's all good. you may have been wondering ... Well, let's to deduce the type I want to track the type sprout C++ programmer back in the day and high snow, six-foot-high snow. That sounds I know to be suspicious of the equal signs of all, that's not an assignment, right? Because quirk of C++ syntax for a long time. That's We're constructing x of some type. temporary, and then, copy it because in some out standard says, &quot;Nope.&quot; That's a good thing. but it basically has the same meaning. Notice 00:46:07] when a has type t or derived from Turns out when you say auto, you always have have type t. It deduces it. That is true by costs to exactly zero according to the standard. type value so that's the second one where use auto. Does that create a temporary and That copy can be elided and in practice, many but full disclosure, yes, the basic language compilers are getting really good at it. There auto style, it's where you're using the explicitly x equals type name initialization expression. to move. A mute x, an atomic, an array events, types where you can't use this idiom, declare it will compile, but be slow because it doesn't, you can use this idiom very well. That's the For completeness, a few people have suggested to show you I'm aware of them with some sketches at all, but let's document the list, and what One recent time I was resisting using auto, auto everywhere, maybe this is too much of I don't want to be that guy. I know I'm going least here I consciously don't want to be I wrote base star pb = new derived in my original I left it be unique pointer base pb = make to this article a week later, readers, when &quot;Why didn't you just write auto on the left?&quot; that's right. I should have put auto there.&quot; changes the meaning because there's a conversion.&quot; pointer base. If I had followed my own advice, simply stick to my guns and put auto first. time you see it, and then, you realize, &quot;Oh, there could be a type, caste expression or side. that much over made it perfectly clear, at that the code isn't a bug. &quot;Oh, yeah, you're find in practice the middle one was too easy it come back a week from now and take a quick you remember. It's just that much distance Preferred declaring local variables using auto and bind directly to the type or stick to explicitly mention a type but you can still no implicit conversions, no narrowing conversions, but I forgot to say in words so let me add to write an uninitialized variable. Why? is meaningless without an initializer. It of uninitialized variable, which is not bad. also use auto. The new C++14 feature you can from the body just like lambdas can. That's anyway. You can do that and the bodies have the type so auto is often a very good return auto, I thought I should mention return types It's simple. We can tell Nigel Tufnell and who agrees, that to make a type track deduce, cases, you can still use auto, try it. You not complex. Give it a shot. When you think of how much the C++ has evolved standards, you could point to a few features in terms of how the type works and how our those is rvalue references and move semantics. always has be able to deal very well with is largely an optimization of copy. which is a new thing, but largely it's an types that C++ has always been so good at mainstream just got even better, but what to absorb. Okay. Well, what does that mean from trying to develop guidelines, seeing I think that this summer, and in particular, this week at this conference that we're ready guidance specifically on how does move semantics and 14 effect parameter passing. I'm going are some antipatterns and why I think that actually should get a lot of love in C++14. even before C++11 because compilers now routinely return value, return by value way more often. pass by value. I'll explain what I mean. tend to get overused and Scott made a very over the last couple of weeks about what are because a lot of people have said since we've value more, maybe we should do other things we have access to, right? optimize for those. Now, we're mesmerized a focus on rvalues that when Howard Hinnant way here the, if you do that way you're causing moment. One of the realizations Scott put are with lvalues. We've been focused so much how often those things are actually pessimizing I'll show you what I mean. What's important In fact, it's exactly the same as C++ 98, you, and second, you have to think about all not just focus on the new thing such rvalues. try and catch everywhere, using move semantics everywhere. keynote on Tuesday, rvalue reference didn't show up once in our default parameter passing many, many people including more not listed up to this to firm up. Here's a great opportunity it through and see if we can converge on new I believe that we have time will tell the and so, I'm very glad to acknowledge these follow. Here is parameter passing advice in give people. On the vertical axis we have, an out pointer, is it an out, in out, in, keep a copy. It turns out to be an interesting Across, we have, well, is the type cheap to more often. Is it moderate cost a copy or like some big data structure? For the out the return value optimization in modern compilers, cost, and you'll notice the footnote, moderate contiguous and hot and cash, yeah, just passed That's a new thing in the last 10 years, but can assume your compiler does that optimization those cases. If it is expensive to copy like advice was passed it by reference. That was an x star, allocated on the heap and return you have to decide if it's worth it so I mentioned reference is what you use. reference because that way you can modify cases, usually passed by const reference, None of this should be news except possibly objects than maybe 10 years ago we would have is not surprising advice anymore C++98 advice. C++ advice. you might miss it. There it is. Let me go difference is the advice is still the same, how you pass your parameters, but the applicability becomes even more usable because more types exception. In particular, if the first column such as unique pointer. It might be impossible The middle column is now is it cheap to move now moved into the middle where it used to become more usable, and if it's still expensive which is a smaller set of types they're still case has been shrinking, which is kind of Again, back, forward. This is the slide that cubicle wall, not the next slide. The next open the hood, here's advanced advice that I want the advanced stuff so I'm going to this one to the wall. The summary, and here working through this. &quot;You know the defaults advice. and I think that even Scott and I agree entirely one extra line on the next slide to be on and I don't, I still don't think it's worth default advice, we just talked about covers passing unique pointer by value just like Now, if you want to optimize C++ is even better is where you see rvalue references come in in the middle part. Now, on the previous slide Reference to const. Now, it's, and by the add an overload of x refref, rvalue reference. explicit case of, &quot;Okay. I'm going to pass knob if you want to optimize that, you can that often won't be an optimization. a parameter often will not actually be an you pass an actual temporary in by value to you move out from it again, and then, inside plus move.&quot; If I do unique pointer refref do it, hold on, wait. even by value, it's just a single move, and pointer move that's like moving a raw pointer for a moment that 99.99, maybe 99% of code if you want to optimize it move for other more expensive the new pointer, do know about Now, a few comments about this. First of all be here, special case. Yes, for those middle forwarding in certain cases. Well, you could see it mentioned on a later slide, but we'll Bjarne summary, which I agree with is defaults opportunities than we had before, but remember for them prematurely. That's just good software A note here, you might be thinking, &quot;Well, and move constructors for my class.&quot; Herb, me with a straight face here in ... that I This is a subtle point, but it's actually is nevertheless an optimization, but the advice line is exactly what you write for your constructors. It's exactly what your right to express the assignment versus copy assignment. You overload do that unless it's an optimization. Now, going to be widely used, now your library makes sense to reach for such optimizations consistent advice it's just when you're writing often because you're supporting a larger audience. Of course, and especially in the standard in a standard library even perfect forwarding widely used. As you go further down, you reach advice as for any other code, overload on Now, there is one drawback to that. Let's opportunities. Those are the things that are rvalue refref? Again, like I just said, &quot;Write move assignment operators, move constructors, writing, trying catch a lot, move semantics, move, and refref a lot just return by value kick in, but wait, let's dig into an example. a bit since 2009 has been, well, hey, move are here. Maybe we should pass by value more does a detailed analysis of a compiler optimization, you can accept lvalues and rvalues, named from the ladder, great. You'll still get a retain a copy case. many of you have seen the advice to do that? to this nice reasoning. It's interesting this can tell of Howard Hinnant, a very experienced 01:04:41] libc++ implementation, and metro many of these optimizations, and then, told people popularized this advice, but Howard be dragons there too. There are downsides call out to Howard. the information to follow about why this advice don't want to do, but there's one specific can, in fact, be faster than C++98. For the I'm going to move from rvalues. I still get but it can all so be much slower than C++98. an lvalue, a named object. Remember, this the lvalues.&quot; We're focusing so much on optimizing being passed a named object here, I am going the function I'm going to move it then into string, the move is an assignment, and it assigned. or what if that vector if x is a vector is eventually going to move it into. Well, if reused the capacity. It's much more efficient. because the destination already had the capacity, in cases like large strings and a vector that it because I'm forcing a deep copy and a memory in. Here's an example that it would be a crime, give a simple answer to this question, and long arguments about how do we answer, how the answers with you, but some of them are words that speaking of how C++ is being taught C++ using C first, but that's not the only He says, &quot;If that's C++, I don't like it either.&quot; on earth could we have a modern language where I have a set name function? There should be parameter, to change the names with the new going on. Let's step through it slowly not that has been happening. the slide. It said, in this case, the n plus pass it by const ref. You already knew the you knew the answer I was going to give. Just That's the same answer as C++98. There ain't Let's analyze it a bit. There's always going much less than 50% of them will perform an are many systems is 16 or 24 length or 11 every major std string implementation already are stored in the string object itself using a heap allocation, which means that you can have a single heap allocation, and if you've It turns out this is a good thing to optimize there are lots of studies showing that the mainstream applications are short. It makes if it's a large string this still performs right? It's only going to perform an allocation of the current string, which means that if a few times, and then, stop allocating. a loop, you call this repeatedly, it's going ever unless you happen to hit a really long get one more outlier. What if I want to optimize for rvalues, so that's okay. We had advice on string refref, on the rvalue reference the function. it's important to think about exceptional string ref it can't be noexcept, why not? actually do memory allocation. It will do it might do some it could throw, but the second of the buffer already owned and I'm going had, but that's okay because that's no throw. for rvalues so write this by default and if have performance data that you should then notes. When you pass a name to object it's you passed a temporary it's one move assignment, benchmarked the three common STL implementations as copying for five ints. It's pretty much we can make it noexcept. this that actually in practice almost never I'm going to come back to this, but I do want downside. If you do this, overloading on const than one such a parameter and the N+ copy you mean if I have like three I need to write We don't like that. Now, the good news is Hold on for that. We're constructing an object but in most set like functions, we're usually good advice, standard library does it all at pushback basically and others like it. like the shiny object and that actually did that we should explore as a new guideline, happens here. If I pass my value, first of I get a single function. I completely agree and right for simplicity first. I agree with one, therefore, you should write option one, I passed string by value, I move from it inside, construction of the string, which means I'm is a long string if it is longer than the a sign. That means I can never reuse the capacity it's good because then I just have one move You notice that noexcept is not green. On Green is soft and cuddly. Reminds you of freshly nearby, but this noexcept it's kind of dark noexcept is problematic. I'll overstate it, This noexcept is a lie. It is technically fire. It is actually technically following nevertheless a lie. that that function never throws. Now on what nothing can throw. That's perfectly true. that might throw into the caller. If he has will be performed. That copy could perform That could throw, but by saying no throw, you actually got to us. It's your problem. that if we tell people to do this a lot, I &quot;How so hard C++ is. Here's a puzzler for function and throws. Hahaha.&quot; Don't be that means. If you're going to do this, and there's this, I strongly suggest not writing the noexcept never actually fire because it's alive for problematically. I'll call it mendacity. in the room, but this is being recorded and those of you who have parents, children in the room. We're going to have some graphic those of you in the room you may want to cover to some viewers. literal gasp. It if you want to write a perfect parts, but you still need to template class the enable if is same decay T and the noexcept to write a perfect forwarder, write it reasonably going to write a perfect forwarder then I of developers in the world that you could it was only a couple of pixels, compared to talk about it. more. It's entire, it's for perfectly forwarding make it a template so it can take anything, going to name the template parameter string object, there's one copy assignment as before, assignment, noexcept, it's optimal so we actually is no throw assignable, std string ref to The quote unteachable comes from Bjarne Stroustrup. option for advanced developers that if you about this, and if you might see it in your not see this in much production code because some drawbacks, it generates lots of functions you might call. It must be in a header, can't I don't usually hear people mention this forwarding. Ooh.&quot; I don't normally hear them be in the header.&quot; Generates lots of function. worried about the generates lots of functions. out, it's a template, but most people over I never actually hear bug reports about that, an urban myth than a reality that that's an exposed in the header is an issue. That it Now, I already answered this question, but of questions. How many here believe that they still some hands up. Quick somebody, who's a string literal or not? Male: Does not. Herb Sutter: Does not. Male: [inaudible 01:18:11] Herb Sutter: I've constrained it wrong. This love to hear why it's constrained wrong because it, we can't either. By the way, I will mention Bjarne in person. What about the way you think &quot;This is unteachable.&quot; He said that in terms &quot;There are very few people in the world who think he was one of them.&quot; of understanding it, but just write it with something up. Now, let's talk about performance toughest performance, right? Let's measure. passing a const string ref, that's option The default that I'm saying you should always rvalues is the second bar. Then, option three, and just have the one function that's option four. Here is benchmark code for that employee is exercising the case where it's reassigned hundred times through the loop it makes a 99 out of 100 times. Notice options one and two are fine for lvalues and use option three, as long as you're in having, you're passing a short named string, the single, the small string optimization. In the second case, we're passing larger strings those will have to be allocated on the heap spike and only for option three. This is the just pass by value, you must allocate on every of a vector, anything else that could reuse reuse the capacity. having to do now an allocation costs you more, here is a big pessimization and actual data where it's a pessimization. It's not always I did. You might notice that the top of the Microsoft problem. It's probably STL's fault, Actually, it's not. We're going to optimize fault because Howard also graciously ran this Yes, I changed the slide. Let me go back so with Clang and libc++. STL being no worse plus this is unavoidable because you must case. news for you, kind of. Here's libc++. Is this Because it still does the copy-on-write optimization, problems that would show up in different benchmarks like compare, &quot;Oh, look, Clang, GCC, better. Well, yeah, except it's non-conforming, but are slower. I'm just making a little fun. this problem for a long time. In fact, in be the new basic string as soon as they can They've been deferring it and deferring it, or something like that. I forget exactly, of you by the way use vstring? see one or two hands. Are you ready for vstring there's our friend again. This is a pessimization with passing the string by value advice didn't really well understood, and one of the reasons this talk and I wanted to give this advice, to it because very few people he said seem sharing some numbers with you here. that the cost of the special member function classes likes a shared pointer, which is more Copy construction, right? Because you're at which you don't have to do it with move and, copy and assignment and move have different they cost less. get rid of the previous state, when you move vectors and large strings, the cheapest thing from it. Move assignment is actually cheaper where you get to reuse the buffer. This is being able to, construction costs more than, because you have to get rid of the old state. and large strings it turns out that the assignment and so, by taking my value we incur that copy Well, that's the most expensive operation These numbers don't generalize to all types you, Howard, for pointing out the construction costs. Here's a nice quote from him that you razor, don't multiply entities. He was talking to objects, needlessly, and Scott and Andre don't need.&quot; teaching a lot that it's a bad habit. It just that. Remember this is about default. It's It's actually not hard right for clarity and Now, there is one place I said where you might and it's for two reasons. Look at class employee, city and when I construct I have to pass all for the overload const ref and refref because case that's bad for option three because I there's no capacity that I'm missing reusing. them. this avoids the pessimization in option three case where you typically do have multiple consider option three, but, again, as an optimization. want to optimize for rvalues in that one case, new knowledge. at an overload that's noexcept often for rvalue One more thing, when you have, when you see what do we call that? Read the slide. What say universal reference and that is a term He has rightly popularized that we need a up to give it a name. reference. One of the nice advantages of being to have discussions about this. Let me ramp here this week. Again, just to motivate this let's say I have class types foo and bar. very, very different refrefs. to non-const. It only takes rvalues and the In the second case, it takes a mumble reference. reference, but I'm now recommending a forwarding I didn't say to anything, I said to everything It will take const. It will be volatile. It all y objects, lvalues, rvalues, anything is not to optimize anything. It's a very different The reason that it exists is to take whatever and just pass it on. I don't care if it's it myself. I'm going to pass it on to somebody care, whether it's const and so forth. [crosstalk what I'm going to suggest should be the new it this week, Scott has rightly pointed out other refref parameters. a name for it. He coined that name and he galleys are due like in like three hours, not supposed to make big changes and you just going to press [inaudible 01:29:41] just can't we were all here, it was a great opportunity, able to talk with each other. Scott and I haven't talked to everybody yet so this still committee as to whether people agree that But we all agree that the word forwarding reference, the concern is that it makes people the time. It doesn't describe what it's for. name because it says exactly what it's for, unique name. in the meantime, Scott is going to change very much, Scott, for doing this. That is so that he's not changing it universally, by the way it looks like forwarding reference in the community if and when that actually several people who are going to keep using Then, you will find new printings of effective FYI, this is, we want to thank Scott very shining light on this needs to be taught differently, us to say, &quot;Okay, let's try to come up with for the next 20 years.&quot; Use refref only for to optimize rvalues like we said or t refref, One dessert slide. Did you know that C++ now tuple or a tuple if you're Scandinavian. I out. Sweet realization. We're already doing you insert into it, what does it give you and bool. You would say if result dot second result dot first, right? That's just the convention That code exists in the wild, it's been there Ready? Watch this. C++11 gives you auto. It have to type that big long thing, but wait we have this nice backward compatibility with value and say dot first and dot second as which works well with that old feature. We a tuple can do has generally been added to two. group did a great job of that, which means unchanged from C++98 and tie two variables, I don't have to say first and second anymore, call, multiple return values. If success do The only thing I can't do is declare a variable for that because that the next thing they It works with the existing STL and with your values express them with a tuple. Remember I just have a show of hands? Like how many of students here. if you're a student, please, and please stay Now, please, please stay standing and anybody please join them. Please, also stand up. Five and stay standing. Thank you. you're standing, is it okay if I take a selfie Okay. I'm going to come down there. please, of you guys because this shows we need to C++ and welcome all the people who are joining Male: Where did the [inaudible 01:34:26] go? Herb Sutter: I'll go where he tells me. This Thank you, Chandler. Thank you for accommodating, decided I want photographic evidence to keep places all the people who are new. We welcome than ever. Sometimes we are addicted to too reasonable defaults simpler than ever for Smart pointers, never write delete again. if you have a couple of questions please line then, we'll break for lunch. Then, come back panel as well. Here, please. Male: Yeah. In the spirit of simplicity, which simplify the algorithms in STL so I don't Herb Sutter: Yes. We are looking at simplifying wonderful. There's some real proposals coming. Male: I was wondering if you could go back could you like ... Herb Sutter: It's all the way back here. Oh, about GCC? They're good. Male: It's fine. Okay. In the last example me basically option four is much faster than like match option two. Herb Sutter: These were the results as measured Male: I mean it isn't like ... Herb Sutter: You can download that code and pretty much the code. Check the assembler. on the right-hand side they were different. to the others you'll find the same thing. characters stars than the others. Male: Yeah, but it makes no sense to me because Herb Sutter: Goat and Stefan is waving and Male: I have one last question and ... Herb Sutter: We're going to switch over to Male: I want to say forwarding a char star I think. My question was about at the end, of your first points was if I say auto x equals variables, but today if I want to use std uninitialized variables? Herb Sutter: Well, you don't. If you use std reason to have uninitialized variables. Yes, You have to declare them somewhere else. That's want to have for tie is to be able to declare reason you just said so you still have to still have ... C++ is evolving, man. We're the local scope. if you don't want to initialize them that's x equals whatever and even if it's zero. Male: Okay. Herb Sutter: One more, and then, let's go Male: I love that you started with all this started with the quote from I think Bjarne because they're new. I am not sold on your auto about allowing your code to be more maintainable, large meaning, not large but meaning full-sized function or return ... return types and the Herb Sutter: Let me ask you a question. Male: ... without having to do any work. Herb Sutter: Let me ask you question. How a std map, the tree based one to a std unordered Male: Yeah, but you have to [crosstalk 01:39:01] Herb Sutter: The iterator type changes. Male: Yes. Clearly, but you're going to have Herb Sutter: Oh, yeah. Sure. The question the question is, A, is there a code ripple compiler do it for you? Second, the correctness won't tell you that you need to change it, existed I found them in real-world code bases You, however, sir, I know who the ... are internal code base that is monolithic, has a switch and do these things for people. Those our compilers to help us with auto. Male: I'm going to have to see like war story, being wild unintended consequences. Herb Sutter: All right. Thank you for that any of you who are listening to [inaudible please, tell him, and I will ask him after going to be a line, but I would be curious back together. Male: Absolutely. Herb Sutter: Thank you for coming. Enjoy lunch. you.