s js is a framework for building scalable Node js Vlad will teach you an S JS by teaching you how course. My name is Vladimir, I am a full stack to build a CRUD REST API with Nest. Yes, our goal production app, we will implement authentications databases as well as with a modern development RM on. I'm a firm believer that you only learn by you're stuck, you will find a GitHub repository below. Additionally, feel free to leave questions flood. I will try to answer to them as soon as I JavaScript ESX and TypeScript. But don't worry if a step by step fashion. So what is nest GS? front end react framework. NES GS is a no GS And it's also very different problem from the weak point of Express GS, see, if you're doesn't give you a direction of how your product And while Express GS can work out very fine for And if you are not an experienced developer that it can quickly become a mess. But NES GS is not not try to reinvent the wheel, it actually uses an abstraction of Express GS. And in a nutshell, maintainable applications for NSGs. Modularity is injection, and it is often branded as the Angular what NES GS is, why would you use it? Well, a lot of functionality out of the box easily and has very good documentation on security. It very important factor to consider. In fact, right below express on the same level as Koa, Gs, and Meteor. Plus, employers really love it because it hire developers because they don't need to learn on boarded on a Express GS project. So after that code our NSGs application. And in this project, we interface. This will be a CRUD API Lucia's very we're going to either update, read, delete, or let's get started. Before we start, we need to any future version with a long term support should So you need to install their CLI globally and and create our new project with Nest new. The CLI will ask you to choose a package manager. our product is installed, we can navigate into it. course use any editor of your choice. And let me Studio Code. The theme I'm using here is material icons. You can download them and install it here starter project for us. It has a source folder where it keeps the end to end tests. And it clean it up, we don't need the app controllers And nor do we need the app dot controller. And since all those files were imported into the So for NES modules are very important. You app.module.ts. This is similar to something or app.ts file. So this will be the main module or talked about modules, but I haven't introduced nest, yes, you can just go into the nest Yes, And you click on documentation, and you'll have any concept that you want. And for instance, annotated with the module decorator. And in fact, annotated with the module decorator, if it's not it's not a module. And if you don't know what a adds some metadata to the to the kind of decorating. So just adds more property to documentation, we see that a module can import application module. So the main module, the root or there's model chat module, any module that also controllers, and providers, we are going know that a module can import other modules. feature modules. So if I have an application, what would be the part of the like the authentication logic where a user can create its then you will have maybe user module that will also the bookmarks module, and maybe the database those features, right, and you break it down into much more easier to handle. And to reason about, just to illustrate the structure. So I have a category, common post Prisma, which you see all you see that you have some data, you have the providers, those we are going to talk about it production ready, project. So you guys can see the of of next year's projects. Okay, so we now know are declared with a class annotated by a decorator class another module to break down our application are creating a bookmark application, what would already touched upon the authentication. So in our to allow them to log in, right, so we will have create a auth module. And usually the convention in a folder, and the only time that you can not main app module component that will import all let's go ahead and create the And at first, I'm going to show you how to for the first time. It's Better to actually write Because nest yes has a generator has a CLI command And we're going to see that in a moment. But at muscle memory going on. So we create a folder we know that it should be it should be a class So let's create a file. And we just respect that the its kind of function to its extension. So this extension dot, CPP for C++ would be an extension will be.out.module.ts. And we're using TypeScript create a class. So it will be od module, right. called module. And that decorator module, and we just need to open it provide requirements to create a module. So all we need module, and we have forgotten something important, don't type export, this class will be available when you export it to allow other files of our module. And now we can just import our module. us to find our modules and files. So here, it all we need to do is to click here. If it doesn't and it will propose you an option to import it that our logic works, let's go ahead and launch is inside the main.ts. It looks a bit like what right? So we have the app that is being on port 3000, I will use Port 3000 333, because my development pipeline. So I prefer to use in the project. Let me clean that out. And all I all those scripts are actually defined here inside start Dev. So the reason why I'm using start Dev and recompile the code when needed. So if we and we don't have any errors, which means that NES GS has generated a dist file, so a kind of we don't need to really worry about it. It's just API working. So let's clean that up and, and come down into smaller components that we can easily and the bookmark module. In this case, I'm going you have an idea about how it works. Just open the session. And we execute nest G for generate the module for us and automatically imported into user, with the user, that module class here. Right. And it also generates a bookmark let's kill this one. We see that the application save, you see that it is recompiled so everything our application. So let's add the login logic. So separate our logic into controllers and service, it says that controllers are responsible for for the clients and providers or services are So we separate our logic into controllers and what we do, right. So let's go ahead and implement service and a controller. So again, the same can do it by hand the first time. So let's create go to the controller, we need to create a class the decorator controller. So nest years knows that that service class service. For the service, we And that just means that it's going to be able uses under the hood. But more on that export those otherwise, we will not be able And since we have added that, we need to add controller, and providers, or that service, let's Okay, no errors. Cool, running good. So I've really said what it is, you can of course Google with a concrete example to see how it works. So we Christ, right? What is happening usually is that the controller will receive a request from asking to login a user, right. And then it's class and return its result back to to the client will have to instantiate a auth service class, So if you want to create that instance, new or service, right? To avoid doing that. To manages it all, we use dependency injection, that have to declare it, for instance, to actually give me the service here, give me that, an instantiate it, just give me an instance. And Service. And that's it. Nice, yes, we'll handle and how to pass it to you in that old controller private here, if you have never seen that and then have to do something like Instead of doing that, you just write private, and And if we check our code, we see that it everything is compiled. And now if we odd service called test, this function is not this function directly like that. Right? So if you want more information, just Google it. how it really works. This is how Nigeria's use dependency management. And it's just easier to So let's come back to the auth service and create to functionality, login and signup. So let's go Right. And that's all is going to do for now, right now there is none. So let's come back an endpoint for login and an endpoint for signup. it just simplifies how you write your logic. So request on login. So we create a function, And, and to make it a route, we just need to from Ness GS common, and let's call it signup. And it's usually a good practice to put a global to call that route, we're going to do a post that route, it's going to be that that request. And here I am signed in. is compiling all good. And let's go ahead and HTTP client, similar to postman, you can also in some way, just a bit more minimalistic test our endpoint. And if you remember, our old right. And we do the Send Request. And we see And that is basically what we have written here, it's going to print us the other response. One at the headers, we see that it is powered by Gs use Express under the hood, you can replace for most use cases, you will probably use That also means that everything that you know nice thing about NES GS, if you like Express you can use NES Gs, and still have access to that that is very interesting is that Express has this is a text. So NES GS will automatically here, it's a string, if I send a object, And we send it to sign up. We now have a object a very handy, you don't need to worry about do it for you. Let's go back to our app. And let's the controllers will handle the requests. So it It might check some headers or any work related actual execution, we offload that to the service. the same function on the service side. So let's and sign in. Right? And instead we can actually call the service and Hello. And that's right. I have signed up. correct and let's call those functions from the out service that sign in. So what it does is and only busy with a logic with to the requests, business logic like connecting to the database, and do it again. And we see that it works as well. Now we know how a controller works, we know We know how a service works or a provider, it But what would be a business logic without to somehow set up a database and connect to it. my style of teaching is to introduce concepts Let's go ahead and set up a database. Docker is an amazing tool that will allow us but so we don't have to install it. So it will already installed, you can go ahead and install just write docker ps and if it inputs something is version 20. With that being said, let's go with databases, I prefer to use Docker Compose, spawn the Docker containers and to destroy create Docker hyphen, composite Yamo. So here's version 3.8. In the services we define our Docker dB, this is just the name I give it to, to it. The to use the relational database Postgres version 13 connect to Postgres 5334 on our computer, we'll be I'm going to use is the user who is going to be very secure, and the database name will be nest, that is defined here. That's about it. So to to we open a new one. And we do Docker compose up, we the DB, and we will run it in background. So with we see that we have a container now that is So Docker logs. And it's written that the it has deployed, it has compiled everything is So we have the database running in Docker. But how typo RAM mongoose, that allow you to I'm going to use a new IRM that I really love and Prisma. So you can access the website on Prisma. it's kind of a query Query Builder, but it's so for instance, that will be a post with ID title And you can get them from your JavaScript code going to explore it straightaway. So with Prisma, logic the database module in a way. So that since the database module will be able to use login sign up. It should be used by bookmark feature of our app for Prisma. We need to have two it will allow us to create Our schema and database. So it's more of a maintenance library. has different clients, the one we're going to use yarn add, and we're going to add it as a Prisma client for the client. Okay, let's we now have access to the Prisma. CLI. Let's run several files for us. First of all, it generated And it just created a Postgres connection a bit later. And it also generated that Prisma it just has its schema. And this is where we're library like type or M, you will create entities Prisma. There's only one place that you need to actually. So you would declare those structures will be in your database right here, it says that which we have installed, the provider will be Prisma supports my sequel, and even MongoDB. the database. So it's going to grab it from So if you place one inside the prison folder, we're just going to leave it here in the global models. So the way to declare the models is just word. So if it's users, it's going to be user. right. Model bookmark, bookmark. And what do bookmarks, right, so we only have two entities It's an integer, we need to And we need to set a default as auto increment. of course, and same goes for bookmark, we also will not know when it has been created, it's going which means when the record is created in the at the creation is assigned to that variable. And that as well. Date Time and prisoner has a special bookmarks as well. Right. So for the user, what the user is going to be a string. And it's going the password, so we're going to put hash shrink. optional, you can just put the, so let's create an optional string and last name, optional string bookmark that we're going to save is going to which could be optional. And we are going to have be optional, because when you set a bookmark to a we go. We have created our two models, we save Then we need to add the database connection So let's check it here. So the user is Postgres let's go ahead and change that. User is Postgres. The database is nest and scheme not public, we can commands, prisma will be able to access our local way, if you have the Docker app installed, like the dashboard for Docker and see your container in even see the logs, right, so let's run our Prisma And let's press help for good to get some help. into the Prisma documentation. Of course, it's So we have several commands that will be useful And we have the studio Studio will allow to create database through the browser, we're going to see that point is Prisma migrate devs, what it's going and it's going to generate the migrations in that clear MPX Prisma and migrate data and basically and users for those migrations to be applied, common when you rise my when you run, migrate Dev migration to production, there's another command we can just delete it. And we can press yes. And we can just say in it. Now we see that And basically it just generated some it actually does two other things. First of that SQL to the database. So the database if we there is some command that has been run insert Prisma has already pushed some migrations onto the tables of users, and bookmarks. And one run the Generate command. So when you use Prisma, generator, and what generate does, and it's takes your schema here. And it creates TypeScript interfaces or classes. And same for model, the directly use those fields in our code. So we the user and the bookmarks as well, that from the Prisma client. So we can use those awesome. They're just very awesome. We don't directly with Prisma. Right. So let's come back studio. So Prisma gives us a very handy tool MPX Prisma. Studio, and it's going to connect Here we go at Port 5555. We are now at the Prisma. bookmark models, right. And we can go here and stuff there. And we can even add records if we schema. It's actually quite cool. Let's discard can leave that running that a that Prisma studio far, we have created the Prisma kinda migrations But we don't have any way from our code to we're going to create a module to do it easily, regarding the database in the module and only be accessed by the application. Alright, let's go I'm going to use the NES CLI, because I'll be call it the same name as, as this folder. But this Prisma folder in the root, stores the schema following the NES, GS modular structure, And now it's here. And we we have created the service manually here, with the CLI. So instead of module, we have it is going to create the spec files. So the test And now we have the service that is And in the service, we are going to create So the way I like to do it is that I like to have And Prisma client is a class that allows to it has a constructor constructor, it has connect, what I'm what I want to do is I want to configure, so I need to constructor and I need to call super. I'm extending, and the constructor of Prisma DB and URL and the URL will point to that trink. config variables, so dot n and everything in into our Prisma. Service. Right. And I think that estate to run our scripts. So instead of running it actually prisoners to you as well. And I'm Let me make it a bit bigger. So I'm going to and do yarn MPX Prisma. Studio. And this is item So if you have any questions regarding the to our code. We have the prisoner service declared technically how it works in SGS. So let's say we module, because it's all modular, right? Well, Prisma module, right. So let's see if you would have access to the providers that are try it out. So in order to service that is part Prisma module now, because auth module imported to get reference to that service to Prisma service private Prisma. And we can just reference it by what we have, oh, we have an error. Well, why do dependencies of auth service, please make sure available. So what it does is that it says hey, I don't know what is that? I don't I don't have the Prisma module from the in the art module, we export the prisoner service to other providers. So Prisma service, right. And now the error should errors. right now. So basically, that means that it in auth module to make it work. But that's a where the user will need to have access to access to the database. And if we add to other prison model. So do we need to really import create an import and create a model. Now, what is module. So instead of importing it like that, and add another decorator called global. And stuff that we want to be exported, it also that this prisoner service will be available to logging, everything works correctly, just make into the app module into the root module. And in and and do what we want. And here comes the really start to write business logic. This is configuration. And if it was a bit tedious to set properly, with Express alone, it will take good with architecture to be able to make we have everything working out of the box. And of way of SGS. But in the long term is going actually need the object so we can delete it. The it's not important in the scope of this of this and start writing our logic. So for this signup, a user right, we need to create a user based so usually it's going to be as post route to all that route. And the body will contain the email back about something back we're going to discuss authentication and especially DWT JSON web later. Right now just let's focus on the process in the logic. So net GS has a lot of This is a decorator, right? It has a lot functionalities. Remember I said that under you can access that express GS under the hood, all And it comes from Nash yes common. And let's which comes from Express actually, it's where things come from. And if we now press that rec will have a lot of properties. And Express request object. So let's just log I have signed up amazing. Let's go back to our request object. And that request object is And you can get stuff like Heather's like body, it will be something like request body and then function. So let's go ahead and request body form URL encoded. Here we have an email and that into the console and we see that the body is that we will pass the request body inside our it the sign up doesn't doesn't have any declared defined if the password is too weak, or even, validating, that is called the validation. And SGS to do. But before even going to to that direction, clean every time we need to get a request. And inside the body. And SGS uses DT O's data transfer push your data from, let's say a request. And you even have the shape of those details because we have an email, and it should have a password, working with NES GS, you should never really use library. Because what if you switch to fast defy might add in the future, you will use that kind be able to reuse the same code pretty much. So use another decorators called body. And it just let's call a DTO. And let's declare it as any, And let's console log that detail. And pattern. So basically, is just going to create the shorthand for that. Let's go ahead and do works. So the advantage of using decorators like depending of the framework for you. So you don't fast defy or any other framework. Message. Gs does half of the answer, because we don't know the for that shape. Let's go ahead and create it. So And inside the DTO, I use the Baron export to export all the fields. So here we are going to And there's going to be interface called odd DTO, and it will have a password, which will Right when to close that. And we're going to index And if you have never seen that The main advantage is that And it's going to import all the details from odd detailed Ts. And if we have something else that is going to import everything from the same in those brackets instead of being spread out pattern that I love using it brings a bit of makes your code much readable. And now we have in the DTO. Right. And let's let's clean it a bit. And it works again. But here, it's only the email? What if we, we forget to if we log that, we don't have any errors, we, we So that's a problem because now we need if not then throw error and is this is very class transformer and class validator libraries. before we implement them, let me introduce pipes. that transform your data. So if you have a string from if you send the JSON If you send a string for instance, user ID is equal one or user one, you need to use a number, that could be a the built in types. So what we can do is that can isolate the email field directly from the will be created like that, right. And let's, let's log goals email password. And for some this line is a bit big. So I'm going to go into and you try that out. Okay, 50 works of email, which will type of email. And same for I go here, and we say that the email is a string, transform the password into a number? Well, inline pipes, parse int, type, and there are other going to use. And here, since it's not a number, to stop the execution of our code. And if you stop the execution of our code before even we run the password is a number, well, it's going to have the password has been converted by the pipe to the because you need to create a pipe for every is just apply those transformation and Right. So let's go ahead and continue what we're pipes. But I think it's quite important into the detail of validation. So there's more And you see that we have different types, both unique identifier, but there's something this is what we need, we need to install transformer. So let's go ahead and add them. Here we go. And now what we can do is that transformation and the validations, we need it is the same for us, it doesn't change anything, And we need to add something here is email, package, and is not empty. And is going And it's going to be erased, not empty. And let's that it does not work right. Why doesn't it work? the pipe logic to use the validation pipe globally just before the abduct, listen, write app, use type. And validation pipe is a built in pipe by to instantiate it like that new validation pipe. let's go back to the insomnia and run the request. one is email should not be empty an email must be something like test, well, it's still going Gmail dot Come. And now everything works. This the validation pipe can do other stuff such as could be interesting for you guys is to see that I'm going to console log, the DTO. Right. And if what if I try to cheat? What if I have identified to inject a variable, for instance, ID is equal log, that ID will be passed to our DTO. And maybe the things that the pipe validator can do is that what we can do is just set whiteleys to true, and And now we see that the ID is not here, what it that are not defined into our DTO. So now we can and know all the fields that we Let's go back to our controller now. And that the DTO is validated, and it has an email and To make it all clear. Clean that and let's open the signup function will receive a detail of the with self assurance that the data that we actually correct. So the first thing that we're based on the password, I like to use Arcanum. So And that's a fine solution. But I also had the a problem with B crypt because its verification are going is considered to be a better solution For that we need to install argon, two. So all as argon from argon two. And the first Then save the new user in the DB, right. And we going to do those three things first. So let's first will come the plain text that we want our And that's it. Then we're going to say the user it will be in a sync function, of course, because user. And since we have defined data. And this is the data word that we're And what we have here we have email, which can be that hash. Right, we can save it. And it's not assignable to type string, and of course, are and the user is created. And then the user is ahead and, and create our user. So we can go back And our user has been created. Obviously, which you should not return because that's Not very secure. And let's let's try it We gonna reload, and we see that the user has here we go. And go back to our code and just say Well, how do I do it with Prisma? Prisma has a lot and you select only the fields that you want. Id true email true. And, for instance, created like that. And let's go ahead and delete that. But lot of logic to, to write, right. So what I prefer cover that topic a bit later. But for now, an easy there is going to just strip out the hash So let's go ahead and create one. And we have the one other thing that will be interesting, what if I do it, again, it's going to be created again, email field is not set as unique in the prisoner. set it unique. And we can delete that. Otherwise, and get back to the Prisma model. And this is how have created, the bookmark and the user. Now it all compatible with our database. So we can well we need to do is we need to modify our We might want to rename the the table user is good for Prisma, because Prisma But we're going to just map these names book marks, everything seems to be correct. is the relation between bookmarks and user. So do it with Prisma is to create a link to the user many Bookmarks can belong to one to the same user. but any given bookmark at any given time belongs to one, let's create a user ID variable is shall model, we need to tell it it's a relationship is a prisoner which fields are used for primary to which variable this primary key references integer, or fuser. So we just name ID, right. Prisma automatically included an array bookmark And is going to be an array of bookmark module. we need to run the migrations, how to do it, Prisma. Migrate, Deb is going to connect to the Let's just name update models. It has run variables in TypeScript for bookmarks and for user has pushed the new migrations here into the Sometimes it's a bit buggy and it works correctly. So now we have the user it should be unique somewhere it should be ready the bookmark has been updated with user ID and the go back to our code and write continue writing let's see if our logic against the duplicate because we have visited database. And if we what we have is a five or not very cool, right? what happened. It's better that we provide to the in that case, it is a forbidden exception, because create that error in SGS, it's actually quite we see that the there's an error with the So prismas tells us that email is unique, do is that we can say, we can add try catch, error. Here, we can just isolate if the error of prison Prisma known client request right? The only time where you would is basically when you create a unique field with cache all the possible Prisma errors here, I Prisma, duplicate, unique duplicate error, so if else is that happens if error dot code is field like Prisma has error codes defined and this record with the unique fields that has been exception, throw new, forbidden exception. exception actually comes from from SGS. It is well does not come from the Prisma what we do is that to our insomnia send request. And here we see a descriptive message error message telling you cannot use that. Amazing, right. So we So let's go ahead and create the sign in. So will provide the password and the email? The first If user does not exist, throw exception, incorrect, we throw an exception. And if Okay, so the sign in function will also receive difference between the signing and signup process the signup object, the signup detail will be more same. So the first thing is to find the user. So this prisoner user find. So the way you can find unique or find first. So if you want to find a you can either find it with unique or first any field and find unique will allow you to get either a ID or a fields with unique Where email is DTO that email, right? So the first in with an email that does not exist in our going to create what's called a guard conditions. that point and throw an exception, throw new, And if the user has been found, we can just For the password comparison, we're going to use compare password, P W, mattress, physical await hash. So the hash password, it is in the user, of is the password in plain text, and it comes from we put a guard condition if not PW matches, if the same exception as above, here we go. And if back the user. And before sending back the user, That looks good. Now before we go ahead and try So first of all, let's just write a script that typing it manually here in the terminal. Let's just run it and it will rebuild our container thing is that, let's also write a script that will So let's start by the database. So let's, let's So that means restart the database with Dev we only are in development. But if you have a as testing environment, maybe staging or something that syntax. So for now, let's go ahead and first So to remove a container, and here in our Docker To remove it, we use RM. And let's go ahead So we have forced to, to remove them without to try to stop the containers before it's a nicer way of stopping them instead of v to remove the volumes attached to that for our cleaning script is going to f v. So let's go ahead and put that into let's put our logic into several sub scripts. right. And the same would be dB dev up. to push it to create it and with is going dev restart script is going to do Up. Let's try our our newly created script in our Yarn DB dev restart. So we see that it runs So we had the Remove thing here. And we have And if we do docker ps, we see that we have is that even though we have created the to it. So it does not have tables of users and to automatically apply the migrations. So command Prisma, migrate Dev, what is going to based on the current migrations. And we don't we want to apply those existing migrations to to than regenerating the whole migrations every time. it asks you for confirmation. And it asks you in it here, and we have update models. So it's that Prisma has is called MPX, prisma. Actually, And we have Maghreb data, that's the one that we schema and to run the migrations. But if we we can just run Prisma migrate, deploy. So let's Devil deploy. So this is going dev dB, which is here at that, at that at right. So and what we're going to do is that to run that script as well. So it's going to also we're working with. And yarn Prisma dev dB, what computer, the database might take a bit of time sleep here, I'll put sleep one second. So we are our database is running, and everything is the migrations on a database that is in Bootstrap yarn DB restart, is killing the database. It's migrations here. And we we see that it's written the following migrations have been applied here. And thanks to TypeScript, we amazing, we don't need to run the script we have it here even before starting the server. you have not given a DTO while in the service, So in the surface, the sign in function, it don't pass it. So let's copy the body here, the That should resolve the issue. Amazing. Now we can to make the font bigger. And I just didn't think in the in the in the journal options where you can in the beginning, I'm learning as well. Let's go Senate and we had the user, if we try it again, we the same credentials, we have the user again, if which is nice. And if we do a mistake with We basically have implemented the sign in function in the real applications, when you sign to the browser. So it can it can, for instance, enough to help the API to help the server to we see that in our case, we send the email and the But we cannot do that every time. Right? So there and the password. And basically anything required encoded, maybe in the base 64 format. That might case, for the user experience, we want the So to allow the server to track the user to The first is sessions, you probably have heard Jason Web Tokens. And that's another way of, of the user is and allow or forbid, requests based back, it's not enough, of course, anyone can fake and authorization, right? So we identify the We know who that is, we identify then the user, So we can authorize that user through subsequent everyone can call that route, right. But there slash me, and that only attentive FIDE users can functionality. I said before, we are going to use NES GS. Now. So far, we only have seen custom ourselves. But Ness, GS also has modules that so let's go ahead and implement some of them. the Config Module. So for now, we have used hard we have actually hard coded in Prisma, right. So not secure at all, because that will be available prone, because what happens if you do an error be only detected at runtime efficiently. So that's Module. So let's go ahead and install it, nest GS config. And we can start the server that Config Module. So the Config Module is or you can put it in a in a custom module and like validation on that. So for instance, you can this variable should be a number, this can of this project. So let's just leave it out. But inside a custom module called config if you want. We have just installed the Config Module, let's and you see it comes from Nash TS config, I packages on top. Now Config Module requires some route option. And that's all we need to do Under the hood. The Config Module uses dot and for on my channel. So if you are curious how it works, it also have a service and also uses dependency Service inside any of our modules of our we're going to need it in Prisma. So let's go injection. Don't forget to annotate a class with that would be able to use dependency injection. don't have any dependency injection requirements. service, for instance, if you use that Ness, GS User, find many, if we do that it should complain, that will be undefined. So it will not know what property of undefined, right. So for any class And that class, of course, needs to be inside the decorator. So now it will work. But of course, we don't want to use Prisma. That is the Config Module. So let's go ahead and name service declared in the Config Module that we have can absorb the new, the new concept easier, right? is that this string, now, I'm not going to and file. And the way the Config Module having getters in on the config object. So dot get. And we just named the the name of the clean that and fire it up. And now we have an a Config Module is, but the Config Service is not all the modules are kinda contained. So this module, but will not be available into the Prisma With a global, you can expose our Prisma compatible module also have this functionality. here. But inside this object, there's an option and that basically does the same thing. Let's our prisoner Service is working correctly. With And we see that we get the right URL. So everything is working. And let's have led to amazing the new user has been Now let's come back to the GW T, the subject of how hard can it be just login and sign up? Come the hood, it's very, very complex. And there are if I'm not mistaken, making hundreds of millions to corporate and, and and companies. So that's a So in this example, I'm going to very simplified authentication. If you need to hours video on that subject alone on my YouTube If you're interested, check it out. But without try to add authentication to our CRUD app. Now SGS and authorization. And behind the hood, it uses for Express GS with a lot of strategies. So you zero Twitter govt and has a lot of functionality just going to use G wt. So basically the user will a G wt, what is it readable T, I have a video on with a signature, some data and some description it is using. And basically inside it to say, the information that the server could pass to we could pass that the sub which refers to the Vladimir, in my case, and the email could be claims as you want, though, all those fields you can put an expiration we can put a creation And you pass that the server creates that passes it back to the browser. So every time it sends it over to the server and the server says This behavior is quite similar to sessions, except with each request while govt needs to be passed, they solve pretty much the same problems, same problems. Of course, some might argue but I don't necessarily subscribe to that point of we should at least show them how to do it the needed packages, we need to install quite following the steps. Of course, all the code below this video. But without further ado, let's So what we need to have we need to have passport and passport to local we don't need authentication. So we don't need passport local NES GS passport. This is basically the passport of a, a module for Nash Yes, for passport. So we add those. We also need to install g WT specific govt package of passport. So it's a bit a lot of the steps everything is going to be okay. And we G WT thing because no library and they don't have repository. And we are going to save it as a for development dependency in types password TWG. Right. And let's see how we can use them in regarding authentication, of course goes nice thing because everything will be organized that we need to import is the G WT module. So WT is basically used to sign in the code tokens. so it just kind of a niche yes modularization beginning that uses passport. This is a true kind So the reason why I'm saying that is that this we library, we are going to kind of put it in first time you see that kind of pattern, it's G WT module. So this is to sign in decode the the And there are several ways to do it, you can to sign with a secret, you can provide it here, like to leave it blank, because in most of a refresh token. But most of the time when refresh token. And the refresh token will have from the access token, and more about those declare the module here and customize it further this is to sign in decode JSON web tokens. So we go here. And since it's a module, because also has a what a service of course, well, we need this DWT models is registered inside this module. make it accessible there. And the use case of that ahead and do it. We need to import it here as service. Right. And this is imported from DWT you can also just check the package and see what's and some interfaces. And I think it's actually a the libraries that you use, it will allow what is inside instead of just blindly following out of nowhere. So we have signup and sign in? we actually need to return tokens. But to return like this user information and transform so we need to generate something like that, and ID. So let's go ahead and create a function And I like to put it in a sink as well. And this sign, it's going to be user ID, which is going be a string, so we're going to send the user ID something like that, we can get those two or assume that all this is the user ID one. So first is that he has authorization to pass action. So this is the kind of information and kind of trust what's inside. So we're going let's call it data user. Let's code of the GW T's kind of convention that that a sub field. And let's add any field that we And what we're going to do is that we're going come from Jason Web Token library that you And the first thing is going the second argument is going to be a options for secret secret information that we're going to sign So if a user comes back with a token ad with we have signed it with our secret password. And going to be more descriptive payload. And the want to set when the token will be expiring. So that means that once we give that token to the for 15 minutes after that, the token will be we also want to add the secret, of course, secret up for the secret. Since it's a secret, we should into the MV file as well, as called GBTC. Correct. And let's copy that and use the same Prisma service, let's import the sorry, Config Service. And let's get that the govt secret. Here we go. And since we're interesting function descriptions, like the Right. And here. And for signing, for what we do is that we return this sign Since we return in a synchronous function, we if we do some asynchronous operations, when with we don't need to put it here. The code will know And we don't even need to do it, the user here, the user here. Awesome. Let's get back to our we do sign in, is going to return us. Of Silly me. The server is running no And now we have a text, which is not a text. But it gets us the the JSON web and paste it here into govt.io website, we see and our email. So this information that we have into the next part, one thing that we might want because here is going to return a string. And of text HTML, I'd like to return a object. So instead Here in our sign token, we can I have noticed that usually, the have this snake case convention. And we can just course, is going to complain because our type now should be promise of object access token, which and we execute the sign in again, we get a object next part, the strategy part, we have generated a to pass requests, protected requests to our the logic that will be able to intercept that validated, make sure that it didn't expire and the token is correct. And then only allow on our platform. So to summarize, we have written It returns a access token to the user. will call another route, for instance, the current user and He would provide in the that bearer space. And that would be the access bearer token is correct is called a strategy. For that we create a folder in our module And we'll create the strategy which is strategy, the G, the Ts, export class, G she has documentations. Let's check it out. Here. which comes from the NES GS passport module. And this passport, DWT library. And what it does calling super. So it calls this module this from the headers as a bearer token. So it just of format bearer space token, which is a standard by default. So we don't need to set it to false. of the access token which can be useful when point. And it takes the secret key as a as this thing that we have defined here, we Well, we need to allow the strategy to decode that the code, but more to verify that the signature of So we know that the token comes from this server The jeido which is strategy should extend passport and it should take the strategy that And it has a constructor because we are extending the constructor of the parent class like that. that of that password strategy class. So we And delete that. Because it's false by default, basically the secret, right? So this class is right, so it can use injectable. The reason just to make sure that we don't we know And it's for validating the D token, the access it can also use dependency injection under the inject Djibouti and inject the config and this that secret from the environment variable and here is going to be config Config I think we call the govt secret everytime I forget everything's okay. The only thing that we need to Baron export, which is a good pattern. And we So NES GS is aware of that of the strategy being And that's all we need. Let's go ahead and start instantiated, and we now have the DWT some of our routes with that strategy. That means valid strategy here we are using CWT but if you Facebook login with Google. And they have their So again, we generate the token with the auth decorate other routes with. So only it. But we don't have any other routes, any other let's go ahead and create one in the user module, I would name my controller users based on implement a simple get endpoint is going to be get will catch any any requests. So it will catch any it will actually catch it with that pattern. the pattern of the controller to catch it. it will try to catch it at root, which is not and undesired behavior. But in this case, call that endpoint with users slash me. And in me, It's just a drink, right? Right now we are not and CO users me, and let's actually delete that, is going to return us user info because we have but we haven't protected it right. So there condition that will say, Okay, if you meet certain logic, else, we are not going to execute that. To And again, you can use the nest GS documentation a function that will stand in front of a route or not allow the execution of that endpoint. In And if the strategy digital which strategy is route if not, is going to block it, you can of we can use something that has already been passport module. And it's not called. So to use you can use pretty much everything at a global it at the route level. So in our case, we want to token. So let's go ahead and create that we And in the youth guards, we can And Neji has passport, the module that NES GS passport, it already has a guard if we inspect the code here, we see that will it has some interfaces. It has passport It's not guard and basically. So it's Nash's that we can use. And that works very Let's go back to the user controller and import guard. And here in the parenthesis we provide what guarding for. So it's G W team. And when we create that strategy object that comes from passport, it so so you can assign any key that you want. For leaves it like that. So it will be identified have a refresh token, you can do something like you can give it any name that you want. But by can leave it here Djibouti, I will prefer to leave going to be a bit less of magic, because the first how does it know that this job jadibooti is we are going to say that, Oh, this route should insomnia and try to use the same request again. it's because the strategy is being executed. And an error. So let's recreate a bit the flow, I get me route, a signup and sign in route. So let's lad@gmail.com passport, sorry, password 123. And that access token, we can use it in our bearer right now if we use a request, right now, required any we haven't given any bearer token. Bearer. And then we paste the token. And now Let's see what is going on. This validate is in the in the GW strategy, and it's validly And it's going to take a payload Cool. One important thing that we forgot valid function. So the token is going to be And then we need to return it. So here we can we can return the user. In our case, we're just by returning the payload is going to append the It sounds a bit confusing, but under the hood get the request and the response of express with in the beginning of the course, right? What the object to the request object, so we can use it payload. So it's going to be that object with get back to the strategy and just run it again. the console log the payload here, as I said, our email and other information that was contained And let's see, why is it useful for us? I said that the strategy will put that decoded value we pass in, the validate function is going object of the request of the or the or Request. Actually the Ric Rec. And Rec object Express. And we can do console log user is equal even expressed now that a user is possible because its identity can be appended to the log that is going to log the payload. here. So if we run the requests, again, we'll come the same payload, but from the controller, because value here, let's say hi, Here, because we basically attach whatever we user object, right? Does that make sense? If that going to build upon that concept. And I'm going to that means that we can get the information of it. Since we have an ID, we can get a user by the get the user by that email, everything is that requests the users me endpoint, let's we can close the strategy file and come back to do now is that we need to get the information of So now we need to get information of the user and ways. In that example, we are going to get the validate function. So on top of having Prisma service and here we can get the the object it's going to have a subfield which have an email field, which will be a string, validate will be in a sync function can get the And I forgot to put private. The reason why is because if we do something use this because super must be called before in the rest of my application, there's no point just means that we declare the So we don't need to do that I can leave it config dot get. But here we can use private user, find a unique ID is going to be very important thing to notice is we if we Right? So the user will be now if the user returned. And if the user will be found, that user object on the request. And the thing that we we don't inadvertently export some sensitive in our user controller, what we can do Now if we run the requests user, slash me, access token. And now we have our application information of the user. So that's quite cool. But before I told you should not use the request And this is correct. So we can fix that. clean. So this is easier to do. So let's start a string somewhere. It's called the magic drink. by abstracting it in its own class. So let's be part of the odd. So let's go ahead new father guard, and again, the Baron export guard.ts. And what is going to do is going to just be a class jadibooti guard. And all we we are extending a guard with GE WT strategy. And and, and we need to export that class so we writing out guard, like that, with those strings, and import it in our user controller. jadibooti guard. And if we run, if we check can even get the information correctly. Oh 401. similar to what will happen in our application, we And once it is expired, you cannot use the new one. So let's go ahead and create a request 123 We get the new access token. And then we come a new one. And if we send the request, it works go ahead and fix this. This is a decorator. we have made a custom guard that extends the But we can also make a custom decorator that will and return it back to us. So now we can go in the ot functionality, right, we can create And again, export the burn with a burn export. puram decorator. And I don't remember the syntax we have documentation, so use it when you can And in the custom decorators documentation, we that you can put them in the parameters of your defined, you see that you have the request, You have IP headers query body that we have a custom decorator, for instance, to get the user it is like that. So they just copy it. And I'll create our decorator, let's call it get user. And that's it. It is creating the params Get User right, and it in fact, it only knows it. And what it does is it can take a data that you But by default, it's unknown. So you don't you it's actually gets, it actually gets the execution understand that NES GS is an abstraction right? Express it can use any other protocols. Here, to HTTP because we're using HTTP, but sometimes Or you can use RPC for something like like micro get requests, there are other things that you can we want to get the request. So it's going Library, right. And then we can do something with Express request. If that makes sense, and then it's going to return whatever we want here, whatever we return to it, and is since we have used the strategy, in our case, the Right, that's all we need to do for the custom File, and in the user, we want to use the Baron decorator file. And here, we don't need to put And here user is going to be of type user. And the beginning of the video, I said that Prisma very cool. So now, we can say that this variable schema. And now we can just return the user and can reuse it pretty much everywhere. Now, we can on the controllers level. So that just means while it will require you to be to have a token, you are, which makes sense. That way. We if we Edit User, well, we want me to copy the guard here So let's go ahead and run our requests again, and in this case, you don't really want to pass the So you can say I just want the ID and then it's So you can say something like that. And then if you want to do something like that, it's quite And you say, well, if if data if there's something and data will be a string. And it could be return the whole user object, if the the a field from the from the user objects. And here, we say we want to is going to be a string. And we can before Let's run the request. And if we come back here, parameter cannot follow an optional parameter. Let So instead of doing like that, and this is true, here, the old order kind of metrics. So we the data could be potentially undefined. Let's a log of our email and the same time we get our clean that up. And we don't need to get the email guards. We have created quite a clean logic quite organized, and everything has its place. and it allows basically you to save Have some code from a from a visual point of view. For instance, And that I haven't showed yet. It's HTTP code. So you send back a 201 HTTP code. So if we go ahead code will be 201. Right? So that just means that that's kind of a standard, you can of course, HTTP code. That's the decorator. And inside the for instance, it could be 200. Gnaeus, also which is error prone, you can return accepted found and it basically means So and if we put the mouse here, we see that code that is that are used in the development. for instance, that is very known for or for 401, bearer token is not correct and forbidden, for exception. So we can do that. Obviously, two Oh, but by default, a post request will change that. However, when we sign in, we don't the code 200. So we can use it 200 Here. it can be used to sign in and get it to oh, that's GET request will return 200. So we don't need implemented quite some features already. And you soon implement the user routes. For instance, the and application will start to grow, it's going to run all those kind of tests manually. Imagine you test several use cases, for instance, like, Oh, admin should be on boarded. And then it should oh, my God, it's pretty much impossible to test There are three kind of main levels of testing heard about, unit testing will usually take any the sign up function is going to mock any for instance, argument or connection to make sure that this function is executing and is working correctly on that unit level. However, you need to actually practice a lot. There's a it can be really nice when you have a project that will respond through years and years of in terms of your time. However, in most of the testing and integration testing. So we have unit integration testing, will kind of take several because, by default, it separates our application odd functionality on it. Well, I can load the odd Module. And I can test only all those three I can just test something else user user well it needs to use the auth module. So we're going but not the bookmark module. And we can can you define some segments of your app and you test database, so on of having a dev DB that I I will also have a test DB here in our Docker every time I do my tests. So you have integration end to end testing kind of verifies a very high signs up signs in, he requests his profile, he interact with your app. While integration testing, well, is the same token working correctly, is it are the exception throw correctly. So this is more of time, usually, it's estimated that testing have spent on creating your app. So if you have you'll probably spend at least two weeks testing there's test driven development where you we have not done that here. And it can solve in our small CRUD application, what we can do end testing will allow us to kind of showcase the we don't need to go into details and If you're interested by that, you'll probably be that on my channel. So if you are interested about well be my guest, there's a one hour video on the end to end testing. And I'm going to use a library developer of NES GS. And I have to say, it's quite it's called Pakhtun. By default, NES GS uses super we are going to use Pakhtun je s. So without to end tests. So we don't have to jump between our let's start with that amazing endeavor. And first So pack to me is an amazing library for testing And it works very well with Graph QL. And use straight away. And to install AES to install it with factum. So before we start, our test will need to consider set up a test database for our end to end tests. separate from the test dB, so we don't delete And the second thing is that we'll have to set cleaned up every time we run our tests. But before file. We can just go here and delete everything. a module. And we're going to take the whole global and we can create a test module out of it. And on with insomnia. So let's go ahead and first, app content. And inside that app, and when we should pass just to see that if our script is because we don't need the server anymore. We are development. We are going to write tests and write So The way to run that file is through tests end for us by nursery's. So yarn test end to end. And we have a past test, nothing really happened. But yet. So let's go back to our test and create what we're going to do, and it's it's kind of a hook that is provided by jest, both describes come from jest. And we're to send the request to our server and to analyze So before doing that, we need to create a module come from from NES testing. NES GS Test create testing module. And here we import. here in the app module. So we create a module That's the easiest way to do it. app module for And we are going to say compile. And we just import everything because everything then is to well, let's see Right? Amazing. Now, what we can do is to avoid the test. To avoid that we have to go here and kind of automated. So the run automatically So we go back to package json and say just watch. to disallow the cache of the test in case we might be cached. So that's fixed as well, let's now it should be running continuously. And if new test, it should automatically recompile it. application. And if I press A is going to run all just I would say flow, you press W to get more And let's delete that test and, and see if we let's add a couple of things. Basically, what the server. So anything that we have defined In our testing module here we use Global pipes. in our tests will not work. So we need to also have the module compiled, we need to run a win to So we can say app is equal module, dot ref. Create he's going to try to emulate an app. Here, it just integration testing. But since we really want app we can abstract it in name in the describe And now we can include the pipes. Otherwise, be as close as possible to our real server. And at kind of start the server and when We are done. we do app close. So we close the app. And we see This is our starting logic. This is our teardown about the database. Well, by default, NES GS, we need to have a dedicated test database for our So how are we going to do it? First of all, let's So just copy here and called sorry, test and 5435. So it should not be running on the And the rest can pretty much stay the same. We can that we have a we have the scripts for the dev dB, test dB. So let's copy that and write and and just copy all the scripts here. And dB. Test, remove and DB test up. So for the test, the B prisoner deploy. And here remove yarn DB test up, and er prisoner test, is that Prisma does not manage the the environment load the environment, the database URL from the be a bit more specific here. This means that the environment variables. And if it doesn't find one thing to work with Prisma with because you can just create another.in the work. Well with that the cleanest way I found to a NPM package called dough 10. CLI, so let's go So what is going to allow us to do is in our kind of scripts. So by default, if we just this environment variable. So if we don't do immediately from this one, right. However, if we, such as in the the test, it's a bit more tricky because Prisma will automatically only get the and it cannot know about it. The Config Module For instance, it has a variable called end file variable ease, but we will have to create a lot it's better to use the 10. CLI. It keeps our code we just need to include that library here. So the dot env development, we don't need to use using this one and this one will override any if we use the test ones, we need to inject you do you just do the n the E and you just and dot txt And then you just execute the rest. does need to be aware of the environment we also need to make sure that the NESs GS is not this one, but this one. And for that we also hyphen, e dot and the test on the test end to right, and let's come back to a dot and here, and implement that new string, but instead 5435, which is the right port. Now to test it all, and kill it and do yarn test, end to end. Also, an for test and twin. So when we run the end to So it's going to clean the database, the test on that test database. And it's indicated in package that Jason scripts, so we just say if we execute that, this is the hook that's DB test, restart. And just to make test restart. Okay, let's try So we see that the hook is working. And everything that the migrations have been pushed into our session, and I just do docker ps. And we have just just now. And it is the database And this is the old database on port 5434. this database has the migration, all we need to do is also using this the 10th file. So what we this one with the same technique that we have And it's MDX because we are running it And that should automatically connect us to studio is blank. However, if we connect will be connecting to the dev database. And here insomnia. So everything is working correctly, for our tests. And let's come back to our testing process, feel free to drop them in the comment possible. But all the code here will be available this video. So if you are stuck somewhere, just everything works correctly. And yeah, let's start test DB via this environment file. Everything module. So what do we need to do? First of we need to make sure that the database has been end to end tests, the whole database is actually run our tests in the same kinda just session, we to restart the Docker container because that seconds. And we don't want to wait all that time. tell Prisma to clean everything that is in our So because we have a just end to session that is We need to do it manually. So it's But let's first examine our schema to make So what should happen here? Well, every time we and the bookmarks. And sometimes there could be is linked to a user, right? But what happens if the user, first, the bookmarks suddenly might be problematic, because that can create errors, that elements are deleted in the right order, we and then the users. But that can be a bit 20 models, so your teardown logic of your something like that you can say, on Delete. And we is it is the kind of the parent of that when the bookmark should be deleted as well. To I'm not going to do that, I'm going to go with that the bookmark is deleted before the user, it is really good to have a on delete cascade, the data in your database. So for instance, you say that the user decides to delete a category, in that category? Are they kind of Or do we delete them as well, in our case, if a of be deleted as well, I don't see why would we But in some application, you might want to keep that it is possible to have those kind of hooks Because I don't want to run the migrations, The other way is to go into Prisma. Service. And Clean dB. And what does clean dB? Well, we need the bookmarks and the users. So we can do return like that, because this is actually prisoner. So So what do we need to have here, we need to the bookmarks. And of course, since we need to do you're right, except that Prisma kind of optimizes the bookmark. So to avoid that we can use to make sure that the things are transaction, and we just provide an array and need to delete the bookmarks, and then we delete can be without a user. And we just need to return This is our teardown logic that we need to run to the end to end test in before all hook, database is reset. So how do we get the database? because it uses dependency injection. So you Prisma service here. And now we can say, and we can get any provider that we want. It's that Prisma service and we can put that into the await Prisma clean dB. So it's quite cool to do nice experience. And we can come back here. And we prisoner service. That can happen sometimes Nigeria to recompile the files. So in restart the server. And that should work. So if you are doing major changes to you might actually need to restart the end to end into JavaScript, right. And that's it. And let's we can close that collapse this, we don't need to either. Because as soon as we close the app, the So we are quite happy. Now let's create our tests and we will have bookmarks. So you notice that I actually write the tests bookmark logic is because that will allow us to our application before we even build our code. sign up. And there should be signing and that's pretty much all the race, then we or more like get me then we should be able to edit get bookmarks create bookmark we We should be able to get bookmark by ID maybe we will have our CRUD application now next year's test. Let's go ahead and just create a should sign up. Let's see that we have should sign up we And let's start by that. So this is kind of run our tests right our tests actually so to run the tests was packed on we first need to So after that we have imported Pakhtun. We can a request making library, it needs an API, it our servers, our NSGs app, it just has initiated start a server by providing a weight dot listen. app to listen. And now we can do the request we can provide a callback function to that test. And then we provide the the request type is a post up and then we need to provide the body as well and it will take an email which will be be one To free. And we will provide that of 201 Because we're creating a resources. So took 42 milliseconds. And that has succeeded. If we can just call inspect, at the end of the locked, along with the code and the headers that is powered by Express, the status this is a bit verbose because every time we're this is called also the base URL. So what we can post request. So we don't need to repeat it in a said base URL, and we can just provide that base we can just write out, sign up, that is much effect. Let's get rid of the inspect to see if So it just took a bit more time, but it Okay, now, it's amazing DTO, we are going to flow. So we can just move it above. And let's we are going to delete it to do here, provide a Since it's a end to end test, it will first and then it's going to execute that code. And how it works. Amazing, everything works together. and that we can sign in usually when you write a your test will will fail. Alright. So for we should actually write it should throw, throw also write all that to test if that logic will, and say that we expect a a code of 400. So expected because we expect the error to be thrown bad user input. And we also need to provide a do is that we're just going to provide just the reuse that, that detail. And let's see if our test next we can also check the other way around. So instead of having the password here, and should also throw 400. Right. And we should throw if not that you nobody provided. And we can do pretty much the same with and test it with a sign in here. Except Let's go ahead and check our tests. And everything of kind of end to end testing. It doesn't really with. So we might return the right status, but is not saved in the correct format and that we to end testing. end to end testing is not the is there to make sure if the app is working end are working more or less as expected, if you actually create integration testing. And Now, a very interesting part is that we need to we need to send the bearer token. So Pakhtun us to store a variable in the packet and create a variable somewhere, for instance, access token, and then assign it somewhere what we can do is that we can use the store let's inspect the body response that's going to access token. So we can actually save that value and use that functionality. And it's basically a data. And we can choose where what we want to user access token is kind of like assigning a access token. So it's going to get the access from the body, which is in the Jason and is going we can reuse that variable in our requests. get current user return packet on the just copy that need and it should not have a a an authentication headers. And if we check get current user, we have a status of 404. less So users? Has that controller and me, users me, 404 cannot post it's a post request, of And now it says that it's it's 401 access token. Right. So let's get go ahead have passed them in insomnia. Remember here bearer space and the access token. Let's go and we can provide the object key value. So the to inject that variable that we have saved here, this thing a bit like what we have in in template here for store. And you can put the name of the a correct answer. And we can even inspect And you see that we got the user object that was testing is most of the time you will just test we have tested all our routes. And what is left and the write the logic for create bookmarks, get actually by ID, and delete bookmark by in the next part. In the next section, we our CRUD application. So what we need to request, and the crud requests in the bookmark And we are going to need the service here, we And we can go ahead and create our, our service. create a service for us that we can now use, let's Edit User in the same fashion that we have done probably in a sync function is going to take And that's pretty much it. And it Max service. And that's yeah, that's it also needs to receive a DTO. And it's going So Edit User DTO, the Ts. And it's a class, Edit edit the email, we could edit the first name string, and last name, think and all those edit the email without editing the first name, So we can also provide the class validator string is string. And all those It's optional is optional and mean to export that, export pattern from Edit User DTO, let's clean The patch request, edit user will receive going to also get the user and just the user ID. And he's going to call the function in the have video edit user DTO. And let's just call this is done return this. We have of course we also need to import it through dependency And now we can use that user service here return on the control side, it is now done. Let's go back So what we need to do is to update the user with an email first name or last name. So we can trust we have this pipe with a widely that's true. So something at least something in in in our in await this Prisma user update where ID is user ID can just destructure the DTO. So if the video and before returning the user, we can delete the logic. And before continuing any further, let's go edit functionality. So we come back to our tests. have edit user, right? So we go here and just is going to be users. And it's And the headers are correct. And we need also user DTO. And let's just edit the just the email. Lat at code with blood, that embody the T O and let's see if we can let's see this test executes. So here it goes. let's maybe inspect that. Where's the answer here with the updated email and with the updated we can also make our tests a bit more defined. the body contains a field where we expected and an email of that, well, we can just say expect going to be detailed that first name. And And let's see if our code executes. Cool. Our code you can say expect body contains let's say I because false value is not part of the body So that's a handy way of checking if some fields Okay, now let's go ahead and create the routes for anything yet. We will need to have a controller So nest G controller, bookmark, Miracle we can clean that out. And here what Okay, bookmarks, maybe put it here as bookmarks. need to have an access token in order to use those Have we forgotten something else? No, I think just work with bookmarks controller right all the bookmarks, so it's going to be get get bookmarks. We also have get bookmark And maybe delete bookmark by ID. Let's check create all create bookmarks as well. So we get by ID and delete bookmark by it and we also need that's it we need to have a positive decorator get decorator for get bookmark by ID by ID. We also have added bookmark patch and delete is going to be crud thing. Let's also import the service because Private book mark So bookmark service, book mark, in the bookmark service. And here we go very well, now all of them will And it will have to use user ID. Number. And we need to fetch the ID. Same goes for here. Same goes for here. And same goes for there. And I can check if a bookmark belong belongs to a bookmark, we need to make sure that we are And when we get the bookmarks, we need to make user. That's why we in that, so the Git bookmark to have a DTO, either, but it will have to have a book marks by ID forces, two, or five, well, another decorator. Here around that also comes and the Name of that variable will be equal to to put two dots like that. And similar to what And there's going to be book mark by default, this is going to be a string, and pipe, the Create bookmark will have to have Index Ts and create book mark that detail And what will the Create bookmarklet to have? has a title description, which can be empty, no go ahead. And let's add that title is a string And link a string as well. And is drink is drink. And this can be is Here we go. And we can export Now we can close it all open the the DTO will map to create bookmark DTO and edit bookmark DTO will also have something neat way to reuse our code. And here we have should be capitalized here because it's a class. And the next thing we said that we want to have Detail the Ts. So what we can do is to just And everything could be optional. That's This is this is for TypeScript. No this is for We can change title description and link and DTO folder. And then go back to here and the patch just need to have the one last route, delete the ID here. And we can just reuse the same Here we go, we have everything that we need the service side. Let's jump into bookmark we need to have user ID, which is a number and anything else yet just to user ID, then we still need to get the user ID. But we also and create bookmark, we need to have the user ID. since it's going to be an object, edit, bookmark DTO. And delete bookmark by ID Like, like here, and that's pretty much our R values here to the service, return this we also need to do the same here, change it here. And you also have the bookmark purchase similar except that the And here as well, it's going to be create bookmark edit bookmark by ID. And Since it's added a bookmark by ID, you say to be edited and you provide the body so And let's just copy it here and and then the DTO. And of course, we need to And delete the bookmark by ID is going to bookmark by that by ID user ID and bookmark it. all the logic pretty much programmed from the from and jump into the service to to see how we one by one. So when you write code, it's So you get an immediate feedback on how your code are running entwine tests. But usually you would since the application is quite simple, database to make sure that everything is as they should be. We have our first tests that logic for the second one. So the first thing we can first get the bookmarks, get empty we want to kind of simulate the user experience with end to end tests, let's actually close So we have the signup functionality, the user get himself. And then he can edit himself. So we then the user will go on a dashboard or something, haven't created. He hasn't created any bookmarks Let's copy this code and simulate Return Pakhtoon is going to be the headers can stay the body, we don't need the result. And we see that the body is actually because we haven't written any any logic yet. and write our logic. So let's import Prisma Prisma service. So get bookmarks. We need this. This Prisma. Bookmark, return file, is equal to user ID, we can just leave it like that are linked to us to the user that is doing And here, now we have an empty array. And because it's not going to find anything is going to return of elements, right? So what we could say is that what the body will expect. And it should be an Then we can go ahead and continue with our logic. And we can write the code for create a bookmark. return Pakhtoon spec post bookmarks with headers So let's go ahead and provide Create bookmark the deal. Okay, it should be first bookmark. And the link will be Free Code Camp. I personally liked the needs are really well done, man. And I'm Here we go. And we put the DTO into our with body. It should expect the status or two or one because Well, obviously it will do nothing, because So let's go ahead and program the logic here this make it a sink and create our bookmark bookmark create data. And what do we put a user. So we can say user ID is equal user ID. then we can return the bookmark to see what it going to check here and inspect the, the, And we see that we have, we have created the which is the current ID and that is the we see that the ID is three is because we're not cleaning everything, we just clean there's another table that keeps track of the normal, that is going to be incremented. But And anyway, you should not in your test relate created a bookmark. And we can go here into let's go ahead here should get And let's see that code executes. Okay, cool. We had to get bookmarks and wish we And we'll probably see that we have an array. bookmark. So now we should have the get bookmarks that the body should be an array, and it should to make a very simple test is that expect Jason bookmarks should have at least one element. So logic for getting the bookmark by ID. So the way which will copy the tests that we have already. we can write it like that. But we don't know as I've just said, we don't reset the ID is the for elements. So we need to keep track of the So let's go ahead and where do we create it to use the stores API, like we have used for book mark ID is going to put the ID field of with Pakhtun, when to use their own kind and with params with path params. And it's going going to be the value that we have saved in Very well. But now let's write the logic. we have the function here, get bookmark by ID we are going to use Find first. And we need to And which ID is also a a bookmark ID provided our logic. And we see that And we can go back here and do some body contains and it's going to be what is it this number which will which is Okay, let's see that works. Perfect. Let's now bookmark by it. Before we go any further. get bookmarks. By user ID, that's fine. Get We pass the user ID and the DTO that's fine. And do a bit more work. So first of all, we need to be if user owns the bookmark. And then only we first part is quite simple bookmark is equal where ID is called bookmark or so the bookmark add specific ID does is not equal to the user ID. That means does not own to the current user, then we throw access to resource denied. That's it, and And we can clean that out, we don't need those throw exception. And again, it's a god condition. below. So if the bookmark belongs to the user, we can modify the bookmarks. So we will return where ID is called bookmark ID. And the data will and we can come back to our tests and just copy Edit bookmark is going to be a patch bookmarks So the detail is going to be here and the add the description. And the description was and the description. So let's just copy this and we pass that DTO to the body with body. Here, we expect the status of 200. And let's that we had the right things. Awesome, we had and description to the to build those values. Let's expect body contains DTO dot Let's see our test. Awesome. That works. And now let's run our last test. So usually when two or four. Let's see if we can we can actually delete book, delete bookmark. So it's going to correct. We don't need any body. We Okay, one thing that I like to use when I delete So we're going to modify a bit HTTP code, like which is which stands for code to have four. And we now have an error. We can modify that and we can return back to logic here. And we don't want to return anything. we also need to check if the user owns the And if the user owns a bookmark, then this prisoner bookmark delete, And that's pretty much it that will And just after the Delete, let's make another And what we can do is that we can just And and expect the Jason length to be to And yeah, amazing. We now have a entwine tested enjoyed this tutorial that you have there's a lot of stuff that we can still do. We we can run it in the cluster mode through pm with that library called Ness GS. Furthermore, to integration testing and unit testing. But so taught you how to use NES Yes, and how to make Vladimir, I hope you liked this tutorial,