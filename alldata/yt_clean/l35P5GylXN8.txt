Welcome back, everyone, Dan Vega here. And today we're going to be talking about I've done a bunch of videos on the rest and above. But today we're going to be answering a And it happens to come from a friend here just go ahead and read this to you. Hi, Dan. Hope all as well. Do you know if there's a way or a good concise request and response logging for the new rest client, which I replied Daniel. What information are you trying to And he said, really just the body of the codes that are associated with it. This is very easy to do with something I've seen how to enable the logging of that logs far too much detail. And I agree. So there's a way to get at the underlying using and go ahead and turn on logging But that is pretty verbose. You'll get a lot out of there. So we're going to do that today. There's a couple different approaches to One, you can include the spring boot and spring boot three and above. And any calls kind of made out of the us. So we can kind of get at those if we need But if you just want some concise the request. here's the response and here's the status Can we do that within the confines of And the answer is yes. Now, once we read in again. And that's because input streams in Java So there is a little bit of a trick to get into the tutorial. So here's what we're going to do. We're to talk to a public API. So we'll talk to something like the JSON and that is just an API that we can all And then we'll take a look at two We can, when we set up the rest client, and go ahead and read the request in and read the But this is on a per rest client basis. What if we wanted to use this interceptor So what we'll do is wind up going in and client HTTP request interceptor interface. And that way, anytime that we kind of set we can just pass this interceptor in So this will make for a reusable applications. All right, so to go ahead and get over to start .spring .io. We're going to create a new project using Spring Boot 3 .3 .5 is the current And we'll go ahead and fill in some information about this. We'll say dev. Dan Vega. The artifact will be, let's just call it Go ahead and remove that. And then I'm going to go ahead and set up Actually, the only dependency that we're This will bring in the support for a rest We can get a rest client auto -wired in have a rest client available to us. So that is all we need generate. This will download a zip file for us. You editor you're most productive in. For me, that's going with that, what are we waiting for? Let's write some by creating a post package here. Let's call this create a couple different things. The first thing that So we are going to say new and Java class And this is going to be a record. This is And we're going to align this up with I'll show you that in a second. But that's going to have an integer ID, So that represents a post in our system. Now what we'll need is a post client. So This is going to be a class. And this is a call out to the JSON placeholder So I'll get a couple of things here. The I'll go ahead and declare a variable for So we'll call that rest client. We're injection. Now, the way to get an instance So there's a builder. I like to call this And then we'll say builder. build. Now, what we want to do is we want to set going to talk to. In this case, it's going to be the JSON So if does that load up, nope, let's go And there's our JSON placeholder service. If you go in here and look at one of the 100 posts. And you can see that's why we modeled posts around it, user ID, ID, title, and So now what we can do is we can go ahead to. I've done this before. I'm not going to type this out. the past, this should look pretty familiar. This is placeholder service, and this is a way to get a single post. actually log the request and response as we make a call to that So one way that we can do that, again, is request interceptor. So here when we set up the rest client, So what we do is we can go ahead and get execution, execution, Dan, and then we can go ahead my co -pilot is going a little bit crazy, completions there. Right. So now what we need to return the response. So I could return execution the body. Now again, here's where that tricky part response once. Once it's read in, you can't read it in around. that and we will once we get to kind of But at the very least what we could do is the request and log the response. So one thing I here. We're going to add one for logging the for logging the response. If we could go ahead and import and that one. And so now we have these response. So we could come in here and say log the body. So we can pull that in and then we can And this is going to take in the request. HTTP response. Now this is where we would actually need So if we did something like this, now we Now, here's where it gets tricky because So we can come down here and like in our log. Info. We can say the response was this and we But if we do this, what's going to is we will actually log the response out But when we go to actually look at the there is no response there. Because But let's just kind of test this out and So I'm going to run the application. I didn't log the request, but we could to. I'll show you a more complete example But what I want to do is make a request 80 slash we don't have a controller quick so that we have something that we And again, I think, you know, if you've this, so I'm not going to get too far into the We'll just say this is a post controller So this is going to take in the post a component right and now this controller ahead and restart this. We're going to give us all 100 posts from our external service and And there are the 100 posts that are But what you'll notice is in the council, response class. So let's go ahead and take a look at you see that we just have this response Okay, so what we actually want in the the response body, I'm going to have to We'll call this response body. And to get Get body. That read all bytes. So that'll give us a output this here. So let's say response and let's go ahead and rerun this And I'll go back to the terminal. And I'll run this request again. And what you'll notice here is that we We don't have all 100 posts coming back. But if we go over and look at the, where we're getting this in byte array we can easily kind of turn that into a So we could say new. string response. Come on. We want the of, we can just use the default character Or actually, let's just make sure we're Standard care sets, UTF8. So let's go want to see the byte array. And let's go local host 80 slash post. Again, we don't the logging, it actually logged it out. And again, the response. Once you read in the response, it's no longer ahead and return the response back to the client, it can't be read there is a way around this. What we're going to do is kind of cache another class that kind of simulates this. So this is one way of too exhaustive here because I think the that implements a certain interface will So let's go ahead and do that. I'm going place so that you can kind of see this and then what I'll do is we'll create different service. So let's go ahead and create a new And inside that package, we're going to So let's say new Java class, we'll call And this is going to represent a to -do Again, it's just kind of lining up with service. Again, we're going to do something client. So I'm going to create a new to -do And this one I won't make you watch me go We'll get back to this in a second. And then I'll have a to -do controller So I'll say new Java class, to -do and this will give us that. So the error that we're getting there is request interceptor. So what we want to do is create a new interceptor, it needs to implement a request interceptor. So what I want to do is create a new So let's say, , no, Why is my generate not helping? That's okay. Let's go in here, new Java class, and I'm Actually, let's call this, I think I So let's say Java class client logger And this is going to be a class, and it's interceptor. And it's going to implement the client And basically, this is what we're using Because it's a functional interface, we right there in line. But for this one, we've got to implement And there is that single intercept that takes in the request, the body, and So we have those same things available to But now what we're going to do is, again, request more than once because we want to but we still need to return that response So let's create a logger. We'll have that. And then what we're going to do is in So this is going to take in the request Then what we are going to do is get the So we'll call execution. dot execute. This takes in the request response variable for that. And then finally what return the result of our log response method, that's going to take the request and the get past this. The first thing I'm going to do is put in This is going to log the request. So it's going to say, here's the method. We're going to log headers. If the body the actual request. Now, I've split the log headers out to a in both the request and the response. So that will give us our request. Now, our response is going to be a little So we have our request here. We have a private, which is going to is the contract for this method. For our intercept method, it needs to And we'll call this log response. This We'll call this request. And then we have And this is response. So the first thing that we're going to going to do is we can just log out some status was, and then we can use the Get status code. So there's kind of our, there. Then what we need to do is we want to log takes in the response. Get headers. All right. So so far, so Now we're going to do something we did the body, right? And from the body, we're going to read in So that will give us a byte array that we And I think I called that response body. Let's do that again. And so now we have the response body. Okay, so here's where, well, actually, right? We will check the response body. If there log that out. Okay, so this is pretty much everything to, like, capture the actual response so that when we return this back Because right now that response body is empty. We've read it in So I am going to paste this in this is going to be a let's see here a buffering client HTTP response wrapper which implements create create kind of an instance of this, then the contract of returning a client HTTP response. So what here, when we return the, that's the response, what we really want to return wrapper. So we can say return new buffering client in the way there. So that's going to take in the response. and the response body. Because what that and the body and really just stores the Because again, input streams can only be read once. Once basically creating a new byte array input stream. This should just throw an exception, Overrides method that is depicted. Okay. Yeah, that's okay, though. Cool. So I think that will give us Now, if we go back to our to do client, Could not out of wire. Okay, that's okay. So that looks like that should be okay. Okay. So now what we do when we make a back over here and look at the to -do and we make a call to find all, so slash -dos in the system, but it should return them back to the again, the beauty about this is we just interceptor. We pass in this custom class that we've used. And again, you can reuse this in importantly, every rest client that we kind of create in the basically log out the request, the response, and the Let's go ahead and rerun this application. I'll go back to to Local Host 8080 slash todos. And we see all of the to the the council. We also see the to -do's should see more. So here is the headers. So we got the headers here being logged, and then the request should be in length. Here's the request. It's a get request to this the base of all of the logging that we wanted to but if you wanted to, you can come over to post with that client logger request interceptor. And now this is a again. So friends, Daniel, first off, thanks for that question. I me a big favor. Leave me a thumbs up. Subscribe to the We can't care. There we go. And we're going to be able to be.