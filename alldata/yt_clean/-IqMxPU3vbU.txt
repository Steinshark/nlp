In this video, I'm going to teach you role based authentication in React, which is a case to have in your application a certain part only by the user being authenticated, but also access that specific data. So that's exactly what before we get into that, there's quickly two is that I actually teach all of this and more in I teach in my videos, and you actually want to to know about React in a super organized way using that really hasn't been done before, definitely in the description. I promise you, you are not I also recently launched a newsletter that's love the name. It's completely free. And you week. You're also going to be able to find that All right, cool. So let's begin. So over here, essentially serve as a mock backend, which we're we don't have a real backend, we don't need one sufficient. So what we have here is we have a it has an email and this role property, we're if they have the correct role to access a specific we essentially have two functions and get user they actually have the same code, right? And again, there's no real backend, then they generate special. It's just doing math dot random, mock response status code 200, the authentication that's it. And then over here in the main.tsx because we're going to be implementing this as protected, and only allow a signed in user with So we have the setup code here for the router. and passing the router. Again, nothing fancy here. the way that we're going to approach role based to create the authentication setup. So using these user. And then we're going to be implementing the and determines if the user is allowed to see this I'm going to go inside of SRC, create a new I'm going to do auth provider. And this is going the authentication, calling the backend with the user to the rest of the application. And for API in React, I'm not going to spend too much time I have a whole separate video on it, I'm just but efficient way. So first, because we're working actual type of our context. So I'm going to come to be equal to and here we're going to put a auth token. Because remember, this auth function probably want to store that in a state of auth there's a reason why we put it optional. And like this. And then we're going to do exactly the to call current user. And this is going to also be we can import from type slash user, or no as well. string or user in this case of the user, and then want to state no over here is going to represent is not authenticated. So we're going to set it to or the actual user is going to represent the case we store it in a state a user or not token. And going to map to undefined, this is going to it means that we're actually in the process of point in time if the user is authenticated or not, and implement the rest of this video. And then in the user and want to log out the user. And So we're just going to do a handle login, this is because this login function over here takes no emails and passwords, that's not relevant for this the role based on how we architect all of that. void. And we're going to do the same thing with going to be the type of our actual auth context. I'm going to do const auth context equals create we're going to pass it here, our type of context, this to undefined like this, this is going to creating our component to be able to access this auth provider, this is going to be a component. context dot provider. And we're going to put because as a provider, we're going to need to which we currently don't have in this component. let's do it again. Children like this, right, we we can just create some types over here, and we can do props with children and import this And then auth provider props like this. And now we're one step closer. Then as we always to be able to use with this provider just to in this provider outside of the actual provider. that is going to be an arrow function like this. let's do function, use auth, just to make it be a function and it is going to do const context the auth context like this, then we're going to we're going to return, we're going to throw this. And we're going to do use auth must be used we're just going to return the context like if this is unfamiliar, I have a whole tutorial And I actually explained to you why you need then what we need to do is over here, we have a of our context, which is all of these properties let's start with the auth token and the current use state because that is going to be extremely set auth token equals use state, we're going this as a type, we're going to do string and it initially as undefined, right, this is going as undefined. So this one has exactly the same we're going to then do the same thing with the equals use state. And this one is going to be cancel the user over here. And we're also going to they start off as undefined, because initially, we're going to have to implement logic to change undefined. Then once we figure it out, we're in the case of the current user as a user or no. handle logout. These will be pretty simple, we're that is going to be a function, it takes no function like this. And here, we're just going to our login function, and actually get the response. going to import this from API slash auth, it gets the const response from away dot login. And here the response, because remember, the response is let me see how did I do it here? Yeah, there user equals response, and then one, right, we're here, at least in this example, we're just going second argument, and we're going to destructure here. And then once we have auth user, the only we're going to do auth token like this. And we're set it to user like this. Finally, because this is we're going to do a catch. If we have an error for token to null. And we're going to do set current we created our state as having three different mark over here, and then string or null or user or off as undefined, then we have this handle login login function from our back end, we're going to we're going to be able to set in a state our auth error for any reason, we're going to set this to going to let the rest of our application know that of a user and either it worked, so we have it in so we can react accordingly in the rest of our we need one more function, async function. async because we're not actually going to be handleLogout. And this takes no argument. code over here and just set our auth token and our you might want to actually send a request to there's no need to. We don't even have a function This is not a real backend. But keep in mind do this. But the concept is the same. You send a the user is logged out. And then here, what's the state of the front end of this provider to know that the user is currently logged out and this context provider, we do value, and then we current user, handleLogin, handleLogout. And now this? Oh, this needs to be async because our type async just to make TypeScript happy. There you go. these properties over here. And this component nothing done with anything role-based, and it useAuth custom hook, we're going to be able to That's good. Step one is done. Now, inside of the actually use this custom hook and actually access So we're going to come here and we're going to do actually check if the user has a token or not, specifically. handleLogin, handleLogout. And we're We're going to import this from our auth provider we have access to the auth token. We have the functions, so we can actually do stuff with them. Let's do this on click. We're going to pass this login like this. But let's actually check for the actually currently logged in. So we're going to mark. And then if the user, if we don't have Otherwise, we're going to put in here handleLogout Now, if we actually go and check the browser, auth must be used inside of an auth provider. I created this auth provider. And see, this is the this. We tried to use the context using this hook the provider in our component, in this main.tsx wrap the router provider with our auth provider. import this, and then we're going to put our There we go. We have cause and solutions and then for one second because our API simulates waiting we have logout. We have an actual auth token. because inside of app.tsx, we're only seeing that that this auth provider component actually works good. Now, let's move on to the second step. Let's what I'm going to do here inside of this component React Router to a protected route that we're going like this, import this from react-router-dom. And or path to actually it is and we're going to put as a link, we're going to do protected route like So now we have a link to slash protected and it link over here. Maybe we just want to actually do like this to make this call and then we also need go. And let's put, I mean, this is fine. This is we're actually going to get an error because we That's fine, we can just fix that real quick. We we can do path like this, we can do slash we can do perhaps a div that says protected we can go to protected route and we have protected currently not being protected, that's left for protected content on this specific route and also of the user, which remember gets here from this to do something very similar that we did here in creating a component that is only responsibility going to use that in here in our main.tsx. We're here with that protected route, pass it some roles everything should work exactly as we expect. So of the components folder that I just created, protected route.tsx. And in here, we're going to route component. So protected route component. And first going to start by defining some types. So And that is going to be first props with children, then we're going to extend this by also adding this can be optional, we might want to protect the going to put user going to import our user over the role property of the user. And then we're actually want to allow an array of roles and check role is within that array. And then here inside do auth allowed roles and we can do children. props like this. And now we have allowed roles and component. Now this component, as I mentioned, responsibility is not to handle anything related protect the route against a user and some allowed That means that in this component, we're going the state that we have in the auth provider This is a great example of following the single you have two different components, they serve two and use them together, you connect them together get the functionality of both components working protected route and we're going to do const user. because we're going to be needing to use the component. So that's going to be use auth, and like so. So now we have the user over here. And hmm, what is the problem? Property user does not not the user. There we go. Now if I hover over separate types. We have user, null and undefined. to handle each one of these specific types. So checked if the user is authenticated or not. that's our loading state, if you will. Null means the backend, and it was an error telling us that handle that. And finally, we need the user. If against the backend, the backend told us and gave inside of our application. So we also need to it's pretty simple. If we have a user, and if we children over here, right? Again, this component fine, we're just going to return the children. And the actual content that is being protected by this it's also pretty simple, we can do the loading So we can come here and do if user, current user, can just perhaps return, and we can do diff. And loading, we're in the loading state, we don't yet authenticated or not, sorry. And finally, we have when the user is not authenticated. So what we can so if we don't have a user, or if, and here I'm roles, right? So in this case, the user might component, and the allowed roles does not include and say, let's say current user, why do I keep then we're going to do here, we're going to return right? So if the current user is null, which means is authenticated, but we have provided allowed does not include...This is all that we need to of the user's roles and protects the content based This is great. So now with this, the only thing component and just protect this content over here. directly, we can pass our content inside, and here example, we only want to allow admin, which our the role of admin. So this should theoretically here, as you can see, we're currently seeing the So let's press login. Let's wait for a second. go here to protected root, you're going to see role matches and we are authenticated. This out. Now we're logged out. Let's go to protected out and we don't have the correct roles. So this Permission denied. We're not allowed to see this Now there's a problem here, if I reload the page, if I reload the page, it's actually going to show authenticated or not. And it's actually going to us to show to show a authenticated user is if the it inside of our app component, there we go, is this is not a good user experience, because on they should be automatically handled by the back request to the back end to make that check for us we're going to do is we're going to come back responsibility of the auth provider, because it is is instead of just only doing this on login, the component, we want to use the not the login which again, it does the same thing. But just do entirely different things, right. So we need to this with react query or some fancy data fetching we're just going to use use effect for this that going to come here to use effect, import this to pass it here an empty dependency array, this here, we're going to do literally the same code is paste it inside. And here, we're actually instead going to import this from API slash auth. And here That's because we just need to put this inside actually fetch user, user, and then we're going front, and in the body of the function, we're function, which we can call fetch user like this, mount. Now we have the same code, we're calling on mount automatically, without having the user better. So now as you can see, going back to the because this fetch already happened. But if I we have loading for one second, the request is because our user, remember, has the admin role. So If however, I go back here to auth dot API, and and then I reload, it's going to say loading, I am authenticated, the request work, there was role. So this is going to say permission the and say that I want to also add here, viewer. Now correct role protected content, right. So this you just wrap every component that you want to the allowed roles. And then everything just works, thing, it's really efficient, this is all the code then you have this auth provider component that is responsibility. And this also just works and you is very efficient, simple to work on. And it just that you need to have role based authentication in back here to the protected root component, I will a protected root component. But that's because the is going to differ based on the framework that using, and also your specific use case, maybe you actually want to do this in another component, unauthenticated, you want to show something else one to decide what you should do, it doesn't three different states, one for the user, one for depending state. And then you handle each one of about. And that's the only thing that I want you happy, you're happy. And you're now a much better that you do is you take this code, you'll be able the case for pretty much all my videos, take this understand why we did each of the things that we Why not another way, play around with this, get a if it breaks somewhere and try to fix it, because developer. And that is the only way they're going is capable of building really efficient code. If videos just like this one, make sure to leave here to subscribe. Or you can click here to watch think that you're really going to enjoy. And with this is Cosden Solutions. Thank you so much for