When deciding how to store large amounts of data, a key question is how to organize that data Let's start by looking at a popular tree. A binary search tree consists of in this case a unique number, and can point Binary search trees obey the property that any node's key, and any keys to the right of This allows for an efficient search we start at the root of the tree and compare depending on if the key we want is less At each step, we pick only the half of the tree saving time by not bothering to search parts At this point, we might wonder: if binary search in on only the relevant half of the search space, into three instead of two, so that at each step we But depending on the circumstances, That's because each node, instead of having first key would be to the left, keys greater and keys between the two would be in the middle. The tree is definitely &quot;shallower&quot;, meaning answer. But we also might need to double rather than just compare against one key, we might we'll often end up performing more But does more comparisons mean That depends on what operations take up more time. If you have a lot of data, say in a database expensive part of any algorithm will be the time keys the processor can perform very quickly, the processor needs to wait much It's in this context that the B-tree shines. The that can have more than one key. Maybe they have To demonstrate the idea, we'll use a B-tree Once we have a B-tree, search works just like and check our key against the keys in the node. but otherwise we need to search another node. However many keys a node has, it has a number of keys. This lets us know where to search: if we'll look to the leftmost child. If our we'll look to the rightmost child. our search key falls between, we'll look This process continues, one node at find the key we're looking for. Because each we cut down on the search space quickly, by checking far fewer nodes than a But how exactly do we create a B-tree? And where the tree is deeper on one side compared Let's start with some rules of B-trees First, the leaves of the B-tree, the those all need to be at the same level of the we're not allowed to have some leaves Next, every node has a maximum and a minimum And the minimum is always half of the maximum So in our case, each node can What happens when we try to add our first number into a B-tree? We'll place But wait, you might say -- we just said that the root node is the exception to the but all other nodes in the tree So let's keep adding keys to the tree and see will get added to the root node, in sorted order. maximum number of keys -- in this case, four. So It's not going to fit. So any time we need to split that node up. Remember that each take the smallest two keys and make one node, and What do we do with this leftover middle are less than this key. And all the keys in we can push this key up into a new root Now, this is starting to look more we're always going to add them at the new element comes along, we use the root and when we get to the bottom of the tree, That process will continue, with new level. Notice that most of the time, we just follow the B-tree nodes down to It's only when we completely fill up a node and perform a split. We'll split the node into two As we add more and more data, you might start full of keys too? It turns out this splitting for example, and try to insert a new key that start as usual by splitting the node up into two But the parent is already full, so when it's overflowing. If that happens, we split the parent into two nodes of its own, This elegant recursive algorithm preserves all the we split it into new nodes. And the only time the into two and create a new root node, keeping But we don't just care about the ability to delete data. So how Well, let's say there's a key we want to delete. starting from the root, looking for the key. That worked well in this case, but there about. Take a moment and consider -- deletion algorithm run into problems with Here's one case to consider: what but the node already has the minimum the node would have fewer than So how do we fix the problem? we'll take a key from a node next to it, In this case, let's take a key from the since we're going to be moving it to the left. we'd instead take the largest key, But we can't just take the key from the sibling because that would make the parent key in between key acts as a separator: all keys to the left of of it should be bigger. So we can't just move With a slight modification, though, we can from the sibling directly, we'll let the key and we'll use what used to This preserves the properties of the are to the left of it, values greater So this works, as long as we But what happens if when we remove our sibling nodes are also already at the Instead, just like when adding when deleting keys we might merge nodes our sibling node, and the separator between them In this case this works out fine, might mean the parent node ends up we can recursively apply the either taking from a sibling if possible, or The other scenario we need to think about is what tree rather than from a leaf. In that case, since that key was also acting as In that case, we need a new separator. And than everything in the left subtree right subtree. That means we have we either need to take the largest value in the right subtree. Either one works, Of course, after we do this, it's possible have fewer than the minimum -- but we just take a key from a sibling or merge So by taking care to always we've constructed a data structure that's Even though we have lots of nodes, we them any time we're working with data, waiting for data to be retrieved. And the half full and completely full turns out split up nodes when they get too full, and The fact that many nodes aren't completely most of the time, since often we in a node without needing to change These properties make B-trees and variants handling data, especially in databases and file its structure, and how it operates gives you what's really going inside your computer