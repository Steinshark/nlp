In 1997, the US National Institute of Standards for an encryption algorithm to become the Cryptographers from around the world were Fifteen algorithms were submitted for consideration, of debate and research and analysis. Some algorithms were deemed not secure enough, At the end of the process, one algorithm -- Rijndael become the standard. Today, AES is everywhere: it encrypts hard and many processors on computers and phones for running AES efficiently. But how does AES work? And what makes for a good encryption algorithm? That's what we're going to explore here; but When we talk about encryption, what we want and use a secret key to convert it into ciphertext. The ciphertext should ideally be encoded in that key in order to translate the ciphertext When working with computers, the plaintext, as sequences of bits: all just 0s and 1s. So what could this encryption look like? Let's take some plaintext: some sequence of And let's create a randomly-generated key: we'll assume is the same length as the plaintext. How could we come up with an algorithm that Well, we need some way to transform the plaintext Here's a simple algorithm we could try. For each bit of the plaintext, we'll look a decision: if the key bit is a 1, that means 1 would become a ciphertext 0, and a plaintext And if the key bit is 0, that means leave a 1 in the ciphertext, a plaintext 0 stays If you're familiar with Boolean logic, you here as the exclusive or operation. And the result of applying this bitwise exclusive This is a perfectly secure encryption algorithm. If an adversary were to see just the ciphertext, the contents of the original plaintext. But there's a potential major problem with we ever use the same key more than once. If we reuse the key, then it becomes possible Think of it this way: when the key is used, of the key to get a ciphertext bit. So if two ciphertexts have the same bit in in that position must be the same too. And that can be enough information to perform parts of the original data might be. So for this algorithm to be secure, we can approach is known as the one-time pad. But if the data we're trying to encrypt is key to encrypt multiple pieces of data, then So what properties are we looking for in a Two important properties to think about were Shannon in the 1940s. He described the properties of confusion and Confusion is all about complicating the relationship In the exclusive or cipher we were using before, each ciphertext bit is fairly obvious: changing same position in the ciphertext. But ideally, a cipher with confusion will on many bits in the key, so that the relationship Diffusion is all about spreading out the statistical Plaintext messages have statistical patterns: frequently they appear, and some words are If those patterns were to appear in the ciphertext to gain information. So to make our cipher secure, information across the ciphertext. In practice, that means a cipher with diffusion in the plaintext results in a change to about But our exclusive or cipher doesn't do that changes, only one bit of the ciphertext changes. A good cipher should have both confusion and So let's turn our attention back to AES, the design achieves these goals. AES is what's known as a block cipher, which number of bits and produces a ciphertext block AES uses a block size of 128 bits or 16 bytes. So we start with 16 bytes of data that we AES lays out these bits in a 4x4 grid -- this and we'll make updates to the state repeatedly So what do we do to encrypt this block? Well, to go back a step, what would our exclusive We'd need a key, and a key that's exactly And then we'd apply an exclusive or operation of the key to get the resulting state. We call this process &quot;adding the key&quot; to the Now, how could we try to introduce more confusion Remember that confusion is all about trying parts of the key, instead of just one part So here's an idea: let's take our original There's lots of ways we could do this expansion, involves starting with the original key, and key by combining values from particular previous At particular intervals, the process will around or swap bytes for other bytes. The goal is to get an expanded set of keys many or all of the bits from the original And once we have that expanded key, we can one key, we'll apply multiple rounds of transformation, round key. If you stop to think about it, though, adding any more secure than just adding a single After all, adding many round keys is the same of adding together all of the keys. But the idea of applying multiple rounds of to add other steps into the process. What other techniques from cryptography could One simple type of cipher is the substitution In a substitution cipher, we transform data units of data with other units of data. A simple cipher for working with letters of letter A with B, the letter B with C, and So a message like HELLO becomes IFMMP. Of course, a substitution that's just a linear is fairly easy to analyze and break, so a relationship. AES uses a substitution step too, called SubBytes. Instead of substituting letters for other for a different byte. The encryption algorithm defines exactly what replaced by 99, 1 gets replaced by 124, 2 substitution for every byte value. So when AES substitutes bytes, it goes through its appropriate substitution. Just like with our letters where we wanted the substitution, the AES substitution was and one that isn't just a linear transformation That said, even though the substitution is advance. So AES couldn't rely only on this substitution, and get back the original data. Instead, we interleave byte substitution and Something like this: we take the input state, Then, we repeat some number of rounds, and and then add the next round key. Only adding round keys one after another doesn't Only substituting bytes doesn't do much for But integrating these two steps together results depends on multiple parts of the original not immediately obvious how to reverse the So what's missing from our algorithm now? Recall that, in addition to confusion, we spreading out information from the plaintext When we change a single plaintext bit, we bits to change too. But our algorithm right now doesn't do this. When we change a plaintext bit, it might result byte, but it's not going to have an impact So AES needs some way to introduce diffusion other bytes, and ideally add even more confusion There are two operations AES uses to achieve Let's actually start by taking a look at the The role of the MixColumns step is to mix essentially diffusing information throughout It operates independently on each column. For each column, MixColumns defines a particular in order to get a new value for each byte. Each new value in the column therefore depends It's worth pointing out here that we're using but we're not quite performing the normal to. If we did use normal multiplication and addition, what could be stored in a single byte. Instead, these multiplication and addition number of possible values: the 256 possible Since there are only a finite number of possible So the MixColumns step successfully spreads so far, no information moves between the columns That's where the earlier ShiftRows step comes This step shifts the values in each row by unchanged, the second row gets shifted by fourth row shifted by three. These two operations combined -- ShiftRows values from the state, and even more so when So with all of these operations in mind, we We start with some data, and a key we want We start with a key expansion step that takes each of which depend on the values from the We then add in the first round key. Now comes the round itself. In each round, we start by applying SubBytes: Then we ShiftRows: shifting each row by a Then we MixColumns: combining the values from And then at the end of each round, we AddRoundKey This process repeats for each round, until It turns out that the MixColumns step is actually that doesn't change the security of the algorithm. How many rounds of transformation does the That depends on the size of the original key. AES is designed to work with multiple key keys. Each key size is associated with a different number of rounds. And if you've ever heard the terms AES-128, refer to: the size of the key. The larger the key, the more difficult it There's a lot going on in AES -- substitutions, -- but each step contributes to the security secure enough to be used to encrypt data every And there's other details we haven't covered it to sequences of data longer than a single But hopefully this gives you some insight and an appreciation for some of the ideas