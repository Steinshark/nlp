Hey programmers, I'm Alvin l come to our course is one of my most favorite topics to teach. also has a reputation for being a very difficult can be very intuitive. If we actually take right? A lot of students have this habit of programming problems, without going through the material, right? It goes without saying, and algorithm interviews, you definitely need give you all the background knowledge, you Now, that being said, What problems are we are a few examples. So one question I can on the Fibonacci sequence seems like a very number of different ways to move through a like given a set of coins? How can we make example would be given a set of substrings? string potent pot? And all of these questions programming. And this is really why I think very difficult, because the problems ranged are totally different. And there may not be tackle all of them. But the short answer is, thinking about these problems. That being this course, in this course, I think our key all of these algorithms, right? So we're going whiteboard, as well as visualizing things on an algorithm interview is really done when you describe that process, and then translating Right? The hard part is designing the algorithm to draw out of things to make sure we understand up with a solution. And then once we're really we'll hop into my editor, and we'll solve back and forth, until we end up with an algorithm right. So it goes without saying, we're also of all of our solutions. I'll be writing my easy to translate our solutions into the language programming, we're going to divide the material be about memoization. And then Part two is it if you have no idea what those two terms that material step by step together, I think these things in all very logical progression, And I don't just have to tell us what the I won't assume you know anything about dynamic a little basic recursion, as well as some sort of familiar with big O notation. And of that notation as we move along. So I think ado, let's hop into the course. Alright, so really ease into this new topic. And so what that you probably seen in the past that is for us, we'll have a particular phrasing of write a function fib of n that takes in a the nth number of the Fibonacci sequence. work? Well, the first and second number of point in time to generate the next number two. So for example, these are the first few 112358, and so on. What I'm saying is your the sequence. In other words, if I asked you to return the answer 13, right? Because the actually calculate that 13? Well, logically, that is five plus eight gives me the 13. So get us going for what we do later on in the one recursively, right, it's really going don't we kick things off by quickly implementing Fibonacci function, probably in this function one of the earliest examples of recursion notation here. So I want to take in a number Fibonacci sequence. Like we expect, the base numbers of the sequence. In other words, if to two, then what I should do is just returned first two numbers of Fibonacci sequence are general, what I can do is just return the one I'm asking for, as well as the Fibonacci right? Again, the kind of baked in recursive number, you can take the sum of the previous course, we should test our code for some correctness, fib function. So I'll try fib of six, seven, of 813 and 21, respectively, right. So let's There we have it right. 813 and 21. So this Fibonacci, you've probably seen this many And really, what I want to do is give some if I asked for, let's say, I don't know, the reasonable to ask for. So if I give this code of bonacci do work fine, right, I get 813 running, right, my program actually hasn't type of implementation with Fibonacci. So work. Let's go ahead and head to the drawing Fibonacci function is correct. And that returns large enough value of n, it's pretty slow. some efficiency. In the long run, we definitely Fibonacci. But to do that, it's really important room for improvement. And to do that, I think I think students actually need to work on. picture everything in their mind. And that we want to tackle more complex problems, if just mentally without drawing it on, like chalk and chalkboard, you're going to really So I want us to be very, very methodical, visualize a problem like Fibonacci. And so to trace through what happens when we call for the seventh number in the Fibonacci sequence, back to 13. Right. 13 is the seventh number mind. But over to my drawing, let's say I drawing a circle with my value for n inside. what is it going to do? Well, I know that not less than or equal to two. So this call calls. In particular, on its left hand side, On the right hand side, I'm going to do n And at this point, I carry over the same logic if I look at the six node, if I'm routed right minus one, so five, it will also have a right to see a pattern where really this recursive is really neat. I hop over to this five node, on slept minus two on its right. And we will of these nodes. But let's say we pause right have pointed to in red, they're actually the values of two or one. And I know that those importantly, that means they don't branch start flushing out the tree of those nodes. base case, right? That is these nodes in yellow. not branch out further for the base cases. So at this point, I built out my entire tree, we had a base case scenario. So this is actually numbers inside of the nodes here represent if we have this visualization, how does this Right, so let's start to break it down over particular, this base case note of two, right? going to return the value of one according really just means return to your caller right is going to return one to its parent of three. side of one is also a base case, two will returning, they go back to the parent of three, values up. One plus one is two. And this makes Fibonacci number is two. So we can continue is also a base case. So it returns one. And up both of its children values. Two plus one because the fourth Fibonacci number is three. speed things up. For all of these base cases, their parent. And for all parent nodes that both of their children returned, they're just just continues all the way up the tree, right? get the answer that we should return the very get the final result of 13, which makes a that, hey, the seventh Fibonacci number is of how to visualize this fib function, what do we know about time complexity. And so you a classic recursive implementation of fib And that is the case however, you really understand is the reason why Fibonacci for us is going However, something that's kind of unfortunate that's, I think, a big reason why students that a function like this has a two to the do, why don't we warm up and kind of go through And I promise we'll answer that Fibonacci say that I gave you this foo function, notice right? It's similar in that recursive, this doesn't calculate or solve any particular foo function behaves, let's draw it out. Let's of five. I know five is not a base case. So going to call upon for four calls three, three actually bottomed out at a base case. If you made exactly five function calls. Which makes where do we stop once we hit a number less we just subtract one from our current value But if I generalize that, for any arbitrary to have about n different function calls recursively. of this is really just O of n time, right? calls. While we're at it, why don't we take may have heard in past that when we analyze we should include any of the additional stack when we make a recursive call, we add that by our computer. And so since we have about the stack, before we hit our base case, you code is also O of n space, overall, we're this function. Pretty straightforward stuff, function. So let's say I gave you now this it's very, very similar to foo, what you should make a recursive call, we do an n minus two actually change the time complexity of this this and I made a top level call to bar of is gonna call upon to, to call zero and zero similar to our last example, except we kind kind of take a bigger step in time, right. twice as far upon every recursive call. And calls we need overall. So I guess we might of this one is N over two time, but a keen bego, you know, understanding, we can remove a time complexity, so N over two is the same it's just an O of n time complexity. Using the space complexity from the stack is also of the land, I showed you two functions that in how they made their recursive calls, right? But in the grand scheme of things, we saw right? We have O of n time and O of n space two examples, you may be able to see the reason actually ready to make the logical leap and recursive function. That being said, I don't methodical, I think, if we pay the cost of like Absolutely. Understanding fib. It's really I slam me with some much harder problems. Let's take a look at some other functions. very particular Right, we'll pay it no mind. Well, it has two recursive calls now right do an n minus one. How should we visualize guess, our initial fib drawing and shape, let's say five, five is going to branch to is not yet the base case. And for this did and also it's a right child, right. So the than twos, then just ones which would actually nice, like, beautifully symmetric tree, right? function. But what does it tell us about the me say a lot in this lesson is when we tackle we're really trying to do is just leverage at this tree structure, I'm trying to notice over here that I can grasp that to really learnings, right? Where can I find our base So if I look at this path, I've highlighted at the root node going down to some base case And what's really nice about this structure It's a linear structure that we saw before, 5432. And one. And so I know that in general, of this path that has a number of nodes highlighted nodes. If I kind of adapt that language for of this tree is n. So the height of a tree node all the way to the far this leaf, in our top level called Five, all the way down five here. Something you may also hear in in this tree is also n, this term is pretty of levels, a level is just a collection of the root. So for example, here in yellow, one, this is level two, this is level three, look at the very, very top level, there's two nodes. On the next level, there's four the pattern? So let's try to generalize that. So I know level argument for dib, we know that we're to get the number of nodes on the next level, after that would also multiply by two and And I do this a total of n different times, tree, or the number of levels in this tree make over here, we're basically saying that number of calls a recursive function would and multiply it by itself about n times over. right? This is the same as two to the nth this recursive function has a two to the N, this dip function is having a two to the n the space complexity over here, I think a of automatically assumed that the space complexity the time complexity. And that might be a reasonable the long run, we're gonna have to evaluate that means you have to put two to the n function nuance to this, the time complexity of this jump in. Let's say that we made our top level to the stack in the same way five calls for for every call that we make down until just reached a scenario where I have a base case, call stack. And the important insight is when highlighted the left one over here, it actually function returns, its stack frame is actually point, only after I have returned from that to the stack to be explored. And this process most number of stack frames that we use up, throw all of these function calls on the stack visual, we know that the number of stack frames the height of the tree, right, so the height means our maximum stack depth is also n. So call stack. So overall, for a dip function, but only and space complexity. Alright, so you this very similar lib function. Notice minus two. So by now you should be able to like, say we initially called lib with a value Well, it would just look like this. Notice node branches to two children. But this time, familiar ground here, I've noticed that from And this occurs all the way down to a base identify this tree as having a height of about time complexity is going to be two to the level of the tree to the next, we double the two times two repeating pattern for the number two, right? However, we can actually simplify over to in the exponent and simplify that a two to the n time complexity. And using that the space complexity for this from the simplifies nicely to N space complexity. So we're looking at a two to the n time, but Alright, so now it's time to look at the big dibben lib. And we saw that the only difference did did a minus one and lived in a minus two. both functions had an exponential two to the complexity. That being said, Where does our Well, you can imagine that kind of falls right it has two recursive calls for the first recursive did. But its second recursive call this n of like smack in the middle, right? If you just talking about the time complexity, we is somewhere between dibben lib, but we've know, that, hey, the lower bound that as Deb is lib has to at the end as well. So that two to the n time complexity as well, right? time complexity. Awesome. So that was a really function, it's evident that it has a two to Right now, the bottleneck that we're experiencing two to the n overall, is not undesirable complexity. this really implies? So let's take a look of this? Well, you could kind of imagine that, that would take you know, roughly two to the punch this exponent into a calculator, you're is roughly a 16 digit number. So you should very, very large quantity. But I think that, of what we're really saying here, if we expand That's over one quadrillion 125 trillion, Because we just asked our Fibonacci function right, the 50th Fibonacci number, and it's to do that. And of course, we can probably So if I recognize that the bottleneck for I know that that comes from the number of to do is look for any patterns that I see see a quick snapshot of what the recursion that it looks like this tree just like we tree, do you notice any interesting patterns Well, one thing that I noticed is I can see two on the left and one on the right. And see it in many different places in this tree, in a bunch of different places, it's very other sub trees, let's say I root myself at all over the place. And it's even carries So I see that this tree has a lot of duplicate connection between this diagram and what happens in any of these sub trees of five, I know question. Hey, what's the fifth Fibonacci changes, right? If I calculate it once on get back on the right hand side shouldn't possibly reuse these calculations right? If then I should just store that because later it over here. I would basically get rid of down this entire recursive tree rooted at is known as dynamic programming. And so for where we have some larger problem, in this smaller instances of the same problem, we us, right, now, I see that I have to calculate the larger a fib of seven a solution. And this lesson is really trying to visualize nature. So we're going to be drawing a lot is try to really recognize, hey, what pattern some duplicate work, if I do some duplicate later on. But that being said, let's go ahead and work on optimizing this solution. Alright, ready to actually implement some code that have our classic bonacci implementation, this definitely too slow, right has an exponential I want to do is kind of capture a duplicate I get that way, if I have to recalculate those data. And so the trick here, it's a very common some memorization. memorization is actually to solve any dynamic programming problems. called memoization? Well, this refers to like, let's say, like real life, it's really just I'm looking to do is store some duplicate results later on. I think a really neat way well as many languages is to use some sort like your hash map equivalent in the programming a JavaScript object. And so our plan is to I want the keys to be, so the keys in the function, right. And then the value will be for a argument to the function that is a function And so what I can do for my existing function So my favorite strategy is to do this, and you're unfamiliar with this syntax, in JavaScript, I were to call our fib function, and not pass create this memo, as containing a new JavaScript it's gonna be useful that way, whoever is deal with setting up any memo object. So well, I want to do is treat it as if that, hey, values are going to be just the return values see us doing a lot in this lesson is at the inside of our memo. So let's say that we're first thing I should do is kind of add an argument n inside of the memo, and if it is, that memo. And I'm done. So I'm going to do the value that corresponds to that memos key, and as a key in my memo, and this condition I'm just checking if some key is inside of really quick, maybe just to warm us up, if say I had some object and had some properties me, then it had a favorite color of like gray. of a key in that object. So JavaScript keys Hey, his name in the object. That's true, I spell it right. That is also true, I can know, his location and the object that is pattern, but for and right, which is going into a string key, which would still totally logic, right? I check, Hey, is this argument to actually manually do the calculation, which at least once. So what I'll do is I'm going this is my return value in the original brute that entire result inside of my memo and the access is always just what your argument is. So I can just go ahead and return what I just any return values, or I'm returning exactly now I'm actually also saving that value inside sure that all of these recursive function I'll do is I'll pass in that object to both here is, I know that I only receive a new top level call, that's a fit, right, because here. However, if I look at my recursive calls, so they're actually going to receive the same reference, right, because when you pass a receive kind of that exact object, right, neat. So basically, I'm giving my function other, they all have some sort of global information So this is looking good. Again, I just want here, I added a new base case on line five, seven, but I didn't change any of the functional cases. And we'll see how our code is doing this file. And notice how blazing fast our program was, the 50th Fibonacci number is indeed have this almost instantly. So let's go ahead and head you know, what happens when we execute this implemented the improved version of Fibonacci the program that we definitely had an impact don't want us to understand you know how the we implemented this memoized version of the an example of Fibonacci. And let's say I pass for here is to get back eight, because the eight. So we know that we're going to have a tree that would really be the full recursive like if I did not optimize it. And what impact Alright, so let's start tracing through this, top level, an important thing to know is I'm by default, my code says it will initialize aspect of this is I'm going to create a new that same object is going to be passed down five. And so I'm going to travel down my left for four calls three, and three calls to, that this note of two is going to return one. In the same way, now I need to evaluate this it also returns one. And at this point, my the sum of its children, right. So one plus values. And now three is returning two. However, is this node going to return to to its parent, right? So the key insight is, at this point, value is to basically in my memo, I kind of number is two, right? That in itself is logical. Now I start to evaluate what happens when case, it returns one. Now my call to four take the sum of its both children. So it's of course, it's also going to store that inside result out to be used later on. So that means value, the value, right, so I'm going to have And now here's the beauty of this memoized what happens for fib of three. However, this cases I added, right? I know that three is my code, right? It's in the memo object. And And so this call to fib of three is just going I do that, I won't have to travel down the three, right? I don't need to travel to these value in my memo. At this point five is ready both with children, three plus two is five. right? The fifth Fibonacci number happens for six is right child. So I have to evaluate number up, that's actually stored directly returns the stored value of three, right. that stored memo value without having to travel I can return for fib of six, so I do five actually technically be stored in my memo as eight and very happy, right? The answer So it's evident that by memorizing our Fibonacci of recursive calls, we want to visualize that in light blue, I have a circle the nodes that recursion at, right? So these nodes of two, my initial fib of six, I was able to kind forego traveling down the recursive subtree. complexity of this function now? Well, I think generalize things. So we just stepped through But how does this sort of scale? So this is up a little bit. So I know that in general, I want you to take a moment, look at this. would look like if I memorize with with seven, it really just looked like this. Notice if child is still six, right minus one. Its right, obeys the laws of Fibonacci. If I asked for be like this. And nine would look like this. we're just growing this like memoized chain by you know, that just like structural argument, we know that in this drawing, there is some say, when you tackle these new problems, or right? Where can I recognize stuff I've seen 98765432, right. So this goes all the way right, just counting down. So I know that yellow, that's definitely just an notes, right, know that what I have highlighted in yellow n nodes. But I haven't accounted for everything are still in white, meaning I need to kind shape of this tree is, well, I know that each to some of the nodes, I've colored in yellow, For every node in my ello chain, it has exactly on its right hand edge. And overall, if I overall, right? There are two things in a two n. And I know that that can actually be would be two n, which just simplifies to n we did for our space complexity, we know that is pretty powerful stuff. by memorizing our time complexity to just a linear time complexity. we're ready to graduate from Fibonacci. And this one has more of a narrative to it. So grid, you begin in the top left corner, and corner of that grid. And the rule is you can you can't move up or to the left, and you In how many ways can you travel to the goal? bottom rate if you had a grid of dimensions, is looks like the grid, maybe a rectangle, what we want to do is implement a function is to take the dimensions of the grid. And for this one, I think it's really important what this question is asking. So let's say of two comma three, that means they're asking top left to the bottom right, of a two by the answer here should be three. Right? So you can imagine that we had, you know, a two well as three columns. And we start in the right. And so why do we say that there are bottom right? Well, they told us in the problem or a down To move, so one of the ways would bring us from the start to the end. And it way, another path we can take is doing a write And the only other way would be going down, And that's why we say there are only three three grid. All right, so that's just one example of how really important to notice is try to also relatively small inputs, but I think they're happens if they give us like, basically, the one by one grid. This one is kind of trivially one unique way to travel from the start to if you had a one by one grid, there's really the start is really the same as the end, and out the gate, because to travel from the start So the logic here is in a one by one grid, to the end, you're kind of already there. else we might think about is what happens say someone asked us to calculate grid traveller question to ask because for one, if there means that the grid is empty. So I would consider that grid because the grid is sort of invalid for traveling through a one by zero grid, So it should also return zero. And likewise, answer should just be zero, right? If one is no grid. So maybe you're catching on into why I brought Those kind of sound like base cases, which But let's stay grounded and look at another grid traveler of three comma three, right? grid. Well, how can we reason that one out? of frame the problem in a way where I can the arguments to my function call. So let's I want to move from the top left to the bottom, say, and so I know that overall, I have this can I travel through this entire three by right, I can move either right or downward. Well, if I move downward, then I would appear move to the right or downward. So now it's just this shaded region. And if I look at still sort of in the top left corner of some the question, hey, and how many ways can I this is a really important way that we're three by three grid initially. Now I have the relative grid from my current position, position. So if you look at this coordinate is like not the coordinate of the person within the rectangle that the person is trying to say that, hey, I want it to move to the right along a different dimension. So I'd appear that I'm trying to solve. And if I keep following the problem size over here. Now, I'm asking if I take a right move over here, I'm asking know is one of those sort of base case scenarios be really useful when we actually implement here is when we make a move through the grid, basically shrinking the effective size of along one of its dimensions. Awesome. So I grid traveler problem definitely has some I tried to take more of like a programmatic ton, like, basically, for every problem in that we kind of know is going to be recursive. tree, right? I want to really visualize this on pen and paper, I can implement that with right. So let's say that I wanted to take now a grid traveller of two comma three. So we encode nodes of the tree Using the arguments where I have the number of rows and number like Fibonacci, I only had a single argument. I should get back is three. So just keep that diagram. So I'm going to start with that top about how this node can transition to other actually change? Well, I know there are really have one child going downward, or another the two options based on the gameplay here. of the number I put in the node? That is, grid area? Well, if I go downward, then I'm means my left child is just one comma three. mean I'm reducing the number of columns by Notice that from parent to child, all I'm by one, right, that means you're either going just carry over this pattern recursively, node now, five, mat one comma three, then And a similar way. If I wrote myself at two, two, one. But now let's notice something important. have zero comma three, remember what we trace is this? No trying to answer? Well, let's through a zero by three grid, but if you have dealt with. And so I think for this note of contains zero, we don't need to actually flesh recursively, drawing out these other nodes. point, we've actually hit I think all of our notes, that have one comma one that was exactly I know, trivially I can solve the one by one are going to return one, right, in a one by from start to end, right, you kind of just for all those notes that contain a zero, they're the negative base case, meaning that there end. So for all of these notes containing right? There are zero ways to travel through values at the parent node, right? So I just I forget what these things are saying, right? above, it is one meaning there is one way You kind of just move rightward. And so I children nodes at their parents. And this what do I know, there are three ways to travel like a narrative, and there's some, you know, just a spin off of Fibonacci. And that's going programming problems. So we've confirmed that by three grid. And there's also some other whenever I took like a left hand edge in this downward. And whenever I took a right hand of moving rightward. And so if I have that able to count the number of ways that I can combination of moves lead to a solution. One right, right. Another way is to go right down, down. So we can glean a lot of information I think that's enough drawing for now let's Alright, programmers, here we are back in this grid traveler function. So you want to by just laying down my base cases, I already cases is we have a one by one grid, just go really easy to do. So I'll check Hey, if m trivially one. Right? Then along with that, an invalid grid. That means if either of my here, right? If either dimension is zero, definitely no way to travel from top left recursive scenario is very straightforward. going downward and me going rightward, right. rows, if I go down that I'm decreasing the but I keep the same number of columns. And the right, that means I still have the same n, right, I have one less column. So this some reminiscent Fibonacci style code. Let's a few examples over here. And these are the go ahead and bang this one out, grid traveller. looks like it's working just like a charm. 18 grid, looks like my programs hang right an 18 by 18 grid, so you probably see where the drawing board and really understand a here we are back in the drawing board, because our recursive implementation of grid traveller. brute force solution here is actually a really in on where there is room for improvement. the actual time complexity of this implementation? of two, three, the full tree would explore to understand the time complexity here, it's calls we make, which is really the number to generalize my understanding for any large you know binary in a way, meaning that a node sense, because from one position of the grid, go down or I go to the right. But that being this tree is. And this one's pretty interesting, input arguments to our function, I'm given contains two inputs, it shouldn't be the case describes it in terms of those two number the height of this tree. And so I'll just And kind of in the recursive sense, that means the way down to the base case, and preferably cases are either when one of my arguments turn to one. And I think in general, the farther my arguments are one. So here I have a path general, I know from one node to the next, or I decrease the n by one, it's never the by one, because that would kind of entail which is not allowed in the gameplay. So if one from n, and overall a path from my initial to have a distance of n plus m, we basically initial node to reach that bottom level of of levels in this tree, right using the same most of this tree is going to be binary, meaning so I have that two times two times two pattern saying that they're n plus m levels. So really, power, right. So still some sort of exponential, because I have two variables of m and n. And likewise, for the space complexity, you recursive code is just going to be the height us the maximum stack depth of the recursion. levels still, which is n plus m. Cool. So to be that time complexity of two to the n the time complexity of this one being exponential. to still have a nice argument to you know, you can get a massive buy in from your interviewer draw it out and actually defend your reason But let's try to improve this now. Is there this function? Well, here's that same drawing, grid traveller of two comma three, and this know now that I have this recursive tree structure. work, right? Is there some work I can prevent really remind yourself of the actions we took any patterns in this tree, probably from the sub trees right? Have one comma two. So in that's sort of asking the question, hey, what a one by two grid? That being said, I think to that particular problem. What if you look if you really, really think about it, asking by two grid is the same as the number of ways just flipping the rows and the columns, but the same. So that's actually a pretty interesting still memorize it. That is I have these duplicate we can make in this problem is, you can also if someone asked you, for grid traveler have for a grid traveler of B, comma a, write the matter here, until we can totally encode that here is, we better memorize this one. So I are back in my text editor. And hopefully, complexity for this one, make some sense, running. And my computer's fan is actually Let's go ahead and memorize this one to the programming like problems is if we have the brute force recursion, and we wrote like a actually use return values, and I reconstruct top. Because I have a really nice recursion pattern. So it's going to be almost the same problems that we do in this lesson. So we're object. And then along with that, I'm going here in general, and to check, hey, are the into my memory object using all of the arguments. the arguments combined, sort of dictate the both of those in JavaScript keys are either strings is the most relevant one. So what integers together. That way, I have a string we'll all definitely want to do is also maybe I'll say like key equals m plus a comma, plus, like some sort of separator between these the numbers don't get misinterpreted. So I've can you imagine like, if I had a scenario was 42. And then we'll say n was a number make my key, something like four to three, the exact input argument, right? Because if the same key for a totally separate set of both of these combinations of very different would collide at the same key. So instead, now I know without a doubt that this key corresponds a separator between them. And depending on for interviews, you can find a very similar check, hey, if my key is in demo, then I have return net cash value. So return memo at key. old return value, right? So here's where I Before I return that I want to store it in that thing, I just put in the memo just completing this pattern before, I just want to emphasize seeing it. memoization, for me, at least, I always take the exact expression that I thing in the memo object, right? Notice that right? Mnn. Something that I've seen students logic, where they try to, you know, check words, don't write any pre emptive logic where so if you like concatenate those two things key is in the memo, right? So imagine like, if that is in a memo. When you write logic and a little harder to debug, right? Instead reasoning for its children calls, you know calls, they're going to cache themselves, if statement anyway, alright, so don't do make the recursive call. That way, every recursive I prefer this way implemented. And with that, give this a shot grid tremor, I still have last time didn't actually finish while I was because I'm actually missing a little bit spot it, I forgot one really important thing. exists in the memo. And I also have a logic doesn't exist, but what I failed to do was of the recursive calls, I want to pass it top level when someone calls like two comma to initialize a brand new empty object, which because it's passed down by reference at this Let's go ahead and run this now. Nice. And execution was over here now is the expected what we'll do, it's evident that we definitely back to the drawing board to wrap up this complexity here. All right, so it looks like function. But I want to really understand improved function is now. So sort of a way complexity is, is to think about where the to travel through. So let's say I looked at of voice a traveled through a four by three top level node, of course, four comma three. So I'm trying to think in a very general way the other nodes of this tree, they're all but then probably be less than that, right? It's not as if to solve grid traveler, four, would be a larger grid. That doesn't make only in this rendition of grid traveler. And I know that if M is for top level, then all would be from zero all the way up to and including than four. In a similar way, since n is three rest of my tree are zero through three. Right? here, because I have to include zero, because of this problem. That being said, there are and n choices for the second number in the not gonna have to travel through many duplicate And so I think what I can say here is the is m times n, and I'll be the number of like for the first number in the node and n choices to really minimize any duplicate exploration implication here is we started out with our looked like it was exponential in the time, then by memorizing this function, we were complexity, which is much faster. Notice that really fine, because n plus m is some sort we have our nice optimal solution for this you to take away from this one is, although it seem, you know, pretty specific, and pretty problem, like Fibonacci, was really the same we're going to sort of leverage throughout is try to think about your recursive functions information out of the tree. And then from a brute force, but to also recognize, hey, way you can reach for the optimal solution. Alright, so we've gone over two different to notice how we tackled them in similar ways. guidelines for solving dynamic programming we'll call this our memorization recipe. And about learning this topic of memorization. This is just my particular recommendation. if you want to, you know, solve some dynamic to stick to to like high level steps, we definitely recursive. So just make it work could be slow, I think this is where a lot of students sort to just solve it quickly all in one go. Right? right? First, I look for correctness in my then I look for efficiency in my solution. want to get a working solution, then I have in dynamic programming problems, the gist that I can break down into smaller instances as a tree, what I'm looking to do is figure should represent a problem. And when I draw the size of the problem. And depending on have to figure out that logic, right? In the we know, we can decrement our values of n. we had to do was travel rightward or downward. that tree using recursion. What's great about Right? So how do you start to translate that code? Well, you think about the leaves of for us, it's been about some small numbers, also be in the case of Fibonacci, just our equals two. Now, once you have that baseline solution. And so you'll want to test it. To right? So if you pass inputs into your brute Although possibly for large inputs, it may big difference between code that is slow, should give back valid results, although maybe working brute force solution, making it efficient scenario. All we do is start by adding a memo to have keys which represent arguments to represent the return values for those function set of arguments should give me a particular mapping inside of an object, you need to make of your recursive calls. One way you can do lately, I've been doing that by giving myself of my recursive calls right through my top add a new base case into our code. So I'm from my brute force solution to me, I'm just In other words, if my arguments are in the stored value, I refer to that as like my memo value in my memo. And beyond that, the only storing logic. And it's as simple as going in our function. And then we just make sure object before returning, right, so I always write some code around it, right storing that return it, right? Step two is actually very, easy to memorize a brute force solution, it's first place, that kind of feels more difficult. for these dynamic programming problems, I and follow these steps, right? Don't try to get go get a brute force working solution memoization. Afterwards, right. And as you you'll be able to do everything all in one definitely finished this course. So we'll be sure to follow these rules for tempting increase a difficulty and we're going So let's work on this can some function, what as an argument, as well as an array of numbers true or false, indicating whether or not it some numbers from the array. And along with totally use an element of the array as many all input numbers, so the target sum as well So let's try to understand what this question case. So it looks like our targets, I'm a seven, here, the response should be true because some amount of numbers from the array, one three plus four, another way would actually is actually a member of the array. So it's you know, some amount of numbers from the see, I gave you another example. Let's say I gave you a different array of just two and because there is no possible way that combinations Cool. So that's really what the question is can frame this problem of recursively. Right? mind. If we have a smaller amount of targets problem than a larger number for targets. recursive structure. For the first example, to derive the answer true from the string encode the arguments to our function into since in the problem, they told us that we as many times as we need, I'm just going to every node every function call is going to the target sum in every node. So I start with transition to other nodes, right? How can know that I only have, you know, four options element of the array. So basically, if I'm to some children, and sort of the rule for take a three, take a four, take a seven. And as a choice, they are going to decrease my minus five is two, seven minus three is four, seven minus seven is zero. So notice, we have a parent node to some child, I can just carry out right, so let's say I tried to flesh out look at the options I have, right, I still none of them are really compatible with this to do is take any of these choices, because sum. So I can't really flesh out this note for this node. However, some of these other So what I can do is take a three or take a respectively. And I'll also do this for the I can only take a minus three as a choice. have, now, I like the leaf level, it looks case, that is there is no further choices of my nodes have a zero in them, if I look actually are a really nice base case, because to the original target sum right away, you the target sum is zero is you can always generate array, right? So these zero nodes are trivially backup to their parent, right. And it's sort are not zero. And they also can't break down right? Because they kind of have a leftover. can take to reduce that further. So all of parent. And remember what this question is it possible at all to generate the original values these Boolean values return to their least one of them is true. And if at least also return true. And if I look at this for of answers the question, Hey, can I generate and you totally can because if you look at one for so I can just take that into my son. these Boolean values to their parent. And at least one of the values that gets back true, then the parent itself will also return bubbling up pattern as well as our grid traveller, some boolean data, but it's really the same that was an example where we said true, right, look at another example. Right? How do we right, seven, and an array of two, four, in there's no possible way you can generate that example would look like this. So this is a as low as one, but they can't be broken down sketch all of these ones, since they can't reached zero, they're going to return a false up all these false values, of course, a top So it looks like a key insight we have for know, one base case that returns true, I know true all the way up to my parent, because can you generate the target sum? They're just target sum at all. So that's gonna be a really ready to jump right into the code. So let's this can sum function. So since we're going place, as always, is to maybe handle some tree, I noticed that one of our base cases zero, right? If our target sum is zero, then problem, because you can definitely always no numbers from the array, right? So I'm going Apart from that, I think let's go ahead and that I need to establish some logic where element of the numbers array. So what I'll So I'll use some for let of syntax we'll say unfamiliar with the syntax, all it does is So for example, let's say I just called the array of two, three, if I just console dot printed out of two, three, right, so let's iterating through every number of the array, I need the branching logic. So remember, the of the tree to the next, what we did was subtract sum, and they basically gave us like the new maybe some variable, so I'll say, Alright, the difference between the target sum and the number from my target sum, that gives sum. Right? So at this point, I think I need in this remaining quantity? It doesn't need a second argument, still, array. So I'll still pass in numbers unchanged. in the same exact numbers, right, it's pretty because we can totally reuse the numbers of So now that I'm using our function, again, about what this call will return. I know at going to return Boolean. And what's great right, either true or false. So I think, based call, if that returns true, then I can just So I'll write it like this. So this is saying, to generate the remainder now using numbers larger problem of target some, right? So if I'm going to do an early return true. And want to write the LS and then return false. the for loop. And so here's the reason why I only know that after I attempted you know them worked out Can I actually say that it Right, so I need to make sure that this for I can say false, the target sum cannot be we should add to our code. So if you look choice of num from the target sum. And that negative. So remembering our tree structure, we had a sum note, I didn't do any branching. bake that into another base case. But this I'll say, you know, if my target sum is negative, far. And you can just return false. Here, if your target sum hits something less than really nothing else you can add from the numbers Remember, they told us in the problem, that as positive numbers or just zero, right? So try all of these examples. And we'll see what false. Cool, so looks like a few of them are are working totally fine. But looks like on And if you notice, I chose a pretty large solution has correctness. But it possibly finished, the definitely took way too long. a slow input to can some, because for one, gave two elements here. But it seems like the runtime. So we'll do, let's head back of this baseline solution. Alright, so we But obviously, now we want to make it a little memorizing the solution, let's at least describe So let's try to visualize this example. So for my numbers are two, three and five. In visual for the full tree would look something of forbs and relatively small inputs, right, three choices. So let's try to describe the the shape of it, get rid of those numbers. And I know I want to describe my complexity function has two inputs to the right, I'll and n is the length of the array I'm given, have an effect on the dimensions of this tree. I'll start by maybe analyzing the height of distance from the top level call to a base is the maximal distance from the root of the leaf. So if you sort of imagine that, we have the left hand path, we just did a minus one a minus one, right? In the worst case, maybe array. In the worst case, the distance from because you have to subtract one m times, of this tree is M. And it kind of like we the number of levels is m right. So now that move is now to identify the branching factor. from one level to the next. Remember that example is having numbers array length of branching factor is exactly three or in general, So for example, if I had three numbers in three children, right? Cuz you have three I have n levels, and from one level to the by n, right? This is the same thing as saying, m times. And this would definitely give us and to the M time complexity, like we always diagram is we can also derive the space complexity, the call stack, it would really just be the as M. So overall, our brute force is looking space complexity. So now that we actually complexity, let's go ahead and focus on how the drawing for this particular example. It's when you're trying to notice where there is yourself a sufficiently large example to see have overlapping subproblems. And in the context trees. So I can look at possibly this subtree subtree is trying to answer the question, using the array? And of course, once you find change for your target sum of three, right? are trying to ask the same problem. And so in my memo object like we always do. Let's back to my code editor. And same stuff, different can sum function, right. Once we've established memorization is pretty formulaic. Right? Alright. object like we usually do. So if someone calls is like a top level call, we'll be sure to forget, be sure to pass down this memo object, call and it's recursive tree shares the same what what should I use to key into the memo original function are I have targets summon you know, which of these arguments is actually So I know that through the recursive calls doesn't change. And so if it doesn't change, return value. So I'd be okay to just use the go ahead and do that. So I'll check if my that sub problem before, so I can just return you know, memo fetching logic. But now I need the trick is, what I want to do is look at cases, and I need to now store them in my these two lines, lines, 10 and 14. And so of those lines, it's as simple as quite literally some, and then assigning the value we just So I'll just write it like this. And this you can always use our for a memorizing a I'm just going to take exactly the lines or scenarios. And now just store them in the a shot, this code is looking pretty good. input of target, some 300 took notice will a shot, right, it finishes really quick. So for cancer. Really, most of the work of this afterwards, it's really just a minor adjustment let's go ahead back to the drawing board and definitely memorize the heck out of that code. the new complexity is. So again, we're saying of the array. Initially, we said that our complexity, which is exponential. And actually, that complexity, we brought it down to n m that the memo is complexity is now m times that the value of the nodes in the tree are different possible values we can have in a cache values or cache results inside of the a subtree before M. That being said, I select right. So overall, I have m times n nodes. So hopefully that can some problem made some carryover a lot of that knowledge to solve very similar, it still asks us to take in this time around, we want to do is return up to exactly the target sum. And if there's the target some, then I should just return combinations that can reach the target some probably Already recognizing that this house to the can some problem right? instead of return exactly the combination of elements sum, so it's a little more involved. That to make sure we're on the same page. So let's and our target was seven, and our array of a few different combinations that can give be to take three plus four, that's one possible be returning an array of seven. So no matter be considered correct in either scenario. your target sum was eight, and your choice solution for a combination is two plus two in an array, another combination would be what we're always looking to get back in array, be generated. But let's look at the flip side. I have a target sum of seven, and my array thing we notice is it is not possible to actually said, the problem in this scenario, what you that, hey, it's not possible to generate any All right, I think it's important that we that I was given a target sum of zero. And In this case, I just gave us one, two, and problem, we had to return a Boolean result, And so what I want to think about now is how Well, if I want to know the combination that combination, right. So I think the logical your target sum is zero. Remember that an an empty array, that means I take no elements all the elements in that empty array, it would to be a really important facet that we need next, as well as our code, right. So let's and try to take a step toward really understanding say we're stepping through this particular an array of 534, and seven. So the full tree time would look something like this. from or some nodes where I reach zero, which means the target sum. That being said, How can I to return an array. So you sort of reframe base cases that have a target sum of zero, combination would just be the empty array. through how one of these base cases would is going to return an empty array. And like returning that information to its parent, its parent. And now what I want to do is actually something to it. So I want to really put the first place. And that would really be the I have them labeled with a minus four, meaning want to actually add that choice into the into the right, of course, I actually don't sake of understanding the math here. But now an array of four, that array bubbles up to that edge that I took, which would be that as well. And if I look at what I'm seeing we have an array of four, three, which makes target sum of seven by doing four plus three, answer in this particular problem. But like combination if one exists. So let's say we we know that this zero is going to return to the parent. But we also have to add the press seven in this array. And that makes sum of seven by just summing up a loan seven. pretty good about how we can return a valid there are some options that we take that don't this node first, right? This was the first of our code, it really would be right. So out any further. So it's sort of a dead end. that, hey, there is no way I can generate array. Or if you look at the elements of the that this base case is going to return null. base case, we would hit it would be this one, next base case, to the right, that's actually array. So it's kind of reasoned out how these parents. So I know that both of these values, right, so it kind of bubbles up a little bit. I would also have to push the edge that I now I'm sort of comparing you know, the nollan, the branches that I take from a node. And an array that I know that it's possible, right? of four actually wins out over the null, right, I'll just continue this process, right, now So let's I'm considering them at seven. In I took, which would be a three on this array. always override the null, right? So I could And a really nice pattern in this code is, the tree, or that is we find a combination return early because we don't need to really need to explore any other options because Right? Awesome. So again, to recap, the punchline a combination, encoded as a path through edges path I have highlighted in yellow, I see that eventually led to a zero. So I know that one All right, at this point, I'm feeling pretty for this now. All right, here we are back house implementation. So the codes going to the really the whole point, we're just kind we're gonna have a very similar base case, we have a target sum, that's zero, we have just return an empty array. And a similar base case, if our target sum ever reaches null. That's because it's never possible to in this problem, the array of numbers is only up writing very similar base cases for our true, we return an empty array. And instead let's go ahead and get the branching logic. calls, I'm going to need to make a recursive So I'll say, let num of numbers, we'll just And I'll go ahead and do the same logic as my target sum, they'll give me my remainder, mine number. Cool. So this remainder is now So here, I would make my recursive call. So argument will stay exactly the same. I'm going I don't need to remove anything from the numbers, that we can reuse the elements however we see fit, right. Cool. So now I returns. So this problem is interesting, because we could get back in array of some elements, or we can get back know, when it's not possible what I get back, I'm just going to save into result for the remainder. I'll call it remainder of like how I thought about this logic in an early return if I found a valid combination. the remainder result is not No. So the implication it is possible to generate the remainder. and I can return of basically almost the same I need to make sure I include the element we had a recursive call that returned in array, it took transition to that recursive call of the tree, I had to put the labels of the put the num into this array. So some syntax So I can copy all the elements of the remainder add on the number I just took, right. So all basically the same array that I get back from the end of it. Let's say you're unfamiliar quick. It's pretty neat. Let's hop into the, array, let's say it was this array of just can use the spread operator, which is the you can sort of say like, new array equals I can spread out the elements of the old R, has all of those same elements, vi, capitalize syntax, right. So I still have that array we'll call it other array, what I can do is from our using the spread operator. And then I want to add while I'm here. So let's say now, it contains ABC, and also this new element I'm returning the same combination, that my that I took are added to the end of it. Cool. very reminiscent to our previous code, because one way, to generate the target sum, I can I found, right, they say we can return any for loop finished, and we never found a valid the for loop, you can just return null, because sum, apparently. Cool. So this code is looking shot. It goes without saying no, sometimes But we already handled that with this nice So I already have some example outputs over are working. Obviously, our last one seems this program early. But before we talk about here, if you look at these other examples, to seven. So that's looking good. This array good. We already saw that this example of No, because it's not possible generate that example is also good to go. So notice here, have returned and would still be considered we get back are really just dictated by the So for example, let's say I switch things same array, just in a different order, we'll one, right? So I'll run this now, notice I to eight, so we're totally good to go. Awesome. They bring this that now the limiting factor seems to be the before. And so let's go ahead and talk about time complexity for this is almost identical is conveniently over here. But sort of refresh. complexity should be described in terms of the foundation. And we already know that M, also say that n is the numbers dot length. recursive calls that I'm going to make, it's going to say that, hey, the time of this function the base of the exponent is the branching And then the depth of the tree would be the was the same time complexity as last time However, it looks like we have some additional coming from this expression, right. So if creates a copy of an array. So that will actually over every element of an array right. So I It sort of under the hood like iterates through length of the remainder result I can get back result in the worst case is going to be in exactly the target sum, right? Imagine that a combination to generate the target sum. target sum was 50. And I had an array filled plus one plus 150 times to generate the target will take m steps, I need to do that for every number of recursive calls, in addition to that M, right. So the time complexity for times M. Really, the thing we want to optimize really want to focus in on that. But while the space of this brute force. So the space, the stack space, it's going to be the same But think about any other space I use up I you return back, whoever we know that we're that we find all the way back up to the top of those arrays that we return is really just would still say that the space complexity Obviously, let's work on optimizing this time brute force. And you guessed it, and there in this brute force. So we'll just memorize the work is always the brute force. So I'll we always say, we'll use the target sum as that is if it's in the memo, then I'll return point, what I want to do is make sure I pass calls. That way, they can benefit from any on over here, right in this stack frame. Cool. take all of the return lines that I had before, trick here is I can say, memo of target. So now the values in the array, or sorry, the arrays, because that's the return value of not right? So I'm just going to complete this in the memo. And in a similar way, I also want to memorize target sum equals No, I can just still return very, very straightforward change. Let's see example of how some 300, it is not possible and fourteens. So should we get an all for And there, we have a really quick running had an effect on the runtime here. Let's talk this code. So that was a brute force. Let's with the time over here. So we know that in of recursive calls that we make, it's the just have to consider any other time operations, but in just terms of the recursive calls that calls. And then in each recursive call, I over the contents of an array, and the array so if I have this many recursive calls, and operation, now I just multiplied by another m times m, which is the same as n times m So the space complexity will be at least as at least o of M, above, now we have to consider So I think about the keys of this memo object, of target sum, right? Because I just literally right? But then everything about the value now, because sometimes of value but in the said that the maximal length of any of these M. Right. So to me, it's now the case that mental object, which is going to be of size, And each key has a value, which is, at worst m times m, which is m squared. Cool. Notice implementation, especially in terms of the trade off that we made here. But now we're amount of time. So to wrap up this problem, board. Alright, now that we coded the house the complexity of it. So recall that for our right, so I need to describe them. So I'll length of the array. Remember that the array baseline solution, that is our brute force right? It was kind of in the form of n to optimize it using the memorization strategy, to a polynomial time complexity. In particular, So really important fact about our memoized Please recall that when we have m squared, is a constant number. Cool. If I look at the pay a little more cost in terms of the space complexity we use up is still not exponential, So I'm still satisfied with it overall. So over the brute force. All right, that was one more variation of it. In this problem, I'll still give you a target from. But this time, what you want to do is of numbers, that adds up to the target sum. the shortest combination, you can return any you probably recognize that this is similar asking for a little bit of an optimization, an array containing the least amount of numbers, we're really just going to add on top of our at a few examples. So let's say I gave you and the numbers I choose from are 534, and can generate your target of seven, one way combination. But another way would be just actually a member of the array. And here I be just the lone seven. So that would be the way, let's see, I gave you a target sum of three and five, there are plenty of ways to two plus two, or you can do two plus three five. And here, I want to return always the plus five. So that would be the result over that Alright, this problem is similar in structure generate a way to make the target sum. But array, right? So let's try to visualize this through this example, with the target sum look like this. And we've seen this tree before. with a different process for the value your valid to just return the first way that I the best way. So let's start coming up with that we can definitely implement some logic recursive calls, we did that in the last problem. to assume some return values. So let's say level problem asked me what's the best way path, I have to find the sub solution for we're rooted at this subtree. And we know right? If I look at this subtree rooted at right? So if I look at the first one, I get will be able to know that all right, one way two, right? We kind of implemented that logic to do is consider any other paths in case That this path of three 300 return upward. you know, between these two options for generating So that means it's sort of two to two versus wins because the array length is shorter. what the diagram is saying, it does make sense because that is the shortest way we can ever But now I can return this sub array to my the value of the edge along that path, right? this makes sense, because one way I can generate But we know that's not the optimal way. Let's let's say we took the same sort of process to generate five, there are three options see three different leaves that are have zero paths, they would work out through their own choose the shortest one, right? So obviously, be returned all the way up to that five node. its parent, then, of course, I need to include right? How did I transition to that five in it in. And now the root node over here has between 332 or five, three, it'll just choose out over here. And I just need to continue tree, right? I can't return early and this optimal way. And I can't be sure until I've Cool. So it looks like our overall logic is we want target sum. But then when we find a way that's can just replace it, I'll continue that process possibility and keep replacing what I consider branch, we would have the absolute shortest. code. Alright, programmers, welcome back to one out. So here I have some initial examples I noticed for this last one, right, I get way to do that is obviously just take a bunch I want to bring our attention to is this third And my choice of numbers are one, four, and four, right? That is the shortest way to generate make is sort of assume that the best way to the largest choice of number as many times took a five in your your sum, then you would is not going to work out to the shortest answer, the biggest choice of number always yields overall. So don't fall into that trap. Which right, we have to do that in exhaustive sort start with that base case, like we always here. So if the target sum is zero, then I just return an empty array, right? That is combination that can generate the target some if our target sum goes too far downwards, is less than zero, I'll just return null, that target sum. And now we'll use our branching choice of numbers will say for let num in and create my remainder, which I know would that choice of number. Right? So what I'm my target sum. At this point, I would make passing in the same numbers array. But now right, best sum is either going to return to return null, so I'm gonna have to kind here, maybe I'll just save this as a result. And if this remainder combination is not null, I'll say if the remainder combination is not this if statement, then that means it is possible remainder combination is, is an array containing Cool. So if I enter this if statement, then right, I can just take the remainder combination, last time. And also add on the choice of number complete combination for target sum. So I'll So so far, this is very reminiscent to our logic relevant for this problem, that is a needed to implement in the tree was, I need RAMs, I'm going to need to work in that logic. to compare basically, all of my branches together, out the shortest combination. So I know that of iterates and attempts, all of my branches. to need some outer variable, I'll call it just keep updating this variable if I find combination, right? So I'm gonna initialize And the reason is, imagine that we set up And then we iterate through the for loop. target sum. So this for a loop finishes, and that'd be great to return, right? Because not possible to generate the target sum at is a good initial default value for shortest logic. So here on line 11, I've actually created But now I need to check, right, so I'll say, shortest that I need to update it. So let's if statement. And I'll start by checking if an array, right? I check if that is less than And really, it looks like shores combination, a little bit. But if I update it with a valid right? So I'm really checking the length of So what I want to do is assign my shortest combination good. So this means the shorter combination at this code, it needs a little bit of work, I know that I be comparing that array length combination starts as null. And I can't do like a nice or clause here. So I'll say, if is equal to No, then you can go ahead and here is going to make sure that I automatically combination. Even if right now it may not that combination I have stored to some possibly looking pretty good. Let's go ahead and give on occasions where we call besam, with a remainder we subtract a number that is maybe too large, out at a base case and return null, which statement. Cool. So let's give us code a run looks like I get maximum call stack size exceeded, base case. So there's some work to be done if I take a look at this code, it's a very, that it breaks the entire code. But really, over here. So here I wrote for letting them indices of the array. So they'd be like 0123. right? So instead of in any of over here, Let's give it a run now. Yeah, it looks like we have 735, and four, four, notice that the doesn't really matter too much. But looks this last example, over here, right? So obviously, we have the brute force recursion. But before of This. So this code is going to be very function, sort of compare the two, it's almost side, right, these two functions look very, we probably have the same or close to the know that over here, we always like to say ahead and say that n is the numbers dot length. force shouldn't be the same story as last of the brute force is going to be some sort tree drawing, in general, the exponential factor to the height power. So not the branching choice of number, and then the height of the n to the M. But along with that, we also have some additional so this for loop gives me the branching factor, line 11, which is copying over the array of worst case will be of length m, right? The is a combination that is just filled with 50, the longest combination possible would So what I'll do is, I'll say that for each have to do a linear operation in M, right? And then the space complexity is sort of interesting values. So look at this. So I talked about space, it would just be the heights of like m over here, right? So I know it's going to then we have also like this variable on line going to be storing an array inside of this the worst case, m in length, right? So what have to have its own shortest combination variable is going to be an array of length for every recursive call right? Before I bought so also, the space complexity here is m times right? And sort of the reasoning is, your however, now you need to have those stack as you recurse. Nice. So really, the limiting time complexity, which is exponential. And memorize this. So memorization pretty trivial So I'll just begun my initially empty memo sum is in the memo, then I should actually Target sum. So now that I have my memo checking storing logic, right. So I need to just go before I return it. Notice that the return the for loop, right in the last problem, it early. But this time, we're going to return So I'll say, for here, the memo at Target I can still return the shortest combination. down the same memo object by reference. Alright, try this last example. Now. Give it a shot. in this last example. And that is the best we cut down on the runtime. So let's talk so the time is obviously much faster should the land, I know that now that every target And target some is really just a number, right? have 50 different keys I can never store in keys in my memo object, I know that I won't for each of those keys. However, I will slap right? So overall, I'm looking at an m times some additional work from this array, right? from this for loop, I'm iterating through copying over this array, which would be linear. just kind of squish these two M's together. n, which is really the same thing as last be the same as it was last time, which was right? And the logic is, your memo keys have their value can be an array of length m, right? So looking at this code, you probably, you best some problem is pretty complex. And I what I really want us to focus in on is this, everyone could tackle this best some problem, problems like can some and how some write the code is very, very similar. So to words on the drawing board. So in its best had m as our targets, and also say that n that we initially implemented it with just after we optimized it, we brought it down notice that between our brute force and our space complexity. So we definitely prefer series of problems. That is we worked on the they all had the common frame of us having with some options given in an array. And in it asks us what that task of generating target and problem. So is how will you do it? So that you'll use? And finally, the best son is the best way to do it in terms of the least definitely is a logical progression to these capture a different variation of a dynamic right, we had to return Boolean there. That's no? Can you accomplish this task? Is it possible? a combinatoric problem, right? We want to And the best some problem was a variation the shortest way to generate the target. So have some common ground, but they also have we're trying to answer. These all fall under being said, dynamic programming problems aren't I think it's time to work on another prompt, do is write a function called can construct as an array of words in a word bank. My goal or not I can make the target by concatenate with that, we can reuse as many elements as that in this problem, we're looking for a yes or no. Is it possible to generate the here. Let's say I gave you this. So my target some words. And so I'm basically asking, Can array. So if I kind of take a look at the the target string, which are just B, A, B, there is at least one way to make the target, So let's say I had this word of skateboard. So take a moment to kind of look this one to generate skateboard here? And the answer here is no. Right? It is not array of words. So we should return false, But we can never build the full string. Alright, but they don't work out in the long run, right? of get stuck, as well as this. And also this we can ever generate skateboard. So we should let's look at one more example. We should easier to create a shorter string than a longer you're probably going to need to use more in mind, that I know that possibly the easiest right? So let's say your target was the empty of random array of words, really, the array no matter what they should return true. Because take no zero elements. From the array, and help us really start to solve this problem. what we want to do is return true if our target array of words we're given, right? Cool, more right? But let's go ahead and start to kind all of the options, right? So I want to really that really means a tree. Right? So let's visually. So my target is abcdef. We already or conclude a true about this input, right? that is the target string as the root of this like, Alright, I have two inputs, how do I Well, it's about what will actually change. problem to the next, the array of words, I So it's not like I'm taking out elements from better or more reasonable to encode the actual Because I'm gonna start with this original about how I transition to the children of shrink the target string, right, I know I I already have the base case of the empty closer to a length of zero. We'll talk about I need to sort of use the array of words as as a choice right now, if I take a B, then of characters from my parent node. So if I child is just C, D, F. Cool. So notice that looks like we're taking out that substring. that I can take out for my word bank, and the child d f. And then I can do this for And the really important thing to know is, it's also a common trap I see a lot of students right now I'll talk about like the common of take out the CD from our root node, if would be a, b, f. And so what we're doing out something in the middle. And if you take your resulting string actually creates a new words, I know that this is kind of suspicious, A, B, E, those are now like adjacent next of abcdef, A, B, he was not present, right. then I'll have this sort of mistake of creating impact the moves I take later on. So I don't to not take out any characters from the middle way of doing it? Well, if you look at our common factor for them is the fact that we root node, that is a B as a prefix, and so that kind of begins some other larger string. over here, there's only one more prefix I If I take that prefix out, then my resulting that we want to use when we build this tree matching prefix in the word bank. And of course, we remove that prefix. So let's keep it rolling. recursively. So let's say I'm rooted at this and notice any prefixes that actually match just be CD. If I took out the prefix CD, then do that for d f, I find that d f is actually also a prefix. If I took the prefix def out which is pretty good. At this point, I look have no matching prefixes inside of the word sort of base case. In the long run. If I can it's not possible to construct EF so that Mr way, if I ever run into the empty string, return true, right? Something we said earlier string, it is always possible no matter what. familiar, right? All I have to do now is kind And overall, if one of my children return So I'll bubble this up a little bit, bubble chooses basically the true value among these And so the ultimate answer here is just true, using words of this array. So you're probably use the same exact logic for the previous how we transition from one note to the next, data. But we're going to carry over a lot that we understand like the general like knowledge we can apply that under any circumstances. What I want to do is see an example where you that skateboard example from before. In If I tried to break down skateboard, I would prefixes from the array. There are two prefixes SCA and SK, and those would give me t board this point, if I route myself at the keyboard In a similar way, if I am at the eight board eight. And I'm left over with board. At this there actually hits a dead end, right, there's there's no matching prefix, because I basically words of the word bank start with E. So I Looking at this board, I can take either a respectively. And unfortunately, those two I can't transition further and take out any those will have to return false. And if all ultimate note at the top that is a skateboard a false as well. So it's pretty clear to me back a single true, then we can just return if everything is false, then we'll just go we're ready to code this one out. All right, let's go ahead and code this one up. So here I have code for correctness. Looking at the last And notice that the target incident F, whereas So we know that that should result in a false. for this. Like we said, a reasonable base right. If you have the empty string, then by taking no words from the word bank. So I need to make my recursive call in a way smaller and smaller toward this empty string. I need to make a choice based on the words through all of the words. So I'll say for every element of the word bank. And now that when it's okay, to make the recursive call we pointed out that we need to make sure that do that, I can just check if the target dot just give me the index where I can find some index i get back is zero, that means that So if you're unfamiliar with this method in dot index of pot, that will tell me the index index zero. But if I looked for tayto, I would in potato. So this is a really nice way I of another string, right, the index should if statement is if I have a prefix, then I I'll create another variable here. I'll call after I remove the prefix. What I can do is slice. And what I want to do is start picking I can say word dot length over here. So it's So we'll trace through this, let's say that note repple. Let's say my word was the string is potato. So I know when I do target dot So this if statement would be true. And then length. So we're dot length is just the length three over here, providing the target that give me everything after the prefix, right? eight. Oh, cool. So when you use slice, if to be the starting position of what you start way through the end. Cool. And that's the code. Now that I have the suffix, I want to basically asking, Hey, is it possible? Can along the same choice of word bank. Nice. So I'm focused in on what type of data do back a Boolean, right? True or false, it tells And I want to check, you know, if this call So if the recursive call is true, then I know So what I'll do is return true early here. and the word that I use to generate the suffix target must also be able to be made. Nice Like you expect, where should I return false, after I've tried every possible choice of can I say, No, the target cannot be created. So this code is looking pretty sharp, I think I should get true false true, and then false So I get true, false true. And it looks like some time to finish. So I think our code has to you know, reasonably run this last example. take a look at the example I pass it for this case here. For one, we know that the answer do a full exploration of the tree, meaning And because of like the length of the string, a very big tree, right? Notice that there's right? every element of this array is actually that happens again and again. So I'll tell And we'll try to visualize what the exact Alright, so we implemented looks like the about how we might want to optimize it, I begin with actually understanding what the us this kind of large example to sort of visualize pot, and I gave you a pretty diverse array ahead and kind of give us though the full this pretty long tree, right, so I follow examples. notice a few things. There are some character prefix, which is totally fine. And case scenario, right? If you take single characters you're going to have a very, very tall tree many steps. So that kind of reminds us of ran the code. But that being said, we want basically some generic size of our input. tree in terms of its overall shape, and then tree has this sort of basic structure. And to describe the complexity right. So I'll n is the number of words in the word bang. variable for each of my inputs, because I to my complexity, possibly in different ways. before in terms of like their structure, right, the time complexity would be the number of start with some familiar territory, I kind height of this tree, the height of this tree our target string. And so imagine, in the a bunch of single character, choice of words that the number of things I would have to or the root to the leaf would be exactly M. characters, so we can be confident that the about the height. Now I need to realize the the tree to the next, how does a number of that the branching factor is dictated by how that would be some relation on n. So I know But then in the worst case, to get to the that, basically, almost every element of the you'd multiply by n. And let's say that carried of the word bank was still a prefix of those by n. And I would do this overall m times, to be exponential, I need to multiply n by me an N to the M, time complexity. In general, call tree like this, then the overall time to the height power. So we have a branching said, this will just really consider the number sure and make sure we didn't do any other of our code. So here's our code, same code some things I need to consider are probably was where I did a target that slice that's And to do that operation, I would actually Right? So that would actually contribute to would I be slicing? Well, if I'm slicing a length of M, right. And so in every call to additional m operation, if I have n to the M over here, right. So I, I added some additional by M. Cool. And so overall, if you look at so that multiplication by m, doesn't really N to the M, that makes it unbearably slow Now let's look at the space complexity. So due to the call stack, it looks like it's Like we always say, the height of the tree we would need on the call stack before we when we return from a call, we would actually The height of this tree is definitely just is just o of m. But again, we should also any other like growing structures. So we look six, and kind of talking about that slice new string, right. And that new string is call to can construct, I'm creating a new the recursion, right, because I actually slice of that, I know that each of my M stack frames that just means m times m in my space complexity, isn't too bad of really a space complexity complexity for our brute force solution is in space. So obviously, let's work on improving you're seeing where this is heading. Let's So this was a huge tree. Take a moment look some work away? To we're trying to do is notice any overlapping that means I'm looking for any duplicate sub here, right? They follow the same structure So I've looked at the sub trees, they're really is they're both trying to figure out, can And if I saw that once, on the left hand side, right hand side. So I can just store that is here to of course, memorize it using our right, here we are back in my code editor. So I'll create my memo object. And here, I'll memo, I know from one call to the next, the need to actually make it a part of the key if my target is in the memo, then what I'll Cool. While I'm here, let me also squish this logic. Now I need to make sure I pass down then I need to actually store data in the recursive returns. Now, you should also store actually complete the return. Right. So for them in the memo. So it's a memo at Target same value. So we'll return true and return my exact argument targets, right? I don't the suffix, right? Imagine if we made the frames target. So the memos ation would still good. And it wasn't that much code, right? layer, we add on top of our brute force solution. And there we have that last example finishing of false over here. Alright, so here's what drawing board. And of course, we'll come up function. Some classic memorization, right? we wrapped up this can construct problem, So again, like before, we'll say M is the in the word bank, our original brute force and that was n to the m times m. And when it from exponential. So now, the time complexity And the reasoning is, now we don't have to time we run into it, instead, we just store of short circuit and fetch the stored result right in the memo, I have complexity, that still have to do the slice, we have to pay object in our memo II solution, our space class. So overall, we definitely prefer this you know, complexity. So now it is reasonable I think that wraps up this can construct problem. this problem. In particular, I want to work up here, I want to take in still a target bank. But this time I want to return a number, that the target can be made using words of elements of the word bank as many times as us to do something slightly different, we we want the exact number of ways that we could a look at some examples. And also, you know, So let's say I gave you this string of abcdef. we saw before, and it is possible, and there's So we can construct the tree in the same way this time around, we want to choose a different as changing the logic for reconstructing our the base cases here, I wanted to kind of just adapt the return to return which is number. So I think the break down our current target any further. be broken down because it doesn't have any that means there are zero ways to breakdown And then when we have the empty string we know, create the empty string. And so that before in problems like Fibonacci, as well to bubble up these values to their parents, the numbers that come back from their children. we do zero plus one plus zero, which means way. And if you look at the way that actually the path from this root node all the way down string, right, ABC plus d f. Let's take a target string purple, and I have some other So take a moment to look at the input here So the answer here is two, right, there are the tree, we know we start with the initial three prefixes that match here. And those pattern recursively down the tree. So the I have a two base cases that actually end going to turn one up to their parent. And can't be broken down any further that returns up these values, until at the parent, I actually two. All right, there are two distinct ways bank. All right, I think I'm feeling pretty one, it's really just a small variation of in. Alright, programmers back in the code So I already have some examples that show count construct, right. So I have some examples with our large inputs, we know that that will foundation with a brute force. So we'll start So if the target is the empty string, then that there is definitely one way to generate from the word bank. Along with that, I need right, I want to iterate through every choice then for every word of that word bank, I need before, if the target dot index of word bank, to zero, then it must be a prefix. And if like the rest of the word that is the suffix in line now say, count construct, and I'm would be target dot slice, and then I'll slice that the slice contains everything after the Also be sure to pass into the second argument, think about what calc construct returns. So particular, this will be the will say, num maybe a little wordy of a variable name, but this returns here, right. So this is a number like the rest of the target. What I want to for loop, I need a way to add everything that create a total count over here. So I'll say it as zero. And now inside of my for loop, the rest of the string, I'll go ahead and as simple as total count plus equals the number right after I've removed the word. And after and I can just return the total count. Something pattern is let's say that none of the choice I finished this for loop. And this if statement true, that I never add anything into the total I return a still zero, which makes sense because target right have no initial step to take this one out. So looks like we should get give that a go. So 2104. And it looks like the last example know where this one is heading. Let me tell memorize this one off the bat, right? Hopefully, feeling really good about memorization. And into our minds already. So if the target is memo at Target. And then I'll need to adjust over here is I'll store that total account let's not forget to also pass in the memo right here. Nice. So let's give that a run right. So looks like I have an error over replace my return value. So I can still return actually adding it into my memo. So let's right, I got zero for the last one, notice it ends in an F and all my words only contain a pretty similar to our previous problem of construct basically has the same shape. Really, that I add into, and of course, the return be the same for these two functions. Let's look at the complexity of this. As always, going to be the length of a target string, array, right? So that means a number of elements as it was in the can construct problem, right, We just brought that down from an exponential complexity remain the same. Really, there for this counting version of the problem, a number that we just add to, you know, on doesn't really affect the runtime or the space this count construct problem. Now I want to do one more variation of the a function called all construct that has the a target string, as well as an array of words to do is return all of the ways that the target inside of that word bank. And that means I element of that 2d array is going to represent the target, right, and I want to return all we can reuse elements of the word bank as we understand this question by looking at an example using purple. And it's the one last problem I had us return to because there don't want the number, I want the exact ways need to return a two dimensional array, the represents the collection of all combinations. represents one of the combinations that creates Let's say I gave you abcdef. And I gave you I actually added some elements inside of this of in our previous examples. Because of this, abcdef. And this contains all of them, right? string. And again, notice that each sub array in the word bank that creates the target. the shape of this problem in terms of the some base scenarios. So let's say I gave you Hello. And my words in the word bank are just is not possible to generate Hello. So there we actually return an answer here? Well, I array. Remember that we're saying the outer of all of the combinations that can create Hello, that means that our collection is empty, are zero ways to create Hello. Now let's say have to generate the empty string using the I think it's reasonable to return an array reason is if it is possible to To create the array, right where the outer array represents inside of that outer array, that means there's does that one way? Well, it's to take no elements to be consistent logic, this is going to be problem. That is, when we're given a target bank, we should return an empty array, right, are zero ways to create it. On the flip side, that it's always possible. And so we should Cool. So with that, let's look at some tree example from before, we know that the overall look something like this. Obviously, now we're values that we do for our base cases. So you that kind of reach the empty string. And I create abcdef. And now I have to adjust the that if I have the empty string, then that something like this, right? And how I actually very small sub solutions. So let's just stay know that these arrays are going to return I also need to make sure that I include the the child. In other words, I'm going to be of those sub arrays. So the key insight is into their sub arrays. And from here, I continue I know that these arrays return their parent edges that I took to get to those children. front, and on the right, I'm going to put at this point, notice that this node rooted both of these collections, right? And what to just combine a both of these arrays. Recall dimensional arrays, which means that a sub the actual target. So if I just concatenate this construct, if I do a quick spot check, question is asking, right? This is a two dimensional that we can create CDF, if I look at what D plus F. And the other ways to do c plus itself. So I'm going to use the same exact I know that these cases return to their parent. edge to each of those sub arrays like this. at the top just to give us some more room. to make a look more symmetric. But I'm not the edges at the very top of the tree. So know that those need to receive AB. In other front of each of those. So I'll just do that, in the middle, which is really just a one them, like this. And finally, same thing on I look at what I have, these represent the original target string. But at this point, of these two dimensional arrays together. 2d array like this. And if I do a quick sanity represents one of the paths that I can take what we intended at the start. So this type the previous examples. But hopefully, you right? Let's do one more together, though, full tree would look like this. And we'll we're going to start with a 2d empty array, empty string. Meaning that hey, it is possible that is to just take nothing. So I do the returned to my parent, but I'm being sure And so the key insight here is, I'm being node label here. The note and the edge happened looking forward to adding the edge right? returns to its parent even further, and so to do everything for this middle path. And at the very bottom. And this really bubbles every edge label as we go, right. So it sort And what's really interesting about this a that doesn't work out, meaning we kind of our initial examples was, whenever we have all using words of the word bank, then we're And that actually works out in our favor, parents, our parent is going to try to add array. But if there are no elements in this words, this one dimensional empty array really always, if I just concatenate all three of my final answer, notice that when I concatenate actually contribute nothing to my file answer, that work out on that right hand side. So both of those sub arrays represent the two All right, I'm feeling pretty good about this Alright, programmers back in the code editor, start by laying out the base case over here. is the empty string, then we want to return single sub array here represents the one way nothing right I take no words of the word to make our recursive logic. So that's going for this style of problem. So I'm going to So I'll say let word of word bank word bank. right? If this word is a prefix, so if target then I know that it must be a prefix, so I what I'll do is I'll go ahead and create an I remove the word which would give me like and I'll say target dot slice of word dot But just to refresh, this just gives us everything the word, what is the remainder of the string this suffix actually wants to call my function like this, I'll pass along the same word bank. intense, right? So we've been doing a lot structure, and then we memorize it in the to do is when you make your recursive call, works, right. So I think about what type I that all constructs and give me back an array, all of the ways to make the suffix. If there going to give me like an empty array, right. create a variable. And I'll call it, let's naming it like this is, I really want us to, from this as an array of all the ways to build two dimensional array, right? There are many the ways to make the suffix, how can I get in this current stack frame? Well, what I suffix ways, and add my word to the front the suffix in the first place. So what I can So now I want to relate how the suffix ways All I need to do is really iterate over every front of it. Right, that's exactly the process use some nice JavaScript methods here. If element of the array, I can do a map here. that a single element there's going to be I want to do is just take that same way, copy But I'm also going to put the word that I before, although maybe this like map method familiar with JavaScript. I think that's fair to demo this, let's say I had some array, my array. What I can do in general is use should pass in a callback. So that means another gonna take in every element, and it's gonna is really just how I want to modify the elements, by two, right, the return value of this callback of the new array. So notice, I get back 2468, a new array using map. And so essentially, in my actual code, I'm just taking every sub of every sub array. So an example that speaks something like this, like suffix ways. And a sub array, and we just an array of some say x, y, and then z. And then the second a x and then a yz. Right, so that's my original suffix ways dot map, and let's say for every to copy over that way by spreading out. And like an A at the front, just like this. So sub array from before, except now I have a So that's all I'm doing in this particular node repple. Back to our running solution. good. It's basically just like a piece of really only going to give me all of the ways currently like on in my iteration. However, branches, right, it's going to use all of target. So I need to kind of gather them all outside, I'll call it result mailstore. Everything I just want to add the target ways into the ways, and I need to actually spread this out Right? Remember that this is a one dimensional dimensional, I don't want to just push target a three dimensional array. So I'm going to So with that, let's actually go ahead and is after my for loop, right, after I'm done the results of Mr. Just work recursively. So let's just try maybe the first example you know, a two dimensional array where I give that a go all construct. Nice, and that's Let's try these other ones. Now while we're for that second example. Nice, here it is. return just an empty array, because it's not is also not possible. So we do get an empty last answer, like we did in our other examples, time. But before we get to that, let's take it. So the biggest logical leap we made here back valid data from line nine, right? And adjust that sub result to get our full answer, suffix, and for each of those ways, I can would give me all the ways to make my target. for every choice of word, which is why I'm outside of the for just pushing all the ways to be super clear, you're not familiar with use the spread operator with it as well and right, this is just using push and spread and let's say it was just an array of just I'll call it just numbs, let's say in nums, my original array. And here's my nums. And going to force some nesting in this array. But it also actually manipulates or mutates, at the array, now, notice that it actually I literally just pushed the entire nums. If what you can say is array dot push, and you separates the seven and eight, basically removing at this. Now, look at the array. Notice that seven and eight without those additional brackets. said, I don't want to add another level of just always remain at most a two dimensional solved this one. And let's kind of talk about This is kind of an interesting problem. So we were on the drawing board, we said that, this problem, it is basically going to require return every possible way, to make the target the work of creating all of those sub arrays, over here. If you think about this example, worst case anymore. All right, here, we know an empty array, because we can never generate remove the Z, then the result will be a very, bunch of ways to actually make this target direction of what it means to be like worst. to use the Z. If you really cared about optimizing, some benefit to like memorizing it, although because the worst case is actually where you an empty array. So maybe just because it's we go to the drawing board, we'll see that worst case. But if you just want to optimize over here, then we check, you know, if our we return the memo, add the target, we'll calls. And then we just need to make sure store that inside of our demo using the target as a key, and then we still we once did. Cool. So let's run this now. runs faster. But it is not the worst case here. Right? The worst case is when you actually And so let's head to the drawing board and here. Like we usually do, well define m to will be the number of words in the word bank. an array containing every combination that with that answer, we have to visualize it drawing, we saw how each leaf of this tree string. In other words, if we can figure out this, then we will basically have the number how many sub arrays we have to generate in our process, we described that there are dimensions tree is going to be m and we know that from the number of nodes by n. And that means at m number of nodes, right, so we have n to the M different combinations that generate each of these entity m combinations, then our output. And so what we're saying here create, we really have to return a result going to drive the complexity of this one. here. And its overall will say at the time. If you want to split hairs here, you can really However, the exponential nature of this alone because once something is exponential, there's different vein, we can say that this space say, it's really just the height of the recursion is very large, we usually don't include the into our space complexity, which case obviously, the result is exponential. Right. So here, use for the call stack, which would be o of this problem would be just about this fast. problem. So at this point, we've gone over many dynamic strategy to work out a solution for all of the ways we can actually implement a dynamic revisit all of those problems, but this time always, I want us to ease into things. So is the same problem as last time. In other the Fibonacci sequence. Here, I'll say that And the first number of the sequence is one, saying that the zeroeth number is zero and time we did this, we said the first number no matter how you start the sequence, they of numbers. In other words, down below here, the output for our fib function should be. Fibonacci number, the answer there is eight, into the heart of this strategy, right? What about building a table. So what we'll do now fib of six. I know that in the long run, I right? So I hope that I get the answer right we're choosing to do is really think about terms of subproblems. But instead of doing a table, really just an array, and I'm going In other words, if my input here is the number six, notice that if I want the indices of with the original input number. And I'm going In other words, this array spans indices zero actually are seven different elements here, So something very common that I see when students kind of overlook this off by one nature, right? has one greater length than my number input. I want it to represent? Well, in the long in a way where each subproblem corresponds I'm going to begin this table. The move here this table with zero. And the reason for me is the fact that I know Fibonacci requires great starting value when I need to calculate I need to be sure to seed the starting values at the zero position of this table, it already zero number on the Fibonacci sequence is zero. contain a value of one. And that kind of entails one. And now at this point, once I've seeded the general algorithm to fill out this table. this table, so I'm going to start you know, just with a regular for loop. And what I need Fibonacci, right. So if I have this number, Fibonacci number, what I can do is just add to in yellow to the next two positions. And is used to contribute to the sum of for the do is take the zero and add it to the next actually don't change the values of those calculated on that first iteration. But any so my current position is always in yellow, in blue. At this point, my current position add it to both of my next positions. So that are contained both a one and a one which so the to the second number of the Fibonacci thing, right, my current position contains positions. Keep doing this, I add two to my positions. And at this point, I sort of reached the end step out of bounds. So really just want to this point, I just add five into my next position, stored in index six of this array. Which makes the Fibonacci sequence is a just like we intended. the most apparent difference from our previous right? This really just requires us to iterate And at this point, the actual complexity of foresee, we know that we're just going to mean that our time complexity is just n. In just the space of the array, which I know overall, we're looking at a linear solution this one, I just want to draw a really important iterative strategy looks very different from really carries over, I'm still using my overlapping I know that every index of this array really n, right? So I can kind of visualize it like number is eight. So I'm just going to choose at fib of six. So I know that to calculate previous two numbers into this position, right. I kind of dropped the table, and even just basically just a tree that can kind of shift So overall, you're looking at really the same just encoded in a table instead of the recursive know, the recursive solution, you should still iterative solution. But I think at this point, programmers, let's go ahead and translate by creating a table, which really just means And I need this array to have certain dimensions in JavaScript, I can say array and call a So here, I want to say n plus one. For the to make sure that the last index of this array because of course, indices start at zero. n plus one size. And then at this point, what this table. So let's just say I console dot run this first example of fib of six. So I'll prints out is this, it says like seven empty right now, according to our strategy, but So what I can do is, after I initialize the zeros using the dot fill method, right? It's now I should have a seven zeros inside of At this point, I also need to fill up a particular make sure that the index one contains a value one equals one. So we're seeding index one first bonacci number is one, remember that Fibonacci, let's just console that log with in the correct state before we actually iterate point for our table. So at this point, what So use a regular for loop for that. We're say let i equals zero. And I'll go up to and through the entire table. And I'll do i plus According to what we did in our strategy. after I right, so I'll say as I'm gonna look I plus one, and also i plus two, right? Of position I. And what I did was I added into current value in the table. So what I'll say to increment it by exactly what table I says, by the value in my current position. And the two spaces away, right, so they both get plus know nice. So this is looking pretty good. entire table, where we're just going left positions, what we'll do is just return our n, right? To finish this off, I just want elements of this array correspond to the Fibonacci input to my function. So let's try these examples. Cool. So I get 813 21. In this very large This is a fair implementation of Fibonacci. iterative strategy, we already satisfy a decent over here, we already mentioned the time and it gives us a linear time and space. However, could actually optimize a little more here if you want to kind of subscribe to just a going to be useful in most problems, I will right of initializing our table upfront, that iterating through that table. Of course, you only track two variables represent your last Fibonacci number. But I'll leave that to you which is a topic want to drill into our heads board and do another problem. All right, now using tabulation. So like before, we're going left corner. And our goal is to go to the moves at any point in time that is to move we actually travel to the goal, if we had to write our function to actually calculate a table for this one, let's say we're going grid, that means that our output should be step in this tabulation recipe, is to create And so here I have two inputs, and they really columns. So I can create a 2d array to correspond to match up here, I'm going to have to make four by four, right? If I give it a four by index is really three comma three, which works that last fib problem. Cool. So I established figure out what should I actually begin my values to use here? Well, I know this is a me to count the number of ways to travel through initial value to choose is usually zero. So But at that point, I may need to seed another you recall our previous discussion about this really important case that all right grid right there is one way to travel the gray actually take that information and encode actually contain the elements of one. And this algorithm. So at this point, what we come up with some logic that combines the different subproblems to solve my larger problem corner of this grid. In the long run, we can through a grid using just some nested for if I'm at this position, if I see zero at zero by zero grid, there's zero ways to move if any of your dimensions contains zero, then So the game isn't even valid. But if we want to use your current position highlighted in right, according to the game, I can only move what I'm doing right now is I'm taking my my down neighbor and my right neighbor. Obviously, then really no arithmetic takes place. But to make sure we have consistent logic, right, and down neighbors, nothing changes for now, iteration, next row, still just add zero to I'm going to take this one, I'm going to add means they both turn into a one, I keep following turn into a one. And obviously, whenever I I need to probably make sure that I don't really an implementation detail for the code. to both of our neighbors. Here, we contribute Now we contribute to to both of our neighbors. neighbors. And finally, things get interesting to my neighbors, I contribute one to my neighbor, this point, we've kind of finished iterating this position, it contains a six symbolizing a three by three grid? Well, there are actually we jump into the code for this one, you can this. So we know that the complexity is really know that this table is going to have m rows this table, it's just going to take m times that we need? Well, it's really just a space m by n. So overall have m times n time and Now. All right back into the code editor. tabulation strategy. So we'll start by initializing complex here compared to our last function, I'll do is I'll start by creating, let's say, as simple as calling array. And I want really for that off by one error, because I want exactly right. And I know indices start at Cool. So I'll give me the correct number of inside of this array are also other sub arrays. to fill this is kind of just a very particular on this array I just created. And afterwards, spread this out like this. And when I map over this array, what I want array is going to be a new array like this, so I have roughly m rows and n columns. So of this is. When I print out, let's say the run this code. So notice that if I look at I have a four by three array, which makes dimensions by one that looks good to go. However, how what this map is useful for. So a very do is Can't I just, you know, skip this map of n plus one. So that will look like it gives But if you write it this way, what you're with a single array instance multiple times, let's say I kind of change only one position of arbitrarily, that would actually look like And that's because this is technically just the outer array, whereas I need a really unique map pattern here. I know every time we evaluate going to execute this entire function, which instance. Right. So if I use this map pattern right? I have a unique array as a sub arrays that being said, Now that I have the correct starting values, right? So what are the seed we said that basically the entire table could right into this line. So after I make a new zeros. So if I run that, now, I should have good. At this point, I also need to see another should see table at position one, one with case, when we have a one by one grid, there's it. So now we have the elements of one in now I need to iterate through my table and just nested loops for this. So I'll say let's I goes up to and including m right, basically plus plus. And very similar for my inner loop is gonna go up to n this time, because we'll through this two dimensional array, right? was the logic we trace through in our drawing? element that I'm at, so maybe I'll call it, would be at table ij. So I need to take this my right neighbor, and my down neighbor, right. means I do some arithmetic on i and j. Right. neighbor, what I can say is, look at table, to my right. And I'm going to increase it look at my down neighbor, and that'd be i this will add to my two neighbors that are point, what we have to be aware of is like know that if we're already at like the last gonna go out of bounds. And so to make sure expressions, I'll need some conditional logic. so if j plus one is less than or equal to end should be okay. And likewise, if i plus also increment right? Notice that when I checked because that's the number of columns and then Cool. So what I have so far as I'm iterating going to take the elements at my current position, as well as my down neighbor, about only if filling up the table, then my final answer the very bottom right corner here. So let's And then there's a very large number, or run Nice and looks like this solution is totally the last example here, right? If you tabulate solution. And we already traced through the know, look at this code, let it sink in, or whiteboard strategy and implemented it in kind of fine implementation details, especially the most important logic, it's about how our to our immediate neighbors to the right and into the drawing board. Alright, now that hopefully we're noticing some patterns right? to tackle any dynamic programming problem this tabulation recipe, it's going to be pretty in that there aren't two main steps when I you implement the brute force first, and then if you just try to tabulate a problem, you're of your solution all in one swoop. And so of course, you have to visualize it as a table. of what you'd like the size or dimensions correlated based on the size of the input. our table roughly, you know, n elements long, for like an off by one scenario, which we've traveler problem, we saw that because our, to create a two dimensional table at that. on the inputs to the problem. Cool. And once within the table. To me, this is always about if your problem asks you to return a number, of your table with numbers right? On the flip in a problem, Na, consider initializing true I have all of the kind of generic values filled seed value, right? I know that this seed value a trivially small instance of the input where in the case of our classic Fibonacci, that values of my table with one and one respectively. were sure to capture the scenario where we to see those values, because that's the basis And then we have the hard part, which is really to come up with some logic, right, as you some logic that fills further positions of you really have to, you know, look to the the case of Fibonacci, it's as simple as if one space ahead and two spaces ahead, very case of our grid traveler problem was about downward, effectively shrinking the size of out the logic, look for it language in the options I have at any point in the problem, do I go downward in that grid traveler and we tackle our a tabulation problems, and we'll Okay, so let's work on tabulating our can we want to do is take in a target sum as an And we want to return a Boolean indicating sum. By adding numbers in the array, we can as we want, we can also assume that all the So we've solved this problem before, right? want to use a tabulation point of view. So say I gave you this input of seven and an is true because it is possible to generate four or a four plus three, and that would that in the first step for tabulation, all the question here is, what size table do I as well as the array of numbers, which of And so the key insight is to think about, the problem. In other words, if we can reuse we need, then it's not like we're shrinking about the target number of the target, some reaching that target. So now we're going to to use that as a basis for my table. That the size of my target sum. So because the the indices lined up perfectly. So I'll actually And in general, I just be creating an array have that classic off by one error over here. of table, what do I actually want to store of this array be? So a really nice rule of what type your answer should be. In the long Boolean answer. So that really tells me that the elements of this array. So I'm going to array with a false value. And the reasoning we check anything, that none of these target Cool. But neither think about any particular this can some problem is we treat the target base that we use. In other words, someone is always possible, no matter what elements I can just take no elements of the array. value here. So I'm going to populate index that we have some good seed value, now we other elements of this array, sort of in a iterate through this table. So let's just I'm looking at index zero. And if I'm situated I'm currently looking at, should basically that index amount? In other words, since I it is possible to generate zero using the position, how can I actually transition into what I want to do now is consider the possible going to start by looking at this first element zero, then if I also have a five in the array, the context of my array, that means I should position. So I look at this spot, right, exactly actually replace this false value that's stored reasoning is, if it's possible to generate true in the zero, it's possible to generate that means that the position of five steps to actually continue this process for the going to look at the next element of three, next spot three places away should also become a true. And finally, likewise, for the last ahead, should also be turned to true. Cool. And at this point, I think I finished when my current is at index zero. And at this the array, so I'm just gonna shift my point I'm looking at my current as index one. And is actually false. So what that means is, numbers of the array, which logically makes four. So there's no way you can ever give value at my current position, then I should ahead. So notice that if I look at my edge going to make that a true because my current to keep iterating. Same thing happens when is false, there's nothing to be done here, iteration right? at index three as my current, means I need to look ahead to my future positions, you'll notice over here, if I look five positions then that would actually be out of bounds. we'll kind of drop that connection. But at positions ahead truth, that's almost a space six and seven are set to true, right? I keep entire table. Notice that as I keep iterating kind of stopped being useful because it goes of all of these iterations, I do have a true is possible not to generate a quantity of I look at just my entire table right now, if I notice where all of the true values are that all of those quantities for target are if I look at the only elements and indices sense, because those are the only quantities generate a one and two, using a five, three So we know by the end of this algorithm, the of our table would be the final answer, right? false, it is definitely not possible. All talking about the complexity of this, as always, n is going to be the target sum, which is say that n is going to be the length of the that, hey, both of these terms definitely me a larger target sum, that's probably a if you give me more numbers to choose from, we can recognize that the algorithm just has table is of size m, so we're going to have every position of the table, what I had to every single element of the numbers array. basically, using some nested loops, where just the table, and then a nested loop to array. So overall, I'm looking at N, N times does this space here? Well, the space is really based solely on M. So I have just m space like an efficient implementation, especially complexity over here. I think let's work on editor, let's start like we usually do by and like we discussed in our drawing, we need sum. So I'll create an array, I need to make one index, that is exactly the target sum. plus one, right. So that means if I pass in of length eight, which means that its very And while we're here, we'll go ahead and actually So I'll do that. I need to make sure that that the target sum is zero, it's always possible what's in the numbers array. So I'll just to true. So let's just console dot log, what this table say the second example here. So I should see this tabulation folder. Now I'm going to run right? eight elements. And I do have a true I want to actually lay out the core algorithm a regular for loop here, let's say let i equals to, up to an including the table dot length thing based on target some I'll do i plus using, you know the manual index, because ahead on the array. But as I iterate through check you know if this position is true, so they know inside of this if statement, I need on what's in my numbers array. But I only true, right, I only got to look ahead, if amount, right, the current amount I'm sort at this point inside of my if statement, what number of this array, so a nested loop here. this array. So I'll say for, let's say, let this time. And now for this number element, I want to look at basically table at index on like the first iteration of this, I know first index of my table. And if my num is looking five spaces ahead right just like that is like five spaces ahead. I want to hey, if my current position is reachable, that must mean position. I plus numb is also inside of this if statement, right? So this the last thing we need is just to return our the table. So here I'll just return table ahead and run these examples. Maybe we'll a probably an infinite loop. Yeah, my program debug this one together. There's something did consider when we drew it out. So something to do with like the bounds checking. Something this characteristic, this may have different that you're following along in. But I know array, and I set it equal to just a handful actually do like array, at some out of bounds assign it like x, that will actually change if I take a look at what happens here, so when we run this, notice that we have about when you do this type of weird assignment your array. That way, it makes sure that this index 10. And so why is that relevant? Well, I'm out of bounds, right, and I just assign the current length of my array of my table, is a little suspicious, right? Because if of bounds position, then the length will get argument, right? I keep iterating, only to the table even more. So that's why I ended way I can fix that is to just maybe limit a little too dynamic. I know, I can basically actually be the better move over here. Pretty, With that, let's go ahead and run this code true, false, true and false. And that is the a nice tabulated solution for our khamsum having n m times n, time complexity. Now it's these exact the loops. And our space complexity that, let's head back into the drawing board work on the house some variation of this problem. some as well as an array of numbers. But this array containing a combination of elements So here, I want to return exactly one way say that it's actually not possible to return the null value. And if it's the case that can generate the target sum, I can return for this one to be very similar to our last logic to return the array now, right? Because an array. So let's sketch this one out. Let's my target is seven and my array is 534. For would be an array of three comma four, right? You can also I guess, switch around the order four comma three, I think that would also to return at least one way that can generate one with tabulation. And so we'll just follow an initialize some table, we already know based on the target sum, so roughly seven off by one nature, right? Because I want the actual number argument. And in general, I'm that is target sum plus one. Cool. So now do I actually have to initialize as elements Boolean version of this problem, we initialized there was, before we actually try all the that it's not possible to generate every quantity. of problem. They tell us that if it's not amounts, then we should just return null. value to just put everywhere in your table. none of the values or none of the amounts is sort of the analog for false in this rendition. added to the table, now I need to figure out some actual data to begin and get the ball about having an amount of zero, right, no a target sum of zero, and no matter what array generate that quantity of zero, by just returning elements from the numbers array, and there course, that means at index zero of our array, empty array. And at this point, what we want and come up with some logic we can use to on our current position. So let's say we begin figure out which further positions of the pattern before, I should just base that off So look at my first number of five, that means the table at this position. And so if I know I see that I have an array and my current position is possible, then a position exactly And so what I'll do is I'm just going to copy other words, I want to put an empty array to include the number that I'm using right to this position in the first place. So I'm Cool. If I do a quick spot check, this is at the state of that index five, it contains return a sum of five by just taking a single logic for the other numbers of the numbers look three positions ahead of my current place. at my current position. So I copy over the I actually want to populate it with the number place. So I just go ahead and put a three for before. So if you go to the next iteration, you see that the amount, right in other words, our not reachable, meaning we can't get an amount array. So what I should not do is actually So I just continue these base iterations. things get more interesting when I'm at index is not null. So it is possible to generate and look at my my forward values, and for need to look five spaces ahead, because that at the position exactly three spaces ahead like this, what I also need to do is make right now, which is three, right, because with three comma three, at index six of my want to do something very similar for the copy over my current array, but then also So now have three four over here. Cool. At is heading right, I've actually already populated is exactly a one way we could create the seven. that you continued the algorithm. So in the the indices ahead would be out of bounds, to our general logic, I would actually manipulate And so what I'll do is if I, you know, follow not really changing any of the rules here, position. So I basically overwrite index seven, point, I would also be sure to include the three, right, because I'm looking three spaces which happens to be like another way I can if you actually continued this algorithm, keep iterating until I hit the very And and is exactly an array of four, three. Cool. like exit early. As you iterate through the your iterations. And you'd still have a valid just want any way to actually make the target. think all of the stored values here make some two, there's a null, meaning that it's not the array. In a similar way, if I look at you can just take one four, to make a some to make a sum of six. And of course, you can that we have a plan of attack, let's look the M will represent the target sum, and our So if we begin with just the time complexity, through the table and the tables of size m, complexity. But for every space in the table, to also iterate through all of the numbers by n over here. Nice. But at this point, now, step here, then what I also did was copy over forward looking position, I know that a sub that m is our target amount, the worst possible sum would be to have an array of exactly m worst case, we have to copy over an array time is really m squared times. And now let's we know that the initial size of the table long run, we could be storing a sub arrays be a 2d table. In a sense, I know that the going to be m for the same reason we just So overall, we're pretty satisfied with the right? It's not an exponential quantity. So All right, I think we're ready to hop into Alright, programmers back in my trusty editor, need to create the table to begin, right. roughly targets some positions in it, really, array, and I'll pass in target sum plus one, to go ahead and fill this table up with all in our drawing. What I also need to be sure of our table with an empty array serves as that the target sum of zero can always be sum of zero by taking no elements from the of this array, it would be zero. Nice. This So you've seen this code before. I equals time, I go up to an including target some in shape to our last problem. Now that I'm I need to add some conditional logic. If you the heavy logic when our current position you can't even reach this current position if my current amount is attainable. In other amount, if that is not know, if it's not know can generate amounts i that i know some other want to look forward in my table for every num of numbers, so I'm getting the elements that number of positions ahead right. So if looking position would be at Table A plus over here. So I'm going to do is start by my current position, right. I know that if it could be is an array, right can be array of many elements. So no matter what that array array. So I'm going to spread out all of the is looking pretty good because I'm basing I, right. But in addition to that, I also just going to add that into this new array previously in the course. Right. So I'm just at table I, and adding on an addition to that pretty good. I think at this point, all we and then wrap up by returning the last entry target some cool, so not that much different a shot. So I'll run how some and here I have of them should return null because they're bunch of twos and another No, nice, it looks that we already have a very efficient algorithm tabulation, we definitely have m iterations the inner loop. But then we also have to consider an array will be at most m. So it's m times how we spoke about it before. It's something isolation, if someone just asked you to solve it's an easy problem. However, it probably just did cancer, right? There's a really, problems. If you compare the house some and right, really just changing the type that assignment that we do when we transition into just adjusting that logic for the data type some array answers here. And here, I have smashing through all of these tabulation exercises, some problem, that way, we'll have a little it's time to revisit the best sum problem. sum as well as an array of numbers. But this the shortest combination, that adds up to the shortest combination, we can return any at an example kind of like we did before, a few different combinations, I can yield plus two, or I can do two plus three plus these options, the shortest one is obviously return value over here. Obviously, if you be a valid answer. Nice. So let's start tackling we need to decide on the size of our table, on the target sum and not so much the length saying recently, it would be nice if the last target. So although the last index of this length would be nine, right? Let's start by to begin my my value seed with the type that's words, they want us to always return an array the sum. And I know that trivially if I wanted what array of numbers, I'm given the answer, to be sure to store that value at index zero in the array, I can't be sure if I can generate as null just like our last problem. At this by iterating through the table. And so what based on the numbers of the numbers array. now I see that there's a no inside of that a way to create two, but I'm actually finding array from my current position. But I also ahead by so just to inside, and do this for something similar happens for three, as well began the algorithm, this is a really the further values. And so let's keep these iterations by one since my current position, good things right have no way to generate a sum of one current position. So we move ahead to do, have an array over here, that means I should by looking two spaces ahead, I see that at I actually need to replace that now. Alright, then I also add the value for how far I'm two inside of that index of four. So now I index five, I'll notice that index five already my sort of standard process, I would consider in yellow, which is an array of two, then by which is three. And technically two comma But it's definitely not the shortest way right, arrays, and notice that the original array one should get the stay in this spot. Cool, I see five spaces ahead for my current position which means that I can just go ahead and put array of two, then I add the five, right, I keep this process rolling, I'm going to Notice that this sub array I'm considering stored at index five. So I actually don't the same. Now I look three spaces ahead. And at least a way to generate six. So I copy value. And now if I look five spaces ahead, which means that I'm actually finding the my array of three, and then I add my five actually already found a way to generate eight. be the shortest way in the long run. However, would actually be nothing wrong with continuing put something longer in that spot. So if we two spaces ahead for my current position, two comma two, to my array of three, three, one, so the three comma three gets to stay. be comparing two comma two comma three to is shorter, so it gets to stay. And this process array. By the end of this algorithm, we do have the before we jump into the code, let's look at MSR target's m, and n is the length of the of the time complexity, it's going to be the times n, we don't really add any additional into the mix is just some conditional logic, So that's not going to add any additional is still m squared, right, because I have of that table could be an array, really just let's hop into the code for this. Back in out. So we'll start by creating our table. of targets. But really target some plus one I actually initialize this table, I want to So by default, all elements will be no basically be generated yet, we have to actually prove them. But the really important seed value array, right? Basically, the one guaranteed of the array. This point I need to iterate do. I'll go up to the end including why not every position of the table, I only need to is not no, right. So if my table and my current need to do some additional logic. So just if my current position is not know? Well, current position is null, then I don't need this position if this position isn't reachable a non null position, then I'll actually iterate I'll consider possible moves. So let's say these additional numbers, and then I need by that number amount. So I need to write right, just looking forward in the table. it can some we ended up doing this logic, array, where we took all the elements from out that array. Then we added additionally, so we have to actually add that into our move add some like, min value logic, I want to that is shorter, right, I want the best way, or refactor this code a little bit. I'm going above. So I'm going to save this to a variable. is like my candidate combination, I'm not right now. And so if I do the assignment over I only want to do this assignment on line I want to express is, like, if this current stored, right, I only get to replace something to express and an if statement, right? So needs to be if the thing already there. So thing is actually bigger than my current combination, to be sure to do that element dot length, current thing being stored in at that future Nice. So this code is looking pretty good. but I think we'll just run it and we'll kind end, I return my table at index Parkinson. added this conditional logic. So if I run of foresee it's very an error. And the error message alright, cannot read property length of null. this expression. So we know that our initial So when I look ahead to a future value, and to make it, then I'm going to check the element, dot length. Right. And so I need a way to a null value in my table, then I can just I found at least one way to make that. So So I can still do the assignment will say value. So let's say table at index i plus is really false. So if I say not false and assign that combination to that position, for using this syntaxes. We know toward like to potentially look out of bounds, which means undefined is also a falsie value. Right? So as true, which means I would still correctly thing is I need to be sure to not do this You can't say no dot length, and you also will guard against that. So with that change, and a bunch of 20 fives nice, especially looking the best way to make 100. And just to be super around the order of these sort of ways. So still give me a bunch of 20 fives, right? to generate each some, which would mean the interesting tabulation a problem. However, to our last how some problem, right? So here, on the right, notice how similar the code statement, right? For the best some problem, this does is prefer to keep the shorter combinations that's what I want to return in the long run. preference in either direction. Awesome. So board, I think we'll kind of switch things those string problems with tabulation. Let's we're going to take in a target string as And this version of the problem and I want false, indicating whether or not I can make elements from the word bank array, and I can as I want. So we've seen this problem before. an example. So let's say my target was abcdef. substrings. In this particular scenario, it of the array. So the answer here is true. string is by just doing ABC plus the fright. to this one. So I'm going to create a table I want to base the size of this table off really where I have some problems, I'm going in other words, building up to my original to make it about the target string and not to remove a word out of the word bank. So the sizing is is kind of particular, because information of a string, right. Whereas before to just use the index as the actual number. an encoding here. And so what you'll notice right, table dot length is seven right now. by doing target dot length plus one. So we that's kind of a very characteristic of these And so what will this table represent? Well, target string, I know they have corresponding wondering, then what's the point of having right? What I need to store index six, if reasoning is, we need a way to actually represent here's the pattern we're going to use. If actually making a statement about the empty of this table, depending on what that index starts at index zero, and goes up to but not see how this scales over the rest of the indices I'm looking at index one, and you're really two, then you're looking at a B, if you're for index four, then you're going A through at A through E. And so the really key insight table, it means I'm making some logical statement going up to but not including index five, about the entire target string, then I should imagine you start your substring at index your current index. And again, the whole reason a statement about the empty string. And so speaking of the empty string, let's that a really core you know pattern in this hey, if your target string was empty, no matter word bank, that is always possible. So it's of my table, I can go ahead and seed a boolean as the elements of my table? Well, if the then it's probably a good To actually just So if index zero is going to start as true, right. So I'm going to consider all of these until I prove them otherwise. Alright, so begin like we always do by just iterating, just we have some notation to make it easier table to the statement it makes about our up top, and I'm going to like them up based here. So if I begin at index zero, like we about the empty string, right, I see a true the empty string can be constructed using to figure out how I can look ahead to my further do that based on the choice of words in the like a B. So something great about this option from my current position, right. In other in yellow, the characters below it start with now would be a totally legal move, right those I'll go ahead and look two characters ahead, that just means look two indices ahead. So is actually reachable by just taking a B. I would do this same logic for the other words words, ABC is also some matching word. So would be the only other one that actually one true. Again, how do I know to actually just the length of the word right, my current looking at a word that is four characters ahead to store my Boolean. Cool at this point, for this current position. So now I can move And so what you'll notice is in this current f, which means that it's false, right? It write, there's no way you can ever just give in the word bank are too long, right? So I logic from this position. However, on the true, then I need to do my heavy logic. And stored in this position to write if I'm looking I'm making some statement about indices zero the substring AB. And I know that if it's at the elements of the array, it's definitely get to this position. But I need to look ahead. bank that match starting from my current position. So if you look at my going characters, right what I'll do is I'll look two characters ahead true. But the value stored at this position changes here. And there are no other words a C. So I'm actually done with this pass. for any matching words that begin with like that, really, the only one here that works now I'm basically considering this chunk, look three positions ahead, because the word right def is just three characters. If I do I'd be making this one a true now basically colon at this point, I would do the same thing else is really going to change within this And so by the end of the algorithm, we have our entire string is possible to be constructed. if I look at the table at index six, that substring that starts at zero and goes up really be the entire A through F. I know that be generated, right, which was our final answer there's a false here, which means that I'm four, right, so ABS C, D E. And since there's it's not possible to generate this string. bank, it's definitely not possible to ever our table a does look consistent with that, So we know that m is going to be our target of words in the word bank. And so we just know that we're at least iterating through was roughly size M, right? However, once we we had to look ahead based on all of the words N operation for every iteration of m. And coming from my current position. And to make I can't just take arbitrary words, from the have their characters matching right now, or the maximal length of a match, I would of M, so give me an additional m term. So time complexity of this one. And besides that, comes from the table, which is just a array from a bird's eye view, it looks like this we have a polynomial time complexity, but So let's code this one up now. Alright, let's start by creating our table. And so we'll length, plus one just like we spoke about give some initial values to my table. So I'm all falses. So we're going to assume that constructed until we prove it otherwise, then zero to be true, symbolizing that the empty from there, I need to iterate through every just go up to the entire table. And here just to target dot length. Nice. And as we iterate, value. Recall that in our strategy, we said our current position is reachable, so our go ahead and check Hey, if my table at index If I enter this if statement that I need to use to progress to other spots in the array, I want to iterate through every word of the word of word bank. Nice. And so what I want words is I need to make sure that these words to my current spot that I'm at. In other words, then when I iterate through all the options use a valid words that match like a, b, or trying to use def right now. Right? I need based on whether or not they match characters, And what I want to express is, you know, if at position, I position I goal, it's not going to translate matches to something straightforward, just figure out how can I look at the correct you target, right? It's pretty straightforward. I'm going to slice starting at index i. And to go like the length of my word. So the move dot length. And so let's kind of break down if your word matches your characters starting Let's say that my current position is zero, at this position like this ABCD f example. if I look at this slice, it's going to slice zero plus three, right, the length of my word would actually look at this run of ABC. Good. the string. Let's say we were actually at at this D character, that means my value for the current word I'm considering, let's say So this ending index is going to be three slice starting at this character, three, going I always exclude the ending index of six here. is check if my current word matches the characters if statement, then I have a successful word. looking position. So I can just set table. look? Well, you need to look exactly this matching me we're at index zero of our target dot length characters later, three characters table of i plus word dot length, that should is to our previous number, like our target this four string data. So now I jump ahead So this code is looking pretty good. Let's I want to return the table at Target dot length, or at Target length, a position of my table, entire target range starting at index zero So here are some examples. Let's give this Nice, and there we have a nice working solution. really the most tedious logic here is probably sure you kind of understand how this comment our previous recursive immobilization strategy logic to make sure our prefixes match. This we already spoke about the time complexity right, we have m iterations here, we have work we do is this slice, right, I'm slicing I have m times n times m, or m squared, N. m space. Cool. So with that, let's head back revisit the count construct problem. So we're well as an array of words in a word bank. right, we want to turn the number of ways elements of that word bank, we can reuse elements So let's take a look at an example of this. target of purple, and I have an array with be two because they are exactly two ways to you can do p plus u r plus p plus le ran, this problem, we really just want to return mind. So let's follow that classic tabulation the size of the input that changes, which we want to actually use overlapping subproblems And like we always say, we're going to have the number of characters in my purple string seven. In general, you want to make sure your of elements inside. That way, I have a way last tabulation. And so we'll start by thinking this problem. I know that when I have an empty matter what array I'm given, you can always no elements of the word bank. So the answer there's one way to make the target string So I'm going to store the value of one at how to initialize the other values in my table. right? It's really important that you try data type. If I remember my similar counting traveller of the move here is actually start saying, you know, at the start, I have zero of purple. And then as to actually find distinct in the table. But we'll get to that. So we'll of course, beginning at index zero of the show the characters that we're considering pattern here is when I'm at some position information about the substring that starts index, right. So if I have some information about the empty string. From my current position. bank that I can take right now to give me since I'm at index zero, I need words that first word of perp. And so if I looked at me a somewhere else within the table, right they'll end up at this position index four. by one scenario here. So although I'm going informations about the substring, that spans and what I need to do now is take my current future position. So I just add one into the basically saying that so far, we found a one from there, I look at any other words that look at the next word of P. Again, just moving now, I'm still at my current position. And character ahead, right, because p dot length is of course, just take my current value in zero plus one is just a one. There is one position, that's purple without the E. And they'll bring me all the way over here. And I think that ends are a very first pass. And So now my current is at index one. So now that begin with a you and kind of match characters just you are in the word bank, if I took a right, so bring me over here, what I should and add it into that position. Now I have words of the word bank that match from my to the next spot in the table. If we're at that starts with an R, there's actually no this position. And what we also notice is this won't really do anything in our table in the table. Here's where things start to is at index three. So I need to grab words have an L enemy. So what I can do here is one character ahead. If I look one character value, right circled in yellow, and I add to two now. Nice. And then from there, I need in my table, right shift my current point At this point, what I do is I again, look really only one that matches perfectly, I of Le is two. And what I do is I take my current right, my logic throughout this entire algorithm in the last spot, you can probably already if we continue the algorithm as normal, or next position, there's no word of the word here. And once we hit the very end, we're we see that, hey, we have a two in the last expected answer. Something I think is really our final answer is in the last position of table should make some logical statement about at index for over here. I see that there's that really saying? Well, if I am looking I'm considering the substring That starts that really means I'm looking at purp, right. the array, that means that there are apparently check in my word bank, that's exactly true, because that's actually a literal word of P. Cool. That's some consistent information. now what I can do from that position at index basically what we did when we traced through you really doing? Why is that value in the has a length of two. So that's why I'm looking I think about what like logical operation it to all of the ways that I have in blue ways to generate purple right in my last spot, move, right? Pretty elegant logic. Let's talk So we know that, hey, r m is going to be the words in the word bank, this is really going rendition, right? You can't construct. So we definitely have m time for just iterating have an additional n, because we have to actually bank. And so where does that final m come from actually performing the match of the way, the space complexity is just going to the table, we're only ever storing just some stays at linear o of M space. All right, I'm it up. Alright, let's code this one out. Let's as an array with roughly target length, size, index aligns, right, I'm going to fill this know in the long run, I'm going to add into being said, I have a really important c value, zero actually starts as one, right, because right. Now from here, I can start my core position of the table. So set i equal to zero, hit every index, right. And so what I'll do bank. So let's word of word bank. And as I iterate through every word, I need right there has aligning characters. So you've that slice I'm gonna slice some characters this is my current position, I need to look the length of my word, I'm going to slice position is I, this will give me the next at position, I will check if that little segment now. And if it is equal, then I have a word further position of the table. In particular, at index i plus word dot length. So I'm looking is I so I'm looking ahead in the table based do is actually increase that by some value, my current position, right? That's what we A common mistake that I see students make by one here, right? That's not the move Do number that's in your current position, right. do is just return our final answer, which Target dot length. Cool, so I have some examples give this a shot count construct. So I get large example, which should return zero, you because your word bank only contains a bunch is looking pretty good. Notice how small of you're really feeling the progression. So That that was our can construct problem. So difference, right, instead of assigning a because I have numbers within my table. That the drawing board. Let's do one more problem problem. So we're still taking in our target word bank. But this time, you want to return target by concatenating elements of the word that means a single element of the array represents And like usual, we can reuse elements of the we take a look at an example, let's say I this array of words, you actually have many four ways over here. So each sub array represents it together, you get the target. And so notice as an element of the outer array over here, something, then I want to return a 2d array. that we should keep really in mind having foresee. Right. So let's say I gave you this and I gave you just some words in the word is empty, your result should really be a 2d, here represents like the collection of multiple that makes the empty string, right, so the we take no words of the word bank. And this take give you this example, if your target and dog, then the result, there should be The array over here represents the collection here, right? There are no combinations at sort of seed value base case scenarios in of abcdef. I'll start by initializing our one. And so we know that the size of this right, just like we usually do. And then we we kind of just spoke about them, we know to have a 2d empty array. And so we'll initialize I know we're going to need a lot of room. Now for all of the other elements of our table, empty arrays. And here's the reason why I I have to actually check for ways to generate found right, that's why I just have an array index zero, right? index zero has one combination Cool. So let's start with our general algorithm. to our last few problems. Now we're just adjusting So we know that we're going to try to visualize prefixes, right. I know that if I'm highlighting prefix or an index zero all the way up to table. And I'll light up those characters now is since I'm currently at index zero of that have matching characters from this position. this A B move, then I should look two characters two. So that brings me to this position in of the combinations in my current location this future position. But when I do that, combinations, the move of the word I just an AB inside. Right. So again, kind of repeating current position in yellow. But then I have right now into each of those combinations keep our current position here because there that have matching characters, right, I can very similar happens write a copy over my ABC to it. This happens one more time for Awesome. At this point, I've considered all position. So I can move forward a little bit. starts with A, B, right? Because my current find any words of the word bank, that kind moved my current once more. What about this word bank that have a seat, right, and there right. And if I do that, I look two characters position. So I'm looking at this index. So situation, right? I already have a some combination one way we could make ABCD, right by just also do is, I should take all of the combinations into that index for right, so I'm taking the four. But then I also need to add to that now, which was CD. Cool. And then from here, far, two ways to create ABCD, you can just B plus CD. So this logic is taking some some there's actually one more word that matches, like I do, I look one character head or one I copy over the combinations from my current the word I'm consuming, which is just an additional ABC. At this point, I can progress my current words that start with a D, right? So that of three. So I look three spots ahead in my here, I copy over my current combinations end of all of them the D F word that I'm using point, I can iterate my current position. I look at any words that start with any, and EF. And so I look to character's head or to again, this is a scenario where I need to right. So if I look at my current position all of those combinations and copy them over And then from there, I also need to make sure now, which is an E, F. So those two combinations this point, you see our final results at the algorithm, we would just move our current a no words of x star with an F over here. there we have our algorithm, right, that index ways we described how we can use to create to look at this table. And notice how every statement about the target string. Right, say index three, that's giving me some information of my original target. And what saying is, take ABC, that's actually a word of my word the only other way that applies for all positions like at index five, that means I'm reading there's no combinations at this position, ABCDE. And if you take a quick glance at the can't possibly just generate ABCD. Overall, that we did was very consistent. Before we analysis. So we know that m is going to be define n to be the number of words in the the memorization and recursive solution for a sort of brute force, right? Because they're way to generate our target string here. So the shape of an exponential, right, so about like multiplication terms of M in it. But overall, we're looking at an exponential that? Well, we know there's going to be an that we need to return. And I have to actually by piece. And so I'm looking at at least exponential that's really the limiting factor, right. for this is also going to be exponential. have at least m space just from the straightforward element of the table itself is going to be with like a 3d table in this instance. And of our table, we're going to have potentially you consider the very last spot in our table, number of combinations inside of it, but then table, so it'd be really a little more than roughly exponential complexity. And you can't in terms of the time, I'm really asking you we'll actually be able to see that once we for one last time, let's solve this all construct By now we're tabulation masters, this is very, target size really target dot length plus of my table as arrays. So here, I need to array in every spot of the array. So I'm going I'll map over it that way I can generate a me just style this up. And so this should right? Notice that the elements right now These arrays represent the collection of combinations. I have no combinations for most of these elements, table at index zero, right? That should be the outer array here represents the collection is one combination that you can use to make you take no words to the word bank. Cool. just iterating through my target, and you've through my table. And what I'll also do is iteration, I'm going to consider some words word bank. And like before I send you to check characters based on my current position. So many times by now. And I'll slice a segment slice starting index i, and grabbing the next I'm going to compare that chunk to the current using this statement, I'm sort of filtering logic on the words that match based on my you know, this nested for loop an if statement new logic within this if statement. Cool, types of data I'm dealing with here. All right, table at index i, well, that's going to do And if I think about what data it's going right? It's either going to be like an empty current target. Or it could be a multi dimensional way I can make the current target. So if this current, then what I'll do is I'm going to we did was kind of copy over all of our current our word that we're using right now to the what I'm doing right here, and a map over copy over the elements of that summary using And then also be sure to add on at the end let's say, our new combinations. So I'll just is going to be a 2d array, right where every And I want to take these combinations and my table. So I know I need to kind of look index i plus word dot length. I know that arrays, right? So this is going to be an array, exist at this position, right? So what I don't because then that would overwrite any previous for this position. Instead, I need to make to that list, right. So what I'll do here of the elements of my new combinations right it out. That way, I don't add any additional pretty good. I think let's go ahead and return some examples down below. Let's give this Right, notice that these last two examples impossible to generate. Cool, let's hover most tedious logic here would be these two like these two lines translate into the logic these lines again, right? line 11 is going position in my drawing that was like my yellow to each of those combinations. And then we're add them to the list add our further position, spoke about the complexity of this one, it's a little more than exponential. Right? If these maps and like spreading, we have to is going to contain an exponential number example, let's say that I made it a little up the size of that input. It's going to be just do it. So let's say I had a bunch of example. Yeah, it looks like our program still really, really a massive array probably can't we'll get like a stack size exceeded, even calling functions way too much over here. this problem to sort of demand an exponential the drawing board where you can wrap up this Alright, programmers, by now we solve many And I want to leave us with some final advice. dynamic programming problem, start by really subproblems. And then from there really focus its type. And from there, you shouldn't be input? So in our string problems, usually it's the empty array, or in our number problems, Is there some input wherever you don't really The answer just sort of is what it is. Once base case, really, then you'll want to realize larger inputs. And then you have two options, use memorization, or you can think more iteratively I think as you practice dynamic programming in two ways, one using memoization and one point on, it's okay, if you have like a favorite But that being said, it really helps to have you've made that decision on, you know which know, slow it down and draw a strategy first. about just data structures and algorithms or draw our process on the whiteboard, we And it's much harder to do when we just write if you slow it down and take a moment to draw more productive, as well as more intuitive course, through all of that, you're gonna these quite hard topics. Alright, programmers, you had fun, you know, learning this new topic. you. So what you want to do now is head down byte comm where you can actually practice see you in the next one.