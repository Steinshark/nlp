[FILM REEL] [MUSIC PLAYING] DAVID MALAN: All right, this is CS50. And this is Week 3 already, wherein at Week 0 where we first began. And in Week 0, recall that everything We talked not just about representation And we talked about tearing And that somehow got us But today, we'll try to start and capturing some of those same yet, but in actual code as well. But we'll also consider the like just how good, how well-designed And if you recall, when we wherein I first had an algorithm and then second one two pages started tearing the that we, with a wave of the hand, We proposed that if the x-axis like number of pages in a phone book, to solve the problem page tears, whatever recall that the first algorithm, which had n pages in the phone book, and there's this one-to-one Two pages at a time, of course, the same shape, the yellow it's n over 2, maybe plus 1 if you But it's really still fundamentally or two pages at a time. But the third algorithm, recall, where we called it logarithmic in And indeed, the implication was that we could even double and no big deal-- one and we take yet another 1,000 So today, we'll revisit some of but also translate some of And all of that now have this lower-level actually inside of your computer. This, of course, is your And recall that if we start your computer's memory is In fact, we don't have to And we looked at a grid of bytes like could be used to store a char, an at that. But let's focus perhaps because last week, of really, arrays, storing And that allowed us to start of characters, and if we wanted to have multiple ones and But the catch is that if you look inside and for instance, suppose these it's pretty easy for us and immediately find the number 50. You sort of have this bird's seated of everything on the screen. And so it's pretty obvious But in the world of it turns out that this is hardware. And computers, for today's purposes, They can't just take it all in and So perhaps a decent the array of memory really is a sequence of closed doors. And if the computer wants to it has to do the digital equivalent at a time. Now how can code do that? Well, of course, we introduced whereby we, by convention, call the the second location 1, the third indexed. And this allowed us to now bridge going on in memory with actual code, syntax via which we could go searching And it turns out, if I now paint it would seem that we actually have standing in place for what would if, for instance, you're storing And so today we begin with a look That is for searching. Searching is all over the place. All of us have probably gone to multiple times per day. And getting back answers fast are really good at. So how are they doing that? How are they storing information Well, let's consider It's really just a problem The input, though, to might be this array of seven lockers. So that's the input to the problem, And maybe for simplicity now, we just a bool, that is to say-- of whether or not some number It's not quite as fancy as Google. That doesn't just tell you It actually gives you But for, now we'll keep as part of this problem we have found the number we're looking But it turns out inside of this black there's all sorts of And we talked about this at a with the phone book. But today, let's consider by way of a game that some of you might And so behind these doors, some denominations of monopoly money. But for this, we now If you'd like to greet the world? JACKSON: Hi, I'm Jackson. STEPHANIE: Hi, my name is Stephanie. DAVID MALAN: And do you want about yourselves-- years, house, dorm? STEPHANIE: I'm a first DAVID MALAN: Nice. JACKSON: And I'm a DAVID MALAN: Nice. Well, welcome to our two volunteers. So why don't we do this? Would one of you like to STEPHANIE: I'll go. DAVID MALAN: OK. All right, so Stephanie's up first. And behind one of these doors here, And so we'd like you to find the 50. We'll tell you nothing But we would like you to And in fact, I'm going to give And I'm going to give It's called linear search. And as the name implies, going to end up walking in But how are you going to do this? Well, let me propose that will be to think kind of like a loop. For each door from left to right, what Well, if 50 is behind to go ahead and have you return true. And hold up the 50 proudly, Otherwise, if you get and you haven't found the throw up your hands in disappointment. False-- you've not found the number 50. So to be clear, step one is going to How would you like to begin? Yep. Oh, and then-- yep. There we go. Yep. And if you'd like to at least tell-- good, good acting here. What have you found instead? STEPHANIE: It's not 50, but 20. DAVID MALAN: Oh, OK. So step one was a fail. So let's move on to step two. Inside of this loop, what STEPHANIE: I'm going to DAVID MALAN: OK. STEPHANIE: Almost. DAVID MALAN: OK, almost. Sort of. A 500 instead. Next locker? STEPHANIE: I would rather take that. No. DAVID MALAN: OK, we're STEPHANIE: It was a 10. DAVID MALAN: OK, so keep going. This is step three now. STEPHANIE: Oh, man. DAVID MALAN: Five, OK. A few more lockers to check. STEPHANIE: A little sad, guys. DAVID MALAN: All right, STEPHANIE: It's 1. Kind of close. DAVID MALAN: All right. And finally, the last step. Clearly you've been, STEPHANIE: Let's go! DAVID MALAN: All right, And Stephanie, if I may, let So on the screen, this is the Suppose, though, I had have gotten to the habit of doing You often have an else branch as well. Suppose that I had done this now. And I'm marking it in red But what would have been bad about might you say? Any instincts? STEPHANIE: Then you the code before you found the 50. DAVID MALAN: Yeah, exactly. STEPHANIE: I mean, you'd DAVID MALAN: Indeed. When Stephanie had opened the 20, of course, is not 50. She would have decreed false. But of course, she hadn't checked So that would seem to be a key of the pseudocode, we actually and only return false but just at the end of the loop such don't return true earlier than that. Well, let's go ahead and do this. Let me take the mic from you. If you'd like to take And Jackson, in just a moment, Carter, if you don't mind But in the meantime, let me translate that same idea to code. Pretty high level, pretty but really now, as of last week, and, soon, Jackson could treat this indeed an array using bracket notation. So we can now get a little closer And the way a computer would translate fairly high like this to something that's a that supports arrays would be a But you'll see more of this For i from 0 to n minus 1-- But that's the English-like we've known come to know as a for loop. If 50 is behind doors bracket i-- so that doors, now, is the name of my But then the rest of the logic, really is the same way. And so you'll find in time that generally, when you start expressing instead of maybe operating you now have a new vocabulary, that you can be a little getting so into the weeds but at least now doing something an array like this. So Jackson, would you All right. Yes, yes. Support for Jackson here, too. Nice. And here now, I'm going to allow you an Stephanie clearly was searching from left to right using But they were pretty much There was a 20 over there, there So we deliberately jumbled things up But Carter kindly has just come by sorting the numbers in advance. And we'd like you this to do something again using what we'll now call binary search. It's exactly the same algorithm But if we translate it to we now might say something like this. The first step for Jackson if 50 is behind the middle done some mental math to then he's going to just return true. And hopefully we'll get lucky Of course, there's two other which would be what? 50 is, with respect to these doors? Yeah, so to the left or to So if 50 is less than the Jackson's going to want to go left. Else, if 50 is greater he's going to want to did physically last week dividing and conquering left to right. But there's actually a fourth case. Let's put it on the board first. What else might happen here Yeah. Oh, it's not there. So let me actually go back and amend my if we don't hand you any as he's dividing and conquering, we have to handle that situation All right, so with you want to go ahead and and walk us through verbally JACKSON: All right, so it looks So I'm going to open it. But it's 20, not 50. DAVID MALAN: Aw. What's going through your head now? JACKSON: So now I'm looking-- because 50 is higher than 20, DAVID MALAN: Good. JACKSON: And look for the new DAVID MALAN: Nice. JACKSON: And it's 100-- bad. But 50 is less than 100. So now we to look left, And ta-da. DAVID MALAN: Nice. Very well done this time around, too. So thank you, first, And in fact, since you're a fan we have the Cambridge with all your Harvard favorites. JACKSON: No way. DAVID MALAN: Here you go. STEPHANIE: Thank you. JACKSON: Thank you so much. DAVID MALAN: Thank you to our So-- that was more So here, we can translate this a little closer to code. And again, still might be another formulation of just using the where you can be a little more and still leave it to someone else But here we have same If no doors left, return false. If 50 is behind doors bracket middle-- so I'm assuming here, that somewhere I've done the to figure out what the For instance, if these are this would be location So somehow I've taken the divided by 2 to find the middle. That's 3 and 1/2. We have to deal with rounding. But suffice it to say there's a the middle index. Given the total number of lockers, So that's presumably what or in his head to find us door number 3. Not the third door, the 4th So this is just saying if 50 is behind That was not the case. He found a $20 bill instead. Else, if 50 is less than the and now it gets interesting-- search So it's getting a little But if middle is 3, this one have Jackson search if 50 had been-- if the number had been less, and go up through this one. And we deliberately the point of looking in We might as well do 0 Else if 50 is greater than doors what did we then do? So Jackson intuitively searched through doors n minus 1. And honestly, it gets a little annoying But just think of what it means. This is the middle door. And Jackson then did proceed to because there's no point in And then the last element where n is just our go-to number for the It's not going to be n. It's going to be n minus 1 because So here then we have a translation to C of this exact same idea. And here, we come full circle to Week 0. In Week 0, it was pretty intuitive a problem like this. But if you now think back to actual or the like, when you're doing it's possible, if you don't have in the phone, you know what? Linear search, just checking every name might be perfectly fine. But odds are your phone's being start to have dozens, hundreds, over the years. What would be better than linear search? Well, perhaps binary search. But, but, but-- there's an assumption, Why was Jackson ultimately able instead of a full seven, like Stephanie? Because the array was sorted. And so this is sort of a teaser for what Well, how much effort did How much effort does it of those names and numbers in advance? Because maybe it's not actually Now someone like Google probably somehow You can imagine it being super slow if, into google.com, if they searched Ideally, they're doing something So we'll formalize, now, And it's not going to be so much But we'll introduce you to that most any programmer or when analyzing their own algorithms. Let's formalize now what So right now, I claim binary But how much better and why, exactly? Well, it all comes back So this, recall, is how we analyzed And recall that, indeed, we had described the running time one page at a time, two tearing the thing again And precisely, if you counted up or the number of pages fair to say that the first might have taken n total pages. It didn't because I was at the time, which is somewhat But if I were searching for I would have had to keep going through all n pages. Not as bad for the second algorithm, And even that's a bit of a white lie. It's probably n divided by 2 plus But again, I'm sort of to capture the essence of these things. And then we really got into 2 event for that third And at the time, we claimed any time in half, in half, odds are there's going And we'll see that today. But today, we're going to actually start And we're going to formalize We are not going to care, generally, some algorithm takes because that's especially if maybe you have a faster It wouldn't really be fair to We really want to, with the wave of how slow or how fast an algorithm is. So the notation here is deliberate. That is literally a capital O, And so the first algorithm The second algorithm is in The third algorithm is in But even that is kind When using big O notation, you the smaller order terms. We're not going to care about the The shape of these algorithms And really, the idea-- the algorithm the same. Instead of one page at But if you throw millions of those algorithms are really going to really large, goes off toward infinity. And the same is true for logarithms. Even if you're a little that whether you do the math with you can just multiply one by the So this is only to say a computer say that the first two algorithms The third algorithm is on And we don't really care precisely And this big O notation, as we'll If you can imagine suddenly so more pages on the screen at once-- it is indeed going to be that matter, because imagine in zoom out, zoom out, zoom out, and on the x-axis, the red are essentially going to look the But the green line is never It's going to be a And so that's the a sense of these rates So here, then, is big a cheat sheet of the common formulas in an introductory context, might And let's consider for a moment linear search and binary search-- So I've ordered them from slowest It's not something but it tends to be slow You're doing n times n. That's got to add up to a lot of steps. Better today is going to be n log n. Even better is going to be n. Even better than that is log n. And best is so-called or maybe two steps, but a fixed, finite number of steps that So given this chart, just let's consider the worst case. In the worst case, how many steps to find the solution to the problem, Yeah? So on the order of n. And in this case, it's exactly n. But you know what, maybe it's a couple of steps. She had to lift the latch. She had to open the door. Maybe it's three steps. She had to show the money. So now it's 3n, 2n. But we don't really care We really just care about the So we'll say yes, on the order of n. So that might be an upper bound, And how about binary search? In Jackson's case, or in general, how many steps did it take In this case, it was literally three. But that's not a formula. Yeah so it's on the order of log n. And indeed, if there are almost eight, if you just And indeed, if you take log base 2 So the math actually checks out. And if you're not comfortable Just think about it intuitively. Logarithm of base 2 is just So on this chart, when we allows you to describe the order like the magnitude of it-- but it an upper bound. So in the worst case, are pretty good measures of how good-- or rather, of how bad-- linear search and Why? Well, suppose you're searching and the person's name starts with Z. on the order of n steps. Why? Because it might take you as Now that's not necessarily going If I use big O as an would be nice if there's a especially if you want to consider not So what might we use here? Well, this is a capital So omega is the symbol that a to describe a lower often in the context of best So a lower bound means how few And here, too, same formulas. And we'll fill in Some algorithms might always take or on the order of n steps. Some might only take n log So something like a linear search-- when Stephanie started she didn't get lucky this time on stage. But what if she had, and the How might you then describe search in this so-called best case, Yeah? Yeah, so omega of 1. So in the best case, the it might take linear search to find Why? Because maybe if and we had prefilled these lockers such that she might have opened the number 50 could have been could indeed be omega And how about now for Jackson? He used binary search. So he dived right into But what would be a lower bound Yeah? Yeah, so again, omega of 1. Why? Because maybe he just gets lucky. And indeed, right in the middle of the It wasn't. And so more germane in would have been the big O discussion. But big O and omega, upper just allow a computer with what could happen case, what can happen in the best case? And you can even get even more precise And this is, indeed, what engineers in a university when and trying to make arguments as to why else's, by way of these And just so you've seen it, it turns to have an identical upper you can actually use a And this is the last of But a Greek theta indicates bound and lower bound. That is, they are one and the same. That was not the case for our discussion not the case for binary search. But you could use the if it turns out that your upper So for instance, if I were to count two, three, four, five, you could actually say that counting because in the best me n points, people in the audience. In the worst case, it's It's always going to take me n steps if You can't really do better than So that would be an example where theta is instead germane. Are any questions now on which are now just more for talking about the Any questions? No? Seeing none. Oh, is this-- yes? No? OK, so we're good. So let's go ahead and translate Let me go over to VS Code here. And let's see if we can't now to some actual code, not so We're going to still operate in So let me go ahead and search.c by executing code And then up here, let's go so include cs50.h so Include standard io.h so We'll do int main void, the to tease apart last week. The fact that it's void again today And let me go ahead and do this. Let me go ahead and declare, just for like an array that never changes. And the syntax for this is going to using the square bracket notation. And I'm going to to 20, 500, 10, 5, 100, 1, and 50, as before. So this is a slightly new syntax And the curly braces here, which and while loops and functions, just an array of whatever size this is I could alternatively use last week's Let's see, 1, 2, 3, 4, I could alternatively do this. And then I could say 20, numbers bracket 1 equals 500. And I could do this five more times. That's just a little tedious. If you know the numbers have to tell the compiler You can just let it figure it out that 100, 1, and 50. So this is how you All right, let me just go ahead We'll call it n by using get_int so nothing new there. And now let me go ahead and And the pseudocode we had for this Let me go ahead, then, For int i-- and you almost always So that's perhaps a good starting point. I'm going to do this so Not the best design to hard for demonstration's know how many numbers I put in there. And then I'm going to i++. So now I have the beginnings me to iterate over the entire array. And let me ask this. If the current number equals n, which is the then let's go ahead and do quote unquote, found, backslash n. And then per our discussion last week, I'm going to return 0 if I found it. And if I don't find it, I'm just say not found, backslash n. And just for convention-- whoops, I'll return 1 or, really, 0, recall, means success. And any other integer tends irrespective of the So just to revisit, the only thing We're creating an array of And then after that we have an implementation of linear search. I mean this is the C version, I daresay, whereas now the array is called But I think it's pretty much the same. Let me go ahead and open my Seems to compile, ./search. And let's go ahead and We'll start with what we did before, 50. And it's found. Let's go ahead and run Let's search for maybe That one, too, is found. Let's run it one more time which is not among the denominations. And that one, indeed, is not found. So we've taken an idea from Week and just translated it now to code. Questions on this Linear search. Nothing. Oh, so successful so far today. So let's see if we can't maybe and see if we can't trip over a detail And instead of doing numbers, We'll stay on theme with Monopoly. And I went down the rabbit article on Monopoly. And the original pieces or tokens that we can represent those with strings. So I'm going to create an array size I defined here. And the very first monopoly were a battleship that a boot, a cannon, an iron, a you might from the game nowadays. Turns out they've been changing these-- had no idea-- over the years. So here is, now, an array of strings. Let me go ahead and prompt the user I want to now search for one of these So let me create a string s, prompt the user for a And then I think my code here is I now have an array called strings. I now have a variable called s. But it turns out, for reasons we'll this line of code is not going to work. And it turns out the reason has last week of what a string really is. And what is a string, again? A string is an array. And it turns out, though, going to generously compare all of just because you use equal equals. It turns out it's not going And so thankfully, there that we introduced last week, The reason for the problem, we'll But for now, just know that when especially if you've come into the class other language-- you Even though you could in So what I have to I have to ask the question, does the compare, or strcomp, equal 0 and that's user input? So if you read the documentation for you'll see that it takes two strings It then-- someone decades that probably uses a to compare every character And it turns out it returns 0 Turns out, too, it will return a in other situations. Any intuition for why useful to have a function that allows If they're not equal, what else when comparing two strings? If certain values are? STUDENT: [INAUDIBLE] DAVID MALAN: OK, possibly. Maybe you want to just And that's indeed an But str compare is a STUDENT: [INAUDIBLE] DAVID MALAN: Exactly, if you're trying just like your phone probably is It turns out that str return a positive number based on whether, maybe it comes or in fact, equal. So that can be a useful thing. And that's just a teaser for that we'll see next week. So now, let me cross my fingers Let me go ahead and do make search. Did compile, albeit slowly. Dot slash search, and let's search And we see that that's, indeed, found. Otherwise, let's search isn't there, like a race car, But huh, segmentation And actually, some of you have Anyone want to admit seeing this? So yeah, not something and honestly, not something But that too, we'll see next week. Any intuition for why I didn't really change the logic. It's still linear search. Let me hide the terminal so you The only thing I did was switched And I switched to str compare here. But segmentation fault happened. And the teaser is that that somehow Yeah. STUDENT: [INAUDIBLE] DAVID MALAN: Yeah, and this So one, two, three, total in this array, versus the seven that we had earlier. And this is where, see? Sort of case in point, The fact that I hardcoded this value as a constant or declaring bit me here, because now, I'm But clearly, I'm going one step going to iterate seven times, not six. So it's as though I'm looking And indeed, next week, And that's just a bad thing. So odds are, not even seeing your code have had segmentation faults, that you shouldn't have. You maybe looped too many times. You might have used a negative In general, you touched memory And you touched a segment of The fix, though, at least Just don't do that. So let me go ahead and recompile this. Make search dot slash search. And I'll search again And now it does not crash. But it does tell me it's not found. So subtle, but something you might Questions then, on what I just Yeah, in front. STUDENT: One thing is the program if you don't do return 0, return 1. So what is the purpose DAVID MALAN: A really good question. So the program will still work even In fact, let me go ahead and do that for a second. Let's get rid of the return here. Let's get rid of the return here. However, watch what happens here. Let me go ahead and Let me scroll up in my code here. Let me go ahead and do dot slash search. And let me go ahead and search battle ship, so I know I hit Enter. Huh, interesting. So it's saying found not found. But do you see why, STUDENT: Is the loop still running? DAVID MALAN: Exactly. So the loop is still running. So there's a couple I could, for instance, somehow But that's going to still I could then instead just return here. I don't strictly need to But I made this claim to be helpful as your programs get more just like a real world programmer, So returning 0 in main is the easiest I'm ready to exit But down here, I could because that's not a huge deal. It's not really an error that deserves up that something went wrong. But return 1 is just a lower eh, it didn't really find And remember from last week, If I recompile this again, now that I've And if I do a dot slash search which is indeed found, recall I echo dollar sign question mark, which But it shows you what main returned. If I run search again and search I see not found, but I can and see that, oh, it returned 1. So now if you fast forward a few months, writing code in a company you might want to be You might not want the human to You might want code to be or something like that. Using these exit codes, can that other code succeeded or failed. Other questions on linear No? All right, well, let's translate here by incorporating these two So I'm going to create a phone book in And let's combine some of this notion of searching a and getting back a number. So I'm going to go ahead and quickly so we can get input. standard io dot h so And I'm going to in case we need that one as well. int main void, no need for And let me give myself, now, an So string names equals. And then in curly will be one person in the phone book, So we'll keep it short so we But this is a phone book Suppose, now, we want to also store So it's not just saying It's literally looking up our phone Well, at the moment, there's I could do something hackish like I after Carter. I could maybe do something But now you're kind of doing the Now, it's not strings. It's a string int, string int. All right, so maybe I could But now it's just a conceptual Like yes, that's an But now you're on the honor system to the second string is a you can do it. But it's a bit of a hack, so to speak. So what might be cleaner than this? Instead of combining our phone numbers what else might we do that's Say it little louder. A 2D array, possibly I'm going to keep it even simpler by name, even though that is, we saw What else could I do if I want Yeah. STUDENT: [INAUDIBLE] DAVID MALAN: Yeah, let me It's a little simpler. Rather than complicate things in let me go ahead and do string. Well, I could do int numbers. But you know what? So that we can support punctuation like codes, I'm going to do this instead. I'm going to do string numbers so that unquote plus 1 for the US, as is US convention. And then for mine I'll go ahead And now down below, let's actually book, just like in week 0 we did. String name equals get string. And let's ask the user for a or someone else. And now let's re-implement So 4, int i get 0. i is less than 2. And do as I say, not as I do. I think we should but we'll keep it simple for now. i++. And then in this for loop, I think to solve this. So if the return value of str i comparing against the name that the equals 0, that is, all of the characters then I think we can go ahead and But you know what? Let's actually print So found percent s, and we'll And then just for consistency, And down here, how about I'll found, just to be clear. And then I'll return 1 as well. So just to recap, It's almost the same as I'm not just saying found or not found. I found a number in monopoly, I'm looking up in one And then I'm printing from So let me go ahead here and run the OK, that's promising, no errors. Dot slash phonebook now. And let's search, for All right, so we found Carter's number. All right, let me do that again. Phone book, let's search for David. All right, we seem to All right, let's do it one last time. Phone book, Enter. And now we'll search for John Harvard. Enter, not found. All right, so I daresay, albeit with Would anyone now like Does something rub you the wrong way, And as always, think about gets longer, more complicated, how Yeah. STUDENT: If i is less than 2. DAVID MALAN: OK, so if i is if I change the number of I'm going to have to update i. And we've already seen that So that's bad design. Good. STUDENT: Say you add someone's but you don't have the So then when you go it [INAUDIBLE] someone's number. DAVID MALAN: Yeah. So again, I'm sort of trusting If I add John or anyone but I forget to add their eventually things are going And then code will be So sort of a poor design setting me Other thoughts? Yeah. STUDENT: [INAUDIBLE] so if you were but not the main [INAUDIBLE] DAVID MALAN: Yeah, really good. We're assuming the same order. From left to right, the names go, and But that's kind of Like, there's literally from reversing the order for whatever Like, they're sorted now, and maybe So this honor system here, I could put a comment in here always update arrays the same way. But like, something's especially when we have not two, but It would be nice to keep all And so in fact, the one new is one that actually allows us to You can think of arrays structure, in that it allows to back to back to back. And this is how strings are implemented. They are a data structure effectively But with C and with other you can invent your own one dimensional, two And with C, can you specifically that have their own names? So for instance, wouldn't it not just char and int and Wouldn't it be nice if C came And ideally, a person would Now, that's a little Like, why would they define a person Certainly, people could have So they leave it to us. The authors of C gave us all of these and so forth. But it's up to us now to use so that we can create an array inside of an array called people, So how are we going to do this? Well, for now, let's just stipulate will have a name and a number that a person should have. And that's fine. You can invent your At the moment, I'm to define a person's name and number. But wouldn't it be nice to encapsulate, types, into a new and improved And the syntax for that So it's a bit of a mouthful. But you can, perhaps, infer So it turns out C has a As the name kind of suggests, this Struct is an indication It's like a structure that has that you are trying to define. And then at the very bottom here is the name of the type So you don't have discretion in this particular case. But you can name the And you can put anything in the And as soon as the semicolon is every line thereafter to a person data type, whether as a So if I want to build on this Let me go back to my C code here. And I'm going to go ahead and Let's go ahead and do this. I'm going to go ahead and, first, get And let me go ahead and, invent this type, so typedef struct. Inside of it will be a string And then the name of the And best practice would have me so that any of my functions, even though I just Now, if I wanted, I could do this. Person P1 and person P2. But we know from last week, If you want to have multiple instances we should probably use what instead? STUDENT: [INAUDIBLE] DAVID MALAN: And-- STUDENT: An array. DAVID MALAN: Yeah, an array. So let me not even go down that road. Let me instead just do this. Person will be the type of the array. But I'm going to call it-- I could call it persons. But in English, we typically say people. So I'll call the array people. And I want two people though I could certainly change How, now, do you put a and then put the number Well, slightly new syntax today. I'm going to go ahead and say this. People bracket 0 just gives me That's not new. But if you want to go inside of that And then you just specify the So if I want to set the first I just use that so-called dot notation. And then if I want to set Carter's I would do this, +1-617-495-1000. And then if I want to I would now do people bracket 1 dot And then people bracket 1 still +1-949-468-2750. And now, at the bottom my logic can pretty much stay the same. I can still, on this line for the name of the person For now, even though I admit I'm just doing this for I'm going to leave the two there, But down here, this is I don't want to compare What do I want to type here as What do I want to do here? Yeah. STUDENT: People i dot name. DAVID MALAN: So people i dot name, yeah. So I want to go into the people because that's what my loop is doing. It's updating i again and again. And then look at name, and that's good. I think now I need to change this too. What do I want to print Someone else? What do I want to print here, Yeah. STUDENT: [INAUDIBLE] DAVID MALAN: Say it a little louder. STUDENT: People i dot number. DAVID MALAN: Perfect. So people bracket i want to print the corresponding And then I think the rest of So let me go ahead and rerun make So far so good. Dot slash phone book. Let's go ahead and type All right, let's go David's name, found. Let's go ahead and run it one more time. Type in John Harvard, for So fundamentally, the code Linear search is still And I admit, this is We've kind of made a two line But if we fast forward a week or to files, we'll introduce comma separated values, or you've surely opened on your Mac Suffice it to say we'll soon learn like names and numbers, in files. And at that point, we're of this hackish sort of and manually typing my name and Carter's We'll read the information And in a few weeks, we'll read it But this is, for now, just syntactically containing one person each. We can update the name and update the name and the and then later search across the corresponding numbers. And in this sense, this Why? Because my person data now, everything that it means to be a And if I want to add something to I could go up to my add an address to every person And now it's not the honor system. It's not a names array, a numbers array, you might imagine related to a person. It's all encapsulated, which is a Reminiscent, if some of you have called object-oriented programming. But we're not there yet. C is not that. Questions on this use of the dot operator being Any questions? Yeah. STUDENT: [INAUDIBLE] DAVID MALAN: On what line number? STUDENT: 16. DAVID MALAN: 16? So yes, so syntactically, we introduced So doing people bracket 0 just means That was like when Stephanie That's doors bracket 0. But this is, of course, Today, the dot is a new piece of syntax. It means go inside of that person in and set it equal to Carter So that's all. It's like, open the locker and check or set the Yeah. STUDENT: [INAUDIBLE] can you set default DAVID MALAN: Attributes is fine. Good question. In the struct, can you Short answer, no. And this is where C becomes less like Python and Java and others, So when we transition to we'll see how we can start But for now, it's up to you to something. Yeah. STUDENT: [INAUDIBLE] DAVID MALAN: Really good question. How can we adjust or critique This is one of the few situations do as I say, not as I do. I am using pretty ugly lines like But my claim, pedagogically when we start storing names in files or in databases, you You'll have one line of code read the information and then fill the entire For now, I'm just doing it manually on the new syntax, but that's it. So forgive the bad Other questions on this? All right, that's been a lot already. Why don't we go ahead and take our We have some delightful All right, we are back. And up until now, it clearly seems to because you can use binary search. You know a little something But it turns out that is kind of a problem to solve too. And you might think, to be pretty fast, we absolutely because that will just speed But if sorting is slow, that kind should we bother sorting going to search the data And so here is going to be, So let's consider what it In our case, it's just going But it might, in the case be actual web pages or So here is our typical picture for Input at left and output at right. The input to our sort problem is going And the output, ideally, will be And if we do this that we want to go about sorting this 3. So it's all of the numbers from 0 to 7. But they're somehow jumbled up randomly. That's going to be the And the goal is now to sort get out 0, 1, 2, 3, 4, 5, 6, 7 instead. So it turns out there's we can actually sort And in fact, just to complement could we perhaps quickly to come up if you're comfortable If you want to do 1, 2, 3, All right, come on down. All right. Come on over here, and I'll And if you want to start to organize you see the numbers on the board. So look up on the overhead and to right in that same order. And let's have the If you want to come right over here, All right, and a few more numbers. All right. Number 2, 6, and perfect. Just the right number, all right. Uh oh. All right, there we go, number three. All right. So let's just do a quick check. We have 7, 2, 5, 4, 1, 6, Do you want to just scootch to make a little more room? All right, and let's consider You want to each say a RYAN: Hi, my name is Ryan. I'm a first year from Pennypacker. ITSELLE: Hi, my name is Itselle. I'm a first year at Strauss. LUCY: Hi, my name is Lucy. And I'm a first year from Greenough. SHILOH: Hi, my name is Shiloh. I'm a first year in Wigglesworth. JACK: Hi, my name is Jack. And I'm a first year in Strauss. KATHRYN: Hi, my name is Kathryn. I'm a first year at Strauss. MICHAEL: Hi, my name is Michael. I'm a first year at Pennypacker. MUHAMMAD: Hi, my name is Muhammad. I'm a first year in Matthews. DAVID MALAN: Hi, nice, welcome aboard. All right. So let's consider, now, how we might go the goal being to get them into order presumably then, we can use something We can actually use that they are already then sorted. So let me propose that we first has a name called selection sort. And selection sort is going to or really you, as the programmer, and again, and then putting So let me go ahead and start this At the moment, 7 is the So I'm going to make mental note of that I'm going to move on now. Number 2 is obviously going to update my mental reminder effectively forgetting, 5, not smaller. 4, not smaller. 1, smaller. And I'm going to make 6, not smaller. 0, even smaller. I'll make mental note of that, And now number 3 is not smaller. So what's your name again? MICHAEL: Michael. DAVID MALAN: So Michael is number 0. He belongs, of course, way down there. But unfortunately-- you are-- RYAN: Ryan. DAVID MALAN: Ryan is in the way. So what should we do? How should we start to sort this list? Where should number 0 go? Yeah. Do you want to say it louder? STUDENT: I will swap, I think. DAVID MALAN: Yeah, so let's So if you want to go ahead We need to make room for number 7. It would kind of be cheating if stepped over to the side. Why? Because if we imagine all of our that's a crazy amount of work to shift to the left just to make room. So we're going to keep it simple Now, maybe we get lucky, and number 7 Maybe we get unlucky, But we've at least solved one problem. If we had n problems at because number 0 is So if I continue to act this out, the smallest. 5, no, 4, no, 1 currently the smallest. I'll make mental note. 6, 7, 3, and now let me pause. 1 is obviously the now smallest element. So did I need to keep going? Well, turns out, at least as I do need to keep going, that I'm using one variable in my mind I'm not smart enough like us 1 is definitely the smallest now. I don't have that whole recollection. So I just am keeping So number 1, your name was? JACK: Jack. DAVID MALAN: Jack, where should Jack go? Probably there. And what's your name? ITSELLE: Itselle. DAVID MALAN: OK, so Jack and we've now solved two of And now we'll do it a little faster. If each of you want to start to swap as 4 smaller, 2 is smaller. Got to keep checking. OK, 2 was smaller. All right, now I'm going to All right, 4 is small. 5 is not. 6 is not. 7-- oh, 3 is small. Where do you want to go? OK, good. I'm going to go back here. And I can be a little smart. I don't have to go all because I know these So I can at least optimize slightly. So now 5 is small. 6 is small. 7 is 4, 4 is smaller. If you want to go in place there. And now, here things get interesting. I can optimize by not anymore, because they're But now 5 is small, 6 is not, 7 is not. OK, 5, you can stay where you are. Now, a human in the to question why I'm But with selection sort, as I still have to, now, And now my final step, So here, too, is this have is this bird's eye view of the where everyone needs to go. But a computer implementing this with an And we're actually saving a step here. If we were really doing this, none All eight of our volunteers And only then could we But we're focusing now So let me just, before we do propose that what I really just did here For i from 0 to n minus that 0 is always the left of the array. n minus 1 is always the For i from 0 to n minus 1, I found the i and numbers bracket n minus 1. And that's the very geeky way I'm always starting from And then everything else to the right. And that's what was allowing me to If, though, my last line says swap think that implements by physically walking to another spot. All right, so that, then, would Let's go ahead and take using an algorithm that I'm But to do this, we need you all to We have a little cheat if you'd like to go back And let me take a fundamentally really liking selection sort of a lot of walking back and forth. And the lot of walking suggests a So what might I do instead? Well, bubble sort is going to intuitively on just smaller problems. And let's see if this So if I just look at this list without this is obviously a problem. Why? Because you're out of order. So let's just solve So 7 and 2, why don't you swap? I know 2 is in a better place now, So I think I can now move on. 7 and 5, problem. So let's solve that. 7 and 4, problem. Let's solve that, 7 and 7 and 6, let's solve that. 7 and 0, solve that. 7 and 3, solve that. OK, done. Sorted, right? Or obviously not, if you just But we have, fundamentally, 7 is indeed in the right place. So we maximally have n minus So how do I do this? I think I can just Let me go over here. 2 and 5, good. 5 and 4, no. 5 and 1, no. 5 and 6, yes. 6 and 0, no. 6 and 3, no. So now we've solved two of the problems. And what's nice about bubble it's nice and simple. It's nice and local. And you just keep incrementally So let's go ahead and do this again. And I'll do it-- we can do it faster. 2 and 4, we know are good. 4 and 1, 4 and 5, 5 and 0, 5 So we go back, 2 and 1. Ah, now another problem solve. 2, and 4, 4 and 0, 4 and 3, And so notice 2, as per its have bubbled their way up to the top. And that's what seems to fixing some remaining problems. So almost done. 1 and 2, 2 and 0, 2 and 3, 3 and 4, 4 Obviously, to us humans, it looks done. How do I know as the computer for sure? What would be the most surefire way That's a bug. OK, 1 and 0, 1 and 2, 2 and 3, 3 OK, so now it's obviously sorted How could I confirm as much as code? You're doing it with your How would the computer, the code, know Yeah. STUDENT: [INAUDIBLE] one more time. DAVID MALAN: Let's do one more time. And look, draw what conclusion? STUDENT: That nothing DAVID MALAN: Yeah, let's even though it's a little wasteful. But logically, if I go through the and again, and I don't now it's obviously logically safe wasting my time doing the if no one's actually moving. So I'm afraid we don't have But we do have eight stress balls. And round of applause, if we If you want to put your So if we consider for a moment-- thank you. Thank you so much. Sure. Thank you. Thanks. Sure. So if we consider now these two Any intuition for whether is better or worse than Any thoughts? Yeah. STUDENT: Bubble sort's even better DAVID MALAN: So bubble especially since I was focusing Other intuition? Selection sort versus bubble sort. Well, let me propose that we try analyze it in some way. And this is not an exercise we'll do But these are pretty So we can wrap our minds or the design of these things. So here is my pseudocode for selection I just iteratively select the next So how can we go about Well, we could just and count up the number to be implied logically by the code. We could literally count the number left to right. We could also just count I was making with each And I was doing it kind of But every time I was looking do I want to remember That number, I was comparing two than or greater than sign, at So that tends to be the norm. When analyzing algorithms like these, because it's kind of a we can use to compare So think, too, that in we have more than eight we can generalize our is the first element at bracket 0. And the end of it is always n minus 1. So arrays or doors, in are always numerically indexed if there's n of them in total. So how do we analyze the Well, how many steps did it take me Or more precisely, how need to make when I walked our first-smallest person, How many comparisons did I do If there were eight people on stage, Like if there's eight people, Then this person, this person, yeah. Yeah, so seven total, right? Because if there's you can only do seven comparisons be comparing one number to itself. So it seems like, in the got n numbers that finding the smallest element Maybe n total steps left to right. But the number of is just a useful unit of How about finding the How many steps did it take me to ended up being the number 1? Yeah. STUDENT: [INAUDIBLE] n minus 2. DAVID MALAN: Yeah, so just n minus 2. Why? Because I'd already solved one problem. Someone was already It would be silly to keep So I can whittle down my number to n minus 2. The third pass to find the third And then dot, dot, dot, presumably ends when you have just one final pair, So if this is looking a little from high school or high school let me just stipulate that if and generalize it, that is the divided by 2. And if you're rusty Just kind of commit to you add up this kind of series, smaller, plus something differs by 1, you're going to get this If we, of course, multiply that out, all divided by 2. If we keep multiplying it out, that's And now, we have kind of can talk about the efficiency, But honestly, I don't really care like n squared divided by As n gets really large, which of is really going to dominate, on the total value of steps? Right? It's the square, right? It's definitely not n divided by 2. That's shaving some time off. But n squared, as n gets big, If n is 100, then n squared is bigger. If n is a million, n And so at the end of the day, about a wave of the hand analysis let's just say that selection it's on the order of n squared steps. It's not precisely n squared steps. But you know what? n squared divided well, it's half of that. n squared is what really matters And that's when you start the Google problems of the world. When n gets large, that's than just sort of naive So where, then, does this algorithm Well, n squared, it turns of n squared steps, in the worst It turns out, though, lower bound, suppose the best case scenario, like And just because they already Suppose they just happened How many steps would to sort an already-sorted Any intuition? Yeah. STUDENT: Would it still be [INAUDIBLE]? DAVID MALAN: Would it still be n-- STUDENT: Still be 7 [INAUDIBLE]. DAVID MALAN: So for the be 7 for the first Because even though, yeah, I don't know that 0 is the smallest over there doing all seven comparisons. OK, fine, first pass took seven What if I look for the next smallest are already sorted 0 through 7? Well, yes, the number 1 is But I don't know they're the smallest get to the end of the list. And we're like, oh, I already had the smallest And so this pseudocode, this is sort of fixed like this. There's no special case that says, It's always going to And so in this case, if we using omega notation, just is also going to be in this because even in the best case, sorted, you're going to essentially verifying as even though we humans of So selection sort would seem to take case, n squared steps in the best case. And so you know what? We can use our theta Here would be an algorithm, that always takes n squared steps, or not from the get go. All right, so hopefully And someone proposed felt like it was using fewer steps. Well, let's consider that next. With bubble sort, we had Whereby, let's focus on the Down here, what was I doing? For i from 0 to n minus 2. That's curious. We've never seen n minus 2 before. But I asked this question. If numbers bracket i and numbers bracket So that was when I was pointing I saw that they were out of How come I'm doing that again and instead of n minus 1, until now as our rightmost boundary? Any intuition for why I'm Yeah. STUDENT: [INAUDIBLE] number, you There's no benign character DAVID MALAN: Exactly. Because I'm looking at the ith and the ith plus 1 person, I beyond the boundaries of my array. So if you think of my left hand. When my back was to you here, at the first position, my right is essentially pointing at And you want to iterate with your But you don't want your left You want it to point at But we know that the last So the second to last person, just So it's a subtlety. But this is a seg fault If you implemented bubble you will, my right hand would go so just bad. All right, so why am Well, we did it very But each time someone-- each pass I did through bubbled their way up to the end. Number 7, then number 6, then number 5. So if on each pass through I was solving at least one problem, run n times total to because the first pass will get Second pass, second number into place. You might get lucky, But worst case, this feels like enough. Just do this blindly n times, Well, technically-- all right, Technically, you can just because if you solve all and you're left with 1, literally just logically. If you've already sorted everything it's already bubbled up. So how do we analyze this? Well in bubble sort, we I'm essentially doing n minus Now, let me back up to the a little less obvious. This is where you can actually how many steps you're taking. So this first line literally says, So that's going to translate to our mathematical formula. Do something n minus 1 times. This loop, just because I'm it's framed a little differently. But if you're iterating you're iterating a total And again, the arithmetic is But this just means do the So do n minus 1 things n minus 1 times. We can now run out the math as follows. We have the formula n We do our little FOIL method minus 1 times n, plus 1. We can combine like terms. But at this point, when which term are we really This is on the order of? Yeah, n squared. So at least asymptotically. Asymptotically means, as n approaches Turns out that the upper bound are essentially the same. Now, if we really nitpicked and compared they might differ slightly. But as n gets large, going to notice the difference, it would But what about the lower bound? If the upper bound on bubble sort is bound here? Well, with this pseudocode, what would Even in the best case when all Any intuition? In this pseudo code. Yeah, in the middle. STUDENT: Sorry, quick question. Isn't bubble sort wouldn't need to compare numbers DAVID MALAN: Good question. Isn't bubble sort designed need to compare numbers that That's what's happening here I'm always going from left to right. But remember that even when and the last two people were need to restart at the beginning, going that way, and the small STUDENT: [INAUDIBLE] DAVID MALAN: So that is true. There are some slight optimizations Let me stipulate that it would still But that would definitely shave But what if the list is already sorted? Our pseudocode, at the for if list is already So we're going to blindly and minus 1 times unless we modify our I proposed this. Inside of that outer loop, if you make and your mental counter you have to keep track well then, you might as well stop. Because if you do a whole why would you waste time doing it So to help visualize these, whereby if the data is already Why? Because it does have this At least if we implement can we go about visualizing these Well, let me go ahead and do this. Let me pull up, here, a visualization thanks to a third party tool here these sorting algorithms as follows. Small bars represent small numbers. Big bars represent big numbers. And so the idea, now, is to get all of the small bars this So just like our volunteers. But instead of holding lighted numbers, So let's go ahead and start with, And you'll see in pink, the current number and then pulled all the way to the left. So this is selection sort. And again, it's selecting But you can see here, all the more we're taking a lot of steps. So is this algorithm touching these And this is why the n There's got to be some Like, why do we keep looking at the We do, in terms of our But it's this redundant why n squared is indeed the case. So now it's done. Small bars here, big bars there. And I had to just keep because it's relatively slow. Well, let me re-randomize so we start with a different order. And now let me click on bubble sort. And you'll see similar idea, So now, the two bars in are being compared and fixed, And you can see already are bubbling their way up to the top. But now, you can also like we keep swooping through like I kept walking back and forth. And this is n squared. This is not that many bars. What? 10, 20, there's like 40 or That's pretty slow already And I think it's going to get So let's just assume that Had I gotten lucky and the list bubble sort would have been pretty fast. But this was a truly random So indeed, the worst case might So I feel like it'll be anticlimactic, don't let you see the end of this. So here we go. Nothing interesting is about to happen. Almost done. OK, done. All right, so thank you. [APPLAUSE] Thank you. So still somewhat slow though. How though can we, perhaps, do So we can do so if we introduce And this one isn't so much a And it's something that you might but perhaps not so obviously so. So it turns out, in refers to the ability of In the world of mathematics, if f appears on both the left side that would be a recursive Whenever f is defined in terms in compute-- in programming, any that function is said to be recursive. And this is actually something even though we didn't call it as much. So for instance, from earlier, whereby for searching via binary If no doors are left was the additional conditional we added. But then if number behind and here's the interesting part, search the left half. Else if number is greater than This pseudocode earlier Why? Because here is an But what's the algorithm telling us? Well, on this line and this line, it's So even though it's not explicitly if this is a search algorithm, and yet algorithm, this pseudocode is recursive. Now, that could quickly get you calls itself again and again and again. But why, intuitively, that this code, this Why will the algorithm still stop? Yeah. STUDENT: It has an exit condition, as in DAVID MALAN: Exactly. It has some exit condition, And more importantly, any you're searching a smaller Any time you search searching a smaller version of the So this is why, in the I couldn't tear the phone book because it was literally So recursion is this ability But what's important is that you do so that eventually, you have or no more data, no more doors at all. So these two lines here would But if we go back to week 0, we could So this was our pseudocode for And recall that we as really representing a loop, But there was a missed opportunity here. What if I had re-implemented Instead of saying open to and then go back to line 3, or open to middle of right to line 3 inducing just recognize that is a algorithm for And if you want to search a smaller through Z, we'll just So I can replace these yellow lines Search left half of book, This would be implicitly, the whole thing, a recursive pseudocode from week 0. And it's recursive, because and you're saying go search That's recursive. But because you're searching it's indeed going to Even in the real world or you can see recursive data or at least in Super Let me get rid of all and focus on this pyramid, then two, then three, then four. Well, this itself, is technically well, what is a pyramid of height for? Well, it's really, what? How would you describe is actually the same STUDENT: Height 3. DAVID MALAN: --of height Well, what's a pyramid of height 3? Well, it's technically a pyramid of And so even physical if you can define them Now, at some point, you have to say there's just one block. You can't forever say it's defined negative 2, you would never stop. So you have to kind of But let's go ahead and translate Let me go back to VS code here, and let that refers to a loop iterating. And let me implement a very So let me go ahead and I'll include our standard io.h int main And let's go ahead and do this. Let's declare a variable for the height of this pyramid. And then let's go ahead and Now, of course, draw does not yet exist. So I'm going to need to Let me go ahead and define a function It's just going to have side effects. It's just going to print bricks And it takes in an And how am I going to implement this? Well again, I want to print one block, That's pretty straightforward, at least Let me go back to the code here. Let me go ahead and say 4, int i, get 0. i is less than n. i plus plus. And that's going to iterate, And on each row, I want to print four bricks. But I'm iterating from 0 to 1 to 2 to 3. So I think that's OK. I can just say something j, let's be clever about j++. And now, let me go ahead I think I can get away with just But then outside of that I'm going to print my So a little non-obvious at first. But this outer loop iterates row And then the inner loop just makes sure Oh nope, there's a bug. I need to make sure that So when i is 0 on my I'm going to print out one brick. When i is 1, I'm going to print So let me go ahead and All right, and now, seems to compile. Uh oh, huh. Implicit declaration of function draw. So I'm making week one mistakes again. What? Say again. STUDENT: [INAUDIBLE] DAVID MALAN: Yeah. The prototype is missing. I didn't declare it at the top. That's an easy fix, and OK and necessary to copy paste. Let me copy the functions declaration So that clang now knows Make iteration. Now it works. Thank you. dot slash iteration. We'll type in something like 4. And there we have it, our pyramid that looks pretty similar to So that's how we would have implemented maybe last week, but just using arrays. But let me propose that we could Let me close this version of the code. And let me go back to VS just to demonstrate And I'll do it incorrectly So let me include cs50.h. Let me include standard io.h. Let me do int main void. And let me just blindly draw a But now in my draw function, let me So my draw function this time is But that's how many hashes So let's do 4, int i get 0. i is less than n. i++. Then let's go ahead and print And then after that, let's print out But now this, of course, is It's going to print out one hash or on one line. Let me now, incorrectly, but just Well, if this draws a let's just use ourselves to draw So the first time I call draw, Then the second time I call draw, it then four. So we're kind of laying these Make recursion. Whoops, I screwed up again. So let's copy the prototype here. Let's put this down Let's do this again. Make recursion. All right, all good, And now let me increase the just so you can see more of the output. And here we have. OK, bad, but thank you. So we have an infinitely tall pyramid. And it's just flying is why it looks kind of like a mess. But I printed out a pyramid of height And unfortunately, what am I any kind of condition that says, stop altogether. So this is an infinite loop. But it's not a loop. It's a recursive call. And actually, doing this We'll see next week that if you you can actually trigger yet another because you're using too But for now, I haven't Control C is your friend to cancel. And as an aside, if you're playing later, I actually cheated here. We have a special clang that prevents you from and creating a problem. I overrode it just for But odds are at home, you wouldn't be But let me do a proper version Let me go back into the code here. Let me go ahead and, not just then three layers of bricks. Let me prompt the human as before they want using our get int function. And now let me call So now I'm going back to But instead of using a loop now, this if you will. Let me go ahead and execute and Per your definition, if is really just a pyramid of let's take that literally. Let me go back to my code. And if you want to draw a pyramid and draw a pyramid of height 3 But what's the second step? Well, once you've drawn a pyramid So I at least have to bite off So let me just do for int i get 0. i is less than n i++. And let me, the programmer of this And then at the very so the cursor moves to the next line. But this is kind of elegant now, I because I'm literally translating this idea that a pyramid of height 4 So I do that first. And I'm sort of trusting Then I just have to lay one more So if n is 4, this is just a that will print out an additional layer. But this, of course, is going Why? It's not done yet, this program. How many times will draw STUDENT: It's infinite. DAVID MALAN: Infinitely many times. Why? STUDENT: Because there's DAVID MALAN: Yeah, there's Like, if you've printed enough how do we capture that? Well, I don't think we It would make no sense to draw So I think we can just pluck off, an easy answer, a so-called base case. And I'm just going to do this. At the top of my draw function, or, heck, less than or Go ahead and just return. There's nothing more to do. And that simple condition, will ensure that the Why? Well, suppose that draw is 4 is, of course, not less But we do draw a pyramid of height 3. And here's where things get You don't move on to line 20 So when draw is called it's as though you're executing 3 is not less than 0. So what do you do? You draw 2. How do you draw 2? Well, 2 is not less than So you draw 1. Got to be careful here. Draw 1. And now, we go ahead How do you draw 1? Well, 1 is not less than You draw height 0. How do you draw height 0? Wait a minute. 0 is less than or equal to 0. And you return. And so it's kind of like this You keep postponing, executing because you keep restarting, until, finally, one of those function return. And now the whole thing starts And you pick back up where you left off. And this is, perhaps, the best scenario. We won't do it in class. But if you'd like to wrestle using debug50 to keep stepping of those lines, logically, you'll see So let me go to my terminal which is now this correct version Let's type in a height of 4. And voila, now we have that same though admittedly, we're using We're now using draw recursively to that need come before it. STUDENT: Can you only use [INAUDIBLE] DAVID MALAN: No. Question is, can you only use No, not at all. In fact, it's very common to have or something else so that you can with that actual value. Other questions on this. STUDENT: When is line DAVID MALAN: Say it a little louder. STUDENT: When is line DAVID MALAN: When is So if you continue to-- let me scroll down a bit more so So line 21 will be executed once Now, in the story I told, we kept But as soon as one of where n equals 0 returns don't keep drawing again and again. So now if you kind of think then you continue to line 21, then and as the sort of logic unravels. And next week, we'll actually happening in the computer's memory. But for now, it's just, it's very book. You're just searching again and again. But you're waiting until the very Google now, who I keep is full of programmers of course. Here's a fun exercise. Let me go back to a browser. I'm going to go ahead and search for a little something about recursion. Here is kind of an If I zoom in here, the engineers See why? STUDENT: Ah. DAVID MALAN: Ah, there you go. Yes. Yes, this is recursion. And there's going to be so many recursion, like if you've ever showing the camera, and you sort of see that's really recursion. And in that case, it only stops once But this is a very funny when it comes to recursion and Google. So how can we actually how can we actually use Well, let me propose that a third and final algorithm for than the two sorts thus far. We've done selection Bubble sort, we liked a little better, where the list is already sorted. Bubble sort's at least terminate early, giving in terms of our omega notation. But it turns out that necessarily a feature of recursion, It turns out, using recursion, we can to sorting a whole bunch that we can do far fewer our final results. So here is the pseudocode for something called merge sort. And it really is this terse. Sort the left half of numbers. Sort the right half of numbers. Merge the sorted halves. This is almost sort of asked for an algorithm to sort, and you sort the right half. That's being difficult, because well, You're just telling me to sort But implicit in that last line, of this sort. Now, we do need another So let me add this. If we find ourselves with a well, that array is obviously sorted. If there's only one element in So that's going to be our base case. But allowing us now, in just these, to actually sort some elements. But let's focus first on Let's consider for a moment what So Carter has wonderfully to help us reset these numbers. Suppose that in the middle of we have two sorted halves. I've already sorted the and indeed, 2, 4, 5, 7 is And the right half appears to be already So in my pseudocode, we're and the right half somehow. But we'll see how in a moment. Well, how do I go about Well, because they're sorted already, I think we can flip down. We can hide all but the first So here, we have a half And I don't really care because they're clearly larger than 2. I can focus only on We know that 0 is the smallest there, that Carter kindly flipped down. So how do I merge these two lists Well, I compare the two on my right, obviously, So let me put this down here. And Carter, if you want to Now I have two sorted halves. But I've already plucked one off. So now I compare the two against the 1. 1 obviously comes next. So I'm going to take out the Now I'm going to compare 2 and 3, which do I merge first? Obviously the 2 comes next. And now, notice, each time I do making forward progress. I'm not doubling back like I kept sort, back and forth, back and forth. My fingers are constantly and that's going to be a key detail. So I compare 4 and 3, 3 obviously. I compare 4 and 6, 4 obviously. I compare 5 and 6, 5 obviously. And then I compare 7 and 6, 6 of course. And then lastly, we have And even though I'm kind of my hands technically were I was never looping back doing And that's, perhaps, the intuition, So that, then, is how you We started with left half And merging is just like And Carter just flipped so our focus was only on the Any questions before we forge to be merged in this way? So now, here is an original list. We deliberately put it at one detail of merge sort that's key. Merge sort is technically going And so whereas, previously, we and swapping people and making in the original positions. With merge sort, pretends that I'm going to need at least And I'm going to cheat, and I'm But technically, I could between 1 array and a secondary array. But it is going to take me more space. So how do I go about implementing Well, let's consider this. Here is a array of size 8. If only one number quit, So let's focus on the juicy part there. Sort the left half of the numbers. All right, how do I sort the I'm going to just nudge them over just Here is now a sublist of size 4. How do I sort the left half? Well, do I have an Yeah, what do I do? Here's a list of size 4. How do I sort it? What's step one? Sort the left half. So I now sort of, conceptually in my And I sort it by first sorting the All right, here's a list of size 2. How do I sort a list of size 2? STUDENT: [INAUDIBLE] DAVID MALAN: Sorry? I think we just keep Sort the left half. All right, here is a list of size 1. How do I sort a list of size 1? STUDENT: [INAUDIBLE] DAVID MALAN: I'm done. It's done. So I leave this alone. What was the next step in the story? I've just sorted the left half of What comes next? I sort the right half of the and I'm done, because it's What comes after this? Merge. So this is where it because you have to remember where recursively again and again. But if I've just sorted the left half now I merge them together. This is a super short list, so we don't But I think the first And then the second number I take, But what's nice now is that, notice, is indeed sorted, because I and the right half of it. But then merging is really All right, again, if you if I've just sorted the left half Sort the right half of the left half. So again, you kind of rewind in time. So how do I do this? I've got a list of size 2. I sort the left half, just the 5, done. Sort the right half, 4, done. Now the interesting part, I merge of the right half of the left half. So what do I do? 4 comes down here. 5 comes down here. And now, notice what I have. Left half is sorted. Right half is sorted. If you rewind in time, Merge the two halves. And so this is what Carter Let's focus only on just so there's less distraction. I compare the 2 and the 4. 2 comes first, so let's Now, I compare the new and the old beginning of this list. 4 obviously comes next. And now, I compare the 7 against the 5. 5 obviously comes next. And now, lastly, I'm So now I'm down to the 7. So even if you've kind of lost here, if you just kind we have the original right But the left half of the original all by way of doing sorting left half, but with those merges in between. All right, so if we've we rewind all the way to the beginning. What do I now do? All right, so sort the right half. So sort the right half. How do I sort a list of size 4? Well, I first sort the How do I sort a list of size 2? You sort the left half, Obviously, there's no work to be done. Done, sorting the left half. 6, done, sorting the right half. Now, what do I do? I merge the left half here And that one's pretty straightforward. Now, what do I do? I've just merged. So now I sort it. I've just sorted the left So now I sort the right So I consider the 0, done. I consider the 3, done. I now merge these two together. 0, of course, comes first. Then comes the 3. And now I'm at the I've sorted the left and the right half of the right half. So step 3 is merge. And I'll do it again All right, 1 and 0, Now, compare the 1 and the 3. Obviously, the 1 comes first. Compare the 6 and the And then lastly, the 6. So now, where are we? We've taken the left half of We then took the right half of So now we're at, lastly, What do we do? Merge. And so just to be consistent, let me Left hand or right hand, noticing none of this back and forth comparisons. 2 and 0, of course, the 0. So we'll put that in place. 2 and 1, of course, the 1. So we put that in place. 2 and 3, we merge in, of 4 and 3, we now merge 4 and 6, we now merge, of And now, we compare 5 and 6. We keep the 5. Bug. OK, well pretend that the 5 is on. Oh, this is why. All right, so now we 6th is gone. And lastly, 7 is the last one in place. And even though I grant this is probably the hardest especially when I'm Realize that what we've just done is We started with a list of size 8. We sorted the left half. We sorted the right half. And then we merge the two together. But if you go down each of sorting the left half involves and the right half of the But this germ of an idea of really not such that you're having the Clearly, we're sorting one and merging them together, ultimately. It does still lead us And if we visualize the remnants of where on the screen here, you see in the top row from left to right. Essentially, even though I divided that list of size 8, And that's where the base OK, we're done sorting that. And after that, logically, I into many lists of size 2 and those And then finally, the list of size 4 And so I put forth this picture here, because how many times did Or really double, double, double. So exponent is the opposite-- spoiler. How many times did I divide? So three, concretely. But if there's eight elements it really is a matter of dividing You start this, and you can divide Or conversely, you can start here double three times, which is log n. But on every row, every made a fuss about pointing my hands constantly advancing them, such I touched every element There was none of this back and So if I'm doing something rather, n things log n times, what n things log n times? STUDENT: Oh, it's n log n. DAVID MALAN: Yeah, so n log n. The order of n log n is, the running time of merge sort. And so of all of the sorts thus far, actually, is n log n, which is which is where both selection But it's also slower than But you would rather expect that. If you have to do a lot some elements versus you're going to have And so the question of whether or blindly with linear search really boils down to, can you And if you're the Googles are you don't want to be searching Why? Because you can sort it once and then subsequently using something like something even fancier and But there's always going You can achieve binary search How much does it cost you to sort them? Well, maybe n squared, if you used But it turns out, n log So at the end of the day, these And indeed, in merge sort 2, I should sort is also going to As such, we can describe it in saying that merge sort is, So generally speaking, probably better or some other algorithm that's n log n. In practice, most programmers are not themselves. Odds are, they're using that themselves have made the decision But generally speaking, and we're if you want to improve time, like you've got to pay a price. And that might be your more time to code up more difficult to implement. Or you need to spend And as these shelves one of the key details of merge sort. You can't just have the You need at least an auxiliary array, you have a place to put them. And this is excessive, I could have just gone back and forth But it's a little more But you do need more space. Back in the day, decades ago, And so you know what? It might have been better to not or selection sort even, or some Nowadays, space is relatively cheap. And so these are more But it totally depends The very last thing we thought we'd of some of these sorting algorithms. It's about 60 seconds long. And it will compare for you, and merge sort in parallel music, showing you means to be an O of n squared, Selection on the top. Bubble on the bottom. Merge in the middle. [MUSIC PLAYING] All right, that's it for CS50. We'll see you next time.