Rubinson, Claude: Okay, so I would like to welcome everyone to the October meeting of the Houston Functional Programming User Group. We have with us once again. I'm very excited. Richard Feldman, who is one of my favorite speakers. He Rubinson, Claude: has. I've mentioned to a couple of people. Rubinson, Claude: I don't think I know anyone Rubinson, Claude: beyond Richard who has more enthusiasm for programming. Rubinson, Claude: We absolutely Rubinson, Claude: loves Rubinson, Claude: programming and talking about it, and he is just a simply fantastic speaker. So I'm very, very excited to welcome him to our group yet again, and I will turn it over to you, Richard. Rubinson, Claude: It's all yours. Richard Feldman: Thanks for thanks for having me again. Richard Feldman: So I'm gonna share my screen. And Richard Feldman: hopefully, people are going to be able to see it. Richard Feldman: And Richard Feldman: all right, everybody see? Okay. Michelle (she/her): Looks great. Richard Feldman: Hope so. Alright great let me Richard Feldman: minimize zoom here. All right. This is the functional purity inference plan. Richard Feldman: I'm Richard Feldman. Richard Feldman: So Richard Feldman: a while back I gave this talk called functional Programming for pragmatist. This was at go to Copenhagen a couple of years ago, and in this talk I gave one of my favorite definitions. In fact, this has now become my favorite definition of what a pure function is. So the sort of bland definition is like a pure function is like, Okay, you call function. You give it the same arguments. Richard Feldman: It's guaranteed to have the same return value. If you gave it the same arguments, and it'll also guaranteed to have no side effects. In other words, it's guaranteed not to affect the outside world like observably in terms of program behavior. They might be doing some memory allocation and stuff like that. But in terms of like observable stuff it shouldn't do anything. Richard Feldman: My favorite definition, though, is pure functions are basically lookup tables. And I got this from Chris Jenkins when we were chatting before that talk. By the way, shout out to Chris. He hosts, the developer voices podcast. It's an excellent podcast. Which you should check out if you haven't heard of it. And so I gave this example in the talk of a function called string length. And basically, you can think of this as a lookup table. You give it an argument like high, and it returns 2, because the length of that is 2 Byte go to Copenhagen, you know, etc. So Richard Feldman: you know, essentially, the idea is that the body of the function doesn't do anything observable. It doesn't look at any outside state. It doesn't modify any outside state. It's really just essentially a pure function from its arguments to its return value. Richard Feldman: Now, one of the things that I talked about in this talk is how I love having an ecosystem around purely functional programming languages. So I talked about, for example, like, if I'm in Javascript and I'm doing it in a functional style. Richard Feldman: Well, there's all these questions that I have about any given Javascript function. So let's say that I'm you know, looking at a Javascript function like, well, is it possible that this function is like what changed my database in a way that I didn't like. What inputs is this function? Depend on? Does it rely on call order? Does it? Could it flake in a test? Can I pre compute it and cache the value? Can I memorize it? Is the thread safe. Richard Feldman: And also, even if a function starts out being pure, it can potentially stop being pure. If someone changes like one line of code, that suddenly all of these things that I thought were true about it all these useful properties stop being true, whereas I contrasted this with elm, which is an ecosystem that I know and love. Elm is a purely functional language. And so all these questions are just always. Richard Feldman: I know exactly what the answers are, because it's all pure functions. And so they all have all these properties all the time. And the entire ecosystem is that way. So it's just this incredible peace of mind, and it saves me a lot of time, especially when I'm doing things like debugging, or even just trying to understand what my code or code that somebody else wrote is doing Richard Feldman: so Richard Feldman: fast forward a couple of years I've been working on this programming language called Rock Rock's Tagline, is that it is a fast, friendly, functional language. It's a direct descendant of elm. So one of the things that rock values is much like elm. It has really fast compile times, and we want to Richard Feldman: make them even faster, actually than they already are. And also we really wanted to have a fast runtime performance. That's like a really important value, like we're trying to compete with, like the fastest garbage, collected imperative languages in terms of runtime performance, and also in terms of compile time, performance. Richard Feldman: friendly both in terms of like the compiler, error messages, and also the community. I think I'm very fortunate to have wound up with a community of people who are awesome and like really nice to each other. That's not a guarantee in every programming language community. But thankfully, so far, the rock community has been that way, and I really hope that we manage to keep doing that as we grow. Richard Feldman: And finally, of course, it's a functional language. And today rock is a purely functional language. And over the course of this talk. I'm going to talk about a modification to that that we're making Richard Feldman: so pure functions as I mentioned, have lots of great benefits. The problem is that, as everyone knows, most programs need effects to be useful and not all programs to be fair like you could have, like a theorem prover or something like that, or like the entire program is just spitting out like one answer, totally fair. But vast majority of programs that get written in the world do all sorts of effects. Richard Feldman: Notice, I said, effects and not side effects. So there's a common misconception about purely functional languages, which is that, like they can't do any I/O or anything like that. And then, you know, that's of course, not true. Obviously you can do effects, but purely functional languages typically represent effects as sort of this 1st class value based thing, where you're sort of passing around some sort of value that represents the effects that you want done. And then also like what's going to happen as a consequence of those effects. So this would be like I/O and Haskell, or the task type in Rock. Richard Feldman: But at the end of the day. Richard Feldman: If you have a function that doesn't affect when you run it. Well, then, that's a side effect, and functions that do affect when you call them can't be pure because they're violating. That. Is it a lookup table thing? It's like running. The function itself does actually cause and effect to happen now. It's no longer a pure function Richard Feldman: so often. What you see in purely functional language is that you have sort of a code base. That's sort of got this sharp dividing line where there's like 2 different categorizations of functions. And some of them are pure code where they're like, you know, obviously, like you prefer to do it this way, where you have like no side effects at all, and you have all these really nice properties. But then you end up doing effectful code, you know, whenever it's necessary. Richard Feldman: Now, this is true of all languages, not just purely functional languages in practice, most code bases where you have people who are like, Hey, I like pure functions. I'm going to try to write pure functions whenever I can. You still end up with some functions that just unavoidably are doing some sort of effect. Now, the reason I'm describing this as effectful code, even in purely functional languages, is that what you end up. Seeing is that like in rock, you see, like a function that returns a task. Or in Haskell you see a function that returns. Richard Feldman: And yes, technically speaking, that is a pure function in the sense that when you run it, it's going to give you back the same I/O value or the same task value, or whatever every time you call it. Richard Feldman: But at the end of the day we know that those tasks are going to evaluate to different things at Runtime depending on the state of the world. So it doesn't really have all the characteristics that we care about. Really, the ones that we like are the ones that are not even involved with effects, the ones where they're just like, yeah, I call this function. It does everything that I want it to do, and it gives me an answer. And it has all those benefits that I outlined earlier. Richard Feldman: So in a lot of cases, people like using a functional style, which is sort of nice if you're trying to work with pure functions as much as possible. And so there's been this rise over the past decade of imperative languages that are adding support for a functional style. So they were built as imperative languages. They were not designed with functional programming in mind at the outset. Almost always it was object-oriented programming. And then they've added support for a functional style, or they were just designed to have some Richard Feldman: functional ideas to begin with. So some examples of recently popular languages that have been doing this are rust. Kotlin, Swift, and typescript. Now granted. Even older languages than this are also doing it. But these are languages that are, relatively speaking, compared to things like Java, for example. Richard Feldman: rust is a good example of this. So this is a language where I have heard people describe rust as a functional programming language. I, personally would not go that far, and I use rust at work every day at Z. By the way, we're hiring, we make an awesome code editor. So also it's free and open source. So if you go to z dot dev. You can upgrade your code editor to one that's built completely in rust. But if I'm honest, I don't really use a functional style that much in rust like maybe occasionally I'll do a little bit of like dot map. Richard Feldman: dot flat map this and that here and there, but it's really kind of sprinkled on. It's not like I'm spending the most time writing functional programming in rust, even though when I started learning rust. That was what I knew best. I knew functional programming. I'd been doing it for like 5 years. And granted, I had lots of experience in industry before that before I got into Fp. Doing imperative programming. But when I got to rust I was like, I am super comfortable with the functional style, and I tried doing rust that way. And I was like Richard Feldman: this is not. This doesn't feel like functional programming. I like it. Rust feels to me like it's very clearly an imperative language at its core. And yes, there's support for a functional style, but I only use it kind of occasionally when it seems like a really nice fit for the problem. By and large, I just default to imperative with rust, and the functional style really feels like kind of an add-in Richard Feldman: Now, typescript, on the other hand, is something where a lot of people will go full bore. Let's do it functional first.st Granted again, a language that was not designed with a functional style, but unlike in rust, I think it's a lot more common to use typescript as like a hey, we do Fp style typescript here. We don't even try to do imperative typescript. Richard Feldman: So there's this, there's a blog post or sorry, a series of posts about functional programming and typescript. This is a little example from chapter 2, and they're talking about a pure function, namely, absolute value. Now, granted, you're not really going around implementing absolute value all the time. But let's use it as an example, because it's something that everybody knows. So here's the syntax. We have function Abs, and then we can see that it takes as one argument, it gets a number. And then Richard Feldman: this is the return type. If you're not familiar with typescript syntax, that it also returns a number numbers in typescript because of how Javascript works. These are 60 four-bit floating point numbers Aka doubles in a lot of other languages. Richard Feldman: So then the logic is just. If N is less than 0 return negative. N, otherwise return. N, and that's the whole function. Richard Feldman: So this function is pure. Richard Feldman: But there's nothing telling me about that from the type signature. I just know that it's pure. How do I know that it's pure? Well, I look at the entire implementation, every single line of it. And I'm like, yes, this is currently pure and hopefully, nobody will ever change that and make it not pure. If I want to rely on the assumption that this is pure. Richard Feldman: Now we can make this a little bit more concise, so you can use a ternary operator if you want. This is like a little bit symbol heavy. I don't. Personally, I'm not a big ternary fan, but at the end of the day, if you want to kind of do an expression based like use, more expressions in functional programming type of style. Richard Feldman: The ternary is kind of the best thing that you get, and of course you can make it even more concise if, instead of using the function keyword, you do it in a lambda style. So this is where you essentially write out a closure with this. This big arrow like equals greater than, and then you can sort of get this down to about as concise as you can possibly get of a 1 liner for an absolute value implementation in typescript. Richard Feldman: Now in rock, I'm going to implement this basically exactly one for one translation here. So the 1st thing is that if you've never seen rock code before, we do our type annotations on a separate line. So whereas in typescript, this is sort of interwoven where you see, like N. Colon number. And then you say, Colon number. After the whole thing Richard Feldman: in rock, we have it on its own standalone line and part of the reason for that is that as we're going to see, the type signature in rock is telling you more than the typescript type signature is telling you. Richard Feldman: And so it's actually quite a common thing to talk about functions just in terms of their types without even talking about the implementation, because you can get so much out of just talking about the types. This is something that rock inherits from elm and elm from Ml. Before it, and Haskell and all these other languages. And I really like that style. Richard Feldman: So here's the implementation again, it's just a 1 liner. So we use backslash because it kind of looks like a lambda if you squint, and then we say, if N was less than 0, then negative N. Lsn, and again, this is just sort of like standard Ml. Family syntax, Ml. Being the programming language, not machine learning. Ml. From like 1970, something which is what Elm and Haskell and ocaml are all descended from, and rock by way of elm. Richard Feldman: I do prefer this style a little bit over turnaries, just because you don't quite get as much like, you know the question mark and Colon kind of I prefer the then and else all right. Richard Feldman: But I said that this this type is doing something. Richard Feldman: but it's telling us more than what the typescript type is telling us. So we'll get into that in a second. But first, st I want to look at a more complicated function. Richard Feldman: So this is a print asterisk function. I got this from a different, I think it was a python tutorial, or something like that where basically, it's like, you just give it a range of numbers. So in this case this would be like one to 4 stars. And it's going to just print out one star, 2 stars, 3 stars, 4 stars or asterisks. So here's the typescript implementation of that. So we do a for loop. I happen to do a for loop here. There's a number of ways you could do it, say, constant num in range. And then basically Richard Feldman: for each number inside this range. We're going to print out one star dot. Repeat for each of those numbers. So the 1st one is going to be number one. We're going to print out one star, then 2 stars, 3 stars, 4 stars. Richard Feldman: and Consolelog is how you print those out in typescript. So very simple function, just printing these things out. Richard Feldman: This is obviously not a functional program, or it's not done in a functional style. This is really, really imperative. This is just like Bam, we're just printing these things out one at a time. Richard Feldman: But if I'm being honest, I kind of think this is like the obvious way to write this program like, I love functional programming. But you know, I set out to spend, like, you know, multiple decades of my life building a purely functional programming language. But I look at this code. And I'm like, Yeah, it's a good way to implement this like, if this is what you want to do seems pretty reasonable to me, side effects and all. Richard Feldman: Now, granted, if I have a bigger program, the fact that some of my functions are going to be doing all sorts of side effects like printing this thing out doesn't make me thrilled. But at the end of the day, if my only task is to make an implementation of something that takes a number of asterisks for whatever reason, and prints it out. This does seem like good code to me. I don't feel like this code is lacking in any significant way. Richard Feldman: Now, let's make it a little bit more complicated and let's say that I also want to print out how many total numbers. Rubinson, Claude: Sorry, Richard. I I think there was a question in the chat. Richard Feldman: Oh, I can't actually see those. All I can see is my screen. Richard Feldman: Do you wanna. Rubinson, Claude: Yeah. So Victor says, apologies for the logistics tangent. But to anyone. Michelle (she/her): When I get into the venue. It's not a. Rubinson, Claude: Oh, oh, oh, oh, oh, okay. Okay. Okay. Yeah. Okay. Richard Feldman: What should I call. Rubinson, Claude: We're sending someone. Richard Feldman: Let him in Rubinson, Claude: Yes, we will let. We will let Victor in. Richard Feldman: Should I pause, or or Rubinson, Claude: No, I think you should go ahead. Richard Feldman: Okay, let me just I'll restart from the the top of this just so. So we reestablish context here. Richard Feldman: So so here's a function that's a modification of the previous one that we saw. And essentially, what this is doing is just saying, okay, let's also record how many total stars we have printed as we're going along. Now, of course, this number can change like you could say, I want to derive this. You know this total printed just from the range, but then you'd have to loop all the way through it twice. So Richard Feldman: the most efficient way to do it is just every time we are going through this these elements loop. I want to just like add up, you know, keep a running tally of how many things we just printed, and then at the end, I can return that as the output of the function having done the side effect of printing out the stars along the way, both of which are separately desirable. So again, not a pure function by any stretch of the imagination. But again I look at this, and it's like, you know, I could do this in a more functional style if I wanted to. Richard Feldman: Where I tried to say, like, Okay, total printed is not, gonna you know, get involved in this for loop. It's just gonna like. Richard Feldman: be a pure function from range to total number of stars. And that's a reasonable way to do it, at least from a implementation standpoint. But again, from an efficiency standpoint, I'm like, yeah, this is kind of going to be more efficient to just like do it as we're going along. We got the number right there, you know, in memory, and just like adding it up. Now, of course, this is the toy example. But the reason I'm bringing up this example is to demonstrate, like, I don't think that using an imperative style for some problems is a bad thing. I think some problems are like, really well suited to imperative programming. Richard Feldman: And I'm not saying every problem is. And it really depends on like, what type of stuff you're doing. But they exist. And this is one of those examples where I look at this. And I'm like, Yeah, I could rewrite this in a functional style. But I don't know if it's going to make the code better. Richard Feldman: Okay, so Richard Feldman: let's say that I wanted to write this in rock. Today, I wanted to do this print asterisk function translated from typescript to rock, just using the stuff that we have in rock today. Richard Feldman: So the 1st thing I would do is we don't have for loops today. And so I'm going to say, let's make a helper function called print asterisk help. This is like a common naming convention in like purely functional languages, when you're about to do some recursion, and I want to give it a starting value of 0 here. So here's our print asterisk help function. So it takes the count in the total printed which we're initializing to 0. Richard Feldman: So first, st I have to say, Okay, go get the length of the range, and then that's going to be the initial count here. So we're going to do our stir. Repeat, to get our asterisks. Echo is, let's assume that's a function that's going to print the string out to the console as a side effect. Now, granted today in rock. You couldn't do that. But let's pretend that you could for a second Richard Feldman: and then I would recurse. So this is essentially just the like avoiding a for loop part. Richard Feldman: Yes, you could also write this in other ways. You could write this using, like, you know, fold, reduce, walk whatever you want to call it. But fundamentally, if you want to say, this is a language that doesn't have for loops what's the sort of like hammer that lets you hit every nail the same way that you would hit a for loop like any use case that you could use a for loop. Recursion will always get you there. Richard Feldman: But I don't think this code's better. I don't look at this and say like, Oh, this I have now made it functional, and therefore I've made it easier to understand what this is doing. In fact, I think this is. It's harder to understand what this is doing. I'm sure there are people out there who look at this and like no, no, this is better, but I'm not one of them. I don't look at this and say like this code has been improved by rewriting it in this style. Richard Feldman: now, let's focus in on this thing that I said, like, okay, this is doing a side effect. So in today's rock, because we don't have any functions like this that allows to do side effects. What we do instead is, as I mentioned earlier. We have this thing called a task, and task is kind of like a promise. If you're familiar with promises and other languages or futures, the difference between task and promise is that Richard Feldman: promise is sort of like right. When you create the promise, it immediately runs the effect as a side effect, whereas tasks. You have to chain them all together. So you have to say, like, you know, the equivalent of like in Javascript would be promised. Then you have to chain all these tasks together, and they sort of the entire program builds up into this giant data structure of nested tasks. And that's how all of the effects sort of get interpreted at Runtime. Richard Feldman: So here's here's what that would look like if we didn't have any syntax sugar. And now we're like, okay, if you thought the previous one was like, Yeah, no. I thought that code was better. Richard Feldman: I dare you to look at this code. I shouldn't say that somebody's going to take me up on that and say, like, yes, this code has gotten a lot better now. Granted the main reason that this code, I think, looks like harder to understand is you have all these like task awaits, you know, going on in here also print asterisk help now needs to take this task that it's like accumulating. So we have like task dot, okay, to initialize the 0. And then, like as we go, we're just like awaiting that task. And then we get okay, the previous like, total printed. And then we await the echo. And then we do the, you know, print asterisk help. So Richard Feldman: yeah, again, I, I'm just like, yeah, did. Did we? Did we do a good thing? Here is this is this program that we're trying to build here best expressed in a functional style. Richard Feldman: I don't think so. So. Here's what we're moving towards. Here is the rock code that you will be able to write once we are done landing. The changes that I'm about to describe through the rest of the presentation Richard Feldman: you can just reach for this if you want to. This is how you would actually implement this in rock. Richard Feldman: So let's just kind of go line by line. Here we have print asterisks, has an exclamation point at the end. I'll explain what that means later. That's a naming convention. Then we have the lambda. We have this new keyword called Var. We have total printed with an underscore after it. I'll explain that convention as well initialized to 0. We have a pretty normal looking for loop for num in range we have do instead of curly braces, because we kind of just use curly braces for records and not for blocks. Do is something that ruby uses for similar stuff. Richard Feldman: Also, the exclamation point is similar to how Ruby uses Exclamation point as a naming convention. This part's the same. Repeat the string to get the asterisks we have echo. This actually is doing a side effect. But don't worry. We haven't given up our value of purity as I'll talk about later. And we're just incrementing total printed in pretty much, exactly the same way that the typescript code was. Richard Feldman: So here's the typescript code again for reference. Honestly like, I feel like, Hey, these are one to one translations. They're like, really, really similar. The rock one's actually, I think, a little bit nicer. It's it's a little bit more concise. We don't have, like as many curly braces, a little less symbol, heavy. Richard Feldman: We don't have semicolons, which, you know, if you like Ruby, you might appreciate the lack of semicolons granted in typescript. You can omit semicolons sometimes, I granted, have not done quite enough like Javascript, to know the rules. All I know is that, like Richard Feldman: you can omit them a lot of the time. But then sometimes you have to not omit them, which I don't know. Personally, I'm just like I don't want to think about it. I'll just keep them in, even though I like it better if I just like never have to have them. Richard Feldman: So this is an example of a functional programming language adding support for imperative style, if you want to, and the resulting code, at least in this small example I like better than a language that was designed to be imperative from the get. Go now, I'm not trying to claim that rock is now a nicer imperative language than dedicated imperative languages. And, in fact, we'll talk about some ways in which, like much like when you start with an imperative language and add a functional style onto it. Richard Feldman: The functional experience is just not going to be as good as a dedicated functional 1st language. The reverse is also true, like, I'm not claiming that rock is going to be as good at imperative style as imperative 1st languages, because it's not going to be, and we'll talk about why, that is. But of course, if we want it to be, we have to give us some of the things that make it so nice as a functional language, and I don't want to do that. So Richard Feldman: So one of the ways in which things are going to change Richard Feldman: is that there's a very, very subtle difference if you notice, when I add the type signature on here between the type of this print asterisks function and the type of the absolute value function that we saw earlier. So here, that is again for reference. Richard Feldman: So the difference is in this arrow. Richard Feldman: So what we're introducing is the concept of pure functions and effectual functions. As a 1st class distinction. Richard Feldman: So pure function looks the same way that it does today. It has the thin arrow, and then we have the thick arrow for effectful functions. Richard Feldman: It's not a coincidence that the thick arrow is like the same arrow that you see in typescript where, yeah, you don't like, none of the functions are pure, or at least you can't tell from the type. But in rock you can't, and this is going to be enforced by the compiler. In fact, there's a there's a work in progress shout out to August, who's been working on that. I saw him on the call earlier. I think he's probably still here. He's been doing some awesome work getting this working, and it's not quite ready to land yet. But that's why the title of this talk is the plan rather than the thing that you can already jump in and use. Richard Feldman: and the basic idea is, it's pretty simple. We just enforce the rules. If you're inside a function and you call an effectful function, guess what that function now has to be an effectual function because pure functions cannot run effects, or else they're not pure anymore. Richard Feldman: So once again, we still have this sort of you know the dichotomy that you see in practice emerge, even in purely functional languages, where your code base is separated out into the functions that do effects or like are causing effects to happen. Whether or not they're technically pure. And the functions that aren't. And we're just reflecting that in the type signature, in basically the most minimal way you could possibly do it. Richard Feldman: So let's look at some of the other conventions that we're doing here. So one is. Richard Feldman: So this bar keyword, the way that this works is essentially it allows you to reassign a name so rock does not allow shadowing. We talked about Richard Feldman: allowing it. But the current plan is not to do it. Whenever you do something like this, where you don't have the Var keyword. That means it's basically the const is sort of implied. So you're not allowed to reassign. Stir by default like you say this, it's as if in typescript you had written, Const, stir equals. That's not changing, because that's the default, like. Normally, when you write an assignment, you want it to be Const. That's just kind of the, you know, like, in a functional style, pretty much what you almost always want. Richard Feldman: But if you want something to change every iteration of a for loop, then yeah, you actually do want to be able to say, I want to reassign this thing like we are here. I want to be able to change this number. And that's what Var does. Now, a really important distinction here is that the Var keyword allows you to reassign a name, in other words, over the course of this function body, I can change what total printed value is, but it doesn't allow mutating a value in place. Now, the reason this is such a critical distinction is that this means that we still have the property. Richard Feldman: that you can always pass any value you want into any rock function, whether it's pure or effectful, and have the guarantee that that's not going to get mutated out from under you. In other words, if you reference that value again after you call that function, it will not have changed. There's no chance. It will have changed, based on what that function did, because the language doesn't allow that. So even if you say Var, whatever that doesn't allow mutation of values, it just allows reassignment of names. So you can reuse this name. You can recycle it. You can change it over the course of this function Richard Feldman: also. Var does not cross function boundaries, so if I do a lambda somewhere in here, and I've got this thing in scope like captured. I can't mutate it or change it from within that lambda, because then that lambda would be getting into territory. We don't want to get into. This is really why we're adding this to the language. It's for loops. And then there's 1 other use case which has to do with sort of like a stale state where it was one of the motivations for why we were talking about adding, shadowing, but this seems like an easier way to do it. Richard Feldman: also of note using Var does not affect a function's purity, like if you wanted to use var inside Vavs, that's totally fine, because at the end of the day a function's purity is just about. If I call this function with the same arguments, does it return the same value. Whether or not I happen to use Var in the implementation of that doesn't really affect that. If Var worked where it allowed you to mutate, what's coming in. That would be a totally different story. But we're not having it. Have those semantics. Richard Feldman: This is an example of how rock is not going to be as good at imperative programming as imperative. 1st languages. We have these restrictions on what Var can do that most imperative languages, in fact, all imperative languages. I can think of. Just don't have, if you allow this thing to be like reassigned pretty much. Every language that allows that also allows, you know, values to be mutated if you if you do that. Richard Feldman: Now, one of the things that I really like about where this design is going is that it allows for some really information. Rich code. There's this really cool book by Edward Tufte, where he talks about basically like data visualization. And Richard Feldman: one of the things that impressed me about this book was this concept of like, you can have a data visualization where you can learn more and more things and get questions answered, just by sort of looking at it longer. You don't actually need it to be interactive in the sense of like, I give it an input and it gives me an answer. You can just answer your own questions just by looking at things. And the code equivalent of this would be, you don't even necessarily need to use your eyes. You can use a screen, reader, or something like that. Richard Feldman: So something that I think is really cool about this is that again, you know, just from looking at the type signature. I can tell you this 1st function is pure, and the second function is not. The second function is effectful. Richard Feldman: And one of the conventions that we are establishing, and this is going to be enforced by the compiler as in like, you get a warning if you don't follow this convention. Is that effectual functions end their names end in an exclamation point. So this is sort of like borrowed from ruby a little bit. Ruby uses this convention for functions that mutate things in place. Now we don't. That's not a thing that we do. But the idea here is that basically. Now. Richard Feldman: if every function that's effectful has an exclamation point in its name, then check it out, I can tell you very quickly, like, oh, even if I don't know the type of this function, I can just look at the body and be like look, there it is! There's the effect, and that's the only effect that this function does. I can see that really quickly. Richard Feldman: I was writing some code that was for a web server that was sort of being done like. Let's pretend that this style already exists, and I can do it, even though like it hasn't landed yet. How would that code look. And there was this cool moment where I was implementing a function. It was for Richard Feldman: reading the access token out of the headers of the web request, and I realized that there was only one exclamation point in that function, and it was for getting the current time, because essentially I just needed to see if the token had expired, and I was like, I'm so close like this is almost a pure function, except for this one thing which is getting the time Richard Feldman: if I just accept the current time as a parameter. Then now, this whole function, like all the stuff that it's doing to get the like, you know, Jwt, out of the header. Richard Feldman: this can be a pure function, and it's like really easy to test. It's it's never going to flake. I'm never going to get like. Oh, this test passes, except like, you know, at midnight on like January first, st when like oh, no, you know like that that type of stuff that can happen when you have tests that are depending on the current system time, or, like, you know, trying to hard code it like now, it's just passed in. And it's like it's trivial to test that function. And the only reason that I realized that it was so close to being a pure function Richard Feldman: was that I was like, oh. Richard Feldman: this thing has an exclamation point in there, which means I need to put it in the name I was like, do I do like? Maybe I can just make it be a pure function, and just like kind of move. That exclamation point out a little bit. Richard Feldman: Now, this is the thing that a lot of people I've talked to have said, like, Yeah, I do that habitually. And I do, too. Granted like, when I'm writing rust code at said or before I was using functional programming languages when I was doing functional style like Javascript and coffeescript back in the day. I would do that as much as I could, but it's not quite the same as like when you actually have compiler assistance where you actually have like. No, this is a rule like Richard Feldman: it felt different even in that moment when I didn't actually have a compiler doing it. And I was kind of like faking it myself. It was a cool moment. I hope to get more cool moments like that. Richard Feldman: Okay, and, by the way, today there's already equivalent to that which is like, if you have a function that returns a task. And you're like really close to not needing that. It's always like oh, let me see if I can get that task out of there if I could avoid it. So I think this is a kind of a lightweight or a lightweight version of that feeling. Richard Feldman: also I can tell more things, keeping on the theme of like information. Richness. I can look@thisstir.repeat, and be like, Hey, this doesn't end an exclamation point. That's a pure function. Again. I don't need to go look up its type. I'm just looking at the code on my screen right now, or, you know, getting it out of a screen, reader, and I'm like, I already know, that this is not a you know if I'm wondering, what effects does this function do? It's like it's only the ones that end in an exclamation point. I can tell that just at a glance. Literally, I don't have to ask any questions. I don't have to stop. Richard Feldman: Go like press some ide buttons. It's like, just from looking at the code. I can tell that. Richard Feldman: Speaking of which, let me get back to that underscore naming convention for Vars. So the idea here is that Vars have to be named. And again, this is also enforced with a warning, with an underscore at the end. Richard Feldman: So the reason for that convention is a to make them stand out so you can say like this is being reassigned, and I'll explain what the value of that is in a sec. The reason for an underscore at the end is that it's supposed to mirror the underscore at the beginning, which is a convention that we use for like hey, this is unused, but, like, you know, don't warn me about it like you get an unused word, and you can just stick an underscore at the front. Which means, like, yeah, yeah, I know it's unused, but like, don't don't yell at me about it. I still want to give it a you know, a meaningful name, so I can tell what's unused. Richard Feldman: So the idea is that underscore in the front means unused and underscore at the end means reused. Richard Feldman: So when I look at this code, and I see at the end here, like, let's pretend this code was like very, very long. This function was long and, like, you know multiple screens. Richard Feldman: I can tell, just from looking at any instance of this, this thing is being modified somewhere in the function, like earlier on whatever this thing started out as it got changed somewhere in here, and I can tell that, because, again, if that weren't the case, the compiler would have warned me about it. 1st of all, if it didn't change, it would say, you don't need to use Var for this. So get rid of the bar. So basically, like. I can tell from looking at this for sure this thing is changing, and I need to be a little bit more careful about it. Richard Feldman: So in this particular function. The way that that's changing is like, Oh, yeah, it's in the body of the loop. It's being incremented here, plus equals would just be sugar for like equals, total printed plus one just like it is in most most languages. Now, the the critical thing here about this is that in pure functions. Richard Feldman: Effect order doesn't matter. And what I mean by that or sorry ordering of code doesn't matter. Like, if you're calling pure functions in like like first, st I call this one. Then I call this one. Then I call this one. I can shuffle those around as long as they're getting the same arguments like it doesn't matter. Nothing happens. And the same thing is also true of constants that are never being reassigned like it doesn't matter if I put it up here or down there, or whatever else, as long as the constant is like Richard Feldman: being computed the same way really doesn't matter. Richard Feldman: not true. If we are reassigning things as soon as we're reassigning things, that code is just less portable. I cannot cut it from one part of my function and move it up to another part of the function, because I think the function will read better that way. That might actually change what the code does, even if all the same stuff is in scope. Richard Feldman: I've actually had this happen to me in rust code where I've moved stuff around. That's a refactor I used to do in elm almost out thinking, and just be like, Oh, yeah, I think it'll be more logical, more easier, you know, easier to read what I'm doing if this thing goes up here, and then the code breaks. I'm like, what? How could that happen? And it's because rust allows doing stuff like this. Richard Feldman: So the idea of the underscore is to give you a warning like, hey? This code is not portable. You cannot like like portable in terms of like where it is in the code base. You can't just like move it around willy-nilly, because it's potentially going to change its semantics if you do that. Richard Feldman: And again, this is not the default, because the default is like, you have constants. So the constants don't need to do that. It's just when you're opting into var like this? Richard Feldman: okay, so here's our print asterisks function again. Now, one of the things I could do is I could say, Okay, let's let's forget about the name for a sec. So you know, print asterisk exclamation point equals. We'll just get rid of that part. Richard Feldman: I can look at this function and infer like, okay, that's the Richard Feldman: This is an effectual function just by looking at that. So even though I don't have the type, even though I don't have the name I can just, you know, at a glance, look at the body, and very quickly answer the question, you know, is this pure or not? And also again at a glance. I can look at this underscore and say, this chunk of code within the function is not portable. Richard Feldman: One case where this came up that was actually really cool was I was looking at Brendan. Hans connects code for Rocky Bird. So if you haven't played this, it's a it's a really cool game. It's got some sweet art. So this is sort of like A, it's based on this platform called Wasm 4, which is like a webassembly platform for building like sort of old school style games in the browser Richard Feldman: and rocky bird is implemented in rock, and I was looking at this code, and there's a bunch of code here like there's all sorts of stuff. You want to look at the full source code. You can look at this Github repo up top. And Richard Feldman: I was reading through this code just kind of skimming it. And I wasn't like looking at, you know, every single thing that it was doing. But I did see one thing that really kind of stood out at me that jumped out at me. So like at first, st I was like, Okay, so it's like, you know, drawing the pipes. And that's like, Okay, effectual exclamation point. Cool makes sense drawing the ground, drawing the plants. Got it? That'll make sense going through like, Oh, we're calculating y pixel here. And then I got to this part, and this is what jumped out at me. Richard Feldman: Player collided, and then I give it the Y pixel, and then the you know the flap, animation Richard Feldman: and player collided has an exclamation point like the collision detection function. I was like, huh? Richard Feldman: Why would Richard Feldman: Player collided, be effectful like? What? Why would it need to like, read from the outside world or write to the outside world? So I dug into it, and I looked at the implementation. Richard Feldman: And I came across this. So here's the implementation, and it says, there's a comment at the top. This is written in a kind of silly but simple way, because let's be honest. This is a side project. This is not like a production, you know, game that's like shipping to be sold for money. It's like it's a hobby project. It checks to ensure a few points in the Sprite are all background colored. This must be run before drawing the player. Richard Feldman: And then there's some other stuff happens. Then we iterate over the pixels. And then basically at the very end, you see. Okay, why doesn't 4 dot get pixel? And this is the part that's effectful and the entire collision detection logic. This is the only part that's effectful. And the reason that it's there is because essentially what this is doing is saying, Okay. Richard Feldman: wasm 4 already knows how to like. Draw these pixels for the bird, like, you know, into the the sort of the background buffer. And it already accounts for like buffer, you know, background, transparency and whatnot. And so the basic idea is just to be like, okay. Richard Feldman: let's see how the pixels ended up. If the pixel ended up being the background color, then okay, we didn't collide with anything great, and if we did collide with something, then the pixel would not be the background color. It's just sort of leaning on the underlying sort of game engine to be able to answer this question rather than trying to write a really complicated like, okay, let's let's go through and look at every pixel in the bird to see if it you know really. Richard Feldman: you know, carefully collided. Because if you just basic like rectangle based collision detection in a game like this. You're going to be really frustrated because you know, the corner of the bird that doesn't exist is going to clip the thing, and you're going to lose. And you're gonna be like what come on like. I clearly did not hit that. So you want to be precise on those things. And this is a reasonable way to do that. Richard Feldman: The point of this is that if I hadn't read every single line of code of this, like in most languages, that exclamation point would not have had to be there. Richard Feldman: I would have had basically like, no idea that this code has to be run before drawing the player or the collision detection doesn't work because it relies on the drawing actually having already happened in order to get that pixel. Richard Feldman: Now, this is, I think, given the constraints of the project, namely, again, it's a hobby project. This is a totally reasonable thing to do, but I have worked at all sorts of places, and worked on all sorts of code bases. Where there are things like this there's some sort of little gotcha, and if you don't happen to read every single line of code and find the one comment that describes the gotcha. Richard Feldman: You just trip over it, and you know somebody else wrote it. Maybe they don't even work at the company anymore. I see these things cause production bugs all the time. Richard Feldman: And what helped me figure out that this was happening and led me straight to this was just curiosity about like, Hey, how come? There's an exclamation point there! Richard Feldman: And to me again, this is awesome. This is such a great like outcome here, because it's just one character. It's a little exclamation point. It doesn't make the code like really cluttered up, or harder to understand what's going on. Richard Feldman: But it gave me this really important clue of like a little thread to pull on, and when I pulled on that thread. I actually found something that was really important and helped me understand how, if I wanted to make changes to this program, I could do so without accidentally causing bugs. That's exactly the type of thing that I'm hopeful that will be able to become part of the rock experience. It's like you look at code like this, it's really easy to follow. It's very concise. The effect handling is very straightforward. And yet you have all this sort of Richard Feldman: information. Richness of looking at the code and being able to get these little insights very, very cheaply and very, very quickly, honestly, without even thinking about it. Richard Feldman: Okay. Richard Feldman: so Richard Feldman: we talked earlier about. There's imperative languages that are adding support from functional style like rust, Kotlin, swift and typescript. Rubinson, Claude: So, Richard, I wanna interrupt. There are a few questions in the chat. Richard Feldman: Okay. Rubinson, Claude: So one is Rubinson, Claude: if the exclamation mark and and the underscore are good indications and compiler enforced, do we still need the the thick arrow and the bar key. Richard Feldman: Totally valid question. Well, okay. So those are separate questions. So one was, do we need the thick arrow? And do do we need the Var keyword? Was that the 2 questions. Rubinson, Claude: Yeah. Richard Feldman: Yes. Okay. So let me back up and see if I can. I'm not sure if these happen to have examples of this, but we'll figure it out. So one thing is, actually, no, okay, I know I can find. Yeah, here we go cool. So Richard Feldman: one of the things that I like about this is I mentioned this earlier, but I'll reiterate it so a thing that we do like an elm and also in rock is like, quite often we just talk about functions by talking about their signature, because the signature tells us a lot. The thing that I like about having it explicitly in the Arrow is that I don't need to look at the name. I don't need to look at the implementation I can just be like, hey? Suppose I have a function with this type? I don't need to tell you its name. I don't need to tell you its implementation. We can just have a conversation about this and about the differences between this. Richard Feldman: And I think that's especially nice when you're talking about like Api differences like, Hey, I got this function, and it's like this. What if I made it be like this instead? It's like, Well, hang on! You'd have to change the thin air to the thick arrow. If you wanted to do that, because, you know, that's gonna introduce effects. Oh, yeah, you're right. You're right. Right. I love being able to talk about those things and not get bogged down into questions like, what am I gonna name the thing and things like that? So Richard Feldman: it is a small distinction. There is a world where you could say like, we don't have that distinction between the 2, but I think we'd be missing out on something, and one other example of this, and this is something that comes up often in language, design Richard Feldman: conversations is like what happens when you put it into the repl. So if I put into the repl, I say, like, you know, here's a lambda, it does. It calls an effectful function. What is the type of that that comes out because it's an anonymous function like I didn't, you know. Richard Feldman: say anything about its effectfulness or not? The rep is not going to choose a name for it. It's gonna be like, Hey, this is an anonymous function. I would like the repl to tell me like, Hey, by the way, this is an effectual function that you just pasted in here. That's useful information for me, because if it was a long one, for example, I might not have noticed that there was an exclamation point in there and then. I wouldn't have had the name to tell me so, you know. Not a hard requirement. But I think it's worth it. Richard Feldman: The question was, Oh, go ahead. Rubinson, Claude: Push back on that a little bit. Richard Feldman: Push. Back. Okay. Rubinson, Claude: certainly in-in Rubinson, Claude: pure functional programming languages. Looking at the type signature gives you a ton, and often right? If it's just end to end, then who knows what you know but but it can often give you a whole lot of information Rubinson, Claude: here, having the thick arrow. Rubinson, Claude: I'm interpreting this as well, I have this type. I have that type, and in between, anything can happen. So is it telling me that much. Richard Feldman: Okay. So here's here's the question. I don't know if you've done Haskell or so, how much Haskell you've done. But what's the difference between saying, F. 64, thin arrow, F, 64. And in Haskell saying. Richard Feldman: F. 64. Thin arrow, IOF. 64 Richard Feldman: to me. That's basically the same thing as take care of any case where you have like in Haskell, or an element would be task or rocket would be tasked today. Richard Feldman: where you're saying this function returns an I/O of this or a task of this. It's kind of the same thing it's really saying like, Yes, I'm going to give you this task value. But as soon as this task value gets turned into the value that it wraps, which is what I really care about. Richard Feldman: All bets are off. It could be doing any number of all sorts of things. Now, granted, there are type systems that make that more granular which I'm going to talk a little bit about later. But but at a basic level I don't personally think at least based on my experiences using Haskell and Elm, and today's Rock, that there's a Richard Feldman: significant difference in terms of like, how much the type signature is telling me between this returns an I/O of F. 64. A task of F 64, and thick arrow, which is saying, like, I'm going to do some side effects and then give you? A U, 64. Because at the end of the day like that's in in both cases, in practice, that's what's going to happen. Richard Feldman: Okay. Rubinson, Claude: Yeah. Richard Feldman: Okay, second question was about Var. So the reason for the Var keyword is to prevent mistakes of like the copy pasting variety. So imagine that I have this code where let's pretend there's no var keyword for a second. It's just total printed underscore equals 0. And then inside here I'm doing total printed underscore plus equals one. Richard Feldman: Now you can imagine that. Let's say we had some like really big code. And there was, you know, a lot of stuff going on, and I copy paste some code from somewhere else into the middle of that code. Richard Feldman: And just by sheer coincidence, I happen to use the same name of this variable that's in the outer scope and being used so total printed. Okay, that's not that likely to happen. But you could imagine I don't know. Count underscore something like that something sort of generic. Richard Feldman: Well, now, what I've accidentally done is that I pasted this code in there which used to just declare this local little variable and then modify it. And now I'm accidentally modifying the outer variable. So this is a problem that used to come up in coffeescript all the time where coffeescript basically didn't have a bar like they just all the assignments looked like this, but they were mutable. So you could like reassign them all the time. Richard Feldman: The purpose of Var is that because we don't allow shadowing is, if you do this, and then you paste some nested code that, declares Var, with the same name again, you'll get a compiler error instead of it silently messing everything up. Richard Feldman: So that's the reason that we have that keyword in addition to the convention of the underscore Richard Feldman: great questions. Richard Feldman: other other questions before we move on. Richard Feldman: Okay. Raul Chouza: I do have a question. Is he underscored, enforced by the compiler in some way Raul Chouza: or, yeah? So the idea is. Richard Feldman: If you use the bar keyword then the compiler will say like, Hey, you're supposed to name this an underscore at the end. So you know, please do that. Just a warning like it's not. You know, it's not gonna like block you from running the program. If you if you don't do that. But yeah, both the underscore at the end and the exclamation point at the end. The plan is to have those be compiler warning. So everybody follows a consistent style. Raul Chouza: Oh, nice! River Dillon: One more question quickly. If a var is only declared locally and used locally, can the outer function be considered pure? Richard Feldman: Yes, absolutely. So purity is really just about like what happens when you yeah, like, get the arguments and then return it. So yeah, like, there's no Richard Feldman: that doesn't really affect that. It could if we had Var have different semantics were allowed in place mutation. But it doesn't. So, yeah. Richard Feldman: yeah, so it happens to be used in an effectful function here. But you could totally use of our in a pure function be totally fine. Doesn't affect that Richard Feldman: cool. Okay. So previously, we were talking about how there's a lot of imperative languages with support for functional style. We talked about Rust Kotlin Swift, and of course, typescript as examples of imperative languages that support a functional style. So the idea here is that basically we want to take rock and make it be a functional language as functional 1st and like, has awesome support for functional programming. But also it does have support for an imperative style. When you want to reach for that. Richard Feldman: Now granted, like an imperative language, is not going to make you add these underscores. It's not going to make you name things on exclamation point Var is going to work across function boundaries. You can mutate stuff in place. I'm not saying that rock has the best imperative experience in the world, but rather that we want to let you use an imperative style occasionally, when that seems like genuinely the best way to write the code Richard Feldman: much like how you know I when I'm writing, rusted Zed most of the time. I'm writing an imperative style, but sometimes I occasionally will say, you know what I think. This code right here will be best in the functional style, and I can just reach for that. Richard Feldman: That's the idea. Here. Richard Feldman: But there's another piece to this which is learning. Curve Richard Feldman: one of the things that's really cool about for loops that I took a long time to realize. But I was talking to somebody who teaches a lot of beginners about like how to do both imperative and functional programming. And one of the things that came up in that conversation was about sort of how useful for loops are, and reassignable variables, for that matter, as a beginner, because if you know how to do reassignable variables, and you know how to do loops. You can unblock yourself to do an enormous number of things. Richard Feldman: You can just figure it out on your own. You can solve all sorts of problems. You don't need to necessarily know, like special purpose functions for that. Richard Feldman: Now, the problem with learning a purely functional programming language. And I have seen this in practice is that at 1st you're like, okay, I learned about like List dot map. And maybe, like, you know, like it's like map filter. It's a couple of you know, small ones like that. You can maybe like more advanced ones like concat map, flat map. You know that type of stuff. Richard Feldman: but it's a pretty long list of like increasingly special purpose niche, higher order functions that advanced users get familiar with, and you know, know, to reach for. But as a beginner you don't know what those are. And so if you're if it doesn't happen to like Richard Feldman: map directly to like the the couple of higher order functions that you know about. Then you're at this sort of awkward point where you're like, okay, I have this problem. I don't know how to solve it. Using the primitives I'm aware of, or like the helper functions I'm aware of. How do I solve it? And then your answers are well. The most flexible way to solve this is either recursion or the most general of higher order functions, which is, either, you know, fold or reduce, or some variation of that. And the problem with that is that Richard Feldman: for loops are notoriously easy to learn. Richard Feldman: recursion is notoriously difficult to learn. So having recursion be the answer for hey, this is your all purpose. Get out of jail, free card. You can solve whatever problem you want. Richard Feldman: Isn't that great, especially when you're like. And also, by the way, you got to make it tail recursive. And now I got to teach you what that is and how to, and, you know, follow the rules for that. If you don't want it to potentially blow the stack, if it's like, you know, getting too big, which maybe as a beginner, you know, might not come up. I have actually blown the stack on like some beginner exercises before. But Richard Feldman: But the point is that Richard Feldman: once you get past the very, very basics of functional programming of like, you know, map and filter and whatnot, once you want to unblock a beginner to be like. Hey, you can now go solve your own problems. A lot of problems. Richard Feldman: for loops are awesome, for that recursion is not awesome, for that Richard Feldman: fold is not awesome, for that like fold is a higher order function that a lot of people, even after they're like intermediate functional programmers like hang on. I gotta go look up all these arguments do, and I know there's like something I could use for this, and then oh, wait! But if I need to exit early. Then, like what what do I do? And then like if I there's just all of these Richard Feldman: layers of difficulty, and like stumbling blocks for beginners to trip over that just do not exist. If you have a for loop in the language, and much like with Elm, you know Rock does aspire to be a language that is beginner friendly. It's not our number one value, but it's important to us. And so to me it matters that people can get into rock and start using it in an imperative style and be like, Hey, I'm just going to write this type of code all the time Richard Feldman: as if it were go, or typescript, or something like that, and over time I can learn. Oh, if I do things in this other style, if I do a pipeline of like, you know, operations. My code gets more concise, and it gets easier to understand what's going on, and I don't have all these underscores, you know, as often underscore, becomes a rare thing rather than a constant thing. In my code base. I have fewer exclamation points in my code. Base Richard Feldman: and part of the reason I think that can be an awesome experience is that that was how I got into rust was at 1st I didn't really understand all this like advanced borrow checker lifetime stuff. This is another thing that's notorious, like functional programming. Purely functional programming is notorious for having basic things like loops that don't happen to fit into. Like, you know, the map filter type of space being harder for beginners to pick up. Rust has a reputation, I think, well deserved for being hard to get into when it comes to the borrow checker and lifetimes and stuff like that. Richard Feldman: But there's this escape hatch, which is in rust. It's called Dot Clone, and a whole lot of borrow checker errors get like. Just go away. The compiler leaves you alone. If you say, Dot Clone. Now you know, when you're doing dot clone. Richard Feldman: that you're not doing the best thing here, because that deeply clones the thing, and it's bad for performance, and very often, if you're using ruths because you want performance. So the Doc Clone is sort of like, I wish I could get rid of that Richard Feldman: sometimes you can, sometimes you can't. But the point is as a beginner. You have this thing where you're like. I know I'm not quite doing the thing that like this language is built to do. Richard Feldman: But it's okay. I'm unblocking myself, and as I get better I will trust that over time I will learn how to use clone less and less. I think we can do the same thing here. And we can say, like, Look, you're starting out doing things in an imperative style, because we support that. But over time you're going to learn the functional idioms, and you can sort of ease into it. And my hope is that Richard Feldman: this will give beginners a smoother experience overall than what's possible today. Because today, once you get to that point, it's sort of like, all right. You just got a cliff that you got to climb down and you can climb up. You got to learn these things in order to get yourself unblocked. You got to become comfortable with recursion right now, before you can continue working on your, you know. Hobby, project game, or whatever the case may be. Richard Feldman: So yeah, that's awesome. And I think, like putting these things together like, it's it unlocks a new learning experience that I'm really excited about. Okay, I do want to mention some other alternative designs that we considered. I I referenced a little bit earlier on. But I'm not gonna spend a ton of time on this, because, honestly, that could be like a whole hour to itself. You know, I want to wrap up here. Richard Feldman: But basically. So here's like a really really simple example of some rock code that you'll be able to write once all this lands. So you say, echo, Hi, stir equals. Read. Arg. So this is doing an effect like reading it from who knows? Environment, variable whatever. And then like, echo out the string that you just read, okay, Richard Feldman: like the very beginning of rock, and we had no syntax sugar for any of this. This would all be done with tasks. So this is like the I don't think again, anybody would look at this and be like, Oh, yeah, this is much better code than that. I mean, maybe they would, but I don't. I don't think so. I think it reads a lot, you know, nicer in that style. The 1st version of this that we had which, you know, obviously, was something we considered, because this is what we started with was what's called back passing. Richard Feldman: So this was rock code that you could write. Actually, this still compiles. Today we haven't. We've deprecated it. Wait me! I think we just landed a Pr. To remove it. I forget. At any rate, backpassing is deprecated. But I think it's still just deprecated. So you get a compiler warning if you do this today. But it'll still compile. Richard Feldman: So basically, the idea here, which I thought was really cool at the time was basically it's sort of like a backwards lambda. So if you look, you see the same kind of ingredients here. So you have like this. Here's this lambda that corresponds to this, and the entire body of that lambda is like over here kind of this is like, you know, calling it passing this whole lambda as its 3rd argument. And it's the same thing down here again. You have like stir and the arrow going this way. You have stirring the arrow going that way. And then this is the body. This is the body. So it's like, yeah, it's a backwards lambda cool right? Richard Feldman: Apparently it's cooler in my mind than it is to a lot of beginners. So back, when this was like the way of doing things. We tried it this way, by the way, and then also tried it. This other way. Where we had it sort of like with the arrow on the other side. Richard Feldman: neither like piping it to tasks out of way. Neither of these, like, worked out great in terms of beginners. A lot of people were just like really confused about it. It was like one of our more common beginner questions people being like, I don't understand what this is doing. Like helping. Oh, look, no, it just desugars to this. I think part of the problem is, it's like you explain what Desugars to. It's like. Richard Feldman: this doesn't look great like this isn't like innately, you know, like, Oh, no, just these sugars to this right? This is really straightforward. Yeah, not when you're used to this. Richard Feldman: so another version of this is what gleam does which we did talk about. We never actually implemented, which is essentially like taking this back, passing thing. And then, instead of having each of these calling the tasks outaway, you sort of do this use at the top where you say, like, Okay, just implicitly. Each of these arrows is going to be connected by a taskaway. Richard Feldman: That's totally a thing that you can do, and I have heard people say that they like enjoy that feature in gleam. I think it. It is relevant to note, though, that gleam doesn't do this, for I/O glean does at least okay, not normally. I guess if you're compiling Javascript, you might use it for promises in gleam. I don't know how the experience is there. But I think in gleam this is used more for things like parsers. And granted, that is a selling point of this is that you can use it for other things than just I/O, because it's just syntax sugar. But at the end of the day I also have heard a couple of people say that, like Richard Feldman: they found that, or or like beginners, find this confusing and gleam sometimes, but I think it's pretty different if it's like this is blocking you from doing. I/O in the language versus like this is something that you as an advanced user, can potentially reach for Richard Feldman: regardless, we tried this out for I/O and it it didn't go great. And then, finally, you have Haskell, which is basically like a more concise version of what gleam does again. This is more powerful. Haskell's is based on monads, and, like you can, you can do all sorts of things with it. Richard Feldman: But at the end of the day, like fundamentally, these are all kind of like, you know, several sides of the same coin. Oh, we also, by the way, on Current rock. We we do have this version, which is slightly different than this, where exclamation point is actually currently a keyword. And we do this sort of elaborate desugaring into this down here, which, in terms of like code readability, I think, has gone pretty well. Richard Feldman: But again we have seen beginners talk about like as soon as you start trying to explain the sugar which ends up being unfortunately necessary in a lot of cases, because if you don't have a good mental model of the sugar. I was hopeful that it was like, you don't need to worry about it, but it turns out that it's like most of the time. You don't need to worry about it. Then. Occasionally you get a really confusing compiler error message. And then again, we just start busting out the sugar explanations. So Richard Feldman: I'm really looking forward to a world where we can just have really straightforward compiler error messages that are just like you're calling an effectual function inside a pure function. You can't do that without without changing this to be an effectual function that's like so straightforward and easy to understand. It's just gonna eliminate this whole category of confusing compiler error messages which beginners run into all the time right now. Richard Feldman: So these are alternative designs that we all sort of like considered. Oh, yeah, one more thing about the like. The whole family of like chaining functions, like task chaining, like, you know, do or use, or backpassing, or whatever else there's certain things that they just like can't do. So. The classic example of this is like, if you want to do an effect inside a conditional. You just cannot do that at all in the chaining style you have to name the thing and say, like, you know. Richard Feldman: does this file exist equals, or you know, arrow, and then say, if does file exist, then there's no way to just like, run this in the middle of this, and you can like. You can't do something exactly like this. You could do the like tasks out of wait manually yourself. Richard Feldman: But again, like these types of things where you're doing, nesting, or especially putting them inside conditionals, which, granted, doesn't come up all the time, but like it's just like it's not possible unless you're doing something like, you know, this style and not using that chaining syntax. Richard Feldman: So Richard Feldman: basically to summarize like, you know, why not changing syntax? It's like there's this learning curve of back passing or use or do that like just does not exist in the direction we're going like that. Learning curve just is completely obliterated. It's just gone. The learning curve of like a task itself, by the way, is also separately a concern. So there's been this ongoing question that we've seen of like, hey? I've been chaining all my tasks together. We've been accumulating these errors like rock is pretty awesome at that, actually. But now I'm like, hey? I don't want to run my task. I want to just like. Richard Feldman: get the error and like, handle the error like, How do I do that? And that's a totally reasonable question. But then we're like, okay. Now, you got to convert from a task to a result. And like, here's how you can do that. And now you need to kind of like, move your code around a little bit Richard Feldman: in the world where we have purity inference. And we just have, like a distinction between pure and effectual functions. It's like. Richard Feldman: just call the function. It's just going to return a result which is like a totally normal thing that you can pattern match on. It's like a completely ordinary value. My hope is that that would just become like a non question, because, like again, this, this category of learning curve just goes away. Richard Feldman: There's nothing to convert between. Richard Feldman: Also, there's some performance overhead to these task containers. I'm not really talking so much here about like the cost of the like data structure itself, but rather the way that things have to be organized inside of it. So we have a little proof of concept of stackful coroutines, which is kind of like what Go does also Brendan Hans Connect, who I mentioned earlier with rocky bird like he and Luke Boswell collaborated on that. And Brendan's been working on Richard Feldman: this like really awesome like implementation proof of concept of. Well, I shouldn't say it's really awesome. It's awesome that he's working on this. This proof of concept that is apparently close to working where basically we can get Richard Feldman: sort of performance characteristics, or like doing things in the same style that go does for like really really high performance, low overhead concurrency. Richard Feldman: as soon as I say that, I guess people are immediately gonna ask about the beam, because the beam also does some like related stuff. It's like, you know, actors versus channel. And there's like different semantics. You could use what we're building to build something more beam like. But the beam does way more than just that. So that's like kind of a whole rabbit hole. But the point is that trying to do that today where we have this task based thing. Richard Feldman: You can't really do something like that. There's other things that you can do. And so there's there's a possibility that we might want to explore Richard Feldman: offering a behind the scenes mode where you can sort of compile down to something that looks more like tasks, because then you can hook into other languages, async runtimes, like rusts or nodejs. But that's again sort of out of scope for this talk. Richard Feldman: And finally, I mentioned earlier, like error, message, helpfulness, like, I think it's just going to be way more straightforward error messages compared to like today with all the syntax sugar that we're trying to do to like approximate this one of the things that we've learned from doing that is just that like, yeah, the error messages are not great. And maybe we can make them better. But it seems like a lot more straightforward and simple to just say, like, What if we just didn't have that category of errors anymore. And we just had essentially the same like error, message, experience that you get when like not doing I/O in the language, which is much better, I think. Richard Feldman: I also mentioned earlier. And I'm just going to briefly sort of gloss through this. There's a there's a much broader algebraic effects design space. We talked about all these things. And the short version of this is like, we're just kind of aiming for something simple and minimal right now, because we can always add more stuff later. But it's much harder to subtract stuff after you've added it. So we're just going for the most minimal implementation. This right now, which is sort of like binary algebraic effects. So this is an algebraic effects system that we're talking about here. But it's like Richard Feldman: the most simple, minimal one you can possibly have. It's just binary. It's like, Are you a pure function or not? That's it. Whereas, like, you know, you have, like ocaml and unison, I would say, and coca would be the like top 3. Like most well-developed algebraic effects systems that I'm aware of. Richard Feldman: So they'll have things like effect, polymorphism for higher order functions. So you can say, like, I'm going to call like list map. And if I pass it a pure function, then it is a pure function, and if I pass it an effectful function, then now it is an effectful function, at least for this design, like we're not getting into that. The door is always open. We can talk about it later, but at least for right now, for what we're planning on shipping as the 1st iteration of this. We're not going to get into that at all. Richard Feldman: Also, ocaml and unison and coca will track which effects the function does. So you can have in the type signature things like. Not only is this an effectful function, but I will tell you that this effectful function is doing Http and file I/O. But it's not, you know, doing this like writing to standard out, or something like that. And you can tell that at the type. Now, there's there's trade-offs there. We used to have a SIM, Richard Feldman: a similar system to that where we had tasks with a 3rd type parameter that tracked like which effects were happening. Richard Feldman: It got kind of verbose. I wasn't a big fan of it. I was like, I actually think it would be better if we stopped doing that. So I think there are like pros and cons to doing that. But it's not like a clear like, oh, this is just better. It's like, yeah, the drawback is actually pretty serious, I think, in terms of like, how verbose your type signatures can get. If you're like, actually just need to do several different effects, and then that's a propagate to every function that calls it. But regardless again, this is something we could add in the future if we want to on top of the system Richard Feldman: and finally customizing how effects run in user space. This is usually called algebraic effect handlers. Again, not something that we're doing for this iteration. But the door is always open. If we want to like any of these things, we could expand from what we're doing now to these things in the future. But for right now it's going to keep it nice and simple and minimal, and just try to get the what I see is like sort of the the main benefit which is just this, like really clear separation between like here are pure functions. They have these properties that we can rely on, and here effectful functions, they have a different set of properties. Richard Feldman: Okay? And finally, before I wrap up, I just want to acknowledge that, like, hey? Richard Feldman: This is adding new language primitives. One of the things that I value about a language is like, I appreciate a small set of simple primitives as like the basis for the language. Elm's logo is a tangram, which is like a small set of like shapes that you can make a surprisingly many things from Richard Feldman: Brock's logo is an origami bird. For the same reason, because it's this idea that you have this. Like small set of simple primitives, you have a piece of paper, and some like folds that you do on it. Also, like, you know, folds are a thing in functional programming. But like, I appreciate that. And this is definitely adding some more primitives to the language. But I think it's important that a these primitives are pretty simple and easy to learn, like famously. So. It's not like Var is like a famous stumbling point for people or for for that matter, the exclamation point, like thin air versus thick arrow. I think all of those are like Richard Feldman: pretty straightforward, and I think overall this is going to make the learning curve for the language less so, even though it is adding more language primitives, I think, overall it'll make the language feel easier to get into than it is today. So overall, I just think the benefits seem to outweigh those costs. But I am acknowledging like this is definitely a cost in my mind. Like all else being equal, I prefer a language, a smaller set of simple primitives. But this is a case where it seems like the benefits are so big that it outweighs that value, that I also have. Richard Feldman: Okay, so talked about a lot of stuff. Let me just summarize it real quick. So here's the purity inference plan again. This is like the plan. But we have not yet shipped it, so you cannot try it out yet. Sorry about that. Pure functions have thin error on their types. Effectful functions have thicker on their types, and they have names ending in exclamation. Point. The compiler enforces that with a warning. Richard Feldman: If anything is mislabeled as pure, effectful, and its implementation isn't, then it will give you a warning about that. And that's whether or not you have the type annotation or not. It's all done with type inference. So it knows whether it's pure or effectful, even if you didn't label it as such. Richard Feldman: Again, Var also not yet shipped. The idea is that just like today, constants are defined just using X equals. There's nothing changes about that. Variables are defined using Var and also by conventions. They're named and underscore. That's also enforced by a compiler. Warning variables can be reassigned which constants cannot. But all values are still immutable. So if you pass a value into a function, and then you reference it. Later on the function will not mutate. It will be completely unobservable. You don't have to worry about things changing out from under you Richard Feldman: loops and early exits while loops work on booleans for loops work on iterators. I'm not going to talk about iterators. That's kind of out of scope for this. That's something that doesn't exist today. But we have a design proposal for how those can work. I didn't mention these explicitly. But just a note, we're also going to add return which doesn't work the way it works in Haskell. It works the way it does in imperative languages, which is to say, exit the current function early, including if you're in the middle of a loop. Richard Feldman: I can see an argument for adding like, break and continue. I don't think that's like a critical, you know. Oh, we must do it, or we must not do it, for this proposal, so Richard Feldman: kind of like not really planning to ship it or not yet, but like it seems like not that controversial to do it. But we'll, we'll talk about it like we do. Talk about everything. Before considering whether to add something like that. Richard Feldman: okay. So basically, I mean, I guess if I could summarize everything that we talked about. It's like rock, you know, fast, friendly, functional language. Really, the only thing that's changing is that instead of it being a purely functional language, it's going to become a purity. Inference, language. Richard Feldman: that is the functional purity. Inference Plan. Richard Feldman: Thanks very much. Rubinson, Claude: Thank you so much. This was this was so so interesting. Rubinson, Claude: So already a number of questions in the chat. Rubinson, Claude: I guess I'll just ask Rubinson, Claude: Just lost our lights here. That's okay. If anyone has like a question that they're just dying to ask, just unmute yourself and ask, or if there's someone here at Pros who has a question that they're dying to ask, and and then we can go through the chat. River Dillon: I have one question, can bars be captured in the environment in a function closure? You said that. Bars, if you, if you pass them to another function. They're sort of passed by value. So does that mean that they're also captured by value? Richard Feldman: Great question. So Richard Feldman: the like implementation work on Var hasn't even started yet. I'm I'm of 2 minds, and we haven't decided. Obviously have to decide before we implement it one way or the other. The critical thing to me is that Richard Feldman: it's so. You write a lambda. It captures the Var. That lambda is not allowed to change the Var 100. There's no chance. That's we're going to ship, that Richard Feldman: there are 2 possible ways we could enforce that one is, we could just give you an error and say, like, Hey, you're not allowed to capture bars. So if you want to do that, you need to like Richard Feldman: name, a constant equal to that, and then you can capture the constant. And now it's extremely clear, like, oh, okay, this is a constant. I know that I'm capturing a constant whatever Richard Feldman: that could turn out to be annoying, in which case we could say, like, Okay, as a convenience for you. We will just like whatever the value of that. Var was right when you made the lambda. That's what you're going to have captured that immutable, you know sort of snapshot of it, but I could see an argument for that being like, although it's more convenient. Maybe it's more confusing, too. That's why I'm a little bit unsure about it. If I had to guess, I would guess that we would start with the error one, just because it's strictly easier to implement. And then, you know, just like, Hey, you can't do this. And then like, if people complain about it, then we're like, okay. Richard Feldman: let's let's consider like doing the less explicit, but also less annoying thing. I don't know if it's going to come up that often, though, to be honest. Well, that's like another thing I'm not sure of. But either way, the critical thing to me is that like, we don't allow mutating it inside, because that seems like Richard Feldman: yeah, that that opens a a door that has a lot of implications that Richard Feldman: I don't want to get into, at least not right now, like maybe some. Maybe someone could convince me. That's like a good idea, someday. But at least for right now I I don't think it's a good idea. River Dillon: And I guess if you're if you're not mutating River Dillon: inside the the lambdas, that also means that this doesn't mess with the stack allocation of the closures that you have. Richard Feldman: Right. Yeah. That doesn't. I don't think get changed at all. Richard Feldman: cool. River Dillon: That sounds great. Richard Feldman: Other questions. Rubinson, Claude: Go ahead! Go ahead! Raul Chouza: Oh, I do have a a question, but it's a little bit outside of the presentation, I guess. I do understand that rock has this property called platforms, where basically, I can attach a platform that maybe like a web server, or that may be a game engine, or that maybe, like Raul Chouza: a driver I can access to. Raul Chouza: But I I wanted to understand if those platforms are necessarily tied to some kind of, or like an interface to like a library or a system outside of rock? Or is it just rock by itself? Richard Feldman: It's the 1st thing. So I yeah, I I Richard Feldman: didn't want to make this talk any longer than it was. So I kind of intentionally excluded a lot of rock features, but very briefly. So the idea behind platforms is that Richard Feldman: you build your rock application. That application is always built on one particular platform you have to pick which platform you want, and the platform has 2 pieces. One piece is the rock Api. So that's what. As an application author, that's what you deal with. And the other part is what we call the host, which is the low level implementation. Richard Feldman: So rock platforms always have a host that's implemented in, not rock, and that's critical. So the lower level thing is like the the current. Most popular. 2 that people use are rust and zig but you could do it in like whatever language you want, and we've had proof of concepts, and like Swift, like any language that basically like has like a cffi, because that's like what the application compiles down to is something that's compatible with the cabi Richard Feldman: basically like you, you can use it for that. So I think you may have actually had. I remember you mentioned earlier that you work at airline solutions. And you you you like gleam and and elixir and so I think we have in the repo. There might be a proof of concept of somebody like calling rock code on the beam. Which? Richard Feldman: Yeah, because right? Because you have, you have cffi, so basically you can use that as a platform and just expose some like beam primitives to like call rock code from a beam. If you want I don't really know enough about the beam to know, like how like what the trade-offs are like, if that's a like thing that is like awesome or not but of course, like gleam is like already, a 1st class, like functional language on the beam. So it's like, Do you need another one? But at 1st class typed functional language on the beam, and it looks just becoming one. So Richard Feldman: But anyway, yeah, that's hopefully, that answers the question. Raul Chouza: And just follow up question, is there a way to track that you're using a platform? Or it's just that like embedded in your environment. Richard Feldman: You can like. Which platform using. So so every rock application has to choose a platform. You can't. There's no such thing as like a rock. Raul Chouza: Oh, you cannot like, combine different platforms together. Richard Feldman: Right? That's a really common Richard Feldman: question. But yeah, I mean, without going into the like rabbit hole of explaining why, that is yeah, it's always exactly one platform, no more, no fewer. Raul Chouza: Okay, got it. Thank you. Richard Feldman: Sure. Richard Feldman: I see some questions in the chat that are marked like sort of for later. Let's see Richard Feldman: if not mentioned. At the end, if exclamation point. Oh, okay. So we did. We did talk about that. Richard Feldman: let's see effectful functions aren't actually required to produce side effects. Yeah, they are. So. So if you, if you want to have a function that does side effects, it has to be marked as effectful, and there's like literally no way that you can Richard Feldman: do that without the compiler yelling at you. I guess Richard Feldman: I shouldn't say that like. Rubinson, Claude: My question was actually the opposite like, can you mark it as effectful? But it doesn't actually have an effect. Richard Feldman: I see. So the current plan is to is to give you a compiler warning if you if you Richard Feldman: do that, Richard Feldman: I, basically because, like, I would hope that, like, you would just like want to know if you're like, Oh, this used to be effectful. And I got rid of the last effect, and it's like Richard Feldman: I would want the compiler to tell me like, Oh, I can make this a pure function now and then, like. So in the future, without again going on a huge tangent. There are a number of compiler optimizations that we want to do, that only work for pure functions, or are only safe to do for pure functions, and so like Richard Feldman: being able to have the compiler know that something is pure or not like, becomes a pretty significant like. Richard Feldman: you know, benefit hopefully it will. if it if it actually is pure. So yeah, I guess there's a world where we could say like. Richard Feldman: Hey, it can know that it's pure. Even if you annotate, it is effectful because it could look at the implementation and like. Figure that out and ignore your annotation. But I don't know if we'd want to like do that. The type system complexity required to have it have, like Richard Feldman: the real version and the like. The version that you said it was like, I don't know but anyway, the plan is to be like, Yeah, let's just like give you a warning if it's if it's inaccurate. Rubinson, Claude: No, that makes sense. Richard Feldman: Okay, let's see Richard Feldman: question for you. Do you have an intuition, for when Fp. Versus imperative styles are more appropriate, that's a great question. So certainly I would say that if you have a problem where Richard Feldman: there's a lot of unavoidable like state changes in a loop, especially. That's the case where like, whenever I insist on doing things in a pure functional style, I'm just sort of like, I don't love how this code turned out. I kind of wish I had a for loop. Richard Feldman: That's the category of things where I've found myself being like. I really wish Rock had loops, and now it will. But like, I mean, basically, I guess it's like when I find myself either reaching for recursion and being like, okay, I have to be really careful to make this tail recursive so that it compiles to a loop. Richard Feldman: It's like I'd just rather have a loop like in general, whenever I'm finding myself like being really careful about tail tail call optimization making sure that it it triggers. Now, like, yeah, this, this code would be nicer. That's maybe my biggest heuristic for that, but again, like not something that comes up often, but but does occasionally come up. Rubinson, Claude: So so- so let me follow up on that. Then Rubinson, Claude: it it sounds like for you. It's more in writing the code Rubinson, Claude: rather than sort of thinking of a problem. Richard Feldman: Well, it's more about honestly, it's more about reading the code. I think. Like when I read other people's like recursive functions like whether it's like writing it myself, or or reading other people's like Richard Feldman: I I often find myself like mentally translating into like, so what's like in like loop terms like, what's this actually doing? And that helps me like, understand it better. Richard Feldman: And anytime I have that like as a heuristic of like, okay, I need to like. In order to understand this, I have to mentally de-sugar it. That's always a red flag for me that like maybe this isn't the right way to write this code. And another example of this is, Richard Feldman: a controversial functional programming opinion that I have is that, like the point, freestyle is like kind of a mistake, just like in general, I started off being like, Oh, this is awesome. And then I was like, Well, okay, maybe I went overboard. Maybe I should only try to do this sometimes, and now I've gone all the way to the other side of like just never do it. And the reason that I kind of came to this conclusion was basically just realizing how much time I was spending Richard Feldman: looking at this thing and being like. Richard Feldman: I'm sure there's a smarter better haskeler out there who looks at this and knows immediately what it does. But for me, I just need to. I just kind of need to de-sugar this, either in my head or even like write it out to understand what it's actually doing. And then eventually, like, I got better and better at this. And I was like. Richard Feldman: I still need to de-sugar this manually. What? Why am I doing this to myself? Just just write the desugared version. In the 1st place, who is this better for? I don't. I'm not actually I mean I'll take them at their word that they exist. People who look at the like really ultra compact, like, you know, function composition on the fly version like, I get it immediately. And this is amazing. But I don't know. It's not for me. I just think it's like it's like a waste of time. Richard Feldman: And similarly, like, yeah, sometimes I think like the the Loop version is best, but but but not all that often. It's it's really pretty rare that it comes up. So that's why I want to have support for it, but not have it be like Richard Feldman: the the thing that's most natural and ergonomic to reach for hence the like underscore, and things like that. Rubinson, Claude: I think it's interesting not to belabor this too much, but often and certainly, sir, in Fp circles Rubinson, Claude: there are these of like, Oh, use the right paradigm for the problem at hand. And I guess that's why I'm asking. This question is. Rubinson, Claude: this is super interesting to me, that it's what it sounds like, is, it's when reading the code that you're like, oh, this is the wrong paradigm for this problem. It's not like, Oh, I've got this problem. I know the right paradigm, that's what I've always, and it's always made me feel kind of stupid that I could be like. Well, should I do that imperative? Or should I do that in Fp. Richard Feldman: Yeah. Rubinson, Claude: This makes a lot more sense what you're saying to me. Richard Feldman: And I think it also that can happen at different levels of granularity. So, for example, I can have a code base from like overall. I want this whole code base to be in like a functional language, because that's the main style I'm going to use, like almost all the time. But I think I will appreciate having access to the imperative style occasionally, but also the reverse has been true, like, I think if I'm writing a super performance. Critical application, like Richard Feldman: Fp does a lot of tricks. And there's like doing a lot of stuff that's like, not exactly what the hardware wants to do in a lot of cases we do our best to like, you know, have rock, try to do what the hardware wants to do a lot of the time, but, like Richard Feldman: the main example I think of is like structive arrays versus array of structs. I don't know if you're familiar with that. There's like the data. Oriented design is sort of like the buzzword version of that. But like this is something that we're increasingly doing in the rock compiler. And I just don't think it's like that innately compatible with a functional style unless we tried to like make it an optimization that happens behind the scenes. But, like man, there's so many things that we're doing in the rock compiler which is written in rust that are just like Richard Feldman: very imperative in a lot of case like memory unsafe, which is also not something. I want my functional language. But it's okay. Because for that use use case, I'm like, it's fine. We can. We can do a very imperative style of compiler for a functional language, because I super care about the performance of that compiler much more than I care about doing it in the style that you know. That I like to use for like application development of like web apps and stuff. Richard Feldman: But so yeah, I think I think it can happen at like a small granularity of like individual functions, or even parts of individual functions, and also at the entire like language level. I don't think there's like a yeah. I don't have like a grand, unifying theory of like when to use one or the other, though Richard Feldman: cool. Rubinson, Claude: Thanks. You want to go through the chat, or you want me to try to find. Richard Feldman: Yeah, let me look at some more. Into the chat, see? Yeah. There was a question from Michelle. Rubinson, Claude: Very quickly. Let's go through the chat. And then our tradition in in this group is that then we stop the recording, and then we can have additional conversation that will not show up on the recording. If if you really wanna push Richard on something. Richard Feldman: Sure, sure, sure. Rubinson, Claude: Even, for after we stop the recording. Richard Feldman: Yes. So Michelle's question was, when you describe trying variations of the code with beginners, does beginners mean people who are already comfortable with programming or people new to programming. I mean, already comfortable with programming. So Richard Feldman: I I don't really have any firsthand experience like teaching people to. Okay, I've taught, like 2 people to code ever. I don't consider myself knowledgeable enough about what people who are new to programming, like want and value to like, really know how to optimize for that use case. And honestly, I'm not sure if like, if rock is like Richard Feldman: is or isn't a great language, for, like people who are new to programming. It's not really something that I'm like aiming for. But like. Richard Feldman: if I could have some confidence that, like, there are some things we could do for that I would consider it. An example of this is I looked at the Richard Feldman: quorum programming language which is actually designed for, like people who are brand new to programming. And like does a lot of like, they have the rule that you're not allowed to make a change to the language unless you've done a published peer reviewed study demonstrating that it's more effective for like beginners or something like that, it's really interesting. So they found things like rather than like, you know, a print. For like printing out to the screen, it's like the terms like output. And input apparently are like beginners like, pick up on more quickly and easily. Richard Feldman: But again, like, that's not really like what I'm necessarily trying to optimize for. So yeah, I'm like aware of that. But that's not really. Yeah. The the goal is like people who are already familiar with some programming language. Richard Feldman: let's see, as team user for a while anyone found any annoying foot gun issues with the design yet and is pending a solution? Or is the happy final design. I mean, there's trade offs all over the place like. We we talked about a lot of different variations of this. Richard Feldman: This is the current thing that we're like. Yeah, this seems like the way to go. The thing that we actually spent the most time about and had the most unsureness uncertainty about is something that I didn't actually put in the presentation, which actually has more to do with like Richard Feldman: error handling, and like early returns of that so we settled on an operator called Try, or like a keyword called Try, which basically means like. Richard Feldman: take this result like, I give it the result type. But basically it's like, if it's an error, then, like early return the error. It's like syntax sugar for that. And if it's not an error, then just like, unwrap the okay. So Zig has something that's a keyword called Try that works almost exactly the same way. That's like the one thing that we're sort of like this seems like the best option. But we talked about a lot of alternatives, and that's kind of the one that won out, but like, not by a wide margin. But yeah. Richard Feldman: Claude asked about like to hear more about user testing these different approaches. Yeah, I mean, it's really just kind of like. We talked about it a lot in Zolip, and, like, you know, we went through like I wrote several design documents like went through several iterations of those design documents. And just the whole process was really just sort of like, let's look at like made up code samples like, what does it look like between this style versus that style? And at the end of the day, like, you know. Richard Feldman: we're not gonna like, go out and be like, let's use your test this on people. We're just gonna try it. Because this is a pre. It's not only pre 1 point. Oh, language. It's a pre 0 1 language. We actually don't formally have a version number yet for rock. It's all nightly builds and part of the reason for that. And, in fact, the main reason for that is just to set the expectation of like, hey, we're changing stuff. So like, you know. Please don't. Don't you know. Be surprised if things change. This is Richard Feldman: the biggest change I think we've ever made to the language, even though weirdly. If you look at a lot of the code today, it's actually not gonna look that different. Because we currently have the exclamation point operator. That's just gonna become no longer semantic. And and instead of naming convention, Richard Feldman: But yeah, I mean, certainly, like. Richard Feldman: I I don't have any like I I can't point to data that says like this is better. It's really just about like we talked about it a lot. And we're this, seems like it's gonna be a pretty awesome change. Richard Feldman: okay. Error message. Yes, that's August. By the way, who in the chat? Who implemented the the purity inference? Richard Feldman: also Luke is here. Luke is also awesome, and has done a bunch of stuff. Not directly related to this necessarily, but luke is like one of the most active and awesome contributors to rock. So thanks to Luke, Richard Feldman: yeah. Yeah. Why? Convention? Because, yeah, it's like, it's the compilers. It's just a warning like the compiler is not gonna block you. Richard Feldman: yeah. So it's like warning being like on the same level as like, you know, unused variables like, it's it's gonna be like, okay, you know. You can keep going. Richard Feldman: cool. Oh, yeah. Yeah. There's a question about like, do warnings block it. Getting to production. Yes. So if there are any compiler warnings, the compiler will still work and do its job. But it will exit with a non-zero exit codes. The idea is that like warnings automatically fail. Ci like, if you have, like a Ci server that builds it. But they again won't block your development if you're in the middle of working on something. Richard Feldman: Cool. Okay. I think that's all the questions. Rubinson, Claude: Yeah, I think that's everything in the chat. So I just want to. The last chat message. I just want to read out loud because it definitely echoes what I'm feeling. I love the strategy of language copying the imperative language playbook of implementing imperative features. Yeah, it's super. Yeah. This is this is so great. So I want to thank you. We're going to turn off the recording, and then we can continue our discussion for a little bit longer. Rubinson, Claude: But thank you so much, Richard, this is this is brilliant. Thank you. Richard Feldman: Thank you. Glad you enjoyed it. Rubinson, Claude: Now I just have to find Rubinson, Claude: how to turn off Rubinson, Claude: the recording Rubinson, Claude: upper right. Rubinson, Claude: Right? Rubinson, Claude: No, here.