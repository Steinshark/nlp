Hello guys, this is an Raghav. And in this video, I'm going to The size of your Docker images. I'm going to show you how I Just 7 MB. Which is like a 98% reduction. And in some cases, not only do these They also reduce your image So let's get started. The first and the most popular Multi stage builds is a feature of don't need to include everything In fact, your final Docker image should necessary to run your application. So the basic idea behind multi stage FROM statements in your Docker file. And and with each FROM statement, and each of them is a new stage in In this new stage, you can selectively and leave everything else behind. The last stage in your multi stage that gets created, it, the final so the trick is in the last stage of your image and only include the artifacts that So in a traditional build, in a will do is you will use a base image. You will have a bunch of dependencies or to create a final application, right? You will use these dependencies and You'll also copy your source And then out of using all these things, But then this becomes your final your final artifact, but it'll also the way, you no longer need, right? So the total size of this to be something in GBs, right? Multi stage says that, sure, you in a previous stage, and then And inside the stage, all you got So, something like Alpine, and then only, Then this is the last stage stage will create the final docker image. And this image will be something you know, in order of tens of MBs. So that's where the difference comes. So. In this Docker file, I'm building an image And then run the final So when I started the We've got nothing. That's doing. docker build. Okay. The build is finished. And this image is 1 GB. Let's test it out once. Cool. It works. The container works, the But if I create my image with image, which I'll be deploying running on my local everywhere. Right? My final image. We'll not only contain the But also all the Go Plus the Golang image, the base image. And it's underlying operating And the problem is this I don't need these things So let's use multistage to get So let's consider this whole thing The build process first stage. So I'm going to call the stage as. You can use an AS with the, FROM And you'll see why the naming is useful. Now we are seeing that We will do all the heavy lifting In this case, the final artifact The executable that we need to run. But we do all this. Building In the build stage. But notice that once the go build produced the final app executable. After that point. The only thing we truly need in is the executable application. All the other stuff is not needed. So let's create a new And now let's take only the stage into the final stage. So, this is where I use I tell Docker. The copy the app created And paste it into the final images /app. And now since this is the last This is therefore by definition, So whatever is written. After this is the final image. But another important thing. My final image contains a standalone So I don't even need a Golang base image provides me stuff like Golang, but I don't need those things anymore. So let's move to a much. lighter. base image. Let's do Alpine Linux. Good. Now we're ready to build the image. Our final stage. Contains a very lightweight base image and Let's remove everything. Cool. Nothing. Once again, we build. And we'll give it a different label. docker build multi. That's cool. Okay. The build is finished. The final goserver image this time one was 1 GB this is just 16 MB If I try to run it, the application still that it needs, inside the container I make sure that my executable everything else can be excluded Another as the base image of my final stage the base image of your final stage is google's distroless images Awesome. That was multistage. The second important technique fewer layers in your image. Every statement that you Create a new layer in your image. And each layer adds to the image In this Docker file, I installed lots of But for each APT command. I use a different RUN statement. First let's build the image. And also let's time it. I'm gonna track the. Time taken to build the whole image. Okay. So the image took around Um, is 266 M B i size. No. Let's reduce the number of layers I'm into single run statement and run all Okay. JQ. I have everything. It's sort of these. And that's it. single layer. RUN.. And install all the dependencies. Let's clean up. And build again. Okay. So in. This case we managed to reduce the Because we got rid of Of course. This is not a lot compared to what but in bigger and more complex difference of about 50 MB as well. But this is a low-hanging fruit, fewer layers in your Docker file. So use fewer RUN statements Okay. So that was about layers. The third technique for size reduction. It's to create Docker images from scratch. This is the single most powerful, way to create a Docker image. Creating an image from scratch means No underlying operating system. No dependencies. No preexisting data or applications. Think of it like an empty storage disc, Because there is nothing in it. Uh, scratch image by itself I think even less than one MB. And that one MB is just So, whatever you put in it is But this does mean that if you applications or tools, you will need to So scratch images are very One. When you're creating your You created your own You don't want to put this like ubuntu or something. You can use a scratch image Linux distribution on top of it. Number two, when you have a standalone compiled your Golang application or C++ it compiles into final executable, right? Just put this executable If the app has any dependencies, runtime library or other utilities. You need to add those too. In this example, I'm using scratch image. As the base image for the final This is by the way, the same But the only difference is instead based image, I'm just using scratch. So that's been it. prune again. Remove everything. Server. Sorry. So. Scratch. This before running. I just want to check. There is nothing on my system. Nope. Okay. Then let's build. This image is even smaller than the example That one was about 16 MB. With scratch, this one is down to most of it is just the size of HTTP server still works Now the want to gain shell access inside this this container is literally baked on application it doesn't have a shell possibility of having a shell inside bash on it and any dependencies that works Its a clean slate image which No. Apart from these three techniques, can do, which will make a huge impact. On your docker image size. Don't keep any of your Image this will directly instead, connect a container. To an external storage volume and still accessible by the application, Alternatively your application data store like MySQL or AWS S3 Also if you aren't already doing so. Make use of the . dockerignore file. Docker ignore concept is It lets you exclude specific files For example, you could add node Image compression tools like dive and They will let you analyze your image, dead weight and what you could remove. And lastly, if you're feeling containers completely and explore. Unikernels. Unikernels. are much smaller images, which come packed operating system designed to run directly. On a hypervisor. I've personally not tried them yet, but 80% smaller than you typical docker images work with I hope you learnt something did, do not forget to share it with your how to solve practical DevOps problems like to learn with me drop a comment