So I know for a lot the idea of a database synchronized updated values is like weird and strange. Like when a lot of developers with a Firebase Realtime Database, when you could just make and kind of skip that whole realtime thing. Turns out though that was hard to do There was a solution, and we generally Luckily, with Cloud Firestore, from the ground up and queries are a lot easier. They're more like first-class citizens and you can go ahead Now that we've gone through the trouble of making the one-time I'm here to tell you, (rock music) So the nearly realtime of Cloud Firestore, from the Cloud is pretty awesome. I would generally encourage anybody to look at adding this kind But when I've talked to developers, to go down this realtime route One, realtiminess is weird and strange to organize my app And two, general concerns So let's see if we can address I think the best way is to give you an overview and then go over how you might Now when you ask to listen or a bunch of documents that sets a number of things in motion. On the client, This is essentially a callback when there's new data And over on the Cloud, on the database itself to see if there's any new data available. Now the first time you ask you're going to get back I mean it's basically all new data So if you ask for one specific document, of that document. If you ask for the top 20 you're going to get back But from that point on, when there's a change whether that's a change a restaurant gets added or removed or they change their order in that query. Now usually for the sake of protecting your users' data plan and battery, only the documents So if Ray's Ramen suddenly changes what I'll get back under the hood one document representing But over on the client, will combine this updated document and in the listener, with the entire set of 20 documents. And I know that might why is it sending me but this is usually what you want If you think about it, to read in and display because that's what happens So when we get back a full set I can probably reuse this code and not have to worry depending on whether By the way, I think this is one reason about pricing at first. They see this list again and again in their listener is charging them for 20 reads but that's not the case. Yes, you get back all 20 documents but you're usually only getting charged for the one document that is changed. Now if you really do care to know in your callback listener, Every snapshot contains which will give you a list that's been added, removed, I think most often if they want to provide a visual cue For instance, we could have if we know that it's been deleted when we know that it's been added. Or maybe you're performing on your data. In that case, to only do this on the documents It's kind of up to you. I know we talked about this but remember those writes are essentially on your local copy of the data. Now when that happens, are also notified. Those listeners are fired off as your snapshot, so then you can act This is all happening to the database in the Cloud So, several milliseconds later with the updated data, that this updated data matches and by default, it will quietly ignore So what does this all mean that behaves nicely First, your listener where you primarily read in and do stuff with it. It will be the place where you convert into custom local objects. You'll probably populate and then you can tell your table view to refresh themselves But then whenever you're looking you're going to want to make to the database documents themselves. That's right. You don't want You want to make the change Now that will kick off and your listener can once again based on the data you're getting back Now most cases, that you'll just kind of blow away and reconstruct it from scratch But you can always get fancier if you want by looking at just the objects But I think the main takeaway here as the source of truth any kind of write operations Now let's talk performance, both when it comes to data usage because I think some developers assume is as much of a battery killer and that is not the case. So yes, anytime there is a listener present, an open socket connection to the database and while that has a greater it's probably not going That's going to be much more influenced by the amount of actual data or having the screen on So don't think that if you shut down and have your app perform a bunch you're going to save any battery. In fact, if you keep turning your radio there's a good chance it might even For that matter, having isn't by itself going to be What is going to be a bigger drain and their data plan To oversimplify things a little bit, the more it'll hit your user's battery. So what does that mean for you? Well, if you're concerned and you should be, First don't download more data I know you can put a lot of data but if you find that you end up that you almost never use, into a sub collection those extra documents when necessary. Second, make sure you deactivate Generally speaking, in your <i>ViewController</i> you want to remove it Meaning that if you create a listener in your viewWillAppear handler on iOS, deactivate it in your viewWillDisappear. If you create a listener deactivate it in your onStop which will automatically unregister it. In a PWA, if you're adding a listener make sure you deactivate it And yes this does mean to a screen it might take a moment because that listener hasn't But it also means that several times in the back end while your user is their device won't be going all that intermediate data and you won't get billed for those reads. So when would you want versus a single fetch? Well, I'll be honest. I'd say that, in general, realtime should probably For starters, using realtime data makes your app of spotty network coverage by default. Remember the nice thing is that they're designed So we can do things then give you updated data when the network actually follows through. Fetches don't work that way. These one-time fetch callbacks are designed to only be called once, so you only have one chance which means if your network is slow, we have to wait those three seconds or wait several more seconds before we can serve the cache data, and, you know, There are ways You can manually run two one-time fetches-- one that's explicitly set to fetch and then another that's explicitly set but, again, this is work if you just used a realtime listener. Plus, having realtime listeners means that when your client makes changes you don't have to add that extra step of manually refetching the data Again, it will happen automagically with sort of this changed cache data. And, of course, which can be a pretty magical experience. If you're powering a turn-based game to have that data update right away when the other player makes their move. If you didn't have this happen, to pull to refresh a bunch of times or send a Cloud data message to tell it to perform an update, and if you're doing all that work anyway, why not just simplify things So maybe the better question is would it make sense to not go realtime And I think the answer's probably and more of a user experience one. Are there situations in your app where it would be, say, distracting Think about my restaurant review app. Would it be weird if new reviews while my user was perusing It might. Of course, on the other hand it might not. Honestly, this is something on a case-by-case basis. Also we talked about this but sometimes pagination if you're trying to combine for one of those infinite In these cases, it might sometimes be Finally, there will probably be situations where data is changing more often than your user will care about it. Think about a popular news site that are constantly getting upvoted Hey look at that! Oh, and it's gone negative. I'm sorry. Now admittedly, to see those votes change in realtime and maybe see them switch places, but that constant stream of data in terms of battery and data usage that, while kind of neat, So in these situations, a one-time fetch Finally, when it comes to things you're generally looking at calls and then terminate. So there's not much of a point in setting up my realtime listeners there. Same goes for probably 90 percent involving the server SDKs. But remember the main takeaway here is that you should start as your default behavior, then only switch to a one-time fetch call when you have a good reason rather than vice versa. So there you have it. Hopefully, now this world isn't quite so weird and strange and you can start adding more Thanks so much for watching, on another episode (music)