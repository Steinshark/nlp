Franziska Hinkelmann - JavaScript engines FRANZISKA: Good morning, are you pumped about are going to do now. I'm Franziska Hinkelmann V8 is being developed in Germany for the most work focuses a lot on performance optimisations you about JavaScript engines now. Engines: if you have any JavaScript source code and it for you. It doesn't matter if you run it device, to go from something you write to doing. JavaScript engines are the heart of have been evolved a lot in the last 22 years. enterprise node.js service and there is a I hope in the next 20 minutes to give you engines, what is making your code run so fast? and I just want to point out when I talk about performance, like computing and running actual other things that are super important for latency. When I say performance, I mean computing JavaScript engines, all the major browsers really good there are several engines because really means better performance and better just to drop a few names, up there, JavaScript Spidermonkey is in Firefox by Mozilla and you need an engine. By default, node.js comes node.js and there you get node.js with a Microsoft using Spidermonkey. Again, if you're working might want to trade in performance for memory fast, they take up a lot of memory. On IoT slower but they fit, like Duktape or Jerryscript. They discuss additions and changes to the then we engine implementers implement those cool before we have a TC39 panel here this to answer your questions, and they still take for the panel this afternoon. If you want what is the take on a few changes, like that. implement that. And the engine is the thing and then to run your JavaScript. What is a the awesome community and JSConf? One thing write JavaScript code, and you have variables, don't have to worry about what that x actually have to distinguish upfront if you have a ever written C++, the rules are really, really read up a lot about integers just to get your write C++ and want to define a variable that you want to specify. In this case, I'm specifying positive or negative. They can only be - within big, it doesn't fit into an integer any more. any of that. That makes it really simple for makes it easy to get started, it makes it usually faster, so that's a really cool thing is dynamically typed, so a language like C++ statically typed. It is not only about the figure out where they are and say not not When you have any objects in JavaScript, you as you need, you don't have to make that clear x and y but if needed, it can delete a property, the properties on the prototype change which makes it easy to work with objects, and sometimes, what exactly your object is like. If you get an object, sometimes, you don't know actually that's super useful. It makes it a little this is not good, because you give so little have a hard time generating machine code which why the point in C++ you specify all that upfront so it can compile your code into an make it hard for developers because that allows compile C++. But know know JavaScript is pretty frameworks, we run all these JavaScript tools fast, even though it is dynamically typed, objects and types. And the trick that all just In Time compilation, abbreviated as JIT that means is we're not first compiling ahead the code, we are mixing these two steps together code to recompiling the code. So we are compiling we collect some information when we run it, you think about C++ again which is compiled first compile it, you get an executable, and that is one step. If you start a node - note all together because compilation and execution going back and forth to speed up the execution. one compiler, they have at least two compilers The main concept I want you to take away here recompiling hot functions, so a function that up is considered hot, that is recompiled by the code, we run it a few times, we collect &quot;Oh, this function is not, let's make it faster at so far.&quot; So when we're recompiling, when that we will see similar types as before, machine code. Now since JavaScript does dynamically type, and you can change the kind of inputs that, at some point, you run this optimised then you have to de-optimise, you can use back to the baseline compiler. So, compile, conditions, run the optimised code, if the Now, so you start with JavaScript source code, tree. I will not talk about the parser because JavaScript and how you can write it to make by the parser and then we generate an abstract abstract syntax stream to make the machine it on to the optimising compiler to generate we have to bail out de-optimised, do an OSI code. In the V8 engine, the baseline compiler optimising compiler is called TurboFan. If it is about the compiler pipeline in V8! It make Chrome and node fast. In Spidermonkey there are a few more around where Safari, two, so a low-level interpreter and a DFG has an optimising compiler. The optimising If you change your objects all the time, then if you've generated, you have to de-optimise performance hit. From the high-level concept, example. I'm going to show you the optimised I'm using a very simple example. It is a load it does is is it returns object at x. The axis in JavaScript is fairly complicated for that a compiler doesn't know anything about this x? Does this object have an x? Is it properties stored for the object? Where in this does quite a lot of work to do something I have to explain before we get started is represent object types incrementally by transitioning have an empty object literal, it is represented with a property x, then we transition from a literal with an x property. And then if to more types of objects, so that's an internal a class or anything in JavaScript, you can we keep track of a type of objects. And because a difference if your object has x defined two objects have the same properties, they're I'm running the load function a few times, here. They look similar, but it is not the different. But all these objects have the to this kind of object. So, if I'm running says, &quot;Hey, this is a hot function, let's optimised to. So this is assembly code. But So, at the top, I left out a little bit of - set up the stack when we enter the function. corresponds to the type of the object that this address represents an object that has was generated after we have run the function and now when we run this function again in load this type, and then we do a comparison. the same type as what we saved before. We like the things we've seen in the past? If where we just - where we now are getting the object plus 17, which means take a memory position, it is the x value. So this short can just take that from memory and be done have to look in the prototype chain or see say if this kind of object comes, then the the optimised code with an object that looks comparison of the object types is going to and 5a is a de-optimisation bail-out. On that point from where we go from the fast optimised we don't have optimised code to handle the because if we say, &quot;For any kind of objects, would be wrong. When you write JavaScript like this, that looks different depending what is happening at the very basis when you're with objects that have a different type - like so we don't consider them the same type, one instead - to optimise the machine code looks of one type, we have four types now, one that before. So we do four comparisons, if we match put in, we say short cut, take the value of none of them matches, then we jump, and, again, on the input values that we've observed, the first one had one comparison, this had four you're just adding comparisons for every single because then you have these if compares, if blow up memory. What we do is, if you have to all the types any more, this address here one just points to string x because we wanted which is now looking up property x in a big machine code, it looks short, but this is than just saying, &quot;Move this from memory over really low level of engine-level performance compilers or the JavaScript engines in general objects. So, if your objects represent the in not making your code terribly unreadable, So, for example, in this case, this is exactly except that I'm always adding b, c. D, as compiler, this is considered one object type, there is exactly one type of object that corresponds and then there is one comparison saying is the general idea. Store information or collect we get the exact same type of inputs - like the resulting code is really fast as long this speed-up for an ES6 feature. In ES6, with computer property names. In ES5 when to create the object and then you could set you want o of x, you have to create the literal. use the brackets inside the object notation. side is a lot slower than the ES5 equivalent. the yellow and green thing. This one was red counterpart. But we applied the same principle. is a symbol, and every function runs is the here. We run the code a few times, we memorise if it is the same symbol we've seen all the creating instead of to make the these expensive every time. So by applying these optimisation on that benchmark, and the yellow-green benchmark can use this ES6 feature without having to if that is really critical to you. So far, much into 25 minutes. I hope I was able to you want to dig deeper into that, of course own experiments and see what is going on. engines I mentioned are open source. You can But you can play around with it. You probably Chrome and palace in a few - if you pass in code that I have just shown you. So, because have to use JIT compilation to get any kind compilers under JIT work, your JavaScript the best thing you can do for the compilers. &gt;&gt; Thank you very much to Franziska for the in JavaScript - very interesting topic. I we don't know what is going on on the system compiled. We're going to start again in just if anyone is here what is curious going on about source maps. Graph QL has put fliers It is another conference that's going to be of this month. We will be starting in just