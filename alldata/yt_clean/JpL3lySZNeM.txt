- Hi, my name's Rion Carter, and today I'll be presenting on why my security camera The talking on signal analysis of an audio and coding protocol. A little bit about myself, I'm a software developer, I love to code, love to I like to employ the hacker mindset. Like to break things in to learn more about the system and hopefully drive an improvement that makes it better for everybody. I love food. Love cooking, love baking. Recipe hacking is a passion of mine, and when I can get a delicious result, that really makes my day. And then of course the standard All opinions are my own. Don't reflect positions or or any current or previous employers. So, let's get to it. Got a few different sections to cover. We're going to touch on what it is that we're actually doing here. The signal analysis piece, hacking the signal, and, if all goes well, we'll get to a demo. So, what are we doing here? And why are we talking about So, my original goal, to submit a Defcon talk was to use an inexpensive wireless And this is the inexpensive It's got an antenna This one's kind of interesting and a speaker, so you could if you wanted it. The nice thing about this So, and it seemed like This sounds fairly easy so what's the catch here? I discovered after purchasing the camera, unboxing it and examining a cloud application in order There's no way to self set up the camera. There's no ad hoc wireless network. It doesn't show up with There's, when you plug in the USB cable, there's no signals there whatsoever. Also, there's no documentation to any real technical depth. Not that I was expecting And then of course, what is the bespoke protocol that it uses to, well that the vendor and configure the wireless camera. So take a listen to this. This is what really peaked the path of trying to do (electronic noise) So that's the sound that to interface with the camera and configure it to connect to a wireless network. I have to say I was not expecting that. That's not usually how like security cameras. So, my new goal after a sound wave signal to was to find out what was and see if I can't hack and if possible, cast off the shackles of the proprietary cloud enabled app that the vendor supplies. So, let's investigate. First thing you want to And as I mentioned before, This connector though only supplies power. When I trace the leads, there's no activity on the data pins. Other investigative angles, of check for ad hoc wifi. And unfortunately, after many of different permutations of things, pressing the reset button, scanning with wireless Nothing was advertising. So that left me to in a little bit more detail. This is the vendor application It's called JAWA. And it's used to configure However, like I mentioned of having to use this proprietary JAWA requires an internet connection. It also requires a username with this cloud set up. So that made me a little frustrated, and incentivized me to Now, in order to analyze I needed a test device. I didn't want to run just being a security I don't really have a trust from from dubious sources, of a $30 cloud enabled camera. And as I searched online about the camera or the application, probably not too surprised to hear that there wasn't very many, I did uncover a few other to use the sound audio to configure the camera for Wi-Fi network. I don't have any of those though, and I just more list them There are some cheap cameras in my opinion, a far the camera to a wireless network. And that's having the app show a QR code that you then scan with the camera. I mean the camera has, well a camera, and scanning a QR code is a to do in 2021. So I doubt, or I should say, if any, more cameras out there, which leverage this audio coded approach. So, now that we've taken a and the software, let's a little bit more. See what we can identify and figure out. And along the way, let's think that we can think about or look for as we analyze the signal. Of course, the first thing is we'll want to capture and visualize the signal. We'll be looking for the variation in replay. And if possible, we'll the signal in a way with a valid coding. This is the raw view of the and visualized in the spectrographic view. Just taking a quick look at this. It's pretty clear that and there appears to be steps. This isn't a continuous wave There's individual tones, of time, that are transmitted and then other tones Taking a look, it seems are centering at least with a few outliers on the low and the high end as well. So that is something worth noting as we go about analyzing the signal. Now, let's see. One thing that I thought as I is this similar to a modem signal? It's been an awful long time and obviously modems encode their, transmit information So I did a quick comparison of 56K dial-up modem And just by looking at these wave forms, it's pretty apparent that The spectrographs are And this protocol, this audio to configure the camera that you can't find and it doesn't track with that you might think of like modem or fax. So, looking a little closer I marked out a few sections just really highlighting that are extraneous, or with what the rest of the signal offers. And on the left of this slide here, I put together, I guess what I'm calling a collapsed spectrograph view, where I basically took all of the tones and I slid them all over to my left, and just lined them up to see which tones and frequencies were represented. And you can see that it does There's a small gap above 4,000 Hertz. And then there appeared to be at the higher register range. Now, a picture is nice, maybe how the signal is structured. But a picture can only take us so far. We'd like to get more what is actually encoded in this signal, and kind of what the protocol into the signal. With a manual approach, such as Audacity or that are out there. With Audacity, though, you can use this functionality called labeling. You position the cursor over each one of those sections where there You press Control + B and to label that time slice, that's detected at that point in time. And so you can see just in the it might be a little smaller. A little hard to see, but on each one of these tones. This next view here is the the labels that you've taken. You can go to edit labels, edit labels, and you can export them to a text file, which you could run of automated analysis, or or what have you. Let's take a little closer look at this. And you can see that and a high frequency that it These frequencies are a little variable. So to me it looks like this for what each of the target tones are. I don't imagine the vendor application is really putting out 5,101.89 Hertz. It's probably something a bit more round. We'll figure out more in this process. What do we know now from doing We can see that there There's a digitized signal. But the signal isn't binary, it's not like it's just There's a range of So there's some type of The frequencies seem to to five kilohertz range. And my suspicion is that the signals that are outliers at the top of bottom are control signals, and that for investigating how the And we see that there's repetition. I noticed that in my analysis and the pairing tones that it produces. The complete sequence repeats at least three times. So, and then finally, we can see that this is not The spectral analysis just do not match. So at this point, we is there really much further And the answer there is yes, There's variability whenever I found that each time I played back, even the same signal from that Audacity would slightly vary, that the Audacity analysis of which frequencies it shows when you do the labeling process. And of course, manually of playing a signal from an application, recording it into an audio editor, and doing that over and over again. It's very time consuming. Since again, the app repeats So even after you get a you have to wait for the before you can kick off And, just to be clear, the only options we have to configure in this vendor application are for the wireless network. So there's not a whole lot of things that you can vary for the input. Then, one thing I noticed is that there's no readily apparent API to leverage the frequency There's no CLI option. There's no readily available API option. And while I could have dug deeper into the Audacity code how that's put together and hook into it, that really wasn't what That would be more of an on my main journey to reverse engineer and better understand this audio signal. So with manual mode, we can do black box signal reversing. We can try to brute force We can attempt to match generated tones with spectrographic views. And then of course, just until we find a match. This is a very tedious and a So I was looking for a better and what I know in order So really the next step of the Android application, since the Android the audio signals. And, let's take a closer look So. How do we go about analysis We could do things like executing in a sandbox or a test environment. We can decompile the package. We can look for strings, anything that might relate or SSIDs and passwords, We can do a key method a higher level language, or this APK is written to And even though vendors it's a lot harder to obfuscate the underlying library functions So you could do a search or Android libraries that provide methods that you might need and audio and coding. Once we figured out these code paths, we can attempt to do high speed fuzzing. And then of course, if that has been obfuscated, we can try to go and deobfuscate it and attribute the classes, some other identifiers, which And it helps us better to really figure out how this all works. Now, let's talk a little You'll need to prepare your of your test device. If you've done any of this, if you've worked with Android before, you're probably already And you need to make sure your that you've allowed USB debugging. Make sure that you have and that version of ADB is So that way you can leverage You'll want to extract And here I show a few if you want to follow along You'll want to make sure of each step and feed Since what I have here to a Blackberry priv, 'cause that I had lying around to do this analysis on. Once you have the APK, you can I leveraged jadx, you can pull the latest release, to decompile the code. Just a quick one liner. You will probably note that I found that the errors my analysis of the package. And I was not impeded in my journey. Once you have the decompiled sources, you'll want to open up a Open the decompiled sources from jadx, and then click a little button in the lower right-hand the Android framework. By configuring the Android framework, it enables you to do and go to definition. Just all the goodness that you'd expect from a modern IDE. Once it's loaded, you'll see a The one that I have which is clearly obfuscated. As you drill into there, there's a bunch of obfuscated Now, quick note on obfuscated code. What is obfuscation? Sometimes software makers want to hide their implementations. They want to impede you from and from reverse engineering what the underlying mechanisms With higher level languages, you get a terse randomly You might have a class named lowercase A. You might have a method named F999, or just whatever the case may be. It's harder to obfuscate in a higher level language. Since those decompile cleanly Why do we use Android Studio? Or I should say, what's the advantage of using Android Studio is in your manual deobfuscation process. It's a very slick IDE, it's It receives a lot of support, And then of course you get all the classic IDE go to declarations, things like that. With Android in particular, you get a LogCats which lets you search. You can also target specific on a phone to reduce the that you see, and better help Let's take a look at what we So live log analysis. This is one of the first things I try because being a developer myself, I know that oftentimes the a wealth of information. And as a regular user of of the application, I regularly the debug output. So if you're rushing a and you don't disable your debug output, somebody like me is gonna come along and hook up the Android phone to LogCat and investigate for about what's going on. Now, let's take a look at what logs we get as we start this application. Here's the login screen. Here's a little capture from LogCat. And we can see that there's in there, there appears to be some kind of an encoded payload. There's some interesting strings in there. And we appear to be and debug output. So, there's a URL that ap.jawalife.net. Go JAWAs! And then as we kind of continue scrolling through the screen that there's a lot more When you try the camera pairing process, you have to enter in the And at this stage, we see which logs the SSID, the password, and then what appears to be some kind of a randomly generated token. And in this log output, I know but there's a class that we And then there's what appears which is what helps us send from the cloud server. Let's try to pair to a So there's a button that says Just to love it, it makes And when we send the sound wave, we get some additional information. And it may not look like much, but there are a few in the analysis. We found, just to recap We found a distinctive characters. We found URLs. We found a class to investigate this bind device new activity. That sounds particularly fitting given that we are trying to enable and configure a new camera device. So, what does this lead us? We can continue our search that we found in the log outputs, and searching for them And as I searched through I found a few things. It looks like the number one They call the random generated code, they call it a SmartCode. Then, there's a string one of this little message block. And even though Android Studio is calling this message DB notify reached, I kind of wonder if this of some kind, because it of the character one. So, what is the SmartCode thing? I noticed that each time I to the cloud app, this It would be different every time. And I could see by looking that yes, every time that you you get characters and and that constitutes the SmartCode. But the question still remains, And just after having gone through this entire analysis process, and seen it change with every single time that I attempt to pair, and noticing that whenever a message was sent from the application up to the cloud server that I can only presume that the this random code to tie this camera to my user account in the cloud. Since, how else is the that it belongs to my account? So that's the best case that I have for what this code is used for. As we continue looking we can see other strings sorry, to functions, methods that warrant further and play voice. Both of those sound, they sound good. Let's take a closer look and At this point, we've a lot of methods, static And we want to take the key sections out of the vendor application, so that way we can perform an analysis. Just a couple of notes on If you're looking at another application, which like this application here, leverages native libraries, you'll need to manually put all those compiled libraries and then you'll need to make the package structure has to be the same. So this thing is called in the vendor application. I can't call it calm.test.reverseengineer, I have to name the package Because the way that JNI works, it requires those two things to match up. And once you have your you're able to perform black box analysis of the code that's used And along this way, one of well, what are the exact by the application to pair Well, there's a class called VCodeTable. And as I ran it in this extracted project, it produced a mapping of all of the tones. All the tones along with the So this is what the characters map to. We have from zero to 4875 Hertz. And there are 16 states, so and coding here. Now, looking at what else we found here, there's a lot of findings. We know that Android uses AudioTrack, we know that the to play a signal. We've identified how as far as the SSID, the and then the delimiters We've identified control tones, like a frequency begin and frequency ends that are just static constants. There's also a space when two tones play back There's a little space tone that pops in, and that'll be better There's methods which play the characters, there's the use of a CRC know if it's received a So, there's a been a wealth of information that we've uncovered through this process. So, what do we know now? We can reconstruct all of of the signal. 'Cause each signal And now that we can reconstruct really that just leaves section three. And I've highlighted in this which is, sorry, the part of the signal which is elusive at this This tone appears to be some It doesn't exactly track that the rest of the which left me wondering. And since this is generated by code that's in a native library, it means that I need binary analysis to dig deeper and try to figure My tool of choice is Ghidra. I don't know how to pronounce that. It's a free tool. It's very capable. And it does the job here. So to get set up with Ghidra, you'll want to visit their GitHub page. Pull the latest release for your platform, and then follow the installation guide. Once you have Ghidra installed, fill out all the wizard boxes. I just took basically all the defaults and gave it a project name. Click the dragon icon. Import the native library In my case, I just went since I am a little bit than I am with arm library at the moment. When you click the yes button, it'll go through and it'll do an analysis of this compiled library, which you can then navigate in the UI. So, reverse engineering with Ghidra. We need to know what So, you want to go to your make sure that you which methods in the higher in the compiled library. Once you know that, you can and you can see here that there's a number of a JAWA com interrupts. So JNI interfaces here The methods that we're looking for are the get voise structures the bottom of the screen. And here's a closer view on as you do this analysis. So, now we just need to and dig in. I focused on this called &quot;getVoiseStructGoke2.&quot; So I love the spelling of voice, and I don't know what Goke2 means. This is the function though and section three output One thing that I noticed as is that on the JAWA side, to this native function. Yet on the compiled side, when we look at the function there were 10 parameters here. So, it seems a little odd, but then doing a little that JNI call in conventions There is a, yeah, let's There's a JNI environment pointer, and then there's an object pointer. And these two parameters are front loaded to the function signature. So those first two are just So this top picture is Just with all the generated identifiers that don't really make a lot of sense. The bottom picture shows to indicate that the first two Now let's continue the analysis. Okay, so inside of Ghidra, there's a function decompiler window. And the nice thing about Ghidra, that I've worked with. You can right click on an you can highlight it. You can do things that'll help you analyze the flow of how a particular parameter is used and manipulated. So, this function, this It calls another function that are passed into this function. What I do when I do this type of analysis is for each screen that I'm on, I try to rename and refactor the functions, to names that actually make some degree of human sense. So that's what I'll be doing here. This is the cleaned up view. And I know it's small, that each of those parameters what value they represent And then, I go from Since this is decompiled, sometimes it doesn't Like I noticed that input parameters are copied to local variables, and then those local variables So, in the analysis, just keep in mind what you're looking at, track the flow through any that it goes through, to see where it winds Now, this is the raw view Fortunately for me, so for this demo, this There's only about 58. Yeah, actually about 56 lines long. So it makes it pretty easy to analyze. Again, since the identifiers are all terse and auto-generated, I need to that I can use. So, start with what you know, Even if you can't get all the names to something human readable, and as you reason through the code, you'll find that the rest of the pieces can fall into place sometimes As I went through this and I found that the critical section, the critical operation in my reverse engineering the signal three, it just So, this is the line. It takes the CRC SSID, and So, that's a very simple in my replicated Android project. It is not something that just by reasoning through the JAWA, or by passing in inputs and fuzzing the output. I think probably with enough time, I probably would have figured it out, but I get a little impatient, and when I can go explore a little deeper and a more fully understand I'll take that opportunity. So, a shift, that's all I got to do to replicate section three. Now, let's think about hacking the signal. How can we recreate this and manipulate it to serve our purposes? So, let's look again at what we know. This is the spectrographic wave form of a complete pairing cycle. The wave form is comprised of hexified data. Each section is prefixed and and section identifiers. We know that when two there's a space tone that the camera better differentiate and identify distinct signals. The duration of each tone that I found is about 50 to 60 milliseconds. And we know the structure Let's look at section one. This one's a long one. It's got frequency begin. It's got delimited, SSID, It has a CRCs of a bunch And then it's got end tones. Section two is incredibly All it's about is the SmartCode, and just making sure that there's a proper error correction on So that's very terse, very short, very easy to reason through. Section three. Yeah, this one's a little We have some CRC codes in there. We have another kind of of the SmartCode. There's a passphrase and then this thing wraps up. So, we can reproduce the signal now. We know every aspect of and we are able to So, that's where the demo I created an application this wireless camera to a wireless network without having to use This enables the camera using more traditional but network style of So with that, let's go ahead and let's take a look at the demo. In this demo, we'll be with a wireless network that's hosted on this advertising a Defcon 29 SSID. To do the pairing, we will leverage the reverse engineered as part of this kind of Where I've configured Now, to get this camera to pair, we need to wait for it After I plug it in, we'll want to wait for the flashing light. And at that point, the camera should be that it paired to a specific network. So, I'll plug the camera and start it up. On boot the camera shows to indicate that it has power. After it goes through its set up sequence, whatever that entails, I haven't been able to really probe that. It'll go into a flashing light mode where we can pass it along our message. So, let's give this a try. (electronic noise) All right. With that tone, it should indicate that the camera has received And in the Wireshark capture, you will see that the with the network, and that it's paired. So that is looking good. Let's take another look at the pairing, this time from the screen recording that shows the Wireshark As the camera goes through receives our pairing code, it should show up requesting an address. Which in this case, I've targeted to be a You can see here that it on the local demo network, and it proceeds to query back home and attempt to call home and We're going to try connecting One thing I do want to is that the video connection It doesn't always work and can require three, of five different attempts to Here I'm showing an attempt to connect to the camera using VLC, It fires right up. So, go figure. Let's go ahead and wrap this up now. There are a few limitations It's not easy to discover the device's administrative password. It is six hexadecimal characters. And the password changes each It doesn't seem to be tied So just kind of brute forcing your way through it might be one decent option. The easiest option is to the cloud and pull That is not the approach if at all possible though. So, it's not possible or not to decipher the camera based off of some of in the application and between the camera and the cloud servers. The camera has a local RSA or potentially between each request. The payloads are encrypted So even though you can view up a self-signed demand you can't really make sense of So, could be worth some You also get what you pay for, even if you know the password, VLC will sometimes connect So, just keep that in mind if you want to economize and save a buck or two on a cheap wireless camera. So, thank you very much for It's been a real pleasure to So thanks.