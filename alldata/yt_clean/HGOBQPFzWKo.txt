Hey guys, welcome to this advanced Python tutorials about Python and machine learning. topics that bring your Python skills to the course is aimed at an intermediate skill level, knowledge. For example, if you just completed next step, then this tutorial is perfect for level, you can benefit from this because I we really go into detail of all the different cover today, the course is splitted into 21 Python programmer should know about these data type that is ordered mutable, and that closer look at lists and what you can do with square brackets. And within these brackets, by a comma. For example, let's put some strings if we print this, then we see that all elements list with the list function. So my list two see that this creates an empty list. And later different data types. So for example, we can a Boolean, and a string. That's all possible. if we put in another apple here, that we then our list. Now if you want to access an element, let's say item equals my lists, and then inside that the indices start at zero. So index zero the banana. And if we print the item, then one is the cherry. index number two is the is too large, what will happen, then we get be very careful with that. Now you can also refers to the last item, in this case, the so on. Now if you want to iterate over your for i in my list colon and then do something we see that for each element inside our list, call this I you can call this also x or whatever is inside our your list, you can do it with check, say banana in my lists, colon and say you run this then we see that the banana is All this let's check if the lemon is no the check if your index is inside your list. Now that you can do with the list. First of all, you have inside your list, you can do that this, and we see that we have three elements items, we can do that by my list dot append. we see that a new item the lemon, got inserted if we want to insert an item at a specific methods. And now First, we have to specify then the item, say a blueberry, and then print we have the blueberry. If you want to remove And this returns the last item and also removes print it. And we see that now we got our apple that the app is no longer in our list. Now the dot remove method. For example, let's got removed. Now what happens if we specify example, if we have a typo here, then we get here. We can also remove all elements with list. Some more useful things that you can with the reverse method. So now the list is list with the sort method. Maybe this, for let's say 4231 minus one, minus 510. And if ascending order. So note that this sort methods, your original list. And if you don't want list, then you can do this with the built and then your original list and note that you see this is still the same. And if you now the new sorted list. Now, some useful the same elements multiple times. So for example, you can do it like this. So let's say it's we print this, then we see that we have a new list with five with the plus operator. So let's say I have want a new list. So a new list equals my list you your fun new lifts with both elements talk about slicing, slicing is a very nice the colon. So for example, let's create a create a new list and simply call it a and my list. And inside the brackets, you specify say for example, start index one and stop we have a new list that goes from index one, index is excluded. So it said index 123, and from two to five. Now, if we don't specify from the beginning. And if we don't specify the end. And you also have an optional step and then the step index, and by default, it's the beginning to the end with a step one. every second item. And I can also specify trick to reverse your list. Now let's talk this list original, and put in some fruits if I want to create a copy, and I simply do you have to be very careful. So if I print as our original list. But now if I if I modify also modify the original list. So for example, and I also print the original, then we see in it. And this is because with this assignment, the memory. So yeah, be very careful here. your list, you can do it with the dot copy the original method, the original list is list function, and as argument we use the copy. And as third option we can use slicing, slicing all the way from beginning to the Now, as a last nice trick, I want to show comprehension. So that's an elegant and fast list with one line. For example, if we have create a list with squared numbers, and we i times i, for i in a, or maybe let's call print the second list, then we see that a squared. And the syntax is you have your expression, note like the same with iterating, you don't x. And then also use the x here. So that's new list with another with some expression that is ordered and immutable. It is similar cannot be changed after its creation. a tuple And let's have a closer look at tuples. And tuple is created with parentheses. And within you want separated by a comma. So for example, we print this, we see each all the elements optional. So we can leave them away. And it's just want to have one element inside your and you write it like this, then this is not at the type of this, then this is recognized you have to put a comma at the end, even if So now it's recognized as a tuple. You can a tuple from an iterable. For example from this, then we also have our tuple created. do that by referring to the index. So if we brackets, we specify the index that we want, gives us the very first item, we print this, 28 index two, we get Boston, and if you use eiroa index out of range. So be careful here. one refers to the very last item. So that's last item, and so on. Now, what happens if we want to change the week, if we write my tuple and then get the like Tim, and if we run this, then we get assignment. So this is not possible because Over a tuple with the for in loop. So for in this case, I just want to print the element. we don't have to call this I can also call also easily check if an element is inside in my tuple, and then we say just print, yes. this, then we get a yes, so Max is in our our tuple if you check for Tim, and we get is inside our tuple. So let's talk about some a tuple. For example, create a tuple with want to get the number of elements inside our tuple, we can And this returns five, so we have five elements. tuples, so we can use my tuple dot count, P. So then we see we have two letter piece inside one, if we check for all, which is not inside find the first index of some specific elements. if we run this, then it returns the first index P. For example, if we say a, and we index of L, then we get index three. And if our tuple, then we again get a value error. convert a tuple to a list and vice versa with my list equals and then I use the list function, out of it. And I can convert it back, I say my list if I print this, so then I have a with tuples. So slicing is a very nice way use of the colon. So for example, let's create create a tuple. And then the syntax is we inside brackets we specify a start and a stop this, then we have number 345. So this goes and the other last index is not included. in it. So if we don't specify a start index, And if we goes all the way to the end. Now, we can also this is one. So in this case, it goes all of one. And if we put in a two here, for example, can also use a negative step, this is a nice can, let's talk about unpacking. So if we let's put, let's use Max, 28, and Boston. at the left side, we write our variables, to my tuple, then we get each separate element you put in here must match the elements inside here, then we get a value error, to many, is we can unpack multiple elements with a So for example, if we use some numbers, so let's say I won, and then a star, and say, then if we print I one, this is the very first last item. And if we print by two, then these to a list. Yeah, so one more thing that I a list. And because a tuple is immutable, And thus, working with a tuple can be more with large data. So let me copy this in here. with the same elements. And then we use the of bytes. And both of them. And if we compare though it has the same elements as the tuple. over a tuple. And also to create a tuple. so there's a very nice method in the time, use a statement and repeat this specific number times 1 million times we want to create a to create a tuple and then measure the time. longer to create the list than to create the with tuples can be more efficient than working type that is unordered and mutable. It consists key value pair maps the key to its associated and what we can do with them. First of all, these braces, you put each key value pair and then colon, and then the value, Max. And So comma, and then let's put in another key one, city, Cole on New York. And if we print then we can also use the dict function to our keys as arguments. So name equals Mary, And if you print this, we see that we have this function, you don't have to use quotes the values, you do that by saying my dict key. So you print the associated value for the name, then we we get 28. And what will happen if we use example, check the last name, then this will here. A dictionary is mutable, so you can when we want to add an key value pair, we then inside brackets give it the new key. value max at x y z.com. And if we print it, email key value pair here. Now if we do the then it got gets overwritten. So let's say has the key email. And now with our new value. options, we can say, we can use the Dell statement, name, and then we print it then we see that our dictionary. Or we can use the pop method. it the key, let's pop the age. So now we see Or we can use the pop item method. So prior and since Python 3.7 This removes the last 3.7 and then it removes the city. So we see When you want to check if a key is inside to do that. The first one is to use an if and then we can use this key we can say print we say last name and want to print it then get executed, so nothing is printed here. So try and then access a key. So let's say print error. So if we run this, then this name. And if we want to access the last name, a key error. So an exception is thrown, which be executed. So if we run this, then we see to loop through a dictionary, you have several can say for key in my dict, and then print through the dictionary, and loop through all will do the same thing. The keys method returns You can also loop over the values. So you then print the value. And then it prints the loop, you can say for key comma value in my key and the value. Now when you want to copy most common way to do it is like so let's assign it to the original mighty dictionary. is the same as the original one. But now if the original one, let's say my direct copy the copy and the original one, then we see value pair. This is because with this simple point to the same dictionary inside our memory. If you want to make an actual copy, you can this one and print it and we see that the or you can use the dict function. And as an argument, So if you use this, then we see that the original a useful method to merge two dictionaries, method. Let's create two dictionaries. And the first And the second dictionary also has a name city. And if we want to merge these, we can and then with the second dictionary, and now existing keys or key value pairs got overwritten. So the didn't change and the non existing keys the to update to dictionaries. Let's talk about before I used a string as a key, but you can also use numbers as a key, or even a tuple. example, we can say, my dict, and then key then a key six and 36, and the key nine, and possible, but then you have to be very careful, so, and you want to do it like with lists, say index zero, then this will raise an exception in our list, what do you rather want to do key three is not nine, and then if you print yeah, we also can use a tuple as a key. So then create a dictionary and S key, we use if we print this, then we see we have our here. And yeah, so tuples are also possible. list. If we use a list here and run this, on hashable type. That is because a list is And therefore it's also not hashable and cannot aside collection data type that is unordered it does not allow duplicate elements. A set but we don't put key value pairs in it. But a comma. For example, let's put some numbers set here. And if we put for example, another then we see that only one of each element we can also use the set function and use an here. This will also create a set, or we can we print this, first of all, we see that the And the order is not important. And we also this is a nice little trick to find out how Now, if you want to create an empty set, and then you have to be careful because now if we see that this is recognized as a dictionary. to do it with the set method. Set is mutable add elements and we do this with the dot add and print this. And we can also remove elements the three and if we want to remove an element raise a key error. So be careful here. So cart method that does the same thing. So it find the element, then nothing will happen. method, of course, this will empty our set, return an arbitrary value of our set and also in this case, it returned the one and also over our set very easily with an for in loops. in this case, just print this. So this will we don't have to call this I we can also call we want to check if an element is inside our So if one in my set, and then we print, yes. our set. And if we check for example, for let's talk about union and intersection. And three different sets one with odd numbers, numbers. And now we can calculate the union. two sets without duplication. So let's calculate union, and then as an argument, the second that now we have all the numbers from zero from both from two sets without duplication. two sets. So the intersection will only take we say the intersection equals arts dot intersection get an empty set, because arts and events calculate the intersection of arts and primes, also odd. So 357 if you calculate the intersection only the even prime numbers. So in this case, difference of two sets. So let's create two one to nine and set B with one with 123 10 with all elements from the first set that call a diff equals set a dot difference set Then we will see that we will get back the the elements from our first set, but not the from four to nine. So if we do it the other it will take 10 1112 but not these three numbers a second different method. second difference method. So, the symmetric difference method set A and set B, but not the elements that from set A, and 10 1112 from set B, but not sets. So if I use set a symmetric difference and intersection and the difference method the original sets, they always will return in place. So for example, we can say set a then we will see that this updates the set set. So without duplication again, so it does 1011 and 12. There's also a intersection up set B. And what this does, it updates the in both sets. So only one two and three are remain in our set. Then there's also the difference set B. And if we print this, we will see the update, it updates the set by removing elements it finds one, two and three in the set B so then there's the symmetric difference update. elements found in set A and in set B, but one, two, and three are found in both sets. all the remaining elements from both sets. with them yourself a little bit to make it sets superset and disjoint methods. So for You can calculate the if set A is a subset return false because subset means that all our second set. So if we use it the other this will return true because one two and opposite is called the super set method. So And in this case, it returns false because contains all the numbers or all the elements 546. So it's not a super set. But set a is two and three. And we can calculate if two if both sets have a null intersection, so B. And if we print this, this will return if we create, for example, a set C and put joint with set B, then this will give us true. If you have watched the previous episodes know this, you have to be careful, and you a simple assignment. So let's say let set if we print this, then we see that we have say set B at set seven. And if we print the we see that also the original one changed, to the same set. So be careful here, you only an actual copy, you have to use the dot copy that the original set didn't change, or you set as a argument. This will also make an to show you the frozen set, the frozen set just an immutable version of a normal set. And there's an argument you can also put an print this, then we see our frozen set here. after its creation. So if I try to do a.at, also say try a remove one. This will also methods I showed you, they also don't work. method, they will work a string as an ordered used for text representation. And it is one hope that at the end of the session, you'll start. First of all, a string is created with use double quotes and then put your letters we can print this and then we see our string probably more common. The only thing you have quote inside this. So if you have for example, am a programmer. Now if you try to run this, you can do is you can either use an escaping put your single quote in Side double quotes. also sometimes see triple quotes. So this So now I can go in another line. And this code. So now if we run this, we see that our may also sometimes see an escaping backslash, should continue in another line. But it should this, then we see we have our one line hello or sub strings, it's the same like with lists, say char equal, or let's create a string first. then you can say char equals and then my string. want. So if you want the very first character, this. So this is the H and F, we use index use a negative index, so minus one is the and so on. But what we cannot do, for example it. So if I want to change the first character this will get a type error, a string object is because strings are immutable, so they can also access a whole substring with slicing. I put this start index, so let's say one, then if I print this, then I will see I get starts at index one, and goes until index here. So it has 123, and four, so our string then it starts all the way from the beginning. all the way to the end. So this goes all the another optional step index. So if I put another this takes every character. And now if I put And I can also put a minus one here, and then So that's a nice little trick to reverse the can concatenate two or more strings simply Tom and I will just call this hello and say my sentence, I will create a new string that between them. And then plus again, plus the and then we see we have our concatenated string. iterate over our string with a four in loop so just print this print every letter So, each character. And we don't have to call x or whatever we want. Now, if you want to our string, we can do this with an if in statement. letter E. So if e in greeting, and then I print. No. So he is inside my word. So it p, then it will print No. And I can also check will also print Yes. Now let's talk about strings. So let's say we have a string with hello world, and then some more whitespace that our printed string also has the wide I can do my string equals my string dot strip. now if I print it, we see that the whitespace does not change our string in place, because just write it like this, then this will not our original string still has the whitespace. it again to our original one, and then we Now, what we can do also, with strings is to an upper case, so let's say my string dot we can also say my string dot lower, then my string starts with specific character or then we can say h. so this will give us true and check with world. And we will get a false. So if it ends with world, so now we have true. a false. Now we can find the index have a string dot find and then we want to find O. finds with an O. So index 01234. So it returns So this is the at index three, our l o substring it will return a minus one. We can also count So let's check for how many O's we have in many peas do we have? We have zero. We can also replace characters or substrings dot replace. And then we want to replace world with the universe. And now, if we print this, And also be aware here that this will return So if it does not find this strings, let's it does nothing. So it will still print the about lists and strings. So let's say you we have here, how are you doing. And you want word of my string as an element in my list. my list equals my string, dot split. And if each word now as an element in our list. And is a space. So here, the default argument then splits our string here. Now, for example, find a space, so it, we only have one element you would have to use as a delimiter, a comma. if you have the list, and you want to convert you can say, let's say new string equals and empty string, and then dot join, and then the new string. And then we will see that of our elements in our list. So this will And between each element, it will put this a space here, then it will put a space between string again. So the dot join method method elements of a list back into a string. And one because this is very useful. And let's more. So let's say we have a list with some and then times six. So maybe you know this elements. And now if you have the task to you will see is that you will create an empty So for i in my list, and then you will say So it worked. We have our string here, but here since a string is immutable. This will back to our original string. So this operation use it The dot chain method. So as I just and then we will say an empty string dot, So this will also give us the same thing, So let's look at the time of both of these time at module, we import the default timer equals timer. And at the end, we can say, stop minus start. So this will give us the do the same thing here. So if we run this, we will, let's remove this, But now let's say we have, for example, a elements. And now I don't want to print my see that this The second way with a dot join more than half a second and the second only it. And remember that duck shine method. Now strings. So there are two ways to format a operator, or with a thought format method. f strings. And let's talk about all of these call it it's, let's say variable equals a we will create a string and say it's the variable use a percent s. And then after our string, So this tells the interpreter that we have afterwards, we fill this placeholder with then we will see that our string is the variable shouldn't use percent s here, we should use value. So now we have the variable is three. like this, and if we run this, then we see the Python that we have a decimal value here. point, so we say percent F. And then we have it has six digits after the decimal points. want to have, we can say, dot percent dot two digits and then.to F. So this will give this is the very old formatting style. The methods. So now what He wants to do is as our string, we call the dot format method. So now if we print this, then we see that we have the placeholder got specify how many digits so we can say, colon, the decimal point. And for example, if we another placeholder here, and then another equals six, and then we would put var two our variables inside our string now. So these way to do it is with the F strings. So this the F strings. And with an F string, you would the string. And then you will also use braces. directly. So you can use var here, and var So if we run this, then we see it worked. it's more concise. And it's even faster, especially would highly recommend using this f string what this does is it evaluates the this at here. So let's say it's a mathematical operation, be evaluated at runtime. So now, we see we yeah, so that's it about f strings. And that's The collections module implements special with some additional functionality compared lists, or tuples. So we will be talking about module, the counter the named tuple, the artists start with the counter. And first of all, counter. And the counter is a container that their counts as dictionary values. So let's characters, a BBB, CCC. And then we can create and then we give it our string. And if we with all the different characters as keys times a four times B, and three times C. And, a look at only the items. So this will give look at the keys. So this will give us an have a look at the values. So this will give very helpful is to have a look at the most So we say if we first print our counter again, my counter dot most common. And then here only the very first so the most common elements. So if I print this, then I will common element. So if I say two here, that it will also put the B in here. And this will if I want to have a look at only the, I want I will x have to access the index zero, so, And then if I only want to see the element, element of this tuple. So against zero, and is most common in our string. So, we can also we can also have a list with all all the different dot elements, and this will give us an iterable as it counts. So, I have to convert this to if I print it, and I will see, I will get And I can, for example, iterate over this. named tuple. And of course, first of all, import named tuple. And the named tuples is similar to a struct. So what I can do is I let's create a 2d point and call it point then as first argument, I give it the class that I use here. And then as a second argument, different fields I want separated by either So this will create a class called point with point. So I can say p t equals point and then example, I will give it one and minus four. I have a point with x equals one and y equals So I can say p t dot x and p t dot y. So then is the ordered dictionaries. So from collections is just like a regular dictionary, but they So they have become less important now since ability to remember the order since python if you use an older Python version, this may the order. So for example, let's create a key value pairs like with a normal dictionary. a and a value, one. And let's do this with B, C, and D, and 234. And now if we print then we see it's the same order as we inserted at the very end, then it will also get printed since here, I'm using three python 3.7. So dictionary now and it still remembers the dict. So from collections import default dict. usual dictionary container, with the only if the key has not been set yet. So what we And as an argument, we will give it an a default an integer here as default type. And then D, with the key a is one and D with the key So we will see it here and then we can access key a, and then it will give one and the key that does not exist, so for example C, then value of an integer. And this is by default a float default value. So then this will return I will have an empty list if it does not exist. raise a key error. So now this would raise return the default value of the type that we will talk about the deck. So the deck is add or remove elements from both ends. And be very efficiently. And yeah, let's create we can append items like with a list, let's then print it. Now, now, we see our deck here left. So this will add elements at the left here. And we can also again remove elements And now if we print our deck then we will remove the last element. So now the two got will return and remove the other From the can also of course, say d dot clear. So this we can extend our deck with multiple elements then give it a list, let's say 456. So this or we can say d dot extend left, this will And note that now, it will add First, the then the six. So now six is the most left deck so we can say d dot rotate one. And now rotate all elements one place to the right, to and then this will rotate all elements to the left side, and I will give a negative one, then all our elements will rotate one The inner tools module is a collection of are data types that can be used in a for loop. the list. And the error tools offer some advanced the permutations combinations, the accumulate infinite iterators. So let's start with the it. So we say from it or tools, import product. and two, and B equals a list with three and a and b, and the product will compute the So let's print this. So print the product. tools object. So this is an iterator. And to a list, and then we will see the product. and one and four, and then two, and three, we can also define a number of repetitions. repeat. And let's run this and then we see our second iterables smaller, and print this. So we have one and three. And since we can one and three and two and three, two, and two and three, and two, and three. So that's permutations. So permutations will return say we have one, two and three as a input, a and print this again, as list and then we 123132213231312, and 321. So that's permutations. permutations as a second argument. So if we with only length two, we skip the argument the length of 22121321, and so on. That's from either tools, import combinations, and combinations with a specified length. So let's 123, and four, and then say comm equals combinations here is mandatory. So in this example, I only as a list. And then we will see all possible combinations three, four. And, and note that we don't have here. And if we want that, we can also use So then we import it, so import combinations combination iterable and say combinations and Prentiss comm with replacements, and then and itself. So one and one, one and two, one and combinations with replay replacement. so the accumulate function makes an iterator binary function that I will give as input. the accumulate function. And then we can say, and then we say, accumulate equals accumulate print our list and then print the accumulated and three, and they accumulated sums is 136, And then we have one plus two is three, three So that's the accumulate function. And by can also for example, multiply the elements give as a second argument, we can say func each element so one stays the same. One times times four is 24. And as a third example, the max for each comparison. So for example, a look at our list than one is the same two and five is Till the max compared with three four, five is still the maximum. So that's by function. The group by function makes an an inner rebel. So let's make an example. list a equals 123, and four. And then we say by, and then we want to group A, and we have So as key, we can define a function, so let's and then return x smaller than three. So this will give it this function. And then let's print this. So we will see iterate over this. So we can say, for key want to print the key and the value. And then tools, object, group or object. So we can And then it gets clearer. So we have our input With the comparison if it's smaller than three, they are smaller than three, and the key is and the key is false. Now, we can also use this in the next video. But as a very short that can have an input and will do some expression this same function in one line with a lambda colon, and then simply x smaller three. So then it will print the same thing. Now let's maybe this is not clear at the first side. is a list. And inside this list, we have different a name and an age. And let's say we want to and then we say lambda x and simply x and print this, then we will see as keys, we have and 28. And then we also see that it grouped 25 years old. And then we have Lisa and Claire. have some infinite iterators. There's the the repeat function. And the count function count and then Give it a start values. So this will make an infinite loop that starts So one, so 10 1112, and so on. And this is say, if I is 15, then we will we break, so function, then there's the cycle function. So let's say we have a list that has one, a and print this. So this will print one, two, and three, and again, infinitely, until cycle method. And now as a last thing, the for i in repeat, and then I want to repeat, simply make an infinite loop. And we'll print give it the stop repetitions. So how many I say four, here, then it will repeat the Lambda function is a small one line anonymous it looks like this. First it has the lambda then a colon, and then an expression. And with some arguments, and it evaluates the look at an example. To make this clearer. 10. And this is equal a lambda with an input. evaluate x plus 10. So this will create a to the argument and returns the result. And at 10. So now this is a function that we can with five. And now if we print this, then same as a normal function like this, let's an argument x and return x plus 10. So these function is much shorter and only in one line. arguments. So let's say let's create a another this is equal lambda. And now we give it x this will create a function with two arguments, returns the result. So now if we print for print 14. So that's the lambda syntax. Lambda a simple function that is used only once in higher order functions, meaning functions For example, they are used along with the reduce, and we will have a look at all of let's start with the sergeant methods. So showed this in my video about lists. So let's to the, and the list has tuples with two elements the y well use of our points. And now if we to the sorted list. And then we can call sorted, anything. And now we can start our list. So first, print our points and then print our will start our, our list by the first argument, But we can also give it a specific rule how key argument and the key equals, and this we can write a function with a lambda in one x. And now let's say we want to sort it by then we say, x of the index one. So now if got sorted according to the Y index. So what it a or define a function, and let's say sort give it an argument, and in this case, two first index. So now we can also use this function this will return the same result. But now And then we can simply use our lambda here, of this function. And yeah, that's one use another example of sorting. Let's sort this we would say lambda x and then evaluate x we run this, then we see that it got sorted the sergeant's method with a lambda is key So the map function transforms each element has a func, a function as an argument, and list. So let's create a list with some numbers let's create a another list and call this each element by two. So let's say map. And an argument and evaluate x times to and then then we print this and if we want to print then it will print a map object. So we have And then we can see that each element got However, you can achieve the same thing with know the list comprehension syntax. It's a this. C equals And then let's say x times this will do the same thing. So, personally, bit easier. But you should have heard about is the filter function. So the filter function will, this function must return true or false. for which the function evaluates to true. let's say we want to filter this. And we say, we only want to have the even numbers. So x modulo two equals equals zero. And then numbers. So again, here, we can achieve the can also write C equals a list and then inside we can give it a condition, we can say, if C, then we see that this will do the same you the reduce function. So the reduce function it repeatedly applies the function to the say I have a list here. And I want to compute call this product, product A equals and then have to import this now. So I have to save can come call the reduce function. And as I define the function here, again, in one it has two arguments here. So function, the two functions has two arguments. So let's times y. And as a sequence, I gave it a, so Let's make this example smaller, then we can three equals six, and six times four equals that's all I wanted to show you about lambdas. A Python program terminates as soon as it a syntax error or an exception. So in this difference between a syntax error and an exception? How can we raise and handle exceptions? And start with a syntax error. a syntax error incorrect statement. So for example, if I line, I want to print this, this will raise use a new line here. So this will be fine. or too many parentheses. So if I try to run And now exceptions. So even if a statement error when it is executed. And this is called error classes, for example, trying to add So, if I say A equals five plus, and then run this, then this will raise a type error, string. So, this is a type error. And now exceptions. So, of course, there is the import that does not exist, then this will raise from the import error. This is a common exception, if I have a variable A equals five, and another So, if I run this, then it will raise a name the file not found error. So, let's say I the file is called some file dot txt. So if not found error, no such such file or directory. if the function or operation receives an argument value. For example, let's say I have a list remove elements from a list with the dot remove works fine. So now, I print A, and the one remove the four, which is not in the list, remove x x not enlist, then there's the index a sequence, or of this list, that is not that access the index for, then this will raise if I have a dictionary, so let's say I have Max, and it has only the key value pair have I want to access the age then this will raise my dictionary. Now let's talk about raising an exception. when a certain condition is met, then you say we have a variable x equals and minus then we want to raise an exception and then base exception, and as message we give it then this will raise this exception x should of larger than zero, then no exception will assert statements so you can say. You don't statement. So you say assert, and then a condition an assertion error if your assertion is true. assertion that x should be larger or equal will raise an assertion error, we can also And now this will print the message here. then your code will be just fine. So if I you want to handle exceptions, so you can So you write for example, you write try and So let's say I want to try a equals five divided let's simply run this and show you what happens. because division by zero is not allowed. So blocks. So I will try this statement. And is raised, then the code will continue here. So if I run this, then your program doesn't in this line. And you can also catch the type as E. And then you can print your exceptions. division by serial message from the zero division the type of exception you want to catch. And So for example, if you know that this is a or you should write, except zero division You can also for example, use multiple statements So let's say we want to try five divided by say B equals a plus and then a string. So So let's this will raise a type error. So zero division error as E and print E. And then we write type error as E, and then we this will catch the Type error and prints float and string. And now if this fails, then message gets printed. So now we have division Now you can also with a try except block you is run if no exception occurred. So here I for example, make divide by one that's fine, And then the code continues in the else clause. finally clause runs always No matter if there example, use to make some cleanup operations. you run this, then the else clause runs, and exception, for example, this, then this line also is running. So yeah, that's how you can let's talk about how we can define our own classes by sub classing from the base exception too high error, and typically, you want to end. So the class value to high error. And class, and then we can simply say pass. So error. So now, we can say, let's write a small we say if x is larger than 100, then we can it can also have an error message. So we say with an argument of, let's say, 200, then to high error, so value is too high. And now, So let's say try test value, and then accept we print or let's print the era as E. And then print, let's catch the value to high that the message gets printed here. And usually but you can write it like any other class. to small error. And also, as a subclass. It class. And now you can, for example, define argument, and then we give it the message here. So we can say self dot message equals And now, inside our test function, we make is smaller than five, and then we want to to give it the message. So the message is give it the x. And now if we catch this, then as E. And now we have the information about we can also print e dot value. So if I test error will get raised. So I'm sorry, I'm Miss catches the error here and prints all the class. Python already comes with a powerful add logging to your application by simply this. And in this tutorial, we will have a configuration options, how to lock in different how to capture stack traces in your log and start. So after importing the logging module, lock to five different log levels. So let info, warning, error and critical. And they I run this, then we will see that only warning because by default, only levels of only messages if we want to change this, we can do that we want to do this right after importing them basic config. And then we can specify some a look at the documentation. So in the official arguments for the basic configurations. So format, and then the date format. And so in And then for the format, I give a string, specify this lock record attributes. So for And I do this by saying or by writing percent, Or I can say the ASC time, so this locks the And then I can specify how the time should then give a string for the date format. And documentation. So here are the different formatting percent m will look the month, then the day the second. And now if I run this, then we warning, error and critical are all locked. logger. So that's because the name here is then it's best practice to not use this root modules. So let's say we have a helper module logging, you create your own internal logger logger. And then you give it a name. And it's and then name global variable. So this will So it's called helper in this case, and then so as for example, say logger dot info. Hello After importing, logging, and setting the helper module, then it will lock the message logger. So it's good practice to create your function and then give this name with double this log on here, then this will create a logger, and all these new loggers get added messages up to the base logger. So now if say logger dot propagate equals false. So not propagate to the base logger. And now the helper module, then nothing gets locked logger. Now let's talk about lock handlers. So handler appropriate lock message to the handlers specific handlers to send log messages to this standard And ba you let me show you how you set different in our module by saying logger equals logging module. And then I want to create my handler. locks to this stream. So a stream handler. though this is a built in class. And I also The file handler equals logging dot file handler, lock file is called file dot lock. And then the level and format. So we say, stream handler dot warning. And for the file handler, the of level logging dot error. And now we also equals logging dot format. And then inside the same like with the basic config. So let's want to have the name of the logger and the also set the file handler to this format, we set the formatter to our handler. So we and also we say file handler, dot set formatter add our handler to the logger. So we say logger the stream handler, and then logger.at handler. now if we use this logger and lock something we want to say this is warning. And now we this is an error. And now if we run this, warning and error, because our stream handler And then also file handler locks to a file. is now this file lock. And this only has the the front lock handler. Now let's talk about other configuration methods. So we've already use the file config or dict config method. folder. And you specify it with this syntax. ini. And then you define the loggers, the we define two loggers with these names, one each of these further. So you say logger, logger. And then you give it its arguments. called simple example. And this should lock a console handler. And then we come and we stream handler with this formatter. And then And now if we want to use this config file, dot config. And then we can call logging dot the file name. So we say logging.com. And with for example, with this name. So this say logging dot get logger. Simple example. say logger dot d back, because it also locks if we run this, then we see we have the message the level, and the actual message, just like can also use a dict config, but I won't cover a look at the documentation. So the config And then you would right here, logging dot from a dictionary. So with this two methods, in your code. But you can use a separate file the code. So yeah, remember that you can also let's talk about capturing stack traces in troubleshooting issues. So let's say you have raises an exception. So let's say we have access a value, but we use an index that is And we can catch this by saying except index error. And by default, this will only now But if we also want to lock the stack trace, true. So e xe underscore info equals true. will also include the stack trace in our logger. line where our exception occurs. And yeah, And now let's say we don't know what kind accept and catch everything. But we still the trace back module. And we can, for example, use string formatting. So we say percent s, this trace back dot format, e x c method. will do the same thing. Basically, this will the error is, and then includes the trace So let's say you have a large application keep track of the most recent events, then the files small. So for this, let's say, we dot handlers import rotating file handler, your logger. Here, you set level. And then handler is now a rotating file handler. And then the max bytes. So this means that after to another log file. And it will also keep to the logger. And then for example, we log this means that we don't care about this. HelloWorld. And now if we run this, we see log files, all with this Hello, world message. then we see that each of these files is two rolled over. So this is how you can use a say your application will be running for a file handler. So for this you say from logging and this will create a lock, a rotating lock what we will do here is we also create a our handler. And then the name of the lock and therefore we can give for example, we can H for hours, then a D for day. We can also So, W zero means Monday, W, one means Tuesday, this every seconds with an interval of five. And we keep a backup of five files. So now range, let's say six, and then we want to wait a specific amount of time. So let's import we want to sleep five seconds. So now if we And now if some time has passed, so after with this timestamp. And then after five seconds, time rotating file handler. And as a last have a lot of different modules, and lock if you use a micro service architecture, then simple messages, but use the JSON format for open source, Python, Chase and logger. So install it with pip install Python, Chase and add this formatter to your handler. And for JavaScript Object Notation. And it's a exchange. It's heavily used in web applications, it. Luckily, Python already comes with a built data very easy. So in this tutorial, we will JSON data with this module. So let's dive at how Jason data looks. So here I have this here we see that chastened data looks very similar to value pairs. And as values it can take strings like here, a nested array or a nested dictionary. table. And by the way, you can find this on you can find written tutorials to all my other translated to chase and vice versa. So a dictionary tuples are an array is string is a string, True and False are also true and false, but And so these are all the conversions you have So let's say we have a Python dictionary and is also called serialization or encoding. say we have a dictionary called person. And if it has children, and then titles and this convert this to a chase an object. So first And then I can say, if I want to have this equals and then I use this module and I use this will dump our object to a JSON string. chasen then I will see that this is now in example, because false has a lower case. Now recommend setting this indent to four. And different separators. And this is a tuple separators. So instead of a comma here, I of a colon in the space here, I want to use, now if I run this, then we can see that different using different separators, but instead use argument here is to use this sort keys argument is false. And now if I run this, then we see this is how we can convert from a Python dictionary Now, I can also convert it or dump it into file. So let's say with open and let's call open it in right mode, open it as file. And because S stands for our string, I want to to dump the person object into our file. So got created in our folder. And this contains also specify the indent here, let's say indent at our file again, then we see that it has So this is how you convert from Python object data and want to convert it back to a Python or decoding. So let's say I have our person it back into a dictionary and I will say person want to load from a string and then I will now if I print our person again, and don't a Python dictionary again, because here we So this is how you convert from a chase string. a chasen file and you use the chasen dot load so we still have our person dot chasen here open this file person, that chasen and now then I want to I can say person equals chasen this and if we run this, then we see that can decode chastened data. And now, in this we have a custom object. So let's say we have class called user. And our user has two instance, an age. Let's say, self dot name equals name, create a user object user equals user. And now let's say I want to have this in JSON dump. So dump from a string, dump as a string. this, then this will give a very long error of type user is not chased and serializable. encoding function, and this is not very long. encode. user. And this will take a object. And inside with this is instant method. So this will a class. So let's check if our object is of a dictionary with all the instance variables name. And this equals it, this is our object value object dot h. And then as a little trick, So I can say, object dot with double underscores So this would give the name of the class as matter. So I simply put in true. And otherwise, error and as a string or message, I will put custom encoding function. And now in our dump, argument. And now here, I use this encode function for how to encode the object. And I can print our user dot JSON. And now we the age and the user class is key with value with this default argument. And then there's chasen encoder. So let's say we import from then we create a class called this user and chazan encoder. And then we override this default method. So let's say this is called here. And then inside we do the same thing. and then we'll we will return this dictionary will we let the base chasen encoder handle self and object. And now in our dump or dump a class. Now I use the user in encoder and if I run this, then we see this also worked. directly. So I can say user chasen equals And then I can say dot encode our user. And So this is how you encode custom objects. back. Let's say I have here our user in JSON Python object. So I can say user equals Jason chase in here. Now, if I run this, then this see we have a dictionary here. So we don't of this user, then we see that this is a dictionary name, because it's not a user object. But into a user object, I also have to write a decode user. And this will get a dictionary. our dictionary contains the user key. So now the user class name as a key. So now, in here, So let's say if user dot double underscore and return a user object. So let's return from our dictionary, so name equals dictionary And as a age, it will get the age of the dictionary. it will simply return the dictionary. So then be decoded into a dictionary. And now we have can say in our chasen dot load or chasen dot that is called object hook. And now we set And now if we run this, we see that we have type of user. And then we see that this is variables for example, user dot name, and custom objects. So Python comes with different built in modules we will have a look at the random module for for cryptographically strong random numbers random numbers. So let's start with the random And this is used to generate pseudo random called pseudo random because the numbers seem will see how we can reproduce the data in at the different functions. So the easiest random dot random, this will print a random print a. So this is a random float in the have a specific range, we can use random that So let's say our range is from one to 10. range. Now if you want to enter chess, we range. And if we run this a couple of times, will actually now we got it, this will include with this is not included. So for this reason, will do the same thing, it will pick a random bound is not included. So this will never dot normal variate function with a mu and sigma. And this might be useful if you're random value from a normal distribution with of one. So let's have a look at how this normal for different means and standard deviations. have to have a look at the red line. And this range where our red line is not zero. So this module also comes with different functions a list and call it my list equals. And let's if we print this, we will see that each character now we can pick a random choice. So let's And print this so this will pick a random we can use random sample and give it the number this will pick unique elements. So it will want to have a behavior where elements can use the random dot choices method. And here do the same thing, but now we see it can pick Then there's also the random shuffle methods. this will shuffle a list in place. Now if are now shuffled. So these are the most common are Yeah, I said that these are pseudo random you can do this with the random seed method. a value here. So let's say for example, one, So let's say I want to have, I want to print print some random integer. So let's say random Now, if I run this, this will produce some with this value with the same value here, And now if I run this, then we see that these I can also, for example, now I can see it And then I do this operations. And then again, And at the end, I will seed with two again and now let's have a look. And now we see with a seed of one are now the same, and then picks are now the same. So this is how you functions. And because these numbers are reproducible, purposes. And for this purpose, you should secrets. And this only has three functions. or security tokens or account authentication use the secrets module. The disadvantage is but but they will generate a true random number. first one is secrets dot ran below. So let's it has an exclusive upper bound. So this will zero to 10. And 10 is not included. Then you this will return an integer with K random Now, if you you're familiar with bits and that it can has four different random random number here, and this case would be 1111. of three, which is eight, then this is two plus four plus two plus one equals 15. So range from one to 15. No from zero to 15, sorry. Then you also have a list. My List equals list and with some secrets dot choice and my list. And this would So this is the secrets module. And now if the NumPy module. So if you have not installed can say import NumPy as NP. So usually, you for example, you want a array with random dot Rand, and then give it the dimensions. So this will produce a 1d array with three here. Now, if I can, I can also use more dimensions by three array. Now if I want to have random give it the range from, let's say, zero to give it this size. So let's say also size if I want to have a array with higher dimensions, I have to use three by four, for example. So this will create Then, this will also have a random shuffle method. So let's say I have a NumPy array array. And then I can say NumPy, dot random the array. And this will only shuffle the this will never switch elements in between, So this is the NumPy random module. And one ret NumPy random generator uses a different standard library. And it also has a different say NumPy dot random dot seeds, and then give do some operations. So let's say NumPy of three by three. And then I can receipt and the same, the same array. And the important seed method instead of the seed method from So these are two completely different seed tool in Python and every advanced Python programmer the concept behind decorators how you can function and class decorators and some typical understood the concept, it is not as difficult improve your Python knowledge a lot. So let's function decorators and class decorators. it looks like this. So you have a function, And that does nothing in this case. And above some other function name. So some decorator this is how the decorator syntax looks. And takes another function as argument and extends modifying it. So in other words, it allows function. So in this case, this function would decorator. And in order to understand this Python are first class objects. This means inside another function passed as an argument other function. So now, let's have a closer to, we have a function and call it print name. have a decorator function, call it start and a function. And inside our decorator function, it wrapper. So def wrapper, this is a wrapper So he inside this wrapper function, we execute the behavior. So I can do something before. I say in this case, simply print start, and after it, I want to print and, function, I also have to return it. And now, let's execute the print name functions. And to apply the decorator, I assign this print And as argument I take the print name function. functionality. So now if I run this, we will function and prints Alex and then it prints the same thing as this line. So now if I write this anymore. So this now that's the same start Alex and end. And now this is how we a decorator. So let's see what happens if say we have a function, call it at five and X plus five. And now if I tried to run this if I run this, I will get a type error because but one was given. So here, I need the same use the arcs and quarks. I will talk about basically with this syntax, I can use as many And now inside our wrapper function, I also keyword arguments. So let's write it like So this is how you apply arguments. And now this in a result. So let's say result equals, if I print this, this will print none here. of the function here, and then return it from And now if I run this, it can print the result. function identity. So let's print the help this help function, and also let's print the method. Now, if I run this, this will print name is also wrapper. So Python got confused in order to fix this, I can import func tools. decorator. That's called func tools, dot wraps, of my used function. So now if I run this, at five. And also, our function name is now the decorator funk decorator syntax. So this template for a decorator that you can use say call it my decorator, then you can do the function. And then you can do something and return the wrapper. So this is the template a look at this on my website, Python minus here, we see here a decorator that takes a can also take arguments. And what this means so an inner function within an inner function. example. So let's say we have a function, then inside it will print. And now we use another video about strings, so we can say name. And now we use a decorator and call and set it to three. So I want a repeat decorator how does this decorator now look? First of also takes num times and then inside it takes so we have a Decker Ray down. So define a And then inside here we have our wrapper. this with our func tools dot wraps Decker simply want to repeat this the number of times because I don't need this for underscore in our function with the arcs and the quarks. the wrapper, and then I return that decorator. be executed the number of times I've given So this is how the concept behind decorators about nested decorators. So you can stack let's say we have a function and call it let say hello, which gets a name, then it prints we can debug this, we can decorate this with before. Now, let me copy this here inside. print start and end after our function. And and call it D block. And now let me copy this debug decorator in name and the arguments and the keyword arguments function it executes the function and then value. So, this will basically print some so now if I apply multiple decorators to add they are listed. So this means now if I say all execute the debug function and then inside and decorator function. And then inside this So now if I run this, we will see that first from my Dubuc wrapper. Then it prints start Hello LX then ends and then again I'm here value. Hello Alex. So this is how you can last thing Let's talk about class decorators. also define a class decorator. So let's say it simply print. Hello. And I want to decorate count cause. So class decorators do the same typically used if we want to maintain and to keep track of how many times I have executed it count calls. And this has a init method. the function just like the decorator function. function as class variable, or as member variable. I will also create a state. And I call this the beginning, so I want to keep track of in order to write a class decorator, I have takes self, then the arcs and the quarks. in our function decorator. And now, sorry, And now the call methods allows me to execute So let's, as an example, let's just print a object of this class called cc equals count this example, I just use none. And now, since say CC and execute this as a function. So now, if I run I don't want to print Hi there. So, what I So I say self dot num calls plus equals one, So, I print this is executed and then now this is my man, I also have to return self dot func and now I call the function And now if I say, if I run this and I say Now, if I run this, then I will see this is then I will see. Now this is executed two of how many times this is executed. So this And now let's talk about some typical use implement a timer decorator To calculate the a debug decorator like you've seen before. called function and its arguments, you can fulfill some requirements and the depth the like plug ins, with decorators, you can cache or update the state generators or functions over. And the special thing is that they generate means they generate the items only one at of this, they are much more memory efficient to deal with large data sets. They are a powerful look at some examples. To understand how they function, but with the yield keyword instead call it my generator. And here I can return the yield statement and yield a value. So yield statements inside a generator function. then yield three. And now I can create a generator And now if I print this, and this will only print that this is a generator I can loop over this object. So I can say, this will print one, two, and three. And I the next function. So I can say value equals this will print one, and this will execute the first yield statement. And here, it returns next time if I want to get the next value, say value equals next ci, then it will continue So it runs until here, and returns to and it will print one and two. And if I do it three. And now what will happen if I try to this will raise a stop iteration, because iteration if it does not reach another youth work. And you can also for example, use them So for example, the built in sum function object here and I can print this. So this six. Or I can, for example, use the built here. So this will return. This will create in a sorted order. So for example, if I have then with this, I can sort it again. And then have a closer look at the execution of a generator generator, and I call it countdown, and it of all I want to print starting. And then the num. And then I also want to update the then I create my generator object. So I say to start at four. And now if I, let's first not print starting here, so nothing will be to get the first value with, let's say, value Now if I run this, then now it will start it. So this will print starting, and then statement. And here, it will return the number print the value. And then it prints four. here with again, with this next statement, it will continue here, it will remember the then it will update the number now the numbers loop. And then it stops again, at this line, this will also print three, and then again, continue, it will continue from here, and times. Again, if I print next, then it will and now it will raise the stop iteration. let's have a look at the big advantage of memory efficient. So they save a lot of memory means is, let's have a look at an example. n and it takes a number as input. And this starting from zero all the way up to n. So list call it nums equals an empty list, then your start number and then you say while num you at the current number to a list then you plus equals one and at the end, you will return say for example, I can say my list equals I can simply print this so now this will print And for example I can also calculate now the here with this way, all the numbers are stored in this list. So this takes a lot I can say I define another function first takes as input, and now I don't need the list also the while loop while num is smaller than So I yield num. And then I also have to update So this is the whole implementation of this example, also print the sum of this first this will give the same result. And this will all the numbers inside this array. So I can if I analyze this, I can import sis. And now see size persists precice dot get size of this object in bytes. And again, here, I also So first, I print the size of my list object. object. And here we see that already, the say I don't have 10 numbers in here. But let's the same number of elements in here, then So and use cases like this, the generator another advantage of the generator object elements have been generated before we start get the very first item with the first next all the numbers. Yeah, so this is the big look at another example to practice the generators. So we say define feeble, not cheap. And this And the Fibonacci sequence works like this. and then all the following numbers are a sum zero plus one is one. Now one plus one is then we have five 813, and so on. And to implement to store the first two values. So we say a while a is smaller than our limit, we yield a and then we update the current value. So same line, we update the B value, and now of the previous two numbers. So we say a, b equals B, and so a is B, and B is a plus the Fibonacci sequence. And now we can say limit for example, like if it 30 and Now I i in fib, and then print I. And now we see this limit. And now as a last thing, let's expressions are written the same way, like instead of square brackets. And this is a some generate to implement the generator expression. I use parentheses and here I can use an expression in range, for example, 10. And I can also two equals equals zero, so this will put all to nine in a in my generator object. And so this object, so I can say for i in my generator, and eight. And this is similar to the list the same way, except that they use square So I can say, my list equals this expression. print the same sequence as a list. And by object to a list with the list function. So will do the same thing. And again, let's analyze get size of this object. and here also I want they here they are almost equal. But let's again, my generator object is much much smaller and multi processing, you can run code in tutorial, we will learn what is the difference and disadvantages of both how and why threads use the built in threading and multi processing or processes. So let's start with the difference is an instance of a program. So for example, is one process. Or if I'm running one Python a thread on the other hand is an entity within threads inside processes take advantage of your code on multiple CPUs and parallel processes not shared, but between processes and they means for example, if you have to, if you a lot of expensive computations for them, As the data on different CPUs and this way independently started independently from other and killable. And there's one Gil for each And I will come to the Gil or global interpreter So process is heavyweight. So it takes more, is slower than starting a threat. And since memory sharing is not so easy. So the so called And now on the other hand, threats, so as that can be scheduled for execution. And it's process can spawn multiple threads. So all And they are lightweight. So starting a thread are great for IO bound tasks. So this means program has to talk to slow devices, like with threading, your program can use the time switch to other threads and do the processing up your code with threading. But on the other the Gil allows only one thread at a time. in multi threading. So threading has no effect and kill killable. So be careful with memory memory, you have to be careful with race conditions. or more threads want to modify the same variable cause bugs or crashes. And yeah, that's the And now I mentioned a couple of times the is also known as the global interpreter lock. one thread at a time to execute. And this But why is it needed. And this is needed because Python implementation that you get when you So the gala is needed because in C Python, safe. So in C Python, there is a technique that is used for memory management. And this a reference count variable that keeps track the object. And when this count reaches zero, And the problem now in multi threading is protection from race conditions where two So if this happens, it can either leak, it Or it can incorrectly release the memory while this is the reason why they introduced the Gil. And a couple parallel computing is to use multi processing implementation and not c Python. So there's, you can use Python, Python as a wrapper for it's it works in NumPy artists Sai pi modules. that then call code that is executed in C. jump right into code. So let's start with say from multi processing, import a, the process processes, where I will store all my processes. a good number usually is the number of CPUs and then we say num process processes equals are four different CPUs. And then I will create say, for i in range, num processes, P equals arguments. Now the first one is target and object or a function that is then executed a function here. So I say, let's define this say their square numbers. And here, I will i times i. So this is a dummy example, that's show you to show you how to use different process should execute. So I say target equals some arguments, so then I would also need Give the arguments here. So in this case, And then I say processes dot append, my process. say for p in process, and then I say P dot So I say for P and process, P dot join. So to finish. And while I'm waiting, I am blocking all processes to finish. And I blocked the So now at the end, I can for example, simply point when all processes are done. And now also import time and tear. Just to show you the different processes, 0.1 and now I am having a look at the activity filter for processes. So I say I filter for two Python processes running, they all have also shown how many threads are inside my file, then we will see what will happen. So five Python processes coming up. So this is processes I created here. And now after a will disappear again. So we can see that there on my machine. And this is how we can use multi threading. So the threading API is very API. So here, I say from threading, import and num. Now I call this number of threats. threats. And then for i in num threats, now arguments. So it also has to define a target. I would also have to specify the arcs here. then I will start each threat. So I will say them. So I will say for T and threats, T dot manager again. Now if I'm running this Python Now we will see one process coming up with the 10 child threads that I created here. disappear again. So this is how you can use In this video, we will go into more detail recap how we can create and start multiple data between threads and how to use locks what is a daemon process and how we can use let's start and let's quickly recap from the So this is the code where we left off. So here we define a num so we want 10 threats each threat, we give them a target method. by this threat. And then for each threat, also threat dot join. So join means that we is complete. So yeah, this is how we can can into more detail. And let's talk about how threads live in the same memory space, they sharing data very easy. So we can for example, define a global variable. And in this case, will set this to zero in the beginning, so in our main code, what we will do is, we will So we print our database value here. And then one equals threat. And this will get a target threat a second threat. So threat to that we say threat start. And also, threat join. thread two dot join. And at the end, we print print a database value at the end. So and So we say define increase in here, we want in order to modify the global variable, we we can use it here. And now let's make some access, we want to get the value from the we say local copy, equals and here, we can then we want to do some processing. So here, so we want to increase it. And then we simulate time. So we import time. And then we wait And then when we are done, we want to write simply copy it back and say database value function. And now let's run this. So now we And if we run this, let's clear our console. value is zero, and end value is one. So now we have two threats. And both threats should value should actually be two. And now why condition here. So a race condition happens the same variable at the same time. And now here. So when we say thread one dot start, it in a local copy. So in the beginning, this copies. So now our local copy is one. And can intelligently switch to the other threads to threat number two. And now thread number copies the database value in the local copy. zero because we didn't write it back here. is zero and then it increases it's to one can switch back to threat number one. And that is one into our database, and then it's two again. And that now also copies its local value. So this is why the end value is one. we use the lock object. So we say from threading, So we say lock, dot lock equals lock. And So we have to give this year in the arguments. is a tuple, with only one element, we also here in order to know that this should be this will now get the lock as an argument. another threat to access this to access this say lock dot acquire. So it basically has acquire. And now we can process and modify we say lock dot release. So and we should have to release it. So Otherwise, this will here. And now what is happening with this this works. Lock dot acquire. So Oh sorry. This is a lock see that it's correct, our end value is two. got here. And since it locked the state, now back to our threat number two here, because it continues and runs and copies the local then it releases the lock. So now our second gets the database value. And this is now already it back. So now this is working fine. And to say lock dot release. So there's a recommended as a context manager. So you can simply say the code here. And then we don't need to say this. So if we run this, then we see this acquires and releases the lock for you. So let's talk about how we can use queues in safe and process safe data exchanges and data environments. And for this, we simply we have queue. And now let's get rid of this. And working. So a queue is a linear data structure principle. So a good example of a queue is where the customer that came first is also So we say q equals Q, and then we can put and Q dot put to two. And also, let's put And now our code looks like this. So first, two, and then we put in the three. And here, queue. So now if we want to get the first q dot get. So this will get and remove the will print one. And now our thread, our queue how the queue principle is working. And there important methods. So first, you can check will return true if the queue is empty. And you get a object with queue dot get, and then processing, you should always call queue dot we are done processing with this object and also a Q dot join method. So this blocks until processed. And this is similar to the thread main thread and wait until all the elements the important methods you have to know. And use this. So we say Um, also, we want to define equals 10. And then we say for i in range, So now we say threat equals threat. And as will define this in a second. And then we use a demon threat. So we say threat dot demon will do in a second. So by default, it is our function. So our function, let's call up here. So we say def worker. And now we and then we say value equals q dot get. So the queue and also a lock. And here, we will Q dot get and then we will do some processing print the values so we say print and let's import current threads, so we want to print say we are in and then we are in our current the value. So we simply want to print this to say q dot task done. And now what this now starting. And since we don't have values and wait until items are available. So now with elements. So we simply say for i in range, with all the numbers from one to 20. And we have to say q dot join. So we block the main have been gotten and processed. And yeah, this code and see what's happening here. And no, let's leave this lock, and only gave it it in a tuple. Again, we give it the cue and And now let's run this and see what's happening. we see that we have threads with different threads. And they get the values from our order might not be sequential. But what is easily exchange the data in a thread safe call is thread safe. And also the queue put can write at the same time into this queue in this time, we, this time, we got lucky, here is that multiple threats might try to print statements that are in the same line. line break. So to make it work correctly with So let's also give this a lock. Let's say it also gets the lock. And now this should statements. And yeah, let's have a look at a demon threat. So we are our threats, entered because we have no items inside our queue. it can continue here and process the items. all the items are done, we can continue here and print n main and then we will leave the ground threat that will die when the main have an infinite loop here. Why do we Why and main and then it's it's done and I can thread dies when the main thread dies. So main thread, then all the threads die. And no longer gets invoked. And this is why we is false. And if we don't use a demon threat here in our wild true loop. So, what we should for example, some some signaling mechanism and we can exit the wild true loop. So then and then break. So yeah. In this video, we will go into more detail quickly recap how we can create and start we can share data between processes, and we conditions and how to use queues. And at the to easily manage multiple processes. So let's video how to create and start processes. So And then down here we define a number of processes. of processes on your machine. And you get create your different processes with process a function argument and the target is a callable by this process. So we define a function appear, we give this to our process here. And then And also process dot join. So this says says finish and block the main program until all need to set up multi processing. And now let's about how we can share data between processes. we learned that we can easily share data between processes, processes don't live in the same the same public data. And because of that, share data. And there are two shared memory for a single value, or we can use an array. and import array. And down here, let's first shared number. And this is now a value. And give it the data type as a string, so we give This is no cirro. And first of all printers we say we access this shared number with or now if we run this, and we see that this is should modify this number. So we say process a function that we call at 100. So let's define this gets a number and then it should modify i in range 100. So 100 times it should say should increase this by one. And we also want So we say, time dot sleep and 0.01. And so and it also needs arguments. So we say art it this shared number. And be careful. Since needs a comma here so that Python knows that process that will do the same thing. So process And then we say process, one dot start, and them to complete. So process one dot join, and process to the chain. And now at the end, at end is and then access it with share number happens. So the beginning is 100. It's zero. second time. And now it's not 200. So it's condition happened. And I will not explain previous video. There I explained in detail occurs when two threads or processes try to access and modify the in this case, both processes try to read and some operations might get lost here. So in we must use a lock. So we say from multi processing, in the last video, so please check this out. this at the same time. So to use this, we lock. And then we give this to our function lock. And a lock has two important methods. at the end, we say lock dot release. So as this in a locked state. So this means that access to this code and can execute this part again, with lock that released and the second all we need to prevent multiple process to run this. And now we get 200. Let's run this way to use locks is to use locks as a context you always have to call locked release, then your program cannot continue. So don't forget manager. So we say with lock, colon, and then and release this for you. So yeah, this also single value. And now let's share a array. also needs a data type. So in this case, that's as initial values, so we say, put in 0.0, array, at the beginning is, and let's say element with inside brackets and then with to access all in the indices. So let's just this at the end. So at the end, we want to this. And now we have to change our functions, takes numbers. And then we have to go over of all, let's also change this parameter here. in our function, what we want to do is we But be careful here. So we cannot say for plus equals one. So now if we run this, this at the end, and this is still the same. And a local variable called number that is then our shared value object. So in order to do i in range, and then the range has the length with numbers, dot i, and save plus equals that it got modified. But we also have race So we say with lock, and then our modification operation. by 200. So this is how we can use the shared a queue to exchange elements between processes. video. So a queue can be used for process we set from Q, import Q. And there, we have was formed from the multi processing module. the tasks done and the tasks and the join that follows the first in first out principle. queue, that is then also the first element So let's make an example to use a queue and So in this case, let's say q equals Q, and access and write to this queue. So we have a function that we call square. And as arcs we curate a second process that has In a second negative, and it has the same arguments. So define our functions here. So we say that and Q. And then we say, so in this case, for put it into our Q with Q dot put i times i, And there we also it also takes some numbers for i in numbers, and then we say q dot put start our processes. So pros, one dot start, one dot shine, and process two that shine. because there is no methods cue that join. is not empty, so while not Q dot empty, and q dot get. So this will return and also remove now let's run this and see what happens. numbers a numbers variable. And I will say this is should be included. So I say from one to six. we see that both processes have access to put elements into it. And then in our main get the elements back. So this is how we can let's talk about a process pool. So a process So a process pool object controls a pool of And it can manage the available processes smaller chunks, which can then be processed have an example how this works. Basically, So you don't have to consider a lot. So we pool. And then down here, we create a pool. And it has two or four, let's say it has four for the rest, I would recommend to have a a lot of more methods but the most important we want to do is we want to create multiple function. So we call define a function cube. So it will will return number times number or we create some numbers. So numbers equals to nine. And then we say, pool dot map. And so we give it the cube, and the numbers. And print. So print our result. But first of all this will automatically allocate them the you and create different processes. So typically, have cores on your machine. And then it will sized chunks, and submit this to this function. by different processes, or by different processes. the pool will take care of the rest. So this data and then run this method in parallel. And we have to call pool dot close. And then we want to wait for the pool to process all we have to remember that we should call pool we can print our result and we can see that we can easily use the the pool to run different processes with a function. executed by a pool, then we can say pool dot this case, it will only has one number year. first element. So number zero, so this will execute a process yeah, so this is the most important things calls to this map and apply functions, but we will learn what is the difference between Then we will talk about positional and keyword variable length arguments. So what are the talk about container unpacking, we will also local arguments inside of functions. And finally, to functions and if they can be modified within talk about the difference between our arguments that are defined or used inside parentheses the values passed for these parameters while Let's say we have a function called print print this name, then this name here is our let's call print name with a string LX. Then there is a difference when we talk about them. arguments. So we can pass arguments as positional function as an example. So let's say we have A, B, and C. And we simply want to print them with positional arguments. So we can say foo, will print 123. Or we can also use keyword two, and C equals three. So this will also then the order is not important. So I can and a is the first one that is printed. So and not 123. Like I like the orders here. the keywords matter and not the position. a positional argument first, that's a one equals two, and C equals three. So this will argument after a keyword argument. So if I an error. And also, if I try to assign a a And now if I use a as keyword argument, then the difference between positional and keyword to use keyword arguments, because it makes rearrange the arguments in a way that makes possibility to add default arguments. So I a default value. So let's say d equals four. with three arguments now, one, two, and three. And let's also print D here. So if I ran it for D. And I don't need it here. But I can seven here. So this will print 1237. Yeah, your function parameters. So for example, to run this, then this will give an error. So probably, you've also already seen functions A B, and then have at this star, and arcs stars and quarks. And now what these are, with one asterisk, or one star, then you can your function. And if you mark your parameter of keyword arguments to this function. And but you can call them whatever you like. So let's print a and b first, and then this is over this tuple and say for arc in arcs, and a dictionary so I can say For key in quarks, of this dictionary entry. So I say quarks example, at least it needs the two arguments I can also use as many positional arguments can use some keyword arguments. So I can, equals seven. And now let's run this. And the two positional arguments one and two, 345. So it prints each number in a different arguments and prints the keywords and the length arguments. And for example, I don't arguments here. Or I can use some more positional Sorry. So this is also possible. Now, let's you want to have keyword only arguments, and example, give a write a star here, and then C, and D. And then I want to print them here, parameter after this star must be a keyword this, then these are positional arguments. to say C equals three and D equals four. And the arcs variable here. And then each parameter So let's say C, and D, and then simply print or for example, to make this more clear, let's print, arc, and then print. Last. So if I sees this parameter only as your arcs. And is missing. So I need another one. And now equals 100. And then it's working. So this arguments. Now let's talk about unpacking say again, fool with three arguments, A, B, let's say we have a list, my list equals 1012. into our function in a function in the function So I can say, star and then my list. So this B and the third into C. And this also works Here. The only thing is that is important match the number of parameters here. So for this won't work. Now if I have a dictionary, it must have the keys with the same names some well you want, then the second B, and you then I can unpack a dictionary with two dict. And then this will also work. But here, the number of parameters here. And also, the here. So for example, if I use e here, then this is how we can quickly unpack a dictionary now, let's talk about local versus global So let's say we have a function. Again, foo. variable somewhere. So we call this number we create a local variable x and access this number, and then let's print let's say number then we can call this. So let's call foo, function, so we can access this number here. number equals three, then what will happen, then what this will do here, this will create different than this global variable. So if to say, global number, and this is the name number equals three. So this will work. So call, then this will print the new value three. write this global here, and we don't have now what will happen if we run this now this So this will Print zero, it prints the number call where we set number equals three. And variable. So this has nothing to do with this lifts inside your function. And it will not to modify the global one, then you have to print three. Yeah, so this is the difference talk about parameter passing. So maybe you've call by reference. And in Python, it's a little is known as call by object or call by object be considered. So parameters are passed are No, sorry, the parameter passed in is actually is passed by value. And there is a difference So this might be a little bit confusing. But like lists or dictionaries can be changed in the method, then the outer reference will not changed. And immutable objects like integers But immutable objects contained within a mutable So let's look at some examples to make this And this takes an argument x, and then it And now let's say we have a bar equals 10. with this bar. And after this, we want to 10, even if we assign X to five here. So because and this is an immutable, immutable type, create a local variable called x here, that same with the global and local variable difference. but mutable objects can be so let's say this list. So we can say a list dot append an item, list. And this is, has three elements one, and then call this function with the list we see the list got modified. So immutable And also immutable objects within a mutable within this list can be changed. So I can first index, so index zero, and this is now change the global list here. And but what mutable reference here. So if I say for example, say 200 300 400. And now I call, I create and then I print it, and it will still print I rebind, the reference here. So this is now and new values. So this has nothing to do now the four points are more clearer. So again, objects cannot be changed. But immutable objects changed. And like here, if we rebind, the will not be changed. And let's have a last how this can affect your list. So first, if items, we can, for example, say plus equals this, and now if I run this, then my outer this. But now if I say a list equals a list, not change the original list. So this is a Because here again, this will create a local So plus equals, again, will change the list. different use cases of the asterisk or star different cases like multiplication and power with repeated elements, for arts quarks, and tuples, or dictionaries into function arguments, containers into a list or merging two dictionaries. cases. First of all, of course, there is the say result equals five times seven. And then the multiplication of these two. Or if I use and then two stars and then a four, this will power of four equals 16. This is one use case, or strings with repeated elements. So let's and then I write one element. So I say, one 10. So this will create a list with 10 elements, list. I can also put in multiple initial items will repeat zero and 110 times. I can also So if I say, let's say a B here, then this So next is to use the star or asterisk for So if you don't know what this means, please So probably you've seen a function that looks foo. And then it has some arguments. And then with two stars. So and then let's print A, this tuple for arc, in arcs, and then print can say four key in quarks, and then print key. And now, I can call this function with the And then for this arcs, I can use as many 345. And then I can also use as many keyword six equals six, and seven, equals seven. So the beat here. And then if I only use one then all parameters after this star are keyword I cannot call call the function like this. argument, so I have to write C equals three, use case of the star operator to enforce keyword for argument unpacking. So let's say I have So 012, then I can call this function and my list. So this will work. And the only thing number of arguments must match the number of parameters here, the number of elements here. So if I have another one, then this with a tuple. And if I have a dictionary, the parameter names as keys, so a and then the value, then I can unpack this dictionary will work. And also the number of elements and also the key, the keys, the name of the So if I have a different key here, then this for unpacking containers, so it can unpack single and multiple remaining elements. So This is, let's say 123456, then I can unpack and then a last value. And this is equal numbers. last. So this will unpack all the elements it will unpack the last item into a single always unpack your elements into a list. So but it will still be a list here. So if I unpack the, or put the star sign for the last into the first element into one number and is now called last. Or I can use this in the middle, and then last. So and then I can print with the elements between so if I run this, also unpack more numbers into single element. Second, last. So this is how we can unpack use the star operator to merge iterables into So for example, if I have one tuple with elements, list, so my list equals 456. And then I can and then I say I, in brackets, I put my first star, and then my tuple. And then I can put if I print the new list, then this will be here. So if I use a set, here, my set, then for lists tuples and sets into a list. Or one dictionary, call it dict, a equals and one, and B and two, and then I have a second the keys C and D with the values three and So let's say my dict equals and then inside then the first dictionary and then comma and dictionary. So this will merge multiple dictionaries then I can see that I have one dictionary use cases of the asterisk sign. This tutorial, how we can copy mutable elements with a built shallow and deep copies. And we will also custom objects. So let's start. And first operator. So let's say we have a variable now if we want to make a copy with an assignment, will not make a real copy, it will only create now both variables point to the same number. this is not a problem. So let's say if we then this assignment will again, create a So if we print the copy, and if we print the deal with mutable types, so for example, a say we have a list here with some elements. with this assignment operator. And then if say we want to change the first item and say both the copy and the original, we see that Here, and this is because this assignment make an actual copy, we can use the built And then we have to make a difference between is only one level deep. So at the first level, copies references of the nested child objects. be an a full independent copy. So let's start shallow copy, we can say copy equals, copy And now if we print both, we see that the copy here has minus 10. And, for example, to make shallow copies. So we can also say also work. Or we can use the list function is also possible. Or we can use list slicing, So this will simply be from start to end. also make an actual copy or a shallow copy. one level deep. And now let's say we have a first lists here, a list inside a list and elements, three, so this is our original list. change an object or an item that is at the so in this list, and then again at index zero, make index one here, so this is this element. now let's see what happens. So if we run this, now have minus 10. Here. And this is because to make an actual copy in all the levels, copy dot, deep copy. And now if we run this, So this is the difference between shallow like lists, dictionaries, or tuples, we can for custom objects. So let's say we have a the in it, it gets self Of course, and then self dot name equals name, and self dot age, person one equals person. And now as the name now let's make a copy, simply by assigning one. And now if we change person two, dot two dot h, and we also print person, one dot this is not an actual copy. So here, we can see we have a shallow copy here, so the original if we have a deeper structure, so let's say, and let's say we also have a class company. in it, self and now this gets two persons, boss equals boss, and self dot employee equals one boss, so boss, might be older. And now a second person. say we want to have a company so we say, company person too. And now if we want to make a clone company, or let's right away, make a shallow if we change some variability here, so let's say company clone, dot boss dot age, equals clone dot boss dot age, and also print the let's say company, boss, ah, then again, we shallow copy, and the age is at the level the reference here. And in order to make this copy, and now if we run this, we see that difference between shallow and deep copying. managers, and what are they used for, we will managers and how we can implement our own a great tool for resource management, they precisely when you want to. So a well known order to open a file, we can say, with open, stuff. txt. And we open it in write mode, our width statement, we can use this name something into our file, some some to do. again, this width statement or just context our file again, even if there is an exception this as a full code, it would look something then note stuck text in write mode. And then our file. So write some to do. And now we executed with or without an exception. So executed every time. so here we can say file, is freed up again correctly. So now if we statement looks much cleaner, and much, much to open a file. And this is a typical example open an AI file and allocate the resources. to correctly free up our resources again. with open statements, then, for example, to typical example is the lock. So if you've and multi processing, you already know how say, from threading, import, lock. And now So whenever we acquire a lock, so we say lock and then we can do something here safely. we always have to call lock dot release. And here, and our program won't continue. So never locked out acquire. So a better way to do lock, and then do something here. This will this with statement and then it will make this with statement again. So this is also can implement a context manager for our own implement the ENTER and the exit methods. file. Now of course this has an in it and store the file name, say self dot file name, the same functionality as With the with open is done. So, now what we have to implement So this will get self. And then we have to get self, and then it will get an exit exception, trace back. Now, I will talk about this in both of them. So, the Enter methods will be So, here we want to allocate our resource. to have a look at where this will happen. self, we create a file and say self dot file it with the file name, and open it in write we want to return the allocated resource. And now in our exit methods, we want to make we say if self dot file, so if this is not And then print, exit. And here, let's print this class as a context manager. And now we can say, with Managed File, and this will then we can say file dot write, some to do. So this will, let's also make a print statement we see here, that init method gets called as we enter this width statement, the Enter our resource is allocated, then we can do is called as soon as we leave this with context So now let's talk about what will happen if Python passes the type the value and the trace the exception here. And if anything other then the exception is raised by the width here. So in order to see if we reach this example, let's print, we want say, exit exception, exception value. So now if we run this, we exception here, exception type, and the exception here, this that won't work, so let's say file our class here, so it doesn't notice some So now if we run this, then we see inside file even if there is an exception. So it chat exceptions. In this case, it's an attribute this some methods. And then we can exit this raise an exception. So we won't reach this this exception ourself, we can, for example, then prints that here's an exception. So let's And now in order to not raise an exception, return true. And we don't want to print this we did prints exception has been handled, then no exception here from our width statement, So yeah, this is an example of how to write And we can achieve this with implementing functions. But we can also implement it as have to import something. So we say from context use this as a decorator. So and then we will if you don't know, or are not familiar with have a look at my other tutorials, because create a generator here and call this open name. And then here, oh, sorry, I misspelled we want first, of course, want to open our write mode. And here we have to write a try we want to yield the file. So here, we would, we want to write everything that And then we want to have a finally clause method to free up the resource, the resource. need to decorate it with our context manager in a width statement. So we can say, with and then S f and then we can say F dot write work. And now let's go over this again what generator, so this will first make sure to to yield our resource. So and by yielding So we can continue here and use this file. file. And then when we exit the width statement And then the finally clause will be executed, we can handle exceptions here. And yeah, so manager. And that's all I wanted to show you this tutorial and if you liked it, please See you