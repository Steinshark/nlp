Angular 19 was released and like all these major Angular releases and especially like all the more recent major Angular releases, it's both an exciting release that adds significant improvements and new features to the framework whilst at the same time of course as always being super backwards compatible so that your existing code will continue to work, though there is at least one significant big breaking change in that version, but thankfully a change that is simple and easy to resolve. Because with Angular 19, finally, standalone components and directives and pipes are the default now, because it's been a couple of years now actually already since this standalone mode, the standalone flag which you could add to components and to directives and pipes which changes how you build your Angular application and how you structure it, since that was introduced. It was introduced with Angular 14. Now with Angular 19 it's the default, which means if you're now creating a new component, it is a standalone component out of the box and you no longer need to add the standalone property and set it to true. That is no longer required. So I guess it's a good thing and I had my reasons because it was obvious to see that this is the direction we're going to, that I re-recorded my entire course a bit earlier this year with standalone components as the default. So that all is super up to date and reflects how you should build your Angular applications nowadays. The only significant change is that you don't need to add this boilerplate property everywhere. You don't need to set standalone to true anymore. And of course that's now the case in all Angular projects if you're using Angular 19 in there. Now what does this mean if you're using modules though, if you don't use standalone components? Well you can still update of course. And if you do it with the ngUpdate command, which is the recommended approach of updating your Angular projects, it will automatically ensure that all those non-standalone components get the standalone property and it's set to false there. So it's simply the other way around than before. Previously you had to explicitly mark all standalone components as such by adding standalone true, now it's the opposite, you need to mark all non-standalone components and directives and pipes by adding standalone and setting it to false. And as mentioned ngUpdate will do that for you if you use it so updating is super simple and of course besides that, module-based components and standalone components and directives and pipes will continue to work just like before. It's just that default that changed now. But of course that's a big significant change which shows us that of course the future of Angular is standalone. But in my opinion that has been obvious for at least a year now already, maybe longer because it's simply less code to write and in many scenarios you simply don't need that module-based approach. But if you do need it, you can still use it. So that's the one significant breaking change we have but as you can see it's very easy to resolve and get over it. But what's in Angular 19 besides that? Well there is an official Angular 19 release blog post which I recommend to which you find a link below the video just like you find a link to my course with a nice discount there if you want to learn all about Angular and of course also about Angular 19 therefore. It's all in the course, definitely check it out. But of course I'll walk you through the most important changes in this video here. For example the signals or more signal-related APIs, signal-related features have been stabilized and have been taken out of developer preview with Angular 19. I'm talking about things like the ViewChild and ViewChildren APIs which you could use to query elements in your templates and get back a signal that will of course update when the element updates and so on. I do also cover that in my course and these APIs have been around since Angular 18 already but they're now stable and if you don't use them already you can now use them. The same is true for the APIs related to inputs and outputs which you can also either build without signals with the addInput and addOutput. decorators like you always did, but since Angular 18 you could also use the input and output functions and those are stable and I would say the recommended way of building your components now with Angular 19 as well. And you can also easily update your entire application to use these signal functions instead of the decorator approach simply with help of special schematics that have been added to the Angular CLI. You can simply run ng generate at angular slash core colon signals in your project in your Angular 19 project and it will then automatically get rid of all those input output and view child and so on decorators and use these signal functions instead. So that's also pretty exciting and again leads to a bit leaner more readable and modern Angular code. Of course you don't have to use these features though if you don't want to but just like standalone components signals are also very likely the future of Angular so learning about them and possibly switching to them might make sense. Now in addition to getting all these signal functions like view child and so on out of develop preview and marking them as stable there have been two new functions two new ways of creating signals that have been added with Angular 19 and the first new function is the linked signal function which is arguably for niche use cases I'd say or for very special use cases because it can be used to create a signal just like the regular signal function but unlike that regular signal function you create a signal that you can change like you always can but that is initialized with help of a function which you pass to linked signal and that function can track some other dependency some other signal and if that tracked value changes the linked signal will jump back to that updated initial state so any changes you made to it after initializing it will be thrown away and it will jump to that updated linked state so to say and that can be useful for certain niche use cases where you need a signal that should be changed but that should also track some other value and use that value if it changes instead of your assigned values if that makes sense. The other signal related function that has been added to Angular 19 is the resource function which you can use to essentially track some asynchronous value for example you could use it to send an HTTP request and automatically track the status and the value of that HTTP request in a signal so it can give you a more convenient way of tracking async resources or values with a signal. Now this resource function works such that you pass an object to it and that object must take two methods a request method and a loader method. In the request method you define which other value you might need to track to get an updated async value for example some user id and in the loader method you define what should happen if that tracked value that user id for example changes for example that a new HTTP request should be sent. So it's in the end a convenience function that can help with tracking async value through signals. Now i will say that both the linked signal and the resource API are currently experimental they're not marked as stable yet they may change in future Angular versions but you can definitely play around with them already. Now one other big improvement that comes with Angular 19 is support for incremental hydration in developer preview for now so not fully stable yet. Now the idea behind incremental hydration is that you might have an Angular app where you're using server-side rendering so pages visited by your users and the components used on those pages are rendered on the server and then the rendered HTML code is sent back to the client and if you're using that if you're using server-side rendering of course at some point you need to hydrate the client as it's called which means you have to ship the client-side JavaScript code the client-side Angular code in the end that makes the pre-rendered the server-side rendered page interactive on the client otherwise it would just be some static HTML code HTML and CSS. So that's what hydration is and incremental... Incremental hydration which is new, the other form of hydration has been supported since ever essentially since you need it, but the new incremental hydration means that you can mark areas of your page with the defer feature and a new instruction you can use in conjunction with it and then some trigger that should trigger hydration. You can use that defer instruction in your templates to tell Angular which parts of those templates should be hydrated later and the idea here is that without that feature, if a user visits your website and the page gets rendered on the server, the user still has to download that complete client-side Angular code since, well, it's still an Angular application running in their browsers and it has to download the code of all the components used on that server-side rendered page. If you, however, wrap some of those components with that incremental hydration defer statement here, then the code for that part of the page will not be downloaded when the user initially visits the page, but instead only when it's needed. For example, when that component scrolls into view, so becomes visible and that of course has the advantage that initially your user has to download less code and therefore the page simply loads quicker. That's the entire idea here. So you can mark parts of your pages as incrementally hydrated to hydrate them later if they're not needed initially to speed up your website. That is the idea behind incremental hydration in a nutshell. Now you might wonder how this feature differs from lazy loading, which has been supported in Angular 18 already with the defer statement. And the difference is that with lazy loading, you can load an entire component only when it's needed, which means it will also only be rendered at that point then. So the code for it will be downloaded once some trigger is activated, but then the download of the code starts, the component is rendered and it becomes interactive. With incremental hydration, it has already been rendered. The difference is that the user will not see some placeholder or temporary content whilst the component code is downloaded and the component is rendered on the client. Instead it has been fully rendered on the server. There is visible content. It's just the client-side code that makes it interactive that's missing. And that's why this of course is an amazing feature in developer preview right now, but it will become stable in future versions because it can help you optimize the performance of your Angular powered websites. Now what's super important to understand here is that this feature does not mean that the part that is deferred will not be rendered on the server. It will. So the user will get the entire completed page. It's just the connected client-side JavaScript code that is deferred or where the loading of that code is deferred. The rendering is not deferred, just when this code will be downloaded. And that's the important part here. And Angular actually even allows you to specify that you want to never hydrate parts of your page if you know that a certain component is not interactive, if it needs no client-side code, then there is no reason to download any surrounding boilerplate code, so to say. There is no reason to download the code that could update the component on the client-side if there is nothing that will ever trigger it to change. So you can even mark areas of your page as never becoming interactive, so to never hydrate, to make sure that the code for those areas is never downloaded, hence further shrinking the client-side code bundle, which is of course always a nice thing to have. Now if you want to use this incremental hydration feature, you have to enable it by calling a special function in your application setup process, the withIncrementalHydration function, where the result of calling that function is passed to the provideClientHydration function, but that's all part of your bootstrapping process in the end. And once you call that function once in your application, you can use defer, hydrate, and then define when to hydrate areas of your page to defer the hydration of those areas and to use this incremental hydration feature. Related to this feature and to server-side rendering of Angular applications in general is also the fact that Angular now supports event replay, as they call it, by default, which means that if you're using server-side rendering, with or without incremental hydration, of course, the users of your website will need the client-side code to really interact with the site, right? Because it's still an SPA after getting that server-side rendered page, essentially. Now, of course, if the JavaScript client-side code hasn't been downloaded yet, and the user clicks on some button that has been rendered on the server, of course, that interaction might be lost if Angular wouldn't have that event replay feature, which is now the default with Angular 19, because that feature will ensure that any such client-side interactions will be caught and will be stored, so the button click will be registered and will be memorized, and will be replayed internally by Angular once the client-side JavaScript code has been loaded, which, of course, hopefully should happen within milliseconds after the user clicking the button so that there isn't a huge delay, and as a result, the user hopefully will not even see that there has been a delay, or only a small delay, maybe, and the interaction will be replayed, and things will happen as the user would expect them to happen, which, of course, is also great, but that's not all related to server-side rendering. You see, there's really a lot going on there, just as it's the case in React and Vueland as well, I guess, because with Angular 19, you get a new way of defining routes. Instead of using the route interface, which you would normally use to define your routes, you can now use the server route interface, and that allows you to set a mode on every route to control when that route should be rendered, so when the component loaded by that route should be loaded. If it should happen on the server, during the build process with pre-render, because that's also something Angular supports, not just since Angular 19, or on the client only, and I also cover server-side rendering and pre-rendering in my course, but this feature is new because it gives you fine-grained control over which route should be rendered where if you need that control. Now, if you go for pre-rendering and you want to pre-render pages with dynamic parameters in the URL, where typically you wouldn't know which concrete values will be filled in at runtime, you can also now define a function that will run during pre-rendering to tell Angular for which route parameters it should pre-render a certain page, and that feature would, for example, allow you to statically build a blog, let's say, where you dynamically load all your blog post IDs during the build process with help of that function, and you get Angular to pre-render all these pages, and then you could ship a statically rendered page that contains no client-side code at all if you don't need it. For example, you could use Angular for that now as a static site builder. With that feature, it's easier than ever. And besides that, there have been many smaller tweaks and changes and adjustments, but these have been the big new features. Now, one note regarding zone-less Angular, which is also a thing, because as Angular developers, we're really waiting for the day where we don't need zone.js anymore, which is an extra package Angular uses behind the scenes, so to say, to find out if a user interacted with the website, for example, or if anything else happened that could require your components to update. With signals, you don't really need zone.js anymore, and since Angular 18, you can disable it. I also covered that in my course. With Angular 19, this feature still is not fully stable yet, though, because they're still having some niche cases they wanna figure out. They still, of course, also wanna ensure that it really does not break any applications, but hopefully soon, maybe with Angular 20, we'll see stable support for zone-less Angular applications. But definitely check out the full official blog post to learn all about this update. Check out their upgrade guide and the ng-update command for simple and easy updating. Check out my course, which has been fully updated this year and which is still fully up-to-date with that new version, of course, to learn all about Angular and enjoy this new release.