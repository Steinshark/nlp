&gt;&gt; (Phillip Roberts) hello, come in and sit So for the last session before the afternoon Andea and is here from London -- Scotland. Edinbrough. -- wow, ten second memory, he's going If everyone could give Phillip a big brownedder &gt;&gt; Phillip Roberts: Okay hello everyone, thanks to see it packed out in here. Can everyone give me a stretch. I needed to stretch, so I look less weird. I want to talk about the event loop and what loop inside JavaScript. So first up, as he said I work for AndYet US, look us up if you need help with real-time That's what we're good at. So, about 18 months ago--I'm a paid professional how does, like JavaScript actually work? And I wasn't entirely sure. I'd heard V8 as a term, chrome's Runtime didn't I'd heard things like single threaded, you How do callbacks work? I started a journey of like reading and research started like this. -- I was kind of like JavaScript what I'm a single threaded single concurrent language -- yeah, cool, I have a call stack, an event and stuff. -- rite. I did not do a computer science degree. I mean, these words, they're words, so I heard browsers so I looked to V8 do you have a call some other APIs and stuff, I have a call stack things are, okay, interesting so basically And I think I get this. (Laughing) and so, this is what I want to Hopefully this will be useful if you're relatively JavaScript is so weird when you compare it are a thing, cause us hell but are required. And if you're an experienced JavaScript developer the Runtime you're using works so you can So if we look at the JavaScript Runtime itself This is a simplified view of what JavaScript The heap, where memory allocation happens, where your stack frames are and all that kind code base and grep for things like setTimeout they don't exist in V8, which was a surprise It's first thing you use when you start thinking Hmm ... interesting. So, over this 18 months of discovery I come the bigger picture, this is what I'm hoping what these pieces are, we have the V8 Runtime which are extra things that the browser provides. DOM, AJAX, time out, things like that, we queue. I'm sure you've heard some of these terms how these pieces pull together. So, I'm going to start from the beginning, new to people, other people will get this. We're going to quickly move on from here, a lot of people it's not. So, JavaScript is a single threaded programming a single call stack. And it can do one thing at a time, that's run one piece of code at a time. So, let's try and visualize that just to get some code like this on your left, we've got multiplies two numbers, square which calls which prints the square of a number of calling at the bottom of our file we actually run Make sense? Cool. So, if we run this, well, I should back up it's a data structure which records basically a function, we put something on to the stack, top of the stack that's all the stack can kind of a main function, right, like the file Then we have some function definitions, they're and finally we got to print square, right, push that on to the stack, and immediately which calls multiply, now we have a return when we return we pop something off the stack, to square, return to print square, console.log, we got to the end of the function, and we're call stalk, does that make sense? (Yes, Phil) even if you haven't thought about it when you've been doing browser-side development, which calls bar, which calls Foo, which throws And it prints the stack trace, right, the so, uncaught error oops Foo, bar, Baz, anonymous Equally, if you've heard the term like blowing Have a function foo which calls Foo , so what's which calls foo which calls foo, which calls says, you probably didn't mean to call foo for you and you can figure out where your So although I may be representing a new side in your development practice already. So, the big question then comes is like what So, we talk about blocking and blocking behavior of what is and didn't blocking, really it's So console.log isn't slow, doing a while loop are slow. Image requests are slow. Things which are slow and on that stack are So heres a little example, so let's say we right, like jQuery is like, AJAX request. What would happen if those were synchronous callbacks they're synchronous. If we go through it like we have, we call doing network request, network is relative requests completes, we can move on, wait, Wait, and, I mean, this network request might home. Finally those three, you know blocking behaviors So in a programming language is single threaded what happens, right, we make a network request, we have no way of handling that. Why is this actually a problem? The problem is because we're running code So, let's you -- here we go, okay. So this is just, this is Chrome, this is the Browsers don't give us -- well they do this out with a big while loop, because it's seconds before continuing, so if I open up We can see what happens, so with request foo.com, right, even the run button hasn't finished The browser is blocked, it's stuck, it can't And then all hell breaks loose because I did it couldn't actually render it. Couldn't do anything. That's because if that call stack has things still going. We've got the synchronous request, the browser It can't render, it can't run any other code, Not ideal, right if we want people to have So, how do we handle this? Well the simplest solution we're provided no blocking functions in the browser, equally basically means we run some code, give it seen JavaScript you've seen asynchronous callbacks, Simple example to remind people where we're Code like this, console.log hi. Write, we run the setTimeout, but that queue's JSConf and then five seconds later we log Happy. Basically that's setTimeout is doing something. So, asynchronous callbacks with regards to work? Let's run the code. Console.log hi. setTimeout. We know it doesn't run immediately, we know can't push it on to the stack, somehow it of describing this yet, but we'll come to We log JSConfEU, clear, five seconds later How does that happen? And that's -- this is basically where Right, so I've been kind of partially lying only do one thing at one time. That's true the JavaScript Runtime can only It can't make an AJAX request while you're It can't do a setTimeout while you're doing The reason we can do things concurrently is So, remember this diagram, the JavaScript browser gives us these other things, gives threads, you can just make calls to, and those kicks in. If you're back end person this diagram looks APIs we have C++ APIs and the threading is Now we have this picture let's see how this browser looks like. So, same as before, run code, console log now we can see what happens when we call setTimeout. We are -- we pass this callback function Now setTimeout is an API provided to us by it's extra stuff we time in. The browser kicks off a timer for you. And now it's going to handle the count down call, itself is now complete, so we can pop "JSConfEU", clear, so, now we've got this is going to complete. Now the web API can't just start modifying when it's ready if it did it would appear is where the task queue or callback queue Any of the web APIs pushes the callback on Finally we get to the event loop, title of is like the simplest little piece in this job. The event loops job is to look at the stack If the stack is empty it takes the first thing which effectively run it. So here we can see that now the stack is clear, event loop runs, it says, oh, I get to do Remember it's the stack is like JavaScript on the stack, run, console.log "there", Does that make sense? Everyone where me? Awesome! Okay. So, now we can see how this works with probably had with Async stuff which for some weird setTimeout zero, -- okay, you want me Why would I wrap it in a setTimeout? Like the first time you run across this, if I don't know why. The reason is, generally, if you're trying So we know looking at this, if you've written result, we're going to see "hi" "JSConf", end. We can see how that happens. The setTimeout zero, now it's going to complete what I said about the event loop, it has to push the callback on to the stack, so your "hi", "JSConfEU" and clear, now the That's like an example of setTimeout zero, reason to the end of the stack. Or until stack is clear. Okay. So, all these web APIs work the same way, to the URL with a callback, works the same an AJAX request, the code for running that but in the browser as a web API, so we spin can continue to run. Until that XHR request completes, or it may to run, assuming it completes, gets pushed it's run. That's all that happens when an Async call Let's do a crazy complicated example, I hope all this is in keynote there's like I don't (code blows up, flames animation) (Applause) given a link. Hmm ... is this big enough, can people see? Okay, so basically I wrote this talk for Scotland and could not be bothered to redo all the ass in keynote to do it so I took much easier visualize the JavaScript Runtime at Runtime, So, let's just run this example and, which previous slide, I haven't shimmed XHR yet, As you can see the code, we're going to log setTimeout and we're going to do a console.log. -- I'm going to run it and see what happens so going to continue to run, pushes the callback If I click on here then it's going to ... trigger and run it. if I cluck a hundred times we can see what I clicked, the click doesn't get processed as the queue gets processed, eventually my So I have a few more examples I'm going to Here we go, okay, so, I'm just going to run about a few things that you might have run In this example we call setTimeout four times "hi". By the time the callbacks get queued... that delay, and it's still waiting, the callback this illustrates the -- like what time time to execution, it's a minimum time to run the code immediately it runs the code So ... in this example I want to talk about and how they phrase things, callbacks can function that another function calls or callbacks as in one that will get pushed back on the This bit of code illustrates the difference, The forEach method on an array, it doesn't call a callback, but it's not running it asynchronously, We could define an asynchronous forEach so item in the array it's going to do a setTimeout pass in the value, but any way, so, I'm going is, so for the first block of code that runs, Until it's complete, whereas in the Async basically going to queue a bunch of callbacks actually run through and do a console.log. In this example the console.log is fast, so not obviously but let's say you're doing some I think I have that shown somewhere no, no, Okay. So let's say -- Ooops. So I have a delay function which is just slow, So ... let's say processing Async and here Okay, now, I'm going to turn on a thing I've is to simulate the repaint or the render in is how all of this interacts with rendering -- explained it. So, basically the browser is kind of constrained would like to repaint the screen every 16.6 that's the fastest it will do repaints if But it's constrained by what you're doing actually do a render if there is code on the Like the render kind of call is almost like It has to wait till the stack is clear. The difference is that the render is given 16 milliseconds it's going to queue a rend, actually do that render. So this is -- this render queue is just I do a render? Yes, can I do a render? Yes. Where, because our code isn't doing anything If I run the code, you can see while we're array, our render is blocked, right, if our the screen, you can't click things and see earlier. In this example, okay, it's blocked while quick but we're given -- we're kind of because we've queued it up asynchronously make sense? &gt;&gt; Yeah So, that's just kind of -- this is just but it just really shows you when people say what they're talking about. They're saying don't put shitty slow code browser can't do what it needs to do, create This is why when you're doing things like gets sluggish if you're not careful about So an example of that, we can see with the like scroll events in the DOM trigger a lot, they trigger on every frame like every 16 right. On document.scroll, animate something, or If I have this code, like as I scroll it's right. And then it has to go through and process those is slow, then, okay, you're not blocking queued events. So, this is like just helping visualize, I all these callbacks, there's way you can debounce queue up all those events, but let's do the stops scrolling for some amount of time I There's a whole other talk in how the hell Because basically in running the code, like slowed down by I run it through a Esprima loop, that takes half a second, it just slow Ship it to web worker and do a whole bunch doing it at run time that makes sense. A whole other talk in that. I'm super excited about it and will talk to kind of neat, so with that, thanks very much