I've been feeling quite a bit stuck at my programming adjacent day-job lately. Which led me to the misadventure known as the software job hunt in year 2024. So to prove some basic computer literacy, and add yet another non-consequential I embarked on a quest to make By the way, the game is already available, source code up to the end of the video too, so check it out if you want, So the basic idea is one on played on a 2D grid, where players move their tanks around the board, and try to shoot the opponent. Instead of squares, I'm going to use the clearly superior hexagonal grid. And I want to limit players' field of view to some radius around their vehicles to add a level of uncertainty. The map will also shrink as the game progresses to prevent players from stalling. About the graphics for the game: I decided to go with the I like this style, and some time ago I made a simple 3D renderer and some low poly desert theme models which I then used to generate If you don't know what sprites are, they are series of images that you can alternate to create an illusion of movement. The client side of the game will work in the language of the browser, javascript. But because I don't want to succumb I'm going to write it in typescript. For that I will use &lt;canvas&gt; HTML element, which provides an API to draw text, images or even 3D scenes onto the screen. And for the server side, I'm going I'm not going to use any because I'm doing it more for the but I'm going to use the which at the moment is the de facto So to start off, I opened my favorite editor and began to work on making the canvas responsive, so that game keeps resizing with the window, and doesn't get blurry when user Next I worked on actually making the Canvas provides you with a drawImage function, that basically copies a fragment of some image, and pastes it into a specified area. So beforehand I packed all my and prepared a long list of start, size so that I can copy them out, use the offset to align them to the grid and construct the map, one element at a time, repeating this process on every frame. Next I added the first bit of which is not too complicated and involves using just a With that some final elements of with GameState object holdng all the Display driver drawing them, And Game instance managing it all. Next piece of the puzle will be Grid component, that will manipulate game objects based on user actions and server messages. After implementing dragging, I worked on zooming. The sprites must be scaled by natural which means the initial zoom That's why I prepared sprites so that by interleaving them, So far when implementing dragging and zooming, But to manipulate tanks, I need a way to translate between coordinates on the This was a little bit harder than I expected and I was glad to come upon this nice website dedicated exclusively to hexagonal grids. With that I was ready to Users can perform two actions with a tank, either moving it, or shooting Moving is carried out by pressing on and shooting by pressing it down a tiny bit The range of a single move so players don't traverse and same will be for the range of a shell. After that I started working One is limiting players' field so that players can only see action happening inside some radius around their tanks, and distant parts of the map are darkened out. The second feature is drawing that tank is allowed to move into, with regard to the current path and obstacles. It will be actually two different markers, green one taking neighboring tanks into account, and a yellow one ignoring them. Both can be calculated with a Then I began working on the UI system. To display buttons on canvas on screens with different sizes and aspect ratios, I will need some substitute for CSS grid. I came up with the idea of invisible panels, that will be resized and and will act as an intermediate They will be defined in two variants, Implementing buttons from scratch because in HTML DOM or UI libraries, you usually work with complete But in this case, the buttons are just some painted area of canvas, so I will have to work my way up from simple primitives 'pointerup', And clicking a button isn't but rather releasing while hovering. And it's by desing, because that by moving the cursor out before release. It gets more complicated with We don't want to trigger a button, when we are navigating the map, and likewise, we don't want the grid to when we interact with UI. So I added some basic in-game In the result adding two more the UI system, drawn by display driver, And the Notifier, that will pass button and other game Up next was finally writing some server side code. I set up a file server to serve static For now I wanted the server to resolve them, and send back the results to client. Of course I could write my but I'm going to keep things simple The websocket driver object on the client side will be responsible for exchanging messages and notifying game of any updates. As you can see the system and correctly resolves them. As you can also see, the frontend is devoid of animations right now, and final result is displayed I will tackle that later, because I'm going to implement shooting first. For that, I again need to touch server side code, add some constraints for how check it's path for any buildings and tanks, and if there are any, stop it early and if it destroyed something, tell that to the client. What else I'll need is without that, everyone could have a wallhack, and see all the opponent's moves on the map. And here is the result. Not only tanks can drive, but they also get destroyed when hit now. Enemy vehicles in the shadows stay invisible, but still no animations. So let's do that now. The animations are probably the They also add a lot of unexpected complexity, because now I need to track time, correctly rotate tanks, turrets, interpolate positions, also the movement itself can You can keep it simple with constant speed, and sharp corners, that will only involve some But you can also round the path a little bit. And add acceleration on start and Or even add acceleration mid-drive, to Working with acceleration and but in this case, it's just Here is the final result. I also added explosions, these are just sprites too. I have two player matching You can create or join your or you can enter an open room, and Getting the code from the we could just register the keystrokes. But I want the mobile compatibility. How do I take input from mobile player, using just canvas element? Custom virtual keyboard, is an So I'm going to cheat a little bit, and introduce an actual HTML and style it to blend nicely. That breaks my abstractions a At this point I was quite surprised and started the hardest challenge of this project, namely the actual server side Because I'm writing in Golang, I decided to abuse channels for the Player What I got was a pretty messy where I had to track which and which do not. I added state machines to make and spent some time looking The resolution of players with input from two players and while the logic might seem pretty simple, there is a lot of checks I have to Just for the move action, I need to I need to check if the tank or a building, or it doesn't go through empty space. I need to check if path is continuous. If it doesn't exceed allowed range. It the tanks is not already destroyed. And I need similar checks and also need to account for So there is a lot of a bug potential here. There is also a lot of room for optimization too, some loops may be redundant, some things could be represented as bit masks, but that's not today's concern. Writing this core multiplayer Of course it's not production ready yet, but the important thing is that two users can now play a game between them on two different devices. At the start of the video I said that map will shrink throughout the match, and I haven't done that yet. Each game config will have causing every hex and tank in some radius around the center to dissolve. Otherwise players could without ever engaging in a fight. By the so far I had neglected such as room or server disconnecting, or even the final result, so I tackled that as well with I also refactored the Game the complexity was getting the best of me. The game still lacks any sounds. And I'm not going to create a soundtrack. But some sound effects, especially explosions, would be desirable. So I pulled some .mp3's of a german Leopard tank and explosions from zapsplat, pushed some random buttons in Audacity, and saved them as a single .mp3 file. I then encountered the AudioContext which was not too intuitive at first. Anyway I managed to put it to use, hopefully without causing any memory leaks. Almost done, I added the last I remembered seeing a video to simulate wobbling of the tree and I thought it can simulate ground The idea is to take a sine function, transform it with some random coefficients, repeat for couple more, and sum them Then make a second one and clamp and map as X and Y coordinates, And with that, I'm going to wrap it up. A linked the github in the description. I also deployed the game and To make that happend I added some things that are out of the scope OAuth2 persistent DB rate limiting landing page but also quick tutorial, single player mode, more explicit markers on tanks, HUD with game information and github like avatars, rotating tank in the main menu, speed up button, pinch gesture for zoom on mobile, and probably some more But let's talk about what I did NOT do. I don't own any apple devices, when I tested the game with and it got disconnected on every window change. Turns out that iOS aggressively throttles websocket connections in the background. I tried to make a not very reliable workaround, by reconnecting on the client side, and sustaining player's session But surprise surprise: The iPhone closed the connections with different exit codes, different delays, after resuming window session. So this hack went out the window. The correct way of handling preemptively close and open websocket connection on every window visibility change, but that would mean rolling this out for everyone, because there isn't a reliable And that's a worse UX for many users, I might give it some more time For now thanks for watching.