[music] Hey folks! My name is Addy Osmani and welcome Today we're going to talk about with a case study on Chloe have recently been taking and I'm really excited Now, you may have seen an upcoming search ranking change recently that incorporates Now, these metrics which, together with a few other signals, paint a pretty holistic picture about the quality But, what are the Core Web Vitals and how do you go about Well, Core Web Vitals responsiveness and visual stability. Now these three aspects of user experience So first of all, which measures loading performance. Next up, we have First Input Delay And last, we've got which measures layout stability. Let's kick things off by talking about Now, CLS is a pretty important metric because it helps quantify all those times when we see really surprising shifts and it helps make sure that the page Have you ever been reading when, all of a sudden, something and without warning the text moves That's literally what happens, a giant chicken kicks your content away. And he has no regrets, look at him. He's basically CLS. So, what causes poor CLS? Well, first of all, we've got ads, embeds or iFrames dynamically injected content and web fonts that might cause a flash Now, as I mentioned, and it's become a bit of a go-to brand but also handbags and fragrances And they have recently been focused on all their main pages, so their Home Page, and their Product Details Page. Through a bunch of work all the way down to zero So how did they get here? This is the before view where we can observe due to elements on the page So, let's dive into a few tips First off, always include on your images and video elements. Alternatively, you can always do things with CSS aspect ratio boxes, but, in general, this approach can allocate the correct amount while the image is loading. So, here's a demo of this in action. These are some images that don't have and what you see happening is that they're pushing content This is something that's reflected I've got a little bit of a clip out here, where CLS is in the red So, how do we address this? Well, in the early days of the web, developers would add all over the place, they'd add them they make sure that they kept before browsers That was great because it would Now, when responsive web design developers began to omit and they started to use CSS One of the downsides to this approach is that space could only be once it began to download. And, you know, at that point the browser As images load in in that old world, you know, the page would re-flow as each image appears on the screen, and a lot of us got used to our text which wasn't a very great user experience. And this is where aspect ratio comes in. So, the aspect ratio of an image it's pretty common to see this expressed So, for example, 16:9 or 4:3. For an X:Y aspect ratio, the image is X units wide What that means is that the other one can be determined. So for a 16 to 9 aspect ratio, if dress.jpg has got a 360px height, the width is 360 multiplied by 16 over 9 which gives us 640px. I'm not very good at math, Now, modern browsers now set based on an image's So, it's really valuable to set them This is a change in modern browsers, and it's all thanks They've done some work to just set width and height as normal, and this calculates an aspect ratio before the image has loaded. So, what we're seeing on screen here, this is something that's added and it calculates aspect ratio based on the element's So, as long as you're providing the aspect ratio can be calculated and everything will hopefully so this is a great best practice This is also something that works well With <i>srcset</i>, you're generally defining to select between, you need to find To make sure that your image just make sure that each image And here's that demo once again Notice that in a modern browser and the user will get So, another reminder, set those width and height attributes Here's the impact As we can see before, so we're in the red, all the way back to something There are one or two other things but on the whole we've had on reducing layout shift. You might be wondering, &quot;How can I figure out are contributing to CLS?&quot; We've got you covered. So, in Lighthouse we have that highlights the top DOM elements so check out that audit. In dev tools-- so, if you're using it has an experience section unexpected layout shifts, super helpful for finding They get highlighted with some kind of reddish pinkish And if you click on one of those records, about what was the score, really great diagnostics to help you So, Chloe's approach to image loading with a Sass-CSS Mixin Bruschetta is one of those things that are a little bit of a luxury They're right up there but let's stick with bruschetta loading. So, this is Chloe's approach They have a parent container that's being loaded. Lazy loading strategies like this, where you have a little bit of a preview are sometimes referred You can use a predominant color you can use a low resolution image. Sometimes people will use or something like 10 pixels by 10 pixels, something very low resolution of what's finally going to be displayed. Now lazy loading strategies like this which either use a color they don't strictly improve but they do improve perceived performance, so they can still be pretty good Now, what Chloe did here in addition was that they do use responsive images and they do make sure on their images as well to avoid CLS. Let's shift the things up, Let's go on to the next tip. So, reserve enough space things like ads or promos. Ideally, you want to make sure that you are giving that it's not going to just, and suddenly cause shifts in the page. A related tip to this one is, avoid inserting new content unless it's in reaction You want to make sure are ones that you are making and like occur as expected. So let's try to visualize this. Here's an example of a promo where we're dynamically we haven't reserved space and it's just pushed everything We can see this reflected at the bottom of the screen. Now, this is something with ads, iFrames, promos. And these types of assets to layout shifts on the web. Now, many ad networks and publishers and ad sizes that are dynamic are something that can because you're giving people around what can go inside there, but it can also be something the user experience So, that's something So, how do we approach this? Well, one solution to the problem is statically reserving So, you can make sure for these ads or embed frames, you're not shifting the content So, here I've got a container I've set a background color just in case anything dynamic is a little bit, you know, I still don't want it Ideally the content fits inside like our iFrames or whatever else And what you can do if you're somebody that gets injected into your page, you can take a look at your data, look at what are the medians widths and heights and size your container accordingly. That'll just mean at still being able to present without negatively impacting So, here's what it looks I've reserved enough space, but there are no layout shifts in the page. So, I'm really happy about that. Slightly better is my baseline So, this is the Lighthouse 6.0 impact, we can see that we reduced from 0.24 all the way down to about zero, I'm going give myself So, that's great. Let's talk about a production example Chloe had a promotion banner for shipping at the top of their Product Listing Page. And you'll see this free standard but this wasn't always there. There was a time had a CLS of 0.4 which is really not great The first was the way they approached and the way that they approached filters. Let's talk about the banner first. Now, this banner underneath the main page header. And as you can see here, But, what's the impact on the user experience? Well, we have a video here, As we can see here, and rendered for this banner, it pushes the content and that's not very ideal. So, how did Chloe go about fixing this? Well, they reserved space for this banner. The content for this banner was also coming Therefore, messages were causing occurring a few seconds into page load. Now, they moved this API call and they made sure to reserve with a simple height setting. As a part of this work they moved but altogether, like moving more work to the server, and just making sure these things made a bit of a difference. So, here's the after view. Here we can see the impact After these changes have been made, So, I'm happy about that. So, we talked about their promo banner. The other big CLS issue was that Chloe had a filters widget Now, this would rehydrate and so, on the client, was waiting on session state in order to be able to finally So, this is what We wait for kind for the filter widget, and it would still push content What they ended up doing here to contain more of the information server-side they'd rendered it This helped avoid those layout shifts. And I just wanted right of the screen we can see This gives you a real-time view and can just be helpful or you're just browsing the web for the performance of different sites And here's what things look like As you can see, looking at the before and after, and it was just another case of like, pay attention that might be in aggregate Every little CLS fix helps. And here's the overall impact We can see that the above-the-fold content and offers a much better And this is also reflected in Lighthouse. Work on Lighthouse, As we can see here we've hit zero, To improve CLS, Chloe acted It wasn't just one thing. They reserved space for the Promo Content They made sure to set width and they adopted a skeleton pattern They reserved space before receiving messages. And they also reserved space as well as making to just help with rendering. So, on the whole Alright. So, I have We've got more metrics to talk about. Put a lot of work into this slide. Historically, it's been to measure just how quickly and is visible to users. Thankfully, we now have metrics that are able to report the render time that's visible within the viewport. Now, you might be wondering Well, there are lots of things. Slow server response times are a big one. This could be it could be unoptimized database queries, API responses that are just It could be render blocking Slow resource times are another big one. You could have unoptimized images And then, there's client-side rendering. There's a whole class of problems where those of us who love and using modern libraries can sometimes get into a place for assets like images, behind JavaScript fetches. The browser, first of all, Then it has to parse and process And that whole process can take so long that you delay showing So, it's just things like that There are plenty of tools So let's take a look at some real-world and how to work around them. Chloe started off with an LCP In this view here, we can see wasn't getting fetched and rendered Their home page suffers from, in this case, it suffered from It had heavy full-screen image downloads, some images that were requested late And these are very common issues, that they're doing crazy wrong, it's just very common issues. And it's useful to be aware So, things that impact LCP image elements that be inside video elements, block-level elements Let's talk about images first because they're pretty often For many sites, images when the page is finished loading, especially as UX patterns using more hero images in our pages. So, it's very, very important especially anything that's visible Now, there are a few techniques You can consider not having if it's not that relevant, Compress those images, use, you know-- there are plenty compress your images. Maybe consider converting them use responsive images. And you can also consider I'm seeing an increasing number just to help them to just tweak parameters and change what format gets served down And it's just-- using an image CDN of staying on top of modern best practices because-- even us that are, sometimes have a hard time of everything happening Now, you might be wondering, how can I identify the element Thankfully, we've got some solutions here. In dev tools, in the performance panel, if you record a trace you should find a record for LCP. Click on that record and you'll get that includes things and more importantly the related node. So, if you hover over that related node, was considered LCP. I personally find this really valuable as kind of a stepping stone to where So, check that out This is also something Lighthouse has got and we try to highlight So, if you use Lighthouse, check that out. So, back to Chloe. Chloe discovered that they were delivering even very high resolution Because there is a bit of a cutoff point where, if you're serving kind of the human eye large amounts of difference there. And there are kind of, you know, you have diminishing values very, very, very, high resolution images. Now, in this case, we're in dev tools-- we're looking at a specific image, and what we see is that the maximum is 1920 pixels, it's pretty large. So, one of the things was change things up here. They resized their images the image viewport size. So, they removed srcset sizes to keep an image maximum size and that actually ended up being There's this nice trade-off without negatively impacting Now, by doing this work that was previously seeing worth of image bytes being downloaded, they were able to reduce it down to 125. That's huge, that's like a 51% decrease with no noticeable difference. So, optimize your images, people. The next thing is some of the other image optimizations So, on the Product Listing Page, which, you know, What they discovered was that being loaded above the fold. However, there was one off-screen image that seemed to be tripping up and was still being fetched. This particular image about 200 plus KB in size, and this was negatively impacting So, they wanted to try improving this. On the whole, there are They were able to bring down all the way to 14.5 KB. They were able to tune so that off-screen images, were no longer a problem. They adopted an image CDN, improved their image resizing strategy. And the results of this, a nice Lighthouse report is that each product page which is a really nice outcome to have as a result of optimizing your images. Taking a step back, after these changes. We can see that again, were not rendering in Now LCP happens and it's complete The request time for our LCP related node is about 1.3 seconds in, so on the whole, this is really great. There's still work they could do here So let's switch things up to our next tip. Defer any non-critical JavaScript and CSS to speed up loading Now, this is guidance that is not new, it's been around for a few years, but for anyone that's not familiar I'll give you a very quick recap of it. Now, before a browser it needs to parse HTML markup The parser needs to pause or synchronous script. And scripts and style sheets can both which can delay consequently, your Largest So what we tell people to do and style sheets to speed upload. So, let's take a look once again As we can see, this is a trace independent and as we can see here, that there are a few that are delaying early paints Now, this is kind of manifested in terms of how much white One approach to addressing this problem and deferring the load We often call this technique critical CSS. Critical CSS is all about extracting CSS for above-the-fold content, ideally across a number and making sure that you can render as quickly as possible and deferring the load of the rest you know for things below the fold, So, how did Chloe do this? Well, they built some tooling. They implemented critical CSS and they constructed a syntax allowing their developers what part of the CSS code This is highlighted you see on the screen right now. Now, at build time, they're able to build and the non-critical CSS, so that every single build There are many ways I've contributed to some tooling and you can automate it, I see some teams that they manually curate. And regardless what's key is just making sure that you're delivering important content So, we talked about the need for loading in the other What Chloe do is, their non-critical so they point to references and that's injected so that it's hopefully not render-blocking but is still loaded that isn't going to interfere So, what was the impact Well, the answer is pretty large. They were able to bring down from 2.1 seconds to about 1.1, and their LCP Now, this is really great work. Optimizing your critical CSS but is something that your page is getting styled So, let's talk about another tip. I mentioned slow server response times when we were discussing The longer that it takes a browser the longer that it takes The faster a server can respond, that's going to improve including LCP. So you might be wondering how can I tell if I have Lighthouse has you covered. In Lighthouse we have an audit called<i> And if you see this, it's a good hint to spend more time and causes of the problem. As I mentioned earlier, it can be And we're trying to optimize There's plenty that we can do our DNS, our pre-connects but there are also things that we can do This is where techniques can come into play. Now, if you're new to server push, To improve latency, HTTP/2 introduced which basically allows a server before they're explicitly requested. Now, you and I, as developers, we can-- as well as anyone else watching, we often know what the most important and so we can start pushing those with the initial requests. This allows the server to fully utilize to improve page load times. Now Server Push is not without its nuance. This is one of those optimizations It's possible to over push. So, Server Push is not HTTP cache aware, so I could push something the user could come back and the server would push The way to avoid that is by either to avoid those refetches and track what's in the cache, but it does involve In general, Server Push is an optimization but just be aware of some of that nuance. It's not quite as simple Now, Chloe used automatic Server Push, which is an implementation It uses data to decide, you know, when to push critical CSS, And if you're manually you might end up looking at syntax What we see here is the link HTTP header. This is actually the preload and it's a separate from Server Push. But in reality, most HTTP/2 implementations that's specified in a link header so you can use the syntax in order So, what was the impact Without Server Push, that LCP was closer to four seconds. But with it, it was closer to 2.5 seconds which is like a huge amount of impact. On screen at the moment we've been but you can also tell you know, were server pushed and using things like webpage tests Both are very, very handy. Now, we're on to Chloe didn't optimize but I did want to very quickly cover it. Now, First Input Delay measures the time from when so that moment when they start some JavaScript powered control, to the time that the browser is actually able to respond There are many things that cause There can be long tasks heavy JavaScript execution. Large JavaScript bundles can delay how soon script and it can have an impact here. And then, you have things Now in general, I would strongly recommend because they do try to point out or heavy script execution. Very often the solution serve what the user needs and try to look at opportunities for, you know, minimizing Sometimes people will contextualize this in terms of, you know, some of the logic work to a web worker. But regardless of the path the end goal is essentially that the main thread isn't busy and that user interactions So, we're almost at the end Here we can take a look Thanks to their investments they were able to reduce down to zero, This is mind-blowingly awesome. This is like really, really cool. As you've seen, all of this work of a number of smaller optimizations that when added up, actually make to your end user experience. And we don't have we can look at the field as well. Here is Chrome user experience And as we can see, our Core Web Vitals metrics are trending in the right direction. CLS went from 0.85 down to 0 and this is all, It's really great to see, and I know that Chloe are happy to continue building on this work in the future as well. Now, if you're interested for your own team, you might be interested in checking out the Chrome User Experience This is a great solution and very quickly get access to field data and distributions It also summarizes the metrics. So if you're trying with other people on your team, they'll hopefully be able with the Core Web Vitals too. We also recently shipped a new Chrome This is great for programmatically being able to build out very similar to what we were So check that out too. And that's it! I hope that you found this talk useful. Go and optimize your Web Vitals. There are plenty of docs over on <i>web.dev</i> that cover the methodology, the tools, that you can use My name is Addy Osmani. I hope this has been useful. (music)