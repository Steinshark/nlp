The terminal is always in a love-hate relationship with Neovim. Is Neovim a terminal app, or is the terminal Neovim process? Is multiplexing the way to go, or mapping commands from within the idea is the right thing. There are too many ways to go, with pros and cons, and the choice paradox here is hitting hard. So, today we're going to put things in order once and for all, by covering all options, comparing them, and making some decisions around them. Whether you're new to them, or new to them, or a seasoned engineer, I'm sure you're going to find something new, so stick around, and please do add missing options in the comments if you feel you know something else. With that in mind, let's jump into Neovin and the terminal. We can't really start this process without touching the obvious option of all. The Envim terminal emulator. There are several ways to create a terminal buffer. Run the terminal command within Neovim, or call the Envim option term, or term open function. Let's start with a simple command that opens the terminal shell right inside the editor. Once in insert mode, it feels just like using a regular terminal, where all the commands are available. As if you were outside of Neovin, I can run my favorite listing tool, Eza, and even enjoy the syntax highlighting I love. None of this is lost, even though this is just Neovin wrapping the emulator. To exit the shell, the straightforward option is to end the session with control D, which closes the pain entirely. A more refined approach, perhaps a key reason to run an emulator within Neovim is to exit the terminal without closing it. This is done by pressing Ctrl-Backslash, followed by Ctrl-N, sounds complicated, and it definitely can be. So let's simplify it by remapping this command. We'll leave the prefix D for the mapping, that stands for a terminal mode map, where pressing escape triggers the same key combination. Now with a single press of escape, I can exit the terminal, switch to another pain, and continue using Neovim without losing any terminal content. This is particularly handy, when you're using the terminal to gather data that you later want to edit in Neovim, instead of relying on a multiplexer or some other method to capture and transfer the terminal's history. Using Neovim's built-in emulator means the content is already there, ready for editing. Another helpful trick is to configure a key mapping from moving around the terminal emulator, similar to navigating through pains in T-Max. For example, you can map Alt-H to move to the left split. This is done by setting it to trigger an escape sequence, followed by Ctrl-W, which is Neovim's command for window management, and then age for the left motion. Once set up, while using the emulator, pressing Alt-H will jump to the left split. If you find yourself frequently using this feature, it's a good idea to add these to the terminal mode motions, so you can move freely across the painsplits. Moving on to another option that I found more natural, a floating terminal. Neovim supports a community plugin called FlowTerm that I've used for a couple of years. Recently, I switched my setup, which I'll detail later, but FlowTerm remains a great tool. It offers the simple functionality of a floating persistent terminal that can easily be toggled on top of your code. You can launch FlowTerm, either empty or with a command like FZF, for example. This capability opens up several possibilities, such as mapping a floating FZF search with a dedicated key binding, or using it to start any other process you might need. Additionally, FlowTerm allows you to control the height and width of the window, as well as its name, position, and even include an option to automatically close the terminal when the process ends. Imagine Yazzi running inside a small box, position in the lower left-hand corner, closing itself as soon as you exit the process. We've discussed an internal emulator, and an NVMe internal floating pane. And now it's time to step outside of Neovim and explore multiplexers. Timax is my multiplexer of choice, but there are other viable options like multiplexing features in Western, Kitty, and many other emulators that offer their own split window functionality. With Timax, you can create and rearrange splits, but you can also manage entire sessions by opening new windows filled with various paints. There's also a Timax pop-up feature, similar to FlowTerm, which can run, process, and automatically close when that process finishes. You can see the influence FlowTerm drew from Timax pop-ups here. Timax adds another layer of organization with its sessions, allowing you to separate environments by hosting their own sets of windows. Since Timax itself doesn't provide robust session control bindings or tools, I created Session X, a fuzzy picker, and manager for sessions based on FZF. This tool allows users to swiftly and easily navigate, create, rename, delete, and more. You can learn more about Session X in the project's GitHub page, and in my video linked above. The main reason I prefer using Timax over internal Neovim emulator is the persistency of the shell. While I often open and close multiple Neovim sessions during my work, the Timax server remains active. Exiting a VIM session doesn't affect my other running shells, which simplifies my workflow. I use Neovim for coding and Timax for managing shells, keeping them separate. I want to take a quick break to tell you about giving a net or a G. Almost 3 billion people have never logged on to the internet. They've never taken advantage of Google, YouTube, or the AI tools we use today. They've missed out on education, online jobs, conversations, and equal opportunities. And we've missed on their potential. Before the internet, a person's future was determined by the physical environment they were born in. Today, internet access means access to global knowledge, and equal opportunities. At giving a net or G, you can sponsor internet fees and laptops for students from some of the underserved communities. Their local partners provide skills development programs like coding, design, health care, and entrepreneurship. The only thing the students lack are internet connection and a laptop. Once connected, most of them find either a job, freelance, or start their own business. Join the cause in a few clicks. Read donation made through Give internet or G slash DevOps toolbox, will be matched by some of the donors. You can read the story of every student on a platform, view every penny spent, and receive monthly updates showing you who you helped, and how you changed your lives. Now back to the video. Another remarkable multiplexing tool is Zellage, a modern and visually appealing project I've previously covered. It features a familiar system like Timax with tabs, splits, and sessions, but adds unique elements like floating paints grouped together. For more details, check out Zellage on its projects page, and my videos for both beginners and Timax experience users. Zooming out a little further, let's return to the basics of running processes. Operating VIM or ANVIM in a terminal allows the process suspension like any other application. Using control ZED puts the process in the background, and you can toggle between background and foreground with BG and FG commands. This method is simple, requires no extra tools, and is available on every host. It's a timeless approach, often used by many engineers, to maintain both their shell and VIM sessions without loss. Similarly, VIM and ANVIM can interact directly with a shell. Running a command from the colon prompt, starting with a bang, executes a unique shell command. The output is shown, and you can press a key to return to your editing. This integration means you can perform tasks like creating files, listing them, or writing content directly from the VIM, with STD out being displayed as a message via any of VIM. In this case, using VIM notify. It's particularly useful for editing data, like sorting a list of lines, or predefined adjacent structure with JQ, which then sends a structure version back to the editor. Lastly, I'd like to introduce my latest workflow upgrade called Flux, a new Timax plugin that introducing floating paints in a terminal functionality. Flux isn't just a floating pane, it integrates deeply with Timax, offering persistent sessions, full window management, and history retention. It's adaptable, it allows you to control the size, style, and even enter full screen mode. If you appreciate Flux, consider supporting it with the Starring GitHub. It's a new project, and that can use more visibility. Contributions are also welcome, whether you add tests, issue reports, or pull requests. Stay tuned for a video covering all that Flux has to offer. Make sure you're subscribed, and don't forget to hit the bell icon to be notified when the video goes live. So by now, I'm pretty sure it's clear. There's no one size fits all, there's no ride, there's no wrong. There's workflow and choices around it. My guiding light has always been the path with the list friction, the path with minimal resistance, it works for water, it should work for me. As you've seen, 9 out of 10 times it's going to be Timax for me, it's always there, I know it by heart, and I made sure it's built around my needs and tailored to my workflow. So watch this next one, to get yourself started properly, and set your Timax environment like a pro. Thank you for watching, and I'll see you on the next one.