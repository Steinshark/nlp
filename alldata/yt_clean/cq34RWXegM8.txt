[music] Welcome to the pilot episode where we'll walk you through of building specific things in Flutter. In this episode, we're going to learn a lot including when and how In Flutter, we love to say and it's true that most things In Flutter, any layout and off-the-shelf widgets But &quot;almost always&quot; That limitation comes from a little thing called the Flutter's This means that when Flutter is turning no back-and-forth is allowed. &quot;But how can that be?&quot; you ask. Surely the column widget's<i> proves that Flutter does have Flutter has to know before it can place them. Surely that constitutes Well, functionality like this is why including the three most popularized ones: widgets create the declarative API that we all know and love; elements are the translation layer that hold it all together; and <i>RenderObjects</i> handle sizing, layout, painting, and semantics from one frame to the next. So what do <i>RenderObjects</i> do? Well, a simplified day in the life might look like this. First, the <i>RenderObject</i> wakes up when its widget creates it Then during the rendering phase, Flutter works its way <i>performLayout,</i> <i>paint,</i> and <i>describeSemanticsConfiguration.</i> The first <i>method</i> is <i>performLayout</i> wherein the <i>RenderObject</i> has one job: figure out how big you're going to be. If the original widget then this <i>RenderObject</i> to determine their size. This happens all the way until everything is sized. Later on, Flutter calls <i>paint</i> on all the <i>RenderObjects,</i> which combines their previously calculated with whatever other parameters they have to start making actual graphics calls. Lastly, Flutter calls<i> which builds out the semantics tree, which Flutter uses for accessibility. Those are the three big methods <i>performLayout,paint,</i> and <i>describeSemanticsConfiguration.</i> Then things are stable, but eventually, you call <i>setState,</i> meaning it's the dawn of a new frame. New widgets with your new values are slotted into the widget tree, and Flutter calls<i> to route your new values to the <i>RenderObjects</i> that need them. Each <i>RenderObject</i> then reenters Only this time, it's not guaranteed that Flutter will call each one because depending on what changed, cached values from the last frame It's up to individual <i>RenderObjects</i> which we'll see for ourselves later. Unlike widgets, <i>RenderObjects</i> are highly mutable and live for as long as possible often supporting many frames That's a high-level overview Sibling UI elements but sometimes they have to, which specialized <i>RenderObjects</i> handle with specialized implementations <i>RenderObjects</i> Rows and columns use but the rules are strict and exposed to us and <i>crossAxisAlignment</i> properties. What do you have to do if you need specific to your app? Well, the answer might be One scenario that requires is a common message bubble where the <i>sentAt</i> timestamp if it fits, but wrapped down to an additional line if it doesn't. Flutter's single-pass layout algorithm doesn't cleanly allow for this UI. You could use <i>addPostFrameCallback</i> to make measurements after the first frame and slot in that <i>sentAt</i> value accordingly, but that would create UI flickers and would look terrible. We need a custom <i>RenderObject.</i> When we're done, it'll look like this. Let's build it. To start, I've created a fresh project with <i>flutter create --empty</i> to spin up a bare project. Let's fill our page with a <i>Scaffold</i> and a centered, sized <i>Column</i>, which will begin to house In that column, first add and above that, our chat bubble, called a <i>TimestampedChatMessage.</i> To help it look a little more I'll decorate it with a helpful <i>Container</i> and an <i>Align</i> widget, which will push it to the right. Next, create that <i>TextEditingController</i> we imagined in the text field to quickly test our <i>TimestampedChatMessage</i> against different values. To link the two, wrap our <i>TimestampedChatMessage</i> Use our <i>controller</i> as the <i>listenable</i> and build our widget like normal. Lastly, we'll ultimately need a <i>text</i> value provided from the <i>controller,</i> another <i>text</i> value for the timestamp, and a <i>TextStyle.</i> We're now ready to work The vast majority of widgets likely extended stateless widget But this time, we're going one of the descendants To figure out which one, we need to think about the parameters we want to pass One alternate option would have been and a <i>DateTime</i> for <i>sentAt.</i> This is how most widgets work, of course. Lots of widgets have a <i>child</i> parameter, but it'll be tricky in our case because we need to perform on individual characters That's tough to do if the raw string value is buried deep within a <i>text</i> widget. Plus, what would we do if the user supplied an image or a stack or something else wonky? None of those values make any sense which is why the appropriate is to accept a <i>String,</i> a <i>TextStyle,</i> and a second <i>String,</i> and, of course, that <i>key.</i> The appropriate parent class when the widget in question is called <i>LeafRenderObjectWidget.</i> Our <i>TimestampedChatMessage</i> in its branch of the widget tree. If this is your first time you may be surprised to learn don't have <i>build</i> methods. Instead, we need to supply <i>createRenderObject</i> and <i>updateRenderObject.</i> In <i>createRenderObject,</i> I'll add a stub that we'll finish later. For now, this method will return a <i>TimestampedChatMessageRenderObject,</i> a name that really rolls off the tongue. Okay, onto Again, there are but the right one for our case This is the most common <i>RenderObject</i> when your UI element The first thing we have to see to and the parameters it will require. Once those parameters let's create two <i>TextPainters</i> that we will use later. The next thing to understand is how they think about their attributes. Remember how widgets and can never change? Well, that's not how <i>RenderObjects</i> work. <i>RenderObjects</i> are like chameleons. They can change or anything else without missing a beat. Technically, chameleons but you get the idea. For every attribute we need to write The convention looks like this. For the getter, simply proxy to the private variable For the setter, first evaluate If they are, <i>return.</i> That's called a &quot;guard statement&quot; where you check short circuit conditions and return early. That's how <i>RenderObjects</i> After that guard statement, Here, assign the new value We'll also need to update our <i>textPainter,</i> but remember that it took a <i>TextSpan.</i> To help ourselves, let's make <i>TextSpan</i> getters for both our core message Later, we'll return to these magic setters and update some flags. But don't worry about that yet, just remember that we'll be back here. We need getters and setters so let's add them quickly. With the setters in place, we can finish <i>createRenderObject</i> in our widget class. For <i>updateRenderObject,</i> remember that widgets are immutable, so if any values have changed, the old widget is long gone, and Flutter will call this method This new widget has no pointer to the original widget's <i>RenderObject,</i> so Flutter passes it in to <i>updateRenderObject.</i> We can now make use to apply the new <i>text, It's up to the <i>RenderObject</i> to work out what, Okay, a lot of our code is in place, but sadly, we still can't run That's because we have yet to implement the three critical methods <i>performLayout,paint,</i> and <i>describeSemanticsConfiguration.</i> We'll start with <i>performLayout,</i> <i>performLayout</i>'s job is simple: determine the dimensions and save it to the <i>size</i> attribute. For <i>RenderObjects</i> with children, you should call <i>child.layout</i> and then interrogate its size, but that's not our scenario. We don't have any children widgets. We're a leaf node in the widget tree. The upcoming sizing and measuring code gets a little nitpicky. It's somewhat zoomed in learning about generic <i>RenderObjects.</i> I'm going to quickly breeze through it, but know that the full is linked below. To lay out text, call <i>textPainter.layout</i> and supply a maximum width, which we can pull At this point, our <i>textPainter</i> but we need more granular information, like the length of the longest line and the length of the last line. To access this information, call <i>textPainter.computeLineMetrics,</i> which returns a list We're close now. We can set up a few variables to save values for later and then a little manipulation pulls out the other info we need. We can now save a helpful variable based on the longest line and the number of lines. We'll use this later. You might guess what comes next. Repeat the same process and measure its size. Now, we can compare can squeeze into <i>constraints.maxWidth,</i> which sets the all-important<i> Note to check for whether has one line or more than one line. Finally, remember not just knowledge fits onto the last line of the message. To save the actual size of the widget, combine knowledge of whether or not<i> with the number of lines to make the right measurements. Remember, this fully commented code We have one more task to make sure we didn't just calculate than our available constraints. To do this, we'll use on box <i>constraints</i> and save those results to <i>size.</i> There it is. <i>performLayout</i> has done its job. We're ready to move on <i>paint.</i> The first thing to know about <i>paint</i> is that it's called after <i>performLayout,</i> so we should favor the <i>size</i> variable we set in <i>performLayout</i> when making calculations. <i>paint</i> is passed in two parameters: a <i>PaintingContext,</i> which we'll use to actually draw stuff; and an <i>offset,</i> which is essentially our distance To draw the raw message itself, we can return to our <i>textPainter</i> and call <i>paint,</i> passing in <i>context.canvas</i> and <i>offset.</i> This is the first moment our code has been capable so I'm going to save and run my app. But I do have to tend which is to set an initial string value There it is. Our text centered on the screen, just like if we'd used So pretty. But this is where things get fun. Back in our <i>RenderObject</i>'s <i>paint</i> method, calculate a special <i>offset</i> which adds the extra distance needed to correctly place <i>sentAt</i> in relation to the message text. Finally, call <i>sentAtTextPainter.paint,</i> passing in that same <i>context.canvas</i> and our new <i>offset.</i> Save and run our app again. Voila! Our widget is placing One thing I'm noticing like we wanted, which is because I forgot to update the <i>TimestampedChatMessageRenderObjects</i> to use our <i>textSpan</i> helpers. There. That's better. That said, there are It doesn't yet correctly rebuild itself or participate which is used for screen readers First, we'll handle semantics in the third big <i>RenderObject</i> method: <i>describeSemanticsConfiguration.</i> <i>describeSemanticsConfiguration</i> accepts that the <i>RenderObject</i> Semantics is a whole so for this, I'll only go as far as to say I took inspiration from a render paragraph's version when I came up with these lines. That's how you write <i>performLayout,paint,</i> and <i>describeSemanticsConfiguration.</i> However, there's one more detail You see, Flutter calls whenever our widget but it doesn't always know For that, we need to get familiar with each of those three methods' <i>markNeedsLayout,</i> <i>markNeedsPaint,</i> and <i>markNeedsSemanticsUpdate,</i> are methods we call when we've just done something painting calls, But what does that mean? When and where should we call Well, the rules are actually very simple. Think back to those magic setters Every time we update a variable that was used in <i>performLayout,</i> we call <i>markNeedsLayout.</i> If you update something that change call <i>markNeedsPaint.</i> Of course, if you change the semantics meaning call <i>markNeedsSemanticsUpdate.</i> Revisit what you wrote and notice which of your class variables influenced that method's output. Then whenever you change those variables, mark that work as stale and in need of an update. Now, back to our running app, typing in new text One detail worth noting is that <i>markNeedsLayout</i> so you never need to call both of those. That was a lot of code, but we've reached the finished product. At the outset, we faced a UI that Flutter single-pass layout algorithm couldn't elegantly handle, but with the power of <i>RenderObjects,</i> learned how to write that can juggle back and forth and efficiently lay out This is a viable <i>RenderObject,</i> though there is more for a more robust implementation, like supporting placing this But that additional code In the next episode, and explore how you'd implement with a custom shader if you didn't have Leave us a comment below and let us know what you'd like to see in future episodes of the Build Show. For everything else on Flutter, head to <i>flutter.dev</i> [music]