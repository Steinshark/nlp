Do you know the feeling where you're looking for a file on your machine, but you have no idea where it is? So you pop up some kind of file explorer and then you try to search there. Maybe you don't remember the exact name and you're not sure where to look. So you pop up your terminal because you're a hacker and then you run fine. Now you might be thinking to yourself, oh this dude doesn't know what he's talking about. I've got Loki, even if you do have Loki, which is great to have by the way, stick to the end of the video where I show you how to set up on different operating systems. You may not remember the exact name of the file. That could produce a list of 50 or 100 different files. How do you know which one is the right one for you? Well, you're going to have to view them one by one. That's kind of annoying. End time consuming. There's one solution that does that great and integrates with all other tools. With over 55,000 stars on GitHub, FCF is the ultimate command line fuzzyfinder. Say goodbye to endless scrolling and searching through files, folders and command history. With FCF, simply type a few characters and watch the results magically appear. It's super fast and efficient, but most of all, it removes friction. FCF is a picker. If the result is not piped anywhere, it's echoed back into the terminal. Let's make it more interesting than that. With the preview flag, we can get a glimpse into the peak. In this case, since we're watching files, I'll use bat and add some color and lines to read the file conveniently. Moving around is generally done with the arrows. Minor map to view motions with control. The currently tight string always shows in green within the results to show why they were picked. So, if you just want to randomly find files on your machine, just run this in your home directory and wait for the system to index the files. Now, warning. This depends on the number of nested files under the home directory. Take the step with a grain of salt. The lower the path in the tree you search, the quicker results will get indexed. Let's improve the process though. FCF is not only great with files. It's arguably better when put to command line daily use. When searching command history, most users either just hit the app arrow again and again. Others may watch the history to search with their eyes, or print the list to get from it for more about grab. Check the video up here. Some of you probably even know about control R, where you can search the history and move between results. This is, by the way, by far the best option on remote machines. With FCF, control R is brought to a new level of usefulness. You get a fuzzy search of recent commands. You can simultaneously view recent search, scroll, and hit the result to print it into your screen, where it's ready to run. Another handy built-in binding is control T, which essentially pays selected files and directories into the command line. This is useful when scripting files or directory management. For example, a removal tool. This is also where FCF multi-select mode comes in. You can always trigger it yourself by adding the minus minus multi-flag, and then use tab or shift tab to select and deselect. The third binding that comes with FCF, one which I use daily, is the option C. This opens up a directory switch, where you get a list of available directories, and by hitting one of them, FCF will cd into that directory. This is a simple tool anyone can script in minutes, but it's built for the user's convenience, which I'm thankful for. It may seem obvious, but often open source authors tend to leave these edges for user's creativity, and having such an amazing tool and getting such defaults is not taken for granted. Kudos to the author, which, by the way, is a very productive coder. It is responsible for many VIM plugins and other tools, so check out his profile for more. FCF also has a configurable trigger for fuzzy completion. By default, it would be two stars in tab to trigger FCF. Useful combinations are killing processes with keel and minus nine for setting sigma to one of the processes of ZF lists. Another one is exporting environment variables, or an aliasing certain bindings found in the aliased list. As with everything else, the trigger can be changed by simply overriding it with FCF completion trigger variable. Once the variable is reconfigured, it can be used for anything and any auto completion you've been using before. Speaking of triggers, this video is not sponsored by Zelage, but you may be triggered to give it a go once you hear these news. Zelage now has session resurrection capabilities, something that deterred many viewers of this channel in the past to take it on. If you upgrade Zelage to its latest version, launch a session, then quit your terminal, you can come back, get the running session list, and see your old session still there, where you can attach and run the same thing. By the way, you can now also rename sessions through the session manager, kudos to around and the team for making this a reality. And thank you Zelage for sponsoring this channel with love. I'm usually running FCF inside a git project, where I tend to get a dump of all the dot git objects, which I'm clearly not interested in. Not only that, it slows down the indexing process, so let's get rid of it. FCF can integrate with other tooling for lots of purposes. One such option is changing the default command. For this purpose, I'm going to map it to AG, the silver searcher. More on that in a sec. Note that I'm flagging hidden files, dot git directory, and having the result respect ignore files. And here's the result after the change. Quicker and easier to read. Plus, I only have 33 files to choose from, as opposed to the 500 I had before filtering unwanted files. To prove that ignore files are in fact respected, here's a Docker file I'm currently using. If I were to add it to my dot git ignore file, and save, FCF will now filter that out. This comes in handy when scripting around git repos, especially open source projects, where ignored files should stay out of the release process. At least, that's how I'm utilizing this feature. You can get creative with FCF and files. To read a file with cut or VIM, add the dollar parenthesis notation for command substitution, with FCF inside as an argument, this can be sent to any reader. You can switch things around by sending the output of a file to FCF and have it serve as a line picker. This is usually great when reading large text files like application logs, for example. Then FCF allows you to search the logs, with ease. I can pipe the stream directly, or read the file into FCF. Now fuzzy searching for the health issue I had is as simple as just typing it. In the wild, FCF is used in many open source tools. It comes with FCF Teamax side script to open it within Teamax panes, if that's your thing. It is mine, by the way, I'll leave a link above if you're interested in some Teamax magic. Beyond that, FCF can be found in the DevOps toolbox in tools like HubCTX and QNS. This basically takes a list of available Kubernetes clusters, or the respective namespaces, and using a fuzzy picker to change the correct context. This way, my local machine is configured to work against the picked one. It works similarly with namespaces. For the Kubernetes users here, this one is a game changer. You pick the namespace from a fuzzy search list using FCF, and once you pick, it'll set itself in the context. You don't have to modify anything else. If you're a new VM user like me, you've probably noticed a huge inspiration for telescope with fuzzy file searching or even live-graping. Now, speaking of live-graping, do you remember we used AG? The silver searcher earlier as an FCF command. Well, here it is doing its original thing. Searching through code. Telescope is using a similar project called RepGrep, which is another code-searching tool doing exactly the same. How did this help? Well, what if you can search through code, then pipe the results into your favorite fuzzy searching tool? Yes, you can get a code-searching tool on your own. But let's improve it. What if I'd like every pick to open the file it belongs to? I can cut the result, grab the file name, isolate it, and then send it to new VM. When certain CLI tools can take STD in, XRx is a lifesaver. And here's the file in new VM ready to go. To be clear, RepGrep and the silver searcher are interchangeable in this use case, and both work exactly the same for this purpose. So if you have a preference, please don't worry about it. I'll leave both links in the description below. But if you're really into squeezing every bit from your tools, RepGrep shows slightly better results when compared to AG, but they're both quite similar and different is insignificant. Working with Kubernetes, here's an example for how FDF plays well with QBCTL. Sometimes when not using certain TUI's, grabbing pod names and then describing them is not the most pleasant experience. I fixed this with a local tool, which basically does this. I grab a list of pods with QBCTL get pods, pipe it into FCF, which in turn pipes the user pick into ock. Ock will take the first field, which is the pod's name, and using XRx, it'll push the name for QBCTL, describe pod. All that's left is to pick a pod from the list. There's my description. I can do the same with reading logs, just by piping the same to QBCTL logs. The options here are pretty much endless. Having FZF in my tool belt is definitely a lifesaver. One last word about locate, because I promise. Any systems come with a locate, hibernated in the background, or uninstalled. In order for it to run properly, you'd want to activate it by creating a database, and having locate index the files in the system. Don't worry, it's not as bad as it sounds. If you're on a Mac, you can just run locate. Mac OS will give you the commands required to initiate the database. If you're on Linux and the locate command is not installed, go ahead and install M locate using your package manager, either YAM, APP, or even APK for the Alpine enthusiast. Once done, run sudo updateDB, so that locate will have data to work with. When that's done, run locate, file name, and enjoy the results. But we can't really handle raw text results, right? Pipety to FZF, then ship the results to new of them for further exploration. So this is one tool that replaces a bunch of old ones while improving the process. But what if I told you there is a list of essential tooling that you can replace today. To fix the issues you didn't even know you had. Well, check out this video right here to figure all about these. Thank you for watching and I'll see you on the next one.