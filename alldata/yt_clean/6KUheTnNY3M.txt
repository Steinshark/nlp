How does a model like this serialize itself? It does not. Not into JSON, The primary concerns of a domain model are yourself and the model further? deserialization is a valid concern. This minimal API application operates The model is about books, their This endpoint queries for There is an optional filter in the URL. When querying a single author, the result but there is none at the moment. That feature is missing, and I But still, the question is: Who You need to see the data before we can unveil I am about to query a particular by Enrico Buonanno. There are data about the book, Enrico Buonanno is the only author. But then comes the twist. The JSON you see here differs from Here is the Author model, which The ID was not shown in JSON. which is not part of the model. that URL, but the URL itself is not here. holding the person's name details, Lesson learned: A JSON does not equal the model. cannot convert itself into JSON. But who does know that? let me show you another place where the This is the endpoint that queries authors. When the handle is specified in the author and return it as another JSON. the author was a part of the book's data? This JSON, while still representing the the components of the author's name plus the A new lesson to learn: The same object depending on the endpoint. cannot serialize itself into JSON. who asked for that JSON. The endpoint is asking! unique regarding the transform it applies to the This is where we implement the brand-new Let me explain what this The search handle is optional in the route. single author, so the result set would List patterns are a fairly new addition to C#, This pattern is matched when the result captured in the variable called &quot;single,&quot; Once we enter the right-hand expression, All that remains is to start turning These parts we had in the model. Now comes the field the model doesn't And there is more. But the query I have executed in this endpoint Let me add a short report of that author's books. Well, that JSON is not useful here. This endpoint will only represent Let me show you the result. When I query Enrico Buonanno, with all the details and a very Lesson learned: The caller knows Therefore, the only code that could the one that will use it. There is no JSON in my code. an object, an anonymous object in this case, The framework will then convert each JSON for transfer over HTTP. are only serializable values here. So I took the unique string from it, which is After this point, things become complicated. the response to the query for The result set should produce an array, each element serialized the same way as That is one hefty piece of duplicated code. which JSON to produce, the serialization I will now start cleaning this code up. out these duplicated portions into a helper I mean, who writes code like this? This is C#, a strongly typed, compiled language. Here is the idea. deserialize a JSON from an HTTP request. creates a new author in the database. framework deserializes it into the record type. you will never see a JSON in your code. out of the box, provided the record consists of Let me show you that request record before This record type declares every JSON before creating the Author model. I want the same thing for response JSONs. I will implement the new records now, and There will be some tricky code from now You can download the entire source code before Please remember that every patron is helping all the videos on my channel for free. It had the first name, last name, It also had an array of books, but There you go. A record that serializes into that simple All it takes to complete the array of simple book responses to this record. It is not just that now we turns into JSON on its own. Strong types do what strong types want. Consider an extension method that turns book response object. Any endpoint in my application can utilize this Doing the same in the larger First, it is not the author we transform. and that author's books. That is what the endpoint has and, remember, the endpoint is the boss here. We design request and response records But the rest is straightforward. Poke each value out and Care is required with nested I will transform each book operator before collecting Still, doing things this way is much simpler My work here is done, and now I want this anonymous type out. And I want the strong types in. And this one? It is a sequence of author-books With strong types at hand, it is conversion to the LINQ Select operator. It is not just shorter, but it is also safer. In the final code, I have introduced The entire serialization and deserialization which the framework converts to and from JSON. The JSON itself was never my job.