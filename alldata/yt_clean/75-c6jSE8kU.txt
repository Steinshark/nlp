Hi, I'm Ben from the Swift team, and in this video, I'm going to walk you in an existing application. We'll see how Swift 6 helps protect and look at some techniques for introducing this change as well as how to deal with that aren't yet aware I'm going to be using a simple app that tracks coffee consumption as well as a complication to show your When we first introduced Swift I walked you through how to adopt Swift's In that talk, you see how a sometimes hides If you look at the views and models, But delving into how concurrency The original app had 3 concurrent queues Work in the UI, and on the model, The app also had a dispatch queue And finally, certain callbacks like those returning were done on arbitrary queues. So while the types were organized neatly, the way concurrency was not such a clear story. Which queue was executing code, and why, weaved through the types in a way By adopting Swift concurrency, we went from this To something that looked like this. The UI views and models were set while background operations The actors communicated between using Swift's async/await feature. When we were done, and easy to describe But there was one wrinkle. When doing this refactoring there was still a lot of responsibility to avoid data races. I followed all the guidelines, and used value types to but I didn't have to. I could have taken a reference type, from one actor to another. Reference types allow shared and when you do that, you can break the mutual by allowing them to both access So, if I sent an instance of a class it's still possible to get data races that could cause my program to crash, This brings us to is The Swift 6 language mode introduces The compiler will prevent this between tasks and actors, or add new functionality to your app, without worrying that The Swift 6 language mode is opting for both existing and new projects. Adopting it can significantly improve by catching mistakes It can be especially useful if you are experiencing and want to go through and methodically eliminate And if you're actively working to improve responsiveness and performance, adopting Swift 6 mode don't risk introducing new data races. If you maintain a public Swift package, we encourage you to adopt Swift 6 to help your users They will benefit from building that have also adopted Swift 6. Everyone can follow along in popular packages Today, we're going to see We're going to take our and enable Swift's data isolation. We'll do this step-by-step, and look at some of the guidance about where we need to make that CoffeeTracker Now, I don't believe that my app And chances are, the same You might have already shaken out most through years of refinement, bug reports, using the main thread checker, The real value of data race safety is protecting against bugs either adding new features, or refactoring existing code Data race safety allows you without fear of introducing new data races that you'll later have to hunt down because you can't reproduce a crash. Since we last saw it, our coffee and we've expanded the team As part of that we've factored some of and some of the code now lives in there. The team is keen to start but before we do that, so we know we're not new concurrency bugs when we do that. Now, I've just downloaded This means I have the new Swift 6 compiler let's try and build the app. And it builds just fine. No need for any updates. But that's not because our app It's just that we haven't enabled Just like with previous releases, Swift 6 has a source Aside from very minor changes, your app should always build Now that we know our app we want to take the next step which brings full Now, in preparation for this, you could go through and Sendable audits before enabling But this is missing out on the benefits The compiler diagnostics will guide you Think of it like a pair programmer that's pointing out This helps add some structure We're going to follow where we migrate With each target First, we'll enable This is a per-module setting that but enables warnings for all the code that would fail We're going to go through, resolving all of these warnings Once that is done, This locks in all of our changes, and prevents any future refactorings We then move onto the next target Finally, once that is enabled, we might want to go back and perhaps to undo some unsafe or perform some refactoring you One bit of advice about refactoring: try and resist the both significant refactoring, Try to do one at a time. If you try to do both at once, you'll probably find it and have to backtrack. In this talk, we're going to focus only that we already refactored previously So we start with enabling What does complete checking enable? If you've already been using you've probably seen warnings about concurrency issues that came up as For example, here we're working that's going to receive to tell me when This delegate is going to publish so I want it to be isolated So I can add an @MainActor to the top, requiring all its methods to be made on the main thread. When I do this, though, on the implementation of the protocol. It's telling me that a "Main actor-isolated cannot be used to satisfy This CaffeineThresholdDelegate protocol now makes no guarantees It's inside CoffeeKit and that But here I'm conforming and I just_constrained it Its methods are going so they can't just conform guaranteed to be called on the main actor. We'll come back to this issue But this is an example of an error because you opted a type into checking that it was being called If you watched the previous talk, adopting Swift concurrency you will have seen these issues coming up as concurrency was being adopted Enabling strict checking opts your entire module into being Let's enable that now, Data isolation in Swift and in my app, I have two key targets, the WatchKit extension, and CoffeeKit, a framework for tracking the caffeine I'm going to start by enabling There are two reasons for this. First, it's often the simpler place Much of the UI layer will and will be using APIs, that are themselves guaranteed The other reason is, you're often going to be that haven't yet been updated Maybe you're using a C library Or maybe it's a framework that will get updated to Swift 6, And that, of course, We'll see why going top down like this So, as a first step, and go to its settings. And we're going to search for the and we're going to set it Once we do this, the compiler is going it can't confirm is concurrency safe. These are just going to be warnings, So let's try building. And, we see a few more warnings, in addition to the one Let's take a look at them. Now, the first issue we can see is one of the most common issues referring to this "logger" variable. We see a logger instance Global variables are a source every bit of code in your program, is able to read and write So this can be a really and we need to make it safe. We have a few options as to how. In fact if we expand the issue, we see the compiler is recommending some. First option is the easiest, Logger is a Sendable type, and that means that it can't cause data races So switching this var to a let. And rebuilding. Makes that issue go away. Now, this is the right fix, Suppose I don't want it to be immutable, let's say I want So I want to keep it as a var not a let. Another option is to tie Here, I'm in my UI layer, so maybe all my logging So I can annotate this global and yes, all my logging use so that also eliminates the warnings. Finally, sometimes I have some other external mechanism that the compiler can't enforce. Perhaps I'm guarding all access In that case, I can use Like other uses of the this puts the burden on you This should be a last resort, it's best to use Swift's But the compiler can't so nonisolated(unsafe) is available This might be an example of something where I want to come back later maybe move this variable into an actor so the compiler can verify But for now, I could and move on to the next warning. This is not one of those cases, so I'm going to go back that's the best option. Now you might wonder that initializes the global. When does that get run? Isn't that important to know Global variables in Swift The value is initialized on first use, the first time This is a really important difference In those languages, global variables And this can be really bad Swift's lazy initialization allowing your app But lazy initialization what if two threads try with this global variable simultaneously? Could they create two loggers? Well don't worry -- in Swift, global variables are guaranteed If two threads tried to access for the first time, only one would initialize it, OK, that's resolved that issue, Here we have some code accessing This global instance method is an example The first note here is to actor-isolated state that is, if this were an async function, you could use await to access This function isn't asynchronous, or start a new task. But the compiler is we can just put this function, Since this is a free function, it's not defaulting Let's apply the fixit, and now this method is isolated and if we try and build, it succeeds. To see why this worked, We can see it's called two times, both from methods If this function was being called I would have got and I could go look at that caller One is a SwiftUI view. And the other is in the implementation Let's go look at that. If we option-click WKApplicationDelegate, we can see it's a protocol This is a guarantee that it will either by the WatchKit framework, or once you enable Swift 6 mode, Many delegates, and other that are designed to operate have been annotated like this, that come with Xcode 16. Most importantly, You will probably find if you previously you had to add more main actor annotations and that you might be able Now, let's talk a bit about You probably already know that from a delegate or a completion handler, you always have to first understand what the concurrency guarantees Some callbacks have a guarantee, they might say in their documentation that all callbacks A lot of UI frameworks and it's one that many warnings in our work on this view layer of our watch extension, when we're marking things as main actor. On the other hand, they make no guarantees saying it will be This makes a lot of sense for callbacks that are more likely to be coming The callbacks received by CoffeeTracker In those cases, the user needs to or do their work in a thread safe way. The trouble with this approach, where each delegate has its own rules is that this puts a lot of burden on you, You need to think about where and where you need to be And if you forget to check, or forget to redispatch you can easily get a data race. What's worse, let's say that a callback and it happened to always but that wasn't always guaranteed. Then later, some changes and now it's coming in But your UI layer was relying on it What we're missing guarantees that when I can't easily be broken by changes like them changing the queue Swift concurrency tackles this problem, by making these guarantees, If a callback doesn't specify it's considered non-isolated, and it can't access data On the other hand, if a callback say that it will always then it can annotate or callback as always being and the receiver of the callback With that said, let's go back where our delegate type on the main actor couldn't conform We have a couple of options here, The first one is That means that despite this being this specific method This is the route to go for for callbacks about where they call you back. Of course, this being a view, and do some work on the main actor. If I don't do that, I'll get a new error because I'm accessing that are protected by the main actor. I could fix this In this case though, I know this callback I know it's coming from my that is itself running on the main actor. One option, if I maintain is just to go fix that right now. I can jump to definition and here I could annotate it with @MainActor here, to guarantee it's going But sometimes you don't maintain Maybe another team maintains CoffeeKit, or it's a package or framework you rely Let's assume this were the case here, and go back Now, I know that this method I just checked the code, or maybe I read it in some documentation When you know for certain there is a method you can use it's called assumeIsolated. So instead of the code starting a task, I can write MainActor.assumeIsolated. This doesn't start a new task It just tells Swift that this code Note that it's still perfectly to call this function This is the same as that assume they're being called A good way to protect against this that you are indeed on the main actor If this function is ever it will trap and your program Trapping isn't something you want, but it's better than a race condition Now this pattern of conforming that assumes its called on the main actor, is common enough So let me undo my changes here, and instead, on the protocol conformance, That does everything it assumes it's being called on and it'll trap if it isn't. Now that we've eliminated we're ready to enable Swift 6 So we go to settings. And search this time And we set that to Swift 6. Compile, and it builds without I've now locked in full data isolation and any future changes I make here will have full data isolation checking ensuring I don't accidentally OK,now that the extension let's turn our attention Now that we're working on this target, let's go and add that @MainActor So let's find it. Add the main actor annotation, rebuild, and we get a new warning. The warning is back in the extension, and it's on that @preconcurrency Now that the compiler is guaranteed to be on the main actor, the compiler is warning that that pre concurrency attribute So we can remove it. OK. with that issue resolved, we can follow the same routine as before, We go to the project settings, and enable it for the CoffeeKit target. And we build. Now, this time we see That's quite a few warnings This is going to be a common experience. You enable complete and your project generates hundreds And when that happens, It's important It's common for a large number And many of these issues So, when first cleaning up a flurry of simple changes, or changing a global to be immutable, can then cut these It's a good strategy when you first for these quick wins and act on them, reducing the warnings It's also good to look out for issues, that are at the root Sometimes a single line change If you've tried out complete checking it's also worth trying The newer SDKs include more For example, all SwiftUI views which means you no longer need to your view types yourself. In fact, you might find you can as they're already are being inferred. Once that's done, you may find yourself with a much smaller number The other thing to remember is you don't have to address If you have to ship a release, you can go back into settings All the changes you made will be valid improvements that you can keep and check in, even if you then go back You can return to that setting later In our case, once we start we see a pattern we've seen before. Several of these global variables but I think these are all constants, like the logger we saw before. We can resolve all By the way this is a great time So I just highlight the var, then cmd-option-E selects all of them, change them to lets. Build. And that eliminates these warnings. Now, I don't want to I'm making this look easier than it is. This is just a sample project, in a real project, But our experience, is that this is a common experience, and then a few harder issues to tackle. Let's take a look at the last errors. They are being caused by us between different actors. For example, this first one is saying that sending self.currentDrinks Note that save is a CoffeeData is on the main actor, it needs to be because But save is on another actor, it's on this CoffeeDataStore actor that does saving and loading And if we go back to the warning, you can see that we're sending to save in the model as isolated If Drink were a reference type, where both the main actor could have access To address this, If we go to the definition, we can see that it's a struct, all of which are value types. Based on this, it clearly and then it would be perfectly fine and then send that same array Now, if this had been an internal type, Swift would just automatically But this is a public type, with our CoffeTracker extension. Swift doesn't infer sendability It doesn't do this because is a guarantee to your clients. This type contains no mutable state today, but maybe I want to change that in future, I don't want to lock in For this reason, Swift requires you to explicitly add Sendable conformances Now in this case, I'm happy to do that. Incidentally, this is an example that eliminates multiple warnings at once: three different places that were needing In a large project, it might not be three, it could be dozens of warnings So, let's go ahead We can recompile. And we see that there's Now, it happens this is just an enum, But what if it wasn't, maybe one that could never be sendable because it stores mutable state At this point you might need One option is to reason even though it is a mutable reference type, it's safe because it was a fresh copy, You might decide that even you could protect that class, and store it in your sendable type anyway. To do that, you could again use If you do that, then the Drink type is now compiling Now, I know that isn't necessary, and instead go to DrinkType, and mark it as Sendable, too. Now that we've eliminated all our we're ready to enable Swift 6 mode So again we go to settings. And search this time And we set that to Swift 6. Compile. And it builds. At this point the whole is protected by Swift concurrency. Finally, now that we're protected, let's look at adding a new feature Our users want to start tracking their so that they can mine that data for key insights So let's look at adding So, let's go And just before we add our drink, to fetch the user's current location. CoreLocation has an async sequence that fits very well and we can use it here to until we have the at which point we can assign You'd probably want which you could do and cancellation. There's just one issue We'd have to raise CoffeeTracker's And we're not quite ready for that, we still have some users but do really want to track So instead, we're going to need based on delegate callbacks. These predate Swift concurrency, The really nice thing about is that this code looks We ask for our location, loop over until we get one that's accurate enough, all within this function where we're adding The delegate API, by contrast, wait for the delegate method to fire, and then from there, continue with saving So it's worth trying to to take advantage of these new APIs. But let's say we don't want to do that. So instead, let's remove this new code, and we're going to go and create a CoreLocation So here I have the basic implementation that can receive location updates This part of CoreLocation So I have to do more work Unlike all the other callbacks this CLLocation delegate It does not have a static guarantee Up until now, we've talked about delegates or delegates called If you look at the documentation you'll see that the guarantee it gives is is determined by the thread That's a dynamic property that Swift without some help. In our case, we're using this information So, the simplest path would be to ensure this delegate is going to be It's simple to get back into a mode We put this type entirely That means the location manager here in the initializer. And so the delegate Of course, once we do that, we get the familiar error telling us this delegate callback We've already seen the We mark the delegate as nonisolated. And then wrap the code that must run on the main actor And my build has succeeded. We've now sourcing still building in Swift 6. This was a quick tour for migrating your app There are many scenarios but we have more resources You can start which looked at using to modernize an existing app. Much of the path for was made easier by some Based on lessons from previous migrations, the Swift 6 Language Mode is designed for incremental migration So data races can be eliminated We've only scratched for bridging between static as we take on this transition You can find a guide with all at Swift.org/migration. We hope you find these resources useful Thanks for watching!