Hi, folks, and welcome back to Mastering Python. Today, we're going to dive into the wonderful world of object-oriented programming. We're going to look at classes and objects before moving on to inheritance and polymorphism in the next lecture. For those who are new here, I'm Gunnar, and this channel is all about teaching you how to program. So let's not hang about, fire up your IDE of choice, and let's dive right into object-oriented programming. Right, the best way to think of classes is as a blueprint or a template. Just like architects use blueprints to design buildings, we use classes to design objects in our code. A class defines what attributes, like the data and what methods, which are the functions, an object will have. So let's break it down. In order to create a class in Python, we use the class keyword. And here's the basic syntax. We use the keyword class, followed by the name of the class that we're going to be creating, and then a colon. The class contents, its attributes and methods, they're all indented. Let's create a simple class called dog. We use the class keyword, then the name of the class, in this case dog, followed by a colon. Now classes can have two main types of members. They can have attributes and methods. The attributes are like variables that belong to the class. They represent the data or the state of an object. And the methods are functions or verbs that belong to the class. They define the behavior or actions an object can perform. We will break down all the syntax and what all the components are over the course of this and the next lesson. So if things move a little fast here or there, just bear with it. In the end, it'll all make sense. But for now, let's expand our dog class and add some attributes and methods. Great. So we've created a dog class. As we've learned, it's a blueprint for the actual objects and objects are instances of a class. But what does that mean exactly? Think of a class as a template that defines what something should look like and how it should behave. And an object, on the other hand, is the actual thing created from that blueprint. Now our dog class is a blueprint. It defines what properties and attributes a dog should have, like a name and a breed and an age. And what it can do, it can bark, which is a method. And using this class, we can create an object or an instance, such as a golden retriever named Buddy that's three years old. To create an object from this class, we use a process called instantiation. And here's how we do it. We use the name of the class and provide it with the values for its attributes. And that's all there is to it. We've just created an object. My dog is now an instance of the dog class. And we can create as many objects as we want. Let's create another one, an eight-year-old poodle named Max. The great thing about object-oriented programming is that each of these objects is independent, and that's really, really key. They're based on the same blueprint on the same class, but they're separate instances with their own data. To look at their attributes and methods, we can use the dot notation. We simply follow the object name with the dot and then the method or attribute that you'd like to use. Here's a practical use case. Imagine we're writing a program for a veterinarian clinic. You can use the dog class to keep track of all the clinic's dog patients. Here, for example, we have three patients, Buddy, Max and Charlie. This allows you to easily manage and interact with multiple dog objects in your program. We created a list of dog objects, each based on the dog class, which we can then iterate over and print out the dog's name and breed and age and make them bark. Let's dive a little bit deeper into attributes. Attributes are essentially the data associated with the class or its objects. And in Python, we have two main types of attributes, instance variables and class variables. Now, instance variables are unique to each object. They hold data that can be different for every instance of a class, such as the name of a dog object. And on the other hand, class variables are shared amongst all instances of a class. They hold the data that's the same for every object, such as the species name for a dog, for example. In this example, after defining the object dog, we declare a class variable called species. And it's the same for all dogs since it's declared for the class. So each instance of this class gets the same value for the variable. Name and age, on the other hand, are instance variables. They are different for each dog because they're set individually when you create the dog object. When we run this, you can see that Max and Buddy both have the same species, but different names. We define class variables directly in the class outside any method. And instant variables, however, are typically defined and initialized in the init method. The init method is a special method in Python classes that's called when an object is created, and this is called the constructor. Let's make a new class, a cat class, for example, for all the cat lovers out there. There we go. We've now got two classes, one for cats and one for dogs. You can access both class and instance variables using the dot notation. And here's how. We first create a cat object, a white cat called whiskers. We then access whiskers attributes, its name and species, using the dot notation that we've seen before. You can also directly change the values of attributes, as we do here with the color, though it's generally best not to change variables directly, as we'll see in a little bit. Also be really careful when modifying class variables. If you change the value of a class variable, it changes for all instances of that class. Now methods are functions that are associated with a class. Think of them as actions that objects of that class can perform. Just like how a dog can bark and a car can accelerate, objects in our code can have their own set of actions and behaviors. Just like attributes, we can have class and instance methods. Instant methods are the most common type of method. They operate on individual instances of a class, so on the objects themselves. In this example, bark is an instance method. It's called on a specific instance of the dog class, and in this case, my dog. Class methods, on the other hand, are methods that work with the class itself, rather than the instances of the class. And they're defined using the class method decorator. You remember decorators from the earlier lecture? So here's an example. We define a math operations class, and this math operations class has a class method called add, where we add A and B together and return it. And in this case, add is a class method. We can call it on the class itself without creating an instance. Instance methods are defined inside the class, just like regular functions, but with one key difference. They always take self as the first parameter. The self keyword is a crucial part of object-oriented programming in Python. It's used within instance methods to refer to the instance of the class that's calling the method. Now, in simpler terms, self helps Python understand which specific object we're working with. If we look at our dog class again, self is used both in the init method, which is called when we create a new dog, and the bark method. The self keyword is particularly useful when we need to distinguish between instance variables, attributes of the object, and parameters passed to a method. For example, in the set dimensions method, self.width refers to the instance variable, while width, without the self, refers to the parameter passed to the method. It might sound a little confusing at first, but this will become second nature in no time. So always remember to include self as the first parameter in your instance methods. Python will automatically pass the instance when you call the method, so you don't need to pass self explicitly when calling the method. Now, I've mentioned constructors and the init methods a few times now, so let's have a closer look. Constructors are special methods in Python classes that initialize new objects. Think of them as the setup function for your objects. The main job of a constructor is to set up the initial state of an object when it's created. It's like preparing a new car before its first drive. You need to fill it with gas and adjust the mirrors and set the seat position. In Python, the constructor method is always named underscore underscore init underscore underscore, as we've seen. So let's create a new car object. We use init to instantiate the object. It's our constructor. It sets up the make and model attributes for each new car object. When the object is first created, we need to provide a make and model attribute. The constructor then sets the instances make and model to the attributes we've provided. In this case, the make of the car object is Volkswagen and the model is a Golf. Constructors always have self as the first argument, followed by any number of arguments. Now, we also have something called destructors in Python, and destructors are methods called when an object is about to be destroyed. They're used to perform any necessary cleanup when an object is no longer needed, and this might include closing files or network connections or freeing up any kind of system resources. The destructor method is named underscore underscore dell underscore underscore for delete. And here's a simple example. We use the destructor to close the file that we've opened in the constructor. A Python uses automatic garbage collection, which means that you usually don't need to worry about manually freeing up memory like you do in languages like C++ for example. The Python interpreter keeps track of an object references and automatically frees memory when an object is no longer in use. However, for resources other than memory, like in our case handling files or if it's network sockets, it's good practice to close them explicitly when you're done rather than relying solely on the destructor. Right, and this brings us to encapsulation. Now, encapsulation is like wrapping up your data and methods that work on the data into a neat little package. And the main idea behind encapsulation is to protect our data from unauthorized access or modification. And we achieve this through what is called information hiding. In this example, we've created a bank account class and the balance is stored in a private attribute named underscore underscore balance. We can't directly access or modify this balance from outside the class and instead we use methods like deposit and get balance to interact with it. In many programming languages like Java or C++, we have three main access modifiers. We have public modifier, which means an attribute is accessible from anywhere. We have a private modifier, which means that attributes are only accessible within the class like underscore underscore balance in our case. And there's a third one called protected, which means it's accessible within the class and its subclasses. Now, Python doesn't have strict access modifiers like any other language, but as always, we use conventions. A single underscore at the start of an attribute name suggests that it's protected and it can only be accessible within the class and its subclasses. If we use double underscores, this indicates that the attribute is private and should not be changed directly. So bear this in mind when you're writing your classes and encapsulating your data. Right, when we're dealing with objects, we often need to compare them, but how can we do this? Now, there are two main ways for doing this. Firstly, we're using the equality operator and the equality operator checks if two objects are the same object in memory. So not necessarily the same content. In this example, even though person one and person two have the same content, they're different objects in memory because we've instantiated them separately. So they each independent objects in memory and therefore the equality operator returns faults. However, person three is the same object as person one because we've created it using person one. So the equality operator returns true. Often though, we want to check if two objects have the same content, not if they're the same object. And for this, we can implement a custom method called underscore underscore EQ for equal underscore underscore in which we manually check that the attributes of the objects match. By implementing the equality method, we can define what it means for two person objects to be equal. Firstly, we make sure that the object we're comparing with is an instance of the person class. If it is true, we simply compare the individual attributes. Right, before we end, let's look at some important best practices that will help you write cleaner, more maintainable code when it comes to object oriented programming. In Python, we follow specific naming conventions for classes, methods and attributes. Now, class names always use camel case instead of the usual snake case. And camel case means that each word starts with a capital letter with no underscores. However, methods and attributes still use our usual snake case, which is all lowercase with underscores between the words. Here, for example, bank account is our class name in camel case, while account number, balance and deposit money use snake case. We also follow the single responsibility principle, which is key to object oriented programming and states that a class should have only one reason to change. In other words, a class should have a single well defined purpose. For example, here instead of having a user class that handles both authentication and email sending, we could split it into two classes with each having a well defined purpose. Finally, keeping classes focused and cohesive is closely related to the single responsibility principle. And a cohesive class is one where all the methods and attributes are closely related to the class's main purpose. For example, a car should only contain methods and attributes related to a car's properties and behaviors like accelerate and break. And it shouldn't have attributes of the different speed limits of the roads, for example, that it drives on or methods for paying for the parking. And there you have it, class is an object, a general introduction to object oriented programming in Python. Hopefully it wasn't too difficult, but if there are any bits and pieces that are still a little bit unclear, go back, rewatch parts of the video, do the exercises that you find on the website and object oriented programming will become second nature in no time. Next lesson, we're going to look at inheritance and polymorphism, some design patterns and other more advanced topics. If you found this video helpful, consider liking and subscribing and I'll see you in the next lesson. Until then, happy coding.