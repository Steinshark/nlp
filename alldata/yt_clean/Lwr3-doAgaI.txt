[MUSIC] Hi, my name is ThePrimeagen, husband to a beautiful wife, I love data structures and algorithms. Not only are they useful in your daily In this course, we're gonna cover arrays, some interview questions I've had along Along with that, including searching and sorting. Remember, this is engineering. The best thing to do is have fun. So I hope you enjoy this course. We're gonna first tackle Big O, cuz I do feel like Big O is kind of that it just means I'm gonna be saying And it just kinda sucks, you don't know what it is. So Big O, the easiest way to put it is or memory based on the input. It's not meant to be an exact measurement, someone's not gonna say, your You're gonna first say, well, how did you come up Instead it's a generalized way for algorithm will react as your input or And so, if someone says, this is Of N, it grows linearly based on input. We'll go over some more. And so why do we use it? Well, it often helps us make should not use a specific data structure. You'll see as we do this that data constraints to make them more and But if you use them incorrectly, unperformant, I don't I know what the There we go. So here, we're gonna take For those who know Big O, So if you don't know Big O, You wouldn't have a way to be able to kind this code. You wouldn't actually have the lingo. So hopefully, we can do that, To say it differently, Big O, computation or memory grow? number 1, growth is with respect to input. just remember that, put that in your head. a real trade-off in the sense that depending on how much memory you have to These things are not necessarily free trade-offs, you can't really trade create memory. memory, in some sense your algorithm So it's not necessarily for free. So let's go back to our example. So, how does our program Well, I conveniently but notice that it is a string. So it has a length and has a series Strings are effectively arrays, really, So, here we go. So if you look at the for loop, loop has to execute That means if our string grows by 50%, 50%, it grows linearly. For every one more unit of string, So there you go. That is the simplest way to put it. And for those who did not see that, me, it's O, that's O then. You can see it right away. So how can you tell? Simplest trick in all of it is where do you loop over the input, easiest way to kinda tell the big All right, so when we look at this, you'll we have a function that goes over and that are happening here in this string and What's the running time of this function, &gt;&gt; O of N? &gt;&gt; Okay, we got one O of N, anything else? Cuz we do a sum and I was really hoping, 2 of N, hey, you know what, O of 2 of N. Yeah, you're right. And what's the running time? Right, no, it's not that, Second most important concept The reason why is, here's a very good constants, though practically, speaking theoretically they're not important. If you had something that you'd clearly see as we get down here, It grows disproportionately fast in is in front of the linear O of N. So yeah, so that is why constants we're not trying to get exact time. We're not trying to get this is how It's how does it grow? If I'm gonna give this thing 10,000 as N, am I gonna be able to do it fast? Is it gonna be instant? I need to kind of just generally And so that's kind of the heart of Big O, We can implement this, and I think we dang simple. And it'll also be your first sorting an algorithms class has to at least So I do expect everyone to open Okay, you don't have to, But let's look up Bubbl sort, open up and it's, of course, So hopefully everyone can do this, So again, remember our algorithm. We need to be able to translate So what I'm gonna do is I'm gonna let's just kind of think about We have an array from 0 to N, and not including N or N minus 1, we're gonna take i and So we don't wanna go off the array. If we are using a more traditional what happens? Array out of bounds exception if what I had to program with. If you're in C++, you hack yourself, things happen if you go off the array. So we don't wanna do that, I don't wanna be reading HTML, And so, what we want to do is we want Okay, so that seems pretty easy, right? So we're gonna go for That's our thing. We need to do this n times, right? We gotta keep on bringing that And that means our inner loop needs to be the special magic and doing all that. So it needs to go up to n-1. But remember, every single time we do So we can also -i. Does that make sense? We keep getting progressively For the zeroth case, we go to n-2, for the second case, And from that point, the only thing we have to do is If the array i is greater than array j, That's really all we have to do, right? I mean, It's extremely simple algorithm. There we go. Obviously, when we write this out, All right, so We have the idea in our head. So of course we always do, I'm positive writing out for loops, raw for loops. I think I've seen it called on Twitter. But this is just what you You gotta write these for loops. So let's go here. Let's do an i and the j loop. Awesome, so hopefully everyone has that. Now we need to do something Remember, we got to go up to, but the first iteration cuz we're So, let's -1. Then remember, the last element becomes We don't need to redo that. So, we're also gonna -i, There we go, we've now translated just a little bit more mechanical, So, if array j is greater than array j+1, Swapping always not all that bad, whatever your first line is, Copy that, and go arr[j + 1] = tmp. There you go. Simple swap, right? I should have just created I don't know why I didn't. You just have to write it yourself, And now this should be So I jump back here, npx jest Bubble. Michael Bubble, that would have been so much, I should That'd have been great. There we go. And so now we've just written Bubble sort, This is an extremely simple You should just be able to do this I just did it first try, so But, I mean, if you really think about, simple algorithm, In all technical perspective, binary search is significantly harder than We did it, awesome. Your first sorting algorithm, Is everyone pretty excited about I'm excited. Effectively how a map works, is that we And what the keys mapping to a value Consistent, Hash. All right, so what this means is some key that is uniquely defined, it will If it doesn't give me the same answer What is it good for? Absolutely nothing, okay, So now what we have to do is we Now JavaScript is particularly creating these structures, walk through every character in the string We could have a number and use the number the string. But what we don't have is an object. If you just hand me an object, I can't that object in the sense that if you 5), right? My goodness, great 5. Nah, let's say (foo: 3). And we'll call this thing constf, right? And then you create another one t, You can't tell the difference You don't have a way to be able to say, In Java you do, you can call git hash ID in which produces a unique identifier for This may have changed in JavaScript, but Someone can prove me wrong. I'm sure there's someone that I'm quite positive. You just can't uniquely identify You can only uniquely identify them based So if you have two with the identical, Which means that our key look up really Because you could actually have two be two separate objects, but So for our case, if we do implement one, as our entrance into it, which I don't So let's just talk about how this works. So we can do something like this, that takes in the key and needs to produce And this is the important part the reason why is let's just say K comes And it can be a really big number, there's not anything specific to it. Then what we can do with that number is, we can modulo it based on, say, So say ten. And what that means is that if say we have this many items, I realized That means our key, whatever we give it, can uniquely map to one of the bins And we can just say, plus the value inside of Then we map another one which say, And then we put the key and the value. But every now and then, and since we say only have ten slots, if they uniformly go to any number, it It wouldn't be that great. So if you had a perfectly uniform chance of collision, which means that Well, we need a way to Now, when I went to college, I know, whippersnappers, what we used to do, that you'd actually do something Meaning we would literally go down to And we always store the key with which means that if you did this, So as things become less and you're gonna need a larger amount of load factor to prevent collisions, Cuz the moment you have like five items then having to linearly go down gets So, in more modern ways, is that instead you use a list underneath So you have an array list that has then we just walk the array list. Sounds good. list underneath the hood, because you And so long as the keys sufficiently what we're going to see is little sub maybe sometimes two, right? As long as you have a good hashing So how does retrieval work? Well, we go through our magical We pass in a key, we go through our we then modulo that with we now have an item into it. Well, the problem is, is there could be multiple items inside So that's why we store the key plus say, hey, key, are you equal to that key? You're the same key? Well, guess what? That's your associated value then. Get on out, right? We can actually do that and get it on out, So it does have some sort of, But then as you think about it, maps tend to be pretty simple creations. And that's really all you're doing. Deletion, exact same thing. You go to that spot within your array with the value, remove it from You now have it removed, of course, there is always one problem. So I believe the ideal load factor is believe is considered the ideal this linked list style storing. If you do that, we need a way to be able to redo this, So something we can do is that we what it is, and we can iterate through and then we can rehash them and Thus cutting down our load factor, say, then we have a bunch more And this is the effective way in [MUSIC]