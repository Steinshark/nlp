It's important for software developers to In this course, Jim from JimShapeCoding will teach Python object oriented programming, it could be developer. And as well as lending your first job object oriented programming course. Now if you oriented programming in the past, then you are in this course, I'm going to make sure that this about classes and the complex concepts that are going to do this by developing a real Python write. And we will add to its complexity step by everything that we need to know about object be some requirements to this course, I do expect variables, if statements and as well as for other programming languages, then this let's get started. Now to explain why you I will explain the concepts based on a store together. So starting to think about how to we could first think about tracking after the way we could get started, we could create those So as you can see, we have our first variable item variables that are intentionally starting with the those four variables are related to each other you might think that those four variables are same prefix of item one. For Python, those are So if we were to print the type, for each of those with no surprises, right, we will receive string, Now I want to focus on those specific outputs types, we also see the key word of class. Now this of strings or integers. So in Python programming that has been instantiated earlier by some been instantiated from a string type of class. those have been instantiated from a class that have been nicer. If we call the tail Python it will allow us to write a code that we can each instance could have attributes to And we can think about at least some good item datatype, like its name, price, or quantity. first class. So I will clean everything from here, divided into two parts, the first one will be the the part that I will instantiate some objects of or creating an object, basically I mean to the those. Alright, so let's go ahead and say class. of the class that you want to create. So we would of this class, in the future, we are going to very useful for us. So we won't repeat ourselves But for now, temporarily, I'm going to say here a class definition. Alright, so now that we have some instances of this class. So let's go ahead is equivalent to creating an instance of a class, then you will say something like the following. is very important to understand how classes are because this was just for an example. And now I to instances of a class. So let's go ahead and achievable by using the dot sign right after the want to give it an attribute, like a name, that could be equal to 100. And I think one dot Now in that stage, you might ask yourself, what that we have created to those four lines? between those four lines, because each one of the class. And I could probably do this by going ahead well as the types of the attributes of name, price we are not going to have any surprises because we But if we were to print that, then check so you can see that now we have a data type of what we have seen previously to this thing that we can create our own data types. Now let's go using object oriented programming. Okay, so until instances, we should also understand now how we instances. Now, if we will take as an example, the have some methods that we can go ahead and execute you can see that I grabbed an instance of a string the next line and execute the opera method, which the letters and turn them to uppercase. Now the design some methods that are going to Well, the answer is inside our class. So we could will be accessible from our instances. So we could Now a good candidate for a metal that we'd like because as we understand, it could have been ahead and calculate the result, multiplying it one get the total price for that specific item. Now then I'm going to just create one more instance because we understood the example. So I'm like that. And I'm going to use something like that we have three of those. Now just a quick then I basically mean two functions that are or in any programming language, when you have are considered to be called functions. But when classes, then those are called methods. So that because I'm going to call those methods by opening up and closing those parentheses, is autogenerated that Python wants us to receive Python passes the object itself as a first methods. Now, if I was to go here, and then the action that we are doing now is calling method from an instance, then Python passes the So that is why we are not allowed to create Now you will see this if I was to remove the first was to execute this program now, then you're going zero positional arguments, but one was given. is that Python tries to pass one argument and you very problematic. And that is why you always have ahead and create your methods. Now since we always approach to call this self. It was okay if I was something else. But you never want to mess up developers. So that is why just make sure that go ahead and run this program, then you got to see this means that this method has been implemented benefit from creating this method, because it using price and quantity. So I will intentionally name just x&amp;y for now. And we could just will go ahead and pass in here, two additional The second one will be quantity. So that is in the background, Python passes this as an And then this has been passed as a third argument. and actually print this, so excuse me for running expression with this print built in function. expected, now I could do the exact same thing for So if I was to grab this and paste this in, two, and change this one to item two, and 3000 as expected. And that is how you can we understood that we can assign attributes and as and use them from our instances directly, like that line. Now in that episode, we are going to best practices in object oriented programming, project that is based on Opie. Alright, so let's we have here is the fact that we don't have a set pass in in order to instantiate an instance that for each item that I want to go ahead and like those in here. And it could have been nicer order to instantiate an instance successfully, otherwise, the instance could not have been that it could have been a great option if we could second that we instantiate an instance and there that is by creating a special method with a very init double underscore. Now you might hear this that is a method with a unique name that you need use its special futures. Now, the way that this is So it will be double underscore. And as you can special methods that are starting and ending with methods are used to be called Magic methods. And that you have in Opie, but the first one that we underscore, like that. Alright, so now that we what this metal does in the background. So when then Python executes this double underscore it means that now that we have declared our And then since an instance has been created, and then it is going to call the actions that double underscore method. Now in order to prove point here that will say I am created Like that. another one. So we should see I am created twice. to delete those print lines from here so we can run our program, then we can see that we have I am this double underscore init double underscore we have graded. Alright, so now that we use the we should take benefit from it and solve some practices. Now if you remember in the beginning that we have till this point is the fact that we saying dot name, dot price dot quantity. And Now let's see how we can start avoiding creating instances here. So we can actually benefit from designed. And let's see how now we understand will go ahead and call this double underscore init that not only we can allow ourselves to receive thing that we should do, because Python in the first argument, we could, in addition, take some So as a solder, let's say that we would like to name. And as you can see, automatically, Python not filled in here. So now, I could go ahead and for the second one, I can go ahead and pass in the then I can actually go ahead and change my print line where I can identify from where each an instance created and use a column here and we have created this, then if we were to run our an instance created for the phone, and as well as this, then there is something that is still the attribute of name here and here. So now pay the self as a parameter as well. And we already have self as a parameter here could actually allow so that we will not have to go ahead and assign we create. So what that means, it means that instance from this magic method, which is called dot name, so I'm assigning the that is going to be created or created yet, that is passed in from here. So what that means, this line. And then this line. So as you can thanks to the self dot name equals name that attribute assignment world, then I can go down the following. So I will print it one dot name, order to avoid confusions, then I'm going to the print lines from here. And now if I receive a phone and laptop. So it means that we And that is perfect. And now that we get the idea rest of the attributes that we'd like to receive. care of. So I'm going to go to my init price and quantity. And I'm going to do the exact of price. And that will be equal to price. And the can also see that again Python complains about the So I can say 100 and then five, and then I can I could pass In 1000, and then three, and delete to work, then I'm going to copy myself a couple of this one will be price as well. This one will be run that, then you can see that the results are work with the double underscore init method, that you want to assign to an object inside the constructor. Now a couple of signs that are quite Now when we go ahead and use the Ws coordinate differentiate between mandatory parameters to non don't know how much you have from a specific received this quantity parameter as zero, because know how much phones you have on your store. value for that, for example, zero, and then this five and three here. And now in order to show you then you can see that we receive zero twice for that you will want to remember. And one more quite is the fact that you can assign attributes to you want to know if the laptop has numpad are not the right side of the keyboard. But this is not a to a phone. And that is why you can go ahead And that is why you can go ahead and say something that. And that is something that you want to attribute assignments in the constructor doesn't you will like after you instantiate the instances understood this, then there is still one small Now pay attention how the calculate total And the question that we asked now is why it still now not received those parameters. Because as we then the object itself is passed in argument. And But this is where I failed to understand classes. this behavior. And we already know that the why we receive self. And so this means that now by self dot quantity. And this will mean that we because we assign those attributes, once the we have access to those attributes through how this class in the future. So in order to delete this example for now. And I'm going to say will be able to return the result here. And I will Now to show some real number other than zero, then will say one and three, for example, because I zero. And that could come from here. So I will run results. So now we completely understand the big classes, and what are the best practices that so now that we understood this, then we might But actually I want to show you what will happen an integer and run our program. So if we were to things up here. Because this function for example, times because you'll see we have 1000 multiply shows us 1000 once, 1000 twice, and then one more to validate the datatypes of the values that we achieve this. And one way is by using typing's in so a great starter will be, for example, to first take this back and change those to integer So in order to specify a typing, then you should type of the datatype that you expect to receive reference to the class of str, then it will mean can prove that by changing this to an integer. And that says expected type str God int instead. And then I'm going to do the same for the price same thing with it by passing in float. Now when And that is something very unique with floats use the typing of float. And for the quantity, we that we passed a default value of integer already that is why, for example, if I was to leave this you're gonna see that it is going to complain, So it expects for an integer. All right, so those function more powerful. But we might still want to So say that you never want to receive a negative receive a negative number of price. So that typing's in here. But there is actually a great assert statements. Now assert is a statement between what is happening to your expectations. So actually going to delete this from here. And I'm I'm going to say here a comment and I will say something like run validations to the received to validate that the price and quantity are both don't want to handle with those when they are So we could say assert and pay attention that or something like that. And I can say here, once I said this, then I can also do the same for By this way, and then once we have this, then And you will see that I will not receive any to negative one, for example, and this one being that will say, assertion error. Now you can see is quite a general exception, that doesn't a third, you can add your own exception messages up top here and go back to those two lines. So the the statement that we'd like to check. But if we actually formatted string, and I can say price and zero like that. They can add an explanation Copy that with a comma and paste this and then refer to the value of it and say that to zero. So we need to be actually changed And same goes for here, and I have some a so now if I was to execute our program, then you minus one is not greater or equal than zero. and now it is perfect. So now we understand us to validate the arguments that we receive. soon as possible, before going forward with within this program. So let me actually change that is perfect. Alright, so until this point, we And we also learned about how to assign different unique per instance, which means that you can go and you have the control to pass whatever price and quantity. Now consider a situation that going to be global, or across all the instances could be a situation that you will want to apply a go ahead and having the control of applying some a good candidate for creating an attribute that Now we call those kinds of attributes, class have learned that till this point is actually So about instance attributes, we know but we did not work it with the other kind of the which is called again, a class attribute. going to be belong to the class itself. But from the instance level as well. Let's go ahead that you want to go ahead and create it. So And just in the first line inside our class, So let's go ahead and create an attribute like doing this is because I said that there is going an attribute that will describe how much I still after 20% discount like that. Okay, so now that ways that we can access this attribute. Now, if I and say something inside this print line that will to the reference of the class itself. So I'm not I'm just going to bring in the reference to the this attribute by saying the PE underscore rate. that as expected, we see this class attribute, those class attributes. Now this might be can also access those class attributes from the So if I was to duplicate those lines twice, by and change those to item one, and this one to attribute from the instance, although we don't run that, then you're going to see that we still that might be confusing. And that might be Well, there is actually something that we need to So when we have an instance on our hand, then At from the instance level at first stage, but if it bring that attribute from the class level. So what here and say to itself, okay, so I don't have this an attribute that assigned to me. So I'm going and then I'm going to find it and if sprinted Item one and item two are instances that could not So both of them went ahead and try to bring it really exists in the class level, then we you a better idea of what is going on here. Then will delete these first print line. And I will as well. Now there is a built in magic attribute, all the attributes that are belonging to that this double underscore vi CT double underscore bring you all the attributes that are belonging want to see its content. So I will go ahead and level as well. So this will give me all the will do this for the instance level. then let's explore the results for a second. Now pay rate attribute. But in the second line, we And you can also pay attention that this magic attributes and convert this to a dictionary. And it is just a shortened version of a dictionary. you can go ahead and use if you just want all the attributes that are belonging to some then let's take it to a real life example and a discount on our items price. So that will be by our instances in that means that we can go ahead discount. So let's go ahead and start working and pay attention that I'm using a new method then add first we need to figure out how we are to an instance. And we already know that we can self dot price. And that will be equal to self dot multiplied by the pay rate. Now you might expect if you remember, that is actually belonging to the because this method already inside this class. it directly by saying pay rate, because it is going to work. Because you can either access it understood previously. So we can go ahead and say metal that can go ahead and basically override Now to show you that this works, then I can only call this method by saying apply discount. And I for this item one, and we should see ad right. So that we are going to receive at point zero as that you might also want to have a different one day you will have 20 items or in only for the it is going to be a bad idea changing the class items that you have right now on your hand. So attribute directly to one of the instances that for so let's go ahead and see an example for item or laptop and then what I can do to apply exact same attribute to the instance. So I can go is equal to 0.7. Now what will happen here is of pay rate in the instance level. So it does and bring back the value of pay rate because instance level. But for item one, it is different, which is going to be 0.8. So now, if we were and as well as printing the price now, then let's line to not see this screen for now. And I will that we still, however, receive 800. And what this applied is still a 20%. And where this is coming that no matter what we try to pull the pay rate be to change these two cells. And that way, if then it is going to read from the instance level. from the instance level, then this is still great, item one. So it is going to pull that from the then you're gonna see now that we have expected the first print line for the item one and rerun we had 20% discount. And for item two, we had class attributes, you might want to reconsider up with some methods. And specifically it is a great idea to access it from the instance rate that is assigned to the instance level. about the differences between a class to an next topic. Now you'll see that I have deleted And I came up with five instances that I have those five instances immediately. So that is why accessing these class attributes directory, and the code from these five underscore items.py file. going to be larger in the future, meaning that you that you're going to have the more filtration But what is problematic currently with our class we can just access all the items that we have in if we could somehow have a list with all the item But currently, there is not an approach that element will represent an instance of a class. here is a wonderful candidate for creating a class this, then we're going to see how we are going to and start by going here and use in all attributes. Now we need to figure out how we are going to add go ahead and create an instance. Now if you is being called immediately once the instance going down below inside this double underscore responsible to append to that list every time easy as saying something like the following. So wrote some commands in this double underscore to save object. So it might be a great idea to to execute just to really have a great separation So now inside here I can say item dot all and and then that is a list so I can use dot append we know that self is actually the instance itself go ahead and launch such a command inside the created, this all list is going to be filled with line after we create the instances, and we can say program, then you're going to see that we're going scroll right a bit, then you can see that I have that's going to be extremely useful if you want of your instances. So say that you'd like to then you can use easily a for loop to achieve such in item dot all and you can say print instance, you can see that we have all the names for all the be useful here and there, especially if you know apply some special things on some of the instances that we understood this, then let's also take care was to use a Ctrl, D couple of times, and still that the way that the object is being represented if we could somehow change the way that the Now, there is actually a way to achieve this by is a magic method that is called double underscore objects. So that is why you can actually go you will have the control to display your objects actually recommend watching a video that compares called double underscore str. And you can take to actually watch the video that I'm talking method to understand how this is going to work. I'm going to use double underscore r e, PR double self. Now what we can do now is returning a string Now obviously, we don't want to use something that say that I was to use now return items, something that I'm going to receive a list with this string which instance represents each string here. So that could be unique. So I'm going to close the string. And in order to make this unique, it is create the instance like that. So what I'm brackets opener and the closure. And then I'm as equal as possible to the way that we create single quotes to escape from the double quotes to the value of name by using self dot name. And use a comma like that. And then I will go ahead one more comma, and I will say self dot quantity. you can see that now we receive a list that is way And you can also see that this first element, for Now you might be curious why I worked so hard to the same way that we create them. So that is documentations because it will help us to create copying and pasting these To the Python console. Python console, and you'll import this class, then the Python console. And then you will have an reason that I have came up with this approach. And string that will really represent our instance. the instances of our class with this list. And we understood how we can change the way that we how we can access to all of our instances by this Now in this part, we are going to take a look to best practices when we are going to extend this see that until this point, we maintain our data as Those five items. Now when we will look to extend then we might have a harder life to add those are maintained in the same location, meaning about creating a database that will maintain this for the purposes of this tutorial. And that is that you might have heard of. csv stands for comma ahead and use a CSV file, and you could store your represent a single structured data in CSV is to be saved in a table structured format. file. And I will actually go ahead and name go ahead and paste in some CSV content that will same data that we look to have here. So you can and quantity. And you can see that those are comma we're going to have as the data that we are going we are going to have some data that will represent were to now split the panes, then you can see that look for a way to read the CSV file and actually have a suggestion by pi charm to install a plugin click on that and install those plugins. And you we will see if we will be able to see this data go ahead and install this. And now you can see go ahead and use from here, I know that this is you can go ahead and click on them. And if I was file more focus, then you can see that I actually you can see that I have my columns, you can see I can really go ahead and visualize my data more your data. Okay, so now that we understood how CSV files and instantiate the instances in a generic And I'm going to use those lines below I could name instantiate from CSV like that. Now, itself because if you remember I said we need to receive at least one parameter that this is how Python op works. Now, the problem is, to call this method from the instance because the object itself. So this means that this So the way that this is going to be solved is by class method is a method that could be accessed in delete that, and it could be accessed from the instantiate from CSV, and then in here, we will take full responsibility to instantiate those let's go ahead and see how we can create a class And I know that we have arrows, but we are going in order to convert this to a class method, we to convert this method into a class method. Now the behavior of the functions that we will write that we create our function. So we could use the this instantiate from CSV method will be a class then we should also understand one more piece of method. Now I want to show you what will happen recreate this function here. And I will just say what will happen if I was to open up and close the a parameter, but this time, it is named CLS. Now, on here is the fact that when we call our class as the first argument always in the background. passed as the first argument. But this time, then the class reference must be passed as a receive at least one parameter, but we probably because that is just going to be too much some code to read the CSV file and instantiate and I'm going to import a library that is called CSV line, because that will be the library that file. And then we will see how we can instantiate use a context manager to read the items dot CSV same location. So I can just directly say, Wait, will be passing here could be hour because we only Now inside this open, I will go ahead and use some end of the day will be responsible to convert this is equal to CSV, dot d ICT reader like that. And Now, this method should go ahead and read our of the day, we should also go ahead and convert one more variable that will be equal to items. And that's it. And now that we have completed the CSV file, let's go ahead and use a Shift and instantiate some objects, let's go ahead and Now I will go ahead and use for item in items. the behavior of that. And excuse me, it should be then let's go ahead and see what we have in those ahead and call this item dot instantiate then you can see that I received some dictionaries over a list of dictionaries in Here, and that is miss right now is creating instances. Now besides like item and open up and close parentheses. And Now I can go ahead and pass my arguments in here So I can say name is equal to item dot get, and and duplicate this line twice, and change And this will be quantity. And now I need to and then quantity right there. And now let's go this method. And as well as calling the attribute instances inside the list. Now if I was to go some arrows. Now you'll see that the arrows are receive is not greater than or equal to zero. So in the items dot CSV, you can see that those zero. So the problem is probably the fact need to go ahead and pass those as integers. So And now let's go ahead and see if we will have any the quantity should complain about the same thing. on here. So we can use the same for quantity like we see our instances perfectly. Now I want to show and we should avoid now. So those three lines But if I was to change the price of our keyboard and re execute our file, then you can see that we the price not to an integer but to a float like because we don't want to convert the price float. So now we could go ahead and execute although we see the prices as 100.0 but that is but for now it works perfect. And now we are ready completely understood the class methods, let's go now established metal show do some work for you, for example, if you want to check if a number candidate for creating a static method, because work with. So it makes sense to check if a price a decimal point, I obviously count out those that methods could look very alike to you. But we Okay, so I will use those lines to create our use the def keyword. And we will name this method like to write a static method that will check if I was to open up and close parentheses, this to take a closer look what will happen if I was and the approach is going to be pretty much the will use a decorator that is called static method I will go ahead and use this line and I will say how the received parameter turned into the because that is just a regular parameter that we are never sending in the background, the unlike the class methods, the class methods are And that is why we had to receive the CLS. And purple. But with static methods, we never send we should relate to the static method, like a like we are familiar with isolated functions. Now But let's go ahead and finish up our static parameter because we should receive at least All right, so now that we are inside this method, to check if the received argument is an integer like to, we will count out the floats that are for example, 5.0 10.0, and so on. Alright, so and use an if statement view. So if in we will instance. And this should receive two arguments. to do for us, it is going to check if the received So we will pass in as the first argument the num calling those parentheses, so only the reference should go ahead and check if the num is a folding I will say return num.is integer, so by count out the floats that are decimal that pass in here a number like 10.0, then this will here because he thinks it is a flaw because it is interview should check if the point is zero, and use an else if statement here to basically check instance num, and check if it is an instance of if it is just something else, then I will just designed this method, then let's take a look how and this, I'm not actually going to instantiate access to the static method. So I will just call a number that I will like to check if it is an this. So we will see the result. Now let's go receive through now if I was to pass in 7.5 then background it is the fact that it enters here, but false. But if I was to change this to 7.0 still return true because what is happening then it checks if it is an integer, but we said point zero. So it returns true still so that is a new file, which I will just explain here when method. So we can completely understand the myself I had a very tough time to understand why will be the main question that I will be answering to copy and paste the code following along what I Alright. So in this file, I will just go right and i will use pass to not receive So we will use a static method when we want to do Exactly like we have I have done previously. So be responsible to check if a number is integer include this under the item, just like I could use class. And that was also okay. But I prefer metal that has nothing to do with instance, So that is the reason you want to create this as And the reason that you would like to create from some structured data that you own. So a class metal that was responsible to read the wrote here, those are used to manipulate different have done with the CSV file, we could also use a or from a yamo file, those just are different ways is the code that you will look to include inside existing in any class, especially if you on your programs. So it is a great idea to have at item class. Now the only main difference between that static methods are not passing the object it is noticeable from the fact that we don't for the first parameter. So if you remember, if I like num, then you will see that this is the because that is a regular parameter. But that is we should receive, because what I have just between a static method to a class metal. Now class methods and the static methods could only those also could be called from instances. So as and call the integer in as well as the instantiate like five and I will not receive any arrows. see that I don't have an error. Now, I'm going call a static method, or a class method from the exists, I know that it is very, very confusing. see. And like I said, I never saw a great reason from an instance. So my recommendation calling those from the instance level. All right, in the class item. Now in order to start solving then I'm going to create here two instances. And let's give it a name like JC phone v 10. And I will copy and paste this and use another the version by 10. And let's say that this price now that we have created two instances of a phone, we could think about some attributes that could attribute like broken phones, because we could And so we cannot really mark it as a phone that we ahead and say phone one that broken phones, let's on our hand right now. So I will go ahead and And now that we have came up with this realistic about, could be creating a method that will go not broken, meaning subtracting the quantity by making sense. And then we can understand what are in the future. But we have couple of problems Such a thing because we cannot we'll go ahead because we don't really have the broken phones go ahead and create this method inside this to be useful for other hundreds of items that you phone kind of item. So in order to solve this oriented programming, then we could go ahead and functionalities that the item class brings with from inheritance. And we could go ahead and create this phone class will inherit all the methods in go ahead and simulate that. So I'm not going go ahead here and create a class that I will name semicolon and I will use those brackets and I will So I will inherit from item. And then I will just to use additional functionality right now inside class, then let's go ahead and first execute our will be item instances. And this should not have those item instances and we will not receive phone like that, then we should still a basic way that you could use inheritance in when you want to do that. Now, this could also want to come up with them and buy your own. But classes where each class will represent a kind from the item class in each of the child classes I could also use another class for a kind of item separated functionality for that. Now when we talk considered to be called parent classes. And when parent class, then those are considered to be that you want to be familiar with when we talk we will see more advanced things that you can go so now let's go ahead and understand some more this series, we learned that it is not a great those instances. And the better way to do that is and pass the value that we'd like to immediately So in order to solve this, then we're going to because creating the constructor inside because we don't really want to break the logic parent class. But we'd also like to pass in an we will go ahead and deal with that attribute and done in the second part of our series. So in order and as well as received some more attributes. Then in our constructor and just paste this in right temporarily, because we received the exact we instantiate an instance. And we also have like we want to do with the broken phones. So I will just scroll here, and I will say broken default value for that. And let's go ahead and I will allow myself to just copy that and paste broken phones is greater than or equal to zero actually broken phones, and this should be And now let's go ahead to the section of assigned phones is equal to broken phones like that. execute. Now it could have been nicer if we phone class. And that will mean that we could go then we could go ahead and use a form dot all ahead and run this program, then you can see that this works, then I'm also going to pass in as well. And I'm going to remove those. All right, and the program still works. Now I'd also like we have wrote so far in that will be obviously a because we inherit those methods. So calculate total price, and it makes sense to And you can see that print phone one dot calculate then you can see that I received a result. Now I'm not sure if you pay attention to then you're gonna see that the constructor in the let's Hover the mouse and see what is the warning. underscore in it of super class is missed. And the double underscore init method inside the child called intentionally. Now this function is named us to have full access to all the attributes of we don't really need to hard code in the attribute price and quantity. And as well as for the other that we want to come up with a child class. for each of the child classes that we will create and pasting assert price and quantity. And as those three lines. That is going to be a lot of that is exactly why we needed to use the super the attributes access from the parent classes. the best practices in inheritance when it comes to works because we assign the attributes of name, trial class. But if I was to remove those three lines are happen to be the lines that I have then you can see that we receive attribute and pay attention from what line it comes from. because it thinks that it has the attribute of the phone level. Because we just deleted the why now we have some problems. And we are going with the following thing that I'm going to just of our constructor, and I'm going to say call to slash methods. And then I'm going to say super, And then I'm going to use the double underscore second that I have completed this, then there this child class. And you can also see that these special arguments. Now those special arguments inherit from. So if I was to pass in here, name be fine. Now, you can also ask yourself isn't copied and pasted the parameters that we receive question. That is something that could be solved keyword arguments, that is something that we can to duplicate the parameters that will receive for going to show for that stage, I'm going to stick now calling the super function. And as well responsible to have the same behavior like we for this print line, and we should not see then you can see that we receive the expected practices of object oriented programming for each we also are going to need to call the super attributes and methods that are coming from so I minimize the code for our classes. And I I want to show you the results of the following is the list of all in the item class is going to And then I'm also going to say phone that all if as well here. So I will minimize the code back. something very weird in here we see item. And then that comes from the item class. Now the reason in our EPR method inside the form class. So that's can also pay attention that we only create an good that we see item in those outputs. So what of the class in the rppr method inside the item class generically. Now if I was to replace this responsible to give me the name of the class, then And I'm going to use curly brackets, and I'm dot double underscore name. So that is a from the instance. And by doing this, then besides receive the name of the class that I initialize phone, because that is the only single instance is exactly the result that I'm receiving back. using the super function, then we basically have are coming from the class that we inherit from. So the access to the class attribute of all that is attribute, right. Now to show you that, then I'm And I'm going to remove the old attribute. I'm also going to delete the actions to execute no longer having the old attribute in the and execute our program now, then you can see is a great idea removing the old attribute in the the old attribute in the parent class, because we will have access to the old attribute. So access to all the items instances that have then accessing them from item dot all should also is responsible to add this instance inside the And that's happening because by using the super basically call the init method inside the parent we also use item dot all dot append, which is so that's why calling the all class attribute it will give us the complete picture. Okay, so then we're going to need to do some code for each of the child classes that we will go project, then we're going to need to do this in file that we were working with. And now that multiple files. So that's why it may be working and working with a separate file that will idea. So we will have the main.py file dedicated let's get started with this. So I'm going to go to First one, we will name the item.pi. And I'm going to take the code from our item while the following, and I'm going to cut this and Now pay attention that I use the CSV library. library. So I'm going to just copy the import going to do the same process for the form dot p y, as well. But now this file needs to import the here. So we should say from item, import items And then in the main.py file, we can basically meaning creating data that will represent we can go ahead and import the class from form file. And then we can go ahead and do the instantiate from CSV. into verify that this works, And if we want to run this file now to see that that everything works just as expected. Now just a the child class that we have created in the latest solve in that episode, I'm going to rely more follow. And we will not complex things too much. using child classes or something like that. But it going to show in the parent class. So that's input line of the form class. And I just came up in the price happened to be that number I did not And now after this line, you can see that other items. Now the expected result is not right time when we print this attribute. But we that we always want? What if we want to restrict the name has been set up in the initialization, we might want to achieve for critical attributes the name of our item. So what we could do, we called attributes, meaning that we have only one we cannot touch the value of that anymore. So what initialization. And we should have arrows if we also known as encapsulation when we talk about which I will be focusing more on the future we can come up with read only attributes how we after the initialization of our instances. Okay, on the right side we have the item.py file which going to create our first read only attribute. Now using a decorator and if you remember from functions that you can pre execute before another decorator, and then go ahead and create a could set up the name of our read only attribute. this read only name something in that time, parentheses, and this will obviously receive self instances. And now for testing purposes, let's a three times. Alright, and then now that we have try to access this property. Now pay attention attributes. So I'm going to go here, and I'm going have wrote name, pay attention to the differences a totally different icon here on the left side, the flutter which stands for irregular field. So then obviously we will receive the expected for the read only name, say that we want then you're going to see that Python is going to that, then we will end up with an exception that how read only attributes, so called are working in decorator before your functions and return biggest challenge here is going to be converting which is happened to be exactly here into obeying little bit challenging. But let's go ahead and I'm going to delete those three lines, because And I'm going to scroll up a bit and you might think that converting the name attribute as doing something like first using the property then receive self as the parameter. And then use already have the self type name assigned to the this is like saying to that class, hey, from now going to be rain only. And that is straightforward to leave a comment here that is going to look like the self dot name into a new value inside our illegal because we have a read only property here. the name of basically name, then you are you are only allowed to have access to see So that is why if I was to hover my mouse here, property name cannot be saved. So the pythonic using one underscore before the name of our actual And by doing this, we earn a couple of things that underscore and just use something like that. And meaning the property attribute. And I'm going to Because First things first I go ahead and excuse me single underscore name into being equal ahead and use one more read only attribute that I I return self dot underscore name. Now I can go lines are having right now on our instances. So And I can access to the name of this item by So I don't really have to go ahead and use item be a little bit ugly, and not convenient. Because before is not nice for each of the instances that one time inside the class is going to make it outside of your class, meaning from the instances that is the best way to overcome such a thing. And me, let me fix that quickly by item one dot name, working. And now let's go ahead and also see if thing like that, see, if that works, I can see I can still see these underscore name from the that you look to avoid, it could have been a the axis from this underscore naming here. So one more underscore to the attribute name. Now, private attribute. If you're familiar with that is pretty much the same behavior of using those kinds of programming languages, where it oriented programming. So to sum up, if you add meaning you use double underscore, then you totally outside of the class. So let's see a the terminal, and I'm going to go to my item.py I'm going to add one more. And then I'm going And now if we were to go to our main.py file, and double underscore and try to access to name now we from my drop down, because I don't have access to that is something that you look to achieve when that is the way that you can do that. So just going to complain about how it does not in this instance. And again, if I was to remove it as a property meaning as a read only attribute. Alright, so now that we got the idea of that, set a new value for the name attribute. is going to turn this into being a read only that will allow you to however, set a new see how that is achievable. So obviously, that set attribute. So what we can do is we can use a also set a new value for this attribute that we is by going to our class here. And using here this decorator is going to look like the name because that's the property name. And then then I basically say, hey, so I still want to is a property meaning a read only attribute. So def name, and this will receive self and as well parameter should refer to the new value that a parameter that I could name something like set the new value for our double underscore name. see the value of name, then we basically return will try to set the name again to a new value, value and by doing this, I basically allow our let's show what effect those three lines are going arrows gone, I can now go down here and use print see that I have other item. So this means not only called in the initialisation, I can also do that Now those getters and setters thing are always So I will do a final summary of all what we have add property will basically give you a control of And also by using this then you basically convert implemented these setters in here. So you then this line is going to have some problems, that hey, name is read only, you cannot set then I will have the control to set this now by using this statement here, basically the bunch of codes that are being executed in Python says to itself, okay, you try to get that all the lines of codes are that are here. So show you that, then I can just use a random print get name like that, then you should see this line is. Because at first, we print you're trying dot underscore name, so it prints that over get an attitude. But when you try to set an so here, you try to set an attribute. So because execute the code that is inside here, because is why when you go ahead and use this decorator, the other item is going to be passed it is very important to understand that. And that code that will say self dot double underscore name And to show you that again, I can go here and say appear just before this print line because at and then I just print it back like that. Okay, at first we see the line of you're trying whatever item one dot name is equal to. Now we set it over here and then the next time I try executed. So that is the lifecycle of getters By having the control of whatever you'd like to it, you can go ahead and do some conditioning, If you don't like the value that you receive, of the characters for the name of that attribute. you can actually go here and say if when of to raise exception, that will say something like And then you can say else and then you can set that value. So intentionally I'm going to nine characters. So we should not have any arrows. Like that, and executed, then you can see that we the name is too long. So that's how getters and all the knowledge that you need to play around that you would like to. So I believe that after you have everything that you need to manage your as well as coming up with rich classes that will special behaviors to those attributes. And also to receive those attributes in the constructor, in your constructor. And you can say that, object immediately when you create an instance. So to play around with how to manage your attributes, principles that you should be aware of. So you programs, so it will be easier to keep developing which are encapsulation, abstraction, inheritance be encapsulation. And we will talk about this a of restricting the direct access to some of our great job in the last part, where we implemented So pay attention to how the name attribute could some conditions that we set here, like the length So restricting the ability to override the values what the encapsulation principle is about. Now to principle, then we are going to apply similar to be the price attribute. Now if you take a quick then you can already see that I have the ability that I like to also negative 900 will work here. change. And the way that we can change that is by access to this price attribute. So it could have be responsible to increment these price by some discount. Now if remember, we already came up with when we talk about class attributes, because is actually going to change this attribute being if you remember from the previous episodes, so attribute to totally support the encapsulation convert this prize into being a private attribute. price directly like we have seen previously. Now besides I'm going to grab this whole and then I'm going to say refactor, rename, setting it like that double underscore before that change on the entire class where we try to access we don't really have to change everywhere. So once in the apply discount, then you can see that that we came up with. So now that we have done So we will have the ability to access the price I'm going to say add property. And then I'm going self dot price. So that's a great starter to because now we still have access to the price see that if we were to try to access item one dot access the actual value of that where it oh actually I see that we hit an error that says not add the double underscore in here by mistake. across right now, you can see that we are going exceeded. And that happened because I tried to if we try to call the self dot price, then it is to return that, then it's just going to loop over with the recursion error as you see. So that's if you see this exception in your object And if I was to come back now to Maine and execute here. Alright, so now that we have done this, on our methods that will modify the attributes cut this metal from here. And I will just put came up with. So we will have a cleaner look. Now apply discount. And we will also like to come up will like to say here, self dot double underscore plus self dot level underscore price multiplied So we could actually receive a parameter that just multiply it by that number. So now that we I'm going to go back to our my main.py. And then and then I'm just going to pass in 0.2. So we next time that I access the item one dot price, we which should be 900. And if I was to run incremented to 900 as expected. So that is exactly you don't allow the access directly to the price by using methods like apply increments, or I was to now go ahead and use item one dot apply, in the way that you'd like to. But this currently this should also again, apply a discount of 20% to that's exactly what is happening here. Alright, so called abstraction. Now abstraction is the concept the necessary attributes and hides the unnecessary is basically hiding unnecessary details from people like me or you that are going to use the see that now we have a new program here that has being that number, and we have six from this item. that doesn't really exist, which is called send send an email to someone that would like to decide much money we can earn by selling all the items this item. Now sending an email is not as Because in the background, email sending has to server. And as well as preparing the body of the info about this item. So as we can understand before we go ahead and just call a Send Email go ahead and say send email. So I will just create use pass. Now as I said we also have to go through create methods for each of those processes, like that. And I will just say pass because we only I'm not really going to send an actual email to an email. And we will also have to go to preparing and then I can just return a formatted Someone, we could receive this as a parameter as six times, right, so it should be six. So to shave. So that is just a very simple can understand that we have to call those methods self dot Connect, and then self dot, prepare body. right, so we can just say something like send those metals at the end of the day are only Because those are just parts of the email that we divided into multiple steps in this access calling those methods from the instance. abstraction principle says to you that you should So that is why by converting those methods into abstraction principles. And that is achievable is not too much convenient, but it is achievable programming languages, this is achievable like private or public. And I'm talking about So if we were to convert those methods to then those only cool to be cold from the class try to access it, then you can see that I am going ability to access those methods. And then I will arrow comes from here, because we did not really empty string. Now if I was to go back to our are going to have some troubles. Even if I'm going I'm not even going to have an auto completion. private method. So you really have to think accessible outside of your class, meaning from the is about. You want to abstract the information from your instances. Okay, so inheritance is the inheritance is a mechanism that allows us to reuse that we have totally designed well throughout this are child classes of the item class, where each attention how I change the import line from phone which we came up with, which is called the phone, in they can still use a code that is implemented program, then we are not going to receive any and the attributes that it inherits from the remember we designed the Send Email method the instance of a phone and we can also do that that really affect some of the attributes like in the apply increments method that receives an incrementing, the price by 0.2, and then see 1200. So if we were to print that, then So that is mainly what inheritance is about. It And that's exactly the scenario here. And the more child classes that will represent the kinds that you will think about. And then you can just to the kind of item that you have. So that's Alright, so the last principle that we have now is concept in programming. It refers to use of a in different scenarios. Now, a perfect example that we already know that exists in Python. Now many forms Paulie being many, and morphism being on our programs is the ability to have different an entity could be a function that we just call. something that is specifically applied to how you that refers globally to your entire project. see some bad practices where polymorphism is not Python the polymorphism is perfectly applied. So is in the lane built in function. Because the land different kinds of objects that it receives accordingly. So as you can see in here, if we then we will have received the total amount of then we will not receive the length of characters we will receive back the amount of elements this is going to work, then I'm just going to run as expected. So as the definition of polymorphism how to handle different kinds of objects, as that the polymorphism is applied everywhere in let's also understand where it is implemented on call the apply discount method that is never fact that I can use it from the item class, And that is the basically reason. Now if I was to then you can see that that is going to work I can use from the inherited item class. Now Because polymorphism again, refers to one single if I was one day to go ahead and create that will represent different kinds of items, that's also going to work because the apply accessible from all the kinds of objects so that's of inheritance and polymorphism together combined. more class that is going to be identical to the file. And then I'm just going to say here, class. copy everything from here and paste this in like And I'm just going to leave the init as from phone to keyboard and I'm also going to phones. Alright, so now that we have this, then and use one more important line that and then I'm going to change this to keyboard will then I'm going to run the same problem, you can polymorphism is in action, because we can use this and it will know how to handle it properly. Now by you can have the control of how many inside your classes now, because if we were exactly like we used in the item class, which control for all the discounts that are going I am going to attempt the typing in pay rate. because overriding in the child class that is equal to 0.7. And that will be it. Now I have If I was again to run the main.py file, then you see 700. So that is the beauty behind inheritance for sure if we were to decide that we would like to go ahead and say pay rate is equal to 0.5. about polymorphism a bit better now. Now just a we implemented by using abstract classes. And that other programming languages like Java interface is designed. Alright, so it is like a template abstract classes, which I'm not going to cover in is a term that is implemented in different So I hope you had a great time learning Now you have a lot of tools that you can go ahead which will really help you to take you to the