Hi, we're here at GOTO Copenhagen today. My name Maybe you guys can introduce I'm Simon Brown. I'm an independent consultant I like to talk about software architecture the modern agile ways we work, especially Hi, I'm Dave Farley. I'm also interested development in general. My big thing at the moment does it take to build better software? But some All right. Maybe a quick one to start with. have been in the last maybe decade in terms of better things? What are the I'm gonna say DevOps and pass it over to you immediately because I think Well, I think without being immodest, I'm some extent. I think that is one of the things. in my introduction, which is that I And if it were really engineering it would and it does. That's what the data things, I think, using those kinds of approaches, So I would agree with that, although it No, I'd definitely echo the same thing. teams were really struggling just to get of manual steps. With continuous regression, that's optimized and automated a whole ton of you can point to over the past couple of decades And with more of an engineering discipline, little bit more formalized and structured than I think that's true. I think in part, one of agile was a step forward. It also allowed us to Are you talking about SAFe? Not only SAFe, but certainly SAFe is a culprit. Simon would agree with this, is that it made out and just start from scratch with everything. us designing. It shouldn't stop us thinking So you see lots of developers that or architecture anymore. Because we're There's a very big difference between the countered, and design. To my impression, and taking design more seriously, not less. in one giant leap springing from your brain. It's complexity and systems over time. And part of that evolution safely and in a controlled manner. the quicker delivery of new stuff to or is there more to it than that for you? does. People say that the Agile Manifesto you should not do upfront design, to kind of from big, upfront design to basically nothing, And in order to move fast, in order to embrace the DevOps tools and CI/CD tools to move faster engineering-based way, you need a good design. actually says, &quot;A continuous approach You don't get a good design just by hacking into it. And although I completely agree that way because we're gonna get changes and I think you still need a starting point, a starting point with some principles in place. higher degrees of modularity so you can move I feel that you're saying that your design the things that you learn from pushing stuff stuff in place in the beginning already. Forgive me if I'm putting words in you start off with a model, with an idea of what engineering principle is that you start off with That's the step to engineering for me. you work in a way so that when you find Yeah, right. And that's very different to big design upfront all those years ago they assumed to come up with was the thing they should have a starting point and be prepared for that give us the tools to make those changes easier Okay, so what are the stuff that you would focus long term and what kind of architecture you need to support the final product, but you're are the non-negotiables? What's the stuff that you version that you're pushing out? I think I can set you up for fleshing more detail. So from an engineering point of view, the managing complexity. I would start to try and that I'm able to understand the pieces and change I would say that's a deeply profound and And then, if you're able to do that, so if you're more cohesive, good separation of concerns, good loosely coupled between those piecess, that's the find out you screwed up and made manage, make the code a habitable space that I understand it, takes that, and gives you tools Yeah, I was gonna say, it's literally the same of software architecture where he says, &quot;Software All of that stuff is significant decisions. whether you're building a monolith or And again, it's, how do we make this thing so having this whole blast radius effect that And I'd argue to some degree that architecture is It allows us to build systems that are beyond Or at least a part of it of the system Yeah, you compartmentalize it so Yeah, okay. We've seen a lot of the have moved into the common domain. If we look more than ever the ways that we can You can do that on so many platforms now. With Do you think that people are hurting I do. the room, so let's name the elephant. I think that Like Simon, I'm an independent consultant, that claim to be adopting microservices, aren't If they're starting something new they start by are, creating a separate repo, and then What they've just done is build latency at the order to be able to learn. So the other aspect of want really fast, clear feedback. If my service every time the conversation between those You're changing them in two places. or he's gotta dip in mine, and it's a we still have nice, service-oriented designs. tell me that I've screwed up his service. further? And when you're starting out, the team is put it all in one repo, like host it all in one No, that would be my recommended starting did a talk at a GOTO conference a few years I have a very similar talk. now with talks. They're finally becoming thing, a whole bunch of people have got application. It's a horrible mess, it's brittle, convert to microservices.&quot; And what they do their approach to modularity, which is not and they're basically sticking JSON over HTTPS That could have been in-process costs. The boundaries are hard to change and you've got fragile, and slow. And they just don't get that Don't get me wrong at a certain scale Maybe. I mean, Facebook, Shopify, there are some huge, big thing on their engineering blog over their Ruby on Rails monolith to become much more I'd argue that modularity is always good communications all over the place, and often you people put it. Both of those things amp up the Not just the complexity, also how hard it will And even just deploy. Just to figure out, what is my software doing in something that you take on from the get-go, that always felt like one of the most important This is why some big organizations who are autonomy but they have internal engineering teams and service teams. So literally you can bootstrap your service, and you get observability production GCP environment. And in a standardized way, and that's fabulous. do it well and at scale is it's the most scalable consistency for independence. So this is the but it means that if I'm writing a microservice mine without testing it against his. That's how kind of table stakes. You can't really count it as the decoupling step. That's the point at which we protocol has gotta be stable between it. So you've be able to get to those stable protocols. architects because that requires both the business boundaries in the right places. Because otherwise, Yes. not do this because it's hard. Exactly. Are there any tips that you can I'd go talk to Sam Newman. He's got a I'd talk about a few things. As well as characteristic of microservices is that they're good reason for that. So Bounded context is there's an area of the problem in which a concept we're buying books. The shopping cart is gonna control is gonna have a notion of the delivery. It's different. The delivery probably needs The shopping cart probably wants to have author or something. They're different but that's the difference between two different with a Bounded context, those are naturally the system. It's not 100% but it's a good starting each of these services is aligned with these argue. And then you need to still go back to what to find out all the ways where you screwed communications too tightly coupled until Is that something you look for in your this alignment between what the business domain Sometimes. So I'm the creator of the C4 architecture diagrams, and one of the questions between things like a Bounded context on two And sometimes there is. Sometimes those concepts, times you'll often find a Bounded context spans C4 model containers, like different services. the architecture world, the technical aspects of think that's okay. But I think people perhaps need there are too many people saying, &quot;I must stuff in DDD and stuff in my architecture". never seen it in reality. I think there's another aspect to this. I think and essential complexity in architecture, and little bubbles of domain logic that know nothing And then I'm gonna build the accidental of messaging, all those sorts of things into the therefore, they're isolated from it. If you can flexibility and freedom because you're simulating I was involved in writing something called &quot;The and I was involved in building a financial the most beautiful big system to work on that I've of domain logic was single-threaded so they were to worry about anything, and everything else was all of those things, were outside. They were not out of the code base, Oh, the domain part. Okay. One of the things Application Runtime, DAPr. I don't I haven't looked at that. No. The closest commercially available are actor-based systems of one form those kinds of things. Yeah. you're right, your services against a package abstracted key value storage, you have abstracted of it in your code is abstracted, and in your It works on Kubernetes with sidecar containers, so talks to the other services through gRPC. further in abstraction than that. Yeah. So for example, I could have an account &quot;Create an account,&quot; and it would create an And it would send out a message maybe saying, No storage, no persistence anywhere else, but no so I could just record the message that kind of thing to get back to the same state. way, and the state as a result of events. It's part of the accidental complexity. It's be a ridiculous thing to say, but it's a very nice about this, but I think it's an interesting There's moves towards stateful things of just very well yet in my impression, but I think could imagine offloading a lot of the accidental raising the bar. Because not everybody is an about all of those things at the level of detail But perhaps they should do. I'm gonna rein this a big fan of abstraction, and particularly do you remember how enterprise Java has been enterprise Java beans, and then somebody locally and you could use the same interface, And that abstraction was fantastic but there could be a network call here at runtime So I think abstractions are great but those abstractions are, and what the tradeoffs of back to the earlier conversation, is about up front. It's like, where do we want Absolutely. I wouldn't disagree with that at all. not enterprise. It's the same story. I'm a C# kind of done, what are some takeaways that we could What was the single move that you see a lot that From my perspective it's people just jumping on considering the tradeoffs. So that's why I'm a big a good, simple way to visualize your potential Because then you can evaluate it, dry run it, just make sure you have a clearer idea of your I think I've got two. The first one is, I My perception of most software systems that it's that there is no design. They're just, organizing principles that you can discern. Yeah, and that's problematic. There's no big ball of mud. And so I think as an industry enough design. We don't think about it. We argue or whatever else. That doesn't matter as much Is there maybe a problem in our industry then? Yeah. I agree, but let me finish communicate about things. You see lots of conferences where we this small building block as one. And where on a very big scale we want to be doing he graduates college until the point where there are so many steps to take and there are the path to there is not something that is in the middle, like the run-of-the-mill solution something a lot of people have to learn on their about it. Because those are not sexy subjects Yes, that's why we have so much work. There's and training, and skills in most organizations. all the new hyped trendy stuff sells. Our essential fundamentals that people really need If you'll forgive me mentioning one of One of your competitors in organizing conferences. I don't work for Trifork. One of your competitors had an adoption graph I of these new, sexy technologies, and all this kind things. And the late majority was where continuous laughing because I was just saying, &quot;Really? You that continuous delivery is normal?&quot; It's not. No. talk about in terms of these engineering What do they say then, because their stuff they're doing continuous delivery? delivery and you're not. Continuous delivery is all of the time, that's it. And if you adopt that being much more disciplined, caring much more sorts of things. Because you can't do it if you And we don't have many things like that. If we as software engineering it would make us build we wouldn't count as engineering. Continuous But you can't do continuous delivery running the system in production. but it's not optimal. It's better. What you need you need the team to be monitoring, understanding other people that are looking after it. up but at least they have to not, like in over the wall and it's ops' problem now. off topic, which I apologize for, but my advice to a releasable state once every hour. You can't And you can't do that if there's waste in the process. So every time there's a hand over between that's waste. So you have to get down to these and they need to know a lot of stuff. Trying I think that one of the problems in our by sexy technology that we lose our focus. I've always used as well, magpie development. Shiny things. shiny, I wanna have that. I'm gonna use it I did a little exercise recently for a book that I application in the latest sexy web technologies, And in the code that I wrote and needed to of the code in the technology of 1995 Now the Angular stuff gave me stuff that I more browser indepentence and all those sorts of there's no progress, but there's nowhere near we're too close to the hardware. And they've Software development doesn't move at that Something that has bothered me when we're has become a job title or a function description What's your take on that? comes along and there's a lot of good stuff really understand it and just copy what they We've seen it with everything haven't we? my YouTube Channel, I'm publishing a video on 7pm UK time. But one of the things that I say to be close to the birth of some reasonably people that invented DDD, and DevOps, and a from what's going through those inventors' heads, There's this, kind of, dilution effect. just reads the words and assumes Everybody thinks that continuous delivery is about frequently. It's not. It's working so your Yeah, and getting the whole Everybody thinks that microservices is APIs in a separate repo, and it's not. and they're all like that. And I think we fall to as one of the people that helped popularize term because it's so easily misunderstood. practices are extremely good. DevOps evolved, earlier than DevOps, but they co-evolved from continuous delivery coming from development. the same ideas to a large degree. if you understand both sides of the problem. the first place. Exactly. It's like bringing Climb over across the wall. That's Yeah, like, break down the wall, make not about, like, we need to hire a guy No, no, it's not that. This is what it has turned into, sadly, sadly so. about and drawing some similarities between build big structures. You have an architect then you have the engineering teams that have to and make it so that the bridge doesn't collapse In that world, those things go really well most terrible job. Are there any engineering takeaways give the audience to incorporate I think that there are. That is the theme in so I'm touting my own wares. But I think we should be optimizing to be experts at that, should optimize for that. Good architecture plays We need to be able to get fast, efficient feedback so that we can make progress incrementally and so they can work on one part of the system without Part of Alan Kay's definition engineering, in general, was about making And I quite liked that as a takeaway. And I think optimizing for learning, optimizing for we could start to build a genuine discipline and I think we need it. to apply that same technique to software where we way to build the thing that we want to build. And work. There's a great talk, again, I think at a works for the Software Engineering Institute. And the building world and the software world, and she cue all your stuff. And she says, &quot;We're still And again, a lot of that is because We are learning a lot as we go along. Technologies those underlying fundamentals and principles of the technologies and the techniques not a building architect or a structural engineer my idea is that when you design a structure around stresses, and strains, and load make sure it doesn't fall down. once you start to factor in things like DevOps, things like continuous testing, this whole Evolutionary Architectures&quot; book, and that's are a way to start doing some of that. So if you you build yourself a bunch of fitness functions targets, for example. So yeah, I'd like The downside of it is it's hard, and it have to get some benefits of doing it, I guess. significant advantage that if you are you probably computer model it to do all that And you'd test the model and all that kind of no empirical discovery that's required after that. we have is that production for us is free. So once and design, and you've got your sequence of or complicated, or distributed it is, you press for essentially free. And I think that's I agree with Simon that software development in but I think that we do know some of those I think if you go back a number of years, people They created a model of the system they wanted When I went to Dubai a number of years ago, the of models in the basement that show you how they sides of the building. You need to do this stuff Burj Khalifa and then stick it in a wind tunnel. it's not worth doing. And I think 20 years let's model the software without building it. And simulate it, and you're right, Because that's the biggest difference between you're looking at the cost of constructing a new something you already built without sinking Hopefully. That's the other key difference, to my mind, Software engineers are usually starting off Sorry, I shouldn't have sworn. "Oh, damn, this is gonna go wrong, because to think about the ways in which our system because that's how you do a good job. given me. Whenever there is a fire in production because those are the days that you learn so I did some consultancy for a bank a few building resilient systems, and we walked into this roomful of people, and everybody was a bit if we're building resilient systems we're wrong from the start.&quot; And they said, &quot;What? We I think engineering is about assuming stuff and predict where it is that it might go wrong Kay's presentation where he talked about Facebook should've been doing to avoid that kind of outage. you should've been doing when it goes wrong. And always behind the scenes so that nobody notices. you so much for joining us today and for and enjoy the rest of your conference.