um hi everyone i'm roy roy barkan um and uh as mentioned we'll talk a little bit about the argument passing this uh is an interesting topic that uh seems like a very much like a beginner thing but uh there are some subtleties and uh delicate points to to uh to think about and uh hopefully you'll learn some uh cool things as we talk um so i'll start off by saying that uh i'm not an expert on this i'm not a committee member uh and uh as i said i'm just a dude if you have anything uh that you disagree with please uh ask uh ask questions uh and i'd be happy to learn together with you guys um so my name is rory barkhan as mentioned i mean i'm i live in tel aviv in israel i've been doing a c plus plus for quite a long time now and uh currently i work for a local high frequency trading company called the eastern research in israel where we do a finance and algo trading a lot of cool and hard technological problems if you're interested you can feel free to uh reach out to me um and since uh kovid have been uh you know getting much more online than i used to and got there really addicted to civilized meetups both in israel and around the world there are several german meetups that i've been attending regularly and i really like it i try to participate as much as i can and ask questions and i really encourage you to ask questions and make comments as well um due to the setup here i'll probably answer most of the questions around the end but feel free to ask anything and uh we'll get to the uh to answering as we get as you wrap around wrap up towards the end so um the talk uh uh today is mostly about the simple fast core guideline f-16 civil pass core guidelines for those who aren't aware are just a set of guidelines um initiated by uh brian strasstroop and herb sutter uh trying to encourage people uh to write simple plus in a safer and more modern way cbs plus as you know is a very backwards compatible language so there's a lot of uh his history to uh writing code and many things can be done in many different ways the guidelines are meant to help us and know how which parts of cpr plus are best to use and how to use them and the guide on f-16 has to do with passing arguments to functions and here's the guideline it says there for in parameters past cheaply copy types by value and others by reference to const okay so that all sounds quite reasonable and quite logical and they also say that the reason the reason is that both of these alternatives they let the caller know that the function will not modify the argument and uh they are both fine for our value uh arguments being passed in um however um the guideline you know doesn't hasn't told us yet when should one choose um passing by value and one by reference and here's the their little description saying that uh c2 copy is something that isn't uh really uh hard or easily known it's something that depends on machine architecture and usually two or three words uh are best passed by values and the reasoning that they give is that nothing beats the simplicity and safety of copying and it's faster in in some cases if copies is cheap than actually passing things by reference so that's the guideline and uh to give us a little bit of a concrete idea oh yeah let's look at examples um so here are four different functions that are very very similar um doing similar things to objects of different types so first up we have this scaled down function that receives a vector of doubles many many doubles and wants to divide all of them by one single element okay and so it goes in a for loop divides every item by one single element and we choose to pass things by value because double is a small object okay and it's cheap to copy similarly if you want to do a similar thing uh not with doubles but with points maybe a two dimension or three dimensional points uh it's still relatively small so we pass it uh an origin location by value and we can move all the points um by some specific origin or based on some specific origin location again uh cheap to copy pass by a value then if we move on to larger objects that are maybe um not so cheap to copy we can have maybe a rotation matrix like a a change in the in rotation and changing perspective that i might want to do to many many objects many many other rotation matrices so here again i'll multiply every item by some delta and because rotation matrix is larger maybe four or nine elements i go and pass them by cross reference and similarly if i want to add the suffix to many many strings those strings can be potentially um expensive to copy strings you know many times require uh memory allocations and so copying is hard so again we use the const reference so these four functions are very very similar and based on the core guideline we use either const reference or pass by value for different types okay one of the main questions that i thought to myself as i was reading the the guideline and as i was thinking about the new advances uh to modern c plus plus is what should people do with templates okay so uh i have a template function again very similar to all uh the ones above where i want to accept a container like a vector and a value and perform some binary operation on all the items i need to think whether i want to use pass by value or pass by const reference and the trick thing here is that the value here is templated on so i can't really know if it's going to be if it's cheap to copy or uh if it's uh maybe expensive to copy so i want i want to ask you and ask myself what's the best way to write such a template and how can i write a template function that it works based on the uh core guideline f16 okay so this is what we'll try to answer and think about throughout this talk today okay so um for a trying to answer uh this question uh by myself i try to look around at the other pieces of generic code in the stl and see what what do they usually use okay so in most cases inside the stl uh the method used is passing by const reference okay the logic as far as i understand behind it is that passed by value can be uh cheap for cheaply copied items but it can be very expensive in some in some cases and password reference is generally always relatively cheap that's uh the the main assumption that people can use and think about and for that reason both in both examples uh here the call operator for a destruct plus uh uses a pass by reference and similarly the remove algorithm in the stl that wants to remove an element from a sequence it also takes the type t by uh reference you should note by the way that for plus operator it typically is used for cheaply copied items you know plus is usually an arithmetical type of thing and arithmetic k objects you usually think of them as relatively small but as we've seen in the examples uh previous slides um sometimes uh even uh uh even arithmetic objects can be relatively large like large vectors matrices etc so that's what the stl usually does there are a few cases where they do pass things by value um and one important example one such example there are cases where a copy is needed to be done anyway okay so regardless of whether it's cheap to copy or expensive to copy there must be a copy done at least once in some algorithms like in this accumulated function if a copy needs to be done then there's i guess no harm in doing it as part of the argument uh passing mechanism okay so accumulate has uh some initial value that can be passed to it that initial value gets modified inside the the function and the and returns back um so in this case we do a pass by uh by value get the copy regardless of whether the element is cheap or expensive to copy a copy is needed anyway so why not pass by value um there are other cases where a copy isn't needed but copying an item is much safer and i think a main example for that is actually the constructor of std column column bind i'm not sure how much you remember std colon column bind but it's a mechanism to basically create function objects out of other function objects it's like a functional approach and in this case here i uh i wrote an implementation that divides every element in a vector by some constant a and that the constant a is is passed through the constructor to sd bind and then uh we get a transformer that divides everything by a and in this case because there's a construction a construction of an object uh you know being used and there's a potential risk of the lifetime of the bind object being longer than the lifetime of this object a uh then the stl chose to have the constructor get the elements by value and they also uh uh store store its uh value in that reference for for use later on okay so uh that's uh what the stl does and before trying to maybe write a mechanism that is more generic and tries to really adhere to um to the guideline and tries to really write my template function in a way that behaves differently for cheaply copied and expensive to copy objects i want to address a little elephant in the room in a sidebar about an ocean called aliasing i don't know how many of you have heard of it but anything is actually an obscure but quite important part of the way that the cpus works especially when with regards to arguments but even more generally when it comes to pointers and references so where what's aliasing aliasing is uh basically the notion that uh if i have uh two objects or two references uh especially they can actually be a reference to the same place okay and if i go and try to write the scaled-down function that i showed before using const reference okay you see it's the same function is here but its behavior will be very very unexpected if i go and try to scale down a vector not by some arbitrary value but uh scale it down by one of its own members so this call here scale down of my vector um scaling it by the first element you could think of it as sort of like a normalization operation trying to normalize the first element to one and everything else to normalize by the same factor but when the scale down function is implemented using a const reference the behavior is actually very different from what's expected let's uh go to compiler explorer and see that effect so here's the code base you can see that i create a vector with three elements all of them are equal to two and i want to scale scale the vector down by its first element and i would expect all the elements to be scaled down to one and have a vector of one one one but actually that's not the case and the the first element gets uh divided by itself to become one and then the rest of the elements they don't get changed at all because they are actually get divided by one itself okay so i hope where this example is understood that the object or the argument a is aliased it's it's actually the same value or the same object as the first object in the in the vector and for that reason inside my for loop after i divide that first element by itself then a also gets changed okay so a although a is a const reference and it's it's const there is a way uh for my code to change it as i'm running okay and this is perfectly legal c plus plus this is the the behavior that the standard defines although it can be a little bit unexpected and when we look at it this way okay so uh this is a tricky thing and uh there are also other cases in the real world where this thing can bite us for example here's a piece of code if you know the erase remove idiom that tries to take a vector of maybe non-uh unique items and they remove all instances of the maximum element okay so if the vector has multiple items that are equal to the maximum i want to remove all of them and uh this code is actually a bug and it will not uh perform what we expect and there's we'll see the example of this exact code a little later on and again the reason is that the sdd remove will accept this max element object by reference and even though and max element will return an iterator to the maximum element and the star operator will convert it from uh an iterator into a reference and that reference will be used inside std colon corona remove and uh as we go through the uh the vector uh in in the remove algorithm uh the the element itself or the reference itself might change and the things can go horribly horribly wrong uh if you look at the the documentation for cd column column reference in the cpp ref if obviously they call it remove sorry in cppreference.com you'll see there's an actual warning about this specific case okay so as you can see this is tricky stuff okay when you look at this code it's really it's not so easy to understand that a problem can occur here and uh i think things can be even more complicated when we think not just about functionality but also about performance um okay so uh we rarely consider it uh ourselves and it can lead to strange and rare unexpected bugs and uh the compilers on the other hand they can't ignore it and the performance uh can can really really change when we move or switch from passing things by value to passing things by const reference so um let's uh see the effect of aliasing on performance by taking a really really extreme example okay so let's look at this foo function that i wrote here again very very similar to the previous ones i take a vector v of doubles and the coefficient and i want to multiply each and every item by the sinus of the coefficient okay and this function that i wrote takes this double by a cons reference and uh as we've seen uh before aliasing can give us unexpected results and even if there are there is no aliasing and if the coefficient is not at least with the items the performance can really really be different compared to passing the coefficient by value we'll go to compiler explorer and see it in a second if we like but first i want to try and give you some intuition about why the uh this risk of aliasing why passing by reference can harm performance okay so the basic thing is is that the compiler has several optimization that it can do in general but uh are not possible uh when the compiler is afraid that there might be aliasing that there might be a chance that the coefficient here is actually one of the elements in the vector okay so first opportunity it has to do with registers versus memory okay um whenever the compiler uh you know generates assembly it wants to uh to move whatever elements are heavily used and commonly used into registers and keep them in registers as long as possible but it's they it can't be done if the underlying variable that the object which moved into the register um uh you know has been worked with could have been changed okay so uh if uh so in this case if we move the coefficient into a register as we uh walked through the vector and change elements in the vector the compiler cannot be sure that uh the vector itself isn't also uh pointing or looking at the coefficient so the compiler has to reread uh the coefficients from memory uh time after time to be sure that the value hasn't changed in the middle okay or to take the updated value okay another thing that compilers typically do and can cannot easily do where when it comes to references and aliasing is vectorization okay vectorization is also where something that people sometimes refer to as a simply simd um it's it's an operation where the compiler can use specialized assembler instructions to perform multiple arithmetic operations on multiple items at the same time okay and in this case uh you know most comp processors both uh you know regular x86 processors as well as arm processors and also gpus they have the ability to perform multiple uh multiplications or several multiplications at the same time at once but if the compiler suspects that one of the multiple uh or one of the parallel multiplications will actually change the coefficient in the middle of its operation it will become illegal to do all of them at once you have to do them one by one and this uh can really hurt performance okay and uh the last opportunity that i can think of that's relevant for this case is what's known as expression hoisting okay expression hosting is an optimization that the compiler tries to do where it tries to see if there's any calculation that's done inside of a loop and it can be moved out and and taken and be calculated just once outside of the loop okay and in this case um if the compiler knows that the coefficient is not part of the vector then the compiler can also know that the sinus function is what's known as a pure function has no side effects and has the ability to move this entire sinus calculation outside of the loop calculate it just once and then multiply all the items in the loop but if there's a chance that the coefficient itself might change throughout the loop then suddenly this expression hoisting becomes illegal and cannot be done okay so these are several opportunities the compiler is not able to do when it sees that there's a reference to the coefficient and there's a risk of aliasing and uh this is an extreme case and it can be really really uh uh harsh in terms of performance i don't know where how much you think it is but here's what uh um cpp bench tells us with the with the google benchmark as we can see passing an item by reference in this specific case can make our our hot loop this loop run 40 times the slower 43 times lower than passing things by value so as you can see this can be very very uh important if this is the code inside your main loop so beware okay if we uh go back a little bit into uh compiler explorer this is relatively uh you know tough to see around here but um here's here's our code there's the reference implementation there's the value implementation then the only difference is uh whether the coefficient gets passed by by value or by reference and it's really uh it's not so easy to see in the assembly but if you look really really closely you can see that the by ref function has these calls to [Music] to the sinus function you can see this call here at 940 and uh and it's actually inside the main loop okay um and and this here's another call and these are inside the main loop whereas the implementation of by value i can can actually do it just once uh hoist it and there's no need to call sinus calculation time after time again okay great um let's uh uh move on and talk a little bit more about the aliasing and compilers and this uh performance penalty and how we can maybe deal with it in our own code base okay so first i should say that the compilers they really are aware compiler writers are really aware that this is a major issue and that performance can really go down if they have to be uh so conservative so uh a lot of the work of the optimizers is try to uh prove whether alice is possible or not possible so even if when the compiler tries to um generate code for function that accepts several arguments by reference um where some of them might change the compiler really tries to prove to itself if there's any uh reason or any case where the different uh references might at least to each other and whether this is a risk okay and if the compiler is able to prove that there is no aliasing then they can create the high performance code even for a function that accepts arguments by reference okay and uh there are actually also cases where the compiler is not sure but they can can think that the performance impact is so large that uh the generated code will actually uh check for aliasing in runtime okay so if the compiler can do it there are cases where the generated assembly code will start by checking to see whether a reference to cons or a reference might alias some other vector or some other region of area if there is aliasing it will go to and run the slower variation of the code and if there's no aliasing at runtime they can go and they run the fast code so that's something that's done by compilers but my personal experience is that compilers are really lacking still in this area and they can try to prove that there are many cases where they are not able and they go for this worse performance okay um in the c language there's a way for us to help the compiler there's a keyword called restrict that programmers can use to uh annotate their variables or their arguments to tell the compiler this this pointer is a restricted pointer and it cannot alias okay so the general definition is that if there is a code block that has a pointer or an array in c that is a restrict point or array then uh the the developer the you know the programmer basically guarantees the compiler that uh uh there's there's no other there's no place inside this code block where this area pointed by the rest pointed by the restricted pointer will change either than through that pointer itself okay so if a function in c accepts several pointers into several regions of area and one of them is a restrict pointer then i'm basically telling the compiler that it can be sure that no other pointer will actually point or change that area appointed by the restricted variable except through this home pointer itself and uh if for some reason i tell the c compiler that a pointer is restricted and there actually is a aliasing in runtime in my code base then it's considered undefined behavior the compiler can ignore it and there's no reason for the compiler to even give a warning or treat anything here especially okay cpus pass it doesn't currently have the restricted keyword and many simplex compilers do have some support for for similar things but it's not part of the standard um and this means that in c plus plus we don't we don't have the ability to really tell the compiler easily uh that we know something about what's going on and the compiler doesn't need to worry about things and this makes our life harder um the reason why uh this uh keyword exists in c and not in c plus plus is uh i think because in simple plus things are more tricky okay if i add a new qualifier to arguments uh you know currently every argument can be const or volatile or const volatile now if there's a different qualifier or restrict we need to think about what does it mean for function overloading is a function that accepts a restricted reference different from a function that accepts a normal strict preference uh similar to const and that's a really tricky part so um implementers really or i think um the simple wars committee wasn't sure how to how to do it um also in simpleplus there are references not just the pointers uh there are potentially template uh objects that are getting instantiated and again we need to think ourselves um is a template to of to is a vector of int different or or the same than a vector of uh restrict int uh things like that and uh um there's also the issue of uh functors and lambdas that need to accept sometimes the objects by reference and keep and keep the references to themselves and we need to think about whether uh if the argument that i get the lander accepts is a restrict argument should it take should the restrict property be propagated into the lambda itself so this is tricky and that's why the restrict uh keyword hasn't been adopted so easily into civil wars and hasn't been adopted yet but there have been various suggestions um to try and add similar uh uh capabilities into the language all of them are relatively old like more than two years old i believe and uh so far as far as i understand there aren't there isn't they aren't really moving forward too much into the standard so there was one uh proposal um to add up like an attribute called alias set where the programmer can uh give like add attributes to various references or pointers saying that uh they might alias with some other uh variables but not with others there's been a suggestion about adding things to the library like std column column this joins function where that i can call which will be sort of like a precondition for my function when i call it the compiler can know to not actually generate code but uh understand that uh this is uh this is like a precondition for my function and and then and generate code as if the two different uh references or two different arrays are disjoined and do not alias with each other and there's been also uh suggestions of maybe adding as like attributes to span and md span to say that a span of various elements is a restricted span meaning that the others spans or other pointers or references will not also you know alias or pointing to the same data in the span but all of these as mentioned have not been added to the standard yet as far as i know there are there aren't really a lot of productive discussions to adding into the language okay um i should also say by the way that uh in c plus plus anything is type based okay so if i have uh two references to a double uh or and they might potentially aliase with one each other but if i have in uh a reference to a long and a reference to a double then they cannot aliase and the compiler knows that there's no reason that it's undefined behavior to have uh two uh uh two references pointing to the same address of different types there's a notion of what similar types are and uh if i have for example a union of uh double and longer than that union i can do those uh um strange things perhaps but but then not much more and even with the union there's the notion of the active member and if a union of a double vlog currently has a longest act as being active uh also looking at it uh through a double reference is something that isn't a defined behavior and uh the compilers so if we have several references of different types uh the compiler is allowed to uh make the assumption that they will not always with each other and uh by the way std calling column byte and car are special uh um you know types of uh of objects that can potentially aliase with with everything else um and this means that the compiler uh has a little more opportunity to assume no aliasing if several types are are involved and this by the way is something that people sometimes overlook when they think of a strong type this okay so strong type diffs um as we know are mechanisms to make the compiler more aware of the actual um you know attributes or the actual meaning behind the different types and uh so we won't get confused and let the compiler give us errors if we try to uh for example uh add uh seconds to meters or do some inappropriate calculations between different types but uh something that people don't think about that much is that strong types can also improve performance because a reference to emitters cannot also cannot alias a reference to a second um and that can really help because the compiler is much more aware of what can be done and then if i go and try to you know multiply several rotation matrices by one rotation matrix there's a change of aliasing but if i uh have strong typedefs for like an object orientation which is actually a rotation matrix and like a camera orientation which which might be a rotation matrix the compiler will know that um a camera orientation and object orientation cannot enlist with each other okay if it makes sense and this is another motivation for us to try and start using strong type tips more because they can really improve performance in several cases okay i should also note that although the uh steepleverse language has these relatively strict rules about aliasing and on aliasing and there can be undefined behavior in many cases and most compilers relax the rules a little bit and there are some cases where although uh the signals language says that two different references cannot alias and it can be undefined behavior otherwise the compilers will actually check for aliasing and will actually um not be aggressive with optimizations uh favoring more predictable executions over performance knowing that some programmers might use uh unsafe reinterpret casts and these types of things and the compilers prefer a predictability over performance which can be a shame for us i guess okay so that's uh my uh prelude about aliasing and now let's get back to the um uh earlier uh discussion of how do i write a template function uh that uh that can either get things by value or get things by reference and how can i write a library that tries to cater to all different types so uh one thing that uh i want to say is that regardless of what the library does uh it can be very very powerful to also let the whoever uses my library um uh give me some hints or give me some advice about what to do and how to do and this is something that already exists to some extent even in the language itself so um one thing that uh you might be aware of is something called the reference wrapper used by std column colon ref which is a way to basically wrap a reference into something that looks like a value and something that has semantics which seem like a value semantics and if i uh use std column colon ref with the bind constructor then the the object that gets passed by value into bind is not the actual object a but a reference to a and the reference wrapper is sort of like a trick that existed since uh cps 98 it's a an object that inside it has a member that points to the object a and has a casting operator that can be uh the thing that can cast that pointer into uh reference to that object um so it's a nice uh trick and it can and if you find yourself using a library that is templated maybe and it wants to get an object by by value then perhaps sometimes you can use the std column colon ref to make things easier and to avoid their paying the the cost of copying a large object into and outside of that function um you should notice note that the std reference wrapper is relatively delicate it's not uh it's not easy to do everything with it um you know the rules about when a compiler is allowed and not allowed to invoke the casting operator are relatively delicate so it's not a i can't promise that whenever you want to uh avoid the passing things by value you can just use sd card column ref but you should keep that in mind and i should also say that if you're writing your own template functions that do accept the values by or to accept arguments by value uh you should consider and think about cases where your whoever uses your function might want to use std quote unquote ref whether it makes sense as well and whether you can write your template functions uh to be um accepting and willing to to take these types of arguments okay there's also the opposite uh way to give power to the caller um in cases where i want uh uh the function wants to receive uh you know a pointer to uh to accounts reference or so i want to receive a account reference and i want to pass it an item by value to make sure that there's no aliasing okay so this is uh what we can do here um there's this usage of a decal type of colon colon value type is basically a way for me to convert the reference that max element returns into a temporary object and that temp and and then sdd remove will accept a reference to the temporary object instead of getting a reference to inside the vector okay instead of this decal type colon colon value type ugliness there's a there's another simpler code called the decay copy it's not part of the standard but it actually appears as like a helper function uh in the cpl standard itself and it's relatively easy to uh to implement such a function and uh make sure that in this decay copy um it knows how to uh create a temporary object if it receives something uh by reference but not a incur an extra copy if it's not necessary so let's look a little bit at this uh source code and uh see the behavior of the sd card corner remove with the amx element so here we can see a compiler explorer again i have a vector that has a four ones and a single maximum element which is two and uh i copy it uh so both vectors v one and v two have the same four elements and now we can i use the erase remove idiom first time on v1 using uh just asterisk star element and the second time i use this decal type quantum quantum value type trick to create a temporary object in reference to it and we can see in the output of compiler explorer that uh the second vector v2 has uh the size that i expected only the second element uh the maximum element was removed but there on the uh first uh example on v1 the you know aliasing really uh uh hurt us really shot us in the leg and there we suddenly get uh have a vector with only two elements and again this is perfectly legal uh plus code there's nothing uh undefined in here this is the way that the compiler should behave okay this is you it's on you to know not to pass a reference into the container when calling uh std colon code removed i hope this all makes sense and uh a short look at uh a decay copy um so here's an implement uh you know uh you know suggested implementation for decay copy you can see it's a template uh function that gets a um universal reference uh for for uh for a value and just affords it um but it returns std column colon decay t okay so if i if the the function accepted the value type it will return a value type but if it accepts the reference it will still return a value type okay and uh this this way we can write a nicer code with the k copy and then get the exact behavior as we wanted okay there's also by the way a suggestion uh to the superior standard to create a new language facility called auto x where one could really uh just instead of calling a copy they could just use like uh auto as like just to create a temporary object of the type that it is and to basically materialize a reference into an object okay great um [Music] so uh now that we've seen all of these things i want to uh go and look at a way to create a general template function that can uh pass get accept things by value by reference based on uh uh based on whether they're cheap to copy or not and i'm actually uh you know taking a a suggestion from herb satter okay in cppcon uh 2020 last year herb sarger talked about this exact notion of passing arguments for input for output etc and he also noted that there should be a simpler way or simple way to write a template function that accepts an argument either by um cons reference or by value based on whether it's seek to copy and he gave some a suggestion on how to do it as or seeing how complicated it is in the c plus plus a 20 as it is right now and uh his suggestion makes use of a c plus 20 concepts okay so this code here is relatively small that's i wrote it in a little larger font in the next slide and let's see what the suggestion is okay so the suggestion is basically uh to write the same function for uh twice okay once uh receiving uh the argument t by a value and the second time receiving it by cons reference and using the simple class requires mechanism okay simple plus concepts mechanism in order to let the compiler correctly choose which of the two implementations uh to uh to use for different uh types t okay uh before if we uh didn't have the required slots here the compiler would uh see these two full functions as ambiguous to each other okay but now in c plus 20 with requires if it's like a sphenoid mechanism to have only one of these two functions actually exist for each and every type t okay and uh uh so sutter actually created this uh or suggested this notion called the should pass by value to v uh which uh could be true or false for different types he also gave a suggested implementation uh using a context for boolean um and the suggestion was saying that if something is trivially copyable and its size is smaller than eight bytes it can be passed by value v i should know that this is not something that really hurt things that should be added to the language okay uh herb just said that if we wanted to implement the template function in the correct manner for input input arguments c plus 20 this is the way to perhaps do it and he wants to suggest for newer versions of the language to have a simpler way to do this thing because this is quite a cumbersome and complicated um what do you think about this approach do you think this is something that we can do and work with right now when we write our own uh functions food that are templated i personally think um that there are several things that you know aren't really uh don't really make sense to me uh when i look at this code let's go through some of them uh first of all um we can see that this is simple as 20 code but in herb's example um should pass by value v is a context of boolean and not a concept okay um uh herbstatter could have chosen to define this as a concept but he did not okay and uh this really puzzled me regarding why why did he use a conceptual boolean which is an older mechanism and not a concept and i'm not sure but i think that the main reason has to do with specializations okay um cos x or booleans can be specialized and if i if i would have written my function for like this then any user that has a type t that may be uh and who isn't really satisfied with this condition over here can specialize should pass by value v for their own type okay concepts cannot be specialized okay um secondly it's obviously always important to think about this condition and why why did he choose this condition not some other condition uh we can see that we you know we know that the core guidelines says something about the two or three machine words okay and uh this size of t smaller than eight is actually i think very very restrictive i potentially would have done something uh would be something larger but again this was just an example that he gave i don't think he really gave it much thought but then again maybe i'm wrong and uh thirdly i'm really concerned about the fact that the function foo needs to be re-implemented twice there's really a lot of code duplication a function foo is a large function it and you need to duplicate it twice it's really really uh a big shame and if you think about it it's really hard to get away with it or to get around it because uh if there's if those two functions have some uh share or they all share their code they want to call some share the uh functions themselves they want to um you know extract all the shared code into some other internal function then you need to think about whether this internal function uh should receive the argument uh by value or by cons reference so it's really really difficult and without using some ugly preprocessor mechanics i don't think see an easy way uh with this kind of code to avoid the code duplication which is a shame okay and uh lastly and this is something that by the way herb starter also mentioned um this code doesn't really think too much about aliasing okay and and this function foo if it just accepts one argument then there's potentially no no not much risk of aliasing perhaps maybe only aliasing with some global state um but still um um as we as we saw different types t uh if they would automatically be implemented with passing by value or passing by reference means that uh the behavior the the functional behavior of the function of the foo in cases and on those different types can be much much different in in face of aliasing which is tough and i think that uh you know any library that wants to be smart needs to also you know at least hint to the user uh about anything and let the user give us some guidance regarding uh what to do with aliasing okay so that's herbs code and now as we uh you know moving into the uh final part of uh of the talk let's uh i want to show you my suggestion for a way to do uh this type of functionality maybe in a simpler manner okay so this is a my suggestion and again i'm starting off where a herb such a left off with a context of boolean should pass by value v but instead of having uh two implementations and utilizing the requires clause mechanism to choose between them i try to write a single function a single apply function um but uh which which will have a different argument type based on based on whether type t is uh is easy to copy or cheap to copy or expensive to copy and uh the mechanism i i use for that is the std column column conditional okay so i said as far as i remember was added on 6.17 and it's a nice way to basically um based on on some compile-time boolean choose between two different types okay so based on this compile-time boolean uh a copy or f is either a value of t or a cost reference of t okay and now my function apply can accept the value argument by a const reference okay and inside the function implementation after i received it by cons reference i uh create an internal member called v which is either an actual type t or or another reference okay and so for cheaply copied the items the the object will get passed sadly by reference into the function but then uh copied into the stack into uh an internal variable and then the compiler can know that there is no aliasing and can give us the best performance whatsoever and uh in case the object is uh expensive to copy then the reference will be passed into a function be kept as a reference inside the variable v and then uh and i won't need to have to pay for the uh for the expensive copying that they might uh you know that might hurt me okay and then if uh there's any reason or any case where uh the user of my function um is concerned about aliasing even if they have an expensive copy argument and they are concerned about anything then they can just uh pass an extra boolean telling me um that uh they want to force things to be passed by value they want to uh specifically um you know have a copy made uh if necessary just to make sure that there is no aliasing okay so that's uh the potential idea and that's uh my suggestion um it's still a little bit tricky that night and and not so nice to uh you know to look at all of this but at the end of the day it is a single function uh where uh where uh you know we can use uh either value semantics or reference semantics based on the different types and uh as mentioned i'm sure you might have nice ideas about how to improve it actually when i presented the version of this talk uh earlier this year uh on the dresden cps user group i got some great uh suggestions and incorporated them here so and i'm sure you'll have some suggestions as well yourself okay so uh wrapping up uh this is uh basically all that i had to share today and uh so to summarize it all uh argument passing as uh um we know in c plus plus is a hard uh issue and it is it does uh um make sense to have specific core guidelines about how to do it and it's something that we need to think about when we design our own functions and our apis uh aliasing is something we rarely think about it can uh cause rare uh bugs that are hard to find and also very frequent performance losses so if i uh use a passing arguments by cross reference i can sometimes leave a lot of performance on the table concepts in the simpleplus20 requires clauses uh can make it uh easy uh for uh library writers to capture nuances and have and let the compiler uh do uh more complicated things that existed before but things are still hard and there's all still issues related to uh um to a co-duplication and also related to specialization and uh when you write your own templates i really i want to encourage you to think about your users think about how they might want to use your your functions in your code a little differently than what you expected uh so think about ways where when they might want to use std column code and ref or decay copy and try to make your template code as as positive and as accepting of these types of things yourself okay so that's what i had planned for today i'm very very happy to answer questions and listen to your comments so uh thank you thank you very much for the wonderful talk we already have a number of questions in the q a tab and audience please feel free to add some water there the first question concerns slide 10 so maybe if you could go back to slide 10 though yeah i'm trying um we're currently seeing slide 13 i don't know no it's legend wonderful uh the question uh daniel asked is isn't the compiler allowed to assume that cool f is unchanged because it is marked as const uh and now someone asked the question yeah but the performance should then not be effective was what then you are sorry i just got it confused with it's good okay yeah great so uh so the compiler is not allowed uh to assume that the co-f will not be unchanged uh as discussed this is a tricky part in c plus plus where uh having uh you know a variable marked as conch reference means that it's not allowed uh to change it's by itself but if it's a reference to some place some other place uh then it's totally legal and totally fine to change that other place and assume uh that and the compiler must assume that that change will also affect the other accounts references and it's uh so the compiler is not allowed to make any such assumption and that's where the performance penalties lie okay okay wonderful the next question concerns slide 10. slide 12 sorry two slides further um and the question is what is considered a strong type diff here wrapping a type in a new class struct is that what you meant there yeah so uh yes so a strong type def is a a notion that uh you know others have discussed the in the past there are uh some uh template libraries uh that implement these types of things and there are suggestions to add strong titles to the language itself either to the core languages or to the scl but basically they're these are usually things that are implemented as you mentioned there's a some wrapper class that has a member inside it and that rapper um usually also supports uh like many operations that that the underlying class typically supports like maybe addition multiplication assignment comparisons etc but the compiler knows it's a different type it's a it's a different type and there's in the the compiler know that it's undefined behavior to take an object of one stroke tie def and uh just reinterpret cast uh uh you know another a pointer uh to another a strong type that with the same underlying type pointing to the same a location so this so it's undefined behavior to have two objects of different strong type diffs uh pointing to the same location and the compiler knows it and can give performance boosts uh based on that okay thank you the next question was if you could please clarify whether the k copy or any other workaround with stacker type still has the same performance as was passing by value that is still 43 times faster yeah so um let's think about it so so the the the the you know the correct answer is that uh that it depends and it depends on the compiler uh the tricky thing here is that uh the compilers really try to prove whether aliasing is possible or not okay so if i have a function that accepts objects by by reference and that function is uh unknown to the compiler and cannot be inlined or like like in some third-party library then uh using the k-copy uh will not affect the performance or the code generation for that function and the decay copy will only assist me with a functionality to make sure that anything won't hurt my functionality but won't affect the performance on the other hand if the code of that function is known and there's a and the function might be inlined as well the compiler can really uh prove for itself that the copy operation happened and thus there's no aliasing and create its own separate uh like in-line implementation that is faster okay cool um the next question is david zanevsky also showed some examples on how the compiler optimizes especially gcc and playing themselves makes best decision on how to pass the arguments into generated machine code it often ends up having nothing to do with c plus plus programmer wants to enforce why buzzer what is your opinion um if you thought i would talk yeah yeah it's a long question let me try to read it uh to myself again uh yeah uh oh yeah okay so i see that uh this is a reference to david zlasky talk yesterday i only saw it briefly so uh but i encourage you to go and look at it it might be really really relevant um and uh um yeah so so first of all when it comes to argument passing as david said sometimes compilers can can do a lot of things and optimize things but sometimes they they actually cannot because there's the issue of abi and api is something that is very very strict and has and the compilers rarely have uh good ways to to go around it so uh it's it means that there's many cases where the compilers can't really make the best decisions themselves because they have to adhere to an api um and then um yeah i'm not sure what uh uh the you know what the uh what uh you mean by uh why why bother uh but i guess maybe we can take it uh you're welcome to join us in the lounge after the talk and i'll understand what you're asking and we'll see okay okay are there any further questions if so now would be the time to ask or later in the lounge as well will be available for questions there for a time yeah by the way i i can also uh mention uh that uh uh if you any of you is interested in the rust programming language then in russ there's a notion of a borrow checker and then rust uh through the borrow checker the language tries to enforce a case where in case where if two references uh um exist to the same underlying object uh then both of them have to be uh a constant you cannot have a mutable reference uh to an to an object and another reference to the object and that way uh rust can get the better performance than c plus plus and uh i should think that with something like the restrict keyword we can get that performance back um but not until we do that so and again thank you everyone this was really a pleasure i hope you learned something uh uh cool and nice and i'll be happy to chat with you in the lounge so thanks thank you again for the great talk and for the great answers yeah of course so see you in the lounge bye