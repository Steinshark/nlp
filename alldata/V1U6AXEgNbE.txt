thank you very much i'm very pleased to be here celebrating the 10th anniversary of c plus plus and dusseldorf so correctly calculating min max and more subtitle what can go wrong so first a few words about the big picture as we all know the c plus standard library long ago more than a quarter century selected operator less than as its ordering primitive and the library even spells it in several different ways for example standard less in this talk i will first illustrate and demonstrate why operator less than no matter how it is spelled must be used with care even in such seemingly simple algorithms as max and min after that i'll discuss the use of operator less than in other order related algorithms showing how easy it is to make mistakes when we use that primitive directly no matter how we spell it and along the way i'll also present a rather straightforward technique to help us avoid such mistakes i'm very fond of this quote by alexander stepanov the father of the standard template library he says one of the amazing things which we discover is that ordering is very important things which we could do with ordering cannot be effectively done just with equality with that as background let me share with you some of my early attempts at implementing some of these simple algorithms we have of course what we might consider the intuitive approach using function like macros in a c style and if we were to do that the macros might look more or less like this but those of us in the c plus plus world tend to prefer functions over macros and if we do that we can repackage the algorithm as functions and they would look more or less like this of course now we need one overload for every possible type i've shown inc but we would need to overload this for floats and for doubles and for chars and for and unsigned long and even standard strings for example so the c plus plus solution to that of course is to lift these algorithms and turn them into function templates which in the c plus 20 style would look sort of like this however those c plus templates that look like this do have a few issues first the parameter passage which is by value as you see is potentially expensive for example if we have arguments that are large strings and when the arguments have different types it's really not clear what the return type should be in fact can we even compare those kinds of arguments generically as one example just think about what it takes to compare a sign versus an unsigned and do it right we'll talk about that later by this and of course our major concern always are the algorithms correct for all values well the cures for these are mostly straightforward and in fact the standard library has built into cures in the specification we can certainly enforce consistent types by using a named type parameter and we can avoid expensive copies by using call by reference reference to const but nonetheless called by reference and after we make those adjustments we have something that looks like this for min and analogously of course for max notice we have a single type t that we use consistently for both argument and return types please just recall that when we have l value references to our values there are some subtleties involved if we call min and provide temporaries as the arguments we get a result back that of course can be freely copied but if we try to take a reference to the result after this statement finishes the temporaries are gone you will be left with a dangling reference and that's not really the main thrust of my talk i just wanted to point that out as a brief aside so the question is well you know what's wrong haven't you cured everything and the answer is no because unfortunately none of the code that i have shown you so far is right i don't consider it right and neither does alexander step enough who has spoken of it and i'll return to him in just a moment i'm going to stop talking for just a moment give you 10 or 15 seconds to look at this code see if you can identify what we consider to be the missed behaviors okay did you notice that both of these algorithms will return b whenever the arguments a and b compare equal specifically this is what i'm talking about in both cases you'll return b when a equals b and of course why should max and men of the same two arguments ever ever ever give us the same result i would argue it should be never someone posted that uh a claim that it took stepping off 15 years to get these functions right that's a bit of an exaggeration but it was a short time it did not get both of them right the first time specifically the algorithms mishandle the case of a equals b as someone posted i believe on stack overflow that at cppcon 2014 which was the first cpp con committee member walter brown mentioned that standard max returns the wrong value when both arguments have an equal value and that's correct i did say that but the posting concludes with a critical question why should it matter which value is returned now i've heard these arguments and observations for decades and usually the argument goes more or less like this the claim is that equal values are indistinguishable so it should really not matter which of the two we return so this really is not a very interesting case and barely worth even discussing unfortunately for men and max and related algorithms these are superficial opinions and unfortunately they are incorrect in fact let's listen to what alexander stepanov says about his own mistake if the audio isn't clear because you're having trouble making out his accent i have subtitling over on the left side of the screen how stupid could one be and one spends decades working on all these waterings and writing mean and the most generic way and then he writes max and it up and the person is me and you will say well but nobody will even remember that oh no people will remember because that's the bad good library so for as long as c plus class stand my shame will be publicly visited so in his own words alex stepanov acknowledges that he made a mistake so let's talk about that further the observation is that there are many types that in fact do distinguish values even though they compare equal let me give you what i consider to be a bare bones example here is a very simple type named student it has two data members a name and an id for each student and there's a static data member i have named registrar and the sole use for the registrar is as a source to initialize the student id the name is passed in explicitly to the constructor but the id comes from the registrar and is automatically assigned and the only other component is a member less than which looks only at the names notice that for purposes of less than the id isn't considered not salient but because each student variable will now have a unique id number even equal values are distinguishable so it can matter a great deal which one min and max choose to return so the question now is how do we address this from the perspective of mathematics we have the notion of a monotonically increasing sequence and of course we in the computing business would consider such a sequence to be sorted but the converse is not true and the counter example is very simple if you have a sequence of identical values we would consider it sorted but it is certainly not monotonically increasing it's not increasing at all for that matter so instead what we must say is that a sequence is sorted if and only if it is non-decreasing and this is what allows us to have equal items in a sorted sequence now c plus plus embraces this viewpoint and there's the citation in case you care to look it up it says that a sequence is sorted if for every iterator i and non-negative integer m indirect of i plus n is less than indirect i that claim must be false in order to consider the sequence sorted so what's the key insight from this specification if we are given two values let's name them a and b and we are given them in that order unless we have a reason to do otherwise min should always prefer to return a and max should always prefer to return b in other words never should min and max return the same item never never never it would be counterintuitive when the values a and b are presented to us in order min should return a and max should return b and when the values a and b are presented to us out of order min should return b and max should return a now we can state this even more succinctly very simply we should always prefer algorithms that are stable especially so when it costs us absolutely nothing to provide it and this is very often the case recall what we mean by the term stability an algorithm that concerns itself with the order of items is described as stable if it keeps the original order of equal items in other words a stable algorithm always ensures that for all pairs of equal items a and b a will precede b in the output of the algorithm whenever a preceded b in the input to that algorithm so here is what i recommend for men the body that i recommend looks like this return if out if a and b are out of order we return b otherwise we return a now i understand that some programmers would prefer to write this by asking whether a and b are in order and if so return a otherwise return b i prefer this formulation because it's closer to what i said earlier do we have a reason to do otherwise the reason that rises when a and b are presented to us out of order if they are out of order we return b otherwise by default without a reason to do this we return a and similarly for max if a and b are out of order return a otherwise we return b so of course the next question is what is out of order look like and it should look approximately like this given values x and y in that order they are considered out of order if y is less than x if y precedes x then they're presented to us out of order and of course they are in order if they're not out of order and for what it's worth in my experience of these two out of order tends to be the more useful of the two when out of order returns true we usually need to do something and things are in order that might be a reason to do an early return for example you don't have any work all right well that's all well and good but there's more to this than just men and max because i believe these ideas are broadly applicable i have found that analogous logic applies in lots of places and let me give you a few examples here is a fairly straightforward merge algorithm we are given a pair of iterators to denote the first input sequence assumed to be sorted another pair of input iterators to denote the second input sequence also assumed to be sorted and a destination an output iterator which i've named two now if you look at the body we have a simple while loop which looks like it never returns but the returns are implicit in the body of the wire so we're going to check first to see if either of the two input sequences is now empty the second one is empty we return the result of copying the first sequence there's nothing left to merge except what's in the first sequence if the first sequence on the other hand is empty we return the result of copying the second sequence because there's nothing in the first sequence to be merged the actual merging happens in the trailing else clause and here's what i mean by analogous logic we should prefer to take from the first sequence we need a reason to take from the second so if you look please at the code here that i've highlighted in either case we're going to write to the output if the values denoted by b1 and b2 are out of order then we'll take from the second sequence otherwise by default we'll take from the first sequence so that's one example here's another example let's consider a very simple sort where we're handed two items and we want to ensure that they be that they are in order so we ask the question are they out of order if so we'll swap them now we could have written it using in order if they are in order we have nothing to do and we can do an early return otherwise will fall through and do the swap that way and no matter how you write it the post condition of course is that a and b are in order which is the intent of the algorithm but as i said earlier my preferences for the use of out of order when it comes to sorting three items there's a little more work to be done i've written this in the c plus 20 style so if the if you find that the if statements look unfamiliar it's because this has been allowed by c plus 20. so in brief the body of the function says if after sorting items a and b it so happens that b and c are now in order then we can do an early return otherwise if after swapping b and c it turns out that a and b are in order we can do an early return otherwise we swap a and b so again the use of in order and out of order in sorting algorithms has proven its value by the way in that sort three algorithm did you happen to recognize that what i've shown you is bubble sort it's an unfamiliar presentation i will grant you but nonetheless this is bubble sort so i was curious how other people might have coded this sort 3 algorithm so i went online and i found this on stack overflow and just a quick glance convinced me that this is far more complicated than the version that i had written it's an attempt to use the minimum number of swaps but if you look at it you'll find that there are six separate cases that need to be looked at corresponding to the six possible permutations of a b and c and it's much more difficult to tell whether this algorithm is correct and i actually had to elide a little bit of it in order to get it to fit onto the page but i claim that it's fairly quick to tell that this algorithm as presented isn't quite what we want have a look at that first pair of nested ifs if a is less than b then if b is less than c we can return because they're already sorted well that's certainly true right and that's not wrong but it's not right either my claim is that this algorithm does more work than necessary it's using operator less than where it should be using a call to in order and the proof is simply can to consider the case that a b and c are all equal if a and b and c are all equal we should be doing an early return yet it's very clear each of the other five cases does some amount of work and because of that we can quickly conclude that this algorithm is certainly not stable again operator less than is not usually a substitute for a check to find if values are in order so let me recap we have two main takeaways so far the first that by itself operator less than is not sufficient to tell us whether the operands are in order second by itself operator less than is sufficient only to tell us whether it's operands when reversed are out of order now as i mentioned at the beginning there are other ways to spell operator less than there are a lot of standard algorithms that don't directly use operator less than spelled that way as we know standard library algorithms often specify an overload that takes an extra parameter usually named comp such that the algorithm calls comp of x comma y to decide ordering instead of saying x less than y so let's consider as an example excuse me let's consider this algorithm is sorted until it's not one of the more popular algorithms in the standard library but it is standard and this version internally uses operator less than but there's an overload declared thusly notice it has an extra parameter of type compare named comp and internally this overload will com call comp in place of operator less than now i'd like to say just a few words about this algorithm the the specification says the following it returns the last iterator i in the closed range first time a last for which the range first comma i is sorted and it does so in linear time in other words i induces a pair of adjacent partitions adjoining partitions first to i and i to last where the first of these is known to be sorted and of maximal length now i believe there's an equivalent formulation that does not use i and i believe this formulation is better for those of us who think algorithmically which i believe is all of us namely let's treat whatever up to first as a partition that's known to be sorted and let's give it an adjoining partition first comma last and we know nothing about its order then we can iteratively advance first so long as indirect first is in sorted order with respect to its immediate predecessor so by construction the sorted partition that goes up to first will have maximal length so it is correct in every case even empty cases just to return first a while back i looked at many standard library implementations of this algorithm and all of them that i looked at at that time used a variable i in the implementation and there might be one that still does i don't recall but most of them have updated this way nonetheless let me share with you my earliest implementation that uses operator less than it looked like this now it turns out this is a correct implementation but it dates back well over two decades and over the intervening years from time to time i would go back and look at this to see if there was any way that i could improve this to use new features of newer versions of c plus plus and i know that every single time i looked at this i scrapped my head for several minutes trying to figure out what i meant by the highlighted code starfirst less than star creed so if i finally realized a while back that i should have used a named order predicate such that the code would look more like this which makes this much much more readable right i've introduced an out of order now please note that i do the indirection in the out of order predicate my tip for you is to pick when every possible pass the iterators because they're typically cheap to copy rather than the dereferenced values it's certainly possible to code this to say if out of order star prev comma star first but that's not as good an idea because those values we don't know anything about them and for all we know they might not even be copyable so i strongly recommend that we pass the iterators whenever possible and do the dereferencing inside out of order if you're in the pre c plus plus 11 world you have another way of writing this you can resort to a macro which would look approximately like this and the rest of the code is totally unchanged now here's what the standard has to say about a comp parameter it says the declaration compare comp is used throughout as a parameter that denotes an ordering relation compare is a function object type whose call operation yields true if the first argument is less than second and yields false otherwise comp in other words induces a strict weak ordering on the values and for all algorithms that take compare there's a version that uses operator less than instead now i just like to comment that in my opinion i don't really care for the names comp and compare because i believe they're too general they're not terrible names but they're not sufficiently specific for example i would prefer that comp had been named less than or abbreviated lt or proceeds would be a good uh usage if we're talking about order related algorithms does one item precede the other but nonetheless even when we have an explicit predicate i still recommend adapting it via what i've called an order predicate it would look something like this you'll notice this is the overload it is sort of until it takes the extra parameter of type compare here i've named it precedes because as i said i believe that's clearer i've introduced an out of order predicate notice i've provided what i consider a better name namely it or out of order because i'm passing it iterators the standard library has set the precedent because we have for example interswap in the standard library the standard library isn't 100 consistent though because there are places where it spells out iterator underscore whatever nonetheless um iter suffices for my purposes here the rest of the body is essentially the same as we saw previously the difference is the extra parameter and the small change in the out of order predicate now it is certainly possible to avoid having two overloads we could have a single template that has appropriate default arguments it might look something like this which looks very much like the last version but i've supplied a default function argument as well as a default template argument now some of you might have a couple of questions about this one of them being what exactly is standard ranges less and the second question do we need both kinds of default arguments it sort of seems that we should be able to make b with one so let's answer those questions what is standard ranges less well it's a class it's declared in the functional header defined in the function it looks approximately like this i've simplified it just a bit just for exposition and you'll notice it has a function template as a member so if you have a variable of this type it will be a function object because it's callable through its call operator member template do notice please that the comparison implemented by that operator is heterogeneous and sometimes that's exactly what you want of course if both parameters happen sorry both arguments happen to have the same type it's perfectly capable of doing a homogeneous comparison and that's fine i've previously mentioned that there's also standard less and that's a template who's very similar but it has an operator appearance that is strictly homogeneous i'll mention uh i'll talk a little bit more about that later most of the programmers i've talked to nowadays seem to prefer the design of standard ranges less so the second question do algorithms like this need both kinds of default arguments and let's arrive at an answer let's review this declaration for just a moment and now consider a call start with an array of some size appropriately initialized and now let's call the algorithm and provide a pair of pointers a plus 0 comma a plus n so first question what is the deduced type of parameters first and last and i hope you'll quickly decide that it's going to be deduced as pointer to int because both a plus 0 and a plus n have type in star now what type is compare notice that the call does not have a third argument so we're going to have to rely on our defaults and it turns out the answer is taken from the default template argument so the answer is standard range is less the rule here is that the compiler will never infer a type from a default function argument okay and that's appropriate and this is what enables calling code to default construct the third argument namely standard range is less okay now some of you may be asking here's a third question i've looked at my standard library and it doesn't use those default arguments well the reason the short version is implementers are prohibited from doing so unless it is specified to do so and here's the relevant citation an implementation shall not declare a non-member function signature with additional default arguments there's a reference in case you care to look it up so why is that why not consolidate the two overloads into one and the answer is that it's it's problematic when it's not specified that way i found this paper back from 1997 almost a quarter century ago that says the difference between two overloaded functions and one function with the default argument can be observed when you take a point of the function moreover suppose we have a call that specified a type but not a value of that type so here's a quick example of a template named g which defaults to int as its template parameter template argument sorry and a default argument for x but if the call says i'm telling you what class t is going to be it's my type now what happens if my type isn't default constructable the call is in trouble okay now i should point out that algorithms that are declared in the standard ranges namespace are specified with defaults so those algorithms do use the consolidation that i've pointed out but the algorithms in the standard namespace are prohibited from doing so as i've just explained okay well it turns out that the standard library has a bunch of what i've labeled disguises for operator less than i've mentioned some of them but if i were to ask in how many different ways does the standard library design and spell operator less than you might be surprised to learn that i have discovered at least six and if you know of more i'd appreciate you letting me know here's a quick summary let's go through them very briefly we have the class template less in the functional header we've had that since equals plus 98 and as i mentioned earlier it's callable but it's strictly homogeneous two arguments each of type t in c plus plus 14 we provided a specialization of that class template named less of void notice that you could never have deduced a rest of void it's just not possible so this allows us to have um heterogeneous comparisons in the standard library standard less avoid when ranges less was designed we used the uh the uh the heterogeneous approach from the get-go and i've already discussed that so i won't say more about it in c plus 20 we also introduced a function template named compare less we put it for some reason in the utility header i really don't know why it's there but it is and notice it does a heterogeneous comparison for two integer types since c plus plus 11 we've had an overload set named is less in the c math header it is capable of doing a heterogeneous comparison of any two arithmetic types and then we have the specification named total order which is part of an ieee standard dates back to 2008 and we absorbed it in c plus plus 20 as part of the specification for the strong order algorithm in the compare header and it is specific to a pair of floating point values of the same type so it's a homogeneous comparison let's look at some of these in a little bit more detail i have a private version of standard ranges less that looks approximately like this sorry i went too fast there we go so we take a pair of values left and right as arguments if it turns out that both are integer types i forward them to compare less which i'll talk about shortly otherwise if they're both arithmetic types then i forward them to is less otherwise i do what the standard specifies and compare them with operator less i don't know why the standard library doesn't do this i wish it did but it doesn't here's my version of compare less it takes a pair of integer values not necessarily of the same type so first we check whether either they're both signed or they're both unsigned and if that is true then we rely on the core language to do the right thing otherwise we know that one is signed and the other is unsigned well if it's the left argument that is signed then we'll check its value to see if it's negative if it is and the result is true it is less than because the other one is is unsigned and can't be negative otherwise we convert the signed left argument to an unsigned value which is safe to do since we know it's not negative and then do a strictly unsigned comparison and the third case is the same as the second with the arguments reversed and of course the logic adjusted as appropriate here is my version of is less it takes a pair of values of arithmetic type step one find a common floating point type which is a little uh meta programming that i'm not showing here at the moment once we have that common floating point type then convert both left and right to that type and then we do a compare of x less than y in that type but we take one preventive or precautionary measure first if all we did were ask x less than y then if one of those two values happened to be a nan we would be raising a floating point exception let's avoid that by asking the question are x and y unordered if so we immediately return false without doing the less than operation so we avoid raising a floating point exception next we have ieee's total order predicate which specifies the following order in broad terms it's most negative to least negative followed by least positive to most positive now there are some subtleties involved so first we'll have all the negative values and then all the positive values but within the negative values we first have all the negative quiet nands and yes there are several distinguished by what are called their payload bits and then we have all the negative signaling nands and we order all those according to their payload bits then we have negative infinity then we have all the negative numbers normalized and denormalized in value order and finally negative zero then we have all the positive values but in the opposite order so we have positive zero then the positive denorms and normalized numbers then positive infinity then we have the positive signaling man's and finally all the positive quiet mans ordered by their payload bits okay now that's what specified by the ieee total order predicate now think about the layout of an ieee floating point number and think about it in that light as we know compared to traditional scientific notation ieee has decomposed and rebased and reordered and adjusted all those parts the mantissa the sine and the exponent and by the time we're done everything is base 2 laid out this way if we have 32 bits we have the one bit sign eight bits of exponent and 23 bits of explicit mantissa and there's actually a 24th bit which is an implied one if we have 64 bits the layout is the same they're just more bits and if we even have 128 bits the layout will be the same but again with yet more bits you ever wonder why they're laid out in that order and the answer it's really for the convenience of the radix sort algorithm what if you were to treat those bits as a 32 or 64 128 bit int so here's my version of ieee's total order and we're going to assume the ieee layout so we're handed a pair of floating point values the same type first thing we're going to check are the sign bits because if one's negative and the other one's not negative i know the answer i don't have to do any work so the interesting part is in the else clause so the step one is let's convert those floating point bits to integers so let's find a type that's big enough and again i have a little bit of meta programming given the particular size namely size of f tell me the first type of that or 128 t that's big enough and i'm going to assume this exactly the right size we could do a static assert to check that but let's assume that that's the case then using c plus 20's bit cast we'll do a bit cast of the left operand and then a bit cast of the right operand and now i have exactly the same bits but we're now going to treat them as ins and then the final step is simply let's check the sign bit and let's consider whether x and y are in order or whether y and x are in order depending on whether we have a negative value or not sorry whether we have two negative values or two non-negative values right the case of opposite sign bits was handled way up at the top so i don't have to concern myself with that now okay all right well i have a few more minutes left so let me discuss with you what i've called a bonus algorithm which i find very interesting and i hope you will agree returning to the beginning of the talk where i discussed max and min suppose we have an application where i need both of those extrema how could we write that code well we could certainly reuse min and max especially now that we have correct versions and if we did that it would look approximately like that we're returning a pair where the first common component is the min of a and b and the second component is the max of a and b now of course if we do it this way it should be very clear that each of those internally is going to end up doing a less than comparison we really don't need two less than comparisons because one would give us the answer so how can we do this more cheaply well if we replace the body with this code just ask directly if a and b are out of order then return the pair b comma a otherwise by default we return the pair a comma b okay and that should be pretty straightforward but let's generalize this result let's consider the min max algorithm and we have not just two values but a sequence of values and we'd still like to find both extrema we have this in the standard library it's in the algorithm header it's named min max element and it's designed to take a pair of iterators and what it returns is a pair and i've just named the the components little m and big m each of which is an iterator in the range first to last such that little m is the first iterator that denotes the smallest value and capital m is the last iterator that denotes the largest value in the range please note first iterator versus last iterator now if we let n denote the distance from first to last then if we take the obvious algorithm that steps through the range and for every item we say well is this a better min is this a better max it's fairly straightforward i think to deduce that we're going to end up with two n calls to out of order one for each call to min and one for each call to max but it turns out that almost 50 years ago ira poll published an algorithm for this problem that needs only three halves and calls to out of order it's a fascinating paper because not only does he prove that this algorithm gives the correct results he also proves that it's optimal that we can't do better it's a fairly short paper it's an interesting read but it's kind of mathy nonetheless i'd like to share with you some of the details of his algorithm let me begin by showing you some infrastructure and on the next page i'll put that all in place and show you the entirety of the algorithm so let's suppose we have a pair of forward iterators i've named them f1 and f2 i have a function named precedes that returns the result of comparing the values denoted by f1 and f2 either it uses less than directly or uses some compare function depending on on how we code the algorithm i superimpose out of order on top of that this is actually an iter out of order i have a pair of functions max and min and these are again iterator versions this maybe should be called intermax and intermin and they call it or out of order and now let me introduce the name little m big m as a synonym for standard pair but with the precondition that the members of this pair denote ordered iterators okay now how do i get such a pair mm well the first piece of infrastructure will be a min max that makes such a pair and it returns either mm of f2 f1 or mm of f1 f2 and decides by calling a prime out of order and that should be pretty straightforward and the final piece of infrastructure is a function named meld it takes two mm pairs and consolidates them combines them into one by asking for a that first and b that first which is the min and for a dot second and b that second which is the max now these last two pieces of infrastructure are the key if you look at it carefully you will note that there are a total of three calls to out of order one is explicit the other two are implicit in the calls to min and max and in three calls to out of order which means three calls to proceed so i've got three calls to compare i have processed a pair of iterators that's where the three-halves coefficient comes from and finally let's put all of this into context here's the complete logic please observe that most of the code is for special cases at the beginning or the end of the sequence of the input sequence so i introduce mm as before right the precondition is implicit but i don't want to repeat standard pair forward forward so first we handle two special cases at the beginning of the sequence do we have an empty sequence or do we have a sequence of a single item that i've named a singleton sequence okay and this handles both of those special cases it's not very interesting here's the rest of it notice the body of the for loop has three cases two of which are just special cases all right dealing with the end of the sequence it is possible that we had an even number of it of values in the sequence and if that's the case we're done so we can just return the best so far it's possible we had an odd number of items in the sequence in which case i need to handle that final item and so that's what the second case does we can actually handle this a little bit better but this one is a little more straightforward to understand we could sometimes save yourself one comparison there but the general case is the final else which calls meld being given our uh our min and max so far it could be combined with the min and max of the two most recent items and that'll be my new best so far and that's it and with that i thank you very much i've appreciated very much the invitation to come speak at this 10th anniversary celebration of c plus in dusseldorf for those of you who have questions i will go to the lounge and i hope to see some of you there thank you again goodbye thank you walter that was a really nice talk