This video is about a forbidden technique
in Python, the twin snake sacrifice juts-, storing mutable or non-hashable things in
sets and dictionaries. Normal sets and dicts use hashing, meaning
when you want to check if an element is in there, you use the element's hash to pick
the exact index where the element would go if it was present, so you can just check that
one location instead of checking every location. It's kind of like when you go to the grocery
store and need to find the milk. You don't walk through every aisle, you just
go straight to the refrigerated section and if it's not there, then they're out, no need
to check the rest of the store. But hashes are necessarily based on the state
of an object in order to make hashes be different for as many different objects as possible. Hash collisions are allowed, they just degrade
performance. Like if the grocery store made the whole store
refrigerated then you would have to fall back to searching every aisle to find the milk. But if hashes are based on object state, then
mutating the object would probably change its hash, so if you went to go find it later,
you'd look in the wrong place. For that reason, the usual wisdom is that
you shouldn't make mutable things hashable. Python tries to enforce this by defining a
hash for your classes by default, but not defining the hash function if you define an
equals function. In practice, this is a solid 6/10 solution
but realistically Python can't do any better, it can't read your mind and there's no default
that would suit every case, so if you have an opinion about whether or not your type
should be hashable, then either define the hash yourself or set it to None. But sometimes you just want a set of mutable
or unhashable things, so what do you do? You could use a list or create your own mapping
or set type that stores data in a list, but this is not the forbidden technique. The problem is looking up elements becomes
incredibly slow because you lose that constant time lookup that hashing provides. You're falling back to checking every aisle
in the store for the milk. Instead, let's take advantage of a key property
of every Python object, its identity. Every Python object, hashable or not, mutable
or not, has an integer id that's guaranteed to be both unique and constant for the duration
of its lifetime. You can access this id by using the built-in
id function. Id's can be reused, after one object is garbage
collected, its old id could be reassigned to a new object, but as long as an object
is alive, the id is an immutable hashable value that uniquely determines the object. I hope you see where I'm going with this. So what we're going to do is make our own
mapping and set types that internally never hash the object itself, but instead hash the
id of the object. In our mapping type, we'll still use a plain
old dict, but we'll map the identity of a key to its key value pair. Again, the id of a key is just an int, it's
perfectly fine to use as a key of a dictionary, regardless of whether or not the key itself
is hashable. The result of looking up an id is a key value
pair. Storing the key in addition to the value ensures
the key isn't garbage collected and that the key's id won't get reused by another object
as long as this mapping exists. Getting an item now looks up the id of the
key up in the dict and returns the value. Setting an item maps the key id to the key
value pair. And deleting an item deletes the id of the
key from the map. There are a few other functions here but they
are pretty straightforward, and we take advantage of the collections MutableMapping ABC to fill
in the rest of the usual dictionary interface like get, pop, and so on. Our set type is similar, we keep a plain old
dict of value ids to values. Again we're storing the value in addition
to its id to prevent values from being garbage collected while the set is still alive. Adding an element to the set means mapping
its id to its value, discarding an element means popping its id from the map, and checking
if an element is in the set is just checking if its id is a key in the dictionary. Once again, there are a few other pretty simple
functions and we use collections' MutableSet abstract base class to fill out the rest of
the usual set interface. And there we go, we can now create a list,
which is not hashable, put it in our mapping or set no problem, even mutate it in-between,
and we can still look it up no problem. Mutating the list doesn't change its id. Great! So what's the downside? The downside is that when I lookup an element,
I need to use the exact same object, not just an equal one. Compare to a normal set, if I add 257 in,
then add int(float(257)) in, the set just has one element, 257. But if I use the IdSet, the same code would
add in two copies of 257, because the two 257s, although equal, are different Python
objects that have different ids. It is still a set and it does filter duplicates,
but in order to be considered a duplicate, you have to add in the exact same object twice. This can be especially confusing for small
object types like ints and strings or for types where it's not clear whether its operations
mutate the object in-place or return a new one back to you. I highly discourage using these types with
IdMapping or IdSet, and this potential for confusion is the reason this is forbidden
Python knowledge. But, if you're certain your objects will be
stored and looked up using the exact same object, then you might find this trick to
come in handy. I take no responsibility for the criticism
you get in code review if you actually try this though. It's forbidden knowledge for a reason. Thanks to me myself and I for sponsoring myself. In addition to making esoteric and questionable
Python content on YouTube, I also run a software consulting business. If you have a project at your company that
you think needs some outside eyes, check us out at mcoding.io. And of course, thank you to my patrons and
donors for supporting the channel. I appreciate the support and I'm glad you
find my videos useful. Don't forget to slap that like button an odd
number of times, and I'll see you in the next one.