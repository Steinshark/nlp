Hello and welcome. I'm James Murphy. In this video, we're talking about multiple assignments or chained assignments in Python. These multiple assignments are different than tuple assignments. Multiple assignments involve multiple equal signs not multiple things on the side of the equal sign. But they can be combined. By the end of this video, I hope that you're going to understand multiple assignments well enough that you can understand something like this extremely tricky example. But before I get into the explanations of things, let's talk about this video's sponsor. Me. That's right, me. I'm sponsoring my own video. Did you know that I am available for software contracting, consulting, training and interview prep services? So, if you're looking for someone to do a code review or help you hunt down a bug, please consider using me. Okay, let's get back to multiple assignments. If I go ahead and run this code, of course, we see that four copies of the empty list are printed out. But are these the same copy of the empty list or are they different copies of the empty list? So, if I print out a is b, do you think this is going to be true or false? Let's run it again and we see that the answer is True. So, these are in fact all just different names for the same copy of the empty list. They're not all different empty lists. This is slightly different than what you would have if you did a tuple unpacking. If you said, like, a, b = [ ], [ ], then these two empty lists on the right hand side are different. So, a and b will be pointing to different things. So, when I run it this time, I see False at the end because these two empty lists are different. What's happening here is analogous to the following. First, we evaluate the right hand side and store it in a temporary variable. Then we go from left to right and assign each of the things equal to the temporary variable one after the other. When we write it this way, it's clear that they're all going to be both equal but also identical in the sense that a is b will be True. Thinking about it this way is really going to help us understand this trickier example. For starters, let's go ahead and print out what we get in this example. If you'd like a moment to think about it for yourself before I explain, pause the video now. And make sure that you're able to explain why this [...] appeared   Okay, here's how you're supposed to reason about this code. First off, we make a temporary variable and set it equal to the right hand side. Then we go from left to right. And we do each of the assignments one after another. So, I'll say a comma b equals tmp and then a slice equals tmp. After this assignment, we have that a is equal to this list containing the empty list and b is equal to this empty list. So, in particular, after this line, a is a list. Since a is a list after the previous line, it makes sense to use this expression. So, what this does is, it assigns the contents of a equal to the right hand side. So, the contents of a will become equal to the contents of this tuple. Meaning that, a will now contain these two elements. But remember, before this line, a was equal to this element. So, then when we're setting its contents to be these two elements, we're setting a to be one of the members of itself. that's where the [...] come in. When you print out a recursive cyclic data structure like that, Python will notice that there's a cycle. And then just print [...] And that's your cue to think: Oh, I have a cyclic reference in there. So, let's go ahead and print it out again and see what we have. So, we started with a equal to this and b equal to this. And then we replace the contents of a with this and this, which are a and b. So, you can see here, the highlighted blue portion. That's the contents of a. So, a contains a and b. That's why we have these [...] here. It can't just print out all of a. Because of the cyclic reference, it would go on forever. We can confirm our intuition by printing out a is a[0]. Since this is going to be true that shows us that the first element of a is a, confirming that we have this cyclic reference. Okay, I admit that example was kind of silly. You really shouldn't ever be writing code like this. I think a good rule of thumb is that for any variable like a, you shouldn't use it in more than one part of a multiple assignment. Otherwise, you're just asking to confuse people. So, yeah. You might be able to use this to trick your friends or whatever. But in real code, please don't ever do this. But I think it is important to understand the way that multiple assignments work. Namely that, you first evaluate the right hand side and then go left to right assigning things in turn. So, this is really the example that you should keep in mind. If the only language you're familiar with is Python, this might not be confusing at all. But a lot of you I know do know more than one language. And you might actually be confused by this because a lot of languages do it a slightly different way. One big difference about Python is that: In Python, an assignment is not an expression, it's a statement. The difference here being that something like d equals the empty string doesn't return anything. It doesn't have a value. It just assigns the right hand side to the left hand side. But in a lot of other languages, assignments are also expressions. So, the assignment d equals empty list would return d back to you. But Python does have assignment expressions. They were added in 3.8. They use this colon equal syntax. And it does essentially the same thing that the equals does with some restrictions about where you can use it. But it also returns the value back to you. So, this d := 0 is going to return that zero back to me which I then assign to c and then to b and then to a. And when you write it this way, it becomes clear that the only way that this could make sense is if you do things right to left, not left to right. I have to start on the right hand side here. Otherwise, the parentheses can't make sense. Because I couldn't start on the left with a equals b, because b isn't defined yet. I have to start right to left. So, that's going to be the big difference between Python and other languages. In Python, the normal equals operator is going to go left to right. But in many other languages and in Python if you're using assignment expressions, then it actually goes right to left. And if you're wondering about all the redundant parentheses here, they're there because they have to be. You're not allowed to chain multiple assignment expressions together unless you put them in parentheses. Python does this to discourage people from using assignment expressions where they really should be using just regular old equal sign. Okay, quiz time. Let's see if you really understand the rules. What does this function print if you were to call it? Put your answers in the comments below. And that's all I've got for now. Thanks for watching. And thank you to my patrons and donors for supporting me. I really appreciate the support. If you especially like my videos, please consider becoming a patron or donor. And subscribing to the channel, liking the video, commenting, all that good stuff. Thanks again.