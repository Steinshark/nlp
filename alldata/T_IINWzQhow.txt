today we're going to be doing something a little bit different and it's something that brings together many ideas in computer science and it's the idea of program correctness so what we're going to be thinking about is what does it actually mean for a program to be correct and then how can we specify and verify that in some kind of precise way so that's what we're going to be thinking about today program correctness we're going to come at this problem by means of an example and the example that we're going to look at as a simple compiler so what a compiler does in computing is it's a program that takes a high level language and translates it down to a low level language which is more easy for a machine like this one to execute so what i'm going to show you is a little haskell file which i've written but it doesn't matter if you don't know anything about haskell because it's really incidental to everything that we're going to talk about today it just allows me to do everything in quite a concise way but actually you can do everything in any old programming language that you like but i'm going to explain everything as we go along anyway we have two data type declarations and we have three function declarations or function definitions rather and what we're going to do is we're going to explain what these do by means of some simple examples and then we're going to think well what does it actually mean for the compiler which is embedded in this code to actually be correct so what we're going to start off looking at is the source language for the compiler and it's going to be a very simple language it's going to be the language of integer values combined using an addition operator so we're going to be building up simple arithmetic expressions things like 2 plus 3 plus 4. so here is the data type declaration for this in haskell and it's got a few components so we'll work through these so we're declaring a new data type called exper for these simple arithmetic expressions and then the data type has two constructors for building expressions it's got a value constructor which takes an integer parameter and it's got an ad constructor which takes two sub-expressions as arguments so this is how we're going to build up our simple expressions and the really expression trees and you might be thinking well what is deriving show mean here well this is a little bit of haskell magic and it just instructs the the system to be able to print these things on the screen so we can view them so not everyone's familiar with haskell so i'm going to give you three little examples of values in this expression data type and these are going to be running examples that we're going to be using throughout the video today so the first one is going to be e1 and it's just going to be a simple integer value so we have an integer here one and then we tag it with the vowel constructor and then we've called it e1 so we don't need to type this in again whenever we type e1 now it just stands for vowel of one our second example is going to be an addition so we're going to do add of val2 and vowel three so this is like how we would represent two plus three as a value in our simple expression data type so we've got a number of components here we've got the value two and we've got the value three and then we combine them with the add constructor so it's a little bit more verbose than what you'd normally write down in mathematics you'd normally just write down two plus three but here we're doing in a programming language so we need to be a little bit more verbose and we're using the two constructors of the expression data type so just as one final example let's do something a bit more sophisticated let's reuse e2 and add that onto valve four so we defined e3 here to be the sum of e2 and the value four so what this really is is it's two plus three plus four and we can use the little pretty printer here which we got from writing deriving show and if we print out the value of e3 what you get is you get the addition of two and three here as the first parameter to the add and then as the second parameter you have val4 so these are three little running examples of arithmetic expressions which we're going to put into our compiler as source expressions so the next thing we're going to think about is what do expressions in this language actually mean and this is very simple in this case expressions just denote simple integer values so we can think about evaluating an expression so let's look at the three examples so we had e1 and if we evaluated e1 we just get rid of the vowel constructor and we get the value one very simple if we look at our second example which was two plus three if we evaluate two plus three and of course we're just going to get five and if we look at our third example this is two plus three plus four bit more verbose but when we evaluate this one we're going to get the value 9 as we expect so let's have a look at the source file now and think how do we actually define this evaluation function and it's actually just a very simple two-line recursive definition so let's look at the two lines one by one so the first line says if we evaluate a value n we simply remove the valve constructor and we get the underlying value n the second line says if we evaluate an addition of two expressions x and y all we're going to do is evaluate the first expression x evaluate the second expression y that will give us two integers and then we can add them together and that will be the evaluation of the integer so it's a very simple two-line recursive definition the next thing we're going to look at now is the actual compiler for these simple arithmetic expressions and what it's going to do is compile from expressions down to code and the code is going to be a sequence of operations for a very simple stack machine and the stack is just like having a stack of books it grows on strings and you always put new values on top of the stack so let's have some examples to see how the compiler works first and then we'll see how it's actually defined in the code if we think about our first example value one we can compile that one and what we're going to get is just a sequence of a single operation for the little machine and what the operation is going to do is just push that value one onto the stack if we look at our second example we had add of two and three if we compile that then we really start to see what the compiler is doing it's compiled it down to a lower level sequence of operations and in this case what we're going to do is we're going to do a single push of the value 2 another push of the value 3 so that will have two values sitting on the stack and then you'll perform an addition on those two values and that will leave the value 5 sitting on top of the stack so you start to see how the compiler here is taking high level arithmetic expressions and compiling them down to lower level sequences of operations which a machine like this one could more easily execute so let's have one more example let's look at our third example two plus three plus four if we compile this one then we get five operations this time we have push of two push of three and then add and that will leave the value five sitting on the stack and then we push the value 4 and then we perform an addition and that will leave the value 9 sitting on the stack at the end so that's what the compiler does let's have a look to see how it's actually defined and again it's just defined as a simple two-line recursive definition so if we look at the base case for the recursion what it's saying is if you compile a value this is very simple you just simply emit a single instruction or a single operation which pushes the value n onto the stack whereas if you compile an edition then you have three things to do what you're going to do is you're going to compile the first part of the edition compile the second part of the edition and then put an add operation on at the end and the plus plus here is just a way in haskell of combining lists together it's list concatenation or list append and this then brings us to our second data type declaration at the top we're defining the data type for operations and this is very simple there's no recursion involved this time around it's just simply you push an integer value onto the stack or you can perform an add on the top two values on the stack and again we're using the haskell magic here to derive a pretty printer which can print these things on the screen so that's the compiler for arithmetic expressions but we're not quite done yet we still need to think about how does code for this little stack machine actually get executed so again let me give you some examples of this and then we'll see how this is actually implemented in terms of haskell code so if we take some examples here so the first example is just going to be if we execute the result of pushing one onto the stack and we give it the empty stack then you just get exactly what you expect you get the value one sitting on the stack remember a stack is like a pile of books and in this case it's a pile of integer values and you always put things on the top okay so in this case we're just taking an empty pile and then putting the value one on the top let's take another example suppose we did push 2 push 3 and then add and we executed that with an empty stack then we get the final stack with the value 5 on it so the way this will actually get executed is the value 2 will go on the stack then the value's three then you'll add them together and you'll get the value five sitting on top of the stack and that's exactly what we get sitting here so the very last example if we did the two plus three plus four example so i do push to push three perform an addition push 4 perform another addition and then hopefully we get the right result which we do which is the value 9 sitting on the stack so this kind of shows you how the little stack machine actually works so let's have a look at the code for this so the code looks a bit more complicated but it's actually completely straightforward and we can just kind of talk through this so the way if we want to execute a push and then we have some more code afterwards in the context of a given stack is we're simply going to put that number on top of the stack and then continue executing the remaining code so very simple if you want to execute a push you put that number on top of the stack and then you just continue with whatever it was you were going to continue with the second case says if we're trying to execute an addition all we're going to do is inspect the top of the stack and hope that we have at least two values m and n on top of the stack and s is everything else and all we're going to do is add together those two values and then put them on top of the stack and then we'll continue by executing everything else that we're going to execute so again very simple if you perform an addition you take the top two values of the stack add them together and put the result back on that's all that's going on here and the very last case is kind of the catch-all case it says if you've got any other code sequence and any old stack then there's nothing to do you just return the stack so this brings us now to the issue of compiler correctness so what we've defined now is we've defined a syntax for our source language which is simple arithmetic expressions we've defined our target language which is a stack machine code for a simple stack based machine and then we had a compiler which translates arithmetic expressions down to the simple stack machine code but how do we know the compiler actually does the right thing that's the point of this video today we're thinking about program correctness how do we know that our program for compilation actually does the right thing so that's what we're going to think about now so let's look at our most complicated example which was 2 plus 3 plus 4. so there's a bunch of things we could do with this we could evaluate it and we get the result 9. very simple we could also compile it so we could translate it down to some stack machine code and then we get push to push three add push four and add and then we could execute that stack machine code now so what we could do is we could execute the result of compiling that expression using an empty stack and what we get is the value 9 sitting on the stack which is exactly what we expect and you can see here by looking at these examples the essence of what it means for this compiler to be correct is that when we compile an expression and then execute the resulting code we get basically the same value as when we evaluate it so in each case we get the value 9 in the evaluation case we just get the integer just sitting there on its own whereas in the compilation case we get a stack with the value 9 sitting on it so this is the essence of what it means for the compiler to be correct if we compile and then execute the code it's the same as just evaluating the original expression so what we can do now is actually think about making this precise and kind of precisely specifying what it means for the compiler to be correct and then we can wrap things up by thinking how can we actually verify that so what i'm going to do is write down a simple function definition which captures what i've just said about the compiler being correct so i'm defining a little function called correct and it's going to take an arithmetic expression e as input and what we're going to do is we're going to execute the result of compiling that expression with an empty stack and what we want is that that's the same as the stack we get by just putting the value of that expression into a stack on its own so this generalizes what we just had what this is saying is if you compile an expression e and then you execute the resulting code using an initial stack which is empty then what you expect to get is just the value of the expression sitting as a single little value on the stack the double equal symbols here is just haskell's operator for checking whether two lists are actually equal so this captures in a very precise concise mathematical way what it means for this compiler to be correct but how can we actually check that this property is actually true well if you were ego eyed you might have noticed right at the top of my file i was importing the quick check library and quick check is a random testing tool which computer files already done a very nice video on with john hughes which you might want to check out and what quick check does is it blasts random test cases through properties and it tries to check that the property is true for all of those test cases so we have a property here we've got a simple compiler correctness property so what i can do then i can just write quick check the correctness property and it will run 100 test cases through it it will start with very small things like just simple values like 0 and 1 and 2 and so on and then it will consider larger and larger expressions with more and more additions and it's trying to find an example which breaks this compiler correctness property but it doesn't do it because the compiler is correct maybe it was a fluke maybe we can try it again let's try two or three different runs and in fact it doesn't matter how many runs we do of this this is always going to work okay because the compiler is actually correct so suppose we'd messed up suppose we had a compiler which we'd implemented incorrectly so let me break the compiler now let me change the compiler and this is a very easy mistake to make rather than compiling an addition by compiling the first thing and then the second thing and then omitting an add operation what i'm going to do is put the add operation in the middle and this is a kind of very common mistake if you teach compilers to students this is a very common mistake that you see in their code but it will break the compiler correctness property so this compiler is now incorrect let me quick check it and it's managed to find the counter example and in fact any addition will break this compiler if you work through the details what we've seen here now is how in a very simple way you can capture the correctness property of a small but interesting program a simple compiler and then how you can actually verify this or give high confidence that this is actually doing the right thing using an automatic testing tool such as the quick check system if you wanted to do this properly of course you could do some kind of mathematical proof that it's also correct or that it's correct using some kind of induction or if you wanted some machine assistance you could use maybe an automated theorem prover or an automated proof assistant but actually for many applications just doing this kind of high confidence activity of using a random testing tool like quick check actually gives you very strong confidence that your programs are actually correct but ultimately the gold standard is always to do a proper inductive proof or to use some kind of proof assistant to do it for you okay so just to summarize what we've done today we've been looking at the problem of program correctness and what we've shown is how you can prove a simple compiler correct and the way we came at this is we first of all defined what the source language for the compiler was which was simple arithmetic expressions then we defined what the target language was for the compiler which is simple stack machine code we defined a semantics for both of those languages we worked out a way of evaluating expressions and executing code and then we had a compiler which translated from one into the other and then finally we formulated this simple correctness property and used the quick check system to check that it was correct with high confidence and of course if you want to do this properly you could do a mathematical proof using some form of induction or you could even use some kind of mechanized proof assistant and maybe those would be interesting topics for other computer files another day so that's it for today see you again next time got a cost of three blue links to black go across the one there's our routing network that we're going to work with pretty simple but the routers need to find out it still doesn't work so now we find another example where packing and unpacking failed this is