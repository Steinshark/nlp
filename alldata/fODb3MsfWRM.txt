hello everyone thank you very much for coming I am Arno I am the the CTO at think cell these are the guys where you see the logo throughout the building on the videos and um I'm one of the founders we started 22 years ago we are still doing a PowerPoint edin but we are doing it in a really cool way in C++ and um and this is one of the things that we learned along the way um to how to write better ranges now now well first of all ranges have been in C++ now since C++ 20 so who is now using ranges on a day day-by-day basis okay still quite a few actually um that's interesting uh because I think they're very very practical um we've been using ranges since there were ranges in boost range so that's 20 years ago and we've built kind of our own library of ranges then made it compatible with the ranges that came in C++ 20 and closely observed what they were doing compared what we were doing learned from each other and um yeah this is this is what this talk is going to be about now first of all if there are so few people who actually are using ranges already on a day-by-day basis this is why you want to do use ranges so let say you have a vector and um you want to sort it well then you have to pass to iterators to the Sorting function and then when you want to throw away duplicates you're writing V erase did unique V begin V end end and you V V and V begin ve end and V and ve and V and V and V and it's like oh I don't want to write all that stuff right okay now pairs of iterators which are throughout the standard Library belong together they are describing one object so quite natural just put them into one object so then this would look like this and this is this is C++ 20 range of sort of the vector and then V erase ranges unique VC V end all right I think it's clear what this thing is doing so we are sorting it and then we are throwing throwing away the duplicates [Music] um now if you don't have a C++ 20 compiler yet that's no excuse not to use ranges because Eric nebla has an implementation that you can use and it's close enough to the standard that if later on you switching into C++ 20 you it will be pretty easy to the codebase to C++ 20 so I think it would be a good start um it would be an even better start if you use our ranges but we'll get to that later now why do I think I know something about ranges okay now think that has a range Library well we actually have a library that library is built really independently of our PowerPoint addin okay forget PowerPoint addin it's a better C++ Library uh we are looking at what we are using in our codee and then try to package that um in into useful Library functions and we really aspire to be a better standard Library we don't try to reinvent the wheel we're building on top of the standard Library we are building on top of boost so whenever there is something in boost that we find is good and useful we use it and everything else we build on top now we have about a million now probably a bit more lines of production code that use that library and there is a good and a bad the good thing for us is we are ready to change production code and Library code at any time that makes a library less stable right so if you want to use it and you don't want to follow all these changes you are welcome to Fork the library and just run with it it will still be much better than if you don't have any Library so if you have a new project or even into an existing project it's probably good still to have it but the ability to change the library at any given time says we have no obstacle that to change the design and throughout the code base we kind of learn how that Library ideally should look like and there is always something you learn there's always a better design you can constantly tweaking it around and and then we have that large code base to try out these changes so I think over time doing that for 20 years we learned a lot about how this Library looks should look like and this is how it looks like okay so that's why I think I know something about ranges uh because we've been doing this process now for 20 years now get back let's get back to our ranges sorting and erasing that's wrong it's wrong at least under certain circumstances the problem is the Sorting takes operator less the uning takes operator equal if they don't agree this is wrong they should agree of course but do you really want to rely on that in generic code it doesn't really it feels kind of wrong right so and you don't really need with this sorting and uniqu the less that the equal operator really has nothing to do with it the less operator is good enough so in our library we have sort unique in place uh which is the in place version of sorting and then making it unique there's also a non-place version which is lazy but we get to that later uh and there's also of course also one way you can plug in the less operator but you don't plug in the equal operator anywhere because you don't need it okay now first of all let's talk a little bit about basics of ranges what are ranges first of all the containers that we all know so Vector string list they all own their elements they have deep copying when you're copying the copy elements you copy the elements along with the object and they have deep con constness if the object is const you cannot mutate the elements now and then there are views views are kind of references to Containers or elements of containers and this is essentially what we all know already from the standard Library these iterator pairs just an iterator pair packaged into a single object that's a view they reference their elements they have shallow copying if you copy an iterator you don't copy any elements so if you copy it it's it's all o of one uh and it has shallow constness right so the const iterator even the the mutable iterator if it's const you can still access IM mut the elements through it kind of like through a pointer a const pointer um and if there is a special const iterator just like there is a poter two const through which you cannot mutate the elements okay now there are also more interesting views because this is pretty boring if you just have these iterator pairs um that we use a lot um these arrange adapters they essentially take an existing range and turn it into something else and I will talk here about the two probably most used ones the transform and the filter now let's say we have an Vector of ins and we want to find a four within that Vector of ins right we would naturally use range as find and uh give the vector and the elements we are looking for and then we get an iterator back that points at what we found if that that that integer here that we are looking for is not in in it's straight in in a vector but it's embedded in some substructure like down there structure a has this int ID and then some data attached to as well and then you have a vector of these things right and they also have these these integers one two four but if we now want to find the find looks very different we can't reuse the find that we used up there we have to write it with a find if because we need to access the the ID here and so that means these two things are quite similar in semantics they can do similar things but they look very different in syntax which is not nice and really the problem here is that we we mung two things together one is the projection onto the ID and the other thing is the the finding of the four these are two different aspects really that we should be able to pull apart that's why there is a transform adapter um where you first basically take the vector of A's and you transform it into a vector of ins and you do that lazily so you apply this transformation function lazily while you're iterating you get an iterator and every time you dreference the iterator it will actually call the projection function and gives you back that that projection and now you can use the regular range find to find your four in that transform version of your vector now one thing to uh point out here is what's the iterator pointing to well the iterator is pointing in this case to to numbers ins right because we projected the whole thing onto ins it's natural to say well but I want the a I'm I'm finding the the the four and now I want to know what's associated with that four so I have to go back to the base um and you can do that by just calling base and that basically takes the iterator from the transform unwraps it and gives you the Raw iterator Back which is then pointing to the A's not bad okay now here is a possible implementation uh of this transform and one way to do it is that you're writing an iterator um that carries around this projection function and every time you invoke the operator star it will actually invoke the projection function and return the result and there's also the base which actually just Returns the iterator that is encapsulated that is that is U um aggregated by this this wrapping iterator take note that we are carrying around this function in every iterator H maybe not so good you'll see here's the other one uh I said transform and filter here's the filter uh let's say we again have our Vector of A's and we want the ones that have ID equals four so you want to just have the elements with ID equals four um again this is lazy lazy so this filtering actually only happens when you start iterating creating the filter range is is essentially o of one it's very cheap and only when you start iterating it will then basically skip the elements which are not passing the filter here is a possible implementation now you again have an iterator that is basically the iterator of your filter and it has a functor and two iterators one is the base iterator that where we are currently at where we with which we skip the elements but the problem with the skipping and that's clear from the operator increment down there with the skipping the problem is well we may fall off the end we need to know when to stop because we can't D reference the end iterator so we need to remember the end iterator so when we are incrementing we're not falling off the end we don't need to remember the begin because D referencing begin is illegal so you can't do that but you can't can increment the one before end so you need to remember end so that you don't fall off the end okay so we have a functor and two iterators inside each iterator now how does this iterator look like H you have a filter of a filter of a filter you're think well why don't you just have a single filter that's pretty stupid right well I mean imagine one of these functions is one function is generating is returning a filter and that is consumed by another function that adds another filter and that's consumed by another function that adds another filter so these filters don't necessarily know of each other and they shouldn't have to right so this things these things may come about just be because you you structure your program in that way and it's fine to structure it should be fine to structure your program in that way you don't want to optimize the number of filter um adapters that you are using that's the iteration H it gets an awfully big iterator the iterator grows essentially exponentially with a number of levels of of transforms or filters you put around which is not good and boost range did this not good now you have we have to keep our iterators small because we will'll run small Loops like tight loops with them and we will pass them around by copy and all that means that we don't want to make them huge because then they get very expensive to copy um so here's the idea the adapter object so the object not the iterator but the the object that is associated with a filter it will actually carry around the end iterator and the funter and then the iterator will be very simple it will simply be the base iterator that where with which we skip so where are we in our original sequence and a pointer to that object that filter object that is C++ 20 state-ofthe-art and that's the reason that C++ 20 iterators cannot outlift their range unless they are borrowed ranges so for filter and for transform in the standard Library they said you need to keep your range alive because we want to store stuff in it in particular for the filter iterator we want to store the end iterator so let's let see how well they did um first of all consequence of this decision that the iterators cannot outlift their range there is some danger so if you call ranges find on this transform it will actually not compile with the standard library because they are afraid that if you call views transform and uh I think I made a mistake yes so I made a mistake because V imagine V is an R value this guy that's an R value okay so you had you you generated a vector and then you immediately want to transform it no disregard disregard correct as written correct as written the the thing is that the range is fine still takes a PR value and if so so because we are generating this transform we wrapping the vector into the transform that's a PR value now we are pulling an iterator out of the pr value now the standard is afraid that that PR value will go out of scope and the iterator relies on this transform to be alive to stay valid so they are afraid if you're giving me an R value and you say give me an iterator back to this R value what happens if that r value goes out of scope that's what they're worried about in this case there's nothing to worry about because we call Bas on it so it's fine because the iterator that that is returned by Bas is pointing to the vector v which is not a PR value so this is okay it will still not compile because they're afraid so you have to wrap essentially this thing around you have to little have a little utility as LV value that essentially turns the r value into an L value reference at pure cost purely to satisfy the compiler and say ah it's fine it's fine I know what I'm doing all good okay silences the error okay now let's do the same exercise that we did before with the wrapping a filter a filter a filter filter this is what you get HM it's still linear so you are point you you have a back pointer to the range and you have the iterator but the base iterator still has to hold a back pointer to the range and an iterator and a back pointer to the range iterator and so on and so on so it's still you get a linear growth of the iterator size which the standard said that's fine can't help it h whatever we said nah that's not good that's not nice you want to be able to stack these things like crazy and we shouldn't pay anything for it so how do we do this the key here is is that you need something more abstract or a different abstraction than an iterator iterator is not quite good enough we call this thing an index an index is just like an iterator with the exception that for all its operations it needs the underlying range so you need to give it the range and the index and then it can do things like increment decrement D reference and so on but always you need to supply the range okay and that would essentially be the interface you have an index range and then you have functions on it uh member functions begin index end index increment index and they all the begin index end index return the index and increment and increment decrement D reference they always take the index uh as an input and they are member functions of the range so they have the range and the index okay now of course if I tell you this and then tell you well now you have to rewrite all your code to use indices instead of iterators it's going to be a nogo we don't want that we still want to use iterators probably in our in our code because that's what we're used to so um and arguably it's also simpler to do that okay but still that's not so bad because it's pretty easy to fix this compatibility between index indices and iterators so if we have an iterator and we want an index that's trivial because we can just use the iterator as the index if we then basically get a range Supply to it for free then then we just disregard that we just execute whatever we have to execute using the iterator so with a bit of glue we can just say well use the iterator if you only have an iterator if you don't have an index forget about it we just use your iterator as as the index and this is what we did for your normal ranges that we that that there are so we don't want to reinvent the vector and the string and the the list we just can use it because we can use their iterators as the index now if you only have an index but you want an iterator that's also not very uh very difficult because you can simply build an iterator that again just holds a pointer to the range and the index and then it can Implement all its operations in terms of these two information pieces of information that it has so here operator increment is calling range increment index with the index and it has both of these things the range and the index so it can it's it's trivial you you can you can easily now turn something that only supplies indices into iterators with a bit of gluc code now let's see how now the filter looks like the filter would contain the function and a reference to the base range that it actually is filtering and the increment index is then relatively easy to implement you can just say Okay um my index is the same as the base index and that's important because as you imagine when we have the stack then we can now stack gazillions of these things the index is always going to be the very base the index of the very base range and it will always be in this case a ve if we if you filter vectors it's going to be the vector iterator so you essentially any one of the in the inside this stack needs to just remember okay my position is a position inside the vector that's it doesn't matter how many stacks are in between and when you want to increment you can just ask kindly your base to increment this index it's like here's my index please increment that index and it will apply its own predicates and filtering and whatever there is all the way back down to the base and then return you the or or do this for you for your index mutate your IND index and say this is my index that I my that that that I that I changed for you and so you don't need any more information about what's there in between in this stack it will just automatically work um same with the end you can just ask your base for the end the base can decide is is are you at the end of my of my uh of of this list and if you have a stack of filters then all these end checks will just go back down to the to the base and will just at the end will just be the vector end so it will it will all fall apart into into very very simple operation um and do reference the same so it's it's it's all quite quite simple you you just pass everything down the stack um and if you if you are holding the base by reference which is done here then this may involve some indirection um there is also um in our library if if you pass an r value and you can have similar function actually in the standard Library as well if you're passing an R value it will actually hold the the the the adapter will hold the base range by value so in this case it will really all be inlined it will all be the single object okay uh yes and the iterators all have two pointers so pointer to the base range and in this case the vector iterator also a pointer and you can stack as much as you want okay uh on to the next idea when you are calling St algorithms then you quite often get an end back to say oh I didn't find anything right or I didn't something it's Singleton it's it's I don't have an answer for you here's the end iterator and so the typical thing is yeah I'm finding something and then either assert it's not end or if it's not end do something which is not not nice because you have to the range that you having there that you are checking uh that you are passing into the algorithm you need again to do the end check so you're always mentioning every range twice which then you cannot inline it you need to assign a variable name and so on not ideal so here's an idea of how to do this in a more compact way let's say we have algorithms and we can basically tell them how what you want to have returned in case of Singleton result so for example for find you are running through the whole sequence and if you found what you what you're looking for then you pack this up as the result and if you don't want to don't find what you are looking for then you pack a single ton you say essentially generate the the the default answer the the fallback answer and now you can Define what that fallback answer should be in the caller so we have the little structs that essentially traits that that tell the function well what to do when when you come into one case when you go into one case or the other and when you're now calling find you can say well you know either give me the element or give me end if that's what you want okay but instead you could also say you know I only want the element this this end case is not a case that I'm expecting here I don't want that and that's that's very nice to write that into your code because it's it's documenting it you can tell by reading the code this guy is not expecting the end case it's no longer an assert that you have to write in the second line beneath it you can just directly State what you are expecting from that function call um we also have one version that packs up the iterator into a wrapper an element type um which is nullable so that you now have a nullable type being returned when you are when when you are when when the Singleton case uh arises so when you do a find you can just simply find if Auto it find and then just you go into your branch of of doing something when you when you found it um there is more you can you can do uh you can think do things like return me the prefix before the things that you found you you return everything before the element that's a that's a sub range return everything afterwards um that's probably the include the element that you found don't include the element that you found so there are various things that you can you can plug in there that makes it a whole lot more expressive to write what you want um it's so and there there um that but that's a different talk there there is a different interpretation of iterators depending on whether you found an element where the iterator is really pointing at an element or the iterator is pointing at a boundary really like basically slicing the the range you passed in two like lower bound upper bound it really gives you two parts and there you can do similar things you know give me give me the the sub range before subrange after and so on so there are different traits to use for different algorithms okay next to the another idea um say you have a a visitor pattern right you Traverse widgets here um and you have a sync that you pass in these widgets so if if you have some something then you Traverse these widgets cely and then you have some widgets that are always there and then there's another window and you Travers widget you essentially go through this tree of widgets and enumerate them all right it's a bit little bit like a range right now it's it's it's a visitor pattern but it's it's an it's a list of things so why why not make it a range uh well we don't have an iterator okay is that a big problem how big of a problem is that really let let's try to make that that a range so we can use it as a range we can use the same algorithms that we use for ranges now for example write something like this if you I want to know did I hit any widget well if it's it's when I Traverse my widgets that's that's my range there auto sync Traverse widgets um then I and any one of that has a mouse hit then my mouse got hit or I hit something with a mouse um um should be able to write this I think it's nice very practical in our code now what's really happening here typically um so the the typical C++ iterators that we know do what's called external iteration uh external iteration means that the consumer of data calls the producer if it wants more data and the producer returns that data consumer consumes that somehow and does something with it whenever it wants more data it again calls the producer so the consumer is at the bottom of the stack and the producer is at the top of the stack now that has advantages for the consumer and disadvantages for the producer the consumer it's always nice to be at the bottom of the stack because if you're at the bottom of the stack you have a contiguous code path for the whole range so you you you are never interrupt your code flow is never interrupted uh for the whole range that makes the the this consumer much easier to write uh it also has better performance because you don't have to restore the state of your consumer when when it's being called it's never being called you are always in the same piece of code and your instruction pointer basically encodes the state of that that consumer so if the code path of your consumer is very complicated that's a nice thing to have the producer is at the top of the stack and being at the top of the stack is not as good because you only have a contiguous code path for each item so every item really has is again entering the code at this operator star and you have to essentially in this operator star restore somehow where am I in my sequence what do I have to do I cannot write this as a contiguous uh contiguous Cod path which in case of that recursive uh iteration that we just saw with the widgets is difficult because we need to basically know where am I now in my in my tree and that tree is easy to write if you just write you know one one uh function that calls other functions just make recursive function calls um but if you have to Traverse that with iterators it's a whole lot more complicated um makes it harder to write also has worse performance because you have the single entry point so matter no matter how you do it you still have to when operator star comes you have to say well where am I and where do I have to continue um also between elements you only can allocate a fixed amount ount of memory because you essentially only have whatever you have you are storing in your iterator is your state you cannot just say well I dynamically just get get more memory from somewhere that is from the stack because that stack will be gone the next time operator Stars being called obviously so then you have to go to the Heap Which is less efficient now what you can do and it's kind of funny that I think that the uh the C++ Library doesn't support that is you can turn these things around you can just say the producer sitting at the bottom of the stack now has all the advantages of being at the protom of the stack and the consumer is at the top of the stack so this is essentially the case where uh you these these for each something when you have a four each something call that's that's essentially turning this around because a four each function call will produce these items and will just pass them into you uh or visitor can also call it the visit visitor pattern um really the ultimate ter turn this around function is stit for each stit for each is essentially says call me back with all your elements well in this case you essentially relinquished your bottom of the stack position and says and say well I'm actually happy with top of Stack I'm happy with being called for each element and that situation is very very common we always write for eaches all the time and in all these situations we are happy with being at the top of the stack so the producer could we could give the luxury of being at the bottom of the stack to the producer and maybe you can do something with it let's see first of all can both the consumer and the producer be at the bottom of the stack that' be oh everything is fine right we are both have the luxury of being at the bottom of the stack yes you can with C++ coroutines but C++ coroutines have their own problems first of all you can write this which is actually it's the generator is now it's supported you can you can write that code uh except uh every function that this coroutine calls has to be a coroutine so it means you have to coroutine your whole call tree otherwise it won't work uh which is which is annoying and that's one of the my my big ripes with with cortines that you essentially have to coinify your your whole code base in order to use coroutines in particular imagine that this Traverse widgets it's I mean if it's a if it's a custom function Traverse widgets that's possible but what if I want to use algorithms here what do I want to use generic functions I would have to have them in two versions one basically being cor for cortines and one for non chorines kind of weird strange uh so you have to yeah you have to coinify your call call now uh and it's still a bit expensive because the the the the re-entry point to the coroutine is some sort of dynamic jump you have to remember where you are in a coroutine you have to get back to it uh you have to save and restore some registers so you have to really have to have an the compiler has a has a has a tough time probably to find out which registers do I have to to store and save uh save and and and restore at at the point of switching between the cortines it's a if the if the compiler Optimizer is really really really good maybe you can do that but um it's it's by no means assured so same with inlining right so it's much easier to inline if the compiler knows which Which F exactly which function it it needs to inline um while that decision is by necessity Dynamic if you have cortines so compiler has a lot more work to do um the the Deep Co rific you can also avoid but then you're really going to stack full cortines which the standard doesn't have um and it's it really means you you have two stacks you have to switch between them you have to implement them as cor as as operating system fibers it's going to be very expensive and nothing that you want to use for a tight Loop that you typically have in range code where you have a very tight for each Loop that that has to be very efficient so and it turns out the internal iteration is often good enough you can write quite a few algorithms with internal iteration you can't write find or binary search because we don't have iterators and they they output iterators but many others you can for each that's basically the mother of all internal internal iterations of course but accumulate all of any of none of Works uh we can also have Ed adapters we can have a filter we can have a transform for internal iteration I mean if you pass me an element I can p transform that element and pass it on no problem right so um so the the the uh these algorithms in in the standard in the think cell library all support internal iteration now that's how the any off implementation for example looks like right so you're you're saying uh my my result is false and then you you you iterate and then you see well anyone anyone true and if yes then then it's true and if not it's it's false and yes oh there is there is an any off actually in our library that doesn't take a predicate just does a Boolean um Boolean uh evaluation um which also turns out to be practical now of course here's a problem the problem is uh any off is lazy so we should stop really when when true is encountered when we see true we say oh that's true okay stop don't don't irate further um so we have that as well the first idea was ah we use an exception to bail out well of course exceptions are way too slow don't want that in in tight Loops uh and don't want to do this all the time now the other idea is well we just Define a specific enum uh break or continue and the um the tc4 each implementation can basically decide when looking at at one of these uh at the sync it's it's sync doesn't return something else but break or continue then it's normal I don't have to check whether it's break or continue I can just carry on or if this guy con returns break or continue you decide that at compile time um then if it returns break I have to stop so you kind of Eli the Eli the uh the breake check when it you don't return break or continue so you don't lose anything performance- wise with that check now when how is that useful now these these uh these these this internal iteration does that how does that what does that buy us here's an example quite frequent probably you have concat which is just concatenating two arranges making turning it into one now if you run that together with a for each of of conat right um within with indices that would be quite complicated so you have a concet range and it basically has to carry around a variant of two indices you need to know in which of the sub ranges you have two sub ranges you need to know where you are you do need to say I'm here or I'm there now that means that every time you increment and you you cannot don't remember anything you are you are you are you you get your increment it's like okay where am I am I here okay increment am I there okay increment that guy that guy different code for either case so I can't can't put this all in one one bag I just have to decide I have to make a make a branch of what you do need to do if you increment now the referencing now oh surprise I first incremented now I the reference again I have to Branch I have to decide okay I'm either here or I'm there and again do the right thing for each of these ranges how do we avoid this well it's easy for generators for internal iteration we can it's it's it's so simple we just write two for eaches we just iterate over one when we're done with that we iterate over the other we don't lose any performance much better much easier don't know branches at all all good and that doesn't mean we don't have the iterators the concat will support iterators and it will support internal iteration and if the guy who's doing stuff gets by with internal iteration it just uses the internal iteration interface and then it gets the internal iteration performance and everyone's happy now here's what we can do now uh with this internal iteration another thing stit format also C++ 20 new surprisingly although they introduced both in the same version of C++ s format does not use ranges they had Rangers but they didn't use ranges because they designed the format one guy designed theform it and the other guy designed Rangers and they never really talk to each other much so they we have now stood format and we have Rangers and they don't really fit together very well so here's how they fit together now stit format is actually writing to output iterators and output iterators are in a way already internal iteration because you are essentially passing the things that you are producing to this output iterator one by one so that's internal iteration and it's much easier you you when you are when you are turning a number for example into uh into a string you have to hold state so it's quite nice if you can write this with internal iteration if you don't need internal if you don't need external iteration and typically appending to a string doesn't hold much state it it can just take you know just take the characters one by one so it's quite natural to use internal iteration and now with the generators we can actually do this with internal iteration so let's say you're writing a string like this you won number of f dollars okay and this s deck is really just a generator that generates the number it's think of it as a range it it's that's the string that is that is that is that is written by this F and with two uh two digits um or two decimal digits and and and things you can actually you you actually are required to pass a decimal separator as well which I left out here um required because you want to know when you know you're doing all international code right and we don't need internationalization so you need to specify what kind of decimal separator you want um note that it's not like iostream iostream allowed you to put that double straight into the string which is kind of confusing because What's happen happening when you are when you're putting a a number into a string what does that mean well it it it meant something based on the state of that stream but that made that stream quite cumbersome a lot of virtual functions a lot of state that was carried around how many decimal places do you want does that decimal place oh I forgot to reset the number of decimal digits and now I'm getting an unexpected output IO no one loves IO streams so that's why that's not a good idea it's better to say here this is essentially turning my whatever I have whether it's a number or whatever it doesn't matter into a into a string and this is the range that that is essentially that I'm giving you and please add that to my string now um this also easily extensible I mean there's in s format there are also customization points and you have to write them in a certain way and it's all complicated no you don't need that you only need a function that returns a range and then you just naturally extended the stuff that you want to format like here there's dollars is okay you put a dollar sign in front of it okay that's my that's my formatting function for for dollars two decimal digits and a dollar sign in front of it and I just write this into a function and now I can use it wherever I use use strings right easy and this is how we actually do um a lot of string formatting uh the whole we have a we have a um a an HTTP server for our website and that's how we generate the strings that coming out of it um it's it's you know whole database like queries and turning the database query blah blah blah into a string and you want to format it as that table and blah blah blah big stuff you can all write this basically in one expression turn turn your database query uh into into Strings um yeah there's there's um how you format strings um that have placeholders right so you can have your there's a TC place holders that allows you to put python style placeholders into the string or format style whatever you want um and and it will go by or by by by order okay uh you can also name them here's here's the named version of this thing uh so you can say well it's it's now it's amount and date and then you can give it named arguments that replace the amount and date if that's that's what you prefer and then then the the I I think it's right that when you translate this when you internationalize this string what will get passed to the international usually use some sort of agency or you you built yourself a front end for for de um but what you will pass to that to that to that translator is really just the format string it will not contain the number of decimal digits in the format it would but I don't think that's right because typically you determine your number of decimal digits in a more formal way you either know your data or you look it up you say well this is Yen I don't have any decimal digits or this is dollars and I have two decimal digits whatever you have to to to find out what how you want to format that uh that number um really does not depend much on the on the translation of the actual language so here you have you we we designed this so you can pass this to the translator even if the translator messes up entirely there is no danger of of bad things happening and the worst thing that can happen is he misspelled uh she he or she misspelled the the placeholders and then um and then you won't get a proper output but there's no no danger of anything else happening like like numbers being printed in funky ways and stuff like that um yeah so here with a date I actually you know I have this other format in there the iso 8601 format which turns any date into an ISO 8601 string so it's it's easy it's easy to to to um extend these things okay um and the named things are good for of course for reordering right in different languages it may be ordered in different ways so the in this case the translator has the freedom to do that um now we want to form it into containers um now of course the stit string gives us the empty construction right that that kind of it's it's no parameters means empty uh one parameter means use that parameter for the content of that string okay makes sense and then there are two um of course uh oh there's there okay so that is what we need to add right we should be able to add the construction from one range and and that of course doesn't work but we somehow have to put in glue that it will make it work that you can basically create a string out of any range have range you want to make a string out of it you should be able to write this unfortunately you can't but they'll pour some glue onto it so that you can um the last one is a concatenation now if I look at this first one you know empty construction takes no parameter one parameter means take that parameter as your content multiple parameters means that should be shouldn't that mean that that's the content of the string if I mean if I'm passing three parameters to the string right doesn't that mean that the concatenated version of these three parameters should be the string I I would I would think so but no no no no they're very important two parameter Constructors of strings let's look at them look at them ah there's n ranges okay this is what we want right here this is what I want uh multiple ranges all concatenated is a string there this is what I wanted we have very important two parameter Constructors of the the string okay I'm sure that if you look at them you immediately know what they mean look at them everyone knows what they mean yeah I I didn't okay that's UB uh because a is considered a buffer okay so you you try to put a length of three the buffer of a length of three into of in the buffer a but that that's B because a is only too long a and theator uh okay oh this one as as you all know probably it adds 65 times control C into the string okay this is exactly what I want in this case and and that's that that adds three times the a so good luck okay let's let's deprecate these things right we don't want them um we can write it easily like this right make a range that repeats a three times it's a lazy range we have one for it just add add this to the strange just like yet just like another range we don't need Constructors for all this stuff we just describe the range construct our our our string now of course we can't have this because we cannot change around s string but things s throughout the library uses kind of to to simulate or or remove Constructors it uses explicit cost you can name it whatever you want but point is that this is a glue function that essentially simulates the the Constructor this is our Constructor this function that means it by default can pass on to pass to whatever Constructor you the default Constructor but if you want to remove things or add Constructors you can do it by customizing uh explicit cost you have a customization point to change around Constructors which is very useful so now this works in the standard in our library right so this explicit casted string of uh of of these multiple arguments now constructs the St string um here's a similar thing the the cont M Place back uh is is again a wrapper for imp Place back push back and but that uses TC explicit cost if it needs to so if you if you find something where you really you you want explicit cost it will use explicit cost um so again to to to keep the this illusion alive That explicit cast is really the Constructor so this is like basically throughout the library we use explicit cost um we can also append right so you can do the concat and uh either we append with concat or we just have uh multiple arguments and they all being concatenated automatically now let's see how we can speed up the formatting into containers the idea would be we determine the string length then we can allocate for the whole string we can allocate the object uh allocate memory and then we can fill in the characters okay so this is maybe that's something that we can reap as a side benefit from having everything as a range um so we could write it this way where explicit cost essentially just just takes iterators begin and end uh and then constructs the container um the problem is uh for non-random Access ranges the string con this the string Constructor runs twice over the range the standard Library assumed that iterating over a range is cheap it is no longer in a Range World in a Range world it's expensive to iterate over a range but they assumed it's cheap so the standard says you we only allocating once when we construct construct a stit string that's important we don't want to avoid memory allocations we don't care about the iteration so no how no matter how complicated your range is the stit string Constructor when Constructor in from a non-random access range will iterate twice over the range uh which may be very expensive so the idea here is give the poor range so first of all avoid iterating twice we will always only iterate once and if we need to we will reallocate the string multiple times but if you want it to be fast then just give a size function to the range so that the size can be uh determined up front and then only single allocation happens that's the idea so determine the r the size of the whole thing at once at up front single allocation and then iterate over at once now um so we have an explicit cast where the range has a size and it's not a random access and then you can do the reserve with sit size uh and then iterate and uh for list for example not random access that's fine so um otherwise you would have to uh you would have to um you would have to iterate you you would have to um still reallocate multiple times here you don't have to because list for example would have a size uh there's also a pendant um watch out there's a cont Reserve cont Reserve is evil cont Reserve is evil because cont Reserve doesn't take you into account what you reserved before four if you are adding something repeatedly that is only one character at at at at at it will it will reallocate every single time horrendous okay uh there's cont Reserve in our library doesn't do that okay it at least doubles the size of the allocated memory or something like that so let's get rid of this so better reserve um and then what about the generator ranges now we have an appender customization point where you can add you can for each container it will get the appender it's it's now a property of the container to get an appender and that appender um by default just doesn't imp Place back right this also works that's a sync for for uh for generators but you can also have a customization Point chunk which takes the whole range at once and here again you have the possibility to query that whole range for the size so even for the generator you could write a generator that outputs these things one one by one internal iteration but still has a size member that can tell up front that's my size and then the container we preallocate that size up front and then you're faster for files that's also useful because chunks of of continuous me memory you can write at one with one go into a file that's that's efficient uh now we measured how fast that is and it turns out I'll skip over the details uh if you do it iterator based we are wasting 50% more time over a handwritten Loop but if you use internal iteration we are at 15% so it's quite efficient you write very high level code and still you get a lot of performance out of it um there is another OPP opportunity for optimization which I skip over so we have a bit of time for questions um where you can when you add things to a string one by one it does the end check every single time although you you know I pre-allocated the system doesn't know that and you can optimize for that we haven't done this yet but you could with that same interface you could say I am essentially having an appender which is not checking for end because I I asked before the size and now I can write that whole memory in one go without the end check and that actually that that's the that's the one say basically just put it to the end increment the end just do that in one go um that saves 20% in visual C++ again when just filling a string so it requires your own basic string implementation which we don't have yet all right you can do more you can uh for example if you don't have a size but you know a minimum size at least then you could say well I I know roughly how to allocate don't not exactly but I can already I know it's at least 100 so I can already allocate 100 and I don't start with 1 two 48 and so on okay um the custom file dependo can be even more optimized if you had your own file buffer because you know that you know file buffer they get written out with a cluster size so you could really just fill the cluster if you know I'm again 250 bytes I know there's no end at 250 bytes you can just write 250 bytes no end check because I asked you before how big are you you 250 btes okay just write 250 btes now I have I don't know so many btes left I know how long I have can write it's like oh stop here now we have a range that may run into end so run into end stop right there and then write out my cluster get a new buffer for a new cluster and keep writing can all be done uh conclusion is ranges are very useful uh we had index based ranges and generators they improve performance over C++ 20 ranges and uh you can there's also plenty of opportunity to unify ranges with text formatting which is very useful uh for us now that we half all this range stuff and this is the Earl to our library uh lot of useful stuff in it again um if you write in your project looking for a library use that Library if you just want to copy it Fork it run with it without bothering about the changes you're still going to be ahead I think uh I think it's a it's it's a very good Library um I hate the range based for Loop don't use the range based for Loop because it makes people write things like this instead of this thank you very [Applause] much questions questions no questions Hi H did you have the chance to look at the flux library from Tristan brindle it's also based on he calls it curses but it's basically the same as you did with the index um just remembering like the index and then no I haven't seen I haven't seen that Library there's also another piping Library out there I know which is very similar to the generator library is this Library um uh compatible with regular iterators uh yes he has some adapters so maybe I it's a maybe you can talk about it afterwards it would be interesting yeah okay um hi uh thanks for the talk I I especially like the the formating it looks much nicer um in the beginning you said that the uh the old boost range iterators are kind of very fat because they contain everything in the iterator do you have performance data on how much that actually matters or are you aware of any other like comparisons between boost Rangers versus Range V3 versus things cell ranges versus the new standard no um but I do know that I brought up this this topic um on the ba mailing list when they designed the the C++ ranges and at least they all said oh  uh and that basically was then the the I think it was the the kickoff for saying iterators have to keep the Rangers alive we need we need to require this because that's non obvious I think the first iterations didn't require this so at least so I I I don't know um I mean I guess with exponential growth I mean you can always make it bad it's just how many how many you have to put together so I think exponential growth is always so bad that you have to do something about it um I mean if then you add add three more and you it's all going to explode um so yeah all right thanks hi what I'm missing in current implementation of C++ ranges is par processing when I move from from iterator code to to to to new ranges is it possible to add such for example sord you can adds too power and you have power processing is it possible to add it to your probably probably not as as much um I mean the the the ranges are or the way that they paralyze ranges does rely on the fact that you can you can you know chop these things up into pieces and then operate on pieces um really the ranges are the generators I think are most useful in this very frequent case where you have small Loops tight Loops uh very lowlevel Loops essentially where this inlining is just very important if there's if if you're doing a lot per iterator de D reference or or if if there there are big operations then that overhead for D referencing doesn't doesn't Factor so much anymore so I think in the for um for parallelization then yeah you would need probably need to do it manually um but but for for these very frequent tight Loops where you don't really think about it how many four eaches do you have in the program it's just many many many um there it just it's it does something for you so we have two questions from the internet one question is um does your lar have a shallow constant problem as C++ ranges also use I didn't quite understand go ahead sorry say say again the first question uh no this is one question does your library have a shallow constant constness problem as C++ ranges also some views cannot be passed to a functions that accepts values as const reference like Drop in CS Plus+ ranges does your library have the same problem um do we have shallow constness problem um the so I when designing this Library I had a big headache because because exactly this problem um is is there a way to ensure that if you have a range const reference pass to a function that you are that you're guaranteed there is new mut no mutating happening I think per se this is a I wouldn't say impossible problem to solve but I think it's a very hard problem to solve because a transform can always turn a a whatever you know whatever item you have into say a mutable pointer and per se you don't know what you're mutating there it it could be something that's within the range it could be something well outside the range so what's what would be really useful in this particular case would be that there is just no mutating ever possible um so that it's a real pure function that you're that you're calling your iteration is really pure function there's no side effects and I I think this is very hard to to ensure sure with the compiler um because you are you essentially you could pass out a project proxy object which then turn then turns your your it could be passed out const and and you call it and it gives you something mutating out of it so it's something that you it's it's I I don't think thinking about this I don't think it's a range problem this const problem I think it is a language problem it goes much deeper than the language if if you have a than than the than ranges if you have a function that is marked con reference and you call this a method on a on a uh on a on a class then this class is still able to return you a pointer through which you can mutate the world essentially and and I think I think that's that's that's wrong I think the language should have something that ensures that something is a pure function has no side effects whatsoever but I think just C++ does not have that and and I I believe this has not so much to do with ranges in particular if you are looking at transform because transform is effectively calling General a general function and guaranteeing anything through that General function is going to be impossible so I gave up on it um I'm we are still we are still having the convention that if you don't want to mutate the range you tank it by conre but that doesn't guarantee that you cannot mutate anything through the r through that range it would be nice if we if we could but it's it's I think it's very hard and I think it's maybe even beyond the scope of Rangers um there was another question yes um so can the uh Library use as open source yeah it's a boost boost boost license you can use it as as you as you wish than