this presentation was recorded on my live stream and honestly it was one of the best presentations I have ever seen in my life no this is not an ad it's just an amazing walkthrough of the technology that is tiger beetle you have to watch uh thanks Prime uh pleasure to be here with you all uh tell you a little bit about tiger beetle uh tiger beetle is a financial transactions database uh designed to be a thousand times faster than existing systems uh so I want to share with you the techniques we used to achieve this performance hope to convince you why tiger beetle is not only the fastest but also the safest database we could possibly have built uh but first I want to tell you why we designed a database from scratch uh so in the past existing Financial systems uh they' take like a general purpose database uh and then they'd add 10,000 lines of code around them uh to record the debits and credits as money moves so we noticed this in 2020 uh I was working on a central bank switch it was by the Bill and Melinda Gates Foundation uh open source switch and but looking around we saw this is what they were doing and then looking around everywhere else we saw well everyone else was also Reinventing accounting over general purpose databases so it was like a right of passage uh before you could work with money you had to roll your own Financial transactions database out of postgel sqlite uh so the problem is that these databases give you the Rowl transactions engine uh but you still have to build the financial transactions sh you can't just get in and drive uh the second problem is that the world is becoming more transactional so Financial systems today they need to drive a thousand times faster than they did in the past uh because transactions are becoming smaller and more frequent for example energy sources are changing uh from from coal to clean energy so as you move to solar the sun rises and sets and the price of energy changes it's cheaper you know when the Sun is hot um and it's maybe more expensive at night so if your smart meter can transact energy every half hour um it's it's it's literally valuable so you can actually Arbitrage solar prices but to do that your infastructure needs to handle a thousand times more load as you switch from monthly billing to to half hourly Bly billing so you also see the same increase in the cloud As you move from dedicated servers and monthly billing to serverless and postc billing uh except there it's often just map reduce billing every 15 minutes uh so you can't always set real-time spend caps and that's why Cloud Bulls can get out of control uh so cloud and energy are becoming real time and then there's actually realtime payments so 5 years ago India's realtime payments system UPI uh processed 10 billion payments a year uh the month of January alone they did 12 billion so the volume of transactions across several sectors has increased 100 to 1,000 times in the last 10 years and yet the three most popular databases postris my SQL sqlite uh they're 20 to 30 years old designed for a different world in scale um so it's one thing to build a car with an engine from the '90s another to race Formula One uh but if you want to break ma 10 you need to rethink things uh not only performance but especially safety so this is the question we asked with tiger beetle how can we take the four primary colors of computer science network storage memory compute how can we blend them into a faster safer design for the future for our kids for the Next Generation for the next few decades so let's look at performance first as you go through three orders of magnitude acceleration uh things get hot anything that's not aerodynamic burns up so you suddenly see an impedance mismatch and that's because while the language of databases is sequel the language of financial transactions in the real world is really debit credit that's all that most most Financial systems need however if you want to debit credit to accounts and you trace the actual SQL queries that these systems do uh one financial transaction you need around 10 SQL queries and that is like kind of you know let's catch a plane from Cape Town to New York with one person in it then we come back again let's go again let's do that 10 times you know as you do the network round trip and that is one financial transaction and that's if you're pretty good you know they do a lot of direct flight so it's a rule of thumb in many systems of course you can use St procedures to get this down to one but that's only a 10x win so we took a step back and said hey uh debit credit is actually a pretty solid schema um everything you need to represent the who what when where why and how much of business it's also small you can pack one of these Financial transactions 128 bytes is two CPU cach lines why not just pack a few of these to together um let's put 8,000 of them in the plane and send them from Cape Town to New York in one trip uh so it's one you know that that's a 1 Megabyte database query 8,000 of these little um 128 byte transactions so that would give at least a thousand times more performance and this is the Breakthrough in Tiger be it's so simple like we really did nothing special this is all we did uh let's just put 10,000 more things in the query and hopefully you know we should get a thousand times more performance so when you make a trip to the database 8,000 transactions in one query and then these run through a single CPU call it's a nice hot tight Loop no rocks no contact switches CPU is like a sprinter you let it loose on the 100 m hard to go faster so I think a lot of distributed systems in the past they made the mistake maybe you know people thought um things were slowing down so they made the mistake of betting on the speed of light in fiber and then they take the data cut it up and they spread it across machines and then when you want to transact across your accounts the CPU must wait across the network you know to bring everything together but the secret of financial transactions is that they're transactional so there's always a counterparty one of the parties is almost always your bank account and there's just one of them you can't you can't Shard it uh so you could have a million customers you can Shard those um you know you try to get a little bit of horizontal scalability but all the shards are going to bottleneck on your hot bank account uh so you're actually making things slower as you go horizontal but now you're also getting lumpy you know Network weather in your late in your p100 latency so there's a saying that the number of people predicting the death of Mo's law doubles every two years uh but I think if you bet against Mo's law that could actually be twice as costly in two years as chips like the M3 keep transistor counts doubling um so that's why if you look at high frequency trading everyone's actually running single core they're getting massive scale going skyscraper vertical M law is that good they say so we were inspired here by Martin Thompson's elmax thread per Core Design um like elmax tiger beetle has replication but like elmax we don't make the mistake of going horizontal too soon so we're not overd distributed uh we are distributed multiple machines involved there's replication but we don't go too far so there's a time for going horizontal I think and that's where you drain to object storage but that's only once your hot data has cooled so the architecture of tiger beetle it's a classical replicated State machine uh and I think this actually just really makes a lot of sense if you say it backwards so it's a machine with state that you replicate uh first a request with 8,000 transactions comes in off the wire from the client Second Step you log this to disk for durability you replicate it in case a data center blows up and finally transactions are debited credited to the accounts reply sent to the client so this amortizes the death by a Thousand Cuts of dis Network even consensus so you get the gold standard of perfect atomicity consistency isolation durability by default and you're not sacrificing performance so if you get the design right things like consensus become free they're not expensive they're only expensive if the design is wrong I think so these are the big performance ideas we also put a few cherries on top um and here performance is about what you don't do so after startup we don't call Malo or free if you think through the physics of the database how data flows you can statically allocate the memory you need and decouple performance from memory usage so because they're no hidden allocations you get these hard p100 latencies no GC spikes and because every struct is handcrafted you're also more efficient with memory so gravity has inverted memory bandwidth is the new bottleneck so you don't want to burn bandwidth or thrash the CPU cache with M copies so we try to be zero copy as far as possible uh we do do a copy from the Kernel's TCP receive buffer um but from there we use direct IO to dma to disk so we save copies also with zero deserialization enforce little Indian what comes off the wires what goes to discs or fixed size cach line align structs um and then to eliminate CIS calls contact switches we to the kernel through IO uring uh use the kernel thread pool for async non-blocking Io so to handcraft everything like this we wanted a systems programming language and here the question was should we invest in the language of the last 30 years C or C++ or should we invest in a language for the next 30 Years Zig and rust so with static memory allocation we had a way to downgrade most issues around temporal memory safety convert those from physical to logical we didn't want a Fearless multi-threading because of the performance overhead and we had a single-threaded control plan uh thanks to a uring uh so rust's borrow Checker while a great choice for many applications made less sense for tigerle at the same time we wanted to handcraft memory have no hidden allocations in the standard lip you can see where I'm going with us and we wanted to handle memory allocation failure so Zig stood out uh for its ability to work with memory explicitly not to mention comp time um you can program Zig while the while the binary is been compiled and that's just a force multiplyer so as a result tiger beetle has zero dependencies pure Zig single binary it's about the size of a floppy disc so you get a whole distributed database everything and it's it's it's amazing just to actually shrink back to the past and get these small small binaries and then you run the single binary on a few machines now you've got a database it's extremely reliable predictable easy to operate and that's why we called a tiger beetle uh after one of the fastest creatures on Earth shout out to Don choot the original tiger beetle with me uh who coined the name um and the tiger beetle it's got the small footprint you know it's not only fast but small and it can thrive in tough environments so why Big Iron when you can Beetle uh of course it doesn't matter if you're database is fast if it's buggy so processing Financial transactions is close to nuclear not enough to be as safe as 30y old systems you need to be 10 times safer so to achieve this level of safety for tiger beetle uh we developed an engineering methodology called tiger style uh tiger style is based on NASA's power of 10 rules for safety critical code we have over 6,000 assertions in tiger beetle uh there's code to check the code everything is double triple checked thousands of trip wires so we either run correctly in production or shut down safely again static memory allocation is crucial uh to give the operator a reliable piece of software with well- defined shape so while these are techniques you don't see often uh tab t style is starting to be adopted even just by other companies as engineering methodology uh but for a database especially you need to be durable and here the research is exciting uh for example most uh existing database designs are from before 2018 however in 2018 uh fsync get showed that databases don't always handle disk failure correctly this can lead to data loss and then in the same year a paper from W medicon uh called protocol aware recovery for consensus based storage showed that distributed databases even with replication also don't handle disk failures correctly and this can actually lead to Global cluster data loss so for example even with raft uh rft's formal proof didn't actually include a storage fult model uh so the reason is that like SQL light which is like it's the best of them all um most databases were designed to handle partial dis RS you know during power loss that's what they were designed for they weren't really designed for whole other kind of storage fault beyond that um so they assume the data they read is the data they wrote or if they do have check sums they assume that the disk firmware will fsync correctly or that they are reading or writing you know from the the right place on disk and that might not actually be the case so even check sums don't protect you here um so these older designs they can survive they can't survive you know the 1% of discs that misfire in a year and this is a problem at scale and that's why in 2020 we took this research we just took it you know um we stand on the shoulders and and pay tribute to to the researchers and we we took their recommendations and we designed tiger beetle to be one of the first databases is to have a storage fault model so the big idea is that if you already have replication why wouldn't you want to embrace the endtoend principle be like ZFS but in the database and then you make your database selfhealing so to do this we took U the pioneering vew stamp replication or VSR consensus protocol from MIT we integrated VSR with tiger beetle storage engine so the consensus can repair each machine storage engine uh it's kind funny you know consensus gives you replication but for years it was never actually used to be self-healing uh you have to throw the whole machine away and um re-replicated a whole new one you can't really heal these things um but VSR enables tarab Beetle to run across machines and then have multi- region automated failover so when the data centers and discs are burning vssr keeps your transactions churning so to learn more come join Matt clad live on Twitch every Thursday for iron beetle um he's doing these code work walkthroughs and the code is all on GitHub py to open source so it's been just over 3 years since we started from scratch our first production release around the corner literally weeks now and at scale a single uh tiger beetle cluster can already process a 100 billion transactions just spin up a cluster and send them in um or you can take a very small rasbury Pi cluster run tagab on it and maybe you can do 10,000 Financial transactions a second at least we could you know with micro SD cards which are very slow so on an office laptop things are getting a bit better tiger beetle can do you know 300,000 Financial transactions a second and that's just indexing all the data uh with primary indexes only it's about 640,000 a second and we're aiming for a million design Target U here's the crucial qu question how do you overtake databases with two to three decades of testing for example how do you test tarab Beetle for two centuries every day so tigerle was designed not only as a distributed database but as a new breed of deterministic distributed database so they two databases in the world the other is foundation DB they're like Neo they can fight not only in the real world but also in a simulation they can train faster so the simulator can speed up time it can fuzz two centuries every day uh it can take all our explicit fault models inject them check them like a model Checker but on the actual code uh and then automatically open a GitHub issue for any bugs we find and then we can replay these bugs again and again just perfect reproducibility from a seed to fix them so you get this massive developer velocity and a small team like ours can build a little Beetle like tiger beetle and this is how you know we feel this is the safest that we could possibly have built this um but we also had some fun uh with the simulator so Zig is the kind of language where you're like okay we're runting a database let's also make a game so we took Zig we cross-compiled the simulator that can run a virtual cluster we cross comile this the the simulator to WM so we could run a whole TIG virtually with like simulated Network and everything but we could run it all in like a browser tab so our friends Fabio Arnold Joey Ma they plugged the simulator into a zig rewrite of nanov VG game engine they drew illustrations on top so that as the simulation runs you see everything visualized so now that I've told you about tiger beetle I want to show you quickly about tiger beetle how it runs even in the browser you normally you wouldn't do this at home this is just a game right but it's a walking Sim and let's see uh law of demos there we are so what we've done simulator again and we've taken the fault models and we've said let's just start easy let's just make everything um everything perfect there's no Hardware faults let's just run a database in the browser let's just see if we can do that uh so it's going to be prime time everything is perfect are you ready so he has a cluster of five five tiger beetles descending um these are them here we can select our units they're getting ready to start up these are three clients that are going to send requests in from the network there's our leader who's been elected wait for it wait for it there they go so the requests are coming in the clust is replicating backing up and saying to the clients we got this we got your transactions and everything is perfect and each of these beetles is actual real zinc tiger beetle code they don't know that they're running in a simulation with fancy clothes they just think they're a database but they're in they're in the browser thanks to Zig and wum so that was pretty easy let's let's level up this is now red desert and what we're going to do here is we're going to introduce like a a flaky Network so we're going to mess with the network packets um packet loss of 13% we're going to replay packets and do Network partitions there you can see the mission impossible five uh glass box which is causing Network partitions and we can also do these ourselves let's I just put a network partition in so the cluster now is trying to recover and elect a new primary which is it's going to take a long time because we're just putting in so many faults here but the simulator is checking that we're getting maximum from availability and correctness uh and everything is working fine if the screen crashes then you know we found a bug but so far we're good so this is like chaos just on the network and everything is is recovering [Music] fine we we doing a leader election because the primary was partitioned do that one and we made it so this is sort of how far most databases go like if you can write a distributed database that can survive this you know then you've pass the Jepson test which is pretty amazing so this is really really really hard to survive and no one really goes beyond this but let's do that let's get radioactive what we're going to do now is just corrupt 10% of our IO to dis on each Beetle and you can hear that in the music so we've got 8% of reads are being corrupted 9% each time you write a disc one in 10 is going to get corrupt and tager beetle is going to detect this and self [Music] heel we can crash a be as well so now we're actually interacting and poking a deterministic simulation and you can engage duck mode as well so shout out to duck DB one of the most awesome analytics databases and you can use duct TV to CR the tiger beetle or you can zap them with a cosmic gray which is quite shocking but it [Music] survives we've done 31 requests and we're doing okay so far getting close to the end think we're going to make [Music] it so far so good Zig is a lot of fun so again shout out to Joey faia who cooked this up and also to the whole tiger beetle team and all our friends and family and supporters we did actually we didn't only make the walking Sim we made a little a little game within a game just to to P for and so thanks to everybody who's it's a whole lot of people that made this possible and uh yeah let us know if you can if you can beat the highest score [Music] wow um I'm pretty sure you know I I'm not going to say that I know exactly what everybody is thinking but I would just like to say that I'm pretty sure everybody here thinks that that's probably the coolest project they have ever seen in their lifetime that was awesome that was great and the the game was even better like the visualization of what was going on the network not working the packets like you could see that kind of like the the over sending between everything to try to recover and just watching it come back to life and then the crashing ah it was fantastic cuz it's it's hard to visualize what actually happens when people say all these things are happening like you don't actually have an idea of what it looks like you actually got to see the thing in a cartoonish way it was glorious Y no thank thanks so much this is kind of the dream is like how can we show this just to kids you know and like let them see computers and distributed systems see how this works and relate to it and then we just had so much fun making it so um yeah it's just a privilege like that we can be doing this and again a whole team you know cooking this up and just having fun so thanks thanks for the awesome uh glad glad you enjoyed it this wased glad was so awesome this you have no idea this you just accidentally raised the bar for every technical presentation ever to exist from here on out I'm not even sure what's going to like you you're you're the balers gate three of technical presentations thank you we're going to have tweets now like great you ruined it for everybody we no longer want to do this that was awesome I'm just so glad we could we could put you in there Prime I hope you liked liked liked your throne we had for you honored all right so so I'm sure we have a lot of questions I the first thing I saw is a lot of people were asking so Tiger Tiger uh tiger beetle specifically designed around Financial transactions right it's this is not a general purpose database this is not a drop in replacement for postgress this is actually a specific Financial database is that correct that that's it so this is like your bank fault so normally you know we take people's money and we put it in the filing cabinet with all our general purpose data and this is like this is like your bank fault so you put the money in tarab Beetle and then all the control plan meter data goes in your general purpose post gral sqlite so it's just a separation of concerns um but there's some good news is that the whole the H of tiger beetle is kind of designed like like an Iron Man suit so you can take the financial transactions um State machine out the business logic out and you can put another database inside so you can write your own business logic and use tiger be as a framework and suddenly you've got a whole new distributed database so we've been very careful like that so actually I'm kind of excited you know how we can make new databases with this as a framework all right I mean that that is even mind-blowing really is where we're at right now I think everyone in chat is just they're having a hard time even imagining how awesome this thing is uh that's fantastic all right so I'm going to get some some questions up from chat we'll see if anyone has anything that's worth saying uh chat always isn't the most reliable when it comes to insightful questions but if there is anything we'll see yeah do you have more info on this tiger style do you have a like a article you can share with chat anything you can point to cuz that is like I like the idea I've done a little bit of like development on Space stuff and it was very rigorous testing policy so I'm very curious how does this translate to real world software yeah great so thanks thanks so much so we if you go to the tiger beetle repo it's github.com tiger beetle tiger beetle in there you got a docs and tiger style. MD it's the whole tiger style Doc is right there and then if you go on tiger beetles YouTube we've got a talk there called tiger style and there we sort of fill that in as well so there's a talk tiger style and in the GitHub repo tiger be tiger be tiger style. MD you can also find out design dock for Tiger be as a database like how you know a lot of what I've showed you here too so and if you use tiger style let let let us know you know if people use it if you want to adopt it at where you work in a project just let us know and we can put your logo there or sort of start a little bit of a movement uh it's I think there's three or four companies Now using it which is pretty cool well can can you give us like a a quick because you know I'm looking through the MD and there's a there's a there's a decent amount of words it almost even looks like you might be quoting billbo bin down at the very bottom but uh shortcuts make long delays as we always like to say around here I think that's Mary but um can you give us like the three super high level points of like what is tiger style someone just walking by on the street if you had to tell somebody in 15 seconds what is it so tiger style is a way that you can tackle the hardest hardest software problem you can ship it quicker like five times quicker five years quicker if it's a 10-year project you can do it in four or five and you can do it to a quality and and and much much tighter tolerances so kind of like what we did with tiger be or the storage fault model so those are the three big Ideas um tackle the hardest projects um solve them quicker with much better quality it it it's a way of taking responsibility as software is again uh software developers again for like handcrafting software but it's also quicker because of the deterministic simulation so you're a lot of the time on these projects the hard projects the time sync is the testing and debugging so if you have a simulator that can speed up time and reproduce bugs for you you can be fixing like 30 bugs in in 3 weeks um you can just go so much faster so it's you go slow to go fast all right all right um is there is what is the primary um way in which you are attempting to test this is it is it purely through simulation or fuzzing or is there is there also like a recommendation on using asserts and all that is there like a code style enforcement something like quote unquote clean code that's you're trying to enforce or is it just purely about testing nature okay so it's the the testing as well but the the other so tiger style is both how do you write code how do you test code in terms of writing code it's not like it's not very pedantic so we say like look um you know it's it's it's a it's a tight you know it's a tight beat and a rare Groove it's both so it's got a a coolness about it that it evolves it's not strict it's not none of that what what we think of like how you write code comes down to things like how you name things um and there's a lot of tips there that we've learned like use usually as programmers we write variables as like least significant bite order um so we will say like Max transactions Max replicas and then we will have like like time out for transactions but now in the source those things don't line up anymore so if you switch it to most significant bite order you'll get like you'll get something like LSM table count Max um LSM growth factor and now all these things just are nice in the source so there's little tips like that on the coding side the the biggest two tips on the coding side are assertions assertions are like um they're beautiful so it's it's basically saying look as you're coding you're thinking about this stuff you could write comments and it's great to do that but also encode your expectations what you expect what you don't expect put that also in the code AS assertions and and and we show you how to do that that you can stay fast so you separate control data plan and then you put your your expectations into the code and then as your code runs if it's running correctly great if it isn't it shuts down you get a nice stack tress you know exactly where it went wrong your your your understanding wasn't quite right and then you you tweak your understanding so it's it's fantastic you know for a team you you can document your your all your knowledge in the code and then combined with the fuzzing with the simulation T deterministic simulation testing is a bit more specific than it's a certain kind of fuzzing where you actually can you abstract the time that gives you timeouts in your code then you can speed the whole system up and run it quicker that that's the key thing plus when you run the software it always runs the same time so the the G the game that I showed you is running real tiger beetle code if you watch the game it's always the same and the code always runs the same every time but when you combine the simulation testing with the assertions that is really really powerful because now you're yeah you you the simulator is also checking you know no split brain in the consensus log it's checking many things cache coherency of our user Space page cach and what's on disk the dis is being simulated so it it can reach in and do all of this stuff but your assertions also help to find a lot of bugs so that's kind of the two you know how it it's ying and Y yin and yang it plays nicely together the assertions part is particularly interesting because you know being able to build a simulator for this is probably not tenable for most computer problems that people are building software for that they you know you can't it's it will be very hard for me to convince my boss that I need to simulate disc writing and all that right like he's going like okay slow down just you're just quering some [ __ ] data let's let's slow it down a little bit here uh but the idea of putting in assertions which is something I've just started to do a lot more ever since listening to that uh podcast with Le Lex fredman and uh carac where he talks about how he largely drove correctness through assertions and I realized like I never did a lot of asserting and that actually seems like such a powerful technique because you do get such good information and you know exactly what has gone wrong it is so much more clear than undefined is not a function it's more like no this was the expectation we did not like get there so therefore the undefined amount a function that's a consequence of who knows what just doesn't happen because of the assertion and so I I love that I think that that is such an amazing thing I I do have a followup because you do a lot of automatic um posting of GitHub issues I saw that that which was by the way super cool that you have this do you ever accidentally like post a security exploit by accident due to automatic GitHub issue posting like do you have to have some sort of filtering on this to prevent people from performing naughty stuff uh great question yeah so we we thought a bit about that so the these reports come from our simulation infrastructure We Run 100 CPU cores 24/7 so you get you do get two centuries of test time every day that's simulated but so it's actually like it's it's just it's not it's not um this is not reports coming from production deployments of tiger beetle so this is is there's no user data these are you know from it's the simulator that sends the reports uh tiger beetle proper doesn't have that code to do that so that's yeah and and also um what was interesting Prime is that the simulator the first version of it took it was 600 700 lines of code and it took 3 weeks to build so the tricky part was just that we had to think about it up front like with tiger style so we built tiger beetle for a year with these ideas in mind and because we had it like that then the simulator took 3 weeks so it it wasn't it wasn't actually and and then it really sped us up because you know often you can sync like two or three Engineers just into testing um and then this now it's it Yeah you sort of you can you give yourself a ratchet that you you make things reliable and then and you you can now sort of do like biodigital jazz as you work on these protocols you can try try really cool stuff like with the selfhealing protocols algorithms cuz now you've got a way to like climb these mountains safely with a rope okay okay that's I I do I do actually really like this because I now my brain's spinning about this because we have a particular problem of an internal tool in which needs to become more reliable and a lot of it is just like the problem is we do a lot of stuff through mocks and and testing and so you know all the tests seem to pass but the reliability still is fairly low and so it's like okay so maybe we can actually play these things in a more real environment that actually causes the real problems to be exposed and so something very very interesting about that that I'll I'll I'll definitely want to think about more because the simulation you're right if you think about it ahead of time and you put in the proper Hooks and everything so that when the day comes you have to write it you can write it in hundreds of lines of codes as opposed to rewriting things from on both sides to try to line up so it is something that's very interesting if you have long-term projects think that maybe a simulator might be a a potential future at some point um all right Judo keeps asking this question are there any plans to support the modeling of transactions other than numeric types for example if we we were let's see if one were to create a data type in corresponding logic functions for how to apply those transactions to an account add subtract Etc yeah cool awesome so if you if you go into our repo um look for stat machine. Zig that is the business logic so you you could actually just go and change it and then you compile it and and then that's your database uh so you you can if you if you want to like really customize it you can uh and yeah and and then you get all this infrastructure comes with it free so you get the static you don't in the state machine you don't worry about static allocation you don't see it there so we've kept all that away you just get to write really nice um imperative um business logic there's no IO no concurrency it's it's a very cozy environment you get the simulation testing comes with it uh yeah and and we're hoping to sort of extract this as a library open source vssr so that other projects can build on VSR and just have a rock solid foundation that is awesome okay one quick kind of more boots on the ground practical question uh a big thing when it comes to system languages right now people are very excited about rust and one of the big downfalls of rust of course is the compile time they just you know Meme after meme about the compile time what is it like working in a larger Zig project do you find that the the tools surrounding Zig and also just like developer happiness if you will what is that like including compile so I think okay great awesome question so um we love rust as well so we like to say you know rust and Zig and there's there's a time and a place and so Matt clad on the team wrote rust analyzer so it's been very interesting to see you know in terms of tooling like what what what can we do for Zig and Zig has got Zs which is great by AUST and um and Zig is is it feels good for us you know we've we've got a little open issue of things we're learning um things maybe can improve in this in standard Library we had something awesome the other day where we've got now Zig build check so you can check your Source you don't you're not actually interested in the binary you just want to check that that it would compile but that is so so fast so like it was just today in slack someone was saying wow just is it's hard to believe how fast this is um and what is exciting with Zig is how much they're investing not only in the language but in the whole tool chain you know the cross compilation story but also like they're thinking the next 30 years as well you know do we still want llvm in 30 years for sure but but do we also want new stuff like new back ends for sure so like it's so nice to see that they're they're doing that as well so um it's it's been a overall it's been a fantastic experience like we'll find if we find a bug like this happened two days ago we found a small bug in the standard lib um around process execution and when we reported it it had already been fixed because the language is just going so fast so this is what we want you know what we don't want us a language where you know it takes a year to to get iing in like we just put it into Zig and it was there so the velocity you get and it's a great Community now it's a perfect time it's like you want to paddle out and catch that swell now and nice people hanging at the backline there awesome that is that is super good um hey is there any where where can people find out more about tiger beetle about any of this stuff what is the best you know mediums to use yeah so we're on Twitter uh tagab Beetle DB on GitHub so there's a lot of like day-to-day info there um we've got a our newsletter we put a lot of time into it just as engineers so we like every single PR we do I it's the weirdest newsletter cuz every single PR we like write a whole story about it like the whole backstory of what was going I mean the PRS themselves you know you can read it there too but it's a nice way to see like a a very detailed change log um otherwise yeah and GitHub is the best place so github.com tiger beetle tiger beetle and then join our slack for questions we're happy to um we' just love to pay it for and connect with people and make friends and have fun awesome this was absolutely fantastic thank you Yan for joining us um the presentation again was you've set a new bar so really appreciate that uh I think the beetle just did it Prime so we just follow where the inspiration strikes and zigg and um just so nice to have so much fun you know um yeah so and thanks thanks to you and to everyone it's really awesome to hang out