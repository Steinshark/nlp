hello and welcome to coding adventures episode number 2 in the last episode I worked a little erosion simulation and got a lot of interesting suggestions on how to try and prove it I really wanted to experiment with these ideas on larger and more detailed maps so I've course simply increased the map size and the number of droplets in simulation and then pressed run I couldn't wait forever so I decided to try the suggestion of converting my erosion code into a computer which would mean that instead of each droplet being simulated one at a time loads of them could be done in parallel on the GPU this of course sounds fantastic in theory but unfortunately I had no idea how to do it after a bit of searching however I came across an article called GPU ray tracing in unity I'm sure they're more direct ways to learn about computers but I was kind of curious so I began reading the first goal was to draw some spheres so I began in c-sharp by saying that a sphere has a position a radius and a color and then generated a bunch of those with random properties and sent that data to a computer the shaders job is then to draw those spheres to a texture so I first had to tell it to cast array out from the camera for each pixel in the texture and then do an intersection test to find the closest sphere so this color can be drawn to that pixel with just these 256 rays that you see here the result is of course extremely blocky so I'll scale the texture to about a million pixels instead to make it a little prettier I then wanted to add shadows the way that this works is say we have a ground plane and a sphere and in some way up here is the light source and in front is the camera now say one of the Rays of the camera hits the ground over here before we just draw the ground color to the pixel let's first check if that point is in shadow to do this we cast a ray from that point towards the light source if it is blocked by an object that is here by the sphere that tells us that we are indeed in shadow of course in reality the Rays come from the light source not the camera but most of them will fly off in other directions and miss the camera so by doing it in Reverse we get to save time because we can just calculate the few rays that do actually hit the camera he has my little scene again this time with shadows I also made this fears bob up and down just for the joy of it the last thing I wanted was reflections so now when a ray hits something it should bounce off and keep bouncing until it reaches the max bounce limit that I defined so the color for this ray should be a combination of the spheres color the spheres color and the sky color okay now I'll add some simple shading in to make this look a little better and then I'm just going to scooch the camera over a little so you can see this better and increase the light bounce limit to 1 and all of a sudden you can now see reflections if I increase the bounce limit too to weaken RC reflections in those reflections at 3 reflections in the reflections of the reflections and so on now the article I followed does go a lot further than this so I think it's really worth checking out if you're interested I'll leave a link in the description but by this point I was feeling ready to tackle the task of converting my erosion code to a computer [Music] well it was a bit of a bumpy ride but once i'd finally verified that i was working it was time to put its speed to the test so I set up a 1500 square map with 600,000 simulation iterations which the old erosion code can crunch in about 43 seconds anxious to see if my work would pay off I press run and just one and a half seconds later the erosion was complete so that means that it's now feasible to experiment with larger maps like this one which of course I'm very happy about I also converted the height map generation to a computer and got a similarly dramatic increase in speed anyway this video is titled compute shaders so I should probably spare a moment to actually talk about the things in the old code I had this loop to sequentially simulate each droplet but in a computer there is this function here which is called the kernel I have the code to simulate a single droplet in there and the shader then runs many of these in parallel the num threads attribute lets me specify how many threads should be executed in a group and when the shader is dispatched from the main thread I can specify how many total groups I need so if I want to simulate a hundred thousand droplets I could have a group size of one and ask for a hundred thousand groups or I could have a group size of a thousand and ask for 100 groups if I'm honest I really don't know a thing about GPUs so I don't know what this actually means but I have found through trial and error that in my case setting the group size to the maximum of a thousand and 24 gave me the best results to pass the original map data to the shader and then get it back afterwards I need to create a read/write buffer of floats in the shader in the c-sharp scrote the syntax for setting the data looks like so and for getting it back like so if you're interested in learning more about this topic a link to all the resources are used in the description but for now that is everything for this coding adventure so until next time Cheers