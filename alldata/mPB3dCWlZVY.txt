this code is horrible it's really bad you can see here it's unsafe here we use volatile and memory accesses as a way of writing values to a variable it's all trash in this video we're going to take this code from my other tutorial on doing embedded rust and make it a little better using the idea of a peripheral access crate that will create ourselves using structures in Rust let's get into it so if it isn't already incredibly obvious this code is barely rust it is rust in syntax and it does compile via the rust compiler but the code is almost entirely unsafe and uses things like write vital and read volatile to put memory at a memory location that's not incredibly Rusty and in this video I want to fix that so to make the code a little more Rusty I'm going to create an interface to the addresses that we have written here in the video I made before this we actually wrote bare metal code that ran on the Raspberry Pi and we used it to turn a gpio pin into an output and then use that PIN to turn an LED on and off we're going to create some interfaces that we can use as a programmer to make our code a little cleaner and more accessible to someone else that has to take that code on the first thing we're going to do is we're going to create a byteless or a sizeless struct and call it gpio and then use the gpio struct to implement some functions that will expose to the user that they can use to do things so the first thing we have to do is turn pin 21 into an output using a function in the gpio interface so we'll create a public function called set output and it'll take a parameter pin that is a type u32 and the whole point of this function returns nothing it just does this functionality to turn a pin into an output the way we do that is we consult the data sheet and we go and find the function selector register if you didn't watch a previous video not a big deal I'll show you real quick when we want to turn a pin on the Raspberry Pi to be an output we have to write a particular value to a register called a function selection register so for example in this video we're turning pin 21 to be an output so to do that we have to set bits three through five equal to 0 0 1 in the function select register two what the math turns into is if you want to set a pin 20 through 29 you use f cell 2. if you want to use 10 through 19 you use fsl1 and if you want to use 0 through 9 use f cell 0. the math here is pin number divided by 10 gets you the register that you want to use so we can actually do that operation to figure out you know programmatically how to access the right register so we'll say that let register equal a match statement on reg where reg is going to be pin over 10. and the match statement will say if it's zero gpio f cell 0 if it's one we'll do gpio F cell one and if it's two we'll do gpio fsl2 and if it's something else that's the default case there we'll say Panic which is a macro and we'll say something has gone terribly wrong Okay cool so by doing this we've actually created a match statement that produces the right address of the right register these constants don't exist yet we'll go up to the top of the screen real quick and fix these so we want to actually create variables that represent the address of the function select register we'll do that here by saying that 0 1 this will be at four this will be at zero and all these addresses in case you weren't aware are coming from the broadcom 2837 data sheet here are the addresses right there and again I talked about in the previous video but instead of 7e it's 3F okay so now that we've created the register that we want to read from now we have to actually go through and read from it so we're going to do is create a variable called value that'll be mutable it's a type i32 and we'll set it equal to zero okay now what we can do is use our unsafe code and essentially steal this function here to read from that register so we'll say that value is equal to read volatile we're going to read from just register as a mute 32 and there's no value there so what we have to do is we have to read the value out to put our data in and then write it back okay so now that we've read the value out of the register that we've selected based off the pin number we then have to actually make sure that our data is able to be put into there the way we're going to do that is we have to what's called mask the value so for example if we wanted to set pin 21 to be an output the value would have to be 0 0 1 but what if we read the value and it had 1 1 0 in there by setting this one here for our output we would actually turn it in to 1 1 1 which is no bueno we don't want that right so we need to actually disable all these first and then eventually turn on our value step one we have to create a mask step two we have to shift the mask to the right location we then have to end in the not of the Mask I'll show you what that means here in a second and then finally we have to set our value so the mask is going to be a value that is just one one because again we're dealing with three bits here we'll make sure that it's set as a u32 I don't want this to also be a u32 okay so now that we have the mask set up we need to shift it to the right location so for example I said that 21 divided by 10 gets you two how do we get to bit 3 from 21 in general what it is is it's the pin number which is 21 mod 10 times 3. so say let pin num equal pin mod 10. and then mask is going to be shifted over by pin num times three so that'll put the ones we've created to the right position and then now we want to actually take the value we've read out from the register and make sure that all of the zeros in that location are cleared the way we'll do that is we'll say that Val is equal to Val and the not of the Mask and then what we can do is finally set our value we will do that as we'll say that Val or equals one left shifted by pin number times three so this will actually put a 1 in bit 3's location awesome so now that we've done that we can use the same math here same code here to right volatile we're going to write value there awesome so let's make sure this code all builds and I didn't make any uh Grievous errors I forgot a semicolon on line 33 let's see what we got here yep boom and then I don't want to read in about I just want to write cannot assign twice to a mutable value oh yeah I need to make this all mutable I would say let mute mask and and mute vowel okay I think we're good okay cool a couple warnings but uh we will make sure we go through and fix those yes it's mad that all of these uh variables are not used but there's no errors so we're good so we can do now actually it's pretty cool but you can actually use that code to replace our first line of unsafe code how cool is that so we can say gpio set output pin 21 boom so at that point after our code gets ran gpio is now set to be an output pin and there's no unsafe code so we can actually take the exact same methodology of you know choose a register read in a value do some math on it and put it back to create our next function which is pretty awesome right so we'll say Pub function set is going to take a pin it'll be i32 actually no it'll be a u32 I don't know why I keep doing that go cool so here we're going to do the same kind of operation to turn our pin on and just like before we have to write a value to a special register to make that operation happen so the way we do that is we will write a bit to the bit location that represents the PIN for output set register zero so just like before in our code we have that commented out we're going to take it and make it a global constant so const gpio we'll call it set zero is equal to the u32 of that address we'll do the same exact thing for Clear zero we'll make it two eight awesome so for the set operation it's the exact same thing the bit position is going to be is equal to the pin that's it and then now we need to get the value so let mute Val and a u32 equal to zero and we're going to read from our register where it's going to always be the gpio set register so now that we have Val we can shift in our bit or equals one left shifted by bit position and then we can just write it back same exact thing and this will turn the pin on and again register is now gpio set pretty awesome and again no return there we're all good to go if you can literally take this exact same functionality call it clear and then set the register to clear zero not full clear just clear let's make sure that our code compiled a couple warnings but no issue there so we can actually do the same thing and first of all we can remove our entire unsafe block that's pretty awesome now our code is safe in air quotes even though it's really not uh but here we can do just like before gpio set 21 and then gpio clear 21. uh use of inline assembly oh that's actually unsafe yeah copy and paste it real quick okay it's mad about the mutability of the value file but that's fine and then one final thing we have to add is this attribute here uh previously I had made a pretty hacky modification using Global assembly to put the start function at the dot text Dot start section in the code we can actually use the link section notation here this will actually put the code at the very beginning of the file so it gets built properly into our firmware and then also one thing that I did is I made a make file the make file here just removes our Target directory and then properly invokes rust C with our Linker script as the Linker script Target so that it produces a clean and sane uh you know file for our uh our project so we'll go to my rusty Pi here we'll make it boom a couple uh you know warnings no issue and then we'll actually object copy that like we did in the previous video to the kernel 7 that image and I'll put that kernel 7 onto my SD card and we'll go from there if you enjoyed this video you should go watch this next video on getting rust to run on the Raspberry Pi Pico or this other video I think you'll also enjoy