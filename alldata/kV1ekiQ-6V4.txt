hey guys welcome back to another low level learning tutorial um in today's tutorial we're going to be doing one of my favorite things when learning a new assembly language which is going to be on the left we're going to write some c some very simple c right and we're going to do some basic things in c like set some variables set some string pointers do some array assignments function calls stuff like that then we're going to compile it on the left and then on the right see how it translates into assembly and use that process to learn the assembly language that it creates so this is the output of binary and there's a lot of code here that for the purposes of this video to learn the assembly we really don't care about all we need to do is type slash for search unless look for main and it's going to be the first second third fourth entry okay so this is the object dump output saying this is the address of the binary where main the function exists and then everything south of that is the assembly language for the function main right so there's a lot that has to go on for a function to happen in assembly we're not going to talk about all of it we're going to talk mainly about what's going on to make these variable declarations happen right so when we're doing this what i like to do is look for things that i call reality anchors right and a reality anchor is something that we have this chaos right this this assembly language that we're not really sure where to even start if you're new to assembly this looks completely foreign to you a reality anchor is a thing in our code that we know has to exist in the assembly for example we set the variable x equal to one three three seven right to me i know that the number one three three seven has to occur in my code it is impossible for it not to otherwise the code wouldn't be doing what i told it to do we're going to look for 1337 to give us kind of a starting point to figure out where we should start to care about the assembly and pretty quickly we see this 13337 pop-up right this is object i'm telling us that hex 539 is decimal one through three seven so then we're gonna walk through this code and figure out where the thing that we've created goes right so okay so we look at it and we see okay it puts our number 539 into w0 and if you've watched my previous arc 64 tutorial you remember that w0 is the lower 32-bit half of x0 which is just a working register in arc64 right it's just a register where you can do math in and then it stores w0 at x29 plus 20. and remember when you see these curly or these hard braces in assembly that's a memory operation right you're saying treat x29 as an address and add 20 to it and then put w0 at that location so what that says to me is that x29 is being treated as some kind of stack pointer right um and you're like okay no the stack pointer is actually a separate variable and that's true in an rx-64 they have two stack variables or stack registers um one is called sp and one is called fp or the frame pointer and that's x29 and what's happening here is it's saying treat the 20th index on the stack as the variable x okay so we've we've figured out now how does arc 64 do decimal variable integer assignments right here it takes the variable it puts it in a working register and then it puts that working register on the stack pretty cool right so we're kind of starting to figure out how the first line of assembly or the first line of c rather translates to assembly awesome so let's move on to our next uh our next assignment so we say that we have this pointer s and this pointer s points to a string called hello world okay let's see how this works so we've already done the storing of one through three seven next we do this little number here right so we move zero into x zero so that means that x zero is zero at this point we add this number here interesting to x zero and store that in x zero and typically if you're not used to this right when you see three operands in um in assembly it means perform the operation between these two and store it in the third right so we're saying this number plus x0 stored in x0 right so that means that at this point because this was set to zero before x0 is equal to this value and then just like up here with our 1337 we're storing x0 onto the 24th index of the stack and you may not you may be confused you may be like where is hello world the string occurring here well when you actually write hard strings like this and see what happens is that string gets put in the data section of the binary at compile time and every reference to it is actually treated as a pointer so this pointer 98a is the pointer into the binary where hello world lives so now at the 24th index on the stack the variable s points to our string right pretty cool so we're we've figured out now how uh pointer assignments work in arc64 it's very similar to integer assignments it's just instead of the hard integer value we get the pointer value instead right working through it so next in c what i've done is i've made a variable called buff it's a character array of four characters and i set the character array equal to a b c and d so if we go back to our process right we need to figure out how does a b c and d appear in the binary well the way that i would look for a in the binary is by looking for its decimal value which is 97 right or hex 61. and you can see pretty quickly here hex 61 appears 97 appears and it's stored onto the stack the exact same way that our 1337 was right we move it into a working register and then we store that working register onto the stack and now we know that the base of our buff buffer is at index 32 on the stack and so we put a at 32 b at 33 c at 34 and d at 35 right so we we just did that entire array assignment in a matter of like eight instructions right that's pretty awesome so now it's gonna get a little more complicated because we're gonna do this loop and what this loop does it's really straightforward in c it's just we have some counter i set it to zero and wall i is less than four printf the hexadecimal value of buff i plus plus right and all that's doing is it's printing hex 61 hex 62 pex 63 and hex 64. right so we need to figure out how does it set up that counter and how does the function call get set up for this loop to occur in the way that we told it to in c um and we can see pretty quickly that after we do our last assignment of buff which is d right we set up this line here and so when you are reading assembly and if a register ever has a zero in the or sorry a z in the name you typically can assume that that is some kind of zero register that will always contain the value zero and in arc 64 wzr is the working zero register which means that it will always contain a zero value so we store the working zero register at x29 at offset 16 okay and that means that variable i which we set to be 0 is at location 16 on the stack so keep that in mind right when we're talking about our counter i we're talking about index 16 on the stack that's where i lives okay so we set its initial value onto the stack then we branch it's not conditional there's no conditions here we always branch so we branch ac4 which is main plus 80. so let's go to ac4 this line we'll scroll down a little bit okay so we load register located at x29 plus 16 so what is that think about it for a second that's our variable i we put i into w0 compare i to 3 interesting and then branch if it's less than or equal to 3 to a9c okay cool so what we've actually just executed is our our while loop here right this is the condition that we've set for it to iterate over so we said while i is less than 4 the assembler did a little bit of optimization for us and instead of i is less than 4 it says i is less than or equal to 3. it's the same logic you know it's just they made it probably a little faster at the machine level um so if it's less than or equal to three which in this case at our first iteration it is we go to a9c which is here so then we load i into w zero again right so w zero is i which is still zero at this point we add 1 to i and store it into w1 and then store that into i's location okay so this is where we do i plus plus right i plus plus is happening right here so then we do sxtw okay another assembly trick when you see an x in an operation typically what that's going to be doing is called sign extending and the reason why we're doing a sign extension here is because we said that i is an integer and we didn't say it was an unsigned integer we said it was a signed integer so what it's doing is it's expanding i which lives in the 32-bit w0 register and it's expanding it by its sign all the way out to x0 and then what do we do we add 1 oh i'm sorry we add 20 hex note that that's important 20 hex to x29 and store that into x1 okay so this is going to be a little bit of a trivia thing i don't like how object dump displayed this but what is hex 20 in decimal hex 20 in decimal is 32 and where does 32 appear in our code 32 is the base of buff remember that that's where a lives right so this right here at this point x1 will contain the base address of buffer right okay stay with me here so x1 is the base address of buffer we add the value of i before it's increment it's we add the value of i before it gets incremented to x1 so it's buff plus i minus 1 at this point into w0 move w0 into w1 so at this point w1 is going to contain whatever character we're on right and then eventually we you know we set up the the format string which is another string pointer in the binary for this string right and we put the um the character into w1 and then we call printf once that's done we do the loop all over again we load i off the stack we compare it to three and if it's less than or equal we go all around again right it's kind of cool how you can take what you know is supposed to happen in c and read it in assembly to figure out how the assembly language works at a very very low level right so then finally once we've done this four times we go to this compare again i is no longer less than or equal to three so we move on we move zero a or 0xa rather into w0 and call put care which is happening here in our last line and then finally we move the return value into w0 which is where in arc64 the value is returned it's an x or w0 you know and they're both the same register um and then eventually this is all some voodoo where we're we're checking the um the stack cookie on the stack to make sure it wasn't corrupted which is protecting from buffer overflows and then we return right so what we've done here is we've taken what we know is supposed to happen in c and figure out how that happens in assembly after the compiler has done its job i hope you've learned something from this if you want to see me do this with other c constructs or other assembly languages drop a comment leave a like subscribe let me know anyway i hope you guys learned something and enjoy the rest of your day have a good night bye