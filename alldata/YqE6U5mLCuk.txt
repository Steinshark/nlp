hi I'm Phillip I work at Bloomberg and I'm here today to talk about what I learned from sockets Bloomberg makes me put this on the first slide they do lots of C++ so please check them out now onto the talk so I'll get straight to the point the thing that I learned from sockets that I want to focus on today is Select it's a really powerful tool the point of this tool is that I'm doing several things all at the same time and I can use select to wait until something about any of those things changes and then based on what it told me I get to decide what to do next now I think this is a really powerful way of thinking about things that I haven't seen used all that much outside of the context of sockets which is the inspiration for a sock and furthermore we can Implement a mechanism like select in P C++ so you get to use it outside of just sockets now when dealing with concurrent stuff mostly asynchronous stuff yeah usually there's waiting involved and there are different ways to wait like one of the common ways that most people encounter first is blocking a thread like I do a thing I my thread is blocked until that operation is done another way is callbacks I provide a function that something runs somewhere else when the thing I ask for is complete well with select we get to decouple The Waiting from the things being done in my summary here A S I ask several questions how can I get the first of several Futures I'm talking about STD future which was introduced in t++ 11 well the sad conclusion what I've come to realize is that we can't at least not with the one in the standard library now if you roll your own future like I do at work or like certain libraries do for instance boost or Folly then maybe you can the reason is this kind of Select it requires cooperation now my next question how can I call wait first of several aables well if you have something that is awaitable and I mean that in the C++ 20 language cortin sense it's a little too late but if you can get in there before the awaitable is sort of ready and then you can do that and the sender receiver proposal has details about how and if you already have senders then we can do that too we can make centers look like sockets in the ways of matter and I'm going to cover all of this if time permits and the point is that to do to do all of this we need some kind of cooperation the mechanism that does the job that you want has to have support for also providing a mechanism to notify you about things and that's what I'm going to show so now the agenda we what learn from sockets we actually cover first the rest of the talk we'll start off with an introduction to sockets this is we this will be very basic very high level and if you've done this before this will be old news for you then we will see how select is used select and pole and eole and KQ all of stuff like that then we will see what a C++ implementation of a similar mechanism might look like and at the end I've left some uh room for so for senders and receivers so let's get into it the introduction to sockets well first we'll look at how sockets are kind of like files how read and write works and how sockets are different from regular files there will be some code I will try to go no faster than is necessary so the basic starting point is a file I open a file I give it a path I tell it I want to create this file if it doesn't exist and or truncate it what I get back is an integer that integer is a file descriptor that I can then use for operations on that file I will use it and when I'm done I close it how can I use a file well I can read and write from it reading is simple I give it a buffer I give the read function for file to scriptor of a buffer and tell it how large a buffer is I'm asking the operating system in this case please read for me up to this many bytes and put them there now the result I get back as an integer if the integer is greater than zero then that's how many bytes were placed in the beginning of a buffer if the integer is exactly equal to zero that's a signal that tells me that I have reached the end of file there's no more stuff otherwise it's usually negative one it indicates some kind of error this is the protocol right this is what posix gives us to deal with files and writing looks very similar except I tell it here are here's the data that I want you to write here's how much data there is please try to write it I get back an integer if it's greater than zero that is how many bytes were written it could be less than the full size maybe it's a full size I don't know if it's equal to zero that means no bytes are written and I have reached the end of file which for a file system might mean it's out of space otherwise it's negative one and some error has happened so see this is a basic protocol for reading and writing in pics now sockets can be used kind of like this the only difference instead of opening a path I can conru a socket I when I do that I tell it what kind of socket it is like inet stands for IP stream basically means TCP maybe I want to use a local socket instead or some other fancy thing then I have to connect the socket which is telling it where it will should where it should communicate to and in this case I give it some IP address in a port then I get to use it as if it where a file so for instance write an HTTP 1.1 request into a socket and that text string now makes its way over a network to a server and I get to read back the response just like a file right but there's a difference these operations this write and this read Are by default blocking which means that my thread is suspended until the right completes or makes progress or something like that and there's a caveat that that doesn't mean what I initially thought it meant because complete in this case means that this string gets put into a buffer so it's kind of like that when you create a circuit the kernel maintains an inmemory buffer for stuff that you intend to write and for stuff that was received that you will read so when you call the right function what it's really doing is it's populating this buffer for example the first part of the gate and at this point the buffer is full if I try to write again or if I try to write some more then my thread will get blocked until such time as there is more space in this buffer in in the meantime in the background the operating system is actually using the network card to send the bites from this buffer out at whatever is the rate of a network interface so this is happening all the time in the background bites are going out and reading is a mirror image that is right now the receive buffer is empty if I try to read at this point my thread will be blocked until such time as there is something in the receive buffer now when the remote server sends me something it gets placed here and then when I read this is the data that my read returns and it's removed from the buffer now it does not have to be this way when I create my socket I can request that it be non-blocking and what that does is it changes the protocol so now when I try to do a read for instance it does not block one the buffer is empty it returns always right away and the protocol changes the return value if it's greater than zero as before that's the number of bytes I got if it's equal to zero that's the end of file or in this case it means that the other side has uh shut down the socket but if the result is negative and Arno which is basically a thread local int happens to be e again or e would block but those are usually the same constant that's a signal that's not really an error it is instead the operating system telling me you tried to do a read but if a buffer is empty so the operation would have blocked if it were in a blocking socket but in this case it's not so I'm telling you right away there is no data please try to read again later and the rights work the same way so we can use this and I skipped ahead a little bit my point is I can try to do a read and if I can't do it right now it will return right away if I try to do it right if it can't do it right now it will return right away so I don't necessarily have to block anymore so I have an option to do something else well what else can I do why not create a second socket but I'm also going to use for something I don't care what so now I have a loop I've got these two sockets where I want to read from both so I try to read from socket one I get some data or maybe not then I try to read from socket 2 and I get some data or maybe not and the thing is I really want to make progress on both sockets but if I just do it this way I'm bouncing back and forth and burning CPU time and maybe I could do a block and read on one of them but while I'm blocked on socket one for instance data arrives in socket 2 I'm not processing that or I might put in as sleep and now I have to kind of uh trade off how much CPU power I want to burn versus how responsive I want to be and that's not not ideal well this is exactly the kind of problem that select solves what I can do is I can create an FD set and when you see that just pretend it's a bit set of some fixed compound time size this FD set is a way of saying what file descriptors am I interested in and by using these macros these are like from posix I'm clearing the set and then setting that I want events for socket and socket 2 then when I call Select that's another function I pass it the FD set and the other n n pointers aren't too important what this means is is hey h well you are they are important the first argument is the set of file descriptors for which I am interested in reading that is tell me if there's data available for reading or if it's been shut down the second one is for writing the third one is for errors and the fourth argument is a timeout so in this case not timeout what this means is put my thread to sleep until such time as any of the file descriptors in the set in indicate what I am interested in in this case data to receive and then once that happens wake me up and let me know which ones they are by modifying the FD set it's a kind of mutable inout argument but if at the time I call this function there is already data to read it returns immediately so now what I can do is I can call Select then when it returns I can see which file descriptor caused it to return so if it's socket then I can read from socket and at this point I can be really confident that that read will give me data or if it's socket two I can do the same and that's really powerful I can wait for either one and then decide what I want to do next and at this point I'd like to make a little aside and remark on how powerful this mechanism is Select and things like it let us do a separation so I can I can read and write or shut down or close and those are all operations that have visible side effects but they all return immediately maybe they do what they want maybe they do nothing but they let me know and they return immediately on the other hand select is blocking it means I want to wait for whatever but select itself does not have side effects like I can interrupt a select that all it means is just I'm no longer watching it has absolutely no effect on the operations going on in the background and that's really the trick that's a big separation that I find extremely useful now back to the kind of intro to sockets select has a problem which is that bit set that has a compile time limited size and I've seen it be like a thousand or something which means if your program deal of more than that number of sockets too bad well there's a solution to this problem which is a function called pole instead of dealing with a bit set of fixed size it deals with an array of runtime size I have an array of pole FD objects and each one of those pole FD objects just yeah indicates a file descriptor and a set of events in which I interested and it kind of solves two problems one is the number and the other is the mutability with select the FD set was modified by the call so I had to reconstructed each time I want to go select poll FD has separate fields for input and output events are saying events are me saying I am interested in these events it's a big mask I can or a bunch of those on there like pole in pole out pole air which corresponds to the three sets from select our events is the out argument when PA returns it sets that field on the file descriptors which had events that I'm interested in so here it's similar I pass it the array I tell it how many elements are in the array and minus one is a timeout which means no timeout this function does the same thing blocks my thread until any of the file descriptors in the array indicate the events I care about or if the events are already there in this case if there is already data to read it returns immediately and sets the r events appropriately then I can react by observing the array and check checking which R vents are set and by the way feel free to interrupt at any time if you want to ask questions maybe come to the front and I have slide numbers at the bottom so that's poll it's cool now I can have as many file descriptors as I like but there is one remaining problem which is when I'm dealing with a large number of file descriptors I have to pass in the entire array every time now it is true that I don't have to reconstruct the array from scratch so that's good but the kernel and like Paul is a system call the kernel has to scan over the entire array every time and when it's done I have to scan over the entire array every time to determine what happened which as the number of f descriptors grows that becomes a problem well this problem has a solution too which is called EO and the thing with EO the key is instead of maintaining an array that I essentially have to pass in and Traverse every time I want to wait instead of doing that the kernel maintains a data structure for me and that data structure is like EO so eepo create creates an object and it returns me a file descriptor that I can use to refer to that object and that object is basically an inmemory map of file descriptors to events that I care about I I populate this map by calling eepo CT SC I tell it what operation I want to do to do which will be add remove or modify in this case I'm adding and I tell it what sockets I care about and what events I care about for each socket so for sock one I want to read and sock to I want to write sorry read again but you can mix and match how you like and the big big benefit is I don't have to do this every time I do this once at the start and now the the kernel remembers what I'm interested in then I get to call EO weight and this thing can produce an arbitrary number of events I pass in an array I tell it a size in this case I just want the next one event and it will tell me which of the file descriptors it was so if it's sock I can read from sock if it's sock 2 I can read from sock two and the trick is I get to call we wait again and again and again I don't have to repeat which file descriptors I care about and this way it becomes super efficient to deal with lots of file descriptors because the only ones I have to think about are the ones that have activity if there are 10 million other file descriptors that are idle they don't affect me at all for the most part there might be caveats but we get to pretend as if that's the case so that's a trick and I find that lots of Asing programming boil go down to stuff like this I do some initial setup which is non-blocking and then I tell which events I care about I wait for those events which is the single weight point and then after the wait I react to what happened and repeat and then clean up it's like this if we structure a code like this and what's a nice thing is the parts before with weight and the parts after of weight are straight line Cod like I love straight line code it's easy to reason about it's easy to test so now the only part that involves any async any waiting any blocking is the select or poll or eole just that one I think that's nice so let me give you an example of a real life use case where something like this comes in real Handy suppose I'm a browser and I want to connect to some website and I'm using microsoft.com just as a as an example which will the reasons for which will become clear in a few dozen slides so I want to connect to microsoft.com but that's a domain name we don't connect to names we connect to addresses so I have to name ask a domain name server please resolve this name for me into addresses and it responds back hey here's an address I can connect to that address and now I do with the TCP handshake sinac a I'm good I'm connected I can talk to microsoft.com but this is this is an idealized version that I was taught in University in real life it doesn't happen quite like this what happens instead is I ask with the name name domain name server where is microsoft.com and it responds me with a list of addresses and I've got to connect to uh one of these and I have to decide how to do that and here we have well we have some flexibility there are lots of ways to do this that are not great for instance I could try connecting to these addresses in turn try connecting to the first one if it fails then try the second one that's not great because timeouts for TCP are quite long and if this is a web browser and the human is to really glare thumbs waiting for the connection to happen while the connecting to the second address would have happened almost instantly that's not great I can try connecting to all of them in parallel but if I'm going to use the first connection to succeed and throw out the rest then that's not great either I'm connecting n minus one connections that I will throw away well there is a solution to this problem which is called the happy eyeballs algorithm and and to sum it up really quick the idea is I try connecting to n address but then I wait for some small amount of time and if I don't have a connection ready in that time I try connect to the next one and then the next one and the next one and the idea is I'm going to fairly quickly find a working IP address keeping the user happy but I won't start too many connections that are going to be thrown away keeping the network Su adment happy so like that I start try the first one when I wait when I try a second one and that one works right away so I've got a connection to the second IP address and I bail out the first one now we can implement this function using select or poll or EO and this I'm just giving you a flavor of how it can be used I want to connect to one of these addresses in the span how can I do that well I create an EO object for each address in this span I try to connect to it and then I wait and presumably in all likelihood one of us is going to work and I'm just going to return but if none of us work I will wait until they all fail it's kind of like that so how do I connect I create a socket I ask it to be non-blocking now when I connect to a socket that is non-blocking that connect call always returns immediately and I think unless it's for a Unix domain socket it always has the error code e in progress which means I'm going to connect it's not done yet but it will be and the way that this asynchronous connect tells us that it has worked is by the socket becoming writable so that's what I do I added to the eole object and I tell it please let me know if it's writeable eole out that should be it's or E Hub which means it's disconnected let me know if it's either of those things happened then I wait and in this case I'm using the time out of the eole to wait some amount of time this this is doesn't really matter so if I get a connection within 250 milliseconds that's what I'm going to use and if it fails within 250 milliseconds I'll move on to the next one and if nothing happens in 250 milliseconds then I will go to the next iteration of a loop and try another connection and another and so on and this is me responding to what EO said has happened so if it's eull out I connected otherwise it failed finally if I manage to get through all the connections if I manage to start them all without establishing any I have to wait and in this case there's not not much Choice other than to well weigh them all out and this is just me consolidating some stuff into some lambdas to make for code look like this and I let's see will this work yes so I actually wrote this code and if I one yeah so this is this is the same code that I just went through I won't bore you with the details but the main Loop is right here yeah so for each socket I create connect add to the EO set when I wait wait can timely tell me either you have a socket that is connected or you don't if I do then I return otherwise continue on to the next iteration then then wait until all the connections have been established and then that's it so I can actually compile this there we go and I can run it so build connect one microsoft.com HPS so see it established the connection to that IP address and really fast and if I run it a bunch of times it'll keep doing that now this example is pretty boring because of how quickly it happens but if I artificially delay my traffics microsoft.com uh uh let's see like that then it's going to take a little while longer because it's fake and the trick is the important part to OB service it's most times it will give me a different IP address because the algorithm is trying a bunch of them and just picking the first one to work see that's working so this is great this is a basic connect function now it has a problem which is what if in the middle of yes what if in the middle of me trying to establish this connection the user of this hypothetical browser changes their mind we close the tab we are no longer interested in connecting to microsoft.com well as written up till now there's no way to communicate that fact hypothetically this is a separate thread that's off running establishing this connection and in normal C++ I can't just cancel a thread well we can use what we know about sockets to solve this problem which is instead of returning the result we can use another socket and put the result there now with Unix domain sockets there's this nice capability which allows me to kind of send a socket over a socket so I have a connection that I've established and I can sort of send it over a pipe maybe to a different process maybe to my own process it doesn't matter just to transfer ownership so I can use that and make the details of how exactly to do us are a little bit esoteric but suffice it to say that it's possible and you know there are examples so this function does that and it's almost the same as the previous one but for a minor difference in addition to being interested in all the outgoing connections that I am establishing I am also interested in the out socket I'm interested in case it gets shut before I am able to send it my result so now what happens um so the loop is the same for all the incom for all the connections create a socket try to connect put it in the pul head and wait but when I wait I'm waiting for one of several things which is maybe it's a connection that got established maybe it's a connection that failed or maybe it's a it's my output being shut that's what I'm checking for here and the bull in this case that's telling the caller which is immediately enclosing function should I return or not so if the socket that caused this event is out then my output was shut before I managed to produce a result nobody cares anymore about whether or not I can connect I should return doesn't matter I'm done otherwise the socket is one of my connections that I'm trying to establish if it is a successfully established connection when I put that socket in the output and I've got a good connection I'm done return true otherwise one of the connections that I was trying to establish has failed I need to remove it from from the poll set cuz I'm done and continue the loop and the surrounding function changes just slightly but only slightly because now instead of returning the result the result gets put in the output and this just has to decide whether or not to bail out early so it's it's the same as before and I wrote this code too connect to there we go so see exactly as written I have an output socket first I register my interest in the socket being shut and then the rest of the code is actually exactly the same so I can run it well let me show you a main Loop for each incoming connection create a socket connect register interest in the vent survette socket and vent call weight weight gives me an event I react to the event that tells me either you're done you're not done and you're done either because you established the connection or the socket where the output goes was shut and it's the same so now I can do that I can build and that's compiled and I can run it and that's going to establish a connection just the same as the other one but there's a big difference what I can do is interrupt the process I set I sent it in interrupt contrl C and in the main thread I set up an interrupt Handler and in that Handler I shut the socket that receives the result and once that happens the thread that is establishing the connection sees that and it Returns the main thread joins that one and I can bail out of this whole thing immediately and cleanly and this is a really cool thing by doing things this way we get automatic and clean cancellations and hypothetically if I wanted to do a timeout well on Linux we have this thing called timer FD which is a file descriptor whose only purpose is to produce events after a certain amount of time has passed I wanted to timeouts great I create a timer FD I add it to my poll set I wait and if the event that I receive says that the timer has fired that's a timeout I get to respond to that and by doing things this way I get to add timeout to any async operation the operation itself doesn't have have to have any concept of timeouts I can just add it separately very nice so now this is a trick what I have shown you so far was using the kernel right actual system calls actual file descriptors um operating system interference but the ideas behind that don't don't need any operating system assistance and what I mean is we can write a class we could write a several classes that implent these ideas totally separate from an operating system I call these things handles we can have a read handle or a write handle they can have arbitrary types and they can Implement operations to cooperate operate with something like EO and in this case I call it for select object the select object is like what the cardal maintains in memory for EO and this is really powerful ultimately what this let me lets me do is to think about arbitrary operations in the same way that we think about sockets I wanted to do a random example GPU comput and I want to wait for it or possibly something else well if I wrap it up in this abstraction I can do that or if I want to wait for either something or a socket I can wrap up an actual operating system socket in this abstraction and then wait for either of those two things in the same in the same select this is a that's kind of really cool in my opinion so the next uh part of the stock is showing you what it takes to get something like this working I'm not saying it should be exactly like this but it could be like this and in this case imagine that those things exist imagine that a right handle behaves like a socket in that I can wait on it and do non-blocking operations on it and imagine that I have the select object which I can do what EO does which means I can insert stuff I can modify which is change the set of events I care about I can have timers which work like handles and then I can use that to implement a select a connect function kind of so what I can do is this is the same Lambda that you've seen before which is given some event that select tells me has happened what should I do and this communicates exactly the same stuff as before but more C++ for example if the handle is the timer then I've timed out I should move on to the next connection if I have one if a handle is the output it means nobody cares about me establishing this connection I should return I should bail out return TR tells a caller to just bail out otherwise it's a connection and if the select object tells you that this connection has been established by telling that the event is ready for output I write that connection to the output and bail out otherwise I forget about it and continue and it's like that this is the same function as before B written in C++ instead of posic and by virtue of this being a class that we write we have control over what the waiting means so far I've been Imaging this in the context of threads you spawn a thread that does with connect attempt doesn't have to be that with a very minor change you can make this thing be a a co- routine coight select or a cender because the only part that's different is the waiting part everything around that it's just simple straight line nonblocking code I think that's pretty cool so let's talk about pipes what we're going to do is we're going to implement something like a pipe purely in user space pure C++ and see what it takes to make that be selectable so some analogies a pipe in Unix a pipe is two file descriptors that are connected to each other I send bites into one they come out of the other I create it by calling this function which populates the array with to file Des scripters under a hood you can think of a pipe as just two handles to the same array writing puts stuff in Reading takes stuff out well we can make that in C++ we can imagine that a re handle and a right handle to the same pipe refer to the same underlying shared State and that shared state is a class which has a buffer in this case a buffer of one Char because I want to keep it simple mutex for threat safety and other stuff the important bit is the number of readers and the number of writers because well you can duplicate file descriptors and under the hood the operating system releases resources when the last file Des scriptor is closed we can do the same thing here but to do that we need a kind of reference counting and then remember at the start there was a protocol for reading and writing positive number is a number of bytes zero means and the file minus one means a an error or it would have blocked well in C++ we like type safety and we can use a variant to represent that so for read I have success with one Char in it for write well writes don't return you any data we just say yep I wrote a Char and the file is just a distinct tag type and as is wood block so I have a variant of these three things and the read and the write just return this variant and this is just to make the syntax nice it's just sugar so yeah success holds a value or not and the other two who are empty structs and result is a variant of these so when I tried to write using a right handle the first time I try to write it returns me success if I then try to write again it tells me that would have blocked so I didn't write the thing you asked me to write now for reading it's the same when I try to read it takes a character out and returns it if I try to read again the buffer is empty that returns W block there's a reference counting scheme here so I kind of keep track of a number of readers and a number of writers and the reason I do that is so that when for example the last writer goes away the readers know about it and they know that there's nothing more to read the next read attempt produces end of file similarly when all the readers go away the next right produces end the file so uh and this is just a dump function to say I want to write I want to create a pipeline that just capitalizes all the characters passing through it it's a function that runs hypothetically in its own thread it has a read handle and a right handle it reads the next character if it's the end the file we're done if it would block try again burn some CPU finally I get a letter I capitalize that letter then I try to write it if the write is a success great if it's in the file I'm done otherwise burn some CPU waiting to write that character we're going to come back to see how this function looks different with select available so what's the read and right handle really there are struct of a shared pointer inside and the main function are read and right there's going to be some more stuff in there for reference counting and so on we shall get to the shared state is as I've shown it has a the buffer the bully that says has it been shun yet new Tex for threat safety and reference counting now in the right handle as in the read handle I have to follow the rule of six to make it so that the reference counts are correct but otherwise it's just a basic type how do I read well for now it's simple if there is something in the buffer I take it out and return it if if the shared state has been shut and defile otherwise it would block right is a mere image of that and shut as simple it just starts for bullan now that just got us a simple non-blocking busy waiting approach but for for select we need cooperation this is why you can't just bolt select on top of something it needs cooperation from the thing the thing that you're doing needs to support notifying under about events and in this case one caller one thread so to speak waits for many handles and each handle read handle or right handle really the underlying State needs to publish events to many callers potentially that's a many to many relationship it looks kind of like that now I like to represent that using a single class a select the select class holds all those relationships and its responsibilities look kind of like this for any shared State the select object tells that shared state which events it is interested in it subscribes and unsubscribes and the shared State notifies the select objects subscribe to it what events have happened now each caller inserts and erases objects into the select it modifies which events it cares about for each object and it waits until those events have happened select when it is notified about events has to wake the caller so I'll kind of skip to the point which is that the proper way to do this I think is to have a single data structure in the select object and to give each shared State intrusive borrows so to speak of of elements in that data structure I call this s a link each link represents one of the many to many relationship and this is an old CBP cont talk which implements the same idea except from a slightly different direction so the job of Select is to subscribe all links to their Corr oning shared State and the job of a shared state is to notify all subscribed Links of their corresponding events how can we do this well H the shared state contains an intrusive doubly link list of events I love W link list an awesome data structure the point is these are Pointers the shared state does not own the links it just refers to them for the purpose of notification it is the responsibility of each select object to insert and erase things from these link lists as appropriate when something subscribes it splices a link into this link list and there can be any number of these V belong to different select objects Each of which potentially has other links for other shared States now when I do a read for example in addition to taking the character out of the buffer I now need to also notify any writers that they can now write I do this using a notify object which does it in R A II so extract means hey take all the interested parties all the interested links from this link list put them into that one one of this function onwi with the structor iterates through a list and pokes anybody who cared to listen Veri does the same thing but but it notifies readers instead of writers and the shut now has to not has to Mo notify everybody that it's been shut that's kind of the end so to speak now subscribe gets a little bit complicated because the trick is if the thing that I am waiting for has already happened for example if I want to write and there space or if I want to read and there's data or if I want to either one it's already been shut then this thing doesn't actually insert anything into a link list instead it it tells a caller right away that you don't need to wait the event you want is already there so it returns falls in the case of the event you want isn't there you do have to wait until it returns true unsubscribe is also a little bit weird because we have to be thread safe the trick is while I'm trying to unsubscribe if there is a different thread which is actually in the process of notifying me I have to wait until that thread is done but if not then I can just remove my link from the double Link Link list and it's all good so that's why this this whole um thing is a bit weird so actually with those two things with a subscribe and unsubscribe we have select that's it we're done and we can treat it as if we treat EOL we create it so we create this repository of relationships between us and different handles we insert handles into it saying I will be interested in events for this handle we modify which events we care about then we wait and that's a blocking piece the result tells us which handle or event happened and once we're done we can erase it so that's a yeah that's a select object now a bit of demonstration select has do I have time I do select has in addition to a set of links it has a bunch of other intrusive link lists when I first insert a new handle into select I create a link for R handle and initially it just exists in the owning set and it is not spliced into any link lists then when I express interest in events I set those events on the link and I splice it into the two subscribe list that is also an intrus of doubly link lists that is used for lazy subscription because I don't subscribe right away I subscribe at the next weit the point being is if a thing I care about is already happening when the weight doesn't actually block it returns immediately so doing it this way makes sense when I eventually call weight it iterates over the two subscribe list and for each link in that list it calls subscribe on the corresponding shared state but may be returns true or false and in this case it returns whichever one means you need to wait at this point in time the link is in the shared States intrusive link list and the colar of weight has been blocked now another thread comes along and writes something to the shared state that right operation first moves the link into the intrusive link list belonging to the notify object which on D struction erases through its list and pokes all the links and that poking is what unblocks the caller of weight so first we move the link to the notified list then we unblock it and that recaller Returns the reason this is important is what if I have multiple things that I'm waiting for maybe I've I've got three Handles in here that I'm waiting for the first one have had an event it woke me up in the meantime the others had events too and if that happens then those operations will put those links into the notified link list and then the next time I call wait I will look at that list first so if something happened from in between me waiting if something happened between the last time I waited and the next time I waited when the next call to wait will actually to return immediately because the event has already happened and but if I call on return from weight I consume this event and when I do that I put it back in the two subscribe list and this is clever too because we always append things at the end extract things from the front and by doing it this way I get automatic fairness round robin I am guaranteed to observe an event from all handles to which I have subscribed that have activity without starvation finally when I decide that I'm done this operation extracts the link from all link lists and finally I I'm safe to erase it so insert is easy because nothing else references with link I just create it in the set select is fun so first I check for notified list which is saying has anything that I'm interested in happened since the last time I called wait if there is that that's the output otherwise am I is there stuff to which I should subscribe for each such thing try to do a subscription and if that tells me the event is already there I don't wait I don't block I immediately return it otherwise I wait and this here this bit I can't select here this is the only place in the entire class that blocks a thread that's it and by changing this one spot where I do cond bar. weight I get to control my wakening mechanism it can maybe be a co- routine or a cender I have control by virtue of having this class be separate and erase it's a bit weird I have to watch out for another thread concurrently notifying this link but as long as I get that right it's fine same for mod modify and this is the utility function that kind of is called from both this is the part that moves interested parties from the links in each handle to the notify object and in the destruction the notify object pokes everybody who cares and finally remember this function from before this is the one that would burn the CPU well now I can use a select object so wait for either one of the handles so now I wait for a handle and if a handle is the output well that can only mean that no my output a shut I'm done if the handle is the input I read the next input capitalize the character change what I'm interested in when I have something to write I no longer care about the input handle but I do care about writing to the output handle so I wait and if the output handle is shut I be out otherwise I can write a character to it so see this version of function doesn't burn any CPU at all and if the output handle is shut it returns immediately and we can extend this these read handles and right handles were for chars they don't have to be they can be templatized on whatever you want or they can work on spans of chars and in this case a read handle takes a span of mutable Char and Returns on success returns how many chars were populated which is the same as a posic interface for reading and the right handle takes a span of immutable chars and conerns how many of those were written which is the same as a posic interface for writing this way we can kind of wrap up actual sockets and treat them the same as are pure inmemory abstractions like I have a project at work that does literally this it's been awesome just like simple and reactive and correct yeah it seems that I don't actually have time to go over senders so if you have questions I'd like to take them now on that note there are other talks about centas which are much better in mind like this one or this one um and if you're interested in then I can go over that afterwards thank you [Applause] [Applause] all it seems I have about um yeah yeah come on up hi uh yeah one cool thing about EO is that it's uh it's also a file descriptor and so you can compose them can you do something like that with the with this uh select so can you compose selects by adding some code to do that Absolutely I'll tell you simp the only reason I haven't done that is because at work there hasn't been a need yet but all the building blocks are there yes an EO file descript is itself selectable so I can insert it into a different file descriptor and it tells me that if it becomes readable then that EO object has events that you can query and you can do entire trees just don't do Cycles but yeah it's super cool and this class can do the same thing okay thanks do I have 30 seconds I have 30 seconds I'm going to get go really quick to what the essence of this Center receiver stuff is um so basically suppose I have senders which if you watch the other talks from before you'll find out know what they are they can be wrapped up in the substraction the trick is how do I map between the operations from the handle to the operations on the center itself well I can do that when the center is complete it set it sets it calls set value which should produce a right event to the handle which I can then report to any interested parties and they can then consume that and if I try to read before that happens that's just a failed non-blocking read there's no value yet if the caller decides to close their handle before the thing has been completed that's just a a set stopped that's like a cancellation we can tell the center you've been canceled handle that how you wish similarly if a center decides to cancel itself we can tell the caller that hey you've got shut event that and there's no data to read you you would see an defile in that case and the trick is instead of having a condition variable here in the select object we store a pointer to some abstract operation state which is specialized for what the actual Center is so that's doable and similarly like you have notified changes just a tiny bit but it's all very analogous and if we have that we can just as easily say hey a CO routin continuation is a center so you can now call weight select that's all I'm exactly on time thank [Applause] you