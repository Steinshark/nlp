you want modules not micro services for those that are watching this on YouTube if you're wondering why chats like this well hey guess what some bad things happened and OBS doesn't work right now dissecting why everybody keeps talking about microservices okay here we go tldr architecture is hard sometimes people keep offering up some new idea that quickly becomes the mainstream way of doing it without any context or nuance and the industry desperate let's see desperate to find ways to improve their architecture snaps it up without hesitation microservices was the latest in the trend and it's time we dissect the idea and got the real root of what's going on okay okay I'm I'm excited at the heart of microservices we're told we'll find lots of good things dude okay if you're gonna do this at least just put the trademark symbol it's so much better when you do that scalability code can be broken into smaller parts that can be developed tested and deployed uh and updated independently yes in some sense this is very true some things become less true as time goes on Focus developer focuses on solving business problems and business this logic absolutely business problems business logic it's not like you have to do Discovery or health checks or an entire Canary process or understanding when parts of your back end are failing or just this distributed craziness that does take place at some point in life it you don't have to worry about any of that back-end data must always be available for a wide range of devices okay Simplicity provides a simplified development on a large-scale Enterprise applications okay responsiveness enables distributed applications to scale uh is response to changing uh transaction loads are supposed to be in response yes okay reliability ensures no single point of failure by providing replicated server groups that can continue when something breaks restoring the running application to good condition after failure occurs okay I mean these are all all of this right right like if I could just focus on writing business logic right like doing the thing I want to do it would be great because you know what ninety percent of my job is is not doing my job ninety percent of my job is just like just solving the most asinine stuff ever that's all it is somebody comes up with the clever new data format guess who's figuring that out hey somebody reported some things in microseconds nanoseconds UTC date ends and of course milliseconds and then even some of them seconds well guess whose job it is to figure out which of the many Rainbow time flavors that you've just provided me in normalizing into an actual time guess whose job that is guess his job that is you know how annoying it is to try to figure out what time you're in you know how annoying that is oh you provided me seconds Mike um milliseconds microseconds uh nanoseconds or UTC dated dude I actually have a function that goes through all of this and tries to guess which one you are it is absurd Prime got some trauma there I got some trauma boys dude and the worst part this is my day didn't I kid you not my date int looks like this my my date in Checker is literally uh like uh function is UTC uh date right let's just pretend this is it uh oh whoa whoa how did I get here how did I get to the change me Daddy uh let's go like this uh date which is just a number right I literally go like this uh date is greater than or equal to uh 2003 and and uh date is less than uh or less than or equal to three thousand and just be like you know future me future me is gonna have to figure this  out when things go wrong you know what I mean there we go right future B is gonna have to figure out when something's gone wrong right like that's me because you know what I'm supposed because luckily I'm only working on things that have date Samson uh in uh 2023 and later so it's just like whatever future me right and then some of my I realized that some of my places I kid you not had this uh it had 20 uh 20 years uh I literally left this comment at some point that said uh future me will uh be mad but present me is very happy yeah like I left that comment for myself just so I will know that I already know this is a hack right like I already know it's a hack we all know it's a hack ain't no ain't no way we're thinking that we're we're making some amazing tool here right like you got to know the bounds of your tool my tools should not exist for another year right if it still exists within a year I think I honestly think Netflix done right it's a hack from the start you got to know your stuff Tech Society it just hurts it always hurts all right these all sound relatively familiar I'm not imagine but the fun part about those six quotes is that the two were taken from microservices literature blog posts papers Etc wait what uh and two from 20 years ago ejb literature I don't know what ejb is I feel like I should and two from Oracle tuxedo which is 40 plus years techno uh ago technology Can you spot uh which went to which I don't know uh we have a tendency in the industry to reuse our hype points over and over again those who cannot remember the past are condemned to repeat it George life of Reason 1905. uh ejb equals trash Oh okay that's trash Dev I didn't realize trash Dev was that with respect to the micro Services hype one company's blog post offers 10 reasons uh to charge into microservices I bet you this might be Netflix laughs how much do you want to bet this might actually be Netflix hold on I gotta do this I I gotta do this hold on there we go this just makes life so much easier because I can go like this all right one they promote Big Data best practices microservices Naturally Fit within a data pipeline oriented architecture which aligns with the way Big Data should be collected ingested processed and delivered each step in the data pipeline handles one small task in the form of a micro service they are relative number two they are relatively easy to build and maintain in some sense I do think this point is correct is that they are easy to build or maintain if what you're building is a really small server right simple servers are obviously simple to maintain it's a very isolated look to think that though that's the problem uh their single purpose design means oh man okay I do I mean I want to look at those things I like this all right anyways they are relatively easy to build and maintain their single purpose design means that oh yeah we already oh wait no I didn't read that there's they're relatively easy to build and maintain their single purpose design means they can be built and maintained by smaller teams each team can focus cross-functional while also specialized in the subset of microservice solutions like all this sounds great right they enable higher quality code modularizing an overall solution into discrete components helps application development teams focus on one small part at a time this simplifies the overall coding and testing process sure they simplify as cross team coordination this one I'm I'm more in doubt of though I do agree but I'm in doubt what I mean by that is that right away without even looking at this there always comes this problem where you have a change right you have a change in API what do you do well you kind of have to maintain an old endpoint and you have to have the new endpoint and then you have to go to all the other teams and then make sure that they do the right thing and then if you're also including mobile applications mobile applications can also end up having these like stale versions in which now you have to support this old path for the life of your application until you force like an upgrade or an end of life like it's not as simple as people make it because it always ends up being really really hard right people there's just this concept that things are just super simple and they're not microservices are a great idea if you have a stable full of high quality developers and have written a version one previously that can concretely identifies your real requirements and weaknesses and the only way it ever works is if you can replace one component at a time this is actually a really great take it's this I mean for me it's the same argument why you'd use rust which is until you know your landscape truly uh this is why I've come around to go I finally have come around to go I know I know shocker but until you know your landscape use something that's really good for it you have the best titles dude I don't have the best titles I take my titles from this the Gopher wins the Gopher wins I know shut up all right they enable real-time process oh Paul let me read this one unlike traditional Services oriented architecture uh cool uh which typically involves heavyweight inter-process communication protocols by the way if you're using inter-process communication protocols you're almost always incorrect I think that moving your database off off box awesome moving your message queue off box awesome right like there's plenty of things that are awesome to do right don't kill the Gophers I'm not going to microservices use event streaming technologies that make it they'll see I don't even believe this right you can still do both these things at the same time anyways keep on going they enable real-time processing at the core of microservices Architecture is a publish or a pub sub uh framework enabling data process in real time to deliver immediate output and insights this part is also one of those really hard things that people talk about a lot which is it's true there's a lot of benefits to microservices but to trace a singular request through a large mature system is really hard right to understand exactly what happened is non-trivial once you go back I mean like if you have three services yeah you can just like you can do it you know you can just kind of grip your way through logs and figure it out you can have like an X ID some sort of request ID that passes through all the headers you can totally do that but it's not necessarily that simple observability is a key observability is a key and it becomes excessively hard when you have 800 Services called for a single request right like there are requests like that at Netflix that literally call hundreds of services or a series of requests right you you call you get some sort of data comes to the client the client makes some decisions based on say A B test allocation all this stuff so you have this like n plus one problem of requesting that can take place and it's just like super hard there's a lot of stuff that's really hard they facilitate rapid growth microservices they do facilitate rapid growth truer statements have never been said microservices enable code and data reuse uh the modular architecture make it easier to deploy more data-driven use cases and solutions for added business value um they enable more outputs data sets are often presented in different ways to different audiences microservices simplify or simply yeah simplify the way data can be extracted for various users easier to access updates in the application lifecycle Advanced analytic environments including those for machine learning need ways to access existing computation models against newly created models a b and multivariant testing in microservice architecture enable users to validate their updated models this was really complicated way to say canaries are great they enable scale scalability they actually I'm not sure if they do truly do enable scale as much as they enable I mean they scale the amount of internal requests you do make I'm not sure if it's true that they enable scale right I'm not convinced on this one scalability is about uh is about more than the ability to handle more volume it's about the effort involved microservices make it easier to identify scaling bottlenecks and then resolve those bottlenecks at a per microservice level that's the problem is you also introduce a scaling issue of making all the requests right you you introduce a whole nother level and those can also be difficult many popular tools are available a variety of Technologies in the Big Data world including in the open source Community work well in microservice architectures uh Apache Hadoop uh Apache spark no squeal databases and many uh streaming analytics tools can be used in microservices we're also proud partnering with the pivotal in this area so one thing that they're not talking about here just even at this one is that say you have three services say you had a singular function or a set of just you know a library that did something that went grabbed your data and made three separate calls and merged it all together and gave it to you now it's a microservice so now you make three different HTTP requests to three different servers and it's all micro serviced out that is going to be a bottleneck of whichever one is slowest now here comes the worst part is if you ever have to break it up you may be able to do something clever where one thing is a monolith and is able to take the state of all this and make it into a singular request whereas there's times you can't do that when you don't have a monolith very easy example say you want ratings ratings on a movie and Netflix is both what the user what we think the user will like plus whether they've liked it or stuff like that right machine learning so now you have this idea where you have to go and you have to go get videos then you have to come back and then you have to go and get ratings right right whereas if you're in more of a monolith world you can go get video ratings Right video and rating same time but now since it's a very micro service architect like new bottlenecks do show up and it's this idea that it's freezy it's not necessarily for freezing you know it's not necessarily for freezing uh all in all that being said the idea of a really well designed go monolith app deployed as a striped binary a stripped binary on a Docker scratch image being an app Service uh Overlord is kind of sexy and disturbing but totally non-furry way reasonable I mean I do like microservices don't get me wrong I like the idea I think there's a lot of great things about it uh really if you think about it your editor has become microservices LSPs are a version of microservices was Jonathan Blow correct on saying LSPs are a sign of the times that we have become bad programmers he actually might be right maybe it should have just been a library maybe it should have just been this way would it have been easier I don't know if the updating and integration cycle would have been as easy but if we have a well-defined protocol it might have been better right I'm not saying which one's better I I just don't know right I don't know many popular tools are available a variety of Technologies in the Big World okay yeah we already read this let's take a second uh and examine each of those by this time in light of prior art uh they promote uh Big Data best practices pipe uh pipes and filter architectures have been a part of software since the 70s when Unix has promoted several ideas make each program do one thing well love this by the way to do a new job build a fresh rather than a complicated old programs by adding features I love this by the way this is like my favorite of all of the unixisms this is it this is like my favorite thing that ever this has been on my mind constantly driven into it because all I do is think about this when I make CLI tools these days which is like how do you not how do you avoid the like how do you avoid FFM peg in some sense ffmpeg is its own problem I understand why it exists it's extremely complicated same thing with like gstreamer right very very complicated yeah it's by its very nature it has to be complicated but if you don't have to be fempeg or G streamer how do you break your program into like three programs right uh expect the output of every program to become the input of another as yet unknown program don't clutter outputs with extraneous information avoid string uh stringently columnar or binary input uh formats don't insist on interactive input I love I love all these things what's the deal with of a vampag uh they are relatively easy to build and maintain see the Unix philosophy above yep uh they enable higher quality code if focus on one small part at a time helps improve quality then see the Linux velocity above they simplify cross team coordination this one is interesting it suggests that service oriented architecture typically involved heavy weight inter-process communication protocols like jeson over HTTP uh it'd be more like atsu message pack over IPC or is that taken to mean that all SOA requires soap uh will diesel XML schema and the full collection of WS Dash specifications ironically nothing about microservices in any way prevents it from using any of those heavyweight protocols and some micro services are even suggesting the use of grpc a binary protocol that bears closer resemblance to iiop from Cabra corba which is a heavyweight protocol a predecessor to soap wsdl XML schema and the full collection of wws specifications I think one thing he's missing is I think it also is uh I think it's just standard like message like because you can communicate just you know via Linux uh just like a little little socket also so but I I see what he's mean but it's mostly going to be HTTP let's just be real it's HTTP pipes are just real-time linear micro service orchestration it really is it really it truly is they enable real-time processing real-time processing has actually been a thing for quite a while and while many such systems use a pub sub or event bus model to do it it hardly requires microservices to do it absolutely absolutely uh but you can I mean I think for me real-time event processing is a great one to kind of quote unquote microservice out or have its own thing that you listen to and use uh that seems like a great thing but you can add events like you can still have a monolith architecture and still have that at the same time right uh they facilitate rapid growth by the way if you break the monoliths like Siri did in The Witcher that's how that's how those beasts come to be you know uh they facilitate rapid growth reuse the modular architecture do we even have a account oh wait no that's not why it was when the the alignment happened what am I saying uh reuse the modular architecture uh do we even have account of how many different things uh have all been let's see all promoted reused as a selling point language certainly uh have it or have done it oop languages procedural languages functional languages uh libraries Frameworks and one day I want to see something hyped that expertly says a screw reuse we don't care about that this man has not this man has not seen htmx htmx is this htmx is is is truly this right which is just like stop stop trying to make everything reuse okay make your API endpoints produce the same thing they enable more outputs data sets often are presented in different ways to different audiences that sounds uh a great deal like Crystal Reports homepage uh I like how they don't even try to debunk this one they just or try to they're just like yeah well what about that this is pretty much how Twitter communicates oh so you don't like react well then why is why is angular sucking then you're like I don't like angular either good call uh easier to assess updates in the application life cycle they need to uh they need to access existing computation models against newly created models for machine learning and advanced analytics environments it kind of sounds like a large pile of action words thrown together with little substance behind them that's what I said uh they enable scale let's see how funny this the same was set of ejb transactional middleware processing a la tuxedo and mainframes yeah I don't think they enable scale like they're saying uh many popular tools are available I don't think I have to really work hard to point out that these tools have always been available for every major hype that's come through our industry particularly after the hype was taken root for a while most readers won't even be old enough to remember case tools but they may they maybe are oh my goodness but maybe they'll remember uml uml is the devil okay I had to do so much you not even talking about we're moving on but let's see but the Discerning reader will notice that there is plenty common theme about half the points above the idea of of creating and maintaining small independent chunks of code and data versioned apart from one another using common inputs and outputs to enable larger integration of systems it's almost as if at the heart of micro uh Services we find modules yup the lowly the lowly module the core concept that has been at the heart of most programming languages since the 70s even earlier though is harder to do with older languages that didn't incorporate the module as a first class core concept call them assemblies on the on the clear a C sharp F-sharp Visual Basic jars or packages on the jvm or dynamically linked libraries from your favorite operating system Doles from Windows sews or A's on nixes and of course Mac OS has the Frameworks tucked away inside the Library directories uh but at the conceptual level they're all modules each has a different internal format but each serves the same purpose a an independently built managed version and deployed unit of code that can be reused consider this working definition of a module quoted from one of the computer science foundational papers a well-defined segmentation of the pro I can't read this word without thinking of the word fault of a project effort ensures system modularity each task forms a separate distinct program module at implementation Time Each module and its inputs and outputs are well defined there is no confusion in the intended interface with other system modules at checkout to time the Integrity of the module is tested independently there are a few scheduling problems in synchronizing the completion of several tasks before checkout can begin finally the system is maintained in modular fashion system errors and deficiencies can be traced to specific system modules thus limiting the scope of detailed error searching this comes from Dave David aparnas a seminal paper the on the criteria to be used in decomposing systems into modules written in 1971 over 50 years ago at the time of the writing well-defined separate distinct program modules cover about half the suggested benefits of microservices you know this I mean this is a fairly compelling take right like I'm definitely I definitely see the benefits of of microservicing things out and I definitely see that people can build some really terrible monoliths I think one of the problems we see is a classic argument in our world which is you point to something that is bad right we all agree that we've made bad monoliths and you point to those bad monoliths and you say see this is what happens when you write monoliths it's not necessarily true it's not necessarily true and so it ends up being this thing where you you you you paint one idea as just purely evil and then you paint a solution right it's like I forget what that I forget what the term is but effectively it's like a what is it this is a concept that happens all the time right uh but anyways it's the same concept where you're just you're able to demonize something by just like some version of it it's a straw man argument in some sense but I know that there has to be a term for this where you effectively paint in the people's mind uh it's like a form of propaganda that paints in an idea and then you you give the solution to that idea that is different gaslighting you're completely wrong on this one gaslighting comes from the movie Gaslight gaslighting if I'm not mistaken where a guy turns down his the lights in his house to drive his wife mad where she goes is it dark in here and he goes no and he's driving her crazy that's gaslighting is where where what's happening you deny reality to somebody else such that they consider themselves crazy no one uses the term gaslighting correct you know why because a bunch of people are a bunch of idiots and all they do is go on Twitter and see the word gaslighting happen and then everyone uses it and now they're all wrong and now gaslighting means nothing gaslighting means you said something that pisses me off now it's broken now it's completely wrong I'm not I'm actually not gaslighting you I'm giving you I'm giving you the Deets I'm giving you the tip and the shaft here okay gosh gaslighting isn't real are you crazy same with the word literally literally literally does not mean literally Prime is trying to gaslighter shut up thank you Dax for raiding I don't have alerts bangers are on and reading an article uh it's about microservices because microservices were really never about microservices or services or even distributed systems at the heart of microservices we should find organizational Clarity I love this I love that this is true Amazon one of the first companies to openly discuss the microservice concept really wasn't trying to push the architecture Principle as much as they were trying to push the idea of independent development teams whose blockers were few and far between waiting on the DBA team for a schema changes QA needs to build uh to test so they can find the bugs or are we waiting for infrastructure team to produce a server or the ux team to create a prototype for the presentation slurp I don't I I don't understand this but okay let's go is uml gaslighting uml is actually gaslighting uml presents you a lie of the world in which you believe is true but actually the reality is that it's moved underneath it cherry picking might be the Terry uh that's uh that sound you hear is the development team aggregating ownership of any and all of those dependencies that could and frequently would block them from moving forward yes so having a having a defined and independent contract between teams in which can move out of underneath them is effectively what you're saying uh it meant that the teams were small microcosms of the average it teams various parts analysis development design testing data management deployment and administration and more it did mean that now teams either had to be assembled from a variety of death uh of desperate skill sets or else we have to require let's see despair oh my goodness I know the word but I cannot say it disparate disparate I always call that disparate it's not it's disparate oh my goodness I cannot say this word I know what word is this but I can't say it or else we had the uh to require the complete set of skills in each team member the so-called full stack developer which meant that hiring these folks would become in uh infinitely trickier it also meant that now the team was responsible for its own production outage meaning that the team itself has to be given an on-call responsibilities and the commiserate payroll and legal implications that go along with that but we all let's see when all that was navigated it meant that each team could build their artifact independently of one another constrained by nothing other than time and the physics of how fast fingers can fly over a keyboard use them by the way so in theory anyway um hold on what did Judah say it's worth mentioning that Amazon embraced this because their shop was an epic trash fire where everything broke all the time and teams didn't trust each other at all it's literally a fortress of mentality to protect your code yes this is true so I've heard this many many times by many people including ex managers at Amazon that it is truly like it has the same air of Apple where like what you know is leverage for you to use against somebody else I hear super effed up things yeah I I mean we shouldn't get I don't like this phrase we should get rid of all people that sounds scary uh but I think we should uh try to nudge people and I think people should fail on their own it feels good to fail you know what I mean invalid stack pointed a string uh disparate I know I can't I know what I'm trying to say all in Winter thank you very much uh yes we'll be doing that in just one second it's right there at the heart of microservices we often find the fallacies of distributed computing for those not familiar with them the fallacies were first coined by Peter dust uh in a presentation to his peers at Sun back in the 80s they reappeared in 1994 seminal paper a note on distributed computing by Anne walrath and Jim Waldo and they both essentially say the same thing getting distributed systems right performance reliability scalability and whatever right means is hard Loosely paraphrase uh when we decompose the system into an in-memory modules running on a single operating system node the cost of passing data across platforms or Library boundaries was pretty negligible even 50 years ago when passing the data across Network lines though as most microservices do as five to seven orders of magnitude greater latency to the communication that makes sense uh I would I would buy that instantaneously I mean because you're communicating if you're communicating to a library we're talking about microseconds right when you're communicating to your network card your network card then has to communicate across the the wire the wire has to then get to the right place the right place then has to have that network card reading the data that network card then has to send an interrupt to your program your program then has to respond to it copy the data into it and then process it then send the response back of course that's going to be like a 10x increase right of course what are you talking about uh every once in a while some smart mofo comes up with a with a title like hey minor note on massive topic and casually attaches 1500 pages of Genius to it and shoves it all down her throats yep yeah Academia if it wasn't so awful it would be great but there are a few times it's fantastic it's amazing that it only increases at 10x yeah it is true that's one beautiful part of close faster the fastest light communication almost fast as life right exactly exactly ziok um all right hold on yep some can be let's see some of that can be made less relevant by hosting the microservices on the same machine usually by loading them into a cluster of virtual machines running containerized images out of the independent microservices as in using Docker compose or kubernetes on the host collection of Docker containers doing so however adds latency between the virtual machine process boundaries because we have to move data up and down the virtual Network stack in accordance with the rules of the seven layer model even if some of those layers are being entirely emulated yep I mean it's true no matter what you have to add some amount some non-negligible amount of call and still creates a reliability issue of running on a single node yep what's worse even as we start to wrestle with the fallacies of distributed computing we begin to run into related but separate uh set of problems the fallacies of Enterprise Computing oh beautiful name at the heart of microservices we need to start rethinking what we really need do you need to decompose the problem into independent entities can you do that by embracing Standalone processes hosted in a Docker container or can you do that by embracing Standalone modules in an application server that obeys a standardized API convention or a variety of other options this is okay for me this is where this is where git sub modules always feel like the right choice I always want them to be right I literally fall prey to get modules constantly because the concept is always amazing the concept is so great on paper every time it just bothers me so much that I hate to get some modules so much but on paper are they incredible they are incredible the idea is they live Judo they are they are horrible but yet at the same time it is such a good idea this isn't a technical problem that requires abandoning anything that's already been built it can be done using Technologies from anywhere in the latest uh the last 20 years including serverless uh aspenet Ruby python C plus plus and maybe even Pearl the key is to establish that common architecture or backplane with well understood integration and communication conventions whatever you want or need it to be do you need to reduce the dependencies your development team is facing then Begin by looking at those dependencies and working with Partners to determine which of them you can bring into the team's wheelhouse if the organization doesn't want to officially break up the skill-centric ontology of its org chart meaning you have a database group an infrastructure group and a QA group as peers to your Development Group then work with senior Executives to at least allow for dotted line reports reporting structure so there's individuals from each group that are now Matrix uh in on a single team but wow that's just I mean now we're getting into the fans to speak uh but most importantly make sure that the team has a Crystal Clear Vision of what it is they're trying to build and and they can confidently describe the heart of their system our service architecture module to any random stranger walking on the street the key is to give the team the direction and goal the autonomy to accomplish it and the Clarion call to get it done I mean actually I mean I really do like this this last part which is when you do break everything into a micro service architecture by that very wisdom of saying we want these separations you also create a ton of ancillary problems right you will find yourself working continuously on a ton of just unrelated issues right you don't actually build your business logic which could be very very simple instead you build like exceptionally complicated ways to make sure that all these play nicely right you'd really truly do have to build an entire an entire Canary testing and like an automated Canary analysis for every single service that you release you need to be able to do that I forget what they call it blue green or whatever type of a thing where you release one and then you can slowly change it over all that it's like it's really it's really non-trivial to also do it the other way uh it really boils down to these two things which really really really have nothing to do with each other except tangentially agreed still using sway I haven't started yet uh love this article this was fantastic honestly this was a great article just kind of challenging a lot of the the key points I think that we that we have in our head whether or not it's actually true it just challenges that point and you should do this more often in your life always challenge yourself because you don't really realize what is and what isn't you know what I mean like you don't actually know why you do the things you do it's the known uh it's the it's the unknown knowns the the things you think are good you may think they're good just because everyone around you right it's the hundred monkey experiment you don't even realize you're an you're you're a monkey right the name it's the primogen