hi everyone last episode we added in weights so that the path finding algorithm would prioritize easier terrain such as roads unfortunately as you can see the optimal solution is often to move along the very edge of the road which looks highly unnatural here's a visualization of the current weights with the light areas having the lowest terrain penalty and the dark areas having the highest if we now a blur these weights a little bit it will result in a much nicer looking path since the terrain penalty will be higher along the edges of the road than at the center to achieve this let's look at a simple blur algorithm called the box blur we start with a grid of values usually representing an image but of course in our cases actually the terrain nodes and their associated movement penalties to perform the blur we want each nodes value to be an average of the surrounding values to do this we imagine a smaller grid usually referred to as the kernel which starts centered on the top left node for this example I'm using a 3x3 kernel but obviously it can be bigger so long as its size is an uneven number so that it has a central square when centered on an edge node the kernel obviously extends past our grid so to fix this we can simply repeat the values around the edge we now add up all the values inside the kernel which here gives us 10 and then divide it by the number of squares in the kernel which in this case is 9 to get the average we then save that result to a new grid to avoid having to write fractions I'll just fill in 10 and then indicate that all the values in this grid are divided by 9 we then move the kernel to be centered on the next node and perform the same operation than the next and so on until we've covered all the nodes the grid on the left now represents our blurred terrain penalties the process that I've just shown is the most straightforward way to think about and implement the box blur algorithm but it's not particularly efficient it turns out that we can speed things up considerably by doing a separate horizontal and vertical pass let's work through this example again this time using the optimized approach starting with a 3x1 Colonel centered on the top left node will sum up all of the values inside the kernel and save the result to the second grid for the subsequent nodes in this row we can then use a simple trick if you can call it that to save having to loop through all of the nodes in the kernel since the kernel is just shifted one place across the new sum will be equal to the previous sum minus the value on the left that is no longer inside the kernel plus the value on the right that has just entered the kernel so here our new value is three minus one plus two giving us four for our next slot with such a small kernel this isn't extremely helpful but when it's larger then you obviously save having to loop over each of the nodes all right so this process is then repeated until all the nodes have been covered next up is the vertical path we'll use a one by three kernel centered on the top left node of the grid containing the results of the horizontal pass we've just done summing the values in our kernel now gives us ten and I'll save this in a new grid and once again indicate that all the values in this grid are divided by nine proceeding to cover all of the nodes you can see that we end up with the same result as when we did this the first time but we've arrived there in a much more efficient manner alright let's get started implementing this so I need to open up the grid class and just come down here and create a method to look or something like blur penalty map and it's all taken an integer for the blur size now from this blur size will calculate the actual kernel size so in kernel size and as I mentioned the the kernel size must be an odd number that it has a central square so let's I'll set this equal to blur size times 2 plus 1 so a blur size of 1 gives us a kernel size of 3 ok I then also want to know what I'll call the kernel extents which is simply how many squares are there between the central square and the edge of the kernel so for a 3 by 3 kernel that would just be one square so we can calculate this by saying kernel size minus 1 and then dividing this by 2 we'll also then need two arrays to act as the sort of temporary grids that we store our horizontal and vertical pass values in so I'll create a 2d array of integers call this the penalty's horizontal pass and initialize this with the size of grid size X by grid size Y and I'm just going to copy this and rename this one to the vertical pass all right so for the horizontal pass we're going to want to go through row by row so I'll make it all full look for that 4 in y equals 0 y less than grid size Y y plus plus then remember that for the first node we have to loop through all of the nodes in the kernel and some memmer and it's only on the subsequent nodes that we can use the so-called trick for quickly calculating the Sun so for the first note in each row we'll have a loop with index starting at negative Colonel extents while X is less than or equal to positive Colonel extents we will increment X all right so now when X is negative we want to clamp it to be 0 so that it just takes the value from the first node instead of going out of bounds and that of course is just the same idea as repeating the values around the edges of the grid so let's create an int or call this sample X which is simply equal to math F dot clamp passing an X and we'll say 0 is the minimum value and obviously X can't exceed Colonel extends so we'll just put that in as the max value we then want to add this nodes value so penalty's horizontal pass at column 0 row Y gets incremented by the movement penalty of our grid at sample X comma Y okay will now want a new loop for all the remaining columns in this row so for index starting at one since we've already calculated the value for column 0 X less than grid size X X plus plus will then want to calculate the index of the node that is no longer inside of the kernel when the kernel shifts one along so you can say in to remove index is equal to X minus the kernel extents minus 1 now we also need to make sure that this doesn't fall below zero so we can just do another clamp operation passing in this value having zeros are minimum and now we can just pass in the grid size X as the maximum value we want to do the same thing for the add index the node that has just entered the the kernel so this will be X plus kernel extents and this we also have to clamp to make sure that it doesn't go out of bounds on the right side of the grid so we can say math F dot clamp this value between 0 and it shouldn't be larger than grid size X minus 1 all right we can then say that the penalty's horizontal pass at x comma y is equal to the previous calculated value so that's at X minus 1 comma Y minus the movement penalty at I'll remove index so that's grid remove index comma Y dot movement penalty and then plus the add index so grid add index Y dot movement penalty all right so left completes our horizontal paths now the vertical path is going to be very similar to the horizontal path so let's save some time by just copying this code and pasting that down there so first of all instead of going row by row we want to go column by column now so change this to four in x equals zero X less than grid size X X plus plus and in this for loop we'll rename the X to a Y and sample X of course becomes sample Y and our penalties horizontal path becomes the penalties vertical path which we want to index at column X row zero then we want to sample the movement penalty enough from the grid but from the horizontal path we've just done so change this to penalties horizontal pass and we have to remove the dot movement penalty and we'll sample this at X comma sample Y I'll write in this next for loop we can rename X to Y once again and grid size X becomes grid size Y and in these two cases as well then over here penalties horizontal pass gets changed to penalties vertical pass and for this one as well let's correct these indices to be X comma Y and then over here it will be X comma Y minus 1 since we're trying to get the previously stored value then we want to get these values not from the grid but from our horizontal pass so let's change this to penalty horizontal pass and remove the dot movement penalty it's there as well and the indices for this will now be X comma remove index and X comma add index alright so that completes our vertical pass so now our to get the final blurred penalty for each node we can just write int load penalty is equal to the value we've just calculated so penalties vegetable pass X comma Y and that needs to be averaged over number of squares in our kernel so we divide that by kernel size squared now instead of using integer division here which always rounds down should be more accurate if we rounded to the nearest integer so instead what we'll do is cast this to a float and then make use of math eighth-round to int which as you can see in its description returns f rounded to the nearest integer that's what we want let's enclose that in parentheses and then we can set our grid at X comma Y to have a movement penalty of the new blood penalty value all right so I mean to save this but without calling the blur penalty map from anywhere just go to him to unity and play this quickly so as I showed at the beginning of the video the unit is sort of hugging the edge of the road but if we now go up to the crate grid method and at the bottom here make a call to the penalty map say with the blur size of three and then run this again we should see that we're getting a much nicer path now one thing I would like to be able to do is visualize the weights in the in the editor just by turning on the display grid gizmos so we're going to need to create two integers a penalty min which I'll set equal to int dot max value and an int penalty Max which will start it in dot min value then in the blood penalty map method over here where we've calculated our final blurred penalty we can say if the blurred penalty is greater than the current penalty max then penalty max get set to that blurred value and if the blurred penalty is less then penalty min then penalty men get set to blood penalty with that done we can now go down into our drug use Mo's method and when we're trying to figure out the color we can say gizmos color is equal to and now we want to fade from white to black depending on the weight so we can say color dot lip from color dot white to color black and now we need a value that's zero if the penalty of the current node is equal to the lowest penalty value and one if it's equal to the highest penalty value so we'll use math F dot inverse lap with our penalty min our penalty max and our nodes actual value so n dot movement penalty all right so now we can just change this line over here to say if n is walkable then we'll set the color to the gizmo's current color so we just retain this color over here otherwise we set it to red also going to remove this minus point one just so that we can see the gizmos a little bit more clearly if I play this and turn display grid grid gizmos on we can see that we've got the path nicely blurred one slightly surprising thing perhaps is that each of these obstacles has got a area of lower penalties around it and this is just because we haven't bothered assigning any movement penalty to the obstacles since you can't walk there so they have a value of zero which then gets blurred around them now we obviously want to fix this because we don't want units to prefer walking close to obstacles in fact we wanted the other way around they should prefer to sort of keep a little bit of distance from each obstacle so let us go into monodevelop and coming up to where we create the grid this is a bit of code for calculating the movement penalty and you can see us enclosed in a walkable condition so we wanted to figure out the movement penalty here even for obstacles so we'll remove that condition and now if we just test this out quickly enable the grid gizmos once again you can see that that area has disappeared now to make it so that there's actually a penalty for moving too close to obstacles we can just create a little public int over here let's call this the obstacle proximity penalty so that equal to10 by default and then coming down here we'll say if not walkable then the movement penalty gets increased by the proximity penalty all right so let's try this once again and this time you can see that there is a dark region around each obstacle now one small thing you might notice is that at the bottom here the penalties are not getting blurred and this is just because if we go into our blur penalty map method you can see that Y starts at 1 in this loop over here which means that the grid will not have the blood penalty assigned for the first row which in the case of our code is the bottom row of the grid so we can fix this by just copying these two lines and pasting them over here and we want to get this X 0 element from the penalties vertical pass so let's change this to X 0 and here as well X 0 now since we define this integer over here when we use blood panel T again we just need to remove the type all right so let's save that and have a look at this one last time we should see that it's blurred down at the bottom as well all right that is everything for this episode so until next time Cheers