hello in this episode we're going to be generating a road mesh along the path the process we'll use is very simple starting with our path we generate evenly spaced points using the method from last episode we then calculate the direction from the first point to the second point and perpendicular to that we place our first two vertices for the next point we have two directions we could use the direction coming from the previous point and the direction going towards the next point for the nicest results we'll just take the average of these two and place two more vertices perpendicular to that for the last point we have just one direction we can use and so our final two vertices will be perpendicular to that we now just need to connect these vertices to form triangles for example vertices zero to one could form the first triangle the only reason for that order being that the triangles should be wound clockwise in order to face the correct way so the second triangle could be one two three followed by two four three and finally three four five also quickly note by the way that the number of vertices we have is equal to 2n where n is just the number of points we generated along the curve so in this case three and the number of triangles is just two times n minus one ok so inside the examples folder I'm going to create a new c-cup script called Road Creator and I'll open that up in here I'll create a method which returns a mesh called create road mesh and this was taken an array of vector tools for the points along the path you can start by creating an array of vector threes to hold the vertices so the size of this will just be the number of points multiplied by 2 as we saw a moment ago then we'll need an intro ray for holding the triangle data so set this equal to a new entry and we saw that the number of triangles is equal to 2 times the number of points minus 1 and then since there are three vertices in each triangle we'll need to multiply that by 3 for the size of the array ok let's not create an inch vertex index starts at zero and triangle index starts at zero as well let's now loop through all of the points so for I equals zero I less than point start length I plus plus and now for each point we want to get its forward direction so I'll create a vector to forward and just set this equal to vector to 0 so as long as we're not currently on the last point so I can express that as if I is less than point start length minus 1 as long as it's not the last point then we can set forward equal to the direction to the next point so points of the index of I plus 1 coming from the current point similarly as long as this is not the first point so if I is greater than 0 then we could set forward equal to the direction to the current point coming from the previous point so points with an index of I minus 1 now if it's not the last point and it's not the first point that I actually want the forward direction to be an average between these two so instead of just assigning it directly to forward I'll say forward plus equals these two things and then at the end we can just normalize the forward vector like so ok so if you imagine this red line is our forward vector we can easily get our left two vector by swapping the x and y components and then multiplying the new x component by negative one okay so I cannot create a vector to left equal to a new vector to with its X component being negative forward dot Y and its Y component being forward dot X all right I'm quickly going to create a public float up at the top here for the road width and set that equal to one by default and then we can add our two vertices so verts with an index of vert index is going to be equal to the current point sir points i+ left x road width x 1/2 and then the next vertex server taught an index of vert index plus 1 is going to be equal to the current point minus left x road width x 1/2 and then we just increase vert index by 2 all right now just before we increment the vert index I want to add in the two triangles so coming back to this diagram so we're currently on this first point over here so we will have just added in this vertex to the left and this other vertex to the negative left also fondly known as the right let's call the index of this first vertex V then this will be V plus 1 up here we'll have V plus 2 and V plus 3 and so on so in general terms our first triangle goes from the current vertex index to vertex index plus 2 to vertex index plus 1 and the second triangle goes from vertex index plus 1 to vertex index plus 2 to vertex index plus 3 note of course that when we get to this last point there are no more triangles to add in unless it is a closed path which we'll worry about a little bit later so back in the script we can say as long as this isn't the last point in the path so if I is less than when start length minus 1 then we can say triangles with an index of triangle index is equal to the vertex index and I'm just going to copy this twice for the remaining cheveux to see is in the first triangle so this will be with an index of try and x plus 1 and the second will be try and X plus 2 and this will be equal to vert index plus 2 and then vert index plus 1 I'll then copy all of these for the second triangle so this will have indices plus 3 plus 4 and +5 with vertex indices going V 1 V 2 and finally V 3 at the end of this we increment the vertex index by 2 and increment the triangle index by 6 now that we finished calculating our vertex in triangle data we can construct a mesh so I'll say mesh mesh is equal to a new mesh and then I'll set mesh dot vertices equal to the vertebrae and meshed our triangles equal to the triangles array and then just return that mesh all right back up at the top let me create a public float spacing I'll set that equal to say 1 and I'm gonna make this a slider so I'll have this in a range between maybe 0.05 and like 1.5 I'm then going to create a public method called something like update road and this will start by getting a path so get component path crater and grab the path from that and then you'll get a vector to array of points is equal to path dot calculate evenly spaced points passing in the spacing value and then here to get the mesh filter component and set its mesh equal to the results of crater at mesh passing in the points now currently we're just assuming that whatever object this road crater is attached to also has a path crater and a mesh filter attached but let's be a little bit more rigorous and add a require component attribute up here so this will be type of path creator and then I'll copy that require a mesh filter as well and also a mesh renderer since the mesh filter doesn't really make sense without one all right now we obviously need to call this update Road method from somewhere if we ever want to see the road so for testing I'm going to create a public bull auto update and when that's true I want update Road to be called from an editor script whenever the scene gets repainted so I'm going to save this go into unity and when that compiles go into the editor folder and just create a new script called Road editor and in here I'm going to add the unity editor namespace inherit from editor and will be a custom editor type of Road crater I'll create a road crater variable called crater and I'll assign that in the on in able method so I'll just say crater is equal to the target but cast as a road crater like so and then on scene GUI we can say if the Creator wants to be Auto updated and the current event type is equal to a repaint event then we'll just call crater dot update Road I'll save that go into unity and create a new empty objects just reset the transform so it's at zero zero zero and I'll add a road crater component to that and return on auto update and just reduce the space thing a little bit and maybe decrease the road width as well so can now move the path around and the road updates one problem might be if we try insert a point you can see it actually deselects the object because it's trying to select the mesh behind it so we'll have to make a small modification to the path editor script just coming down to the bottom of the input method and I say handle utility dot ad default control button a control idea of zero so this just means that if nothing else is selected then this invisible default control will be selected and that will prevent any stuff in the background like the mesh from picking up the selection all the right sort of save that and now once that compiles should be able to insert points without a problem to make it a little easier to see what's going on I'm just going to turn off display control points and turn on auto set control points so I'm just dealing with these main points here all right this is looking good just one thing is of course if we try make the path closed then you can see it doesn't exactly join up at the end so we're going to want to bridge this gap by adding in two new triangles between the first and last two vertices for a closed path so let's go into the road crater and I'm going to add a new parameter to the create road mesh method here so be a bool is closed and when we call it we can pass in path dot is closed and so if we calculate the number of triangles this will be equal to two times the number of points minus one but then if it is a closed path we'll want to add two onto that number all right we can then set the size of our triangles array equal to the number of triangles multiplied by three coming down to where we're actually adding the triangles if it's a closed path then we do want to add triangles for the very last point so we can say oh is closed but now these vertex indices which are +2 and +3 are going to be out of range of the vertex array we just need to loop them back around so I'm going to put these inside parentheses and then say mod vertices dot length okay let me copy that and I'll be doing that for this one here as well and the +3 1 now for a closed path of course the last point does actually have a next point since I would just be the first point then so let's say o is a closed path and we can just wrap this around by saying mod points dot length and similarly for this one here we can say o is a closed path then we'll wrap this around mod points dot length but we have to be a bit careful because negative numbers won't get wrapped around in c-sharp so we'll just want to add points dot length to that to make sure it's always positive okay so that should work let's save go into unity and once that compiles you can see the gap there has been bridged so we've now got a nice closed path and if I toggle off the closed then the open path is still working properly now it should be very nice if we could apply a texture to the road so we're going to need to give it UV coordinates let's go into the road crater script and below the vertices array will create a vector to array UVs and so just need the same length as the vertices array so to say verse dot length and then over here where we're selling the vertices let's start by calculating how far along the path we are chuckle is the completion percent and it's going to be equal to I divided by and cast to a float the number of points minus one so will be zero at the start of the path and one at the end of the path we can then say you've ease with an index of the current a vertex index is equal to a new vector2 naught comma completion percent and you v's vertex index plus 1 equal to a new vector 2 1 comma completion % so just to be sure that's clear this vertex over here would have a UV coordinate of 0 comma 0 meaning the bottom left of the texture this one would be 1 comma 0 so reading from the bottom right of the texture then up here would be 0 comma not 0.5 middle left of the texture 1 comma not 0.5 middle right of the texture and then 0 comma 1 top left of the texture and 1 comma 1 top right of the texture all right so I'll save that actually one second we actually need to apply that to the mesh so mesh dot UV is equal to the UVs okay save go into unity and I'm quickly going to import this simple little track Shack store I have to drag that in there and I'll create a material as well call this road I'll just make this a unlit texture apply the road texture to that and I'll drag that onto the road ok so we can all use the tiling property on the material to repeat this a bunch of times vertically it's currently not actually repeating though and that's just because of the wrap mode on the texture we need to change this from clamp to repeat and that you can see it actually repeating so you make that repeat a bunch of times and that's looking very nice and Rudy there is one problem though which is if I make this into a closed path okay it's not actually visible here but let me just deselect this you can see properly there are some strange artifacts at the end here and the reason for these is that at the beginning of the road our completion percent is zero and remember that's the vertical component of the UVs then as we go around it increases all the way up to one and so it's one at the end here but then on these last two triangles that are sort of bridging the gap between the start and end of the path the UVs quickly go from one at the end of the path to zero at the start of the path so it's motioning the entire tiled texture into that space now there are a couple of ways we can fix this but I think the easiest is instead of going from zero to one around the path it should instead go from zero to one somewhere in the middle back to zero at the end that way the end and the start have the same value so we're going to need a function that takes an input between zero and one and returns an output that moves linearly from zero to one back to zero again so we can use the function one minus the absolute value of 2x minus one so going to the script I'll say float V is equal to one minus the absolute value of two times completion percent minus one and then just use this value V in both cases here all right so if I save that I wait for her to compile if I just click on something to a four so to update we should see that problem go away cool so the last thing I'd like to do in this episode is just make it so that the tiling resizes automatically based on the length of the road you can see if I have a small road then is all bunched up and deformed and if I have say a really really long road then these get really long so they should basically maintain a constant size as we resize the road so coming into the road crater script I will create a public float tiling set that equal to one and in the update Road method I mean to say in texture repeat is equal to ma theft or ROM two inch of the tiling value multiplied by the number of points in the path so points dot length multiplied by the spacing and finally multiplied by some small constant factor like 0.5 we then just have to get the mesh renderer component so that we can grab the shared material and set its min texture scale equal to a new vector 2 1 comma texture repeat ok so save that go into unity wait for the compile to finish and now we can just increase the tiling amount until some lines appear there and if I extend the length of the road those lines should remain roughly the same length as well as if I increase or decrease the spacing you can see those remain roughly the same and now if I turn on closed path this is all working as well so that is everything for this episode until next time Cheers