hi everyone I'd like to start this episode by briefly talking about normals just to make sure that we're all on the same page so I have a little example Messier made up of four triangles and each of these triangles of course has its own normal vector that is to say a direction that is perpendicular to the surface of each triangle and these normals are used to calculate the lighting of each of the triangles now when we're creating a mesh in unity we need to supply normals on a per vertex basis this is simple enough because the normal of say the central vertex over here is simply an average of the normals of all of the triangles to which that vertex belongs okay so now in the project if I just go into the map generator and make sure that the normalized mode is set to global and that the use fall-off is disabled if we generate a map and just look at two adjacent chunks with the same level of detail we can see that even though the vertices match up perfectly this still very noticeable seam between them the reason for this is very simple the normal direction of each vertex is as I mentioned a moment ago based on the normals of the triangles surrounding it however the vertices along the edge of a chunk don't have access to the triangles of the adjacent chunk and thus have incorrect normal values this gives us incorrect lighting along the edges which is what is causing the unattractive seem that we see here let's head over to the mesh generator class and let's begin by creating our own implementation of the recalculate normals method so let's have a method returning an array of vector threes and call this calculate normals let's start by creating a vector three arrays to store the vertex normals in and this will of course have the same length as our vertices array and then we want to figure out how many triangles we have so let's say inch fry angle count is equal to and we can use the length of the triangles array which that just stores sets of three vertices so if we divide the length by three we'll have the number of triangles and then we can just loop through all of those so for int I equals zero I less than the triangle count I plus plus so if I is the number of the triangle which we're working with then I times three will be its index in the triangles array so let's say int normal triangle index is equal to I times three and then we'll want the indices of all of the vertices that make up the current triangle so you can say int vertex index a will be equal to the element in the triangles array with an index of normal triangle index let's just copy this line twice because we want vertex index B as well as vertex index C so the next one will be normal triangle index plus 1 and then normal triangle index plus two let's then create a method which given the three vertex indices will return the normal vector of that triangle so let's say vector three can call this surface normal from indices and I can take in int index a index B and index C then we can say vector three point a is equal to the element from the vertices array with an index of index a and we can do the same thing for points B and C all right now to calculate the surface normal from these points we're going to use the cross-product given two vectors here representing the two sides of a triangle a B and a C the cross product of a B and AC will be a another vector is perpendicular to both of them if you're curious about the maths behind the cross product I recommend looking it up we're simply going to write vector three side a B is equal to point B minus point A and our second side vector three side AC is equal to 0.9 as' point a and then we'll return the cross product so vector three dot cross of side a B and side AC and we'll want to be sure to normalize the result all right so that can now calculate normals method let's say vector three triangle normal is equal to surface normal from indices and we'll pass in our vertex index a vertex index B and vertex index C all right now we'll want to add that triangle normal to each of the vertices that are part of that triangle so we can say vertex normals with an index of vertex index a plus equals triangle normal likewise vertex normals vertex index B and vertex index C will also have triangle normal added to them once we've done that we'll want to normalize each of the values in the vertex normals array so we'll just do one loop through it for into I equals zero I less than vertex normals dot length I plus plus we can say vertex normals i dot normalize finally we will return the vertex normals array so instead of saying mesh dot recalculate normals we can say mesh normals is equal to calculate normals let's save and go into unity and if we press play we can see if this is working and it does seem to be of course the seam is still there we haven't changed anything and but otherwise the lighting looks as it should imagine we have a 3x3 map of vertices and the vertex indices are labeled from 0 to 8 this is essentially our current system what we're going to do to fix the normals issue is that when regenerating the mesh chunk we'll also calculate the vertices bordering the mesh this border will be excluded from the final mesh but will enable us to calculate the normals correctly we'll label these border vertices from negative 1 downwards thus any triangle containing a vertex with an index less than 0 will be excluded from the final mesh let's agree to call this the board size and this the mesh size in this example the board size is 5 and the mesh size is 3 and we can clearly see that in general the mesh size is equal to the boarded size minus 2 with this in mind let's go back to the mesh generator class and up at the top here let's first of all get rid of the concept of width and height since we're working with squares so I'll just rename both of these to borded size and then I'll delete the one of them and we can say that the mesh size is equal to as we've discussed the board size - - when we're working out the top left X and Z position we'll want to do this with the actual mesh size rather than the aborted size and the same story of when we're working out the number of vertices in a line we'll want to use the mesh size for that calculation now keeping this image in mind let's create a 2d array of integers representing the different vertex indices so I'm going to delete this variable over here and instead create a 2d integer array I'll call this the vertex indices map set that equal to a new 2d integer array with a size of bordered size by boarded size a Len create an integer for the ear mesh vertex index this is going to start at 0 and an integer for the boarder vertex index starting at negative 1 will then want a loop just like this one over here so let's copy that and in here we can create a bool is boarder vertex and this will be true if any of the following are true y equals 0 or y equals boarded size minus 1 or x equals 0 or x equals boarded size minus 1 all right so if it is aborted vertex then we can say vertex indices map X by Y is equal to our boarder vertex index and we'll want to decrement that so boarder vertex index minus - otherwise we'll say vertex indices map XY is equal to mesh vertex index and we'll then increment the mesh vertex index all right so then in this next loop over here we can get our vertex index from the vertex indices map by saying int vertex index is equal to vertex indices map with an index of X by Y then I'm going to change how this works a little bit instead of directly assigning to mesh data dot vertices just going to assign this to a new vector3 called vertex position and similarly with this UV line here we actually sign this to a vector to variable called % and we're going to have to modify our calculation slightly first of all we're going to divide not by boarded size but by the mesh size since that's what we care about for the UVs now on the leftmost edge of the map we obviously want this expression over here to evaluate to zero but currently it won't because when X is equal to zero that will form part of the border which as we know is being left out of the mesh the value after x equals zero is X plus the mesh simplification increment so what we want to do over here simply say X minus the mesh simplification increment in brackets and then for the same reason we want to do that with y Y minus mesh simplification increment so in case you confused this modification really just make sure that our UVs are still properly centered all right now I'm going to cut this line and put it above the vertex position and then I may just say float height and just cut this part out here just to make it a little bit neater and then I'm going to change the way that we calculate the X and z values over here so instead of adding X we'll say top top left X plus the percent X multiplied by the mesh size and over here top left Z minus percent dot Y multiplied by the mesh size okay now we need to cast our minds back to what these two lines are doing those two lines are creating two triangles out of the four points a b c and d but now we need to update this to work with our vertex indices map so if we say that the index of vertex a is stored in our vertex indices map at x by y then the index of vertex B will be stored at X plus I where I is the mesh simplification increment by Y and C will be X by Y plus I and D will be X plus I by Y plus I and remember we're forming the triangles in a clockwise order so the first one is triangle ADC and the second is triangle da B so keeping this in mind we can write into a is equal to vertex indices map with an index of X comma Y and let's just copy/paste this another three times this is int B in C and in D so B will be X plus mesh simplification increment C will be y plus mesh simplification increment and D is plus mesh duplication increment for both x and y all right and then the triangles that we're trying to create are in the order a D C followed by D a B okay now going down to the mesh data class let's make these variables B no longer public since we aren't accessing them directly anymore and let's also add a vector3 array for our boarder vertices in other words the vertices that won't be included in the mesh and similarly a integer array for the boarder triangles and then just like we've got an integer for the triangle index we want an integer for the boarder triangle index and then in the constructor here first of all since we've decided to no longer work with width and height but just with a single size value let's rename these both two vertices per line and then we can just delete one of them and then let's initialize our border vertices array so we can say border vertices is equal to a new vector3 array and the number of border vertices is simply the number of vertices per line in the mesh multiplied by 4 for each of the sides plus 4 for each of the corners so we can say vertices per line multiplied by 4 plus 4 then we'll want to initialize our border triangles array so you can say border triangles equals new integer array so our border triangles array will need to record the indices of each of the six vertices that make up the two triangles per square and the number of squares in the border in this example is 12 or the general formula is 4 times the number of vertices per line in the mesh so we'll initialize our border triangles to a size of 6 times 4 times the number of vertices per line or simply 24 multiplied by vertices per line all right so since we can no longer add vertices or UVs directly let's create a public avoid method called add vertex and this will take in a vector 3 for the vertex position as well as a vector 2 for that vertices UV and then an integer for the vertex index all right now we're going to want to check if this is a border vertex by seeing if the vertex index is less than 0 otherwise if it's just a regular vertex then we can say vertices with an index of vertex index is equal to vertex position and UVs within index of vertex index is equal to the provided UV now if it is a border vertex we're going to want to add it to the boarder vertices array but remember that the vertex index in this case is negative and starting at negative 1 so in order to get an appropriate index we're going to have to say border vertices with an index of negative vertex index so that will make it start from one going upwards and then we're going to want to subtract one so that it starts at zero and we can then set that equal to the provided vertex position now we'll want to do a similar thing to the add triangles method we want to check if any of the vertices that make up the triangle are boarder vertices so we'll say if a is less than 0 or if B is less than 0 or if C is less than 0 then we know it is a triangle belonging to the border otherwise it is a regular triangle let's just copy paste this code and just replace triangles with boarder triangles and triangle index with boarder triangle index all right so now when we are calculating the normals we've gone through all of the regular triangles but then we're also going to want to loop through the triangles belonging to the border so let's duplicate all of this code over here and we'll rename triangle count to border triangle count and it will be equal to boarder triangles dot length divided by 3 and here we want to replace triangles with the boarder triangles array and final change we'll need to make is when we're adding the triangle normal to the vertex normals array we'll need to make sure that the vertex index we're using is greater than or equal to zero so let's say if vertex index a greater than or equal to 0 then that index will exist in the vertex normals array so we can use it and vertex index B greater than or equal to zero and the last one if vertex index C greater than or equal to zero all right so now in the surface normal from indices method we're going to have to check if the index is less than zero in which case we want to get it not from the vertices array but rather from the boarder vertices array so for each of these we'll do a check index a less than zero and if that's true then we'll want to get it from boarder vertices with an index of negative index a minus one otherwise we'll get it from the vertices array so let's just copy this to speed things up so change that to index B and that to index B and then over here index C and index C all right so believe it or not we are almost there just a few things we need to do for one we need to now call the advert X method on our mesh data so mesh data dot add vertex I'll pass in the vertex position the UV and the sorry we rename that to percent and the vertex index all right and then we also changed the constructor of the mesh data to take in only one integer so let's just remove the second one there let's save and see if everything is happy does seem to be so there's just one last thing we need to do and this is in the map generator class so if we go down to where the map data is being generated we want to generate the noise map with a size of map chunk size plus 2 for both the width and the height and this is just to compensate for the border so it will generate one extra noise value both on the left and right sides and on the top and the bottom however this leaves us with a problem with our level of detail implementation if you remember how we arrived at this value 241 it had to do with it being divisible by all of our different mesh simplification increments but now since we're adding 2 to that down there it will no longer have this nice property so what we're going to do is we're going to change it to 239 so that when we add to the actual value will be 241 and it will have that property again all right so if we save now and press play unfortunately it seems that while the regular chunks are being spawned in properly the ones that are at a lower level of detail are not being spaced correctly so let's head back to the mesh generator and what we're going to need to do is move this mesh simplification increment calculation up to the top here because we're going to need to use that value when we calculate the mesh size instead of just subtracting 2 we want to actually subtract 2 multiplied by the mesh simplification increment but then we're also going to want to create an integer mesh size unsimplified and this will be equal to the e bordered size minus 2 and this is the value that we want to use for things like calculating top-left X and top left is ed because we don't want the positions to be dependent on the level of detail of the mesh they should remain constant and the same goes down here for when we are calculating the position of the vertex we don't want to multiply by it mesh size but rather by mesh size unsimplified all right so if we save that now and come back here we should hopefully see that it's all lining up correctly and if we find ourselves two adjacent chunks of the same level of detail and let's zoom and nice and close here and take a moment to admire how seamlessly they join together after all our hard work all right that is everything for this episode until next time Cheers