hi everyone when wanting to quickly place many objects into a scene a fairly common time-saving technique is to just let the physics system run wild for a couple of seconds and save the result with the new physics dot simulate function in unity 2017 we can easily set up a tool to help us do this a little bit more efficiently so the script will be creating will ask to simulate and reset the position of our chosen objects and also be able to specify a force say in a particular direction and simulate that or let me do this 90 degrees and then shoot off in that direction or we can even randomize the force angle so that it gets scattered all over the place that's the basic idea so that's begin I have a simple scene set up in unity with a basic terrain mesh with a mesh Collider attached well if you just want to use a default plane for testing that will work as well and then I've got a couple of cubes some red some blue with box colliders and rigid bodies attached so I'm going to create a new C sharp script called physics simulation and also create an empty game object with the same name and I'll attach the script to that object and open the script up this is going to have a public method called run simulation and inside here we want to make a bunch of calls to physics dot simulate which takes in the time step so we can just pass in time dot fixed Delta time now we don't know how many times we're going to need to call this for all of our objects to come to rest so for now let's just create a public int max iterations which I'll set to something they'd like a thousand and we can just run a loop from zero to max it raisins and call simulate inside of that loop now before we can take manual control of the physics we have to turn off also simulate so we can say physics auto simulation is equal to false and we'll set that back to true once we finish simulating with physics Auto simulation equals true now this will really work we just need some way to call the run simulation method from inside the editor so I'm going to add a context menu attribute here and once we've done that can save and go into unity and only physics simulation objects we can just go over to the gear icon on three physics emulation script and the run simulation command should be there so if we click on that we'll see all of the objects have fallen into place now most of the time we're not going to need nearly a thousand iterations for all of the objects to settle so going back into the script let's break out of this loop early if all of the rigid bodies in the scene are sleeping so we'll first need an array of all of the rigid bodies so I'll create rigid body array called simulated bodies and we can set this using find objects of type rigid body alright and then I need to add using the system link namespace up at the top here and this will let me say if simulated bodies dot all so I'm going to define a condition here and if all of the simulated bodies meet that condition then the old method will return true so I'll start by defining a variable RB for rigid body and then using the Landro operator I can create my condition rigid body dot is sleeping so only if all of the rigid bodies in the array are sleeping will this return true and in that case we can just break out of the loop now this is a matter of interest let's print out the value of I at that point so you can see how many iterations it is taking so go back into unity and write all of these are on the ground already so I'll just raise them up again and then come over here and run the simulation and we can see in this case it took 101 iterations for all of the bodies to come to rest now we do of course still need the max iterations so you can imagine if one of the rigid bodies were to fall off the edge and then it would never go to sleep in which case we don't want to have a infinite loop so we assume to keep that max iterations termination condition as a sort of safety net all right I'm quickly going to find that red cube that I dropped off the edge of the world and just bring that back up here all right now I quite like to have the ability to once I've run a simulation to actually reset it in case I'm not happy with that simulation so let's go back into the script a dingy I'm going to define a new structure called simulated body and this is to hold a public read-only rigid body this called rigid body and then that will also have a read-only vector three for the original position a read-only quaternion for the original rotation and a read-only transform for the transform component alright and I'll press command I to generate a constructor this is good to just take in a rigid body in the constructor and then it will go through and set a transform equal to rigid body dot transform and original position will be equal to rigid body drop position and original rotation will be rigid dot rotation all right so this simulated bodies array is not going to be an array of rigid bodies anymore but rather an array of simulated bodies so of course we can't set this equal to find objects of type rigid body anymore but once again link comes to the rescue so we can just say dot select and I'll create my rigid body variable followed by a fat arrow and I'll be creating a new simulated body passing in the rigid body and then we just need to convert this to an array now we had an error in this line because RB now refers to a simulated body and simulated bodies don't have an is sleeping method so let me rename this to body and then I can just say body dot rigid body dot is sleeping I'll then move the Declaration of this array to outside of the method like so so that we can have access to it in this new method called reset or body is so that if you say if the simulated bodies array is not null then loop through all of the simulated bodies so for each simulated body body in the simulated bodies array we're going to call body dot reset and that will be a method inside of the simulated body structure so I'll create public void reset and this is going to say transform dot position is equal to the original position and transform of rotation is equal to the original rotation a quick note from the future that were the rigid bodies velocity and angular velocity to be reset to vector 3.0 inside of the reset method so I'll be adding mass at the end of the video but if you're following along I recommend that you just go ahead and add that now the code is on screen just if rigidbody not equal to null then set both of those things to vary to zero if you're wondering why rigid body might be null it weren't at this point but in a few minutes you'll see that we will be destroying rigid bodies in certain cases and so hence the check all right back to the present so now in order to call this reset or body's method let's add a another context menu attribute skull that reset and now if we save that let's quickly try this out so I'll grab all of the cubes move them up and then I forget to run the simulation and okay I don't like the consideration so I will research and that seems to have worked and then I can just quickly move some of these around and try the simulation again okay and I'll imagine these red cubes are the objects that we're trying to place and these blue cubes are just other rigid bodies in our scene which we don't want to be affected by the simulation so we need some way to tell which is which so I think make sense for the physics simulation to only work on its child objects so if we want to place the red cubes we'll just put this all as children of the physics simulation and let's go now into the script to set that up so when you're running physics let's simulate there is no way to tell it which rigid bodies to simulation which tool ever learn it's just going to simulate the entire physics environment so the only thing we can do is simulate everything and then call reset on the ones which are not child objects so I'm going to add a public read-only booooo called is child to the simulated body struct and this will be set inside of the constructor so Boo is child and can then say this dot is child is equal to the given is child value and when we're creating the new simulated bodies up here we can pass in rigid body dot transform dot is child of this transform all right then once we finish simulation we can look through each simulated body in the simulated bodies array and we can say if that body is not a child so let me preface that with an exclamation mark if body dot is child is not true then we get is a body dot research now just going back to this condition over here we're saying we can break out of the loop only if all of the rigid bodies are sleeping but we don't care about the bodies which are not children because they're not going to keep their simulated position anyway so we can just say oh not body dot is child so the logic is now we can break out of the loop as long as all of the rigid bodies which are children are sleeping all right so let's save this and continue nity and once this is finished compiling we can go a run simulation and only the red cubes have been placed okay now you can imagine that for some of the objects of replacing we might want them to have their rigid body and Collider attached because we want them to actually respond to physics during the game but for some of the objects we might only be adding the rigid body and Collider for this placement process and then we might want to remove those components afterwards because they're just static elements in the game world so as an added convenience at the start of the physics simulation we can just look through each of the children and for any you which don't already have a rigid body and box Collider attached we can automatically add one and at the end of the simulation just remove those auto-generated components so inside of the script I'm going to create a list of rigid bodies I'll call this the generated rigid bodies and likewise I'll create a list of colliders called the generated colliders and then somewhere down here I'm going to have a method called Auto generate components and this is the stuff by saying generated rigid bodies is equal to new list of rigid bodies and generated colliders is equal to a new list of colliders and then it's going to look through each of the child transforms of this transform and it's here to say if that child does not have a rigidbody component and then we can add one with child without game object add component of type rigidbody and we can add that auto-generated component to the generated rigid bodies list just by enclosing all of this in generated rigid bodies dot add like so and I'm going to copy this and just paste it and replace rigidbody with Collider and generated rigid bodies with generated colliders and instead of adding a rigid body here we'll be adding a box Collider as the default type of Collider and then we just want a method to remove auto-generated components so here we can loop through each rigid body in the generated rigid bodies and to remove it we will make a call to destroy immediate and pass the end that rigid body and then I'll just copy-paste this for each Collider Colette see in the generated colliders alright we of course want to call also generate components at the very start of the simulation the end I will call remove auto-generated components all right so I'll save this and go into unity and on the third cube I'm going to remove the rigidbody and the Box Collider and on the second I'll just remove the rigidbody and on the first I'll leave the Box slider and rigidbody so hopefully the simulation work correctly and the components on each of the objects at the end of the simulation should be the same as it is now so if we run the simulation all of the objects have been correctly placed on the ground and our first cube still has its two components the second cube has just the box Collider and a third cube has neither box Collider nor rigidbody so success all right the next thing I'd like to do is allow the user to specify a force that will be applied to each of these objects at the start of the simulation just so that you can get some more interesting results so opening up the script once more I'll create a public vector - and I'll call this a force min max so the x axis will be the min force and the y axis would be the max force and we'll choose a random value between that and that'll create public float I'll call this the force angle in degrees so that will just be the angle around the y axis that will be applying the force in and then over here at the start of the simulation we can go for each simulated body in the simulated bodies array if that body is a child then we want to generate a random force amount I'll set that equal to random dot range between force min max at X and force and min Max dot y and then vector3 force direction it's going to be a new vector3 and because angles increase clockwise around the y axis in unity will have mass f dot sine of the force angle and we of course need to multiply this by degrees to radians and then on the z axis that will be math f cosine of forthe angle in degrees multiplied by degrees to radians we can then say body dot rigid body dot add force force direction x random force amount and i'll set the force mode to impulse now we might want to be able to randomize this force direction so let's make a little boo here public boo randomize force angle and over here we can say force angle is equal to and if we're randomizing the force angle then we will get random range between 0 and 360 otherwise we will use the supplied fourth angle in degrees and as f you just go and multiply this all here by math f and dot degrees to radians and then we can replace all of this in here with force angle okay and now something that I forgot earlier is that in this reset method beyond resetting the position and rotation of the transform we also need to reset the velocity and angular velocity of the rigid body so let's first check that the rigid body is not null remember that since we've got all that auto-generating and also removing of component filling on the rigid body might be null at this point so we must check and if it's not null will say rigid body dot velocity is equal to vector 3.0 and rigid body year dot angular velocity is also equal to vector 3.0 all right so we can now save this and go into unity and to test out this new force stuff I'm going to hide the terrain and this will be better just on a regular plane I'll reset that and scale it out a bit and will include the blue cubes in the physics simulation now and let's do this random force between say 10 and 15 and let's try run that alright so they get scattered down that I'll research and let's change this to 90 degrees so when we run this should get scattered down in this direction so that seems to be working nicely and we can try randomizing the force angle so I'll run at this time and it gets scattered all over the place so that is quite nice and that is also everything that we'll be doing for the moment so until next time Cheers