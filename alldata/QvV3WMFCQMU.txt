hi everyone and uh welcome to my talk on re-implementing signal slots properties and bindings from q in pure c plus plus 17. my name is leon matas i'm from kdap germany we're experts in all things cute opengl and c plus plus uh we do consulting services and trainings that sort of stuff so we are familiar with uh cute per se and um we've actually undergone the challenge of doing exactly this which is re-implementing the core concepts of qt so signal slots properties and bindings in pure c plus 17. um and this is just what we want to show you what we've done and how we did it and introduced you to the new library that resulted from this which we call kd bindings which we're introducing today so i just want to start off with this sort of joke that that um there are only two hard problems in computer science cache and validation naming things and off by one errors so we definitely still have to do some work on these off by one errors however um today we actually want to talk about basically can validation because i want to talk to you today about not just what we did and what we um are introducing into c plus 17 but also what problem it solves and in my opinion this is really solving the problem of cash invalidation but on a really small scale and on a scale where it's really important that it's convenient because a lot of the time you're actually introducing or using caches in your software that you might not even realize that they are indeed a cache and one of the most typical ui problems is really that you have a model and a view and these two store their data separately this is basically the definition of a retained mode googly in comparison to an immediate mode gui where you in an immediate mode gui just draw everything every frame and redo everything um in a retain mode gui of course have your data stored in the view and this gives you a lot of advantages it's more efficient you don't have to redraw everything every time but on the other hand you have this problem that somehow your data must go from your model to your view and typically it also needs to be transformed in some ways some calculation needs to take place for example if you have numbers they need to adhere to the local to the locale so use periods instead of commas depending on whether you're in germany or in the united states with doubles you might want to round them this sort of stuff which your model typically shouldn't really care about this is where your raw double lies you don't really want to have that data there so you basically need to update your cache and your view of that transformed value every time data in your model changes however you also only want to do this if your model data actually changes right you don't want to do this every frame otherwise you're back to an immediate mode gui again which with all of the computational overhead that you have with this um so like i said we're at kdub we're experts at cute which is um the gui framework that is probably the most successful even in c plus plus so how do they go ahead and solve this problem so oh wait before we take a look at that let me just show you basically the naive solution for this problem right so let's say we have this window right here and it has a title and this title is actually just its own dimensions in pixels like this window is 300 pixels wide and 200 pixels high um so an each solution might look like something like this it might have sort of a set title function a set height function a set width function somewhere probably on that windows class um but it also then needs to have a lot of boilerplate right it needs to have checks like the width and height actually change um it introduces a lot of code duplication um for example if the um set height function actually sets the title we also need to do this in a set width function sure we might like move this into a separate function that then updates the title depending on what the current width and height are but this it also still means that our height needs to know about the title so this will just lead to a lot of um problems because if you introduce even more things that are dependent on these variables on this data it just won't scale well it's error if you forget to call this set title in the set width function for example it might lead to really subtle box where only sometimes that update doesn't take place for example only if you drag on the lower part of the window instead of on the corners that sort of stuff so like i said we're experts acute and we're very used to how they do they do this sort of behavior so what do they do well their solution is made up of multiple parts first um you have your model data that's in just pure c plus plus that you then wrap in what they call properties and a property is basically a piece of data a bit of information that also knows about when it's interacted with and when it's changed um and um the these changes are represented in huge by what's called signals and signals cannot just be used by properties they can be used for basically modeling any kind of signal so any kind of event and in q these are modeled as functions so you basically call a function that has a sort of special syntax and that is then sort of notifying the whole world about that this sort of event happened this is what we call a signal that's being emitted and then anyone can listen to this signal and the signal itself doesn't actually need to know or the person emits the signal doesn't actually need to know about um where like who is connected to this signal and all these uh people that listen to or the functions that listen to the signal like what's called slots enqueued um and the cool thing is once you have these properties that sort of notify the world of whenever they change um the possibilities that that you can introduce data binding which is a process that updates and transforms any data that changed automatically and this and then ends up being a very declarative way of coding so in qt this might then look something like this in qt's acute modeling language which is a very declarative way of writing your ui so basically your view but not your really your model your model you want to keep in c plus but you review you can write basically okay i want my title of my window to be the string dimensions plus the width plus like the character x plus height and this is awesome because it will automatically update the windows title whenever the width and the height changes and it will just do this by encude they call it property binding or more generally data binding where a piece of data for example in this case the title actually knows about how it's calculated and where its data originates from in this case the width and the height and then it connects to these properties automatically behind the scenes to make sure that whenever the this source data changes the um resulting data is also updated this is basically a cache right the title is a cache of that calculation so the question is well if qt's solution is so great if it works so well then why don't we just use cute well for one acute actually depends on its own meta objective which means you're really forced into this way cute things about objects which is very specific and not really um as free as you want from your c plus implementation usually uh there are a lot of limits on what you can do with the queue object so um you also then kind of want to avoid all of this boilerplate that's associated with cute part partially because of its legacy for example even here you still have to do that check that your width is your width is actually not the existing width this sort of stuff and crucially qt also requires a special compiler or more pre-compiler sort of the meta object compiler that then can translate this whole cute meta object system with these signals and slots that even have a special syntax into normalc plus and in many cases you just might not want to have this special compiler right you might just want to run this on your arduino but you can't because qt won't run on this arduino because it's just way too big so what did we do well we started to take a look at c 17 and how we could actually achieve this same goal of data binding of reactive coding and modeling of events in a clear and precise way that is available in pure c plus plus 17 because um data binding itself in qt is actually not supported in c plus it's only available like i showed you earlier in their qml modeling language so to get all this started we first need before we can even look at properties and data binding we need to look at signals right the mechanism that has to model events that's your model changes so we just want to take a look at how this will work in c plus plus how we can declare a signal and how we can use it so first to create a signal we might actually want to have a instructor or class person that sort of just has two things that it can do very simple it can speak like it's a person it can speak and it can also listen to other people speaking right so for this you just go ahead and create your listen method that just says okay i received a message from someone like i heard someone say something and i also want to be able to speak and how would you model this in normalcy phosphorus well you could um you could for example use they're just functions then call some connected listeners or something like that or you could model it as a signal right and we just went ahead and said okay a signal is just a normal object this is like someone mentioned in the chat actually very similar to a boost style system that also introduces signals but we'll actually go further than this with our solution and focus on more easy ease of use instead of some of the goals that boost some uh tries to solve so um we then also say okay our event needs some sort of data associated with it this data isn't really permanent it's just something that is associated when this event happens for example in this case the string that gets emitted so um different to cute though signals in our case don't have a return right here because we thought that this is really boiler clip plate and queued you model a signal as a function even though it really isn't um it doesn't have a return value like it's just an event that happens the thing returns from it um so this is one difference we have to cue but it's also simpler this way because you don't have to actually write like my signal returns void even though it can't really return anything anyways um and then how do we use these signals so we can just create two persons the two people alice and bob and say okay um on alice i want to just use this speak signal and connect um a receiving function a slot in q terminology to um this signal we want to say okay every time a alice speaks we want bob to call his listen method so a slot can be a member function in our system just like in qt or even any other callable object this can be a lambda or anything else that you um implement the function call operator on basically and once you've connected these the signal to as many receivers as you like you can emit it and when you emit that signal it will then automatically call the slots and therefore you'll get both that bob received the message because um remember the listen method just says okay the name of the person plus that they received the message and it will also call our lambda which will then um end up printing alice said have a nice day and this is really good because alice doesn't need to know who is actually listening to her and you can model all sorts of events like this for example um input events in your command line could be a signal whenever the user enters some sort of data whenever something changes this sort of stuff and this then actually leads us to properties in c plus 17. like i said with qt you had these properties that could that know about whenever their data changes and in q this is a relatively manual process you actually need to associate um signals to these properties manually and we actually opted to make this a bit simpler because we want to first focus on making this easy to use and making it much faster to write this sort of code so we just opted to say okay a property again is just a normal object you can put it anywhere it doesn't need to be in a class your class doesn't need to inherit from anything it can even be a global anything and as matthias mentioned using an overload of the function operator instead of the emit method yield and i syntax as well um that's actually true and uh if we don't have that yet i think we should consider it um we do have that for properties though to access them that that's definitely a good suggestion so um properties like i said are data that know about when it changes so that data of course needs to type in our case it could just be a string and um properties can then just be constructed like any other object right it's like a string you can just construct from control point and no problem and then what do you get from this property like why go through this hoop why add the property a tag to my data right the good thing is now that your property will expose certain signals to expose certain signals as features that you can use to for example be signaled whenever the data changes there are multiple signals available for example a property will notify you when it's destroyed which is also good to avoid dangling pointers it will notify you whenever it changes and give you the value it has now and it will also notify you even before it changes so that you can react for example shortly before that change actually takes place and um it can also then of course that signal be connected like any other signal you can just call the connect function on it you could in theory even call the mid on it from the outside but you really shouldn't do that um and again we can connect a lambda to it that just prints this out this value which is actually a really great way to debug your workflow and the [Music] this is a really good way to just get logs for example of how the data changed throughout your execution and that's a really good way to find bugs and sort of stuff and unexpected behavior so then how do we actually use this well we just assign a value to our property right this is the easiest way uh to get a change and in this case we'll um just print this value to standard out so it will just print property submit signals when they change and now what do we get from having these properties that know when they react to something because this is still very similar to what can be done in cute even though it's much faster to write because you get these signals for free well the great thing is data binding with properties you can actually start creating something similar that we had before where we just say okay we want our data to know where it's coming from and we can do that in pure c plus so to do this we can first actually just declare certain functions to be usable in data binding you only need to do this if you want sort of a bit of syntactic sugar there are ways to get any function working in data binding um as long as you wrap it in a lambda basically but if you do this this will be done for you and it's just much easier to write because what you can then do after you've registered them basically for using data binding is you can write basically the same code that we had in qml which is at a much higher production level much less um much less performant is you can just write i want a bound property so a property that's bound to certain input values and have that be defined as a calculation you can just write i want my title to actually be the dimension the just the string dimensions plus the width plus x plus the height and this will work this is this is working now in c plus 17 with our library um of course it's not quite as simple as it was in qml you still need to call things like tostring because we're in c plus and types are actually important and the feature so once you do this um we can for example again use that value changed signal on our title property because this is just a normal property like any other and connect to it so that we get nice debug output so that we know what the title is and now all right and of course you can just use any operator and registered function in this sort of expression and like i said if you wrap your expression in a lambda and give it the properties manually you can actually use any function even if it's not registered um and then what happens when you for example reassign the width is the title will immediately update before our width and height was 1920 by 1080 so our title was dimensions is 1920 by 1080 and if we reassign the width the title will immediately change it will update um to be dimension 500 times 1080. perfect this is what we wanted we wanted to not have to worry about this right we wanted to have a cache of the title that has the correct value but we don't really want to manually update it every time and this is exactly what happens and of course the same happens if we reassign the height it will also automatically reassign the title and with cute this is also sort of as far as it like as good as it gets you however do have a bit of unnecessary calculation in this so because we reassigned both the width and the height our title updated twice and typically because we're not rendering this immediately you wouldn't actually see this this was that this is an unnecessary calculation and this like isn't really a big deal right um however if in some cases you might actually run into problems with this because you're just evaluating intermediate results all the time so for this what we've actually managed to do is add deferred evaluation to our data binding or i i like i'm sometimes like to phrase it is controlled evaluation so with a [Music] data binding in our library you can add what's called a binding evaluator and if you just add that to your call to make bound property you don't have to change anything else just add the evaluator that you instantiate somewhere else you then will not get changes immediately you will only get changes to your properties when you actually call evaluate all on the binding evaluator that's when the title in this case for example will be updated and this um at first might seem like it's a bit odd because didn't we just want to solve the problem of cache and validation we wanted to not have to manually do this um and for small cases like this and this isn't really the best use case that's true this is a bit of a toy example but there are a lot more powerful things that we can do with this like i said i like to call this not just deferred evaluation but also controlled evaluation because what we could for example do with this is control the update frequency of our entire for example ui we um sometimes in with the ui get this problem that we have data that changes really rapidly and we can't really show that in the ui like it's just not readable if once every 60th of a second in like in 60 fps this changes um so uh like the you have a question about uh whether signals are sent immediately in the presence of an evaluator um yes and no can you please post the q a about this and we'll get to this later um and just generally uh for the chat please uh don't ask any more questions in the chat you can really post them in the q a and i'll get to them at the end of the talk uh so we could we could now solve this problem of um having data that changes way too frequently for our ui by just adding a binding evaluator that all the data bindings for our frequently changing data is associated with and then we could just control that update frequency we could say okay once every second or 10 times a second five times a second update that binding evaluator and then you'll get your ui that reactively update updates every time like once a second so that you can still read the internet emitting values but it will still update and it will still stay coherent just with a fixed frequency so this is where this is really becomes really powerful and of course you can still use it for its original purpose which is deferred evaluation if you want to control the calculation of intermediate results uh so you might ask like okay how does this actually work like what am i buying with this [Music] and with kd bindings we are actually doing what your compiler does and we are also using the compilers methods to generate an abstract syntax tree out of any binding so we first identify the leaf nodes of whatever calculation you have for example whether a property is involved somewhere and also what other leaf nodes there are so constants for example and this is done automatically by your compiler by using special overloaded functions for example like the tostring function if you declare it as a function it will just overload to string to work on properties but then that property then that to string method will basically start that construction of the abstract syntax stream and it will once it has identified property somewhere start creating these nodes in in the abstract syntax tree so for example the tostring operator will be one of those nodes and um once nodes are involved in any calculation for example the in this plus calculation we have an overload that knows okay if we call plus on a property or on a node we actually want to create a new node and create a binding from this and this is how we can create the entire application text tree just by overloading a bunch of functions and like i alluded to earlier there are ways to um to sort of optimize this if you wish if you just want to use a single operator for example you can wrap your whole code in a lambda and that will then just create one operator node for you instead of creating this entire abstract syntax tree however you do get benefits by using the approach from kd bindings which is that should a change happen for example in this case our height changes we then can move up this tree to identify that okay well our height changed right so we actually don't need to recalculate half of this string it will stay the same and this way we can actually keep reevaluation at a minimum because we know which parts of the calculation need to be redone [Music] when ever something changes we only redo that that part of the calculation that's actually necessary so for example in our example with the width and the height previously it's actually not that bad when when it comes to duplicate calculation we'll only redo the calculation for the subnodes that actually changed one thing that i should probably also note note is that in kd bindings you only have um a differentiation between properties and constants and anything that's not a property will be constant in your calculation so if you use a variable that's not a property but just a normal c plus plus variable it will of course not be updated with um new kind of re-evaluations of the binding it will behave like it was a constant and it would use the value that was um that was in that variable when the binding was constructed um so and this is just how how it works then we can reevaluate all of this now whenever needed so the question is how does this look like in real world use like is this just toy examples or can we actually use this and we were actually tasked for a customer project to re-implement cue camera lens but not cute and in this project we are actually already using kd bindings very successfully a large performant project and this is what the camera what a camera lens looks like in qt it has a bunch of properties um and for all of these properties you actually need to define setters and getters manually and then you also need to declare and the signals that all of these properties need right this is a lot of code uh in this case it's like three pages worth of code whilst doing the same thing in pure c plus without qt actually only takes up one page of code and this is much more readable right we even have more white space in the in this is like half of this is just padding in white space and what this class does as an overview is basically you have a bunch of values like left right top bottom the field of view and the aspect ratio that in the end end up defining a projection matrix which is one of the basics used for 3d uh computer graphics to create a virtual camera and whenever any of these values changes if the field of view changes for example you need to update that projection matrix and so this is basically just a value store for all of these values that has a projection matrix as a cache so again we're back to this problem of cache invalidation and if we look at how this works in qt we actually have to again do these manual checks for equality we have to manually emit a signal for every setter and manually update our projection matrix and have this duplicated this code is duplicated for every setter like you saw this is what like h properties then define this projection matrix every for every set every setter of this looks basically the same it's all this code etc this is all boilerplate code this is something you just don't want to write you don't want to maintain because if you just do one error in in this if you forget to update the projection matrix in any of the setters your code will start to have subtle bugs and how does this well what does this look like with our new kd bindings library well you actually need no setters you need no getters those are part of your property you only need to say okay my projection matrix is again a bound property um that just updates the projection this is a function that's just implemented like any other function and uh that then is again declared for use in data binding to um and to take all of these properties so vertical field of view aspect ratio left right top bottom to calculate the projection matrix and any time you change any of these properties just like you do down here where you just say okay i want my far plane to be 10 or whatever your units are like this might be meters or whatever you automatically emit the signal and you also automatically update the projection matrix this went from i think it was like 300 lines of code in qt plus comments with documentation to basically 50 to 100 where most of this is now actually taken up with the mathematics that you need to create this projection matrix which should be the core of this class and this is really what all of this is about in our opinion we want to be able to write code that's meaningful that's declarative that's easy to maintain and this is where this just comes in perfectly we now only have code that actually cares about how to create a camera lens and uh uh yeah this is just um very very easy to do now and uh then it actually says a function with nine arguments really yes in this case this is sort of necessary because of course this is the entire problem we have a one piece of data that is calculated from nine different values and before this was all done incoherently in all of the setters and uh done with a lot of code duplication but now you can just pass all of these things into one function and it will just work of course we could have put these instructs and so on and so forth then possibly make this a bit better but we basically just reimplemented q camera lens so this is how it looks um right and the good thing is for you and hopefully the rest of the plus plus community as well is that all of this is now available as a library that we call kd bindings so what does this offer you it basically offers you all that i've shown you before plus a few minor details and of course this means you get signals and slots you also get properties that you can just template on the contained type which means they're compatible with practically every type whereas for example qt has quite a lot of restrictions on what types of cues and properties and you of course get property bindings for reactive coding right you are able to write what you were previously only able to write in code like qml with that has a much higher abstraction level than c plus plus and for this you also get lazy evaluation of these properties bindings or controlled or deferred evaluation in whatever context you want to use it which is also something that's not actually available in qt at all at the moment and also all of this is available as a standalone header only library so you have no dependencies you can just put the code in your project and it will just work and as long as you have a reasonably modern compiler that supports cpl 17. and of course because this is only c plus 17 with no additions it can of course also be used in your cute project for example if you want to manage your c plus plus backend in a also reactive way you can just use this as well and then plop this into acute property and have that updated south as well of course this is not perfect this is our initial release today and there are some limitations for example kd bindings is not at all threat safe at the moment if you have signals moving between different threads because your functions are connected um two objects that then start something on a different thread this will all not be locked and you need to do all of this locking manually and also because we're using um c plus 17 with very heavy templating for just a lot of the generality that we get it does increase compile time um quite quite considerably in some cases but then again um we personally prefer having that increasing compile time over income increase in runtime and it will also only be available in c plus plus 17 or newer we do not have any plans to move this to c 14 or 11 but we feel that this is something and this is a good basis to have this working and it should work in c plus plus 20 then of course as well [Music] and of course we also have some future plans that where we already know sort of how to do this and that will most likely end up making it into kd bindings in the future which is for example mutable access to properties so this is a general problem with properties where they need to know whether they changed when you actually don't want to reassign a property but you actually for example want to have a vector that's a property you don't over want to overwrite the whole vector every time you probably just want to have it change single objects in it or that sort of stuff and that and that access we have plans for but we just didn't get around to implementing this yet we but we also didn't really need it for our projects and also our signals are currently the size of two pointers we want to get this down to the one pointer um when uh whenever a signal is empty so that you really don't need to worry about adding signals anywhere like you could just put them in they don't take up a whole lot of memory they basically don't do anything on allocation um they use a sort of pimple paradigm so you just don't have a lot of overhead by adding a signal because a lot of signals will stay unconnected and that's fine you just want to be able to have that opportunity and in that case they'll also not cost you a lot on emit right that they'll just be an all pointer where you can do that null check and it will just um it will just not do anything and we are also looking at whether we can with c plus plus 20 for example construct properties and bindings at compile time because with increased reflection and for example memory allocation at compile time we might be able to pull this off because at the moment all of these bound properties are created are just created when you run the code and we of course also want to focus on benchmarking and see where we can improve performance even more and we also have this problem because we are templating a lot that we um can sometimes get unwieldy compiler errors and we have already worked on some of this but when add more assertions at compile time to make sure that arrows are as readable as possible because that will reduce your mental strain as developers as well and now how do you get access to all of this uh amazing content well it's actually really simple we've made it available as a download from github i see someone earlier um already posted this in the chat and we then just recommend doing a normal out of source build for it configuring cmake if you don't want to use the command line just use your graphical tools for this um whatever whatever works for you and uh then we do recommend installing it on in your system just so you have available at any point in time but of course you can also either add it as your subdirectory to your project or even just copy the header files over we just don't recommend that because with an installation you can easily upgrade to newer versions in all of your projects and once you have done this you first should definitely make sure cpu 17 is enabled if you do not if you do not do this on a lot of machines you will get errors because for example stood optional isn't known or something like that because you're on the old version of c plus so make sure to use c plus plus 17. like i said it's not enabled and it won't be supported for earlier versions um but after you've done this you can just use find package because if you installed it it will just be available as a normal cmake package and then you can just use as normal your link libraries to link to kd bindings and of course if you want you can also add it to the subdirectory for example as a git sub module in your project and in this case instead of using find package you can just use add to add kd bindings to your cmake project and of course in this case you also don't need to do the cmake install and all of this and once you've done this you can just get access to the exact same examples and the exact same code that i just showed you which is in the kd bindings directory if you just installed it maybe it's somewhere slightly different if you're just adding it to your source directory and then you you probably know yourself where to find this and of course don't forget to use the namespace all of kd bindings is available in this kd bindings namespace there is also a sub namespace called kd bindings private just don't uh use anything in this if you want to have api reliability that stuff in there might change at any point um and dennis also mentioned to use fetch content and that should also work and of course then all that's left to do is to enjoy kd bindings and of course like i said kd bindings is available now on github the docs are available on our website we also recommend reading the getting started guide on our docs to get familiar with everything we have a bunch of examples there so you can play around with them and see if the behavior is what you need and all of this is available under the mit license so using namespace not allowed over here well in this case you'll unfortunately have to write kd bindings uh a lot but i hope you'll uh get used to that quickly uh again yeah so like i said it's available under the mit license and so that means it's freely available but doesn't come with any warranty of any kind if you need that and need commercial licensing for example you can just contact kdab for a different licensing options we are flexible in that regard all right this is um the talk for now and i'll just see what the quest what kind of questions we have right now so let me read the questions for you um i'm ordering them on the most uploads to the first one is what is happening in the case of a psychic dependencies between properties surely not a good idea in general but do you discover that or is there any um so that should be sort of hard to build currently but we're not really discovering that no um if you all if you create a property um that directly from a binding you actually can't build a cyclic dependency because then when you create the first property you can't or you can't link to the second one um but if you later resign binding you should be careful about this okay can you elaborate on what's the impact on compile time using kd bindings uh we haven't measured this per se we don't like i said benchmarks are still uh to do on um on kd bindings but it does add i'd say maybe half a second like from feel uh if you use like basically all of kt bindings um in in a but i don't know if this like profile like the small examples that still take a while to compile but it's in the order of like a few seconds not in the order of minutes okay next question on qt signals and slots just pop across threads so you already mentioned that yes i think that should be answered already in the stream but no we don't have uh support for that unfortunately yet which is one of the reasons that you might still want to consider using q directly there's another another question whether it's a curable like a cute connection i guess only if you do it manually i guess uh sorry what's the question uh a qt signal uh you say it on the on the connect state uh call on your signal can you state and connect call that you want to have a something like a qtq connection don't think there's integration for that because it's standalone um i don't think we have support for the cute connections but you do get a bit of access to um behavior of the connection when you connect um you can well you can cue them in a sense of that well no no no not on signals you can defer evaluation of uh properties but you can't do that on a signal signal will be emitted immediately however there are ways to for example block a specific connection for a period of time when you connect a signal you get what's called a connection handle with that you can use to disconnect the connection or for example block it for a period of time okay next one is uh if you have measured the difference between qt signals kdp signals boost signals i guess you're still working on that yes like i said we're still working on the benchmarking part however we can say that we have used it in a project that depends on being performant in general and we didn't have major issues with this we of course don't recommend using signals and slots for your most uh for your compute bound hot loops and that sort of in that sort of calculation um but rather for using it where you want declarative coding first and of course you still want to do your manual um loop iterations uh on on like arrays that are nicely laid in cache and not have that all be properties yeah next question was a bit more curious about would kd bindings benefit from using cpus plus 20 codings um that's a good question possibly i could see there being benefit to this um i'm not sure if that might not also run into problems because we are not like i said not synchronized and threat safe in any sort of way i know core teams aren't threads per se but they um should probably might run into similar issues next question is the width and height bond property example you said that only parts of the string needs to be reconstructed when one of the properties changes does that mean that the evaluation tree keeps copying all the possible substrings and is a big overhead on that so yes you do um store if we do sort these sub calculations we of course try to keep this as at a minimum but we have to do this in order to re-avoid to avoid this re-evaluation and this is an overhead but only but mostly in terms of memory and the good thing is that it's controllable if you don't want to cache this like i said just wrap your whole expression in a lambda and pass that lambda with the properties to this call to make bound property and then you'll only get one operator node and you'll only get the result and not caching for every step yeah thanks for clearing and just another question on uh when you use the evaluator what is exactly delayed is the signal delayed or is it is the processing of the signal delayed or is it only cached somewhere so that was one of the questions earlier right also about whether that will also skip signals from being emitted and how it works is that the root signals like the width and height for example in our previous code those would immediately emit their signals nothing would change about their behavior and the abstract syntax tree would also be notified about this change so with the fx syntax 3 would also know that it has to be updated in the future which also means the binding evaluator will only update the properties that actually need updating but it will just not re-do this abstract syntax recalculation at that time it will just mark it as dirty and then when you evaluate all it will then re-evaluate update the property that is the result of this calculation and of course the property that is the result so in this case the title will only then emit its change signal it will only do this once it's reevaluated because before the property itself doesn't actually know that it's dirty it that's part of what the binding evaluator keeps track of um just for that curiosity when you access the property that knows the value is dirty will it update immediately once you access it or will it report the old value until it's updated from the evaluator in this case it will um report the old old value so in that case it's not really lazy sort of um but there it might be possible to change this in the future though because binding evaluators are currently um something that you could for example write your own version off but that's not yet part of the public api so that might also be a good suggestion for the future okay then we have another question about the evaluator when it suppresses updates um could you couldn't you defer the evaluate to the next drawing frame eg by setting dirty flag and then evaluating all dirty evaluators per frame rendering or before you render the frame actually um so i'm not quite sure how to answer this but you will have to call this evaluation evaluator in any case however the binding evaluator itself keeps track of what's dirty so if you call evaluate all the mining evaluator it will only evaluate the properties that actually need updating so what you could just use every frame called binding evaluator evaluate all and if nothing changed it won't do anything so that hopefully answers like the concern you have but not quite a good question because i'm not sure i i i know how to uh i don't quite know what you mean maybe a good point to hint everyone we will meet in the track b room after this answering the questions so we can go deeper on all the questions you have and if you have to like write four sentences to ask a question then it might be a good candidate for for using that in the room yes definitely getting a bit more live action on that okay and there's the final questions i see so far is do you have a code in package or do you have plans for publishing accounting package and no we currently do not but maybe you could package it yourself that'd be great as well but then again it's also just the header only library just copy paste source and you're done so we have three questions i've updated um yeah dude the first one is just what does the boilerplate refer to i think it's about the qt boilerplate you talked about i think this was clear um well maybe if you want to know what boilerplate itself means if you're not familiar with the term that just means uh like code that you have to write that doesn't really add anything uh to sort of the semantics if you will then can your bindings be bidirectional and not at the moment no unfortunately and the final questions i see now is yeah we see package and conan and so on uh yeah but um yeah like i said if someone uh wants to um move this into a package manager we'd have of course love that um we just haven't done that ourselves we mostly work with cmake so that it's uh that we don't depend on a package manager but we're not opposed to that as well okay then it seems we are done with our questions thanks again leon for i thank the nice talk and anybody who wants who can meet us again in the track room for more questions and discussions about this topic in the lounge right not in the room yeah in the launch okay perfect all right um well thanks everyone uh great to have this opportunity and see you over in the lounge