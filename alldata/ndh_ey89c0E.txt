welcome to my talk on i'm better um i will first um introduce you to embedder i'm showing um a couple of examples uh and then we try to look at it under the hood um so what is i'm better um well on first side and better is an ide for c and as the name suggests it's an um dialect of c that focuses on embedded systems and beta came about 10 years ago as part of an industrial research project and its um sable release was six years ago and it's since been used um successfully in industrial projects and it's also the basis for uh commercial products um now the core of umbrella is open source it's available on embedded.com and on on github um i'm not part of any of this i'm just a happy and better user um at um zwieco university where i'm work um and last year at um meeting embedded i you know talked to to some of the attendees and i mentioned i'm better and no one actually knew about i'm better and i think um there are you know lessons um to be learned even for for c plus plus or um rust developers even if you are not a c developer um there are lessons to be learned and that's why i handed in this talk so let's see um what is i'm better well this is i'm better well nothing really exciting here um it's just ordinary c um so why am i showing you this well um things get more interesting um when you zoom out and look at the whole program here um there there's there's funny things on on top um let me see here's a pointer here so there's you know something called model um okay um then there's this imports and constraints and then there's this exported um keywords um for the for the main function okay um obviously there's something you know different from um standard c but still it's not um that's that interesting i guess but embedder has to offer what they call a cleaned up version of c99 for example in instead of um header files they have a cleaned up module system with imports and exports and that is what we just saw in the example um so we import nothing but we export the main function and they took away all the fun um by not having macros so there's no preprocessor they they added um strict typing um for example there's a dedicated type for boolean which is not um easily convertible to to index there's casting available but um they are separate they are separate types um and they they added anonymous functions um which is quite interesting and also um a syntax for for [Music] arrays uh from these um [Music] and from the embedded um c embedded c excuse me from the embedded c um standard c gets generated so on the right hand side um you can see um the the code that would um get generated for this little program on the on the left and it's actually quite quite readable for a co-generation approach now in the beginning i mentioned that embedder is of course i'm focused on to the embedded domain and what they also added is physical units um so for example you can have you know integral types um annotated with uh a unit seconds meters meters per second whatever and this is part of the the language it's not and not not um annotated by means of comments or something it's it's actually part of the language and um of course you get um language support um your compiler which will tell you that you're doing something wrong with the the units um that they are not compatible as you would expect and there um many more languages i will show you some um in a bit and um all these extensions are called domain specific languages uh so on top of the language for this cleanup c there are you know extensions for physical units and many many more extensions for example they added a domain specific language for testing which exposes concepts from the from the testing domain right in the language you know like test cases and assertions and so on there's also composite physical units and conversions between units um and many more of these extensions for example for logging which can be surprisingly difficult in embedded systems and from a software architect more software architectural point of view there are interfaces and components that implement those those interfaces realize those interfaces and there's um support for requirement specification and requirements tracing for um documentation and um defining inline tests right in in the in the documentation which is really nice and traces to other parts of the of the implementation right from from documentation and there's also support for variability um configuration management so um product line engineering and a lot more of these extensions are available as part of embedded core or um commercially available or um available on github for example freely available and of course you can build your own language extensions um so did we here at um spicker university um we um ported osec to lego mindstorms and did so using some of the extensions available for embedder from the robotics and real-time domain and we added our own extensions on top of these um standard embedder extensions um as i said you know a lot of extensions um come with um embedder already um i can't go into all of these um i will show you some later but there's there's a lot of abstractions available um as we shall see in a second um one of the more interesting extensions um available for for embedder is um and domain-specific language for state machines so um they added a language that makes the concepts from the state machine domain explicitly available in in the um in the better in the language um so they're you know obviously state machines and states transitions um guards actions and and so on the the usual suspects you would um expect for state machines and um the the way embedder approaches these extensions is quite interesting and i will go into more detail in later slides but um for now um just let me say that the domain specific languages that come with embedder they offer well-defined concepts by means of an abstract syntax or meta model and you you get high level extractions with rich semantics but still because there's this c base language still tight integration with the c programming language and for example what this explicit definition of concepts give us this visualization of state machines so you can you know easily visualize state machines using graphics or or whatever um so on the right um you can see uh a few not not an editor um we will come to the other in a second you you can see a few of the state machine that was defined on the left-hand side uh and you can get graphical fuse for you know um other um parts of a system you know more behavioral stuff with something similar to uml sequence diagrams for example so these domain-specific languages they um give us of of course um productivity we we can think in in terms of um the the abstractions of the problem domain um but they also give us reasonability so we we get model checking [Music] we can check for pre and post conditions of modules and interfaces software components and and interfaces and we get formal um verification uh for example uh we could verify a state machine and see if you know every state can can be reached if um transitions um exiting from from the same state um are unambiguous and so on and um in this example um here on on this slide um you can see that there's something wrong with these guards here and this is done by an external tool um by an external model checker which can be integrated into embedder and as you can see um the the results from this model checker they are directly fed into the um ide um right on on the um um abstraction level of state machines i will come to to that uh i will come back to that in a second so um now i showed you some um of the um language exam intentions of um i'm better um i would like to um look a bit under the hoods um um and discuss um how i'm better um does this and um and better is based on um chatbrain's meta programming system mps which is a language workbench there are other language workbenches available but embedded is based on mps and mps offers something called projectional editing and projectional editing gives us complete notational freedom so instead of having um a line-based and parser-based approach you can do um in terms of notation you can basically do whatever you like so for example you could add tabular fuse to your more text-based editors and that's something that is quite difficult codes if not impossible to achieve with traditional parser-based approaches you could also have mathematical annotations write in your c like functions or you could have um configuration um editor for something like like make files and um this projectional editing is quite different from um more traditional ides it actually feels weird in the beginning but once you're used to this um it's it's really um great um projectional editing means that um the view uh is a direct um projection of the abstract syntax tree um and the f6263 uh is an instance of of the meta model so it's the diffuse a direct projection of the model and editing then means that um users directly modify the the abstract syntax tree um directly modify the model instead of having to go from text via parser to an abstract syntax stream um so for example we could have a tabular editor for our state machine uh there's there's nothing that prevents us from um you know having um columns and and lines instead of this um just line based um approach to um tabular to state machines that we saw earlier and still we get the tight integration with c we can still use c expressions in those table cells well we could also have diagrammatic fuse diagrammatic editing actually so this is not just a few this is an editor a lines and box this editor for state machines and it's still tightly integrated with the with embedded base language with the c dialogue um i'm better users and you actually get what i would call roundtrip editing it's not quite roundtrip engineering but you can go from one um representative representation to to another make modifications to your your program switch to another visualization and the modifications are right there um so you can pick the the graphical annotation or the um the view that best suits your your needs um now after showing you some of the of the features of um i'm better um i would briefly go into how [Music] c gets generated from embedded models as you saw everything you do in embedded is actually represented by means of models and then text model to text transformations are used to generate standard c code that then can be that then can be fed into gcc for example to build the binary and um not only is um c code generated but of course you can build um configuration files like make files and so on documentation html latex whatever model checking configurations for various model trackers and so on um so um because there's this um modern text transformation you can really generate um any kind of artifacts that are required for your projects and instead of having a model to text transformation for each domain-specific language for each extension and embedder actually uses another kind of transformation um called model to model transformations to go from high level abstractions to more lower level abstractions and then to the cleaned up version of c to the base language to a better space language and from the base language they go to um model to text tran they do a model to text transformation to generate c code and build files and um and so on so what else does embedder has to other offer in terms of ide integration there's really great support for debugging um debugging on the domain specific languages level not on the c level so when you debug your state machines you're not doing so by debugging switch case statements in in c code in the code that gets generated but you do debug your state machines right in in the ide on the level of the state machine um domain specific language so that's that's really cool and then there's um integration for for version control again uh it's done on the dsl level so um you know you get different merge um right in for example a graphical view if that has been implemented for this visualization of a domain-specific language and you can integrate um third-party c libraries so that you can make use of these um apis from from embedder there's a ton of material um available at embedded.com um you can find tutorials and scientific papers um about i'm better um so please um check out ambetter.com now um why am i so so fond of um i'm better um well um here at uh zwieker university i'm i work as a computer science professor and i try to teach you know good good tools to um students and and good concepts that might be uh you know a bit ahead of what's used in in industry right now and what embedder gives us is you know high-level abstractions that are still integrated with c and and this is really important um and better because it's based on on mps allows to combine different languages different aspects from from different domains because usually you require um concepts from different domains to build a complete system and and some of the more traditional approaches like you know simulink and uml system they tend to focus on um a single domain or um it becomes really difficult to combine concepts from different domains so here's a very small example of how languages can be combined and better here in this example we have obviously state machines we are defining a state machine but we are using physical units here this small m indicates that um we are checking um the altitude for being zero meters so we are combining uh two different languages and that would be really difficult in parser-based approaches and um this is where embedder really shines um and embedder can shine when combining languages because it's built on the meta programming system which offers some great tools for for language engineering um so because um it's it's based on mps you get tools to build composable and extensible dsls you get tools to build the editors that best fit your user's needs so you have notational freedom um you get other things like um migrating from one version of a language to another um and and so on so um in a way um this language workbench approach um as offered by mps but also by by other tools um kind of helps to to liberate this um language engineering and that's what i really like about um and better and mps in general um so with that i'm finished and i would like um to thank you for your attention but i would also like to thank the embedded team and the mps team for building such great tours thank you and i hope we can discuss about and better and i hope i provoked some controversy um and maybe you know we can get into a discussion i prepared some [Music] some topics that we we might talk about you know why not c plus how much do i have to invest in order to start using i'm better why should i even do it and why are you telling us about i'm better now so i hope we can discuss about this thank you yeah thank you for your talk frank