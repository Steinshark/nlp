welcome to your daily dose of leak road today we're doing the question invert binary tree let's read the question given the root of a binary tree invert the tree and return it to Roo so what are the key takeaways of this problem the first key takeaway is that we can be given an empty tree as you can see by example three the second key takeaway is that this is a binary tree not a binary search tree so we don't have to worry about any properties the last key takeaway is that we have to return the roux so we don't have to make a clone of the tree we have to modify the tree itself so knowing this and given the problem statement we can actually calculate the best conceivable runtime or the BCR and the best runtime we can do is oh then where n is the number of notes in the tree this is because in order to invert the tree we have to visit every single node at least once but what does inverting the tree even mean So based on all the examples and the visualizations that were given it looks like inverting the binary tree means that we have to swap the left and right child of all the nodes in the tree so knowing that let's start thinking about some solutions when we're given a tree problem there's two main ways of approaching this one is a depth first search and the second is a breadth first search and if we do a depth first search there's two ways of doing it recursively or iteratively I'm going to cover all three ways of solving it I'll start with the breadth first search way so whenever we do a breadth first search we have to use a Q and we use this queue to visit each level of the tree and this is called level order traversal and the way we use breadth first search for this question is that for every single node that we pop from the queue we're just gonna swap the children and we're going to keep doing that until the queue is empty because that means we visited all the nodes so let's write the code for this the first thing we have to do is check if the root is none this means that we got an empty tree and if we got an empty tree then we're just going to return none or an empty list now we can start our breath first search so let's start by making our cue and add root to the queue now we're going to Loop through the queue and now we're going to pop the note from the queue now we're going to swap the children so the left note is going to be the right node and the right node is going to be the left node and now we're going to check if we have a left child and a right child and if we do we're just going to add them to the queue now that's the end of our breadth first search so all we're going to do now is return the root the time complexity for this is O of n since we have to visit every single node now the space complexity is also o of n we keep track of every node at each level so we would have all n nodes all right so now let's start talking about the depth first search way the only difference here is that while breadth first search goes level by level the first search goes as far as possible in a branch before backtracking so for this problem every node that we visit we're going to swap the children and then we're gonna go through the swap children let's write the code for this I'll start with the iterative way with a stack all right first things first once again check if we even have a root and if we don't return none alright and now we can start our depth first search so the first thing is we create the stack and that's just going to be an empty list now add the root to the stack and now we're going to Loop through the stack and then we're going to pop the note from the stack now we're going to check if we have a node and if we do have a node swap the children so once again swap the left node to the right and the right one to the left and now add both the left node and the right node to the stack and with that we finish our depth first search so now we're just going to return the root the time complexity for this is also oven since we have to visit all the nodes and the space complexity for this is going to be o of n since we have to have all the nodes in our stack but being more specific I think the space complexity is over H where H is the height of the tree and this is because the max size that this stack can be is the height of the tree all right now let's code the last way of doing it which is the recursive depth for search way this is the easiest and shortest way of doing it alright so the first thing we check is our base case which is if we're on an empty node and if we are then we're just going to return none and now we're going to swap the children so the left node is going to be the right node and the right node is going to be the left node now we're going to do the recursive part where we're going to call the function for the left node and the right node and now by the end of the recursive calls we inverted the tree so now we're going to return the root the time complexity for this is once again o of n since we had to visit all the nodes in the tree and the space complexity for this is also all of n since we have to go through all the nodes but be more specific the space complexity is once again of H which is the height of the tree since we're still using a stack but this time it's the recursive stack and the max size that the stack can be is the height of the tree alright so that's all the solutions to this problem and if you have a specific question you want me to go over leave a comment down below and I'll see you guys in the next video so see ya [Music]