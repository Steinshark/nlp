All a library is, is a series of code routines that you're going to reuse. So rather than actually writing it yourself, you'll go and get it from something that's already been written: a code library. So that's where the idea comes from, you're reusing blocks of code that have come from somewhere else. Implementationly, you can do that in many different ways. I mean the simplest thing is to think about a program; So if we think about a programming language like C, it's made up of a series of functions, so we might have a function called int comp, and--that doesn't actually have any parameters--and that's gonna call another function, and we'll call it printf, and it's gonna say " Hello Computerphile." So that's a thing, and this is calling another function, and when we compile a C program or any programming language the computer takes that code and converts it into machine code and then we execute that machine code version. Whether we do that instantaneously for interpreting or we compile it and execute it later or a mixture of the two-- immaterial for this point of view. So, we've got to find this printf. Now we could just have that defined in the program straight after so it might actually say something like void printf whatever the implementation of printf is. There--that could be in our source file as well and then that might use something else and so they would all be and so we could put all the code we need for a program in one file We compile that; we convert it into one machine code program; and then we can use it. That's great-- Except our program is going to get bigger and bigger and bigger and bigger and bigger, and as you write more and more programs, You'll find that actually every program is going to use printf, and every implementation of printf is going to be the same. So what you probably would do is you would start off writing a new program you say okay, I need a printf so you go and find a copy of the previous printf and you cut and paste the code from that one into your new one and You carry on using it and and so on. So you could just do that, but your programs are still going to be huge long things and finding things inside there is going to be complicated. So what you start to do is you say well, actually I'm going to collate various different routines there You know, I probably use printf a lot. I probably need something to read from the keyboard, scanf in C terms, I probably need something to do some file I/O and so on. Then you end up with a series of routines that you pretty much going to use in every program, and so you collate them together And then when you write a program you copy them all into that program So that's what you could do. - If some of these are used that often, why are they not embedded in the programming language itself? So why is it because you might not need them? So why does C not have a print command? Good question. You'd have to ask Brian Kernighan. That actually was probably around at the time there but I mean you could you could take a sort of a purist view of this is that It's printing part of the programming language, or is it something you want to do with the programming language? as C demonstrates you don't need a print command in your programming language because we can implement it separately So you can make an argument that you don't need it in there. You need your programming language to have The basis that you need to write everything you wanted to write. Okay, you want a library to do image recognition or something? Do you build that into your programming language? Where do you stop you've got a you've got a divide this somewhere? Let's keep the language is simple and then it makes it easier to write the compiler If it's easy to write the compiler, you generally know it's relatively easier to check the code works properly It's simpler and particularily if you think about the computers that C was developed on, 64k was a luxury Then it makes sense to keep these things small. So anyway, let's say we've gathered together some routines. We're using lots and lots Printf, scanf, file I/O,..  Those sort of things. We're going to use some of that. So we just collect them together and so what we do perhaps is rather than starting with a blank file and copying them in, we might actually put them all into a file and then when we want to start things, well we copy that file and just add our new code to the end of that and things Which is okay, but it seems the wrong way around to do it So what you do is you modify your language to actually have a way of including that file. Rather than having all your things in there, you start off saying "I want to include something", and then we'd write Comp routine as we had before and all that include things says in C particularly the hash in front of it is copy the contents of that file as If it was at this point in the program It literally is doing text substitution this way it's not doing anything more than copying the text from one So rather than reading the files from one father reads from the other file and then carries on it's like concatenate two files together You compiler just that and then it compiles the whole program. Now, that's not what C is doing. But that's the general idea behind a library. We've taken a set of routines that we use a lot and generally, we'll have them that do various useful things that are thematically similar and we've combined them together and we're just going to reuse them. So it's a reusable library of code in the same way we can have a library of books where you can go and find particular information and you get a specialist library , you might have a science library, a sort of fiction library and so on. And in the same way you might have a a sort of file I/O library, you might have a window GUI library, you might have an image recognition library, a networking library, and so on. You could just include the source file in there and let it work and let the compiler compile it, but actually if you think about it, we're taking the same a block of code and we're going to convert it to machine code and that's a deterministic process, it's going to produce the same machine code. Unless we use a different compiler or we change some of the options. And so actually the next stage of our sort of gathering libraries, is that you rather than combining them or linking them together at the source level, is you say, actually, "okay, I'm going to go and compile all these libraries to machine code ahead of time, then when I compile up my program, I'm going to compile the new bits I've just written and I'm going to link them together with the stuff I've already written." There's the library code there's the stuff that I've already compiled up using every other program So if we take something like printf which is in part of the standard c library, so it's a library thing in there. Generally, we will use a pre compiled version of that. We don't where we say hash include stdio.h. We're not including the source code for Printf we're including the source code for that tells how to call printf It just lets say you need to call it with these parameters and then it will work What actually happens is in another program called a linker which takes the binary that's not even produced for that the binary you've produced and combines them together into a single binary program in the right format that the operating system needs so that you can load them all in one go and run them and it calls printf to do the things and make it work. So that's all, that's all the library is, there's a collection of code routines that probably have been compiled and then linked together to form a complete static binary that can be used. Now you don't have to do it that way If we do it that way then we end up with one binary which has all the libraries copied into it. That's what's called static linking, because it's just one static file, everything you need is in there. You can also do what's called a dynamic linking which is a dynamic library where basically all you're doing there is you're delaying that linking process until the program's loaded and then the advantage of doing that is that you can choose which one you load in and as long as you know where to jump to and how to update things to make things connect together, then you can make it work. So, all the library really is, whether it's a static one or source library or dynamic code library is a collection of code routines that have been precompiled often that you then link into your program to make it work and it jumps into that other bit of code and then jumps back into yours. They don't even have to be written in the same language, so at some point inside printf, it'll probably call a bit of machine code To actually make the operating system print out these characters on screen and so on. See that this is also connected to the same the bottom left side of this switch, and the bottom left side of this switch, and the bottom left side of that one, and so on all the way along, we could follow this trace until we get to the last one. It actually changed to the top right for the last couple.