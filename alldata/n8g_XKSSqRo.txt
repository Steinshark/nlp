if you've been looking for a dev board and the same form factor and price of the arduino but for learning about risk 5 architecture then boy do i have the board for you today we're talking about the red 5 board by sparkfun which hosts the freedom e310 32-bit risc-5 processor as well as an embedded segger j-link for debugging in this video we'll go from start to finish and i'll show you how to set up your build chain and write code for this board and show you how to use it to learn risk 5 assembly also follow along with the tutorial and watch till the end because you don't even actually need the board to run this code i'll show you how to emulate it in this video as well before we start i want to talk about the board a little bit just kind of show you the parts here on the right is that segger j link i was talking about built into the chip and on the left is this freedom e310 a wake button to bring the board out of a deep sleep and then a reset on the right also show you here that there is a usbc adapter pretty cool the first board that i've ever had that has a usbc adapter as opposed to micro and then we'll show you the form factor of the sport compared to others so pretty pretty regular size if i bring it over and compare it to the arduino you'll see it's almost a perfect match when compared to the form factor of an arduino and then putting the arduino down we'll take a look at the raspberry pi pico as well and see the comparison there and one more thing before we go it's hard to talk about this board without talking about its specifications so first this thing comes equipped with a freedom e310 32-bit risk 5 core also 32 megabytes of q-spi flash pretty cool it's a lot of room for a lot of applications as previously mentioned an on-board segger debugger to get an interface into the chip for on-chip debugging a clock on the chip clockable up to 150 megahertz airing near uh you know early generation laptops pretty crazy clock speeds and then obviously your standard uh peripherals be it uart pulse modulation etc all right and with all that fun out of the way let's put these boards down and let's write some code okay guys let's get coding so to get started we're going to actually plug the board in here and i want to show you guys when you plug the board in you actually get two devices they'll show up for me at least as dev t2y acm 0 and acm1 so acm 0 is actually going to be the character device that is the serial port on the risc-v board so if you print anything with printf or puts or right to the uart base it'll show up here i'll actually show you how to get that all you have to do is type minicom if you have any comm installed tack capital d and then the device path it's locked i'm going to actually show you the right window here we go so i'm gonna pull it over here um and we are going to reset the board and you will see that once the board comes up it'll actually run my program so this right here is the boot loader running and then this is the actual output of my program here low level gang so we're gonna write the program that gets this printed onto the uart bus of the device so the way we start doing that is we need to first install a few things first we got to install is the risk 5 64-bit tool chain and we'll use that 64-bit tool chain to produce 32-bit binaries for our board so do that sudo apt install gcc attack risk 5. tab a few times and you'll see this risk 564 unknown elf build chain we're gonna take that and install it let's type my password here you hackers don't get to know it and i already have installed something happens here okay so now we actually get to write some code so what we have to do is you know start a project just as we would any other way we'll use two files today the first is hello.s it'll be our source file for where the code actually lives and then red5.ld that ld is called a linker file and i'll tell you what that does a little later in the video to get started here we need to do some basic assembly programming setup so the first is a line two that just means we have to bake every piece of this code aligned to a two byte boundary that's to keep the processor happy and not hit an edge fault when we're writing through our code um also we're going to make a variable and we're going to call it you are reg tx fifo and this is just the offset into the uart structure on the board and then also we need to get the address of the uart structure which i'll pull up the user guide here and show you where i got this but it's basically at one thousand one three thousand we're gonna start our code in the text section and we're gonna define a global symbol called start and start will actually be the entry point to our code where our code begins to run and we'll start to actually write out that code step one the processor actually boots with multiple threads running so we want to make sure we only actually run with the first thread if we have every thread running this code the code will try to write multiple things to the uart bus and we'll get some weird corruption in our message so we are going to move the control register so special register move into t1 the m heart id this is the machine hardware thread id into t0 and then basically if that thread number is not zero we're gonna move to a label called halt and halt will just be a label that jumps to itself so basically if we are not the zero with thread so for only if we're the other threads we will go to halt and then halt forever pretty cool okay so then we are going to set up our stack pointer so again the device needs memory to function right now the device has no stack there's memory and there's ram on the device we haven't told the device where its stack exists so we're going to initialize the stack by saying sp we'll start at this stack top symbol and i'll define that later in the linker script we're going to also call a function that we're going to write called puts and the argument to puts is going to go into a0 so we're going to load the address of this message we're going to call message into a0 so load address of message into a0 that message is going to live in the dot ro data section or read-only data i'm gonna call it message and it's just gonna be a string and we're gonna say low level gang boom and a new line to print the uh you know the end of the character turn there cool so we have that boom and then so i said we're gonna call a function we're going to write and we're going to call that function puts so we're going to jump and link that's what the l means in the jump in links that means we are calling and not just far jumping we have a function called puts and here we're going to define that puts function so what puts is going to do is puts is actually going to look at the uart base and it's going to index into the reward fifo and if there is already data there it's going to wait and if there's not data there meaning it's clear to send or ready to send we're going to put data there so first we need to load immediate into a temporary register so t0 the address of the uart base so we're going to use t0 to index into the uart structure and use that to see hey is there any data that we need to load or load out of that part of the structure so then we're going to start a puts loop here and the puts loop is basically going to be hey we're going to load a byte that's unsigned that's what this means it's loaded by unsigned uh into t1 from a0 it basically says we're going to pull out a byte from our message remember a0 at this point contains a message so we're going to pull out a byte from a0 it's going to go into t1 and then just like in anything else in c or assembly all strings are null terminated meaning at the end there's a null byte right here that tells us hey man the string is over so if we get a null byte out of t1 or in t1 currently we're going to leave the function meaning we're done if we if we've now gotten to the null byte here we have transmitted the entire string so basically branch equal to zero if t1 equals zero meaning it's a null byte here we're going to branch to a symbol we write called puts leave and puts leave is just a ret instruction that's it it's literally just hey man we're done we can return now and that rhett is going to go back to code execution after our call to puts it'll be right here so now we need to actually incorporate the writing function right so we basically said if we load from the end of the string leave but now we actually have to actually do the rest of the functionality what we're going to do is we have to first incorporate logic that waits for the uart buffer to be clear like i said before you can put data into this fifo but it doesn't mean necessarily that it immediately gets pushed out you are limited by the baud rate of the serial bus there right so what we're going to do is we're going to load a word into t2 from the uart register fifo offset by t0 what that's going to do and again so t0 contains the uart base and this is going to offset into the tx fifo so basically if we get a negative number out of there so if it's less than zero we are going to branch to puts weight basically the fifo was meant is set up to tell us if something is already in there by returning a negative value out of that buffer again we're going to send ascii over there we can't put negative values there but what it's going to do here is if we get a negative value it is still being used so once that is you know no longer the case we can continue going through our loop so if there is not a null byte and the buffer is not full now we can actually put stuff there and the way we do that is we store word sw the current contents of a character in our string and at this point t1 has the latest character from our loop right if we took t1 out and it was not equal to zero we're down in this part of the code now and t1 still has the character we want to put so we're going to do store word t1 into uart register fifo offset by t0 that's the same thing here we're going to index into t0 by this amount so this will actually put the character on to the uart bus and then from there all we have to do is add one to a0 because a0 is a pointer to our message and that message will be now incremented up by one to get to the second character and then all we have to do is jump to puts loop and do it all over again that's pretty much it guys that's the code but the question is now how do we get it onto the board this gets a little more complicated as we need to form the binary in a way that the board is able to actually consume so pretty cool actually when you plug your board into your computer you will get a drive here called high five just like the raspberry pi pico i can drop a file into this directory here and that will actually burn the code to the board and reset the board to run the code the problem is the question is you know what format is that code the hi5 expects you to put a hex file into this folder here so we have to get this code into a format that the board can consume in a hex file the first step to do that is we need to create what is called a linker script a linker script puts the code into a form that the board knows how to handle so for example we made this text section here and it has a global start but what memory address does this text section live at what memory address does this ro data section live at we need to describe in the linker file where do you put these blocks of code and that is dependent on where the chip expects code to live so i'll show you in the manual here our code is actually expected to be at hex two thousand and one zero zero zero zero and that is a function of the bootloader code that sets up the board and jumps over to your code so we need to write an linker file that tells the compiler to build an elf that way so what we'll do here is step one we'll tell the linker hey man risk five architecture pretty simple step two we'll tell the linker what format should this binary be in it's going to be an elf 32 little endian risk 5 binary very simple now we're going to tell it okay what is the entry point to our code and the entry point is a symbol start and again that start symbol is just right here that means that when the elf is created the entry point will be to go to this location now we're going to declare where do the sections go in memory and again this is a section here section text and this is a section here ro data they represent different parts of the board we need to describe where on the board they go in memory so by putting dot we're saying the current location is hex 2001 zero zero zero zero this tells the linker that we are going to start memory at this location and now i'm telling it we are going to put all of the text segments or text sections rather into this part of the code we're also gonna put the gnu build id it's just an easy way to make sure that the elf is saying it has the hash of the elf that we are creating and this actually won't go onto the board we're going to strip this away when we opt copy at the end but that's not important and also the ro data remember that's where our our section for our message is going to go is also going to go pretty close to this text section right next to this part of the memory so ro data will go here okay so that's where the text and ro data are going to go but now we have to move the cursor if you will in the linker script to a different location where ram is going to be and ram is going to be starting at this location and this is where our stack is going to be so we're going to put the data which means it's the dynamic memory of the program the data section also the s data for the static data needs to go here as well and then also the debug information which will get stripped away but still important to have in the binary somewhere dot debug we need to capture that and then we're going to create a thousand bytes so remember again the dot is a cursor plus hex 1000 bytes and the stack top remember that symbol we used up here the sp the stack top symbol is going to be a location in the linker file that represents a pointer to the current place in ram and this is where the ram will be allocated for our heap or excuse me for our stack to live and then finally we create a symbol called end that just shows you the end of the binary so we have a linker script now that declares how to form our binary in a way that the board knows how to process we also have our code to tell the board what to do now we need to combine the two using the commands to make the binary be created so we'll move this to the right to show you guys how to do that step one risk 64 unknown elf gcc this is our compiler we need to also tell it to make the architecture a risk 5 32-bit and then g at the end for the you know variant that we're on uh the machine abi needs to be this abi we're going to statically compile our board or our program the microchip model is going to be a midaini f visibility hidden that's basically going to make sure that certain parts of our code don't get shown for no reason no standard lib this means that we are not going to link libc into our program that'll keep the program a from having dependency issues but also b make the program really really small no start files meaning we're going to incorporate no other additional code we need to tell it to use our linker script which is right here with attack capital t we're gonna use red5.ld we are going to tell it that we're going to use the hello.s code again that's our code right here and we're going to output a hello binary okay so just warning us that i didn't put a new line at the end of the code here i'll add that to make the assembler happy okay so what have we done we have produced a hello binary but what did i say before the board actually expects a hello.hex file so we need to make this file a hex file by copying out the relevant parts into a different file format the way we do that is with the object copy command so unknown elf obj copy tac capital o for the format you're going to output it will be i hex we'll take in our hello and then output hello.hex should be no issues there very cool and then are just going to literally copy that hello.hex file onto the board here we will do that this will go copy hello.hex onto media user high five hit enter and then i'll have my minicom up to show you guys oh we gotta wait for the board to come back to life and while we wait as promised i wanted to show you guys how to actually run this code if you don't physically own the board i know a lot of you don't by using the program kimu we can actually use our code without having the board present we have to make one minor modification to our code normally on the code on the physical board it loads at this address here we have to change it to an address that kimu can process we change it from 2001 to 2040 and then we run our compilation command one more time to produce a new hello binary from there we can actually use kimu system risk 532 to run our code we do that by saying we want to first use machine help and we're going to choose the side 5e we're going to say no graphic to suppress the kimu graphic display by default we're going to say bios none to not use a bios and we'll use a kernel that is just going to be our hello program and by hitting enter we see that our code does actually run without the board physically here pretty cool now back to the real board low level gang guys i hope you learned something i hope you enjoyed this video do me a favor hit that sub button if you want to learn more about the risk web architecture or this board in general also check out my merch store and follow me on twitch guys i'll see you next time take care [Music] you