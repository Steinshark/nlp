hello everyone my name is constantinos canorus and today we're going to talk about uh reflection in C++ and playing experimenting with uh reflection in C++ so uh in this talk uh just to give you an overview of the agenda we will start with uh the general idea of of what reflection uh is and uh some some information about its current status in the language uh then we will move on with uh a very common application of reflection which is serialization and deserialization so converting data and structures from memory into another binary for example representation and then we will combine those two concepts so reflection and serialization uh to create a new library that depends on those uh modern and and future concepts of of C++ basically uh and then we will move on with some some thoughts and conclusions uh now this this talk this is not uh this is not a reflection talk we will not go into detail about the history the Ral the implementation details of reflection uh we will not discuss about uh how reflection works and and what kind of and all the things you can do with it uh because for this there are already a lot of talks uh that have been have been done and reflection is a topic that's been uh discussed for quite some time in in C++ now uh so if if you're interested in learning more about uh how you can use reflection and uh some of its more common applications you can watch one of these talks uh these are some of the more recent ones by the people who actually work on the on the drafts and the technical specifications for uh for reflection uh in this talk we will talk about uh we will talk more about experiment men in with reflection what you can can do as a developer uh right now with reflection what you can do in the near future and how you might take advantage of it to work on a on a very specific use case which is uh which is serialization so yeah uh what gives me the right to talk to you about these things I'm an electrical engineer by trade now I'm doing my PhD in the University of Luxembourg and I'm working on on very small satellites and with this with these very small spacecraft satellites uh it's always very interesting to to see new programming techniques that can basically reduce your development time without a big impact in in reliability and safety uh of your code so I'm technically not a C++ professional uh but I can go through I can get you through some of the experiences I had uh while trying to work with with reflection and some some libraries and serialization ations and thing that things that we need to do in our developments which are intended for space flight uh so without further Ado let's get started so reflection is uh is a C++ feature that doesn't completely exist in the in the standard C++ yet and it's not implemented in in major compilers uh fully so there are a bunch of of drafts and proposals uh to implement it in C++ and uh for those of you who who don't know the term I will give you a definition from uh from one of the proposals that have been published for C++ and this proposal says that reflection is the process of obtaining metadata uh what is metadata metadata is data describing some other primary data let's let's let's look at an example in the context of C++ so I have a class here uh this class is called toast and it has some some values some data members and it also has a function and in the context of C++ I would describe the the primary data the values that that that we are interested in uh I will describe them as these numbers right here so the values of of the data members the values of the variables in this case and the metadata the data that describes this primary data is pretty much everything else uh so right now in C++ we have a bunch of ways to access this primary data uh a bunch of ways to to get the value from variables but it's not always so easy to get this metadata uh for example metadata here would be that this structure is is a class it has the name toast these are the the types of variables these are the names of variables these are the access modifiers and so on and right now in C++ for example it is easy to get the types of things so you can use deal type and get the type of any variable and play with it you can uh do conditionals and so on but some things like access modifiers argument lists of functions uh names of variables maybe it's not so easy uh and this is what we want to achieve with uh with reflection we want to get uh access as complete as possible to these kind of of metadata uh which are related to pretty much everything that's that that's not a value and we can have uh metad data for for classes for uh for types for variables for functions for name spaces uh modules and so on and this is for example something that you cannot do in C++ uh right now uh if you have a class or an object of this type toast uh a very simple example of of reflection of reflecting on uh on your types would be to have a function a standard Library function called get member variables and this function would return an array of the variable names uh or variable attributes information uh of the of this object or of this class so you would call a function and get all of the data members of this uh of this object here uh the same way you would do this for variables you could also do for member function so here you would have a function that Returns the maybe the public member functions of of an entity and in this case it could return like a standard structure member function and you would be able to get its name its return types its argument types A number of its arguments uh and you would be able to call it however you want uh and and this is the idea behind all the all the reflection standards that you want to to to access the uh the kind of type information type hierarchy and information about other entities in in C++ and you can you can take this concept to the extreme uh if you want so there are uh this is an idea uh we have this class and it has two functions Coler and coli and coli uh print some information so it prints who am I where am I so which in which class uh have I been called in and by which function have I been called so kind of a back Trace thing and maybe with some some an idea of reflection would be that this actually Returns the name so I am in I am in coli and you see the function returns its name basically um I'm in toast so it tells you in which class you are in and by which function you have been called so in this case coli has been called by color uh so you would get an output called by toast color and this is the general idea of of what you can do with uh with reflection and there are a bunch of of either generic or or n applications for it but a a very nice summary was given by Andre Alex andresco in one of the toxi uh I referenced earlier uh and it's it's this quote that we must look at increasing leverage more correct behaviors from fewer lines of code so reflection is uh basically one of those C++ features that uh that that promise you that they can uh reduce your code that uh you can reduce repetition that you can use reflection to get information about code you've already written uh and you know about don't repeat your self principle and stuff like that uh and and there is a bunch of of usefulness uh here and uh the thing I'd like to focus on is that we already have a bunch of libraries that uh would like to do something like this but take a lot of work arounds or do a lot of compiler trickery and having reflection would make some things that are now very complicated they would make them very easy and they might prevent reflection might prevent a lot of duplication uh especially when you're writing something that uh that needs to handle the structure of of a class or of an object uh now as as I said before uh in general for reflection for metadata in C++ uh we already have some mechanisms that can work with it and already at run time uh there's this keyword here the the type ID so if you Google how to do reflection in C++ you will see a bunch of results and this type ID think it might be one of the first results and indeed type ID can give you uh the name uh the name of a type so something that normally you wouldn't have access to in C++ so you have access to values you don't have access to names of types or uh or names of variables in your in your binary but with type ID uh you can get you can get the name you can get the H you can get other information about about the type of your variables and uh we see here the output in in mangled format for uh for C++ however this thing is is quite limited uh and and one of the first of all it returns all the the names of types so it's not you cannot not do a lot of introspection on on types if you want to uh but also it's it's kind of runtime only if you try to use something like this at a Conex environment uh you will probably not get very good results you will get the compiler error and it uh it also possibly requires uh rtti runtime type information which is is something that might cause an overhead that you may not want to have in your uh in your binary files and so this is this is a runtime mechanism it's it might be good for some use cases maybe you have uh some some type hierarchy that you want to uh to discriminate but uh it's it's very limited in terms of flexibility and functionality so if if you move forward in the in the story of C++ you see that uh with template meta program and with all the new features being added we have a bunch more reflection utilities and methods that that we can use for example we have conditionals on types and we have templates and we have SP and already you can start structuring your code based on how types are defined and this has given us a lot of power especially in what we can do with libraries we have already very generic libraries in C++ right now and then we have con straints and Concepts and here we actually start going deeper into how our objects are defined and what they can do and here we can have something like Duck typing uh for example but again all these uh all all all this implementations and and these standards uh they talk about conditionals uh and they talk about checking you still cannot extract for example the number of dat members uh of a type or the names as strings so the C++ Community has been thinking on how to to expand this kind of reflection and how to uh how to make it even more powerful for some time now and there have been a bunch of proposals uh on different implementations for for reflection and uh here I'm going to show just some of the more recent ones but uh I have a couple of links if you want to look at the at the whole story uh on on how this thing has been going on and how uh it has been evolving over time and uh the first proposal that I'm mentioning here is scalable refection in C++ in published in 2019 and uh this proposal defines a couple of new keywords for C++ so reflexer and xer ID and what uh reflexer does is basically it gets the reflection of a type and this reflection of a type contains the metadata of this type and as soon as you have this metadata then you can use a bunch of standard Library functions that are defined by this proposal to work on this metadata of this type so for example here we have an enumeration and we're getting the reflection the metadata of this enumeration and we can get the members of this enumeration the names of the members of this enumeration the values of the members of this enumeration and so on so we have full access to the to the metadata and the primary data uh by using those those two keywords and in this example this this function here that I took from the draft uh this is a very standard example uh that you will see in a lot of these talks which is how to convert an eneration value to a string uh this is a very popular stack stock overflow question for C++ something that uh that people want to do a lot and something that would at least if you use it for Diagnostic purposes would might help your development uh your development process by a lot so yeah what this function does is that it converts an En to a string and en num value to a string uh and the way it does that is that it's templated it gets the the eneration value uh and then it goes through all the me the members of the enum and if if one of the members uh matches the value that you have provided to this function at runtime it Returns the name that's given by reflection uh so that was published in 2019 and uh there was another draft uh technical specification published in 2020 uh based on on this proposal and another one I think and this technical specification uh also I think made its way into uh an ISO standard which is the C++ extensions for for reflection a few years later uh we got the second revision of the previous draft which is scalable reflection C++ uh and here we had a couple of changes more notably uh more notably a change in uh in symbolism so now we use this carrent operator and this format uh to- do reflection uh and some other changes as well and actually actually just a month ago there was this draft published so reflection for C++ 26 and uh this proposal is basically a subset of the previous one that's uh and with slight modifications that actually intended to go uh into C++ 26 uh so we'll see whether that will happen or not uh but there are interesting GRS if you want to go into uh the rationale and the functionality of the proposed reflection uh mechanisms in C++ and by the way uh the technical specification the iso technical specification is also available in in C++ reference.com so U most of the uh most of the links have have articles and have documentation in them so you can get a uh a more General uh view of of what this technical specification contains so all of this was intended to give you a general idea of what reflection means and uh where it stands right now from a formal and C++ standards point of view however reflection is a very often requested feature and uh there have been a bunch of people of Library developers that have tried to to work around the the limitations of C++ compilers and Implement at least a subset of reflection on their own and a very good example to show you this uh is the the eneration to string uh question uh this very popular search query and and if you go through the answers to these questions you can find that they usually belong to one of those categories so the simplest way would be to store the strings in a in a kind of container uh so that the variable name and the string representation is separate uh so that's that's a similar way to do it you have to repeat the same thing uh two times but uh but it works uh then there is another implementation which is is that some libraries Define functions or pre-processor macros uh that basically store the strings in a container on their own automatically so you don't use compiler features but you don't need to repeat yourself there are some other implementations that do code generation so there is an answer that contains a cake uh tool that reads your code and then generates another uh piece of code that contains the strings that you want uh and there are some some also clever uh workarounds that use newer C++ features and user defined lits and so on but the top answer uh that you get here is uh is a small Library called Magic inam C++ and what this magic uh inam Library does is it promises you that you can convert an inam to a string without any extra code and without any extra boilet plate so if you have an eneration for example color red green blue values and you want to convert to string what the library tells you uh is that okay you can Define your Coral here so a variable eneration uh type and then you can call this function here so magic inam inam name color and then you automatically get back a string and this is just with just with this single line somehow you can convince the compiler to return to your the name of this of this type basically as a string and this is something that should not normally be possible with uh with a C++ I know uh and you can do the opposite thing so if you have a string you can uh also Define your type and it converts it to an inam value an inam type and when I when I saw that this was possible in just a line uh I was I was very curious to see how it works and the answer is that it does some very nice compiler tickery and it depends on some compiler specific uh capabilities so in this case it's this magic identifier pretty function from GCC and there are similar things you can do on sank and msbc and what this magic identifier does is uh that it gives you the name of the function you are in it gives you the signal of the function you are in to be more specific so you could get uh inam name you could get the return value standard string and you would also get because this is a template function uh you would also get the template arguments so in this case you would get the exact value uh of the color and if you're passing in a numeration value you would get the name of this so if you called this function with uh the red value you get back this you would get get back this signature so standard string and num name and then the template arguments so C equals red and then you can do some very simple string parsing to get this red value and uh this only works at compile time so you need to have your value specified in a template but uh the library uh also does some some trickery when it puts up so it puts all the eneration values inside the map and then you can access everything uh at run time as well uh so so this this is how the this is how the magic inam Library works and this is how it pretty much does some form of reflection uh but without using standard C++ and with by doing a lot of tricker behind the scen so uh there is a lot of of work and code that that needs uh that is needed to make this actually work uh and here I would also like to mention that uh for for many use cases reflection can be considered as a convenience feature it's not something necessary to have it's something that that makes our our development faster in some use cases and if you have a more complex program or uh some more Mission critical piece of say safety critical piece of software maybe you do not want to tie the functionality of your software to the names uh of of your variables maybe you want to be sure that uh if you do a refactor and you change this uh blue to cion uh your end user will not see any change uh and this is something not something you you would use the magic num library for but for for many use cases especially if you're doing uh Diagnostics if you're doing calization as we will see later uh reflection is a very powerful tool to have under your belt so this is one Library this is Magic inam uh let's see other reflection implementations there is uh boost describe so uh this works based on on on Macros so you it defines some pre-processor macros and functions and you can so you have to Define your objects and then you have to tell the library that okay these are my objects and these are data members and then again a lot of work behind the hood but you also get access to the names of the data members the sizes the types the uh counts of the data members and so on uh and this is completely reflection then there is another approach uh from from boost pfr which is a simpler uh more limited version of reflection based on template meta programming uh which also allows you to get the members of of a type so in this example we have uh we have a structure with three data members and and you can just simply print these fields uh and the number of these fields without any extra effort and this is also weird this is not something that uh should be very easily possible uh with standard C++ but it actually is uh and I was also very curious to see how how this can work uh and the answer is that this depends on on structural bindings in CL class so if you have a simple type maybe an aggregate uh you can use structured bindings and basically extract the values and the types out of out of your objects and here for example we have the structure and we do a structure binding with three variables uh then we can print everything uh quite normally uh and there is a a Blog article you can read if you want more information about uh how to do this in in C++ 17 but uh you also need to do a lot of work behind the scenes uh to find out how many members you need uh maybe some CA is involved here as well uh but it is is something definitely possible and there are libraries that do this so yeah the advantages of this thing is that it works with pure Plus+ 17 so no compiler specific features needed but it's limited in capabilities doesn't work with all types of objects and uh the hardest thing you cannot retrieve these names right here A B and C we can still not print them as strings so this is the approach of of the Boost pfr Library uh then we move on we have a couple of other libraries that do uh reflection in current C++ so there is rttr a runtime reflection Library again same concept you need to tell the library uh about its metadata we have refle CPP similar concept here as well and then if you go deeper into reflection you will actually find that some compilers have implemented it uh as a as a separate feature from already from the compilation stat and if you go for example to to Microsoft's C++ compiler uh you will find a couple of Articles explaining that uh it has uh very specific functions that can do uh quite powerful uh reflection and for example here is the standard example of converting the inam value to a string there's a c compiler another experimental C++ compiler and it also defines uh some reflection features with uh its own custom synex but then there are also people that have implemented a reflection from the the drafts and proposals uh that I show to you before uh for example this is a popular implementation this is the uh an llvm Fork by the the Lock 3 company who uh specialize in in very new C++ features uh and they've actually implemented uh this standard with refle Express uh with a few modifications uh and if you go on this repository and you check their Wiki you will see that uh they have a bunch of information on how to use reflection and extra features they've added and so on and there is a talk by by Andrew saton that explains these Concepts uh so this is very nice to have it means that you can already kind of experiment uh with reflection on your own based on the standards I think this is also available on on compiler Explorer uh if you don't want to uh to compile the compiler yourself so there is also another Fork of of sank of llvm uh this one by matusik and this is an implementation of uh the the technical specification that's an ISO standard I think and uh matusi has done a lot of work behind the scenes to to actually create a lot of examples uh and the mirror library that uh makes calling some some standard uh reflection functions a little bit easier so here you can see the standard uh in N to string implementation and he has also done a talk uh in in this conference last year uh about the the design of his of his API and his implementation and about of examples and use cases for it uh which I also highly recommend so this is how you can do reflection today uh now let's talk about uh serialization and deserialization or sometimes it's called marshalling and marshalling or packing unpacking uh there are many debates online about which term is suitable for which purpose I will just call it this realization and call it a day uh so what realiz ation means in in in the context of today is that we have some some data in our program in our memory uh we have some kind of of structure and we want to convert this data to either store it permanently or to move it somewhere else through a Communications Channel and then after this data is moved we can get back into our memory our software representation of this data through calization and distalization uh and there are a bunch of ways a bunch of reasons that you might want to do this uh for example uh you might want to store the data because you are a video game developer and you want to store the save files maybe you want to transmit the data uh or a structure or some information to another application running on the same computer or in a different device over a wired network over a wireless network uh maybe you just want to look at the serialized data for Diagnostic purposes maybe you want to compare objects but it's mostly two categories uh storage and communication and depending on uh which field of software engineering you are working on uh you might be looking at reflection pretty much uh every day in your daily work so this is something that that's already been done this something that's something very popular uh let's see how people do it and what kind of of protocols what kind of ways of formats uh they use to to serialize data and there are a bunch of formats binary formats or plain text formats to do this so uh if you wanted to use a serialization library just for yourself so a naive implementation uh would be to just uh say the names of the variables and then the values so id7 temperature 32 and so on uh Json a very popular format in web development uh you can Define objects and ARS in a more structured way and if you want a more efficient binary format uh there is a bon implementation of this thing uh if you want to be more flexible we have uh XML uh and then some specific serialization libraries from from other languages uh like python pickle they Define their own formats or protuff uh protocol buffers by Google uh they also Define a format and this format has its Advantage disadvantages and in some cases especially if you're doing uh Communications uh radio frequency Communications you might be inclined to design a custom protocol custom serialization uh format for your own specific use case so reflection is so popular that uh we have a bunch of libraries for it uh and it's its Library makes different tradeoffs and has different use cases and disadvantages uh or advantage is but I think we can make a couple of important distinctions on how each of these libraries work uh first of all on the on the data format and on the uh on the calization format uh that you define for them so in some libraries like the protocol buffers uh the library tells you the format that it will store your data in so protocol buffers defines a biner specification it's a very good biner specification you can have versioning and so on but you locked into the specification you give it the structure and it tells you that this is the binary format uh in some other cases you might want to define the data format on your own you might want to say that okay I want this integer to take four bytes and be big Indian I want this uh float to be stored as an I float I want this string to start with its length and not have an N termination character this is another use case uh then there's another distinction which is whether you're uh whether this Library can only serialize and deserialize things at runtime or if it can run on a Conex environment as well usually for this context we will probably not need to serialize stuff at compile time a lot uh but maybe it's a nice thing to have uh then a bunch of those libraries are not technically libraries uh they uh you give them a format and they generate the C++ code for you uh so they compile the data format and they generate C++ code for you but there are also other libraries that uh don't require this PR preliminary step and they just uh they just run entirely within C++ and entirely within the binary that that you generate and then a final distinction is that uh these some of these of these labr these programs have implementations from different for different languages so if you need to interface between different systems written by different people uh with different use cases you might want this kind of capability which is very very common to see in in serialization or there might be libraries that are built mainly for C++ let's look at a couple of examples so this is the Google protocol buffers uh the way they work is that you define your structure in in a nice file so to. prot some boiler plate uh and then this is the the type that you want to convey so 32bit integer ID float temperature string review and here you assign some some IDs to those types uh and then as soon as you have this specification you run a terminal command and it gives you a bunch of autogenerated C++ code that you can just include in your project and compile things immediately uh serialize things IMM immediately and everything is type checked and everyone is happy so this is the the compilation approach let's look at the runs within C++ approach uh also used by by a lot of serialization libraries and this is a common approach that you have a structure with his data members and then again you need to tell the library that okay these are my my metadata these are my data members uh you know about them now serialize them as you know uh and this is a very a very common way uh to do this kind of thing uh so this was for the serial Library another example for the bit Library again similar concept you define a function that tells uh the data members the metadata to the library but here I want to show this example because you you specify the the binary types by handun by yourself and and there are some use cases where you might want to have this kind of more fine control over how your data is serialized this is another example from not a C++ library from a from a python Library called construct and I found I found this interesting uh because this follows a slightly different approach so you have your object to be serialized with all the data uh but then you have another object which defines uh the the structure and here you don't have the the API of the of the library does not give you a function it tells you to create a new object and then with this object you can compile your primary data and you get back a similar result uh so this is a fully uh user defined data format that you can work with uh and finally there is this uh sista library and this one uh allows you to serialize at just one line without giving it any metadata so let's look through this example we have a structure we Define it we give it some values uh we Define an object with some values we use a weird kind of string here uh and then we call just this one line so a buffer equals the result of cista serialize just on line no extra boiler plate and it actually gives us back the the serialized string so these are some some binary non-displayable characters without any other information and the way that this Library works it's is something we saw uh before so it's a similar thing to to boost to boost pfr uh we have structured bindings and this Library does a little bit of of reflection behind the scenes uh this means that it can serialize your structs but it's kind of limited to to some Aggregates uh and maybe not very flexible uh and again based on your use case you might be very happy with something as convenient as this or you might be not happy at all uh finally let's let's look at serialization in practice uh and this is an example from from a small satellite project and what the satellite needs to do is it needs to serialize Telemetry to send back to Earth and deserialize uh telecommands that it receives from the earth uh and the ground station on the planet uh needs to do pretty much the same thing and if you look at the code that we wrote for this satellite uh you can see that uh we have a little bit of repetition so in this case in a function that that passses uh that passes the telemetry we might have uh an event definition ID that's the result of a read eneration function uh and another variable it's a result of a read function from from a string or a buffer then if we want to generate uh this if we want to to serialize and not deserialize we do the same thing uh but the opposite way so we append instead of reading uh but then the ground station we're using a different kind of software uh which requires those arguments to be given in XML format so we have a different entirely different specification and all of this is based on some external paper documentation and this is already four times that we're seeing the same thing repeated and it's also not easily searchable you cannot do uh crlf uh on on this code you cannot uh the the event definition I this this variable names are used pretty much everywhere in that code base so you need to know as a developer or a reviewer that okay I need to uh I I need to change this on all parts of my code or have very well structured tests for this so ideally what what uh I would like is to just have one Central piece of uh one central point of documentation and based on this generate uh have the compiler generate code have a library generate code uh or or structures or convenience functions around it and maybe it would be an interesting idea if even you don't write C++ code but you give this kind of XML definition to your C++ Library it reads this XML definition at compile time and it becomes able to generate some structures for you and parts and generate uh the the binary format of of those things uh completely on its own as a C++ library with everything done at compile time modern C++ conext optimized and so on so today we will try to move forward towards that direction we will not uh Reach the the XML reading goal but uh we'll still try to see if we can make a library that uh conforms to some of the specifications so I here Define that format compile time that runs entirely within C++ with minimal repetition and a couple of other nice nice to have features as well so let's go ahead and create yet another serialization library now I've been working on experimenting with with reflection and creating a library like this it's called okay serializer you know developers are not very good with names uh this library is meant uh not to be used for production or not to be meant as something something serious is just meant uh as an experiment and as as a as a tool to see uh how we can improve maybe already the existing uh serialization libraries out there as soon as we add Reflections and C++ 23 to the mix so it's not it's not supposed to be a good serializer it's supposed to be an okayish serializer hence the name and let's let's start with going through the thought thought through the thought process of working with a library like this and first of all we want to use very bleeding Ed C++ and we want to use reflection we want to see what what reflection can do so we saw that there are a bunch of implementations of of reflection at compiler level already and uh when I started working on this the most recent one was by matus H uh so this is the one that that I started using uh with a couple of updates I think this was written for sank 15 uh but I want to use more uh contemporary s features so uh I did a small merge with C length 17 so we have our compiler uh let's talk about the structure of this Library let's talk about maybe the the requirements of this Library so pretty much what I showed you before almost everything should be possible at compile time uh another requirement is that uh ideally this would be used in embedded systems so system with a low footprint so there is a requirement for no exceptions uh there are a lot of discussions on whether exceptions are okay or not for embedded systems I will not go into this I just avoid all the debate by saying no exceptions instead we will use this new standard expected type also no dynamic memory allocation so uh using standard liary containers is not necessary using new and Malo is something we will not be doing in this Library again to support low footprint embedded systems and no fancy compiler uh features no uh specific things that are not standard C++ or experimental C++ the end goal for today will be to write a single line and serialize an object into into AJ format uh and this is what we will do but the the long-term goal for this experiment is pretty much what I show you before so we want to take an uh XML definition and serialize it completely at compile time now this is not something entirely new this is not something novel uh similar Concepts have been done before uh for example you can find on geub uh on the mirror repository by matus hli that uh he has a couple of examples of uh serialization and deserialization uh with Json and reflection and there was another serialization Library based on compiler time reflection that was presented in CBP conon uh actually last year uh but here I thought this would be an interesting experiment to go you through uh the thought process of developing a library like this of experimenting a little bit more uh and seeing if we can actually get those uh more specific requirements to work for us so let's get started uh the first thing that I would like to do for this library is to actually test uh reflection to get our compiler installed and and see if it's working and that's what I did so uh we have a a test file here on cion and what I've done in this file is I want to do the classic inam value to string example uh so uh I use some code by by matus click this is uh a slightly complicated way to do the the N to string uh implementation with uh with reflection it uses recursive functions maybe you can do it faster but uh this is this is good enough for our purposes uh and it uses completely standard technical specification C++ so let's make an enumeration and I can do an inam color uh and maybe I have Mo uh Canan and orange orange and then what I can do is just do uh standard output uh and inam to string uh the template should be deducted so color move I'm getting a compiler error uh but it's it's printing everything correctly and yeah you can already see that cion does not uh really like uh reflection but uh it it actually works now the question here is we can do this at run time can we do this at compile time so let's try with static uh static Asser and let's see if in am string uh color move is equal to Orange and this comparison should uh should work and okay we see that the static assertion failed so we have the negative test case let's do the positive test case and we see that everything compiled so we know that the static assert is uh is working uh well enough so we we have reflection working uh this is good we can experiment do a lot of other things with uh with reflection uh now let's let's go into making our serialization library and the the kind of API that I would like to we have with this is uh looks something like this so we have uh a serialized method the serialized method uh explicitly takes the the the binary format the serialization format that we want uh and then we get uh we pass our output as a reference and the value that we want to serialize uh so this this design decision here this is intentional because if you're working in in in wireless communication for example you want to be very specific about the kind of format the data sizes that you're using and so on so uh here I'm making it very specific but uh if you want it is very possible to deduct the the serializer that you want to use from the types that you are passing uh here I'm also using a buffer uh uh as an output so I'm saying that okay this is a dynamic kind of of how dynamically expanding output that's connected to a standard string and if I run this then the string will equal to high uh and we can do the serialization in a similar way so der serialize uh here I also specify that I want uh little nns for uh for my for my input and I give a string as an input and I get back my value as uh as an integer now this is a bit heavy to do because you need to specify your buffers if your use case is standard strings and we will focus on standard strings uh for the rest of this talk you can just call serialize to string and you get back a standard string or deserialize and you can just directly pass a standard string inside um now at this point for this Library I would uh like to focus on this a little bit on uh on on on these inputs and outputs and and how this is done and I'm sorry if this is not perfect C++ code maybe there is a lot of room for improvement but uh it should give you the general idea and there are also a bunch of U implementation details hidden in the hidden in the source code but let let's see the general idea for for for inputs for inputting binary data to deserialize and uh in this case for for I have a generic input class that takes as argument an input rate so A+ plus 20 uh input range which is by default a string uh which means that you don't really need to mess with iterators anymore you can just pass a standard string or or an array or weird AO buffer maybe uh inside here and everything should be passed correctly and we can do a similar thing for the output so uh we can Define uh a a range type of output for the serialization library that works based on an output range and uh the output range gives us some very fancy stuff that we can do with with iterators that uh avoid having to handle a lot of a lot of edge cases and this is what we want to do here uh when we are adding basically a character into our output and again here you can pass uh standard string you can pass string views you can pass uh C style strings uh you can pass uh buffers and so on so this how we do input and output uh and I will spend a little bit of time on the binary types that we support so we have uh unsigned integers uh in our binary format we Define how many bytes they are up to eight bytes uh Indian s big Indian little Indian signed integers variable sized integ this is Google protuff think as well a convenience type for enumeration values floating Point values string representations prefixed by the the length of the string uh or C style strings that have a Terminator which is used to the null character and we also have a bunch of uh compound types actually which means that in the same serialization command we can serialize uh many different types uh one after the other or we can serialize an an array and let's actually look uh at one example of this right now so let's go to here and I will remove everything and we can let's say Define a standard uh array of un 16 and let's say it has 68 elements for for no particular reason and we call it R and let's fill this array uh so R begin R oops R end let's fill it with uh 68 69 in hexadecimal format and let's also do a standard output so okay sir serialize and our serializer is length prefix Vector uh and the length P fix Vector contains uh elements that are unsigned integers of uh a width of two bytes and then we should be able to pass our array just like that SD andle and I forgot to serialize this into a string so I'm using the convenience function right here the compiler is Happy let's look at the output uh and we get back our length prefixed Vector so we get back a bunch of highs prefixed by the length in binary representation so in this case it's uh the capital letter D which represents the decimal number 68 uh and this is how this thing work it should be able to work at UH compile time uh at compile time as well uh and you can work with this Library we can already do some very simp calization a very small implementation details uh iterating for the for the bundle type uh which can have different serializers in sequence uh we use duple template arguments uh parameter pack template arguments sorry and uh it takes a little bit of effort to iterate over them at at compile time but it's it's it's possible with parameter pack expansion now another smaller side of uh for return value types we're using standard expected uh not exceptions and we Define a custom uh a custom Alliance in the library for a result so everything you get for de calization gives you back uh gives you back a result and this result might be the type that you actually want so the digitalized type or it might be an error uh and there are some very nice monadic convenience functions in C++ 23 uh for working with uh with SD expected that uh make it quite fun to play with if I'm honest uh and then for serialization for the the reference uh type of functions we are using an empty result so we either return our or we return an error so similar to kind of returning an error code and if you look at the at what this parse error is it's a structure that contains basically an error type and the error type is uh an error code and maybe in the future we can add some extra information in there if we want uh finally there are some some unit tests for this library and uh if you're making a serialization library uh it's it's always fun to to see what we call in theimportance so you want what you uh serialize uh to be the same as what you deserialize so if you get anything through the process of serialization and deserialization you have the same thing in the beginning and the same thing in the end and uh the the cat two testing Library gives you a lot of facilities to uh to be able to kind of do that okay so now we have a calization laborate this is nothing really new okay a couple of C++ 23 features used but it's serialization uh it's fun but it's not something terribly exciting let's add a little bit of reflection to the mix and let's do the very simple thing that we want to serialize structs uh so we want to serialize the dat data members of a trct more specifically uh and for this uh I'm using again the mirror Library by by matus which depends on reflex and I'm defining a function serial I struct uh it takes uh an object and an output and we have uh we here we have the reflection of our struct so we call mirror and mirror produces the reflected type and as soon as we have this reflected type we can get some we can call some functions from the mirror library on it uh and we can get all the data members in the truct we can go we can Loop through all these data members and we can get the value uh serialize this value and get back the result uh and then you see that my code is not perfect I forgot a couple of SD forward things in here anyway uh just a little a little point of attention uh so in the previous examples we had to define the serializer by hand so we saw that uh here we had Define that okay this is the length prefix vector and it contains unsigned integers of sign of of size two uh in a Str we don't really have this uh we need the the library to kind of guess the the binary format that it uh want to use and for this we Define a configuration object and this configuration objects contain uh a templated default serializers uh member which specifies that okay if it's a un 8 it will get assigned to an okay s assigned integer of size one and so on uh and okay let's let's let's see an example of this uh actually I think I can get it to work uh so let's define a structure so struct structure and let's say it contains assigned integer uh a and let's say a is equal to 104 and an unsigned intezer uh B that's equal to 26913 and now I should be able to just call uh okay sir serialize struct I have a convenience function serialize struct to string uh and oops let me instantiate an object first okay no compiler errors that's a good sign let's run it and we can see that the output is actually high so if you go and uh put those on a hex editor uh you will see that these values serialized with a big Indian format they should give back high with an exclamation mark uh in the end so this is this is one way to do it uh and you can see I also have this this example here we Define the structure just one line and we get back uh our our serialized information uh now here the library does the specification for us so it knows that this is one bite it knows that this is two bytes maybe this is something that you might not want maybe you want to be very explicit in what kind of type uh you want to use and what kind of format and sizes and maybe alignments paddings and so and so on so the idea one idea would be that you can change this uh configuration object that we pass it compile time uh or maybe an extension to this Library would be that uh here in your structure you have some pairs so a pair of a pair of value type and serializer type uh and the library kind of sees these pairs and uh generates everything accordingly but long story short we have reflection working we have serialization working uh but this is not something completely new uh already we see with structured bindings uh we can do this in in C++ uh 17 however uh this time the implementation was was very simple it was just a couple of lines uh in in a small function but in any case let's let's see if we can extend this further let's see if we can reach uh our our Json end result so we can write a Json implementation uh by by hand uh we will see why that that is in specific and we can add the standard Json times a Boolean number strings aray object and we can try and and serialize stuff with it and uh already you can see that uh celon is complaining in the object structure because inside the object Thruster we do uh we do a little bit of a little bit of reflection so let's see if we can make this work so remember we had our structure and I think I have uh I can do serialize to string and I can pass uh a Json object and this is our serializer and then I can pass my structure compiler doesn't complain let's execute this and it works and we can already see that with this single line we get back ad representation and the the difficult thing here is that we got these values right here we got the uh the variable the the member names and this is something that you probably cannot do in C++ right now and this is kind of the the power that reflection gives you and if we want we can get this a little bit further so I can make an uh an array of you know uh ins just five members and this is one 2 3 4 minus 8 uh and let's give the name to this array I can add maybe a sub structure so let's define one uh right now and they can say float bals 13.6 and they can give it a name uh and now if I compile it everything should work and yeah I get back all my all my Json uh and nested things as well nice AR I could do strings uh if I want to do as well so uh everything works now the question is can we do this at compile time uh and the answer is probably yes so let's do a static uh assert and let's actually get this thing here and compare it with actually I need to write this as a string and so we getting an error I need to convert this to a coner and am I missing something probably not and everything works everything compiled celon is still complaining but uh we saw that this this assertion works and this serialization basically uh can completely happen at compile time as well and this is uh kind of the power that that modern C++ uh can actually give you and as a smaller side if this is something you want to do for uh if this something you want to do for Diagnostics uh to to look to read that your your objects uh you can define an O stream operator uh and just do this so for this example I've just defined the no stream operator for pretty much every object that's not a string uh and you can see that with this little bit of magic you can just uh output structures as if it was python so this this is the the kind of power that you can get with reflection and this is just a simple example with the current implementations with a with a very quick work on uh on on library and uh right now it's a very rudimentary implementation of Json uh it's it's a manual implementation uh in order to to get this uh to make it work with with con texture and it's just the serializer working but uh you can you can further uh you can further expand this of course uh and this brings me to the end of my talk so we saw the OK cizer Library it has a couple of interesting features uh we were able able to comply with the requirements we set earlier and it's quite useful for embedded systems as well uh so we can work with strictly no dynamic memory allocation and with strictly standard expected no exceptions as well so the embedded people will be happy uh but there's still a long way to go if you want to get this into a kind of mainstream uh serialization or martiall link Library uh and there are some also interesting uh Concepts that you can play with uh if you if you're thinking about the future of how this could work in C++ or uh what serializer label like this could uh do ideally for example Java PHP they have comments annotations that the code can actually read and influence Its Behavior based on that so for for for the library itself uh how does it its future look like uh maybe we will get it in uh in one of the space projects where I'm working uh and the end goal for all of those things is to have this kind of single source of Truth whether it be code or an XML file or or anything else uh that allows us to Define our our Telemetry and telecommands and do everything all those things Parts in generation and so on around it uh and and this is an example of how you could do this for example in in Python using the the construct library and then you can start thinking about uh other more complicated things and experiments you could do uh so those the interpreted languages have uh this called evaluation you can uh evaluate new code at run time could we do something like this in C++ for comp for compile time like you pass the name of a variable or a data member as a string uh and uh you you get back what you want uh it's it's slightly possible with the current proposals for for reflection right now uh maybe it would be interesting to see this expands there are safety arguments on on uh on this as well but it's interesting uh food for thought and the the final thoughts uh that I have is that uh implementations for reflection exist uh whether they are for the C++ that your employer allows you to use or uh the C++ that you can get if you compile llvm on your own or uh if you use a Docker instance uh to do your own experiments that I will uh that I will put up in uh in the library Repository uh so yeah you have the capability to to work and and play with these things uh there is a a bunch of of references online uh most of the implementations that are online are for the uh older uh slightly older uh versions of the of the proposals and drafts uh so not updated with a new operator format and any other changes but uh we have now this this new this new proposal uh which is active uh there are revisions actively being link done on it uh you can check the the GitHub for the for the proposal and it also adds instead of just reflection it also adds a little bit of of meta programming inside there so uh there is a way to actually Define uh new structures uh and uni formats inside so uh this is a synthetic struct uh defined by this uh by this technical proposal yes so that brings me to the end of my talk uh thank you very much for your time these are my contact details and I hope you enjoy the rest of meeting C++ thank you very much