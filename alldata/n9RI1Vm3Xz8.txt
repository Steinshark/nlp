hello and welcome to tonight's meeting seest live episode our guest tonight is Rina Grim who is well known for giving trainings speaking um on conferences giving talks everywhere and his blog which is very active and has written a lot about the ZB standard and so Rina welcome to the show it's a great honor to have you I'm happy to be here thanks a lot yens now we basically get started with your questions um but that usually takes some time so um Rina let me start simply by asking you like you what's like the last things you covered in your blog and you've done like in in writing um about the C++ standard currently I'm writing about 20 and I make a deep dive into the grono extension in 20 uh C++ 20 because I would say most people are not aware of what is inside so I right about time of day calendar then about time zones there's a lot of interesting stuff cor related in C++ 20 and yeah I I actually wrote some code with Chrono this month and I found it quite interesting that often when you search the web you find like on stack Overflow that there's one person answering the questions which is the author of The Chrono Library how not yes and it's sometimes frustrating to kind of get the answer like uh if you if you want to do that actually uh that's like available in the date Library which I have on GitHub but which is not the standard yet um yeah and and there's a small pity is the Cor rber in particular this extension it's extremely powerful but also very complicated yeah that's like um you wrote about time of day and that's something I also looked into um krono is very good in handling stuff which is like um basically by definition a time but um I actually looked it up on that right so the the the answer to that question on um the question is about like basically what what if you only have a time without a day and this is kind of difficult to represent in Chrono right now you basically have to write your own implementation for that okay anyways let me see if there are some questions for Riner uh let me add one small remark what is also nice is the interplay of K with the format Library you can nicely display the values that is true um generally I think yeah Chrono is very thought out and the user friendliness is not always there in my opinion it's like kind of hard to get a start with it and and if you if you just want to deal with uh something which is like easy um I've pondered about just converting to struct TM instead when you just need the values and not like do complex calculations or something in or time zones um so um you said that you covered C++ 20 currently or like that's the current work how much have you looked into C++ 23 oh C++ 23 is not as big meaning I wrote essentially only give you rough number I wrote around 10 post about 23 around 100 about 20 to see the difference mhm so on the call language you have one extremely nice feature this is um de using this which enables pretty smart techniques to get rid of for example CTP on the library side you have interesting uh libraries St expected monatic extension of St optional then empty span multidimensional span what else so do you have C++ 23 already fully covered on your block um I would say I have at least as much covered as reader should know I don't go in each detail and still many features are not available for examp example um um flat map flat set I'm really curious about the performance numbers but so far none of the big three imple implements them that's true that's true I still wait and want to compare it with a map and another map because I'm really curious about performance I've looked into crtp recently and deducing this seems to be really nice for that um exactly nice but it's noted on GCC right now and I'm on on 13 and I have no plans to change to 14 right now there's also the so-called overload pattern to get rid of the design pattern visitor and this can be done really really nice instead using this so the visitor becomes way way easier and one of let me say do you know what my favorite features probably St Import St you can just import a modalized version of the entire standard Library this is so nice in particular for beginners you don't have to think is this uh algorithm in functional in numeric or in um function numeric when I you basically get rid of all the headers right exactly you have like the whole standard available and you don't have to think like what do I need to and you say only Import St this is all and this Windows you can already use it I think this is a very nice feature for beginners because they often forget to include the uh needed headers or sometimes you don't include it it works on Windows but it breaks on GC or the other way around yeah I think like modules are still far away from being like portable cly ahead but it's not a question because now it's not your uh in the responsibility of the developer now it's the question of the compiler uh build now your SE I think this extremely nice feature just say Import St this was it okay um let's go from the realm of Standards to a question about threading if you want all threats in a system to sync on the same clock tick do you recommend sharing one SD Chrono object between all threats I'm still thinking about a question when you want to have let me just provide me uh give you my thoughts when all threats should follow one clock tick you need sequential consistency this means all operations of all threats are performed in the same sequence there's no um uh yeah this is one of the guarantees of sequential consistency therefore I don't see your question about sto I see more question about a member model anyone when you want to have an explicit point in your program at which all threats synchronize or weight use a ledge or a barrier in C++ 20 so I would think about it in a different way establish for example a synchronization Point saying ledge or barriers or use sequential consistency which gives you the guarantee that all threats see all operations all Atomic operations the same sequence okay yeah I agree with uh using a ledge um let's see there is a question let me copy it here and make it a bner all right so in the past summer I read some books and worked examples about cortines of course one of the books was written by you um cortine is another world I think that's the word so we will have a talk on cortines next week so but you've written extensively about cortines too let me say a few words about coroutines it took me quite a time to get them in my head I need a few iterations at least starting in 20189 it's really really complicated but on the other side extremely powerful in general when I teach corins I show examples put output inside these exams to see the workflow of these cortines which function invokes which functions because underhood cortin consists of 23 function which you can partially which you must partially Implement 23 and this defines behavor of your cortin but when you uh when you do it a few times play with it h change it see what happens it you will get intuition what you can do and this is powerful for example I wrote once um complicated or let's say Advanced schedulers for corins I achieved it but I did it in five steps and then I had it meaning even I which I'm not a total expert in CS I can achieve such tasks by yeah because it's doable but anyway you're right it's another world and it's a Pity that we don't have a cortine the only thing we have in 23 is stood generator which is a kind of an infinite data Stream So once more do it a few times dive each time a little bit deeper and study the examples and now and then it will make sense by the way uh um Jens yeah who will talk who will talk about cor next week Andreas Andreas ftic will beginner talk for cortines um on Thursday I'm looking forward to it and it's been a very popular topic to write about there's like so many block entry from you uh btech and lots of others and what's also special about Co teams each one um how should I say um addresses them in a different way you have to learn what's your intuition about cods for example Andreas talks about a state machine for me it's a framework of function which will be performed and you have you can adopt it so it depends on your perspective and you have to find your own true there's actually a first question from LinkedIn so hello to LinkedIn uh Jorge asked how can we convince the company to change the C++ version for example like from 17 to 20 what is the most important argument in your opinion this depends on your use case but but in general do something optimization like meaning this is now faster than that when you switch from 7 to 20 because optimization of performance is always the the key argument but once more it depends on your uh use case when you are for example do a lot of concurrency C++ 20 is way better when you do a lot of financial things you may be a big friend of cortines so it depends when you play with generics go to Concepts this makes your code way way more readable way way more understandable but in general it depends on your use case but anyway 20 is at least as big as 11 there are many reasons to switch to 20 I think one of the arguments also could be that code generation gets better and other things like um when when when you need to communicate this up chain features might not be the big thing uh because you know I mean except from from bigger things which you know modules if you can utilize modules if modules can make your builds faster um I think that modules are a great argument to actually say um our build time gets better and then that raises productivity and so that would be a very strong argument for people to actually put this through the company but modus have now day issue how will you port them from one platform to the other maybe on Windows you are fine so I see this CRI with modules when I give a 20 class all of them want to know about modules afterward say that it's a little bit too early for that so I see modules critical 23 import to is great but modules in 20 we need tool support yeah which is coming depends on on like there like the question is not that easy answerable when you don't know like what what tooling you use and um what what platforms you target like are you in embedded are you under Windows if you under Windows only um I think the the argument for modules is already there um exactly and to you know make a experiment with clang and um DCC to see what you actually can achieve and also like you know try to to argue that like getting the standard Library as a module in in 23 is already available on your fingertips and windows just totally easy and place to to move to the new standard you only compile it once and then you can use it and of course the build times are unbelievable around 10 times faster when you switch from a include based library to a modu based okay by the way these are not my numbers these are the numbers from um Danel and pi and has done a lot of work in that field um so there has been a huge topic about C++ in the in the recent days and we can't get around asking you the question so here it is um Can C++ shed its image of an unsafe language more so in the context of the white to uh news or you know announcement um paper how you want to call it to developers to desist from using CN C++ okay before I say anything I have to say I'm not an expert here but when I teach C++ I teach how to use C++ safely meaning of course you can do things like in C and C++ but this not how you should do C++ when I wrote my book about best practices I teach the model I teach the safe techniques and your responsibility is it to apply these techniques this is for me not a question is C C++ safe or not this is a question just use the right techniques and then C++ is pretty safe this is by the way also the job of me and my colleagues as a teacher exactly to teach rules exactly to use Concepts instead of templates or let me say differently constraint placeholders instead of unconstraint bra to initialize with curly braces not with parentheses and so on and so on to use let me put it differently n n n no NE you use just smart pointers use a unique putter and this is it so essentially it's not a question about C++ it's a question how you apply how you programing C++ so I put a general remark and once more I explained this techniques in my co guidelines book and and I learned a lot by studying the core guidelines believe me yeah I think this I liked Herb's blog post which he written U last week I think so that's like the one thing I probably not want to point towards is that blog post which takes this topic very serious it's very long it's almost a book you can spend several days reading that it took me 3 Days To basically read it in sessions and so I I hope that the committee takes the serious and from her BL post I have the feeling that they do but it's not like that we can you know flip a switch and have a safety Plus+ and so we'll have to see how you know this evolves um and as R said he's not the expert on that topic so we'll see maybe maybe get right we get her on on on here and we can talk about safety all day um and cpb2 and other things um but actually one thing where Riner is known for is mentoring and coaching so there was one question from the audience um when did you decide to focus on coaching uh honestly I have issue with the term coaching so what I want to dis distinguish is mentoring and training once more training means the classic way I give a three days class let's say about concurrency let's say about eded let's say about 20 and so on in three days I can only touch each feature mentoring is something totally different I make out of this three month uh three days four months we do each day each week we talk about different week this means um you have to invest around three hours a week these three hours include Theory pre-recorded exercises examples pre-recorded in a Q&A and the Forum and now you have to do your work and each Friday I I will answer your questions and this is now way we better first of all we can touch each feature a few times second from different perspectives third we can discuss it in the Forum or you can ask me questions meaning this is way way way more intensive and you will learn something not only in three days in four months therefore it will stick in your brain this the main difference a lot of stuff is prepared and I help you to master this this is mentoring it's also easier to deal with to handle more than 50 participants in a class it's not possible 10 is a lot 15 is the limit but this mentoring this case by the way all is recorded therefore also when you miss something you can watch it later so this mentoring and my idea is but our industry has still an issue my idea is that your company sponsors you gives you 3 hours awake and the corresponding Monday and you just participate and you do it beside your usual workload this is my idea because what because what we must learn is that learning is not one step this is a process and I'm honestly pretty engaged in this because I think this is the future it's definitely an interesting format um what is your newest mentoring program about then concurrency with modern C++ this means I talk about concurrency [Music] um in 16 steps about the API about threading about uh about R models atomics about challenges about patterns in this domain in 16 hours and this is my only Advanced one I have few four mentoring fundamentals which is the base which takes 32 weeks in which I essentially explain what you must know about C++ about C++ including 17 then I have two um mentoring which are based on that first is design and architecture patterns in C++ the second one C++ 20 and as I mentioned the newest one about concurrency okay so what's something you'd like to see in the C+ was standard this a question difficult question I think around concurrency there's a lot missing concurrent data structures for example AG company develops its own concurrence deck s safe stick strike St clue Lock Free clue additionally what I miss the most is when we have features which are not 100% done I find this terrible in particular we need Co routines implemented Co routines not only to generator because what I feel is that in 5 years each company has its own coroutines such as in the past each company had its own stream this is terrible and of course we need more functionality around networking and all you see I don't prepare for this question more help for begin meaning package package package manager maybe build support all these topics to support in general yeah because I think this is way too complicated I think there's a lot of things which are on the way but the committee is you know when you like the latest meeting was in Tokyo just last week and over 200 people have attended and there's was 26 is taking shape um have you been able to follow the work on C 26 no um there's a new question and we are again on concurrency uh do you consider boost AIO to be valuable in the realm of concurrent programming or can the same functionality be created from scratch using sdl I have to say I'm not a boost as expert but boost ASU was long thought to be part of the standard of the next standards networking Library um so can you say something about it uh yens so I only know that Bo as uh was one of the one of the future candidates for standard even for 20 but it didn't make it um most as has also quartin involved this makes it also a little bit more challenging so what's your thought um I I I think that Asia is an in certain parts an industry standard which we have and when we Tred to standardize it we saw that we need to have The Primitives upon which AIO is build first in the standard and that we do not want to standardize asio with those Primitives and then standardize different Primitives again and have like two versions of Kines or um schedu loss in the standard so this is one of the reasons why this didn't go through um but it's on the way so networking is in 26 uh probably coming in some parts um the whole scheduling and executor part is coming along um so I think from 26 and moving onwards staying with the threeyear model C++ 29 probably will be interesting and that uh era um could you implement AIO with the standard right now of course um should you I don't think that this is a wise option and on the other hand I'm also not like an a expert like what what issues you have with the a implementation how well it has aged with the new standards and um in that context it might make sense for somebody to write a fork or to implement reimplement these things okay let me add a few additional thoughts first of all Christopher who is the Implement of boost ACU adapted its or changed its implementation for future adoption to the standard so he also did a lot as far as know second what was second ah I forgot second then it will pop up in a few seconds as you um no let's just continue yeah okay um ah now I have it I don't like it when things are kind of and if innoval standard but not part of the standard the most companies at least half of the companies can only use stuff which is in the standard this just a it's a common company policy therefore we need such stuff standardized well um that certainly helps but you know um having boosts in in your code base then makes also sense um yeah but many companies you cannot do it that limits limits the applicability actually there's um a question on libraries from LinkedIn in your opinion what are the most important libraries for C++ that we need to know in depth PO let me first give you extremely straightforward answer the standard template Library uh the containers in the algorithms and the iterators in between of course because this is the basis of all this is what you at least then I would say making congruency without a library is not possible you must know the concurrency stuff so this question essentially depends on your domain what you want to achieve so in general I cannot say it but what I always say is you must know at least or the basics which is the containers the algorithms the inter in between and how to use them using for example lambas or function objects or anything like that and then you can build higher obstructions then when you use the algorithms and you do 17 you can also do it in parallel using the execution policies this is what is a must yeah and the rest depends on your domain I agree with that I mean there's boost and cute as the big ones which kind of you know are not so much in in certain domains and WX widgets um but then it becomes very specific and there's a lot of libraries there's a lot of libraries um which are maintained or not and um I I don't know if have have you like been asked to to give trainings on libraries uh the question is do you mean standardized liaries or free libraries I mean no but I had a few days ago a very interest interesting discussion with cute in the past cute fil the gap which was left by the C++ standard but this Gap is now almost filled by C++ standard so I asked him what can cute to what a C++ cannot do this was very interesting so things like what was it think things like um infrastructure Library such as XML readers security this is uh only D will include or what was it there's one big thing missing UI yeah UI of course but I only think more of the framework so what cute is way more more than qite it's a framework oh I know it's a platform but it's like in in terms of standard things which are not covered by the standard UI is a big thing which is and probably will never be really coverable in in a commercial way that would make sense to use it to be clear here um cute has a good string class cute a lot of things there which come with its history and networking for example is also some one of those things I I know what I forgot tcpip stti exactly this is what I forget forgot for example when I was responsible for a Dy this Dy should have in server on it and therefore we decided for sh okay so let's move on to another question from Link in U asks do you consider code written in C++ 11 as Legacy code due to newer standard versions of C++ what are your thoughts about the minimum C++ standard to be considered as more UN code nowadays honestly this a different a difficult question because the answer depends on in which domain you work for example I have customers from cens which canot not not even use C++ 11 because of their old chips and their old C++ compilers when I say you should uh switch to a Modern Standard I would say at least 14 not 11 because 14 fixed a few issues of 11 such as generic lambas such as generalized con Expo and this makes your life way easier additionally yeah these are the two most important things I would say in 14 so at least 14 not 11 then 17 maybe be a small step it depends if you need this features such as parallel sdl such as the three new containers from boost any optional variant and then comes 20 and 20 is a big big big step the fear the big fear are all change all the way you program so to come back to your question at least 14 if you can do it go to a new standard but at least 14 I agree with that um that you you probably should push for a standard that is is above 14 but if that's what you have to settle on that's finish and like there's like autosar which partly still is 14 depending on the version and um always there's like you know Parts where your job is in a certain context where you cannot change that you during due to being pinned to a compiler being an embedded or anything else like where that your environment fixes you to a certain standard um the other way is like I I want to say that also the context depends on like if the code written in C++ 11 is is Legacy that's not so much the case maybe for code base which is Well written um if you're more like needing to write new features then that should be on a new standard anyway let me see if there's some more questions um so anyways yeah if you have more questions please put them in the chat in LinkedIn or in hubo um in the meantime let's return to the Ming because that's something which Rina has pioneered in the last years um so you have four programs on mentoring right and how does a typical like mentoring program what is the structure so each mentoring has 32 or 16 steps each step is a week in each week each week consists of three parts Theory practice mentoring for example Mo semantics in this week I recorded the theory about move semantics which you can watch consume then in the practice part I discuss this the once more using examples additionally I give you uh around two exercises a week and also the solutions to the exercises this is the um this is the Practical part additionally to that I have a forum in which people asks questions which are answered by me or by others the last point is about mentoring on Friday have two mentoring 1 at 900 a.m. by the way German Time 1 at 10 a.m. 1 at uh 900 p.m because I have people from Seattle and Sydney so in this Q&A I discuss the topics of this week and also the forums questions and we may go a little bit deeper and then we may have additional discussions this um this q&as are also recorded therefore you can watch them later um in each week each week has around one big topic and this topic can be let me say divided in three parts each part has also a topic or a um a page further information in which I provide additional blog posts uh talks I gave in the past so stuff which gives you more information if you want to dive deeper so essentially the minimum you have to invest a week is 3 hours but you can of course invest 6 hours also when your mentoring is is over because there's a lot of stuff you be you can become a Community member meaning for at this uh time pretty small amount of money you can still consume all the all the stuff you consumed so far as long as you like this the soall community membership because my second goal is to build an active community which coordinate itself using the form because it often happens you have an issue with set let's say move semantic by your but your program is is done now you can go back and watch it once more or ask your question yes um um that's exactly what you also can do tonight ask a question to Rana grim and there's the next question um I recently worked with a C++ developer who was against deriving from regular based classes he wanted only abstract based classes interfaces do you agree with this restriction anyway let me put it differently there are two ways to derrive from a class essentially public and private um when you drive public you want to build something such as a interface when you drive private you do something which is called uh you derived implementation so this is the first thing I would uh uh differentiate most of the time you drive public to build this interface implementation hierarchy sometimes you dve private the idea that the derive plus can use the functionality of the base class but is not a base class this is the idea of driv private I don't see so far Point why you should not arrive from a regular based class what does regular based class mean regular means essentially this Bas class support the big six and additionally is equality compar and supports swapping so what does it mean when you drive from such a class I would say my first gut feeling is that I would not arrive from such class because a regular based class behaves like an INT behaves like an in is it's more in value in a value is something you don't want to RVE from these are pretty pretty how should I say early thoughts but I think they are right so let me think about it when you have a regular Base Class it add us the structor now does the structor must be so the point is essentially do you want to have to regular Base Class as an implementation or as an interface as an interface I would say it makes not too much sense I can also not think about implementation so in general regular based classes should be simple meaning more like values don't drive for them when you mean regular in the sense regular is defined the standard true um at that point maybe also should like mention that there's something called Static polymorphism where you use basically uh various types and use variant to join them and you can also constrain that with with uh Concepts and maybe what's your take on that on this way of programming Runner what you mean exactly by Static polym please do you mean just generic templat based yes that that place place into this right that that you can use templates this this is way way more template friendly but um what do you mean CP that place that is that is a pattern which um which also lists in this in this space polymorphism that's true so it's static polymorphism let me put a differ um static pois is a littleit strange C++ because static polymorphism is essentially the idea of interpretor languages baked into C++ what do I mean by that there's an common term for that which is called duck typing this comes from python when I see a bird that qu like a duck talks like a duck walks like a duck I call this bu duck meaning static po of means you implement something and then it may break because it requires addition and your D te does not support addition this is the idea of duct typing you just hope that it works and now it may fail because but now it fails at compile time due to Concepts we can make this du typing in C++ very very way more stable but it's still duct typing by the way the opposite is dynamic polymorphism because you have an interface and you can only use the types which are publicly derived from this interface this is a decision made at runtime but static is made at compile time and then we have this special variant of static polymorphism which is called crtp clly recurring template pattern but this looks really cursy but when you to 23 but missed using this it looks pretty nice and now when you also combine it this Concepts I think this is pretty pretty nice sorry for this long answer um that's okay there's a question from LinkedIn on the new languages coming in what is your take on the ongoing work on carbon language and cpv front this is also difficult to answer the most difficult point is for me there was there were there are already attempts to make the better C++ T rust carbo CP front and what I think is the most uh one critical point is which one will survive and which one gets the most lasting Manpower and I'm not sure if carbon May succeed because I no this discussion around 24 about D almost no one knows D anymore this was also the better C++ so I'm not sure how it will go out I think the mo most important point is how many people keep this alive are there companies supporting it in particular with money and Manpower and will there be any interesting projects using this language and of course these languages need a mighty Library therefore they have to interact in some way with C++ so these are key questions in the long [Music] run there are way too many people companies using CS bu it may become a little bit smaller but only smaller in the long long run there may be a programming language I'm not sure if Caron C front another one which is the dominant programming language in the future when it goes about abstract programming on the system maybe it's not invented so far you have to think about how young our Industries when I study I studied math we talked about uh the Greeks in our domain we don't talk about Greeks we talk about the last uh Century it's extremely new our domain and therefore there will happen a lot in the next time yeah I think it's extremely hard to say what will come from those new projects which basically just are play fields for ideas which is interesting for C++ again which can standardize those good ideas which came out of it and um there's probably also like in the future guests and in the show which can say more about this so there's again a question which goes more let me add one point yes when you just think about how complicated concr is we only know that the existing Solutions in all programming languages are way too bad this the only thing we know we we now fight about the right obstructions may be transaction memory send receiver post boxes uh future promises cor routines you name them we justy for them and we don't have the right obstruction so far we only know that one obstruction is not enough no is there any case where a class containing only public static functions as preferable preferable over a namespace this a pretty theoretical question okay what does public static function mean this means each function can be used without an instance you can directly invoke it on the class I honestly I honestly don't see a use case for that so to group them together I would say a name space is a good idea I think it's an any pattern too that's yeah reminds me a little bit to and single but is a different point true all right right we are now over the hour um R do you feel like we should keep going or I'm fine okay so if you have any more questions post them in the chat and we'll surely have a lot of more of things to talk about with Riner um and like maybe just I see this like you know we have had some questions about super plus features like what what's the most features or topics you are being asked in your mentoring program and trainings about this a different difficult question when it comes to understanding its coins often I give let's say in a 20 class a 2hour introduction to corins afterwards this sometimes was extended to one day because I wanted to dive deeper so I would say in 20 maybe modules and in particular GRS also Concepts so essentially the big four so let me also think ranges but from the understanding point of view it's cors and from the usage point of view modules um someone asks like you know what is your take on nik's view on 20 views that they are broken or generally your view on views and ranges do you agree with NI there is also a difficult question because Nico is my friend but Nico has an or extraordinary skill to find this issues this broken issues I also wrote about 20 and honestly I didn't fall in the same trips but n is in this kind a little bit special he's extremely good and he finds this one two maybe 3% which are really really um AR such as this discussion about to Bas for loop it's a little special regarding niik but this is not a complaint it just sees the issues and I would say the most users will not see these issues so he's right but from his point of view this was a diplom I answer yeah it's um I partly agree with that it's like Nik really well and once I have once heard from a Committee Member that uh the one thing is like that they the one thing they don't like about Nikos that he's usually right and um so I think there's some issues which he discusses but also there's I've heard some committee members that that's like the wrong angle um but that's uh not what we have to debate today um and I'm sure that we have niik on the show at sometime then we'll be able to fully go in depth with those things um but what I totally appreciate about Nico is what I hate is when someone says this is bad but he also shows a solution and this is what I totally appreciate yes I agree with that um I see no more questions right now but maybe there's more questions coming in um I um saw you talked a lot about and have like updates on your blog about your RS journey and do fundraising and exactly so maybe quickly want to you know talk about your activity on on on this field like with your fundraising activities in ALS of course I'm personally involved you see I have um Al SE have I need something to fight for and now we start our second ISS money raising Campaign which goes directly into is research you may ask why the reason is pretty simple alss research is heavily underfunded in contrast for example to cancer research this changed in the last last years but it's still not fine therefore research depends on donations which is really hard by the way this money does not only go to is it goes also in the other issues with your nerves such as I hope this is pronounced in the right way Parkinson MP SC I don't know to the English but any other of this kind of bad uh uh issues so next Friday we start our next money raising campaign and this time I I have to say four of my colleagues are involved his colleagues I mean book writers be um be surprised what you see so at Friday for one week you can have around 15 books 10 15 books with an significant uh K and the money will directly go to our research this time I will give it to dig digital research the idea of digital research is to try something out digital see what could have a poent what could have a potential and then do it with a trial therefore you can do way more in a short time because we are now uh in a time where we can expect the first uh significant improvements all right so we have a question which I copied from Hilo to Linked In because it's too long and cannot display it in in in streamyard but if I bring it in here as okay from LinkedIn then it works with futuris promises the threat that has the future is relying on the threat that has the promise to return and not hang do you see a use case where threat should be able to kill a worker threat do you see a use case I have issues with this killing a thre why first of all we don't canot do it in C++ 20 and second you don't know in which state the threat is maybe it's holding a look and now killing it would be terrible what we can do in C++ 20 is cooperative interruption meaning you can send a signal to a threat or let's say a promise and the promise can you react to it by saying for example I'm done this means Cooperative Interruption by the way one who implement this feature was niik so let me bring him in so this is what you can do use cases maybe you search for prime number and when you have the first one you say to the other threats stop your work because you only want to have one so there are use cases yeah I think this can be done pretty elegantly with Cooperative Interruption which is essentially only a signal mechanism yeah I probably agree with that it's like it's like for me I don't see that you Pro programmatically kill a threat and in in a way it's like maybe like you know you start two threats and one of them is faster and you kill the other one you already have the result but that's not like uh what most people do right in like in their programs let me say this way it's possible in P SS but it's exactly it's mentioned you should not do it so it's part of the P API but not of the threat API we cannot kill so I mean the one test case the one use case I have for that is testing that you write a test where you kill a threat and you you know you maybe you have the um you want to see what your system is doing then and okay that that could make sense but in in in in production code I don't see it um but already like doing this as a test case is very contrived because that's basically um going out of the bonds where your program should be happy with um you've also mentioned like that there is like on Friday on next Friday when this video also will be live on YouTube um there will be C++ books and maybe you should quickly also talk a bit about your C+ plus books and um I do you currently like you know plan to are you working on on on a new book or not so far the only book I'm always thinking about is introduction into templates I think this is still missing but I don't have time to write now one similar such a as my introduction to coroutines not to go into concurrency because I think the book of Anthony Williams [Music] um extremely good extremely good but it's already advanced what is missing is to write a book which brings the beginner to this level to consume anon's book and the same goes for templates the book from niiko Dr greator and um DAV Wonder worthy about templates it's extremely good but way too advanced for the beginners we need a book which fill the Gap from beginner to Advanced this is what often missing in C++ we don't have these books we need books to fill the gaps not only advanc books and therefore we need such kind of book that's true but writing books is difficult yeah of course all right so um I think with that we have reached the end of questions from the audience um oh no wait there's a question uh there is a question on books which is um on books what's what's your opinion on what should be the maximum number of pages a book should have what what should I do with this question I don't know honestly uh let me put it differently I wrote two books about including 17 theor language about including 17 the library C++ Library why because the excellent book from nio has probably 1200 pages this is too much for beginner our goal must be to explain our story in way less Pages therefore I try to write shorter books which I cannot always achieve but I wrote about cor languish in 300 pages I wrote about the library also in 300 pages but not in 1200 once more Niko's book is extremely good but this is not a book for the beginner also be his books more than thousand P 4,000 Pages this is nothing for a beginner you cannot learn a language which has more than thousand Pages you should start with 200 pages and then you should dive deeper so my point is explain your story as concise as possible but not shorter this is my idea I failed in my king code book called guidelines but my book about the core guidelines is way shorter than the original at least my ideas you read it from the beginning to the end and you are done and this is for me the right length of a book because what many people forget is night shop is also to provide you the essential material not all material the essential material and I I'm the filter for you that's true I've heard from a different author that they that you know had a page limit so they had to you know they had more material than was fitting in the book I know I know the book by the way I know by the way the book because I know who we talking about that's possible there's many authors which both of us yeah but I no this discussion and I I know that you went for self-publishing and other authors did that too a few years ago and I think you're still happy with that decision this is a Prett good decision because it's your book you can do whatever you want and then when your book is good other people will translated in different languages with that we are through the part with the questions um thank you for coming Riner I was really big honor to have you and also great to see you know things are good with you and that we able to keep going and see a lot of contributions from you even in the future um because that's like really really you're one of the big big contributors to C++ in the order of explaining and I want to just thank thank you to that I only to what I love to make it simple okay so um with that I'm going to take us offline thank you to the audience um bye and