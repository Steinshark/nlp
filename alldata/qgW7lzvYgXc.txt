welcome to tonight's lightning talk session which streams live from the whole beatles and not in the video studio but from different studio and um if you have any questions there's a panel after the talk where you can you know uh just have a general conversation with us about all and everything which we do with the lightning talks tonight yeah just i don't need to talk about the conference um tonight's lightning talks are five to ten minutes we have five speakers but six lightning talks um so probably less than an hour we'll see as i mentioned there's a q a panel and these are tonight's lightning talk speakers yes miroslav christopher killian siren and i have a talk at the end again so let's get started um i thought for starting the lightning talks and celebrating the two years i say a bit about what we did in the last two years and have a little look out into the future so today meaning c plus plus online is you know as you know it and two years ago we started this to explore things in the online world um and i'm kind of happy that today we do have almost 2 300 members um so when this group started um it was important uh as a playground to meeting c plus plus to see what works and from the beginning i wanted to see if we could do more than talks where just somebody gives a talk and we ask them some questions and then that's it um so that is like how the affairs got born and the event in may which was speaking about c bus plus uh which i organized which actually featured lightning talks but was like a closed event so you couldn't like submit linux talks to it um made kind of for me the knowledge available that we could do lightning talks that we have the technical setup to do it and so hence we do it um now in the group and i don't know how often we do it um but we'll do it often enough to to have a few runs so probably like twice twice a year that would be good um and yeah we started on ramo and ramo had this particular feature that it has two states where a meter runs them and the first state is what you see is basically a break state where people sit on tables and talk and then the software will you know give you a countdown for 30 seconds and then you will transition to the second mode where you see the talk and i started wondering um if we could utilize remo for something else which would not feature a talk if you could utilize these tables for events and that's how the fares basically got born and today is a job fair and also uh broken tools here which i'm going to talk about in a second and last year when i looked for valid replacement for remo i got to see ubilo and in the end uh we're hosting on hobido and i can't tell you already the next year the third year which we're now having uh will also be on hobido and today and tomorrow are actually the last two events which are on the world contract um and our track record for the two years is pretty good we have over 50 online events but you know some some other things count as two events on meetup um like the job fairs and there's also the conferences from last time this year and 2020 and meeting embedded etc so less some some things more but that's that's a good run and there's like in uh september we have seven events and i might even like be looking into having having and currently we don't have an event on the last week and maybe i have an event which is either in the in the last week in september on the first week of october i have to see if that works out um and the fairies are a great success but they are also a lot of work so i'm always looking for people to wanting to join and you know be a company that employs people and is at the fair has a conversation with the folks coming to the fair and also you know receives for that effort uh a lot of cvs and uh resumes and same as when you have like a tool or when you have a book which or an open source project which is related to c plus bus then you can have a table in the lounge for yourself on the book and tool fair and basically have this folks come to your table and you can have a conversation about your tool or just anything else um and a quick overview on what i plan for the future um we do not have cpp cast anymore so i would like to offer an alternative not like cp because i cannot replace cp because but i would like to make armas and armor stands for rsp anything in a recorded version available that we meet with somebody in who below and record the session in the rooms and simply have them you know answer our questions and have the conversation then later on youtube for everyone else to see um tomorrow is something new community planning session is something where i got into when i was looking like hey how did we get started what did i do 10 years ago because 10 years is now also for reading cps plus and i kind of found a news entry about a community planning session which we did at the beginning and i was like it's actually kind of a good idea and so i thought well if that worked you know 10 years ago we have no means to do that again just back then it was an irc now maybe not not use rc anymore so it will be in hobilo kind of using today's event again and of course also something i found this year was this um as you know means the plus plus is my main job that i want to use uh the tooling uh which i use for the user group and the user group itself and some of the other things i built was meaning cps plus a bit more for promotion to actually uh have uh also like this hiring and supersports event um be more targeted towards people that actually want to hire folks and our recruiters or job leads or team leads in their companies so that i can win them to have a starting corporation on the job fair with me super plus and then i want to mention sponsorships which is something i would not have mentioned if i wouldn't have a sponsor for the first time in two years for the events next week next week is our regular up for september with a talk from johann von stembroke and which by the way he's here so if he hangs around maybe you know can ask him about that if you're interested in co-routines but that also is sponsored by undo and i'm very happy to you know be able to get a little bit of funding through them uh for the things i do here um and so the next events next week we have the uh regular meeting which i just mentioned but we have also the book on tool fair which is also again as you can see um attended by undo but also by the author of beautiful secrets which this guy for sure and i'm not sure if um kate has time maybe kate comes around maybe not we'll see um then yeah the hiring and z plus plus i i do that this time in linkedin and that's also kind of a new experiment to see if that works and continue to be used and utilized as a platform um and the online cpus bus job fair um will be in september as already mentioned all right tomorrow we have a community planning session which is actually targeted at folks who want to organize or reorganize things in the community and for example use the groups and i i currently think about starting a learning group that you can uh have a membership in and um have weekly meetings where we then uh discuss things for c plus and i've just uh you know dug through my old teaching materials which are all in german and i have to kind of translate them to english and update them because they are quite old and then i probably will provide some learning materials and provide the space for the debates and also kind of make this a group which focuses on the needs of the ones which then are members and will openly debate like where do we want to go with that um and that might be based on patreon i probably also will offer the billing through my website because it's always the way like you know companies uh should pay that for their employers for employees um but we'll see that's that's something which is gonna be something new and that is all the thoughts i have on those two years and um yes i plan to carry the online events forward as long as it makes sense as long as people are showing up and i think that we will have a fabulous time in winter and we probably always will have a fabulous time and winter and the summers will be free which is nice also for me um but now we see that september october and november we will have a lot of events and i hope to see you at one of those many of those thank you for listening all right the next talk is by miroslav let me quickly share slides and you can start thank you yes for this opportunity to speak to have a short talk i start my timer just to not go beyond our limits um so hi my name is mirisov poka and for in this short talk i'd like to talk about a single entry and single exit rule basically for the software development as we all know we have different rules we apply on our discipline of software development just to make our software more reliably reliable to keep it maintainable and most of all reasonable sp is especially important when several people are working on the same code base so one of those rules is single entry single exit and i had when i stumbled upon this we i got have a closer look at the rule so what is the rule all about so this is the the rule more or less it says that sub programs should have only a single entry and single exit uh point so single entry and signal exit only and it is written like this in this safety norm iec you can see it on screen in the part 7 and given section which gives us some techniques and measurement measures that we should apply to our software to make it safe and good for safety related systems as a reference it it quotes a structured design book which is pretty old 79 which in turn um says that it is highly is it's really was highly influenced by uh the notes uh on structure programming wrote by mr dixtra in 1970 so the idea back then was to simplify the flow of the program because back then the typical programming languages used were assembler fortran cobalt there was no c there was no c plus plus and in those languages especially in assembly and fortran it is easy to jump all over the place in assembler it is clear but then even in fourth run we can jump into a subroutine procedure and start it not from the beginning but a little bit later it is possible of course we can jump out of it uh also earlier so that led to the code which was kind of spaghetti and uh sooner or later people realized we have to do something about it because the code becomes uh unmaintainable and hard to understand so that was the the proposal uh to to solve this problem or to address this problem and and mr dixon wrote quite a lot about this uh not only about the structure of programming but also about the go-to in general she said it's not a good idea to use okay where is the rules uh used so as mentioned already these iec standards say that explicitly misra took this standard from this standard from eac and it says with a little bit different form as you can see this function should have a single point of exit at the end it is clear because they adapted it to the modern languages modern so 90s so when we start a procedure procedure uh we start always from the beginning so we are not jumping to middle of it but we can still jump out of it quite easily in google uh style guide it is not mentioned at all so it is left to the user autosar uh explicitly say that we are permitted to jump out before at different places and iso c plus plus coding guidance go one step uh forward saying that just we should not insist on applying this rule uh so they are just a bit more on a liberal side and so just briefly what their rule how the rule looks in a practice left side and right that we see the same code but on the left side we have this rule implemented on the right set note on the left side in both sides there are just three conditions to do something and and the three different situational and return different error code when when conditions are not met so it looks like like this more or less and uh but we have one single exit point on the other side we can just check the conditions at the beginning and exit early returning the appropriate error code and only when all conditions are met we are doing our stuff so this is more or less the difference in a a style and yeah so for my personal point of view i prefer the second version because it gives me a bit more easier to understand code and if we compare different uh the advantages and disadvantages of this this style um i sorted them out into three categories readability resources and debugging readability i meant in bold because i think this is this is something which is for me personally extremely important so on the the single exit single single entry and exit rule uh as you we could see before um pretty quickly gets hard to understand when we have a lot of nesting inside then it's it gets a bit problematic on the other side uh when we are a bit relaxed about this and we can exit early then makes it makes our record easier to read and which was not visible but it's worth mentioning uh it frees our mental resources when we when we know that at some point in the code from this moment on we can focus on our task because our pre the preconditions are already solved or taken care of so that's that's one thing on the other side is more sometimes people are saying it's more about resources so they are in uh using the rule we can ensure that resources are free uh are free at one place and the rule is not that on the other side uh it was a pro it could have been a problem before but using um c plus plus and uh resource allocation is initialization we can we can pretty nice get around it so even if we exit early and we allocated something uh we may make the code so that we don't lose resources well i've heard also opinion that and debugging is easy regarding single entry signal exits because we can set this one breakpoint somewhere at the end and we know what is when we stop there we know what was before when we can inspect uh the previous variable you know in on the other side we have to take a several break points so that's that's like uh that's the comparison um all the links are due to standards i i mentioned before i collect it in one place and here are the links if if later we are going to share this these slides and uh also i collected some links regarding the some discussions there was on stack overflow regarding this uh which was quite interesting to read so finally what was the conclusion well i would say so it was just a quick overview in few minutes and in my personal opinion to that is that as i mentioned before readability is the most important value at least for me so if uh using the rule makes the code clearer and more understandable and readable i would definitely go for it if the other thing if it's not the case so if applying the rule like in the example makes the code harder to understand i will not use it so is up to you to apply it or not i would say if it makes sense do it if not don't so that is it and thank you for attention thank you mr and the next speaker is christopher so here you go christopher you're ready then we can go you need to unmute yourself all right that was the last thing um okay so in uh in today's world we have uh we have um c plus plus 20 and c plus plus 20 one of its features is boasting modules um unfortunately for us the majority of the world does not use c plus plus 20 and it will be some time before we can use c plus plus 20 which means that the majority of code is going to be unable to use modules um this is also problematic because even once code moves to c plus 20 that does not necessarily mean that we will be automatically using modules for modules in c plus 20 we would need to do something like import uh std and that would get us the stuff but up until c plus plus 20 we've had to dutifully write hash include utility hash include um vector and so on and so that means that unless implementations will provide us with what are called uh header units which are a map it was just sort of like a bridge from headers to to modules then we don't we don't get this this feature um just by flipping a switch now the standard library will definitely provide these header units and uh lib c plus already does this for clang i wouldn't be surprised if uh if libs did c plus plus the g u implementation does it for gcc and msvc's stl does a similar thing for msbc but this doesn't necessarily propagate to [Music] third-party libraries and so we we still have a bit of a problem and it'd be nice if we could get some of the functionality of modules today so one thing that we can do is if we're on clang we can actually already start to take advantage of this this idea of header units which starts to treat headers like they are modules today and the way in which we we do this is by enabling the uh the f modules flag and um and that will give us module uh module-like functionality for example this is a test case as a test suite that checks the casts in uh in utility for forward move uh as const and a couple of the others now something that is uh that is not in in in utility is uh f puts that's in c studio so if i were to do stud puts and then say hello meeting c plus and then i were to run what is the name of this test it is just casts okay so if i were to run ninja casts and it builds however if i were to be using modules then it would have said no no you can't be oh right okay i understand what's going on because this one is a special header so i need to pick something else such as perhaps an iterator why don't we why don't we pick something let's just double check what's in test and so we can see that there is a ceased io and so this is just a traditional header that will that will be like a copy paste and so this is not necessarily going to be a beneficial thing for us because we're still getting the preprocessor working when a header is treated as a textual unit but let's let's now pick something that isn't mentioned in this list of things from this list we can see that a bunch of them are c headers followed by type traits and concepts so as long as we don't pick up where pick one of those then we should be good so let's now go back down here and we will say auto i equals sturd input greater tag that is a good one and so if we look over here we see that we get the traditional error of no member named input iterator tag in namespace stood fixed available and that fix would be to include iterator however that's the pre-process that's that's what's happening in without this without without the modules enabled because clangd doesn't work well with modules so i have turned off that feature however if we were to compile it now i need to ninja oh i haven't saved that's the problem if i now do this we will see that there is no there is no [Music] name is and we still are not getting what we want so what we can do is we can look at the at this file inside the standard library called a module map and the module map is basically a way of saying this this thing is is going to take this file and map it to a particular con to a particular module and this this is how we can say build up a set of header units so what we want to do is we want to make sure that uh that the the uh sorry pardon me you want to make sure that the uh that the uh the module has all the things that it uh that it needs in order to build this thing out and treat it as if it was as if it were a module and i do not see the thing in here that is necessary so we can change this again um to incrementable and then uh we'll say auto x equals zero two and [Music] uh we will also just do this and again we can see that there's no no incrementable in namespace stood and you can do this again and uh okay i've named it x which is the problem here y and we'll try that again and it gives us the same error um so i'm going to have to end this here but the uh the main idea is that with with clang modules uh header modules we can we can compartmentalize things and uh thank you for your time thank you christopher that was interesting let's go ahead and bring kirian back in the stream [Music] yes right thank you very much hands um welcome everyone to 75 sda letters in under 10 minutes so i would say you make yourself comfortable lean back fast and seat belts because we are about to get started algorithms this header contains computer science algorithms which mostly operate on the sequence of elements and since c plus plus 20 this sequence of elements does no longer only have to be provided as a pair of iterators but can also be provided as a range or as a payoff of an iterator in the central you've got the any type which is a type of measure wrapper for any copy construct to give a type we've got array which is a wrapper around the c style array and provides a container api as well as better uh type safety than the system area we've got atomic which is a class template that you can instantiate with any structure layout type and then it provides very defined concurrent access from multiple threads we've got the barrier available in cbs20 which is a reusable fat barrier that blocks up to n threads and when the last thread arrives the completion function gets executed and the barrier opens again we've got it a bit which contains an enum endian to query the endings of your hardware and as well as several functions to access manipulate and process bits and bit sequences we've got sedbit set which is a fixed size sequence of n bits that you can manipulate in access we've got charcon which provides conversion function between a character sequence and either a floating point or an integer we've got caller which is the date and time library of c plus plus it mainly consists of clocks time considerations and since c plus plus 20 we also got calendar time calendar types and time zones the compare header provides library support for the three-way comparison operator also known as spaceship operation in complex we've got complex number support our concepts define some common concepts that are used throughout the stl condition variables a synchronization primitive that can block a thread until it gets notified and some certain condition is verified uh coaching provides library support for coaching as well as the class template ncd coaching handle which is a non-owning handle to the actual underlying protein that the compiler generates fast our deck is a double ended queue exception provides the base class sed exception as well as the terminal handler the exception pointer which is some type of shared pointer type to store any exception object and we've got library support for an asset exception enables us or provides us with policies to concurrently execute algorithms the file system gives us the possibility to access and manipulate files directories and paths format is a text formatting library which is typeset and also extendable by specializing the class template sd formatter for your own types forward this is a singly linked list have screen provides the basic stream buffer as well as io streams to do file i o function provides functional checks to do arithmetic and comparison like plus minus less it provides a standard hash function the type erasure wrapper for any callable object called scd function and other from future provides types and functions related to other current tasks for example you can query or wait for a future or chat feature to get some results that the promise can set in another thread initializer list is a view of a constant area that's get press initialized io mana io mana provides new information and work with arguments and as well as the functionality project ios provides student related stream manipulators that are unblocked without arguments and it contains the two base classes for screens and working with screen buffers we've got an ios forward declaration header ios stream a few global objects the lcrc lock and see in ice stream provides the high level streams for reading and both reading and writing hr writer provides tactility concepts for six kind of iterators provides iterator traits and as well as adapters like a back inserter and utility functions to work with iterators a latch is like sd barrier but it's a single usage threat barrier so it can only be reached once uh limits provides a class template acting numeric limits that can be instantiated with fundamental numeric types and provides options to create properties like the minimum value maximum value and so on scdlist is a single a doubly linked list sorry local provides access to um cultural differences like character classification number 14 formatting and can be also overwritten by the user we've got two kinds of sorted maps of key value pairs a cd map where each key can appear at most once and multi-map red can appear multiple times we've got a memory management um you've got a memory memory with the managed memory management support sorry smart pointer three different kinds of those and also atomic support for sharepoint and weak pointer we've got the allocator traits to access an allocator pointer trades to access pointer light types and some utility functions work with your wall storage we've got memory research which contains the scd-pmr polymorphic allocator which is an allocator that grabs a polymorphic sad pmr memory resource and there are also three concrete predefined memory resources uh synchronized and unsynchronized resources as well as monotonic buffer resource we've got the mutex header which provides synchronization support by mutually exclusive access we have several different mutexes and we have some ai locking classes as well variatic functions to do the locking and avoid deadlocks bars we've got some low level memory management in the header new for example the new handler as well as overloads of operator and ui delete including some attacking node for a line and destroying the lead we've got um mathematical constants and the header numbers like pi and e we've got the numeric header which provides numeric algorithms that also work on the range or sequence of elements but we also got gcd lcm and little point we've got option which is a wrapper around some type t which either holds the value of the type t or is empty we've got oh stream which is a high level facility to write your basic screen map as well as some output manipulators we've got the sctq which is a container adapter which represents the first australian queue as well as priority queue which also takes the comparator such that the underlying container is sorted with respect to the comparator and represents the heat we've got random to generate random numbers the randomness comes from some uniform random bit engine which first uh well produces a randomness and based on this we can have a distribution like a normal distribution binomial resolution which then generates a random number we've got the vendor's levels in c plus 20 it heavily relies on concepts for example range boat range of view then we can have some range factories like your single or yota and most importantly probably are the range adapters where you can take a range and type it into for example the filter view or reverse view we've got the acid ratio which takes a numerator and the denominator has compiled arguments and then provides some compelling mathematical comparison and we've got pre-refined type that's like microcenter which are also used in the chrono library we've got a regular expression library scope allocator provides the scope allocator adapter such that you can have a multi-level allocator which you can plug into a multi-level container like back door list of set of string or something like that similar form provides accounting symmetra which is a synchronization primitive that controls access to a shared resource like a mutex but other than the mutants you have some counter n which gives the maximum amount of threats that can uh enter excess that resource simultaneously we've got two kinds of sorted sets um the sad set ensures that each value of key appears at most once and all these sets can appear multiple times we've got a shared mutex header which provides both mutual exclusive access but also shared access depending on whether you call log or log shared the source location describes a source in your code containing also a file name and a function name and the magic lies in the aesthetic member function current which gets evaluated at the call side and gives you a meaningful object of type source location we've got a span which is a non-only view over some contiguous sequence we've got stream which contains a stream buff as well as io streams to work on strings we've got stack which is a container adapter that represents the last in first out arm stack we've got sd accept which defines some common exception types that are used throughout the stl we've got stop top which provides threat cancellation with threat cancellation mechanisms so you have a stop source where at some point you can request the stop and then you can have several stock tokens which continuously poll whether a stock has been requested and then do some certain action based on that uh screenbars is the base stream buffer class that we have which controls input and output to some character sequence um where we've got our lcd string the stream user read only view over some contiguous sequence of characters sync stream is a synchronization mechanism to synchronize the output to some old stream for example c out system error provides some low level error codes as well as the exception type as the system error which then wraps an error code we've got sc thread to start a new set of execution and since equals 20 we also have the joining thread um which joins automatically and can also be cancelled and we have to mess with at the end to access the current thread we've got sc tuple as well as some helper function for it we've got sd type index which is which is a wrapper around lcd type info and provides a hash as well as being copied which makes it easier to use in containers sd type info is the rtti of some type and the result after calling type id type trends provides some meta programming facilities to inspect and to transform types of compile time we've got two kinds of hash maps of key value pairs as the another map where each key can appear as at most once at once and that's the unknown multimeter that can appear multiple times we've got the same for hash sets basically our utility provides a pair as well as integer sequence and some utility functions we've got a numeric vector called trial array we've got a variant which is a sum type that stores a value of one of the types you specify in the template argument list we've got our vector or dynamics contiguous area and last but not least we've got versions in single responsibility which provides some feature test markers where you can check whether certain features are available or not thank you very much ah 75 indeed that's interesting thank you um which yeah thank you kirian that was really interesting um thank you um yeah i want you hi meeting c plus plus online i want you to make error handling your user's problem it turns out they may thank you for it it says will users are ungrateful sometimes they should [Music] this is inspired by bendin's now six year old talk using types effectively and and by a problem i had at work some time ago now uh but the very short version of it is you should write some total functions because they're easier to understand and they're easier to write and i have some very bare bones examples i'm sure you can extrapolate them to your own work but let's say we want to count some vowels in a text string it's not hard except what's the return type here what if they hand us a null pointer right we can't necessarily just always give a good answer you could say that there are no vowels in a null pointer but you could also say that a null pointer is not a string like it's not a string of chars so what do we do do we throw an exception some people hate exceptions we could make auto a pair right this we've seen this one before or it could be an output value or anything or we could just throw up our hands and say to the user actually you know what if you give us a null pointer that's ub like just don't do it there's a precondition on the input that you don't hand us a null pointer or you could just use a string view you could just use a string view obviously if you're in some very special case where you cannot uh use a string view or if your code is space is old enough then write your own string view if it's not in the standard yet but you can just use a string view the return type is a size type or it's an integer if you want it to be but the point is it's it's not in doubt like this this function is so easy to implement that it's almost it's almost embarrassing to talk about it like implements itself there are no weird edge cases with a string view solid return type and the users don't need to read the documentation for count vowel like you can see that single line of code returns the size type takes a string view i know what this function does i don't need to read any documentation now this is a symbol function but what if i don't need to read any documentation for other functions so string view is in the standard let's take a different example the reciprocal the inverse of a double i mean we we want to write it like this like that that's what we want to do but of course that's not how doubles work doubles aren't real numbers really um we have a we have a bunch of preconditions each of these preconditions you could write them in the documentation the user is going to have to find out how how this function works somehow does it throw what does it do who knows but you should solve this problem exactly the same way right you should you shouldn't take a double you should take a divisor devices class you write it yourself in five minutes and handles all of this so the function has no room for error anymore what if the user has a zero though what if they try to construct the devices with a zero that's what i mean but you should make the error the user's problem obviously if your user can use exceptions you write devices so the constructor throws that simple but if you don't the private constructor right have a static function in the divisor that gives you back an optional divisor or if you don't like optional in your code base because it's c plus 11 write your own optional but either way your actual function reciprocal is that symbol now this does have a problem because if you take every single input parameter that you have in all of your functions that currently throw or return errors and you write classes for them i i have i have some sad news there's nobody who wants to read all of the documentation for a whole new class for every input parameter that's gonna get old but if you adopt this approach also of course consider adopting a framework do something like this the user that this is this is uh the cpp file uh using device or that line goes in the header file along with the with the function function signature so the user can see what it is a divisor is a constrained double it's not zero and it's finite and if you're not if you're not familiar with the c math uh library finite means it's not nan and it's also not infinite it covers both of them so i guess you have to know your your standard headers to know what this line of code means but the the great thing about this is that it shows the user right here without having to go anywhere to read documentation what the constraints are on a divisor you're going to have to write the constrained class yourself and your user is going to have to understand it but once they understand the constraint class in one place then when you use the constrained class in a different place they don't have to read it again it's just a set of constraints and if you name your constraints well you can read them all on that line see exactly but the requirements is for a double that wants to be used as a divisor so concluding really you should enforce your preconditions within variance it makes your functions much better it also lets your users select their error handling because if they can't handle exceptions you can just in your class that handles your parameter not use exceptions it's all been pushed out and instead of writing and documenting a lot of parameters you should consider using a framework to save time [Music] that's that's really it i wrote a framework like that earlier this year it's fantastic it's going open source in a very short while but if you want to have something in-house write something in-house it's it's not very hard and it solves a lot of problems hey thank you that was interesting thank you sir um now oh yeah right i have also prepared a talk so i've been looking into charts and how to do charts and qt because cube is what i use for ui and if you follow me on social media and other ways around you know to have spend some time with smart platform you probably know that i like charts and on the one side you see the most recent chart i created which is uh data from the job fairs and i was wondering hmm if we can have some population data on the percentage of what people had submitted or identified with that'd be great and that's the graph that's some of those graphs have really been a modern work of art and then i have graphs for some time now in the survey which are bar charts and um the new type is a the line graph and for the line graph uh what makes line graph swimming more difficult is you need to have a lot of data points from something that is interesting and multiple of them probably to make that worth looking at but i you know so how do you how do i get those charts into the cute application that's like for me one of the things i was thinking about and i did some research there's two ways uh you can go the qml way and you can go the cute charts way with c plus plus q charts is a cute extension it's under gpr and commercial license either if you use it as qml charts um and that is the way that ships was cute where you can you know draw your own charts and put all your charts into your ml but there's an alternative which i found which uses on qml um chart.js and it's mit licensed um there are of course also some other ways you know you could use a webview but that's you know bring in chromium in your application that's a little bit too heavy um so i'm not going that route um so the way to use qml and not use q charts and have an mit chart library in yours in your code base is this which i could find under github and it looks kind of nice on the at the first class it uses an old version 2.93 the 3-0 branch of chart.js uses web workers and web workers are not supplied in um charges uh no not web workers are not able to run on qml that's the issue um it's mit licensed and with the usage i still have to play around with it and actually make an application that gets data from cpus plus into the graph um so actually you know importing actual data in the graphs is for me still a question how that really works and the advantage for me is like there's a qml widget and so it also would be working for a few widget-based applications if you know one can find out a good way to have an api to get data into the graph from c bus and also let's have a look at cube charts uh q charts draws really nice charts it's no way less or better it's it's equal to the the other chart solution maybe a bit better it uses the graphics view so it's more it's more um natural in your application if you use cpus plus uh you need to install it from the maintenance tool and if you have commercial licensing for qt and with your employer you can use it it's there otherwise you will have to face up this libraries for the open source world under gpl which might not make your employer too happy and also how i learned when i looked at the qml example that if you use it in qml you need to exchange your q gui application instances for q application instances because that is the dependency which you get with graphics view framework which internally is used to draw those charts which um i would have never guessed that this is the case without reason reading this disclaimer um so sometimes it pays to to read the documentation now um and this is a small example which i have written with cute charts today um it basically has a button and it has a chart view and this chart view has a chart and then i just use in this part align series which i generate and append to the chart and then add sirisin so i have three different lines with random numbers being displayed and it's really fun to click on a new chart and see just new lines coming up so and yeah let's make that a bit bigger that you can see the code actually um that's very easy written code to to have some charts in in the application but what about the gpa again right what if we could contain that to its own executable i think that's actually a neat idea to have a cute chart server there's a tcp server class in qt which i have never used and i finally find a useful and small contained example where i could put that to use so one usage example you would have the client send a chart request and probably prior to that start the server if it's not running um and the server then would um probably need to be a gui application because those charts need to be drawn and i think that needs to be in a gui interface and also in the main thread um i think and then you get the response and the response would be telling you that your chart is ready but also either that would be json containing a binary like base64 encoded string or the chart request took the other route and telling the server to write because it was running on localhost to write it to a file to a jpeg file or png file to be used because some of my use cases i would rather have it as an image i could post to social media or use a blog post then to use this in some other manner and this client would you know be responsible for creating the chart data objects was filling it with the data and writing these to json also needs the size of the graph if you know if you have an image or if you have like a window you probably have a size which you know might want to be bigger than that um to scat it down again and all those things you know that's something which needs to be handed by by the client and then you send it to the server and later the client's job is also to notify the application that your chart is here right now there's two ideas which are probably both fairly easy to implement which i'm currently thinking about when and that's probably going to be winter um and so with the gmat example i'm not sure if it's still working with q6 because this code is like three years old and the chart js is also kind of old so the newer gs examples which you find on the web are useless so um that probably has some group to get running on the other side um writing a server application sounds like fun but uh in the actual environment to get this to run with the applications and having this run in the background i don't know that's like on the long run a good idea so charts are not lightweight but it's trying in javascript and pml to have some charts it's nice but it's not going to make your application lightweight same thing with uh like having a full-blown server application running in the background to have charts uh the server application would have the advantage to uh you know when you have several applications running at the same time you would have only to run one server and you'll be fine um and otherwise you'd be having to you know have running this code again and again in your applications but that's probably in today's environment fine if you're not like an embedded but who wants to have a chart and embedded right and that brings me to the end thank you for listening and also thank you for everyone else who has contributed to today's meeting with lightning talks and we're going to move over to vito now and see um wolf as you know um will be there and then we have a panel there to start the q a panel on the landing talks