um okay so in uh in today's world we have uh we have um sql plus 20 and c plus 20 one of its features is boasting modules um unfortunately for us the majority of the world does not use c plus plus 20 and it will be some time before we can use c plus 20 which means that the majority of code is going to be unable to use modules um this is also problematic because even once code moves to c plus 20 that does not necessarily mean that we will be automatically using modules for modules in c plus 20 we would need to do something like import uh std and that would get us the stuff but up until c plus plus 20 we've had two dutifully write hash include utility hash include um uh vector and so on and so that means that unless implementations uh will provide us with what are called header units which are a map it was just sort of like a bridge from headers to to modules then we don't we don't get this this feature just by flipping a switch now the standard library will definitely provide these header units and uh lib c plus already does this for clang i wouldn't be surprised if uh if libs did c plus plus the gnu implementation does it for gcc and msvcs stl does a similar thing for msbc but this doesn't necessarily propagate to third-party libraries and so we we still have a bit of a problem and it'd be nice if we could get some of the functionality of modules today so um one thing that we can do is if we're on clang we can actually already start to take advantage of this this idea of header units which starts to treat headers like they are modules today and the way in which we we do this is by enabling the the f modules flag and and that will give us module module like functionality for example this is a test case there's a test suite that checks the casts in uh in utility for forward move uh as const and a couple of the others now something that is uh that is not in in in utility is uh f puts that's in c stud i o so if i were to do uh stud puts and then say hello uh meeting c plus and then i were to run uh what is the name of this test it is just casts okay so if i were to run ninja casts and it builds however if i were to be using modules then it would have said no no you can't be oh right okay i understand what's going on because this one is a special header so i need to pick something else such as perhaps an iterator um why don't we uh why don't we pick something uh let's just double check what's in test and so we can see that there is a ceased io and so this is just a traditional header that will um that will be like a copy paste and so this is not necessarily going to be a uh a beneficial thing for us because we're still getting the preprocessor working when a header is treated as a textual unit but let's let's now pick something that isn't mentioned in this list of things from this list we can see that a bunch of them are c headers followed by type traits and concepts so as long as we don't pick up where pick one of those then we should be good so let's now go back down here and we will say auto i equals stirred input grader tag that is a good one and so if we look over here we see that we get the traditional error of uh no member named input iterator tag in namespace stud fix available and that fix would be to include iterator however that's the pre-process that's that's what's happening in without this without without the modules enabled because clang d doesn't uh work well with modules so i have turned off that feature however if we were to compile it now i need to ninja oh i haven't saved that's the problem uh if i now do this we will see that there is no there is no [Music] name this and we still are not getting what we want so what we can do is we can look at the at this file inside the standard library called a module map and the module map is basically a way of saying this this thing is is going to take this file and map it to a particular con to a particular module and this this is how we can say build up a set of header units so what we want to do is we want to make sure that uh that the the uh sorry pandemic you want to make sure that the uh that the uh the module has all the things that it uh that it needs in order to build this thing out and treat it as if it was as if it were a module and i do not see uh the thing in here that is necessary so we can change this again to incremental and then we'll say auto [Music] x equals zero two and [Music] uh we will also just do this and again we can see that there's no no incremental in namespace stood and you can pull this again and uh okay i've named it x which is the problem here y and we'll try that again and it gives us the same error um so i'm going to have to end this here but the uh the the main idea is that with uh with clang modules uh header modules we can we can compartmentalize things and uh thank you for your time thank you christopher