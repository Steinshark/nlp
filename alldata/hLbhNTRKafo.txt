hello and welcome to this session on still execution my name is Paul I'll get back to that the agenda for today we will have a little establishing of our environs then we will see what senders and receivers are we will have a little bit of insight about how to connect senders um we will get a program by writing an implementation and then we'll finish off and as special pop-ups will have uh short details into what an ISR is that is short for interrupt service routine and we will have uh I'll have a short word on what freestanding is because I can't be up here not talking about freestanding now can I so some of you might know me as I said my name is Paul I'm an electronic engineer by training always thought that the only way to write program for microcontrollers was in C and then I saw how electronic Engineers program in C so I've been a member of the iso C plus plus subgroup 14 for almost since it started I am a father of two the last incrementation um just as I Was preparing the stuff for this talk so please bear with me um I am in my daily life a firmware pilot at trifork uh where I do all sorts of embedity stuff but of course any Expressions expressed here are my own uh and you can call me you're him so what is this going to be this is going to be an exploratory talk on centers and receivers also known as p2300 and when I say exploratory when I first started this I knew nothing and now I have scratched the surface figured out enough that I feel confident trying to tell other people to do this but these are my findings this is not a this is how we rolled out 50 000 devices into the wild using senders and receivers this is this is new and interesting let's have a look so most of this is not production ready code you'll have to make up for yourself about the p3p23 00 code base um but the stuff I'm presenting certainly has flaws so what motivated me to do this is that I've been following in the embedded space all of the work done on async and watching Eric niebler's CPP contalk he at some point says we have a callback blah blah and we call that a receiver and I was like this is a callback system I know this and then I took a look and of course there was no way to get around exceptions until we had a Amendment removing exception pointer from a lot of the core points which means now we can actually do senders and receivers without having exceptions that is a big thing in the embedded space I know there are a lot of differing opinions but at least for my case the RAM for a for an emergency stack is not just not there so this is a big thing so how do your best figure out a new thing well you write a talk about it and this is what I've done so generally what is senders and receivers and why is it so brilliant so uh what we have here are three of the concepts that we'll be talking about a little later we have a scheduler also called an execution context or whatever gets us the place where we want to execute something uh this is not entirely true because it might be an ephemeral thing where the thread actually runs but for now let's just go with the schedulers where it runs actually runs this will give us a sender which will send you're ready to do something now and the Brilliance of this is that we can chain resenders a chain our senders and chain it up until we get to a receiver and at that point we will end the asynchronous operation which means we can now reason about our asynchronous code there are no branches off into the wild there is only it makes it even more slick when you use the bar operator here because Eric nible has been involved so of course there's going to be piping right um but the reasoning behind what's going on is totally contained within our system which also means that any buffers that we might have doesn't have to be shared by a shared pointer it doesn't have to be allocated on the Heap we can just put on the row above or a row we can put all our buffers on the stack and we can use it because we know that by the by the time this scope ends we will have been done with the buffers also if you want to know more about this um go search online for the excellent blog post go statements considered harmful very good introduction to this aspect of it so conceptually what are senders don't worry too much about the code this is just my attempt at patricio's beautiful graffiti but the concept of a sender is that it is lazy work so whatever work you want to do you put that in a sender and I get a very strong Scott Myers Vibe here because this is a lie but you're not ready for the truth yet um but senders is what we call our lazy work so we Define what the work is but we're not doing anything yet a receiver is as we just talked about just a call back it has a couple of um things a couple of functions that give me call on it and that is the uh the Callback routine um that you'd be familiar with from other asynchronous libraries but this is now contained within the framework so how do we chain these well you I I rearranged the um the sender receiver or the construction here a little bit because all of our algorithms which are senders that also have receivers in them um take another sender as an input so the input then becomes a part of the sender which then can be input to another sender that it now becomes a part of growing growing and this is how the senders and receivers will actually be the receivers inside the senders will actually be able to call the next sender outside of it the whole idea behind senders and receivers is that as users you'll never see anything except senders you will today but that's just because we're special so connecting a sender and receiver is gives us a operation state and the thing about an operation state is that that is what can be started so we had the centers being lazy work but as soon as we have an operation say we can actually call start on that and I um would like to stop right here a moment and um divert your attention to the second to last line that says tag invoke because if you're going to be writing your senders and receivers you're going to have to know about tag invoke tag invoke is a newish construct somebody some people are talking about putting it in as a language feature but for now it's a it's a library feature and it's a relatively simple Library feature doesn't really need anything very different difficult but you can see the first um first thing we pass to it is the connect type so we know that when we take when we call Tag invoke with the first argument being a connect type we know that this is a connect function and the magic of tag invoke is that the execution colon colon start is actually somewhere else defined as tag invoke start underscore t comma and operation state so this means that we can now Define our own vocabulary put it in namespaces and not pollute the entire standard namespace anymore when coming up with new ideas so yes the the syntax is a bit weird and the good sponsors that jet brains still have some work in front of them to actually get all this really working well it does work sometimes to their credit but you will have a problem of Discovery so anyway we connect a sender and a receiver and we get an operation State back and that operation State we can call start on we usually won't we will usually pass it to a sink that will do the calling so the last piece of the puzzle is the scheduler the scheduler just requires that you call schedule on it um again this will be a tiger milk function um and that's really all of the it must be quality comparable and copy constructible but that's really all it needs is just that one function that returns a sender and you can even do functions named otherwise that will return a sender but then that wouldn't contribute to the concept being fulfilled so just to get another view this is a slight modification of a slide that nibla did um we have a schedule scheduler on which we can call schedule this returns as a sender the sender we can call connect on with a receiver and that will generate us an operation state we then call start and some amount of time will pass and then one exactly one of the set functions will be called and the set functions will only be called when start has been called and only one of them will go through this is asynchronous so maybe two of them will be gold but only one will have any real say in the matter the the green box is what uh we would put in the uh the scheduler in our case um and receiver will come from the outside of course sorry the set is the three functions that the receiver can receive that is set value for setting the value Channel set error for setting the error Channel this was the thing that used to be have to be an exception pointer that can now be anything and the set done that as Hannah's nicely uh showed yesterday we want to have a cancellation Channel so short interrupt what are interrupts um I won't be diming too much into this but the motivation for this very interesting quote interrupts just like threads except when they're not stems from the good old and homes who in one talk said that we kind of do have threads that just called interrupts and in another talk said well we the interrupts are nothing like threads at all so the thing about interrupt is that it moves execution to a separate context this is not concurrent work this is just parallelism the interrupt can happen at any time even between clock Cycles because we have to do with the real world here and at that moment in time when the interrupt gets registered in the CPU we will jump to the ISR the interrupt service routine this might be in the middle of a read modify write function so we can't really use the normal threading Primitives and that has an effect on how we need to modify p2300 so when the ISR is done you go back and the main Pro the main thread will just go on its merry way nonetheless that things have changed and this in short means that if you're changing anything in an ISR make sure that you're not reading it in two registers in your CPU make sure that you know exactly what you're doing with the stuff that is going on the ISR because it is not sufficient to mark it volatile it is not sufficient to mark for once it's not sufficient to Market Atomic you need to Market volatile and you need to make sure you understand what your computer architecture is all about so we want to make an asynchronous pipeline I want to say at this point this is like the General thing these are the things that are needed in order to make an asynchronous pipeline does anyone here have a question is there any questions online yet great I'll just Mosey on then so as we saw we'll need a scheduler something to schedule on we need a sender possibly more um we need algorithms we're not going to cover those here because we're doing the very least of uh of things but those would be the things that massage the the data that we're given from the from the sender all pulling data out from there is data okay I will go grab data and then a receiver in order to get the data out that we were given and that were massaged so I'm going to build this off of the reference implementation by Bryce Eric and a lot about the people um the GitHub here says Nvidia it started out as Bryce's uh on private private thing and that's still where the proposal paper is at um I had to make some adjustments but the adjustments I had to do were largely the same as I did for the standard library in in freestanding in order to try and Implement P let's say 0 9 28. the freestanding proposal which allows us to have almost the entire standard Library except for the things that throws exception and allocates and we had I had to do the same for the Nvidia I don't want stuff that can allocate I don't want things that can throw which throws out a lot of the really nice features but luckily not all of them one more thing is that at the time I started this I made a conscious decision I'm not touching co-routines I tried looking at them they gave me a headache and the thing I could take from it was that it is almost impossible to at this point in time to get it to not allocate on the Heap so I went and said okay I'm not going to do that that being said this might send us and receivers might actually be the thing that makes it possible for the compiler to not go onto the Heap because as I said before when we get to the end everything will be released so that might actually be something for the compiler so let's build an ISR sender we just need to be able to return a sender using tag invoke this is not a whole lot of work we'll see how and what the uart sender looks like um in a bit but pay attention to the three dots the three dots are the entirety of the rest of the uart class this means that this is your nice setup Builder classes this is your utility classes utility functions for enabling and disabling functions you can put whatever else you want inside of this and it will still be a sender it will be your uart and your uart is what you want to have give you a sender so the three dots in this is actually very huge but those are not for this talk those are there are a lot of other great talks about that so the you aren't sending as I was saying the receivers can receive either a value an error or a done signal and any sender needs to expose which of these if any and not sending anything would be weird for a sender but it's technically allowed um that we are actually going to be sending out this also tells uh the receiver what value categories we are going to be sending out so for example this case will be sending out a Char because that's pretty much what's going on in the U up and um this is also where you would Define your error channels what those are and whether or not you are using a set done so a cancellation strategy this one let's just keep it simple it'll be more complex later I promise um and uh because we are making a scheduler we need to have a way to get the completion scheduler from a sender and that completion scheduler must be the same as the scheduler that delivered the um the sender so we have this going back and forth we've been seeing this a lot with the co-routines that you need to go all the way through and back and forth and this is the thing that makes a schedule a scheduler that you can schedule something and get yourself back so the operation state you are now ready to hear the ugly truth and that is that this is where we actually do the work because the operation state is the only thing that actually knows what where we're going to put stuff when we're when we have done our work so a lot of the times stuff will end up being in the uh in the operation state um this also implements the the start and this will just kick off the hole we are now ready to take something into a u-word path but there's a problem here right um the interrupt service routines are in sea land how am I going to be able to tell my interrupt service routine what uh sort of operation state it needs to call in order to finish or in order to get the things that it needs to finish when I don't know what operation state to do so um I really realized my mistake too late and I made my own function View and if any of you want to hit up funerson later you can ask him why that's a bad idea but I did and this is how we're going to be doing type Erasure so in the um the the function that we're going to be loading into this is going to be that as so oftentimes before the last line is the most interesting one this is going to say call set value with this receiver and this value so we will be able to just call the receiver Cola with the um void pointer that we've stored and the value that we have gotten in rather not dwell on this so now we can have a type erased operation State we can just set it up elsewhere and this also gives us the the another uh nice advantage and that is that we can now say no I'm sorry I can't I'm busy because if we already have a callback set remember this is an optional uh then we then we can just say set error the int is going to be busy and um this will allow us to and this is legal because this happens in start remember you can only call any of the set functions on the receiver once start has been called so now we're calling start it has been called we're telling you nope that was quick otherwise we're just going to throw it into the receiver callback and then we're going to enable the interrupt which will at some point just magically start call this function and we will then put in the the UDR is a global variable which is why some embedded programmers are not always too uh focused on actually having great segregation because we're forced to deal with global variables all the time and then disable the interrupt again and we need to disable the interrupt because if we get into this routine again then bad things might happen if we haven't set up the chain again now I promise you it will be more complex in order to actually wait for this [Music] output to happen um we can't use the async weight that is part of the standard because that is mandated to be to use the standard exception as a narrow path so uh and furthermore um and possibly more important we don't have thread yield we can't yield the thread um what we can do in embedded is that we can go to sleep we like sleeping so this uh sender will as long as there is no result it will go to sleep and the interesting thing with the AVR architecture is that whenever an interrupt happens the microcontroller will be woken up the main thread will be resumed and you will have to check if you got woken up for no reason or and can go back to sleep or you can you really have something to do so for example if you have a long chain you might want to accumulate some data you'll be woken up a lot of times before you're actually given any data um yes and as I said before we're uh this is not good I am going to try this so here I hope this shows up on the screen recording um we have the optional value and the volatile Bool and as I said before we want to be using a volatile in order to make sure that we are in the state we're looking for and um this can only be written to or read from do not read and write from it in the same operation because it might slice had a nice paper describing this recently in the sg-14 so we need the receiver and in this case well if we one of the things we need for a receiver is that it needs an environment the environment is a magical class a tuple that will carry uh interesting things like meta information like is this a debug thing it is also where we will keep the stop tokens for doing cancellation um and we of course have the set value which sets the value and sets the has result and we have the set error which sets the error and uh which just says the uh has result and any more error configuration could be done in this pod so now gets now we get to the you Society user facing side of the story we can create a uart as we would normally do in order to have a serial connection and then in an infinite for loop as is the way you do things in um and embedded because you almost never want to end your program in a bare metal setting you create a uh you create a sender by calling schedule on the serial and then you call async sleep and if we got a value then it's success and if it's not then we can handle that so this is really the beauty of uh of the centers and receivers is that when once we have done the ugly Parts behind the scenes which is enough to fit on a slide in a full smart font in latter we get to this and we know when we leave uh when when we have a result that all our asynchronous operations will be done they'll be terminated all and in all memory can be released and we're free to carry on not having to worry about multiple threads multiple executions on what happens if my interrupt suddenly fires so did I just do this the Feynman way you formulate the problem you think really hard and you write the solution no of course not um I did this using the concepts Concepts is a very very big part of the sender receiver Pro proposal as you saw and the way uh the my mode of operation was I would right struct and then I would think about 20 minutes about a really good name and then I'll close the struct and then I would write I want this to be a sender I want this to be a receiver I want this to be a receiver of blah there is Utilities in the standard execution library that I'm using the the reference implementation for debugging things it's a bit verbose but it's it's carried off way into the back because that's not for users to use that's for developers to use so just one note please when you do this make sure that you put your static assert outside your class after you've fully defined it it doesn't work on an incomplete class and you'll end up wasting a day so I said that we're going to need freestanding to do this and that is because the way freestanding is defined actually the way C plus is defined in a freestanding uh system today is horrible so a lot of the things that you would want to have in C plus like all of the nice new things that's a rotate no it's not not if you're running freestanding in freestanding you get to roll your own and the p0928 was the first attempt at improving this situation and it took the grab bag of all the things that this is what we can use we can use this without any penalty to us and it would be really great if we had this in the standard and the standard committees looked at it and said that's a mouthful please come back when you've split it up into smaller atomic parts that we can actually look at so in the sg-14 group there's a lot of work going on in or at least some work by Ben Craig to remedy this if you are in an embedded space and you want to cut your teeth on something in the in the standard maybe reach out to him I'm sure he'll be glad to have any and all help he can have we sure could use it because freestanding gives us optional triple and variant I'm not sure I pronounce any of those correctly sorry to all the native English speakers but we need those in order to implement this proposal which means we can have nice things if we can have nice things nice tautology there so what I want you to all go and try out when you take this and build on this the next interesting future work stuff is using the available algorithms in my case it was very few of them that I could actually use because threads are such an integral part of it um I want you to look at creating your own algorithms using the sender adapter and receiver adapter we saw some of the utility functions that were for debugging but these are for creating your senders and receivers and this is actually the shortcut to gluing other people's senders and your or rather your senders and your receivers together so that you can have a receiver inside your sender that gets a function gets a value massages it and sends it out in an easy way take a look at the environments not you know Save the Planet work well but the environment input to any sender and look at how to support cancellation because the stop token an interesting thing about the stop token in p2300 is that now we can actually do inline stop tokens which means that because we know that the stack will live forever we don't have to put anything off in a corner on the Heap we can now have a stop token that can be on the stack so that was a leaving a bit of a room for questions but I want to take uh leave you with three things the first of all is that stat execution is possible in a freestanding environment I took quite a look at the executor's proposal from azio and from p0443 and I just couldn't get it I couldn't see how that would work I took a look at the core routines and I had to give up I know that deed makul has I believe that was him has given talks on how to do this um and it it is really possible but this was something that you can figure out in under a year when you're having a kid riding asynchronous code really gets enjoyable when you're doing senders and receivers because now you can reason about it now it's not okay I have to remember that this goes there and I have to remember that I'm not slicing and it's just all there it's just in line it might split out but it will be apparent in your code when you do a split you can compose things you make asynchrony composable it really takes a lot of the bite out of figuring out how you want to structure things and finally I'm going to make a throwback to two days ago when a grumpy old man was up here talking about how we made all the wrong decisions in order not to make all the wrong decisions it is really really important that you deliver your expertise to figure out where the cracks are and this also goes out to the people who are saying but I'm just starting in C plus plus I've been writing python all my life what can I do you can do this you can try and see what you can do and then you can say take all of the WTF moments and if not put it in a paper because that's what standard [Music] standardization people always say yeah you just write a paper it's not that easy trust me but tell someone tell write a private message or an email to the implementers of the library I'm sure they'd be delighted to have your feedback on what were the stumbling blocks what was really really difficult to grok make sure that this is easy for the beginner and for the experts in the room because I believe there are a couple of you make sure you go through this now it's not going to go in before 26 so you have a couple of days make sure that all of the but if you do this then everything just falls apart and will have undefined behavior all over the place make sure that we get those things ironed out before we go to press because it's very hard to change the standard Library once it's in and with that I thank you [Applause] so um open mic has the internet woken up yet I don't want to touch that sort of thing I disliked Twitter before it was cool nothing wow I must be an excellent speaker well in that case if what nope in that case if you have anything please hit me up in the hallways I'm always interested in talking about this thank you very much [Applause]