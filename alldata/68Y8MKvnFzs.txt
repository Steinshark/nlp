okay I'm gonna start hello everyone my name's Guy Davidson I am going to talk to you today about abstraction the two superfair C plus plus one that's where you can find me on Twitter for a little while yet uh I'm just today of another Macedon I signed up to Macedon I have no idea what it is I'm sure it's going to be great fun um but that's where I will also be shortly should elon's folly come to fruition um so I'm the head of engineering practice at creative assembly we make total war alien isolation Halo Wars 2 all sorts of stuff we are England's in fact we're the United Kingdom's biggest and oldest game Studio to my knowledge um yeah one I'm the chair of BSI ist5 what that means is I'm the king of programming languages in the UK which is a really exciting way of describing quite a dull job I'm a member of BSI ist5-21 so anybody who's familiar with the process of standardization will know that BSI is the United Kingdom's standardization body and 5-21 is the C Plus panel and I'm a voting member of the C plus plus standard committee I'm a member of after in case you've heard of that that's quite fun I get free games all the time because we vote on games which it's worth the membership alone I'm on The Advisory Board of Iggy this is intelligent games and gaming intelligence a post-doctoral research program a doctoral research program about artificial intelligence in games I'm a stem Ambassador so in the UK we have this thing called the stair ambassadors where I go into schools and colleges and say hey engineering it's brilliant do that instead um I'm a co-founder of hash include I'm wearing the T-shirt you may have heard of hash include if you haven't go to the website join in make the community a nicer place to be uh I'm a code of conduct of Easter I'm actually a code of conduct lead here and on four other C plus plus conferences if anybody else feels like being a code of conduct lead please relieve me of this burden I just don't have time to go to all of these conferences I'm a husband father I'm a singer believe it or not I sing with the Brighton Festival chorus I sang the Kamina birana at the Royal Albert Hall earlier this year that was great uh musician actor director things I've done um chef Bobby beard wearer thank you for the beard representation here very very good um and the Carter plect who knows what cartaplect is no I made that word up but you'll find out what it means in the fullness of time I also wrote a book I'm the co-author of beautiful C plus oh you're nodding have you read it you've bought it you bought it I I applaud you honesty thank you um but do read it thank you thank you thank you I think um they're about to call guidelines which you've probably heard of if you haven't you should probably find out ideally by buying this book um I co-authored it with Kate Gregory um she and I are taking it in turns to say how much the other deers and how little they did Kate's saying oh guy I wrote the whole thing I just stood on the sidelines but actually Kate um she devised it and she reviewed it and she gave close editing commentary um and she cheered me on and she showed me that there is a lot more to writing a book than just writing the words writing a book is actually quite hard it's a very hard thing to do on your own having somebody cheering you on is very helpful right here's our agenda we're going to talk about the nature of abstraction C plus plus features that support abstraction the art of working at the correct level of abstraction this is a new talk style it's a new delivery system for me so I'm I welcome feedback um and please ask questions throughout now let's look at the nature of abstraction first um I'm going to start with a little etymology so I asked a bunch of folk what they understood by the word abstraction and got a big pile of rather varied answers um the Latin root of the word is trajere which means to drag or pull and it gives us words like tractor and I appreciate him talking to a German audience tractor is an English word it's a thing you know what a tractor is great okay um it also gives us the word subtract which literally means to pull under but more meaningfully it means to take from as well as retract which is to pull back like you retract a statement and we've got contract which is to drag or Draw together and extract which is to draw out so extract and retract may seem quite similar one of the confusions we have is the precise use of all these all of these prefixes and when we come to abstract which means to draw off from or to draw away from we might be grasping for a um a meaningful understanding of the word and we're still the word abstract is a noun and it's an adjective and it's a verb yay English looking at nouns and abstracts can be a summary of a lot of a longer publication you get an abstract to the front of a paper for example and it can be a theoretical way of looking at things something that exists only in an idealized form used as an adjective it can mean conceptual or ideal and it can also mean apparently difficult to understand uh uses a verb it means to summarize okay or to extract by means of distillation or to produce an abstraction and after writing this presentation I was left with the notion that to abstract means to form a conceptual summary so here's the word planetary this is the Latin word it means to fold or to twist or to braid um we have words like Simplex which is a single fold it's also a triangle uh-huh monoplex is actually a synonym for this as is uniplex so who'd like to Hazard a guess at what a cartiflect is uh it's a map folder I'm I'm very particular about folding Maps I don't know if you've ever handed a map to somebody and they've just done and given it back to you and you're so I'm so angry no no the folds look you've got the big fold in the middle it goes down there and then you fold it and well it matters to me anyway car to collect there's probably a similar word who folds clothes now some of you do fold clothes good all right excellent um I can't remember the Latin word oh vestaplect or something like that for somebody who folds clothes um now duplex so this is um twofold um it also means two floors in a building or two Suites in an apartment or two-way communication that's probably what we're most used to for that word and then we have complex which means many fold and Multiplex is multi-complex it means comprising several interleaved parts you know complexity describes the idea of being unable to see the wood for the trees okay um things are interleaved in ways which defy simple or Simplex apprehension and the result of all the folding and the complication is a new thing in itself and I hope you can see that there is a relationship between abstraction and complexity okay abstraction seeks to draw away the essence while complexity seeks to create new things by weaving together old things and we need to cover the closely related concepts of encapsulation and information hiding because these are often used interchangeably with the word abstraction um and usually this is at the cost of clarity so encapsulation is the process of enclosing one of all things into a single entity so confusingly that entity is called an encapsulation C plus plus offers a number of encapsulation mechanisms the class is the most obvious you take some data and some functions and you wrap them up in a pair of braces and then you put clasp at the front or struct and an identifier and of course there's also enumeration this takes a bunch of constants wraps them up in a pair of braces puts enum and an identifier at the front I hope you can see it past an emerging function definitions they're a form of encapsulation you take a bunch of instructions wrap them up in a pair of braces and you put an identifier and a pair of parentheses and optionally some parameters at the front okay namespace take a bunch of definitions declarations wrap them up in a pair of braces put namespace and an optional identifier on the outside source files they work in a similar way take a bunch of definitions and declarations put them in a file save it to your file system with a name now modules are the First new encapsulation mechanism in a long time and these work in a similar way to source files take a bunch of definitions and declarations put them in a file at the export keyword at the top and save it to your file system with the name Daniela will correct me if I've got any of this wrong I'm sure um encapsulation is only part of the story though as anyone with any experience of modules will tell you because all we've done in each of these examples is gathered things together and named them as a single entity and if we're smart we'll have gathered related things together now information hiding data hiding is a more subtle activity it requires you to make more careful decisions so in addition to Gathering you've got to decide which items you're going to reveal to the outside world okay and which you're going to hide and information hiding implies that some encapsulation is taking place but encapsulation does not imply that information hiding has taken place so they're two different things encapsulation and information hiding some of the encapsulation mechanisms of C plus plus support information hiding the class offers us access levels of members within the private implementation are hidden from clients of the struct or the class and this is how we relieve clients of the burden of enforcing class invariants because by hiding the implementation and preserving the clients from breaking these class invariants things are you know safety is maintained the enumeration offers no information hiding okay there's no way of exposing only a few members of an enumeration and so functions hide information perfectly okay by merely exposing an identifier and a return type while hiding away the implementation name spaces can expose declarations and hide definitions by Distributing over more than one file so header and source files do the same thing as well and then so do modules but abstraction is a tricky word and matters aren't helped by the fact that the result of an abstraction sorry the result of abstraction is an abstraction yay English again Justice's encapsulation is a result of encapsulation um so consider the process of abstraction because in the same way that we just considered the process of encapsulation and information hiding we can see what's going on here now in a programming context abstraction means identifying and isolating the important parts of a problem drawing them off and discarding the remainder so we separate them from the details of implementation we label abstractions with identifiers so again consider the nature of functions we bundle a set of instructions into a single entity and then we label it the function is an abstraction with a name which is Meaningful to the problem domain and similarly with classes the class is an abstraction with a name meaningful to the problem domain containing relevant functionality to Model Behavior that is implied by the name but the art of abstraction is deciding what should be within the scope of the abstraction and what should stay outside and this is where it differs from Mere encapsulation and also I use the word art advisedly because there's no mechanical method for deciding where to draw the line between what is relevant to the abstraction and what is not and that ability comes with practice and experience the more time you spend abstracting the better you become at it now I've used the phrase problem domain now before I came to this talk I assumed that there were there was no controversy about the difference between problem domain and solution domain but I was wrong I was very wrong and simply typing problem domain versus solution domain into Google was really quite enlightening I recommend you try that now this is for a Blog called Shah World which has been unfortunately inactive since July 2017 I think um and I quite like this definition okay problem today no problem space it's an engineering term referring to all information that defines the problem and constrains the solution the constraints being part of the problem solution domain defines the abstract environment where the solution is developed and he then goes on to say that the differences between those two domains are the calls for possible errors where the solution is planted into the problem domain and this is you know this is a significant point so consider the int keyword does it live in the problem domain or the solution domain now if you weren't on your guard for my asking trick questions you'd probably say it's in the solution domain because you write C plus plus programs which solve problems using the built-in types but what the problem is how do we represent data in Ram or in CPU registers okay and now inters part of the problem domain the solution domain is a pile of Assembly Language instructions so problem domains go on to become solution domains for other problems it just layers up so let's look at a CPU how do we actually get to int okay so the CPU is what compilers generate code for this is a diagram of a CPU which I found on the red hat website after a little Googling um I found lots and lots of diagrams of CPUs each with different contents and I had to find the one that was operating at the correct level of abstraction for this talk we'll come back to that phrase you can start anywhere you like really the operation of a CPU is a constant were of execution and state manipulation so we've got the A and B register can you all see this at the back okay good good great thank you you've got the amb registers over there um just above the arithmetic logic unit um there are places where data are stored then we have the instruction register which contains a single instruction and there's two on this diagram I'm not sure why um so what happens is you've got the ALU the ALU combines the registers and instructions to produce a result in the accumulator which is written back to the level one data cache okay it might be written to the instruction pointer because the instruction might be a jump in which case the registers might contain the current instruction pointer and the relative jump size the level one data Cache can get written back to the next level data caches and the instruction pointer then points to the next instruction to be executed in the registers are populated from the data cache round and round and round we go the cash might need to be refilled from somewhere else by the memory management unit so this diagram is actually an abstraction of the Silicon which makes up the CPU the billions billions of transistors um the substrate manipulation all of this really mind-bogglingly tricky stuff that processor manufacturers do inside their foundries can be represented by this diagram now the important features are State and execution okay state is inspected and manipulated via execution to yield new state I don't want to sound like I'm overstating this but the complexity of a CPU is tremendous absolutely tremendous increasingly so as the years go by one thing this diagram lacks is the notion of multiple cores we've just got one core operating here Branch prediction and instruction look ahead that's not represented on this diagram those Concepts would complicate the diagram still further and make the abstraction harder to grasp now when we look at the history of programming languages they all involve State and transformation of State the first language I Learned was atom basic or an acorn atom anyone use an acorn atom I'm not even remotely surprised that none of you have used an acorn atom um this was back in 1980 which is when I first started programming who here was not born in 1980 great that the record showed that was almost the entire room anyway I moved on to Sinclair basic on the city one and then to z80 Assembly Language anyone familiar with z80 oh no yeah old people okay great um and 68 000 to 70 language I moved on to that afterwards anyone donation yes yes I need to talk to you afterwards anyone else yeah yeah a few of you sorry it is almost modern it was revolutionary honestly I could go on for ages about the uh 68 000 processor but that's another talk I have which maybe I'll give you next year um but all of these involved State and execution at different conceptual distances from the CPU and when I first started learning C I was able to apprehend it as a macro Assembly Language I could directly map between assembly instructions and see instructions this is how C was written in the first place a for looped a for Loop looked like a conditional jump you know back to earlier in the code and a bit shift operation looked exactly like a bit shift operation in assembly um the distance of abstraction was very small I was you know it was they were they were almost almost identical except that c was portable across all these different processes it still is um C plus plus however offered a different kind of abstraction so we'll dial back a bit we'll start with easy stuff hint is the fundamental built-in type you may have heard of long or short but int is the machine word it can be modified with unsigned don't do that um I advise again no don't unless you're looking at the size of types you know if you're going to do any arithmetic at all I would avoid unsigned personally um but as I said earlier it's a representation of data inside the CPU um be a team registers or in the cache when I first started programming CPUs the registers were all integers they were all integer registers particularly on the ZX Spectrum if you wanted to do any non-integer arithmetic um you had to go to a built-in ROM which used the rst28 instruction to launch a fiercely coming post-fixed floating point calculator it was a full featured calculator in about I don't know a couple of K of Assembly Language is extraordinary um I spent the whole of the 80s actually working with industry maths um I worked in millimeters which were precise enough for my purposes and I first came across floating Point arithmetic in Silicon with the Advent of the Intel 80386 in one program one of those okay don't be shy all right okay good yeah yeah Arnie really you're too young surely um actually it wasn't the 386 it was a 387 which was a maths co-processor it was attached to 386 and these two devices would work in parallel and the cunning programmer would be able to work to much greater Precision than fixed Point arithmetic would allow um all right who's heard of the Intel i4x6dx oh more hands are going up as I'm going forward in time the i-4860x was an amazing processor it was the uh it was the first chip with an integrated Mass Co processor um so no longer were two parts needed it wasn't an optional thing if you're writing something targeting the 486 you knew that you had floating Point registers um it was you know it was back in the 90s PCS based on this process of where the gaming rigs that's when gaming really hit PCS in a big way um and all of this narrative I'm sharing here is contained in the type float okay with modern processors there's a separate set of floating Point registers and the process is considerably simple when you use the float type You're simply selecting one of these registers now things start to get a little weird with bull um this type is just storing Boolean values true or false we all know about Boolean values and it would not be unreasonable to assume that this type is represented by a single bit however that's not necessarily the case a quick glance that some output from compiler Explorer will reveal that it's an eight bits type for msvc and for GCC and for clang where zero means false and everything else means true and this might seem like quite a waste of bits um but the most efficient implementation requires those extra bits because we wanted to implement it as a single bit that would introduce more complexity to the generated code if you've looked at bit fields that just monstrous code everywhere um it would diminish performance um so there's a trade-off to be made between size and speed for this particular abstraction Char is a strange thing it's a data type with a special purpose for dealing with text so whereas int and float and for that matter unsigned into double and long double can be seen as analogs of registers or or cache data Charles got a little extra going on it's used for storing elements of string literals when you type a pair of quotation marks and you put some text between them that's the type being used um but there's a significant problem because Char is only eight bits wide in the general case and this width is not specified by C but the implementers all choose eight bits for the width of char now as of version 14 Unicode has over 144 000 entries and this means that Char is not up to the job of representing the whole gamut of written human expression um historically characters 32 to 127 correspond to those in the 7-bit ASCII table which forms the basic Latin Unicode characters from character range and straight away you should detect a problem because the use of the word Latin should alert you to the um the parochial nature of the choice of letters um but C doesn't care she doesn't care it was designed for use on Unix it was a US project the keyword Char is just a hint to the expected use of the type but as an abstraction for textual representation it's woefully lacking now the standard has added the type WR underscore t for wide characters which can be 32 or 16 bits wide depending on your platform again this is a loss for portability such string literals are prefixed with a capital l in the code L stands for wide I'd have chosen W but you know L uh operating system vendors have tried to come up with solutions to improve the representations of text Windows as API calls for choosing between ANSI and wide characters um you can switch between them by choosing a preprocessor definition before including windows.hm or Windows programmer that's that's all I know um the Unicode Consortium has cataloged a set of glyphs and provided a library for working with them and C plus plus has of course inherited the Char type and added Char 32 underscore T and Charles 16 and T underscore T and Char 8 underscore t for utf-32 utf-16 and utf-8 character representation it's not a great abstraction for text so there's one more fundamental type anyone for Aid thank you and I suppose stood null putter underscore T which is the type of the null pointer literal anyway so we have some abstractions for data on the processor what about abstractions for execution so this is the plain and simple function it's easy to tell what it does it has a meaningful name Square which conveys that the parameter is going to be multiplied by itself um the name is clearer than the code um at least marginally actually I mean you could say that square is potentially ambiguous as a name because um Square could mean multiply a number by itself or form a square of a particular side length or it could even be a test to see if a number is square um which returns us to the observation that naming is hard you remember what I was saying put it wrap it up in a brace stick a name at the front that's the hard bit sticking the name of the front um identifying your abstraction is the most important part of forming an abstraction but while C plus plus code is an ambiguous and immediately apprehensible the assembly code is not there we are now there was a time when C was a high level language and assembly was a low-level language and level here means level of abstraction so programming in c allows programming at a higher level of abstraction than programming in assembly programming in c plus plus allows programming at a still higher level of abstraction nowadays there are very few people write in x86 Assembly Language consumer chips you know the latest generation of Intel chips are so full of bells and whistles to improve performance um that it's a waste of time to go straight for assembly uh it's a better idea to let the compiler optimize your code for you compilers know what they're doing compiler writers know what they're doing who is it Jonathan Muller's talk yesterday it was a great talk you missed a great talk Jonathan Miller's talk was fabulous you should watch it on the video but at the end of the talk he said let the compiler work it out for you it was absolutely right compiler writers spent their entire lives working out how all this stuff works um forward Declaration of functions is another form of hiding complexity by simply stating that the function exists you're advertising everything the client needs to know the client doesn't need to know how it's implemented okay they do not need to see the implementation they only need to know that it exists and that it does what the name of the function seems to imply or what the accompanying documentation says it does if it exists and it's correct and it's been maintained but this is not the only form of abstraction available a new facility in C plus plus is function overloading so this allows you to reuse a function name okay it's a form of polymorphism the name is the important thing the implementation is unimportant and another way of viewing this is that the abstraction is independent of the type it doesn't matter whether you're trying to square an integer or a floating Point type Square means the same thing now here's the question what complexity does this hide I'm not going to ask this question time and time again through this presentation because that's what abstraction is doing it's hiding complexity so what complexity does overloading hide or simply the type of the object being operated on okay we are left with a pure name and we can go still further this is a generic function making it explicit that the algorithm is irrelevant to the type hiding yet more complexity the use of requires Clauses can further refine the Declaration to make clear what kinds of type can be passed in finally we've got Lambda Expressions which construct a closure an unnamed function object capable of capturing variables in scope these are functions that can be passed around to functions and this hides the complexity of mucking around with function pointers who is used to throwing function pointers around their code base some of you the rest of you are very fortunate really it's a nasty business now I said just now the programming in c plus plus allows programming at a still higher level of abstraction so consider what it means to program at a high level of abstraction the native assembly instructions are replaced with more understandable C instructions the complexity of Assembly Language is replaced with a relative Simplicity relative Simplicity of C instructions but what about C plus plus is it actually an even higher level language all right this is a house it's a strut it's like a record in a database table okay in C a typical interface might look like this imagine it's the 90s and this seems like a rather verbose way of modifying the members of the Strat given that you have a pointer to it in the first place um if you've read my book who has read my book come on oh it's like golly thank you let the record show almost everyone has read I'm not telling you um but in the book I talk about the I talk about guests and Setters I hate the things I really do um but this is precisely what you can see here um now you could always write a superior non-trivial interface like this but it's also easy to turn this into an untidy API you're still exposing the data to client interfaces to client interference now classes make things a lot easier especially with some of the additional features with C plus now in a breakthrough tradition I've put the private interface at the top so you can more easily observe what's going on now one thing that c functions allow you to do is to abstract problem domain activity into the solution domain but replacing Getters and Setters with nouns and verbs enables you to create more meaningful abstractions and this is one of the things that makes C plus plus a higher level language we can directly model abstractions from the problem domain so floor area that's a noun modify plot size that's a verb modify floor size that's a verb add a floor that's a verb but you can see how they might be implemented in terms of the private interface now class polymorphism is not new to C plus plus it was available in C believe it or not although you had to hand roll your own solution and it would look something like this you could write code by switching on the house type and calling the appropriate function like this chance to make this Target because no it's not easy to read this oh that's fantastically annoying isn't it uh yeah how do we lower the blinds Mr facilities people could you I'll just take a moment here um does anybody have a large blanket he's prepared to stand in the window Abyss it's like being in a star it's the future it's the future I feel like we'd have futuristic film of oh but we've still got holes of light all right it's good enough but you can see there you switch on h-type and then if it's a bungalow you return false if it's a villa you can add a floor to a villa you can't add a floor to a bungalow because it stops being a bungalow um but the thing is you've got to manually ensure that you cover all cases um you'd have to ensure that if a new enumeration was added um to house type all places where the enumeration was used would have to consider it you'd need to make sure that that took place and that's a terrifically hard problem it requires extremely disciplined Behavior who knows who's working with a set of entirely disciplined engineers oh oh get a job I'd love to work for you um ah but this sort of thing was widespread practice back in the early 90s switching behavior on a type field in a struct but now we have the virtual keyword now I've restored the public interface to the top of the class declaration the virtual keyword signals to the client that the function dispatch can be resolved at runtime and there are a mix of pure virtual functions and regular virtual functions in interface add a floor provides default behavior for when doing so isn't meaningful for example you're working on a bungalow what complexity does this hide well it hides the complexity of choosing Behavior based on Dynamic type by overriding virtual functions in a subclass the switch case statement is rendered completely unnecessary now this complexity is not necessarily part of the CPU it's part of the way that programmers write code I'm going to have to point out here of course that virtual functions do carry quite a penalty the code needs to inspect the virtual function table locate the function pointer and then call the function which means a data cache Miss and an instruction cache Miss and cash is a quite modern inventions in the grand scheme of things the virtual keyword enabling automatic Dynamic dispatch was introduced in the 1980s we didn't have caches on processes back then they were introduced sort of like mid-90s I think the first caches started turning up and this doesn't mean that you should stop using virtual functions but it does mean that you should weigh up the cost when you decide how to approach the problem if you go back to Rolling your own switch case-based solution you'll suffer the same penalties um the question you should be asking is how did you manage to lose the static type of your object really you know solve that problem and you won't need to resolve function dispatch dynamically for example when you create an object of unknown static type stories Creation in a collection with other objects of the same type losing sight of the static time for an object is a costly designed decision to make now static polymorphism is also available to classes just as it is with functions and this takes a little more consideration so recall that polymorphism eliminates implementation detail it retains the identifier without having to specify certain parts of the abstraction particularly the types Dynamic polymorphism hides all the type of information in a virtual function pointer table static polymorphism hides all the type information behind template parameters and this is most obvious with the standard Library containers what complexity is this abstraction hiding it's the complexity of implementing the data structure for a particular type a class is a set of functions and data with some invariants and if the data types don't matter they can become template parameters in fact remember the full definition of a vector the mechanism of defaulting is another abstraction mechanism what complexity is it hiding it's hiding the complexity of default Behavior you know this is not a trivial problem it's solved for you by default arguments um there are other abstraction facilities offered by the class instruct furniture but you get the idea okay the class is the primary piece of problem domain abstraction it enables you to model things from the problem domain in the solution domain a meaningful name and a credible API are the essence of your abstraction but to reiterate structs and classes abstract from the problem domain functions and built-in types abstract from the solution domain problem domains become solution domains and this last point is very important right here's an interesting question our namespaces an abstraction facility after all they take a bunch of declarations wrap them up in a pair of curly braces and give them a name the the effect of declaring something in the namespace means it goes from this to this now is this hiding any complexity I don't think it is namespaces provide a facility to disambiguate common names which does not remove complexity it just makes the code easier to read I am not in the future right it makes the code easier to read it increases the number of of useful names that you can give to declarations but it's not hiding any complexity if anything it's preventing complexity look at these two function names okay it's quite usual to name abstractions by domain and then by abstraction so that you know whereabouts things live and what they're for and this is fine while your code base is reasonably small but once you reach a million lines of code um that's not uncommon in gamedev um Total War has about 15 million lines of code but you're in danger of naming things like this they have ai entity traversal Loop AI ENT offensive Loop UI HUD animation Loop and it becomes pointless if you're writing code inside the AI entity code body why have you got names like AI entity traversal Loop when you know that you're within AI entity nothing is searched by making your names long I'm prefixing them with AI underscore entity the facility of namespaces allows you to offer domains of abstraction to the compiler and the simpler means of disambiguation but it does bring its own problems so this is a using directive the core guidelines suggest that you should avoid declaring a using directive in a header file there is an exception actually which is stud literals who's used the literal's namespace oh great excellent um you need this to use string literals and header files um but I don't think the core guideline goes far enough I think with the exception of the literal's names today she should never use a using directive or someone's nodding class yeah yeah it's not yeah okay people nodding have both of you read my book yeah yeah well though you see read the book be convinced by my wise words ah I devote actually a whole chapter of the book to why you shouldn't do this I'm going to go over it um a using directive doesn't just introduce new symbols into the current scope a using directive introduces new meanings into the scope which is the lowest common ancestor of the current scope and the target namespace's own scope and this could be really quite surprising it becomes more surprising as a code base grows and acquires more namespaces um and you can you can so easily be caught off guard I tell a story about our own version of clamp which went very very wrong when clap was introduced into the standard um I advise against using directives um and nor is it next facing that abstraction facility despite appearances libraries on the other hand are most definitely an abstraction facility okay in tandem with pedophiles they have the they're the bread and butter of code reuse really um ever since C was a twinkle in kernigan and Richie's eyes we've had headers and libraries it's a simple mechanism there we are actually include my stuff to teach a equals my stuff getting int what's going on here is that the compiler passes the decorations in my stuff.h and uses that to inform the remainder of the translation unit and this is great you've got a consistent way of making a set of declarations and reusing them in other translation units and you're able to adhere to the more to the one definition Rule and have that one definition be consistent that's brilliant the definitions of those declarations are either made in the header file with static linkage were included in a library file so there we are my stuff.lib abstracts all the implementation complexity behind a simple header file and we've been using this mechanism for a long time now but it's not without its costs modules the First new language level abstraction facility you know consider the inclusion model the problem it solves is ensuring identical redeclaration of types and functions by means of lexical substitution when you type hash include matrix.h for example the free processor will hunt around for that file open it add it to the stream of text for compilation and it comes with a few problems the mechanism used about the preprocessor to find the file is implementation defined what works on one toolset may not work on another the preprocessor is language agnostic so it knows nothing about whether or not the code is correct during inclusion potentially burning up valuable time before the compiler gets to it and tells you that it's malformed it relies on the Linker to provide the definitions for these declarations which again knows nothing about compilation the inclusion model attempts to solve the problem of code reuse without using the compiler at all this means that opportunities for optimization are lost and we can and must do better into modules the big deal with modules is they turn libraries and programs into reusable components our module is a set of source code files that are compiled independently of the translation units that import them they've got no effect on the compilation of the translation unit that Imports the module after a module is compiled once the results are stored in a binary file that describes all the exported types and functions and the function templates in a class template and the compiler can process the file much faster than a header file as danila showed us marvelously this morning and the compiler can reuse it every place where the module is imported in a project um composing modules came with a big pile of problems to solve though um you know what you do about preprocessor symbols what argument dependent lookup um it took a long time to answer these questions I won't go into the results but um here's what a module looks like um there we are first line informs us that we're declaring a module the Second Line Imports iostream it doesn't include it it Imports it and when the compiler Imports I stream it we see it's not a module since it doesn't contain an export keyword the third line actually defines something a function called hello that marks it for export into the module defined by this sorts file so and here's how we consume it we rather than include hello world we import it otherwise it looks quite familiar the source file main.cpp is importing a definition a void function called hello and calling it I'm not an implementer those folks are amazing I just write games but I'd like to think that my mental model of the inclusion process is not too far from the import process I imagine that when I hit build in my IDE the dependency scanner will look at the modules and build them first if necessary and then simply add them to the compilation stream as requested by the import declaration um more complexity is this hiding it's the obvious question um particularly though where we were using the preprocessor and the Linker to enable the ReUse of code with all the problems that that brings we're now doing it within the compiler itself with much finer grain control available so we've migrated from encapsulation to abstraction now you might think that this means the end of the link here at the very least librarian but there are some considerations because you know for example with Microsoft's compiler a module and the code that consumes it must be compiled with the same compiler options and also if you want to consume the C plus standard libraries modules you must compile your program like this standard stack and Whiting and the dll version of the standard library now stacker winding is an expensive feature to add to your program and not one that I'm inclined to use in game development okay now I imagine you're all aware of this picture this is the OSI model um the open systems interconnect model but these are levels of abstraction at the bottom you've got the physical layer which is you know the the hardware the the soldering iron stuff you know um and then you've got the data link layer basically each of these works on what's before the the lower the lower layer wrap stuff up and then hides a very minimal representation of it sorry it exposes a very minimal representation of it to the layer above you know if you're familiar with this you'll you'll understand how there is the network layer is really quite complicated indeed but we don't need to know about that if all we're doing is working at the transport layer I don't even work at the transport layer my coding starts at about it starts with the session layer so I don't need to know about any of this stuff below that it's a it's a master class in hiding complexity um more concretely a file come up let's look at a file parts of the command line options I'm running out of time here so I'm going to race through this so imagine that I want to read some options from an options file um they're declared as key value pairs um now when I started writing this there were only a dozen possible options but being a smart engineer I create a separate function for uh for parsing so I'm not going to call it parse options file I'm going to call it pass options file it'll take a file name and I'll pull out the command line and if none's declared I will not call the function so the function body is simple open the file read each option line by line update the stage appropriately until we reach the end of the file it's quite simple I hope you all think so too um and it's great because I can easily add new options in one place and withdrawal options without any hassle and if the file contains some valid options I can just notify the user in the final else declaration what happened to me when I actually started doing this and this was back in 2005 when we started the um third version of The Total War code base a new option is defined his value could be several words and that's fine I just read until the end of the line and so I created 500 character buffer and I'll make a string from it like that now I'm feeling pretty good about myself here I've come up with a simple flexible way of parsing options I can just add code for each option now a colleague tells me a few the following week that some of the tokens are only valid if the user is set the debug flag and that's also fine I can set the debug flag at the top of the function I can query it later in the function and be sure that I only apply tokens um when they're applicable but I'm keeping track of state now it's almost like a bit worried um and then incorrect preferences files start to cause a mess so that you know about three or four months later and so I'm asked to apply the preferences only if they're still valid and I sigh maybe nowadays I could use stood optional perhaps um but this function is so useful that over time everyone else has had a go they've started using the options file and there's now 115 preferences and when I went back to this I thought oh no I'm going to die everything's all everyone is using this file every error is going to be my problem because everyone's using this function um and they say God why doesn't this work I don't know you wrote the you know but that's how people work you know no that's your function it's your problem so you might decide declaring a single function for each option and this is a good idea because it at least highlights the responsibility for bad behavior lies with the person who wrote the individual options parsing function um you can't wriggle out of that um and so what we've done is we've encapsulated all the different options in their own functions it's nice we can easily add further functions for new options this pretty much sounds like what I just said about adding a different code um other users of the function they should get the hang of things though they'll see the pattern and they'll follow it because that's what you expect people to do but that's not again that's not how people work there are so many places where this could go wrong and it did but let's bring abstractions to the party we're trying to parse a file of key value Pairs and apply the results to the environment if they're valid okay the function is well named parse options file the problem we have is safely adding arbitrary key value pairs so is the identity of the full set of pairs actually relevant to pass options file it's not it doesn't matter we don't need to know the full set we just need to be able to pass them at the moment we're simply pulling keys from the file and checking each key in an Ever growing if else statement um since we can't switch case on strings well not yet anyway um so this sounds like an associative container and in fact a map of keys against function pointers sounds perfect here and suddenly our function has lost a huge amount of repetition and been replaced with a single interrogation of a map and a corresponding function call the important part of this function is that it parses an options file and does something with each key but along the way we've lost the capability of values to contain spaces but you know we can probably do something about you know just read a string rather than the key it's it's credible but it's certainly feeling better because all we need to do is initialize the map of keys and function pointers but we've just moved the problem around again okay the initializer is another point where users can trip up it's easy to forget to update the initializer but perhaps we can automate that rather than mapping Keys against function pointers we can map them against function objects with Constructors and create static objects rather than functions like this so we can insert the address of the object into the map and in fact we can derive all of our function objects from the command class so now we've got a base class we can add a validation function to the base class we can perform a validation pass we can follow we can have a commit pass um abstraction has carefully separated the options from the parsing function so pars options file is like the session layer and the presentation layer in the OSI model where the individual classes are like the application layer but if parse options file is like the session layer and the presentation layer does that imply that more abstraction is available it does why would I ask this question because although we're passing an options file we're actually only reading a series of characters they don't have to come from a file they could come from the command line itself so we should rename the function parse options and change this input parameter to an I stream so here we are taking a stream pulling out the key in value invoking the matching option and as a bonus if we don't find an option we can decide it's a file name and then if I open up that file and then recurse into the function again we get batch files for free in fact why are we even pulling out the value if we tell the commands to take a stream rather than the value then the command can worry about extracting multiple values um and better in fact now that we have separate function objects for each key we're not limited to initializing data we can treat each key as a command and suddenly we've got a basic scripting facility also judicious use of abstraction so at the start of this example the engineer had to extend a function in an unbounded fashion but now they need to do is to drive a new classroom command and override validate and commit so we've moved from a single potentially enormous parsing function to a small bounded function and the dictionary of parsing objects we've gained command line parsing at very little cost as an added extra and this is all achieved by considering what's relevant to which part of the problem what started Life as a messy construct has become a clean and easily maintainable scripting facility with bonus content we all win everyone wins so let's consider the things that we did here to make this code better the function was reduced in size so one sign of abstraction leakage is a massive function that tries to do everything finding abstractions is a great moment because it refines both your problem space and your solution space deciding that the parsing didn't care about the source of the data broke the back of the problem entirely it revealed lots of options that sprung out from suddenly gaining a greater understanding of the problem now towards the end of writing my book Kate and I had a conversation where we both realized that the C plus call guidelines can largely be rephrased as respects the level of abstraction um anyone read Jonathan bakara's blog he doesn't seem to be writing anymore okay he talks about abstraction a lot um this is not a new goal for programming but I think it is the most important respects the level of abstraction the purpose of language itself is abstraction um when you try to tell someone how you're feeling we use language to make sense of our emotional state to someone else we have a problem domain of how to communicate and the solution domain based around use your words now when we write code we're trying to migrate something from a problem domain to a solution domain and the reason abstraction is C plus plus is superpower is because it has such a rich and increasing set of abstraction facilities available to it so it can be used to migrate problems it's the solution domain of C plus plus that's why abstraction is the true supervirus C plus plus thank you right ask me two questions float we have five minutes that's not a question all right questions a couple I've stunned you all into silence don't be shy I can go back over more slowly if you like have you got time for that don't be shy a couple of questions we have done you all need to go and watch the video Don't You class thank you thank you it's not really a question it's not like a challenge all right so you said the most important thing is um use the right kind of the right level of abstraction yes now there's also separation of concerns which I personally feel is super important too Yep this is not number two or number zero so where we were I think the same thing it's the same thing I think it's the same thing concerns could be peers or concerns could depend on one another but they're they're separate things you know can concerns are different abstractions and abstraction it's when you see a bunch of stuff and you identify a single and you and you observe a single identifier for that bunch of stuff you think ah I can hide all of this you know you see like a bit of wood and it's got some green stuff on it and and it sways when it's a tree tree there you are tree describes all of that stuff that's that's you finding an abstraction with concerns you know separation of concerns You observe that when you've got a big function you've got lots of stuff going on you're thinking oh there's too much going on here and you think you know what's going on at the top here ah pausing part right put it out separate function okay and then you've got more concern and then as the function goes on you'll see more some people they say no no I'm I like my 200 line function great maybe it is a single concern you know one of the problems we have is that the reason why Kate and I thought it's all about abstractions is that there are so many ways of saying things where people could come up with exceptions you know I could say you could you could have a call Garden that says keep all your functions less than 200 lines long or less than or whatever somebody could come up with an exceptions that they might have a really meaningful reasonable way of of saying well actually no that's wrong because this needs to be 200 lines these core guidelines are rubbish I'm going over here now you know but actually as long as you're respecting the level of abstraction as long as that is all at the same abstraction that's fine and the way that you'll know is because you'll look at it all and you will not be confused you'll see that big function and it won't be confusing because it is a single concern but that's I know as far as you know that's really exceptional you know whenever I look at a Long Function I think right go away find your abstractions and then come back and I'll do a review I I actually do have a question so you were talking about name spacious namespaces not being an abstraction yes but to me the the grouping of code even within a library or without a library can still convey information and can therefore be an abstraction so okay I was interested in why you didn't consider it an abstraction because the simple Act of gripping stuff together and forming a namespace is it's it's making things clearer but abstractions aren't necessarily about making things clear it's about it's about a particular form of identification um namespace is in and of themselves will simply allow you to gather related Concepts together which is kind of it's part of the way towards abstraction because that's how you start you'll think oh actually you know these all live in here um maybe it is an abstraction I just it just doesn't feel like it's me because it is simply it's it's Gathering rather than identifying in that direction the main space tree put all the stuff together and you have a single name for it it wasn't said about the tree right so it's the namespace tree then I think he's finished I think I think you were next uh it's a bit of topic question but would you consider visual languages as the highest form of abstraction like blueprints for example no I wouldn't because I don't think there is such a thing as the highest form of abstraction I think that when you're making an abstractions like I said you're taking something from a problem domain you're putting it into a solution domain and that solution domain becomes a new problem it's all the way down abstractions all the way down blueprints are I've read about them they look pretty good um and I suppose as far as programming is concerned they are very high I mean I was using what were called 4gls back in the 90s fourth generation languages um I think they're a bit of a dead end actually because it constrained the way that you could express your abstractions um but yeah but yeah I think there are the abstraction never stops complexity will always emerge hello um my question is about your advice for avoiding using namespace directly yes and I wanted to clarify is that also for tightly tight Scopes like within a function or maybe even uh avoids using directives at non-local Scopes okay thank you because you know it when you're putting a using directive inside a local scope you know what you know what you're getting into yeah as long as your scope is narrow I mean again using directives at anything other than anything other than the narrative scopes of fraught with danger absolutely thank you okay I think we can stop thanks guys okay thank you very much thanks for coming