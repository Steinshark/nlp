well thanks for coming and I guess we can start now to rest your minds yes the T-shirt says move semantics but in Serbian it technically half Serbian mve is still is English and full translation would be semantic and not even C++ developers would get it they would assume it's like uh some dancing stuff funnily enough uh if this e had a hat or a half hat it would be the way it's spelled in check and would you know it I'm from Seria living in Prague right now but enough about my t-shirt about me now uh I like to emphasize this part where that to be a teaching assistant because uh I see this in a way as part of that meaning um I need you to interact with me like if if you are completely quiet I'm going to assume that either you didn't listen or you didn't understand the word I said and I go into panic and not good for anyone so like if anyone want can just like nod or give me like yeah yeah move it along but don't worry I do have at least three plants in the audience and like Victor already did the entire talk about how layout is important for the ABI compatibility so it's I say it's going to be good with that I guess we can start thank you so you have decided to create a class right you tried all the other ways and you just have to that there is nothing else and uh yeah well you need some member variables and you need some uh member functions some static some private public protected all the stuff right and the way uh it's usually done is you write truct or class you write a name you open and close the braces put a semicolon and it's like you open a bag and just throw stuff in there with Reckless abandon just like don't sorry it's just don't think about it and when you're done you're like yeah it's good and then sometime someone else comes along and it's like oh this is a nice bag I I have some more stuff to to put in there of course the first thing would be you should probably learn the solid principles or at least the S of the solid principles but that's not what this talk is about this how many would you agree that this is something like the code you would write no one nice nice is it because of the exception is that what's what's keeping you back okay so yeah there is this uh perfectly named my struct that has two integers one double triples and a string name because without it nothing makes sense with the name we at least know what it is good so first let's start with the standard and by standard I of course mean the cprf because yeah I'm not going to read the standard this is just to set like some terms and the basically the the rules of the game now first thing I want to emphasize because uh in previous versions of this talk I always forget is that I will not be talking about uh virtual inheritance uh because it complicates things and I only have an hour and also I try to avoid it if possible so everything I say like from this point forward just assume that there is no virtual inheritance uh at any point uh now non-static data members contribute to the size of the object the only thing that matters to us for this talk are the non-static member variables and yes there is also a name data members or member objects and I will try to stick only to member variables hopefully it's going to be bit less confusing that way other stuff like member functions and if you define a class within a class doesn't impact the layout or inum or static data none of that matters like only thing that matter are the non-static member variables and this is the simple part which is that you're gu guaranteed that the object is going to be in one continuous chunk of memory and the first member variable is going to be at the zero offset looking at the the object you are however not guaranteed which the member variable is going to be first but that's the fun part and you can imagine like the class that I showed previously looking something like this in memory except that uh these Bulls would be smaller but was too lazy to adjust the size of the table elements and last night we actually had this uh somewhat Lively discussion about languages uh spoken languages not programming languages and uh yeah there was this like a point uh with Czech and Slovak language where people from uh Czech Republic can understand Slovak but uh or is it the other way around I don't remember but the point is like there is this uh there is one way understanding they are kind of speaking the same language but not really and that's basically how I felt uh reading this part of the cppf and the standard like I know it's English because I understand every word individually but like the sentences not so much so before C++ 11 you were guaranteed that within an access block and an access block is all of the variables like when you write uh let's say public and then you write some variables until you write something like protected or private that's like one block and you were guaranteed that all of the member variables within that block are going to be laid out in memory in the order in which they were declared however uh you were not you not guaranteed the order of the blocks so they could be moved around then they changed it and also like if someone knows if I'm misunderstanding this please correct me like I don't want to guess light people here so uh inos F 11 when reworking pod uh they changed this uh and now we are not talking about uh blocks we are talking about me variables member variables individually so basically uh member now member variables with the same AIS are going to be relative to each other um in the order they were declared but they could be moved around and of course that there is kind of an obvious question which is uh why and there is the at least I don't know any good answer like in theory yes the compiler could do some optimization here and that's probably why they left it but also think about it uh they could change compiler could change its decision how to lay out data from version to version breaking apbi constantly and like we've learned that uh we don't guarantee Abbi but we also don't want to break it luckily uh C++ 23 came along and uh this is the the whole reason why I actually kept this slide there was this paper which does exactly what it said makes the order uh layout mandated the same as the Declaration order and uh if you read it or at least just the conclusion it basically comes down to this uh first of all no one did this like no one played around with layout unnecessarily so either compiler developers are good people or they're lazy and both are completely understandable um and the the second point was that uh it really wouldn't make sense to to like keep this Rule and no one understands like the rational why we had it so let's just remove it and no one is even going to notice so now everything is as you as you'd expect and there is this another uh paper and I have no idea what the status is uh which basically says uh let's add an attribute that is going to allow compiler to again mess with the the layout but this time we are actually going to tell the compiler uh in which way we want to uh we want it to mess with the layout like you can say smallest and then it's going to like solve the uh knapsack or no backpack problem and figure out the optimal way to order your data or I think the compilers are allowed to uh ignore your attributes so compiler implementers can still lazy again no idea what's the status of this it's expect accepted or is it even being discussed so next we have this thing that are subobjects member objects Base Class subobjects and array elements don't care about array elements member objects are actually member variables and Base Class sub objects are as you can imagine uh subobjects of Base classes the point of this is that uh for the purpos purposes of the layout uh Base Class sub sub objects and member variables are basically the same thing and there are going to be examples that are going to illustrate this better and just for the completeness of course if we have subobjects we have complete objects which is things that are not subobjects the next thing is uh that uh every object needs to have a size and the funny thing is it says uh also yeah I copied this like from cppf I was I did not care to to write it in my own words so uh it says that each object object needs to have size which is uh non zero uh we are going to for now ignore this uh overlapping non um potentially overlapping part and uh bit fields are going we are going to ignore completely the funny thing about this is it doesn't really says it's unsigned or anything like that so technically it can be a negative size I mean not really but if it were possible it mean it would mean that downloading Ram would be possible you would just need a bunch of objects with negative size adding memory to your computer so it was not a lie but in reality yeah it needs to be non zero meaning it needs to be at least one or greater also if you don't like the jokes or are they are confusing just let me know I will stop and the last thing is like there is a lot of text here so like don't don't bother reading it's more like notes for me uh if you have uh two objects of same type and same lifetime uh they need to have distinct addresses well if if they are different types also yes but that's like a more obvious part uh this is again going to be shown later but in essence each object object needs to have a size greater than one and needs to have a unique address uh well no sorry greater than zero and um unique address so yeah like if you have something at this address the size is at least one so the next object can be at the next address of course link to where you can read this more cool go on yeah the next thing is the alignment now every every type has this thing called the alignment requirement it's a size T and it's a power of two and the easiest way to think about the alignment is uh to think that uh the address of the the address at which the object of this type can be allocated needs to be divisible by this number which is is called um alignment you can use align of an operator or a function stood alignment off to get the alignment requirement of a type and you can also use align as to set the alignment requirement for a type uh the limitation of the uh align as is that uh it needs to be well basically needs to satisfy the requirement of the Align M which is it needss to be Power of Two And also it uh can only set higher alignment requirement so like if you have an INT which is 4 byte you can only set it its alignment requirement to eight or 16 or like more not less and we also have a bunch more of these functions I'm not going to go into them uh because not really important uh for the for the purposes of this to but I'm going to mention not to use the last one and like just don't and there is also well the the O the o or the processor itself kind of requires has some like expectations for the alignment alignment the point of this is that the processor never really loads one BTE even though you can address one bite is going to read one word which is four or eight bytes and uh yeah we are kind of taught that uh the objects should fit if possible in one word or or if it's possible like don't get it between two words because then you need two loads to to read the object and that's just terrible like performance is just down the toilet but but is it is so this is from the L's blog and uh I would just like to note this is from 2012 basically what he did he took integers of 4 bytes or 8 bytes and just misalign them to see what are the performance differences and you will notice that on a core i7 processor there is basically no difference and on core two there is like minor difference of 10% now 10% is of course not that little especially when talking to C++ developers but who is using core2 processor this day so don't worry other thing is of course like uh you actually need to go out of your way to to misalign data so just like don't do anything stupid and you're fine with that we can I hope move to examples yeah yeah I guess some thumbs up yeah also like feel free to ask any questions as soon as they pop up or if anyone is following the online chat like I would rather not get to the end and find out that there is something from the beginning that was misunderstood so we have inheritance we have these three base classes and uh two of them have an integer and then we have the class that inherits from all three of them of course all the examples are God on on God Bol I assume that uh presentation is going to be available if not it's definitely on git so you will be free to play with it size of the first is as we'd expect four because that's the size of the in the size of the second is one because even though the second basee doesn't have any data it still needs at least one by uh in memory and the third is of course four and now the size of the inheritance is is eight okay so like no Elementary School maths 4 + 1 + 4 is 8 beautiful and the reason for that is okay yeah yeah maybe some of from the back row not the first row okay so let's let's just uh quickly go through this base classes um the slide says usually and it says usually because I don't think it's mandated anywhere but in general if you have base classes uh the subobjects of the base classes are going to be before the sub object of the most derived class and uh uh the no sorry that's actually the next yeah sorry that's actually the the next slide and yeah as mentioned like uh empty stat stateless classes take one bite except uh that they don't really have to and the compiler can do empty Base Class optimization in essence what happens is that uh the class I think the stateless is a better name for for the classes that have no member variables like it doesn't hold any state which means it doesn't really need any space it needs an address and uh we have already addresses for other objects so why not share so yeah the compiler can do uh empty based class optimization meaning it can share uh the space from other parts of the class with the with this stateless class and this is where we get to the C++ part which is it's compiler dependent yes we have three major and I don't know how many minor compilers but I have only played with the three major of course because I mean I can't go through all of them so now we have a bit different example uh which is the second base is the b class of the first and third base and like I kept the names the same because copy paste is easier than you know renaming everything and again second base is size one second uh first and third base are size four and what is the size of inheritance so we got 8 9 and 12 well it depends and of course that's why I mentioned it's compiler dependent so if we ask GCC is going to say eight if we ask clang is going to say eight and if we ask msvc it is going to say 12 it's absolutely refusing nine like in any way but also like uh Victor have a bug so yeah I don't I don't care like just for context Victor Victor from prag and he works in in Microsoft he works for like V works on Visual Studio but as far as I'm conern he works on Microsoft so like if I buy an Xbox and my controller dies I'm like going to Big turn I have a proximate idea where he lives and I know where he works so yeah good but people were told that uh anything we can do well not anything we can do with the inheritance we can do with composition I but we should favor composition over inheritance so first second and third base are the same and now they are not based classes they are member variables and the size is we got 12 and 16 and the 12 is correct and it's correct because alignment yes so I haven't mentioned it like first time I went through alignment but um the alignment of this entire uh composition is going to be the same as the alignment of its largest member variable and like it goes down through the inheritance so in this case it is going to be four uh because both first and third are size four and have alignment requirement of four so yes we are going to have basically nine bytes of useful stuff and then we are going to have three bites of padding so they lied to us we cannot do empty Base Class optimization with inheritance or can we can we I don't know yeah that that's also a good answer I don't know it's why we're here isn't it so since simp Plus past 20 we have this um attribute no unique address and I like it because it actually perfectly uh illustrates what the what the purpose is like no unique address I have this second base but it doesn't really it's a it's a member variable but it doesn't really need any space so it doesn't need a unique address so yeah it can share with uh one of the others and yeah everything stays the same and composition is now eight we have effectively done the empty Base Class optimization uh a bit more about this no unique address yeah so you apply it to member variable when you declare it and um this is a this is like if you remember I mentioned that the size needs to be greater than zero unless it's potentially overlapping well this makes it uh potentially overlapping and now it basically shares the space or well shares address with some other member variable or like Base Class and yeah there is also this part that uh uh if the memory is not empty then the padding can be reused but I haven't played with it and I don't think anyone really has and also it's since C++ 20 and also uh Microsoft had because they had it from I don't know when uh they still use the msvc colon colon no unique address while the gcn CL just have no address so you can use a micro for this we love micro don't we and now we get to like more interesting examples now this doesn't really make sense uh why would I have four stateless like objects because they don't carry any state like one should be enough but let's just have fun right if you do it this way they are in the middle like all three compilers agree it's great if you put them in the beginning then again all of them agree also great if we put them in the end they disagree and Microsoft actually here uh does the better thing I I guess but what we what if we have five because four is just not enough now in this case uh again GCC and clang are in sync so they basically do the same thing and Microsoft just doesn't want to play along same thing happens if you put them in the beginning but if you put him in the end then my moft does the the right thing you know one day we hope all that the compiler implementers are going to agree on how they do this this stuff so we don't have to go to godbolt with three compilers and like see what happens but not today not today so like donate to God Bol please and uh with all this craziness of all these rules we have this thing that's called the standard layout type now the purpose of it is that if you follow the rules that this thing requires uh you are going to get the same layout from all the standard compliant uh compilers now the rules are no virtual functions and the no virtual inheritance if you have base classes they all need to be of the standard layout type and uh you cannot have the same base class twice because well as if we've seen uh empty Base Class optimization may not work and if you have member variables all of them need to have the same access and all of them need to be in the same base class or in the most derived class and uh there is this uh is standard layout uh type tra that you can use to check if your your type is a standard layout and there is example for like anyone who wants to go and play with it but if you want to take a closer look at like how it's actually laid out in memory first thing you can use is this offset off it's uh actually from C it's a macro so you put a type and you put the name of the member variable and then in then it expands and gives you the offset of the that memory variable within the type and example from the cppf we have distruct S it has a a Char a double a short and another Char and you call offset off and it gives you the offset so like the Char is at offset zero which which basically means it's at the beginning of the object then the double is at eight because of alignment requirements short is at 16 again alignment requirements and then um the next chart is at 18 pretty obvious I would say yes yes yes but that's not enough that's not fun enough because we have no information about the base classes and we want to know we have to know we lose sleep over this so all three of the compilers have this flags and uh like just a kind of a fair warning these are uh compiler developer debug Flags so not something you should use or can practically use in like build uh but they are going to Dum uh dump the layout of the classes uh in the well either in a file for the GCC example or in the terminal for the others uh yeah like uh one note for the Clank and just see for the Clank so it's uh dump record layouts but depending on the version you're either going to need to use this CC1 or X clang I don't know when they Chang it like when I originally did this presentation it was CC1 and then in the meantime it changed to it stopped working so I moved to this is clang xlang and for same thing for the uh GCC thing it's like either F dump L class or dump class hierarchy and also the GCC thing is going to damp to a file that's going to be named like the name of the file that being compiled. class so you can't use it in in compiler Explorer and msbc has stayed consistent with the with the name and this is here I've used the the examples from the Clank because I find their um output the prettiest and also like the the sorry gcc1 uh was pretty sparse with the with the information now uh I'm just going to use the or I'm not can we yeah okay sorry I guess not so yeah I mean I actually wanted I just wanted to use the cursor because of the online people but the the projector is not going to work and yes I do care about people that are here more than online people so uh on the left hand side we see the offsets and then in the bottom uh you see the size of the D size I forgot what that is but it doesn't really matter what what matters to us right now is the size of and the Align and the NV size is like non virtual size and NV align is non virtual align for us it's all the same simply because there is nothing uh virtual going on here and then you see the name of the struct and then you see its member variables and uh on the left hand side you see the zeros or 48 which are the offsets yeah so here are the first second and third base and then there is this composition with no unique address which is just like the first example of a composition where we did not use the virtual inheritance uh sorry noic address uh so we see that the first base is in the beginning and the int B B from the first base base is like at offset zero like right at the beginning and then at offset four we have the second base and it also like says it's uh empty but um then uh at eight it says uh it puts this uh third base and it's of course the C it's member variable and so like all in all we get the the size of 12 when we get aligned requirements of four if we use the noic address then we see that the second base or the member variable of type second base is at the same offset as the first base or the in b b from the first base so it is it it's exactly as it says no unique address like it's using the address of this thing because it doesn't hold any state does doesn't need any actual memory and after that the third base and then this is the inheritance and like as I've mentioned the base class subobjects and the member variable sub objects for the purposes of the layout are the same thing and it's I think best Illustrated in this um uh in this example with no unique address because you will notice that the only difference is in this case when we use inheritance it says base in the brackets and here it doesn't but other than that everything is exactly the same and this is the the class from the beginning the myru the infamous myru we see okay in Bull in Bull double bull great but this is I think the the most fun part part of this uh dumping the the records layout is that we now see the uh string how it looks and uh how it's basically implemented at least this part when it comes to the layout we see that uh the string has this aloc hder and data plus and that thing that aloc Hyder has this Base Class which is an empty Base Class Al Ator which is again uh which is uh uh which again has this empty base new allocator for the Char and it has a pointer MP and then there is string L of the science type and then yeah there is this we also see this like um small string optimization the union of the uh car buffer and the the size toop allocated capacity and also like the the entire size is uh 64 and Alignment requirement is eight and also like you will notice that this uh like okay the first two bulls are well okay bull is just true or false so it's Tech it technically needs one bit but we kind of need entire bite we we cannot makes we cannot have size of 0.1 we said it needs to be like a greater than zero but really needs to be a whole number but here because of the alignment uh it's four bytes so instead of waiting uh instead of wasting uh seven bits we are wasting 31 bit and the worst case is actually after this double because then uh this um third is value three set is at 24 and uh string starts at 32 meaning that we are wasting um seven bytes and seven bits really based form and now let's take a look at the the the examples that kind of confused the msvc uh The Inheritance which has size 12 yeah like I no idea what happened here so you see that the first base uh and second base it's fine it's at zero and uh then for some reason the the third base is at eight so don't know why it put like the padding there we see that the Clank did the same thing for the start but then put the Third Way where it should be so I don't know fix it Victor now that would be AI break don't do it or actually you can use this as a is a pin that's going to open the flood gaze and like oh we break this like let's break everything destroy the the ABI and this is the example where they kind of agreed on like uh the size well they at least agreed on the size of the the object but we see that uh Microsoft is at least consistent meaning that uh the S1 S2 and S3 are going to share the memory with the F like it's going to look before the the is going to look to the object that's declared before to share the memory with it while the clang for the S man shares with the first base but the rest share with the third base like seems pretty arbitrary but you know it's how they did it so yeah it kind of seemed like they agreed but no no we don't do that here and finally yeah sorry forgot about this slide but for now just don't assume assert like you don't know what the compiler is doing you know do something like uh check the offset off or check the size or is standard layout or whatever just you don't know what they're doing and any questions just needed an excuse to drink some water finally the performance the only thing we really care about right right now I have these two sorry I have these two very simple classes one is good data and the other is sinful data now the sinful data is sinful simply because it's wasting space in the good data we have uh integer and two bulls and because of the alignment requirements we're going to have two padding bytes but uh in the sinful data we have also one integer in two bulls but because there is one bull then one integer then another bull there is going to be bull padding integer bull padding meaning uh simple data is going to be 12 bytes and good data is going to be 8 byes 50% difference in size terrible now I've create now the the only things that I've implemented for this very simple structs are the Constructor and uh less than operator for the sole purpose of illustrating that uh they are functionally if that is the correct word the same meaning they encode the same amount of data and the constructors are the same they take the the same arguments in the same order simply because the code would be simpler I don't need to implement things twice and uh the less than operator is implemented because of course there is going to be a sort and uh I don't want to use the spaceship operator because I want the values to be um compared in the same order leading to the same evaluation so I don't want the the performance of sort to depend of on the number of uh swaps it should be like the same it should just depend on the fact that they are not um laid out in memory the same cool yeah so for the setup um ryzen uh 7,000 whatever yeah like uh I originally did this like a year ago when like this was a flex it was completely new processor now it's just sold not that fun there are new ones and manaro I I don't remember what the version was uh when I did the test when I did The Benchmark but it's just to show that I use Arch which is required it's like the most basic version like I it's like Ubuntu I just installed it like everything is default but it's Arch so I can say I us AR that's the important part I used like Google Benchmark because it's basically the the industry standard and for each data point there are 100 iterations and the data sizes go from 100 to 1 million with 100 increments generate data is going to create a vector and then it's going to run the reserve space and then it's going to random generate u values for the good and sinful dat data 4H is just going to iterate through all of them maybe there is some like basic operation happening sort is just stood sort and accumulate is just stood accumulate and it's on git so you can go and like um complain about my code style and tell me what's wrong I will ignore it but you know if it makes feel better do it now I do apologize for for the graphs they are not the most visible but like I just uh dumped all of the Benchmark info into a CSV file and there was this uh python script I found online that generated the the graphs and I couldn't be bothered to like fix the size of the fonts and stuff so yeah it's f i don't unless I have to I don't do it but in Essence uh what you need to know is that this x-axis is logarithmic so it goes from like 100 to, to 10,000 to 100,000 to a million and uh this is just CPU time this doesn't really show much this is the The Benchmark for the generate this is the relative speed and well the blue line is the good data which is supposed to be the Baseline which is supposed to be the better but see here that the the sinful data is for the most part actually better the time when it gets like uh close to the good data is basically when we get out of the cach and when we get out of the when I think it's when we get out of L2 cach and then when we get out of like cash entirely it's just chaos that's what you usually see at the end of the the graph but we see here that the sinful dat is actually better in this case so you know is like they always say measure uh before you optimize and now we have for each and in this case uh we notice these bumps and these bumps most probably coincide with the when we get out of L1 and L2 and then L3 cach and we notice that like consistently the sinful data is going to get out of the cash sooner than the good data uh then like by the time the good data gets out uh the performance pretty much um evens out until we get out of cash and Tha and then it's just chaos again and in this relative uh comparison it's yeah you see these bumps the bumps are basically the places where the sinful data has left the cach but the good data hasn't yet and then they catch up and then the end is just the end and we have sort sort um yeah this doesn't really show much but relatively speaking uh it's usually faster to sort the good data compared to the bad data but the difference is somewhere like 2 three% which I guess should not be surprising because we randomly access stuff so we don't benefit from uh cash locality or stuff like that except for this very specific case and I don't know which value is this uh but again it's 100 iteration it wasn't just one off it for 100 times it was 35% faster to sort the sinful data than the good data don't know what happened there and we get to the accumulate which is the only one that did what I wanted it to do to illustrate how how good it is to to have like uh good uh layout here it's like it's consistent right it's just consistently better to to have this good layout uh compared to the to the bad and in relative we see that it's not just p it's much better again I don't know if you can see the the numbers on the left side but it basically goes up to like four times faster with the no yeah four times faster with the the good data compared to the sful any comments surprises wishes nothing perfect I love the cough it was like perfectly T like and yeah uh usually I just like to leave uh references for the stuff of used if you want to go uh into more details uh the first talk is actually going to go into the layout uh when you have uh virtual inheritance if you're interested in that go check it out uh the rest of the stuff are the blogs I've used and uh of course cprf which you know may not be the best place for learning C++ but if you are interested in like concrete information it's good and yeah I'm not like going to go on Twitter or Facebook and argue with people so you will not find me there but if you want to shoot some zombies on Steam I am there and yeah with that I'm done with my part so I'm open to clous [Applause] hi uh thanks for the presentation it was very nice I just have a question though um when you present the good data and the seamful data if you pack the seamful data would you expect to get the same results or will it behave as the good data uh yeah so H I would say yes uh but uh let's just go back I didn't use P because like you shouldn't I've said it and I will repeat it uh yeah like my assumption here is that the size is the only factor that uh contributes to the performance so yeah like maybe there is something uh in sense that uh the int is before the two bulls um meaning like in the order in which they are accessed like for for the less than operat um we access the int and then we access the the one Bull and the second Bull so maybe because the bull is before in they are you know but I think like with the modern uh caches uh it should be big enough to to fit it's it's eight bytes it's like one word so I I think that like if they were packed it it would be the the same performance yeah okay thank you y hello hello good presentation um would you say in terms of of your results so could you say is inconclusive there's no there's no real conclusion we can draw from this I suppose yeah uh if you mean the performance yeah uh yeah yeah it's inconclusive because I did the same test on my other computer which is some older int Intel processor and some other operating system it's like Ubuntu something and the results were different very much different and also uh like in my original Talk on a local Meetup I did the I did The Benchmark live but instead of having so many iterations because it took like two days to to run all of them I just did like uh 100 1,000 and stuff like that and in that case it was very consistent in terms of like yeah the good data was always better in this case when you do um 100 200 like if you have more data points more more uh runs then it gets uh the story is a bit different so yeah it's it's it's not the perfect uh Benchmark by any means so like if anyone wants to like criticize G is there uh and yeah it's somewhat inconclusive but it's also it's also to illustrate the thing that has been said many times measure before you optimize like maybe you have sorry maybe you have exactly this number of elements uh where you have insanely better performance with sinful data and you just do that okay um have you done an analysis of data consistency so you mentioned that especially once you're leaving L3 cache that it's all over the place um did you see a big jump in in uh speed consistency or how's the overall consistency here U I honestly haven't done any like extensive uh analysis okay this was supposed to be like a very short uh fun uh benchmark I kind of assume that the compiler is no longer allowed to pack the bu values because it introduces a data race if you access the boot from different threats so you would have to synchronize because you only have we size access uh this is possible uh I don't really know what the the the comp okay so why aren't we making fun of it like vector of pool because it it prefers uh the dense layout our efficiency see yeah um I mean I I'm not going to comment on Vector of Bo so honestly don't know like also uh padding is not that bad because like this is the biggest crowd I've talked in front of but there are so many empty chairs that it's like it's half empty room so it's not a big deal so yeah um that um um can you go back to the slide where you show the comparison operation uh which one um for the sinful data and the other one uh you mean the code Yeah the code um did you use that same comparison for The sord Benchmark or is it on the is a different one on the slides yeah yeah it's this uh it's I think that might explain things because I don't think it's consistent because you can have one value that is smaller than um an other and if you do some comparison in the other order it's still two because um if value of the first one is smaller than the value of the other one then that will return true without checking the boo if if you compare it in the other order then that will return false but you um then compare the booleans which can still return true so you get an inconsistent result for smaller and that Violet the assumptions of sort uh okay if I'm not very mistaken and if I have explained it properly not entirely sure right so like the the whole reason I implemented the less than operator is uh because and also the reason why I implement the The Constructor is that I use Rand like the cand with the same seed every time so the idea is that the data is always going to be generated the same so basically the values of value B1 and B2 are going to be the same and then uh if uh um if I call the less than operator it should evaluate the same the basic idea is that like if I have the same data with the same way of comparing but with different layouts what is the the difference in uh the performance so I don't think there is any inconsistency here but uh uh if anyone disagrees speak now yeah maybe mistake maybe I misunderstood something sorry thanks okay need to get ready hi um I'm not sure I get it right so maybe you can kind of reiterate the point so that's um using a 64 sorry I said ask questions as they come up don't don't wa no no no no like I'm sorry this is precisely the reason I said just like ask as soon as you but I believe in you we can do this um so yeah does does that's using a 64 environment versus a 32 bit environment make it worse or better because I understand if a Boolean makes pushes a integer because they don't both fit in the same 4 byte alignment but if you have 8 by alignment does that mean you can put two integers uh densely uh so okay for the for the OS part like the four uh the four byte word is just like how much the processor is going to to load so okay I think I I get the the the point I'm not sure uh yeah I guess like if it's 8 byte then everything is going to fit into one word it's going to be better but uh it's like nowadays it's more about The Cash Line it's like more about The Cash Line and cash size than it is about the the world size okay thank you okay I'm going to to the end um well yeah I guess that's it thank you [Applause] yeah I don't get either