so hi everyone um let's see a short show of hands who is doing unit tests okay I guess almost everyone or everyone so who thinks they have like really useful good unit tests and uses them all the time who thinks they have problems with their unit test Suites okay a couple of people I would say that was more roughly half and half so let's see um before we start let me just introduce myself my name is Anna I work as a software engineer at tsuka engineering so we are a contractor company working on different projects my work in C plus plus is mostly on embedded projects so from very small scale embedded to like larger things like embedded Linux and besides that I also am a trainer for a c plus maintainable code clean code stuff and so on so so what are unit tests um if you look for a definition of unit tests and Google for it online then you don't find one definition you find like dozens maybe even hundreds so I took the first 25 I found and made about Cloud out of it so this is what's in unit test so I don't want to give you another definition of unit test but I want to have like a common base to to what I am talking about what we are talking about so you're seeing here like of course unit tests and then many things like module component function class part so unit test is about testing parts of the software usually written by Developers so it's usually using your own your programming language and using utilities of your language relatively often using a unit test framework is so he has been here with the last topic Anastasia there was like in the last survey that had said they had like 30 percent didn't use a unit test framework or did not use any testing at all um but still mostly you use unit test Frameworks and there are some things that are important in here so it's smallest so usually you want to do the small parts and isolate and individual so you want to you test them in isolation so what when I talk about unit test what I mean is something that is automated By Us by the programmers we test the logic of individual units of individual parts of our software and I come to the definition or not definition or what I would say talk about when I talk about units in a second and they cover the entire software so the coverage should be as big as possible and what's a unit well a small individual logically separated piece of code so this can be a function this can be a class sometimes it's a group of classes for example sometimes you can't really separate classes that doesn't mean that you shouldn't try to but in some points there are just small groups of classes that just Belong Together think of standard containers and their iterators does make no sense to test the container without using the iterators and it does not doesn't make any sense at all even you can't use the reiterators without also using containers so you test them together right so the container and the iterator those pair of classes make up one unit so what we have is like the classic test pyramid there are some different versions from this but the commonality is that at the very bottom of the pyramid the base is the unit tests it's broad is covering most of the software all of your cases are as good as possible and above that you have like the integration test where you like take different units and put them together and integrate them with each other to see that they don't only work in isolation but they all know all Tool Work correctly together because you can have like two different classes that each pass all their tests but if they assume that what they work with it works differently than it actually does and then the integration won't work right so integration tests are also important and typically integration tests are written also using unit test Frameworks so what I see relatively often is that these two get matched together and they don't really you don't really have a boundary and you do like well we take one unit or we just don't separate it correctly and we have like well we have this class and this other class and these couple of other classes and we put them together and we still call it like unit tests [Music] um in a project a couple of years back we had like something that had a label unit test and it was using cppu test but when you were test trying to test one class it was using like one or two Singletons and those Singleton would be tied to another Singleton tied to another Singleton tie to a big database and you would be basically having like eighty percent of your code base whenever you pick one class you couldn't separate it from the rest of the code base so this would be not what I would say as a unit test here and atop that we have like different terminologies your eye test System test acceptance as sub system tests um with smaller coverage usually larger granularity radio tests like most of your software in one piece or larger parts of your software but I will try to mostly talk about unit test because they in the day-to-day business they can be really useful and to to see what they can be useful for let's talk about which use cases we have so the first answer the first thing people say when you talked about what our unit tests used for is QA we make sure that what we have written the software we have is actually correct right so I'd say this is the most important um use case of testing in general and it's also a big part of unit testing and also if something is wrong then a unit test and or the unit test framework hopefully gives us some hint of what's wrong because having like a couple million lines of code and run the unit test and says Nope doesn't really help us right so it has to tell us what's wrong where something is wrong test driven development who does test driven development or test First Development okay who does it only as a hobby or so I do it mostly as a hobby because usually in projects um I try to do it but things are set up differently so it's it's hard to actually get there um so big part of Tesla November is that is that you do your implementation after writing the tests so um there's also test First Development some people distinguish it a bit some people don't uh I don't want to go into definitions so let's more generally say test First Development or development where the tests and the development of the actual functionality is relatively close together right and especially in test driven development you have this red green reflector cycle where so if you really do it by the book I'd say you write the tests first and the test is red because you only write tests to actually trigger your development for new features if the test is green it doesn't really do anything to to drive you to develop more stuff it's debatable or people say that the test Suites you write for test driven development while doing test driven development are not necessarily enough so there can be more test cases that you incidentally already covered and you write more test cases and they agree immediately but this development cycle you have like the test on their Red by default and then you make them green meaning you develop the code that is needed to actually make them pass and if you do really buy the book then you try to do the minimal amount of code to actually make the tests pass right which means that after a few of those five Cycles you end up with tests with code that is not ideally factored so there's this refactor part which is also important so you write the tests they are at you write the code it's green and then you massage the code to be better to be a better maintainable they have better names too move functions into the correct places and so on and for this reflector cycle tests are also important because you don't want to make sure you don't break anything right and these Cycles depending on what you which with authors you read typically say like something between 30 seconds and two minutes um in C plus plus land where you have to compile first and the compiler maybe takes a bit longer maybe a few more minutes but it should be like short Cycles next use case fixing box of course um like when we have a backend or a software ideally we write some tests that reproduces the buck so something someone says well if I do this and then that it doesn't work as expected so you write down the test case that says okay I do this and then that and this is my expectation and then you try to fix it to make the test green right to not only make sure that you fix the bug I mean you could test that manually but also to make sure that the bug remains fixed and not someone else goes well this code looks cut looks looks weird I just reverted to how it was before and the bug is there again so those test cases are you can also like to be important and while fixing the bug usually you don't want to run your whole test Suite so you want to be able to select those specific test cases refactoring already covered we want to refactor maybe even outside test driven development so we still we want to preserve our correctness and we want to have short feedback loops because um let's see who has has had the experience like okay here's something we have to improve we have something we have to refactor and they start a big refactoring adventure everything breaks so it doesn't even compile for a couple of days and after a couple of days they put everything together it compiles again and then we run the test suite and the test Suite is red and now like a couple of days of debugging style to actually make the test seat pass again right this is absolutely ineffective the better way to do is like small step refactoring I do a small change in the right direction I run my tests they're still green great next step in the right direction I run my tests in really small cycles and if something fails well I've done only 10 minutes of work or 20 minutes of work I know what I've done and usually the tests that fails are related to what I've done and oh I just inverted the if condition or something like that okay let me fix it that's easy if I have worked for two weeks and the tests fail I don't know which part of my work has actually paid the test right so during these small Cycles really helps and if I don't know what I've done to break it then either I can start a short debugging session or I can just roll back and start again I've just lost 20 minutes of work and not two weeks right and the part about testing that I see usually is the most overlooked documentation if I write a unit test and it's well a well-readable test then the unit Test shows me how the author of the test and probably of the class function unit intended the code to be used so if I see a new class and I have no idea how to use it because maybe the interface is not that obvious I look into the unit test what's done first What's Done second and what are the real results of this so by looking at the unit test I can use them as documentation if they are well written and readable and um the unit tests to to make that work the unit tests should be somewhere in the direction where I can Phantom right I have the class name or the CPP name that I want to know more about then I should easily find the tests so you have maybe seen all these small emojis here on the side so these are hints about what properties we would like to have for our tests but also for the code that we are testing to make this work to make this worth our while to actually have useful chest streets and get the most out of them uh very big disclaimer these are not rules please don't go and say well we have to restructure our code we have to do this because look at this conference talk this is a general don't do this right um be pragmatic see if these guidelines hints suggestions work for your project or don't work for your project and um like it's it's usually no I no good idea to just blindly follow some advice and then you get a different advice and go to the next next Direction it doesn't work so what follows is what I've seen in different projects what works in different projects or what makes unit tests and sometimes also integration tests the pain to use in in different projects and what reduces their worth so this is a bit of experience this is opinion and see for yourself if it works for you or if it's something that you should adopt or not major part correctness so unit tests should be correct to prevent bugs and to improve confidence that you can actually massage your code work with your code refactor it add new stuff to without breaking the functionality because if the unit tests don't really test correctness or are incorrect then you probably are uh shipping wrong Behavior right to get correctness in unit tests don't reproduce logic I've seen a time in the game that people said well I have my functionality here I have this algorithm here I just take this algorithm and reproduce it in the unit test and so I just take my numbers one two three one through ten and say okay one is odd two is even three is odd four is odd five is odd six is odd seven is even right I reproduce the same thing in the unit test and it has the up green even though it's completely garbage it's not really the the correct Behavior right so don't reproduce the logic in the unit tests don't use complex logic at all because well we just said we won't don't want to have to reproduce a logic but if you use a different logic if you say okay my function is odd is correct if my unit test is odd function Returns the same behavior you risk that you either have the same error of thinking in your unit tests or that your unit tests itself the logic has bugs because well we write logic and logic contains bugs and that's why we write tests and if we test logic with logic then either one could have bugs and then you have a red test and you have to debug right so instead try to reduce the complexity of the logic in your unit test and say okay I have one test case for odd numbers and I just put in a bunch of odd numbers one three five Seven Seventeen two hundred five fifty five one thousand three hundred seventy five and this should be odd and I have another test case where I have a bunch of of even numbers and there should be even and it also improves the maintainability because well the unit test framework will tell you well this value doesn't give the correct result instead of well this function call that is really complex logic and you know have to debug it doesn't give it doesn't give it true or false so like having the correct value you still probably have to debug your uh your production code but you don't have to debug the unit testing code in addition to find out which part is wrong with the production or unit testing code then there's something that in some point is called gray box testing so it's a mix of white box and black box usually you want to treat your units on a test as a black box so test the outer interface test the Behavior test what it returns if you don't if you say okay for example I make my units friend of the unit test and I just look inside and I look at all the member variables you make it really hard for yourself to refactor to add additional stuff because well your unit test will immediately fail if fail even to compile if you just change something of your member variables that doesn't even change the behavior outside right so you want to be able to refactor your your data management inside your classes and and the behavior and and and the non-visible behavior the private stuff without your unit test failing so this is test against the interface on the other hand you may have edge cases that you know are there because you know the implementation and that are not visible from the interface but you still want to test that when you get to those edges in the implementation that you still are okay for example think about short string optimization we have a string class and if the string has less than n characters you just store those n characters inside this ring if it gets to more than n characters then string act actually has to allocate memory and put the characters outside that string when you test that you of course want to test it works for zero characters if you want to test the daily works for 3000 characters but you also want to test that it works for n characters and N plus one characters because of by one errors really by does rarity 50 often so you want to see that actually inside the short string range we are okay and just outside the short string or entry arcade anyway so this is the part where the black box test gets gray because you know the implementation detail and you test for those boundaries code coverage we set the testing pyramid the unit tests want to cover as much of our code as possible um I've seen people who say well we need to have 100 code coverage there are things that are just very costly or even impossible to actually uh reproduce and test to actually tweak your your environment to actually you're going to react in a special way mostly this goes in the direction of of special error cases so um I mean for example let's say you have some case that says okay if there's a network failure in the mid of of of of the transportation of my data then I have to react in a special way and there's probably no good way to actually reproduce this right so go for good enough and not for 100 coverage on the other hand if you can easily get more coverage then do this so I've seen people who say well we have like some framework set up in our CI like sonar Cube or whatever and it says like 95 coverage is okay I'm at 95 but 0.01 percent I'm okay I don't have the right module the test even if I could easily like test this feature that feature as long as I'm above 95 that's okay right if you can test the stuff write the tests if you can't then maybe write a documentation in your code or in your test Suite I can't really test this thing because maybe the next person who reads the test Suite has an idea how to actually be um you are able to test it using strong typing so this is more to the implementation part using strong types and named domain objects or how it's called in in domain driven design value types can really help you a lot to reduce the scope of your tests if you say let's say we have a an address if you say my address has a string for a street name and an INT for the house number then your unit tests should be covering empty strings negative numbers because those are strings those are valid values for Strings and ends right if you say well my address has a street name class at the street name class itself already checks I can never have an empty string because an empty string isn't a valid street name and I have other restrictions then you can test those restrictions and that those classes fail to actually be created at one point and don't have to check all over your code base yeah but can this function actually work with a empty street name and can that function actually work with a negative house number you don't have to test this because house numbers can't be negative because you have your specific class and a strong type for this and so using stronger types instead of just just strings and ins everywhere right really helps you to boil down your unit tests or to focus your unit test you have the the logic that has to deal with those coroner cases in one place and you have the logic or the unit tests that have that check that these Corner cases are dealt with correctly in one unit test suite and you don't have the logic and the tests all over your code base so much for correctness let's talk about readability um you want to understand failures so the output of your test should be readable you want to have the documentation aspect so the code of your unit test should be readable and well for maintenance of the code of course and well readability of the production code completely you have to want to be made able to maintain those as well right so we want to use design principles like all this principles solid principles especially I would say single responsibility a single level of abstraction and all these and keep it simple and stupid and you ain't gonna need it all those principles don't only apply to your production code they only also apply to your test code so if you have like really long test code function test function test cases see if you can factor out some functions that if you have like long-ish setup stuff find the proper name and put it into its own function so the test case itself becomes more readable because if you especially if those blocks repeat in every test case like people reading your test case have to read like okay line one two three ten oh another interesting stuff happens next test case Okay line one two three ten if this is just one function set up for the with this number or something like that then people once read the function okay I know what's happening here I don't have to read it again and they can much easier read the other test cases use fixtures or whatever your test framework supplies for you to have this abstract since they have all these initializations everything out of the way to make your test cases themselves very crisp and short test one factor test case so um who has seen a talk by Kevin Henny about good unit tests okay everyone else you should watch that talk um if you have one thing you test per test case and you just write that one thing that you test in the test case name then when seeing your test cases fail you see okay this isn't true that isn't true that isn't true because the test case is red so you immediately say okay my model my program actually doesn't model this fact and that fact and that fact and it makes it much easier than having like test case 234 is failing and now I have like 200 assertions in my test case and I have to figure out what's actually going wrong here right so if you have like really single responsibility one test case test one thing then you really can see okay that's the problem here that does not mean that you have a single assert statement in there so there is something some in some point that says well users should have a single assertion that does not mean that depending on your test framework you should have a single search statement in there or assert that or whatever the single assertion is exactly this one fact to check for example if I build my custom container and I say well a default constructed container is empty that means it's empty this size is zero and the Bing again and the end iterator are the same those are three assert statements but it's a single assertion because it's all the same it's an empty container and also important focus on the unit on a test so if I construct a vector with four numbers I don't want to see an assert statement that the size of the vector is four because that's already guaranteed by the standard library right if I have like curly brace one two three four curly brace closed I don't have need to assert that the size of this thing is for because if the vector breaks then my whole program has broken I only want to test the class or function my unit test is about and all the other parts that I'm using in here have unit tests elsewhere and if they don't do work like I think they work then other unit test break and in the rare case that my actually my standard library or even my compiler is broken then I have a bigger problem and I have to debug it anyway um test cases are usability check in the beginning I said when I read a test case I want to see okay this is how I use my class and if I have to do like really convoluted setup to get my class or the unit under test to the point where I can actually test some assertions on them that means that anyone who uses this class probably has to jump to the same Hoops again to actually use it in their code base right so I test and I see in my unit test cases how usable my code actually is that I'm testing in here how about the test case order um test case order should not matter for the testing framework because we want to have like independent test cases but um when we open a test file for a class or for a function then we usually want to see like the basic cases first to get a primary to get an understanding about the basic cases and then the more complex cases later so for example for my container and testing the enter Constructor first then those construction Constructors for example first and then very simple things like inserting into the containers like push back then the element in the back is what I just pushed back right and then the more complex stuff um group them by features so people can just find their way around the the test Suite and when we use test driven development then this relatively often comes um more or less in this order sometimes we have like features okay now we have like started with an empty container and like pushback it was first and now we actually add the Constructor that we have to go back but um in the very first phases of test driven development you just naturally start in that order because you have to construct your object first and you have to test the Constructor works so this is the first thing you do in test driven development then like adding stuff removing stuff comes later next thing is about discoverability of your test cases as I said when I see a new class unit whatever I want to see the test case so I better be able to actually find the test case also when I work on my on a buck and I fix something in a class then I want to know which test case is actually affected by this so I want to see okay this is my test case that I should keep in mind so naming here is really important and the project structure as well so relatively often we want to have like test failure names that just reflect the file name of the unit on the test so we very often you have the one-to-one matching here sometimes the unit on the chest has spread over multiple files and then you have like a small subdirectory or something like that so you have to more or less figure it out but still you want to to to be able to have the unit name and the test file name and you just have the one to one and you know what to look for when you are in the unit and the other way around um test directories so in some projects you see okay I have my something.h something.p CPP something test.cpp just in One Directory this is one approach to it but it really fastly bloats your stuff especially if you have not only unit test spots also other tests inside there the other version is you just reproduce your source code structure in a test code structure and you have like the same direction directories and you just can navigate in parallel to actually find your test cases again speed I've talked about short feedback loops about these 10 minutes 20 minutes maybe so ideally even less so I would like to have like five minute feedback or something like that because if your tests run for 40 50 minutes you won't be executing them every 10 minutes right I mean you could do and you could drink a lot of coffee in that day and do other things but you wouldn't get very far during the day so having these very long running test streets means you won't execute them that often you won't get as much out of them especially regarding your correctness because in the end of the day you run the test suite and in the next day you look um okay has anything failed so in a project I'm in right now the unit test Suite takes like 40 minutes the whole test Suites for our pull requests take like three hours if the nightly built takes 15 hours so like have I broken anything if I put my pull request right now then someone can review it in three hours which is probably in the next morning and then I get a comment on it I have to redo the whole thing because it's regulated environment if I do a change it has to be reviewed again it has to be tested again and when it's merged after the merge if I merge it before like the afternoon early afternoon then I see in the next day that something has failed or not because only overnight in the nightly the whole test Suite was running and I've started a development of a small feature Monday afternoon I was finished Monday afternoon it's still not merge because of this so you want to have this faster feedback right and especially when refactoring run your test reflector run your test refactor it's much more cozy to be feel safe I haven't broken anything because you often see it well I don't want to touch it I don't know what I'm breaking so so run your test yeah but the test run runs around an hour so I've I'm in a blind blind mode until the end of the day or until noon maybe when I go for lunch and I run the test cases I come back from lunch and I can roll back everything I've done in the morning or start debugging right so this is really we want to have at least a good confidence so we don't want to have everything run inside a couple minutes so this isn't possible usually like full system tests take their time but if you have the unit tests that have a good coverage and we haven't broken any of the interfaces between those units than having a green test Suite in a couple of minutes gives us a very good confidence that we can continue that we haven't broken anything and then we can go home and say okay the nightly built will be green I'm pretty confident it will be instead of I just committed it I have no idea what I'm looking at tomorrow morning right so what does it mean we want to have fast tests rough estimate very back of the napkin okay so don't add me for a factor 10 or 100 but roughly if I have a very busy day maybe we have affected not written one thousand to ten thousand lines of code like a bit of code here a bit of code there so we have like touched a couple of classes lots of functionality of your very busy very productive then you can go in that direction roughly test code to production code in the order of one to one which means we have like one thousand to ten thousand lines of test code affected as well um short test cases meaning about 10 lines of code per test case everything else is factored out but amortized 10 it's 10 lines of code this means in total that to test what I have affected here I need to run 100 to 1000 test cases in a matter of minutes so I want to have the short feedback cycle I don't want to get a coffee every time I run my unit test so I want to have that feedback in a matter of seconds because my Loops want to be minutes so I want to spend as much time of those five minutes actually developing stuff and I want to have the feedback fast including compilation so maybe in a matter of 20-ish seconds that would be great 10 seconds compilation 10 seconds test run or something like that that would be great which means together with those 100 to 1000 test cases in a couple of seconds means milliseconds per test case not more what does that mean for us we want to decouple our units from slow code we don't want to write into files or over the network or stuff like that every time we run a single test case we need to have this infrastructure stuff somewhere right so file access or getting something over the network has to be somewhere and we want to have specific test cases for that but our units that do the logic that do the hard stuff should not directly include this stuff they should say okay give me an outstream I'll write to this outstream and in the integration of everything we say okay this is a file stream this is if I give it to the unit and the unit can just write into the file streaming by testing we can just use a string stream entity unit can just write it to the string string which is much much faster than writing into the file stream right so we want to have this decoupling which also means is basically single responsibility or separation of concerns so it's good practice to do anyway so we want to unit test primarily the domain logic we have integration tests to integrate the domain layer object with the infrastructure stuff and at some point we have infrastructure tests we can even think about having the infrastructure tests in a separate test Suite because usually infrastructure doesn't change that much as much as our logic so like test our logic over and over and over again and if you actually have to work on the infrastructure then we run the infrastructure tests which take maybe a bit longer but usually those are less fewer test cases because the infrastructure is not that complicated so they the individual test cases May a bit slower maybe a bit slower but they run as fast in total as the unit tests keep it simple you ain't going to need it means if I write less code if I don't write convoluted code if I don't write code that I don't need for my production stuff I write less code that I have to test and I have to write less test cases so I see it sometimes that people say well um I have this neat algorithm for the integers but there's my use case but the same algorithm also works for doubles for maybe rational numbers for everything I just make it a template well when you make it a template you should not only test it with integers right you have to test it with doubles with rational numbers with strings with vectors or strings with everything because it's a template you have at least to see that it fails with something if it's not meant for them that it produces a good failure so write the code for your project for your problem that you need to solve and not something very generic because if you write something generic you have to test it generically um in the word cloud we had like independence of test cases we want to test individual units without affecting other units or just or sometimes we have to build on smaller units that we have tested before right for example if we write a big calendar thing and we write our own date time stuff then probably the date time staff should have been tested separately but our calendar then has to rely on that daytime stuff so we have to use it but then we have unit tests for the date times and unit tests for the calendar that doesn't care about the date times because they have been tested elsewhere we want to be able to well select test cases because we just work in a specific part and just having like a filter on our test cases just to test that part makes our test Suites even faster we want to be able to repeat individual test cases so this one test case is failing I'm writing a bug fix for that I don't want to run 5000 tests again I want to run this single test case over and over again until it's fixed and then I at some point I I need to run them all again but I don't want to run them all every time so this means they should be independent of each other which is a problem when we are having Singletons or other static stuff and one test case changes the static state in the back and then the next case goes either red or it relies on the static of the change state in the back right same project that I'm right on on right now we have like test cases that fail in because um if you run them individually it's different than if you run them all in one Suite so we want to have be able to filter tests so proper naming of tests Suites and test cases is a good thing to have ideally the test Suites have the same name as a as a test file which is related to the name of the unit on a test right so you can say okay I'm working on my calendar class so what I want to be executing is anything that has been tagged or has a name calendar in it because those test cases are likely to be affected by work on the calendar class so it depends on the unit test three testing framework whether you go by name for example in g-test it's just gtest filter and you have like a regular expression about the names in there in uh I think in catch two it's um you have the ability to take your test cases and you can say just execute everything there's a check with this tag over the attack so it's good to be familiar with that and to actually use them to be able to shrink down your test Suite that you are using um if you want to have repeatable tests there should be deterministic timing is hard so checking timing something that has to be done at some point in some cases for example if you work on a small embedded device it has limited resources you can't just write code code code and expect that it runs in a in a small amount of time so at some points you say okay I have to do this inside of a couple hundred milliseconds and you have to write tests for those but those are not unit tests um also with deterministic determinism and timing threading concurrency is a really hard problem you do two things and you say okay my unit test now I expect this to come first and this to come second and then this character says well I just shift this a bit in the unit test fails and the next time it's shifted again and the unit test doesn't fail this is a hard problem to solve and Flaky unit tests don't serve any purpose because they just make you insecure about have I broken anything no I haven't broken anything or maybe I have broken anything something so it's just tests that fail and then in the next one don't fail and then don't fail and then fail again they are no use so maybe throw them away write them again find something to to to actually be able to give a good get a good gut feeling about or a good confidence that the tests are actually working and doing as a um are supposed to do um in those cases I've often seen like yeah okay I know how I can do and get to this first and this second I just add a sleep and another sleep and another sleep and suddenly my test case takes three seconds of what would normally take like five milliseconds and we are back to the fast feedback loops right so if I have many test cases that have like these sleeves in there and take multiple seconds then um I just reduce the worth of my test cases because I don't can't run them often so having multi-threading in your unit test is a hard thing and um so I try to go for single threaded unit cast as often as possible and multi-threading when I have to do it maybe it's System test maybe it's something into integration test something in between where I can say yeah I want to this and that and that to happen I don't care in which order so I just have some more convoluted test code which is okay for those harder for those higher level case test cases but in unit test I want to be crisp and concise and I want to have them small so mostly single thread avoid Global stage so I've talked about this Global state is likely to be affected from by test cases and the next test case that relies on the global state will fail if it's not in the expected order if you have very little Global State then you can have your test fixtures basically yeah in the beginning I set my Global State how it's expected and then I do my test cases and in the ending in the end I just reset my Global state to whatever it should be um but it's better to not have the global State at all because it's also like leads to tighter coupling in your code and device some of the coding best practices and and so be careful at least with global state this includes Global State and test cases of course if you want to have in if you want to be able to test individual units and not have like this unit it depends on that unit depends on that unit depends on that unit then the dependency inversion principle or in practice encoding dependency injection is a good way to solve this problem so we had the example um I want to write something in a in a class let's say we have a function that calculates some value and then [Music] um writes it into a file sorry not in a class doing dependency injection I just inject you my file writer or my output stuff then I can do the calculation and I can inject something that doesn't actually write to a file that just writes to memory and then I can inspect the output right and I can test this with all the different input values and I need just one or two test cases that if I put a value into the file writer it actually it ends up in the file that's one test case and that's not 100 test cases for the different inputs I can have for this complex function that gives me the values right so separation of concerns dependency injection really goes a long way to have small interest unit tests and with dependency injection so the typical way to work there is like using mocking Frameworks and then injecting mocks into your uh instead of the actual dependencies and you can also do things like when I don't actually know how these two units interact because maybe they're really old and I'm just starting writing unit tests after the fact then you can just put in something that you inject and that then delegates every function call to the actual thing but in the meantime logs this function call has happened with these values and this is the return value that I got so you can actually set up your mocs or stops or fakes accordingly to to what is needed for the specific tests so on this was a lot of different opinions um a lot of what I would say okay this is maybe not good for a unit test maybe we should get this out of unit tests as I said before those are not rules right so there's nobody who sells we have to do it this way but it's like food for thought so um if we have a few minutes left I would really like you to discuss what have you tried things like this did it work for you have you do you have questions do you have comments on this over here in the front thank you for the wonderful talk so um when I see yagni in a slide on unit test it often gives me a chill because this is what I hear from the team when they say should we write unit tests they say you ain't gonna need it so uh I mean that is the kind of attitude that I see in many projects but maybe it is in a way there there is a point behind that because sometimes it is not incentivized that much like uh and I I find it difficult to convince or tell back that you are going to need it you need it for this and sometimes it is also because of the project like it is difficult to convince them maybe the management or to make it visible to them that this adds value to this so what could be the kind of metrics that we can use to incentivize the developers to write unit tests for whatever they develop thank you um so the kind of metrics um for so the yak me I had on this slide I want to point out is particularly not for unit tests the acne is for the actual production code so what you don't need in production code please don't write it in production code because then it can't be wrong it can't fail and you don't have to write tests for it um when they say well um unit tests do we really need them there is some point when adding even more and more and more test cases maybe um have a A reduced return on investment because if your unit tests I would say a very large part of unit tests is getting confidence that your code works correctly and the code work won't break when you maintain it so this attitude I better don't touch it because I don't know what I'm breaking usually comes from a lack of unit tests or from unit test being unusual because they are just too slow or you don't know what they are actually testing and I don't know what my testing coverage is and stuff like that right so having enough unit tests to have a good coverage to say okay my features are coverage I can actually refactor stuff I without breaking my code this is one of the values of unit tests the other one uh I would say is the documentation to just being able to have someone okay okay you don't know what this class or this function does um here's a unit test um read them if we then have questions we can talk about it because it's just a Time Saver so the direct return on investment on unit tests is not money or time but sometimes it's time if you have like the the unit test as a documentation for example but it's also I can actually maintain my code base and I have loads code rods and I over time I don't get into this problem like I have a huge code base of Legacy code and I can't touch anything because I don't know how it works so I would say this is the main thing about tests but also like there are studies I think that maybe not about unit tests in in a special case but about testing in general say okay if you're testing if your test coverage is like slower than the amount of of bug reports you get is higher and I guess that's something that can convince management especially that are not um that don't experience the the other parts the other benefits of unit test which can convince them to actually we should do at least some testing to some extent to say it's good enough to test it good enough right you don't have 300 coverage you don't need it but it's tested good enough to actually be able to say okay we are confident that we can ship this without getting like a huge huge backlash because everything is broken and all our features don't work anymore does it answer the question okay there was a question over there right yeah you might have answered it already um so last time I thought about unit tests one of the things I came up with one of the most important things is that it makes it less scary to change your code or to judge your code I was missing it a bit on the slides you were saying it once actually in the last reply you were expanding on it I'm wondering um for me that's obvious that it's an advantage but I'm wondering is that too self-centered because I'm a developer and like do we have any metrics on it is there like do I aware of any studies or well any objective reason to say yeah that's worth it off the top of my head not so so I can't just say well there's that study that's been that study but um I think and I'm pretty sure there have been studies I would be very surprised if nobody had thought about doing those studies like doing a correlation to bug frequency between Buck 323 and test coverage or something like that right so these are numbers that you can do and where you can do Statistics over and where you can say okay if I have projects that have like lower test coverage or less tests and the bug frequency in those projects should be something that's doable yes I think it goes it's more than just well I I was thinking about really quality of code even though or maybe bug frequency is a metric for it but yeah yeah I was really I mean I work on a cold place which is 40 years old and you really want that people touch it yes to rewrite it and I'm I'm not sure if you can just measure that with the number of codes so maybe that's a bit harder to measure yeah so that's harder to measure so like like the impact of code quality I mean quality itself is not all is already not really measurable it's it's a gut feeling this is good quality there's less quality even though there was like this this cartoon of the the um only valid measurement of code quality is a wtfs per minute in the code review right so so yeah it's hard to measure code quality and it's even harder to measure the actual impact of code quality besides for example hard numbers like bug reports and and and and how long does it to develop a feature of a certain complexity like velocity is also an indicator of how good is my code base how confident are people in working in the code base are they slow because they don't have like this safety net of testing and do they really have to go like do everything manually but um the velocity is impacted by much more than only code quality so this is only one measurement that you can have hi this is more a comment more than a question so something that I found some very useful is to run the test in random order yes shuffle them and this is related with some of the points that you mentioned like the order of yes not having global estate and but actually I have now like a question I wonder why some of the unit test Frameworks does saying run the test by default you run an order because it will help to identify many things um you have some thoughts I don't know to be honest so so what my I what I think is if you start out with a code base that is for example 40 years old or even only 20 years old or really old that initially had no testing and you start adding uh thinking okay we should add unit tests and then you add the unit test and you are in all the Kinks and then you're happy that you once have a green test run and if the next test one is red again because you have all these interdependencies due to static code and stuff like that it's hard right so you say okay I had a dream test run and next data the test run is red again apparently the investment didn't pay off I just throw off the unit test framework because it doesn't give me anything so like the first step is to have unit tests as all and have them in a specific order executed and having green tests which already gives you some confidence The Next Step then is to have them in random order because you get out um when you do the random order stuff then you get of those those interdependencies so I think that's the reason why test Frameworks don't uh do them by a random order by default because it would just um be very frightening because you run them and you say oh they're right again but yes that's actually a good point I I thought about putting this in the slide because I got the same comment the last time I did the talk but I I I didn't put them in the slide or I had them only in the notes and didn't read those notes yeah um I think catch at least and g-test have random order execution and if the random order execution fails they actually have in the locks the seats so we can re-run it in the exact same order that failed to actually be able to debug it so this is a very good way to to actually find those interdependencies between tests so like one thing I tell developers when they're writing tests is to not be too dry um like actually repeat yourself quite often because if you optimize your your test code too much then it's like not readable and it's too magical yeah wondering what you think about that like should you be dry or not too dry or I kind of agree um on the other hand as I said test cases should be as little uh as few lines as possible to to make them actually readable um if it comes to the point that there is Magic involved like I have just I call a a generic init function and everything that's a setup in the in the back and I don't know what's actually happened and it's what happens behind the init function is actually needed to understand the test case then that's right right so um I've had like like um um in a in a training I'm doing I tell them well um write a a stack class and test the set class and you immediately see the that for many test cases you needed class that actually is like that has actually uh content and it's a very minimal class we just have the default Constructor that creates an empty stack and then you don't have every stack case where say like okay empty stack pushback four pushback four push back five pushback seven and this repeated in every class because it doesn't give any value right so you can say okay I have one test case but I say if I have an empty class empty stack and I push manually in this um Part push for values and the size is four and the last value push is the top and this is one test and then you say okay we have established this and now we can just write a function give me a filled stack that just does this and then the next test is can just say okay my stack is a field stack and I know what's happening here because I read it earlier in the earlier test case okay the time is over thank you thank you again thank you very much [Applause]