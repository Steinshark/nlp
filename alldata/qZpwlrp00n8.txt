in this video we're going to be talking about occurring in Python how that promotes reusability in our code how that helps us avoid repetition with our functions and also how it can help us avoid cluttering our program with unnecessary code now curing is a technique which allows us to add some setup to a function so that we can use that function later without having to call the same arguments over and over and over and I also want to mention that the name carrying does not come from that beautiful Indian Cuisine it's actually named after Haskell Curry from whom the Haskell programming language is also named but with all that being said let's get started with an example so here we're going to create a function and we're just going to call it Dev multiply setup and it's going to take an amount of type floats and inside here we're going to create a nested function so here we'll type in Def multiply and here we're going to add the number we want to multiply by so number of type float then we're going to return the amount times the number and at the bottom we need to return the multiply function without any parameters we're just returning the function itself now this is an example of carrying and let me show you how we can use this and then I'll explain exactly how this works so down here pretend we want to create a function that doubles the number and we want to also double many numbers now traditionally you would probably do something such as multiply I can't spell that multiply and you would say you want to multiply 2 by 10 and then you would do it again you'd say 2 by 20 and you would have to continuously call to each time you want to double a number and while that might not seem like much in a bigger program it might start to become annoying because eventually you might have to change this when what you could have done is create a function that just doubles it consistently each time without having to insert that to as an argument each time so what I'm trying to say is pretend you have a function called double here you'll type in multiply setup and you'll insert two so now every time we call Double for example if we go here and say double let's say 10. every time we call Double it's going to have the setup of 2 which means we don't have to add 2 each time we multiply that number we now have a given function that says double that takes 10 and it will multiply it by 2 each time we use it so if we run this we should get 20 back if we duplicate this a couple times we can also do 30 and 100 or 1000 and you'll see in the console it's going to double each one of those that given amount of times so we didn't have to insert that to three times we can now edit it with our simple setup function and that's a very basic example of carrying now the first time you look at something like this it might be really hard to read because you do need to follow it a bit but I do have some comments that might make it easier so the first thing that happens is we call the main function where the setup is used then after we call that it Returns the inner function so the outer function is returning the inner function which means we can still pass in the parameters once we get to this line and then the third thing that happens is that we're actually calling the function next the next time we use double so to explain this may be a bit easier we can type in Def func One and here we'll just type in a and then def Funk 2 and he will just type in B and here we're just going to return a and b as a tuple and on the outside we're going to return Funk 2. so what we're doing here is returning an inner function of course which means as soon as we call function 1 and insert some sort of value we can immediately use function 2 by adding another value here since function 1 is going to evaluate to function two we can then just use the parentheses immediately after because function 1 has now effectively become function 2 at the end of function one so I hope that made some sense in regards to how carrying function Works you've seen this a lot when you use decorators that's a very good example of currying and this also works with lambdas let me show you the exact equivalent to what we created here but with lambdas so if we take this part here I don't want to retype that def multiply setup here we can just return the Lambda number or whatever variable you want of amount times the number so this is the equivalent to what I created up here it does the exact same thing it allows you to set up a function and then it returns another function where you can actually add the parameter or the argument that you want to use in your function without having to repeat this setup so again the benefit of doing this is that now if we want to create another function that triples the number each time we can just say triple we use the multiply setup and now each time we want to use triple we just type in triple and we add some number and we can duplicate that and add Maybe 40. and each time we do that it's going to give us the output that we ask for without having to specify the number we want to multiply it by each and every time now maybe you don't really want it for multiplication again this is an oversimplified example there will be scenarios out there that you might find it a lot more convenient to carry a function because again if you have to insert the setup many many times each time you call a function it might start to get crowded in your code and it might just be much easier to create a single setup rather than having to do it each and every time in the functions that you are calling but anyways I hope you found this video interesting do let me know in the comment section down below if there's something else that's interesting about occurring that I missed in this video or if there's some sort of python feature or technique that you would like me to cover in a Future video just leave it in the comment section down below I'll do my best to get to it but otherwise with all that being said as always thanks for watching and I'll see you in the next video