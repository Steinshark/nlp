welcome to this uh third german trainers talk in uh today on meeting c plus plus um i work for kdub my name is mark moods i work for kdub we do cute opengl and c plus plus stuff and i'm one of the c plus trainers so let's go directly into the talk so in this talk i will first define what partially formed means and we'll give examples from c and c plus then we will talk about moved from objects especially the indirect in from joffrey's roma's paper and style remove if and that will lead us to the notion of safe and unsafe functions in the sean parent sense [Music] now we will have a look at composability and here we will in particular look at flatmap and the last chapter is about c plus 20 where we now have concepts and one of the concepts seems to change the way we need to write code and i will hopefully tell you why this is not so and if we then have time i have prepared some bonus slides a case study where we implement a pen with minimal overhead implicitly shared we'll have a look at weaker move semantics models and they exist and whether they can be used and if we have time about exception guarantees and the so-called weak exception guarantees it needed is not needed and in that particular case standard variant will be the poster chart disclaimer all of the following and all the talk is about value types that means if you're familiar with the terms regular and semi-regulated types this is not for rai or polymorphic types because we don't usually move them and if you if you move awry objects you definitely want that you have a specified moved from state meaning the right object is disengaged from its resource um so yeah um this is the program and we start with this book by alex stepanov and paul mcjones came out in 2009 and um i thought i would get rich on this because i have a copy of a first edition hardcopy back from when it was in edison wesley or pearson um and the prices on amazon were skyrocketing it was already more than 125 dollars for the book but then um the publisher gave back the rights to alex stefanov and paul mcjones because it did not want to print another edition and so now it comes out of semi-group press which is somewhere in mountain view i guess so probably google has its hand in it i don't know and you can even download the free pdf version from that website that is mentioned and in this book um this is a math book so um alex stepanov treats programming as a subset of mathematics and so this book is full with lemmas conjectures uh probably not propositions and proofs and um so he defines certain things axioms and so on and one of those definitions that stands out very early on in elements of programming is this where he says an object is in a partially formed state if it can be assigned to or destroyed for an object that is partially formed but not well-formed the effect of any procedure other than assignment only on the left side and destruction is not defined undefined undefined behavior a default constructor takes no arguments and leaves the object in a partially formed state and he shows here t a semicolon that is what we know in c plus plus as default construction not necessarily value construction but he does not make a difference between the two as you can see where he says an anonymous object of type p that is value constructed so what do we take away from this is the definition of partially formed state an object is in the partially formed state if it can be assigned to and destroyed so let's have a look at some examples here in semicolon i is partially formed because the only thing that we can do with it is we can assign something to it then we can use it or we cannot assign to it and then we must not use it except that it can run out of scope so we can destroy it so the only valid operations here are assignment of a new value and destruction everything else is undefined because it's uninitialized so this is definitely partially formed [Music] now let's take the same example but initialized i was a zero the question is is i still partially formed so the definition was an object is in the partially formed state if it can be assigned to and destroyed clearly this can be assigned to and destroyed so every object is partially formed as long as it's assignable and destructible if i have not deleted those operations this is the eop lemma 1.3 if the well-formed object is partially formed and this is also the reason why some people try to build up a straw man here and say that partially form does not tell you anything uh because every well-formed object is partially formed so if you say partially formed it can be anything it does not contain any any value any entropy uh as a concept um and so to uh to not fall into this trap in this talk i capitalize partially formed if i mean the following known to be partially formed but not known to be well formed right so this is different it's uh it catches the cases where the the object we know that it's partially formed so we know that we can assign to it and destroy it but we don't know whether we can do more and this is often the case so we don't know whether it's well formed so in i equals zero i is partially formed but not capital partially formed next example standard string we know standard string we know what the default constructed certain string is it's an empty string so we know that s is partially formed but not capital partially formed because we know that it's well-formed but this is only the case because we know standard string right and because center string is a container and we expect containers uh to have an not have a partially formed default controller yeah right that's why it crashed sorry about that so um we know that standard string default constructed is an empty string so we know that s is partially formed but not capital partially formed because a solid string is a container so but if i give you some default constructed rect and you have no idea what rect is then all you can assume here is that r is partially formed you know that you can assign to it and you know that you can destroy it let it go out of scope um but you don't know whether it's well formed if this is a qrect it's well formed because the correct initializes it's well its members to zero i believe and but if you just wrote the struct rect x a x y z with whatever then it's just partially formed so the guideline unless you know that the typing question provides more all you can assume is that a default constructed object is partially formed and partially formed is a program state not a bit pattern you have heard that this example with the auto pointer was a pointer so we allocate a new in to store it in the pointer next thing we do is we delete the in through the pointer and then the pointer but not the point e is partially formed because the standard says that the pointer is zapped as paul mckinney calls it in his paper that means that any access through the pointer but even the pointer value is forbidden it's implementation defined but in a portable code you don't even know whether p was not set to zero to null pointer by the delete call and if you had a copy of of the p before the queue would now be immediately zapped together with the delete p and this causes problems for concurrent implementations of certain algorithms and data structures cp 1726 for more another example that is also from c plus 98 is of input iterator if you advance an input iterator all older copies of the iterator become invalid you can only assign a new iterator to it or you can destroy them but you cannot dereference them you cannot advance them nothing um so here too jt can only be assigned to and destroyed so jt is a partially formed state and this follows from the standard type input iterator the input iterator requirements two interesting things here the first is if i write this code with assuming that i'm being handed an input iterator then i cannot assume more right even if i'm actually given a forward iterator or a random access iterator i need to assume that copies of iterators since advanced are partially formed because that's the only thing that the concept gives me also uh in c plus plus 20 we now have that the input iterator concept does not no longer refine copyable so input iterators need only be movable but the compiler does not check this because implementations of constrained templates are not checked to only use operations that are available from the concept and so if you wrote this um you would not get a compile error um at parse time of the of the template you would get one an instantiation time if you actually pass an input iterator that's only movable so this is a slide where we rejoin so here we use standard next which takes an iterator advances by one and returns the advanced iterator and this slide i said contains a bug because what we're dereferencing is not the advanced iterator which would be jt but the original one i t and so i t is partially formed so we are not allowed to dereference it and interestingly here we see the first example of safe and unsafe functions actually the newer function standard next here is an unsafe function because it leaves a partially formed object around so it takes its argument even by value but once it has finished its argument even though it was passed in by value has magically become partially formed so this is an unsafe function in the sense uh from shared offshine from parent and how to fix this is to use the old version standard advance because that one takes the iterator by reference so the partially formed any partially formed state if it exists is encapsulated inside the function and does not leave the function so this is a safe function and i find it amazing how alex stepanov got this one right in the original sto and in eop he didn't he writes a successor function there which is basically what we have next are we now called next but indoor general in the original x stl the standard advance function it's not next was not available was actually a save function i find this amazing so guideline if you feel uncomfortable around partially formed states avoid them so for the default constructed state you can use immediately invoked lambda expressions and for delete and for delete and new you can use standard unique pointer but don't use don't work around the partially formed state in the type design the default constructor need not establish a valid value because that would violate don't pay for what you don't use right and when in rome do as the romans do uh rather when in c plus plus two as the ins do and then it doesn't do this so your type also need not do this so let's have a look at the ele expression here we initialized in we switch over some condition and we turn various values and the compiler will naturally warn us if and if he finds a control path through the lambda that does not return a value right so we can be sure that um the eye is the eye is initialized and that the use of it is well formed is um well defined so if you instead of this we must always initialize everything um thought group then you might write this so you initialize the value then you switch over it and then you use it of course in line eight you are sure that the i is initialized because that's what you did in the very first line but you rob the compiler of ways to warn you if you forgot to assign a value somewhere in the middle right you probably know that if i would not initialize the in i there that most compilers figure out and worn if they find the code path through the switch where the i is not set um so this is if this could be extended to user defined types that would be great and i think herb sutter's w lifetime work is um is a work in that direction so we might get that actually for um the other example um we can just say say make unique uh we can even spell it correctly and we actually get an error if we try to copy this so we cannot copy um we can resume reset it and that will reliably set the p to null pointer so well formed so we have hidden the partially formed state of raw pointers in a class that we can use so summary be precise partially formed means it's destructible and designable but what we often mean by it is partially formed not known to be well-formed or partially formed known not to be well-formed and you need to distinguish these cases to have a meaningful conversation with other people partially formed objects exist in the language as early as kerning enriching c and c plus we have seen default initialized values we have seen invalid pointers and copies of an input iterator since advanced we have seen the following guidelines unless you know that the typing question provides more all you can assume is that a default constructed object is partially formed and partially formed is a program state it's not a bit pattern and if you feel uncomfortable around partially formed state avoided but not in type design only in your use of types here are some references for when you get the slides as pdf so let's talk about move semantics um consider the c plus 98 class yeah so we are we have written this class not thinking about moves move semantics we have written this in the ords when we only had copy um this is from joffrey rama's paper so because we did not have a shared pointer we use boost shared pointer and the class author in documents here in class invariant that mi is never null and indeed in c plus 98 that cannot be broken because the constructor always constructs a default a valid shared pointer either it manages or it fails then we get an exception thrown from makeshared and the indirect intest never has started its lifetime um the author used the rule of zero and in the equality operator as well as in the streaming operator he just dereferences the mi because there's a class invariant that says it's never null right so this was the introductory example in joffrey roma's paper there's a link later in the slides and herb sutter in february i believe wrote a blog post called move simply where he calls this class a buggy because as you compile this in c plus 11 with a move enables boost shared pointer you get move semantics for free added and those moved from objects that you then get have a null pointer shared pointer there and that invalid that violates the class invariant yeah i'm telling you this is not broken and um to underst to understand why i come to this conclusion we need to go back 18 years uh to um howard hinnon's paper n1377 which is the paper which introduced move semantics into the language and we now know move semantics as a language feature but there were tries apparently from the paper it's obvious that they were tries to make it as a library only implementation and when he reports about this there's this quote from this paper a pure library implementation of move semantics did not automatically move from r values which is a really nice feature of the current proposal because this allows completely safe move semantics to come into client code with absolutely no code changes for the client okay so the idea of move semantics as a language feature as opposed to a library feature is that a class like this is okay and that temporaries and um assignments and so on of temporaries enjoy move semantics automatically transparently and he says safely and this is clear in a way because how else can you make an r value if not by pro producing a temporary and binding that to something and the temporary goes away after the end of the full expression so it's not observable but here's the guideline treat moved from objects as partially formed because this is the only thing that we can follow um from this original intent the intent is to have transparent move semantics for types that are unchanged from c plus 98 and that is only possible if you treat moved from objects as partially formed or in the rephrased like guideline one unless you know that the type in question provides more all you can assume is that move from object is partially formed right so the remove [Music] function stl algorithm is a bit peculiar because um as an sdl algorithm it cannot actually remove something erase something from the container it can only reshuffle stuff and arrange for the elements that are to be kept in the front and um all the rest that can be destroyed in the end of the range that's what standard remove does and um this is c plus 98 code and the c plus plus 98 this was completely okay because there was no move and started remove was swapping elements around until it got the order that it wanted and so um swap of course just exchanges two elements um and so um after swapping both elements are still valid if they were valid before um but in simplest 98 as simple as 11 start remove now moves instead of swaps so the range between the result of standard remove and the end iterator of the container consists now of moved from objects they are partially formed if you follow my rationale and so this looping over it and streaming is no longer safe right because this was crash but this was simple this was possible in simplest 98 but it was already frowned upon um very old guideline from effective stl from 2001 treat objects in the range from that returned from standard remove to the end as partially formed use the erase remove idiom of course straight myers did not phrase the guideline like that he said hands off those are random values you cannot you cannot assume any order there um but now we know what he really meant is partially formed but partially formed the term was only coined in 2009 so he could not have used it so what's the race remove idiom that's here so we do not even touch um store the value of that remove returns we immediately pass it to the container erase so we do not get into the situation where we might want to um we might access elements from the range as returned from start remove to the end and this is okay in c 98 and 11. and this is idiomatic code this is what you should have written from the beginning in c plus plus 20 of course we now have standard arrays which just like standard advance is a safe function um because it completely encapsulates the um the partially formed state um it uses re erase remove internally um but because it's internal we don't get to see the move from elements anymore so this is a safe version of standard remove and i have a conjecture these remove like algorithms that is remove remove if and unique as sdl algorithms are the only cases where moved from objects appear in a c plus plus program without an explicit cost and casts can come up in various disguises you have of course the static cast to an r value reference um all you have these function uh function casts like start move and standard forward which as you remember they are not actually moving or forwarding they are just casting from l value to r value um um so these are casts actually and third move is an unsafe operation sean parent has has been known to say this and um i believe him and um the interesting thing here is that move is a cast we know that cars casts break the type system now they'll lie to the compiler to say i know better than you you know that this is an l value but i want you to treat this as an r value and i i take the consequences so if we reinterpret cars we are we know that there are only limited um procedures or operations that we can do on the return value of a reinterpret cast and um of course for a given type that might be more operations than for another type but um this is the same for standard move we are casting here so we should not be surprised that the result is not as usable as the input was there's hope though because also style move is an unsafe operation but there's a safe companion and you might not have looked at it but at this but um at this like this but um it's true standard exchange uh is a safe companion of style move because exchange also doesn't move out of the original value just like well move is just a cast but so that exchange actually moves so you know that the value is out of the original variable after standard exchange has returned and you get to choose the new value of the of the variable as the second argument of the standard exchange uh so set exchange is safe in the sense that it encapsulates the partially formed state they moved from there are no proof from objects um visible after the standard exchange has returned and i get to choose the new value of the moved from object right um here in this case we have chosen it to be default constructed and often this is roughly the same performance because the compiler can see through all these things and optimize everything next guideline if you can't tolerate the thought of partially formed objects prefer c plus 20 erase if over standard remove if and standard c plus plus 14 standard exchange x hour with d4 constructed over standard move of x or now we can say if you can't tolerate the thoughts of partially formed objects prefer save over unsafe functions move semantics summary valid c plus 98 programs become invalid c plus plus 11 once unless you treat moved from objects as partially formed only then you can gain this free lunge that howard hinnon mentioned in 1377 where the language feature gives us moves transparent moves without changes to the client code guidelines that we have seen treat moved from objects as partially formed treat objects in the range from written as returned from start to erase bachelorette remove to end as partially formed used to remove erase remove idiom or if you can use standard erase start remove a standard move is an unsafe operation and so our standard removes so i'll remove if and it's not unique and if you have paid attention you might have seen that we have now found a safe variant of for every unsafe function except not unique so anyone who wants to propose standard erase unique it's still missing if you can't tolerate the thought of partially formed objects prefer save over unsafe functions and some references so composability um composability is important in c plus plus in software development in general because this is how we write programs we take small programs and compose them into larger programs and one of the problems with locks for example is that they don't compose so that's why lock based programming is hard because two components independently written independently verified to be working combined may not work a different order of log of taking logs one takes the logs in ascending address order and the other one in descending address order and you can get that look so composability is important and if we have if we have a mental model which works with composability we have a much nicer day as programmers so let's have a look at composition the first thing i want to mention is that partially formed states are closed under composition that means if you have a struct or a pair or a tuple and one of the elements is partially formed then so is the struct yeah so here we have this vector and index it contains a vector and it contains an index that is said to be in a command to be an index into the vector so one thing is clear if i just default construct such a struct then it's partially formed not well formed because that an empty vector does not have an index a valid index into into the struct and to the vector so um first of all the in index is partially formed in itself because it's uninitialized but even if we value initialize the struct and say therefore set the index to zero zero is still not a valid index into the container because the container is empty so it's still partially formed not well formed and you can see we're using the defaults we're using the language defaults we're not doing something weird here um this is just the natural state of an int it's the natural state of destruct that's just how it is if we create a well-formed object here in line it's eight work to highlight okay um and then we move away from it then again vi3 is then partially formed not well formed because the vector is empty the index is what it was before in this case zero because for ins moves are copies and so we are in the same situation that we were in the default constructed state and this is also something with a partially found state um because the move from state is the same as the default constructed state that's something that you can that should always strive for but in this consequence you can only reach it when both are partially formed so here's the lemma i'll skip over this because we're shorted time if you look in the standard and somewhere else you will find that you get this valid but unspecified so the standard says unless otherwise specified moved from objects are placed in a valid but unspecified state and up to c 17 this only held for standard types but many people believe that this should hold for all user types too even if it requires extra work to achieve this yeah so first we need to understand what valid but unspecified actually means and valid but unspecified means that you can apply all wide contract operations on the type so wide contract operations are those which do not have a precondition like for example vector.size doesn't have a precondition so we can call it on a move from object right so lama2 valid but unspecified is not closed under composition now so partially formed is closed under composition valid but unspecified is not closed on the composition proof by contradiction assume that the lambda is false so that it is closed on the composition then flat map would not need a custom moves constructor so what is flatmap here is basically a skeleton implementation of flatmap from po so a flat map is is like a standard map but instead of allocating each node and storing key and value there it has two independent containers which by default are vectors and so it stores keys and values contiguously in memory and therefore we expect that lookup will be faster than if the nodes are strewn all over the memory so uh we said that size would be one of the elements the function that we can call so we have two containers here keys and values so which one to choose uh po29 po 429 says to use the keys but these containers that we pass in there if they only guarantee valid but unspecified the unspecified is the problem um they don't guarantee empty we might like that but they don't um so um there are actually certain combinations of vector with allocators which for which this does not hold so if we pass as kc a container which when moved from this is not empty and as vc a container which when moved from is empty then we come into the situation that size can no longer return a valid value if it returns key size it's too large if it returns value size it's correct but then we can have the same argument when we where we swap the containers around and then m values will be too large it could use the minimum of the two but nobody does that so um with the default moved move constructor this breaks this can no longer have a valid but unspecified state when moved from you need to do actual extra work can you still hear me uh in this case you need to um uh you need to move the containers um this is what the what the default move constructor would also do and then you need to do the extra work which is clearing and this is extra work and probably measurable but now you can assume that the key size will actually be okay to return so you need to do extra work here composability summary using the language defaults partially found objects composed are partially formed but valid but unspecified objects composed are not valid but unspecified and the reference to the flat map example let's have a look at how and whether c plus 20 changes anything here so we know that for standard moved from objects um they are placed in a valid but unspecified state and this held in c plus 17 only for standard types in c plus 20 we seem to require this also for user types because style movable the concept that tells us that we can move an object requires standard move constructable which in turn requires in prose that rv state resulting state that's the moved from object is valid but unspecified this clause has many more problems for example it talks about equality when comparable isn't even required and it will be fixed so for now concept moves constructable slash 1.3 can be ignored it will be fixed and no implementation can depend on this don't be scared about this this does not mean that you can no longer write the vector and index struct that's nonsense but if we analyze this a bit deeper and look at what style movable also um requires then we find that we need to adjust a bit our understanding of partially formed state and i call this this the howard hint extension even though he probably doesn't like it but he came up with this uh um as far as i can tell as the first uh um person in in the style committee so um attribute stem element of programming swap works in terms of copies like the c plus plus 98 version did so movable requires standard swappable but in c plus plus 7 11 plus standard move a swap uses moves instead of copies so now consider sweat self swap where i swap a value with itself um this must need not be so obvious like here they i can have two different reference variables and they can alias themselves uh each other um so this can come up so let's have a look at what size swap that this so we have lhs and rhs which both alias x and we move out of ah lhs into temp that is okay we move into lhs from rhs moving into lhs is okay because we are allowed to move into a move from object but lhs is the same as rhs in this case so we're moving from a moved from object and this is problematic because that is not one of the operations that is allowed by the eop definition of um of um of partially formed state right the it explicitly said in the book uh assignment only on the left side and then here of course we move back to templates also okay so how to solve this there are two solutions the first one is to i make move assigned from moved from objects self-assigned safe a lot of words but if you read this out two times i hope you will understand what i mean by this and it is always the case when you for example use the move and swap engine or provide a swap overload found using adl that's self swap safe so the standard does not say that you need to use standard swap the generic style swap you can also overload it um so if you don't like this self-assignment safeness of the move assignment operator then you can provide a swap overload which is self-assign self-swap safe and none of these usually require extra work so it does not cost you extra code performance time whatever to make these both work guideline prefer to provide an adl swap overload that is sort of swappable alternatively ensure the move assignment operator is self swap safe even in the partially formed state as a library writer you may want to avoid depending on a working self-swap i know that some stl libraries have uh fixed self swaps do not call them i think it should be safe so you should always apply this hint extension um but as a library writer you might want to be a bit more careful and and not depend on this guidelines ignore concepts move constructable1.3 which will be fixed prefer to provide an adl swap overload that is self-swappable alternatively ensure the move assignment operator is self swap save even in the partially formed state and libraries if you write one may want to avoid depending on working surf swap and here's a reference to the um to the sible first standard so this was 50 minutes and um i have bonus slides um but i will i know that i will not be able to go through all of them so um there's a tour i gave this talk uh a version of this talk last week and the munich user c plus plus group where i go through all these missing slides and that took one and a half hours um so i would prefer if we just stopped here and if you are interested in um in this pen uh walk through the pen class in the weaker models or the weak exception guarantees then i refer you back to that um talk in the munich use munich user c plus plus group thanks okay thanks mark for the talk um