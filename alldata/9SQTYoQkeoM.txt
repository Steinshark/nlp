this video was brought to you by IND dentle IO learning python Made Simple how's it going everyone as you probably know by now I really enjoy reading the docs and finding very random functionality that's located within it it's not something a lot of people do but personally I love finding out what python has to offer so today we're going to be talking about some very peculiar functionality that's included in the funk tools module and this is called total ordering and while we're here importing things I'm also going to import the self type since I love using type annotations so what exactly is total ordering well to demonstrate how it works I'm going to create a class with some methods and I already wrote this out ahead of time so I'm just going to paste it inside and maybe make the screen size a bit smaller so what we have here is a class called person and it takes a name of type string and an age of type integer inside the initial so that when we instantiate it the class or the object will hold this information then of course this person should have some methods such as working so when we call that we'll get that self. name is working and all workers need to eat so when we call that it's going to say that self-d name cannot eat right now because they have to work obviously and finally when we try to make our person sleep it's going to print out that self. name is now sleeping but dreams about working so here we have the Bas basic Amazon warehouse worker I mean regular worker doing what a normal person does and that was quite straightforward but now imagine you want to compare this person to other people for example down below we can create our if name is equal to Main Check and insert two people so we have Bob which is of type person and the way we instantiate It Is by passing in the name which is Bob and Bob's age and we want to compare Bob to Luigi right now by default if we try to compare these two objects it's going to be comparing the memory addresses of those objects for example if we print that Bob is equal to Luigi that's going to return false first because the information or actually we didn't even call Main that's kind of ridiculous so let's add our if name is equal to Main Check and pass in main so that the next time we run this you'll see that we will get back false but what I was trying to say is that regardless of the information even if Luigi was equal to Bob with the age of 35 we will still get false back and I'll change that back to Luigi and this is because if we were to print Bob and we were to print Luigi the way they are we would get these objects back and as you can see these are both different this one ends with 700 and this one ends with 760 they are not the same object and these two are being compared as is even if the information is exactly the same they are not the same object anyway let's pretend we do not want that behavior we actually want to compare the values well now let's go back to our class and implement the equality Dunder method so here we have the equality Dunder method which takes other which is going to be of type self and all it does is compare that the self dot dictionary and all its values is equal to the other dot dictionary which is the class that we are comparing it to so this time if we were to print that Luigi is equal to Bob we're going to get different behavior of course it's going to return to us false now but if we change Luigi to bul and the age to 35 it's going to return and true because those values are exactly the same but again I'm going to change that back to Luigi and 40 because Luigi should be Luigi rightfully and next we're going to create a different kind of comparison because we also want to be able to compare whether a person is more than or less than another person and in this context that might not really make sense so just bear with me it might be a poor example but this is how we're going to compare people to see whether one person is greater than another person so here I'm going to implement an another Dunder method called less than which is also written as LT and again it takes other which is the object that we are comparing it to and here we're using two PS to compare the two objects first it's going to compare self. name. lower to othername do lower and if those are the same it's going to move on to comparing the ages to see which one is more than the other or greater than the other and with this silly line of code we can now use the left arrow and the right arrow to perform that comparison so right now if we were to run this you'll see see that Luigi is more than Bob otherwise if we put a left Arrow it's going to return false because Luigi is not less than Bob if we had two Bobs here such as Bob and Bob 2 and we changed the age of Bob 2 to 37 you'll see that Bob 2 is going to be valued higher or greater than Bob one so this will return to us true but now what about less than or equal to comparisons such as this one here so we have less than or equal to if we try to run that we're going to get a type error because we did not Implement that functionality and the same thing is going to happen when we when we try to use greater than or equal to so at this point we have the option to also Implement that inside our class but something else we can do is go to the top of the class and use our total ordering method or actually it's a decorator so just type in add total ordering pass it over your class and what it's going to do is implement the rest of the comparison operators that means that it's going to implement the greater than the greater than or equal to the less than or equal to and so on it's going to take care of implementing everything else the only requirement is that you implement at least one of these and I'm not talking about the equality Thunder method it has to be the less than thunder method the greater than thunder method the less than or equal to or the greater than or equal to thunder methods it has to be one of those for this to actually work and the python docs recommends that you include the equality Dunder method but it's not required we can even just remove that so what that's going to do is generate the rest of the comparison operators for us so we don't even have to think about it the only requirement is that we Define at least one of them so now if we were to run this you'll see that our comparison works perfectly fine and we can even make it so that Bob 2 is equal to Bob 1 and when we run this we will now get true because Bob is either greater than or equal to Bob 2 and in this case they're pretty much the same person so now we can compare our objects however we like and I just removed Bob there or Bob 2 because we do not need him anymore so we can also compare Bob to Luigi which will give us false and we can still use the comparison operator and personally I'm just guessing because the docs didn't mention why they recommend that you define the is equals to operator but I think it's because the default implementation isn't really that useful when you are performing comparisons unless the identity of the object is exactly what you want to compare but in the docs they state that you should Define the dunder equality operator but it's not required so by not defining that we're just going to get the default implementation for that operator which again just checks that Bob has the same identity as Luigi but otherwise it's quite cool because now now if you have a class and you only want to Define one dunda method for comparing those said objects you can do it using one simple decorator which is the at total ordering decorator but the python docs did also mention a few notes such as while this decorator makes it easy to create well behaved total ordered types it does come at the cost of slower execution and more complex stack traces for the derived comparison methods if performance benchmarking indicates this is a bottleneck for a given application implementing all six Rich comparison methods instead is likely to provide an easy speed boost so obviously we're not writing this code which means something's happening under the hood which can obviously lead to some sort of speed loss and I guess these stack traces just become more complex because once again we do not see any of this code which is being generated and as for the second note this decorator makes no attempt to override methods that have been declared in the class or its super classes meaning that if a super class defines a comparison operator total ordering will not implement it again even if the original method is abstract so if your person class inherits from some other class or you already have something defined such as this total ordering is not going to rewrite that it's not going to regenerate that now moving on to how useful this actually is because I'm sure a lot of you are saying just use a data class well in some situations you're not always going to want to use a data class you're going to have a regular class with some regular methods and it's going to contain some information as well because if your data class contains a lot of methods then you're probably not using the data class correctly so this is to be used in the context that you require a class but with that argument out of the way let's move on to something else which confuses me quite a bit because to make it so that all of the comparison and operators actually work you only need to Define these three so here I defined the less than and the less than or equals to Dunder method and I also brought back the quality Dunder method which is not required but it's nice to have but once you have two of these all of the comparison operators work and that's one thing I didn't really understand regarding the total ordering decorator it doesn't really feel like you're saving that much effort at the end of the day because now we can just remove this line of code we can remove that import and our class will work exactly the same way because we defined these two D methods and to prove it I'm going to put the less than or equal to add the less than and I'm going to duplicate this and do it the other way around just to show you that it works with everything and if we were to run that you'll see that it's going to work as if we used the at total ordering decorator so that's still something I'm very fuzzy about if you have any information regarding where total order in could be useful please leave it in the comment section down below I still thought it would be a fun video to make because it can teach you a lot about how to compare objects in classes and you really never know when you'll find a certain piece of python functionality to be useful in your own projects so knowing that it exists can always be a great benefit to whatever you're doing but yeah that's actually all I wanted to cover in today's video so do let me know in the comments section down below what you think about total ordering or whether there's any other fun functionality that I should talk about in another video but otherwise with all that being said as always thanks for watching and I'll see you in the next video