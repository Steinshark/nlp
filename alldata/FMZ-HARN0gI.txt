uh I want to talk about GBL circuits a while ago I talked about oblivious transfer and some of you saw this topic coming but I think garbled circuits are amazing garbled circuit so this is uh ones that have been what purposefully garbled or that's right um so it's a cryptographic technique um for a problem called multiparty computation multiparty computation is when you have multiple people um that want to compute something right it's a computation um but they don't want to leak their private information to others so a famous motivating example is Yao's millionaires problem you have a dinner and there's a bunch of rich people there um and the richest person wants to pay the bill but they don't know who the richest person is did we talk about this kind of problem of the rich people paying the bill wasn't that the beginning of oblivious transfer we did a little bit on that didn't we yes so it turns out that obliv transfer and gobbled circuits go hand in hand so everyone enters their net worth into the protocol and then the protocol will simply say person X is the richest gobbled circuits are a way to solve this problem but not just this problem um you can solve any problem that can be logically specified uh using Boolean circuits so that's pretty much how computers work um and and compute the answer and just give you the answer and not leak any other information so a quick reminder uh about oblivious transfer uh the idea is that you're thinking of the value zero or one and I want you to know a secret uh depending on which bit you're thinking of um and I should not learn your bit and you should not learn what the other potential value is let's think about the millionaires problem for just you and I right so two people so garble circuits actually is always works with two people um there's the garbler uh and the evaluator those are are the terms so that means that you have a certain net worth I have a certain net worth we want to figure out who's richer and we don't want the other person to know exactly how much money we have I will be the garbler so that means that I will build an encrypted circuit and I will give you that encrypted circuit and I will let you do oblivious transfer to translate your net worth in bits into a sequence of Secrets and you can then feed those secrets into the circuit and the circuit will then either say you're richer or I'm richer it's of course going to be a big relatively big uh Boolean circuit um not very big for a computer but too big for this piece of paper right so I'm going to keep it simple I'm just going to play a different game um you're thinking of a bit Z or one I'm thinking of a bit Z or one and what we want to learn is whether we both are thinking of the bit one um and if the answer is yes then of course we will learn the other person was thinking of the bit one but if the answer is no and I was thinking of the Bit Zero I don't want to learn if you were also thinking zero or if you were thinking one right so this circuit is a simple and gate right the answer is one if both of us have one and it's zero otherwise so it's a very simple Boolean circuit so you supply a bit and we call that bit s and I Supply a bit and we'll call that bit T so obviously Sean's bit Tim's bit and what we want to compute is the end gate of this and we'll call that the result right now if we do this in regular Boolean logic you supply a value I Supply a value we do the end and we get the value the problem is I will know exactly what your value is and you will know what my value is so we're going to do this differently we're going to use um a trick for this gate so rather than Simply Having the value zero or the value one we're going to have a large value called The Wire value and there are two possible wire values wire value for true and the yre value for false right so we can call them s0 and S one so the wire value for S if the bit is zero and the yre value for S if the value you're thinking of is one similarly on my wire there will be two possible wire values t0 and T1 again corresponding to false and true and the output will be one of two wire values as well and that's it right so assuming that I'm the garbler and you're the evaluator right that means that as the garbler I'm selecting the wire values s0 S1 t 0 T1 r0 and R1 and I'm constructing this gate then you as the evaluator will simply take the gble circuit that I created and feed in s0 or S1 without you learning what the values of s0 and S1 are and that's of course where oblivious transfer comes in now how do we do this in practice what's the big trick of gobl circuits well this gate is actually a table of encryptions so what are the possible values I think we've all heard of a truth table right so we have 0 0 0 1 1 Z and 1 1 that represents the four possible inputs right so this is s and this is T and then what are the output values well that's R right and what we want is 0 0 0 1 right so this is The Logical interpretation of the gate but if we do encryption okay what do we have well we've got the wire value s0 s0 S1 S1 uh t0 T1 t0 and T1 right those are just the yre values corresponding to the bits and what we want as output is r0 r0 r0 and R1 now the big trick is that we're going to do four encryptions four different encryptions we're going to take the value R1 and encrypt it using the combination s0 t0 right so this is some bit string and this is some bit string the big wire values right we combine them together into a single key and we encrypt r0 with that so it's the encryption of r0 symmetric encryption I should say uh under the key that is consists of s0 and t0 right so that means that if you the evaluator have the values s0 and t 0 you can decrypt this value and find the value r0 similarly for the other ones we want the value r0 here and we're going to encrypt it with the combination s0 and T1 and here we encrypt the value using S1 and t0 and finally the only time we get R1 as the output is when both values are one so it's S1 T1 and this is the table that I'm going to provide you right because I came up with the values s0 S1 t0 T1 r0 and R1 so I can compute all these encryptions right I put them in a table and I then Shuffle the table a bit so you don't know oh it's a Top Value so it's 0 0 right you don't want to know that so I'm going to shuffle the rows uh but I'm going to give you these four values then I'm going to give you the bit that I'm thinking of in other words I'm just going to give you t0 or T1 you won't be able to learn the other value because there's nothing special about this value right um so I'm going to give you for example t0 because I'm thinking of the Bit Zero then you need to get the bit s0 or S1 now this is where oblivious transfer comes in you think of the Bit Zero or one and I do the oblivious transfer protocol with you if you were thinking of zero you will get get s0 if you were thinking of one you'll get S1 right and you won't be able to compute the other value from there so you now know either s0 or S1 and either t0 or T1 whichever I gave to you and based on that combination you can only decrypt one of these four rows properly and you don't necessarily know which is which because yeah okay I see yeah yeah and you don't know which is which exactly because we're shuffling the rows right now the problem is there's a minor problem here which is that you can Mis decrypt something right you can just use the wrong key and you'll still get an output and so there's a couple of solutions for that uh the most common one is called uh point and prute it's a fancy way of saying that in s0 or in S1 and in s t0 or in T1 I'm actually going to give you a hint which row to decrypt but you still don't know whether that row corresponds to this one or that one you just know I need to use that particular row so that that's a trick that they use I've given here an example with a single gate in general I could then use this value R you know for another bigger gate right I can then use this as an input together with some other data from a different circuit and perhaps do an or with that and construct a big circuit arbitrarily big and that means that we can do any arbitrary combination including the Millionaire's problem there's going to be a draw right what's the problem problem is yes so it can do anything uh it only uses symmetric encryption now I think it's been said on this channel many times symmetric encryption is super efficient yes but even if it's super efficient if we're talking about symmetric encryption of 128 bits milliseconds no micros seconds even right um but that is to do a single gate and and a single gate in a computer doesn't take micros seconds it takes Nano seconds so it's still slowing your circuit down by a lot as you can imagine every circuit also has four encryptions that are usually 128 bits long time 4 you know there's some tricks you can do to reduce it but the circuit description is massive so I'm going to send you Mega if not gigabytes of data in order to construct this circuit um so while it can solve any problem in theory um it can be a bit slow for more advanced problems was seven of diamonds and message one was the nine of uh Spades right um and now Alis wants to communicate this pretty tiny what I wanted to do is to have a progress bar where it FS on top of the text