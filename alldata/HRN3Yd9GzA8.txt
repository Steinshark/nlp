um I hope everyone is enjoying being back on site enjoying the conversations uh on the hallways enjoying the talks I know I do so I'm very excited to be here after three years of two or three years of online presentations so I'm hoping to we're we're truly back to normal and I'm hoping to see most of you at many more conferences soon a few of the you might not really know me I spent almost all my career building tools tools for developers mostly I worked for close to 17 years on Advanced installer and I've built Clank power tools to help with our workflow and the community at Large being an open source project and recently I joined the visual C plus plus team at Microsoft again helping build tools make the tools I use every day better uh this presentation is meant as a as a starter for a conversation and the concept I'm going to introduce are but just a teaser for more in-depth conversations and I'm gonna point to auxiliary resources for folks that want to drill down and learn more both articles and other presentations from conferences and I do plan to do follow-up presentations uh on on these topics based on the the engagement I see from from this version and I'm gonna do sequels for sure but don't worry no cliff hand openers just a fair warning maybe some of the the ideas here might feel too opinionated and that's all right it's intentional to start up conversation and have people buy into the idea and come forth and start a discussion with me or between yourselves so I'm gonna quickly jump in and try to do the impossible for folks that are not comfortable with some who are not familiar with some of the the functional programming Concepts I'm going to try to do a quick uh quick intro in roughly 10 minutes or so so bear with me in case the the title didn't give it away this would be a presentation on using a functional Style not necessarily about functional programming languages so functional programming what is it about um well there's a lot of Concepts here and some of them you referenced in the talk abstract of course we're not going to have time to go exhaustively through many of them but we are going to identify a lot of these ideas a lot of these programming Concepts in the examples we're gonna see and um um appreciate the way they they change how we structure and talk about code but first I want to highlight a paradox of programming in that I think this really um is somewhat um intense and and um for many folks I think it's difficult to pinpoint the exact mismatch in intuition and comfort they have towards programming and how we we structure programs and this comes from this impedance mismatch between what we need to tell computers to do and how we structure thoughts as humans and machines are very much into local reasoning whereas humans we we tend to think in bigger terms in terms of perspective and we are goal oriented as humans whereas machines are interested about small increments or small operations that need to progress towards a task and we we are very much about the ideas what the purpose what we're trying to to solve um and of course machines only care about the details of the how we want to solve this um of course we we have problems reasoning about complex systems because we have limited capacity of what how many bits we can hold in memory at a particular time how many Concepts we can juggle around in a particular frame of mind that's why we build diagrams that's why we try to distill the complex so that we have fewer moving parts and yes we are error prone and we need help keeping that in check and humans have developed a very efficient language to to reason about issues and complex problems and that language whether you like it or not it is mathematics and logic and machines don't know anything about that machines care about particular instructions and we've been kind of trained into this mindset I'm guessing out of schools or uh by just in in imbuing what we see in the community and in mainstream programming languages where we're imbued with uh trying to think like machines and trying to micromanage operations rather than think in in logical units or mathematical abstractions and we have to always stop and think about the semantics of the operations we're trying to implement the meaning of the the programs think about local bits about denotational semantics how we can abstract a given concept and then very concretely tell the machine how to model that and then how we can lift the the role low level operations results into something that is human interpretable so what is functional programming functional programming is a style of programming in which the basic method of computation is function application to arguments and transformations of data and the functional language is one that supports and encourages a functional style and I'm going to stress that a bit in this presentation my focus is not on convincing folks to switch to using functional programming languages the idea is to identify good patterns that and and things that we can learn from from such theoretical exercises and apply them concretely in in our domain in our programming languages in our Frameworks that we design in our apis but we do need to adjust the elephant in the room because I think most folks are I think you think about this right from the start of the presentation and again it's not about learning some functional programming language it's not about finding a mythical C plus successor language or completely transforming the programming language to be something else the idea is to to learn and see what uh idioms make our apis more fluent more natural to use lesser or prone and um what patterns help us build a simpler simpler shorter programs with less moving parts just a small snippet to get the the sentiment across uh in make your mainstream C like syntax programming language this would be a trivial low level Loop to sum up some integers and the the main computation uh instrument there is variable assignment so mutation is the core idea whereas in in a in a functional style we would think in terms of what we're trying to accomplish what is the the function and we need to always need an abstraction of function that does this transformation so function application would be at the core we're going to see more examples so if I would were to sum up in Just Two Words the the rift here in terms of mental model would be functional is about what what we're trying to accomplish whereas imperative uh methods imperative styles of programmings are about the details about the how Michael feathers had a very nice summary contrasting object-oriented programming and FP object when it makes code understandable by encapsulating moving parts and we all consider this the staple of object-oriented programming encapsulation and that helps us build uh more more complex abstractions and relationships between objects whereas FP makes code understandable by minimizing the moving parts so I think this is a good goal to minimize the moving parts so that we can reason locally about code easily before we start I always want to highlight the the historical background the importance of um of Engineers on that worked before us and we stand on the shoulders of their work and when we talk about new ideas I think a lot of innovations that we identify with contemporary programming languages be it C plus plus or c-sharp or Swift or rust or whatever we tend to consider them modern features modern additions but I think the majority of them are older ideas that just gain new appreciation just a a few persons I want to highlight here and break breakthroughs if we think about Lambda calculus this is all the way from 1930s when Alonso Church develops Lambda calculus for a theory of functions basically in the 50s John McCarthy develops lisp I think a few folks have have heard of lisp but at least in school if if not from for more than modern incarnations of dialects and this was the first functional language of course influenced by Lambda calculus but it still retains something we identified today as variable assignment later on Peter Landing develops a swim the first pure function functional language again based on Lambda calculus and this one didn't have assignments so Purity is nowadays associated with functional Style and pure functional programming languages try to make the best of this and and sell it as a corner feature John bakus I think most folks associate his name with Fortran or alcohol uh a few folks actually know that he develops FP a functional language that emphasizes higher order functions and we're gonna see a lot of these examples today of higher order functions in the 70s Robin Milner develops ml the first modern functional language which introduced another concept type inference that we we love today in in mainstream programming languages and of course polymorphic types these are no longer news in the 70s and 80s David Turner develops a number of lazy programming languages culminating with the Miranda system so for the first time we we surface Concepts as lazy evaluation in in in the way we compose programs and request computation and of course the Beloved Haskell which started uh as a standard discussion um through the late 80s and um in in the 90s I think the Cornerstone additions to the language most folks have heard about or associated with the name type classes and monads Main innovations that landed in Haskell mainly the work of Phil waddler more about him later and of course this got standardized in the early 2000s so all these four Haskell so if Haskell is so great way hasn't taken over the world um well I claim that it has in a way but not not directly it's not something that um happened in terms of um we all started programming in Haskell or in other mainstream programming languages yes there are companies and projects that run on Haskell and Mission critical software and yes you can write high performance software in in functional programming languages but the idea is that I Concepts that distilled for eight years in in academic research and in pure function languages have surfaced in in mainstream programming languages as uh as as if novel ideas and we are trying to adapt them of course not not all of them fit in the context of imperative programming languages where we're still trying to figure out ways to to make them feel natural or feel at home um if we're talking about C plus plus or if you're talking about Swift's algorithm library or rust each Community each each Niche each mainstream programming language is trying to borrow Concepts and make them feel at home and see how we can make code that we write feel simpler and more easy to reason about so C plus plus has indeed become more functional from mundane Concepts like lambdas that everyone is using these days standard function higher order functions value types constants that we're trying to use lazy ranges folding fold expressions and even more Nets yes there are monads in C plus plus um a quick taste of Haskell can anyone figure out what this piece of code does I'm gonna try to um demystify the syntax so the plus plus just means list concatenation and we have some list comprehensions that tell us that y's are all the X's that are smaller that are greater than a and these are all the X's that are smaller than b so what do you think this does it's an it's an algorithm quick sort yeah quick sort very good so if I give them better names I intentionally left them dry so we we would have a recursive application of the quick sort function to the partitions we construct using those list comprehensions so if I were to have like a um step-by-step modification of how these things happen this would be the least cells that we're decomposing and sorting there so the idea here is that we're we're declaring our intent in how we want to attack this problem we're not describing the steps or the mutations or how we need to Pivot we're just expressing intent using release comprehensions and a function application to say what we're trying to achieve in in partitioning and sorting the sequence so if we were to do this in a very imperative Style we would have to don't don't try to read the code it's not important um this was just pseudocode lifted from uh standard the algorithm book by uh Corman uh so it immediately we see that we have lots of moving parts we have complexity we have to reason about State and boundary conditions and it's very easy to screw it up anyone who's tried to implement a quick sort or a binary search or something that's very simple as an idea but very difficult to get right in in all the condition all the details and quick story here in 1986 you know I love history bits by now so in 1986 Donald knuthworth asked to implement a program for the programming pools column in Communications of ACM and the task was to read the file of text determine the end most frequently used words and print out the top n with their respective frequencies in that body of text sounds like a standard interview problem or I know School task so you know Don knuth is a pretty thorough person pretty thorough programmer so his solution written in Pascal at that time that was fashionable it was 10 pages long and it was correct it was a correct and thorough solution but I want to highlight a different solution how many folks have heard of Doug McElroy just one hand so um Doug mcary was intermed instrumental in in the developer of Unix and for a while he even managed to come Thompson and the team that worked on that on those projects so I think we all love and appreciate a good pipe and I think we have many Linux enthusiasts here so he's the person that's responsible for this Innovation the pipe and this is his solution to the very same problem and this is a complete solution so it's not 10 pages long it's six lines of shell script that accomplishes the task um there's the very same task in in in finding what the word frequencies and sorting and printing them out I do encourage you to read more about Doug McElroy I think he deserves more exposure and recognition for his contributions and not just this script so taking inspiration from dark macaroy's unique shell script you can think about writing an algorithm in your favorite programming languages doesn't have doesn't have to be C plus plus and try to solve the same problem but in the spirit of Doug McElroy's pipe and see what you come up with and how would we start on this journey well it's all about functional programming so I guess we should all read up a way thicker book than that one about category Theory and endomorphisms and monads and all the crazy mathematical Concepts required right there is actually a book like that and I did enjoy reading it but I wouldn't recommend starting with that one by the way it's I put a link there it's in PDF format it's freely available if you want another printed version there is a print order a very good book but um we have to think about how does this apply to our beloved language how does this translate how can we use this in C plus plus is there value for for for us today from these Concepts or is just a is it just a mental exercise or something that we like to think about and write toy programs or academic papers can we use this in C plus plus and if there's a takeaway from this presentation would be to start with this book so if you want to learn more and see my many more examples than I have uh today I would recommend this as a starting point for your exploration for your transformation for helping you think differently in C plus plus even is that this conference by the way you can find him on the hallways and ask more uh I'm I have to pick something because the time format doesn't allow me to go into detail about everything so okay so apparently the stream is working now we had some technical difficulties before so I had to pick some topics and my first choice was lifting and you're gonna it's gonna sound like it's something complicated but I want to make it sound very pedestrian very simple and we're going to show very concrete examples and when we're talking about lifting we have to talk about high order functions and don't get scared about the name higher order functions are everywhere you are using them if you're using a dstl if you're using the algorithms if you're using ranges you're using higher order functions if you're providing lambdas or predicates you are using higher order functions uh yeah I had to mention boost high order functions library but I'm going to focus on another Library less known uh called lift by my friend Bjorn and it's a c plus 17 Library has a simple context per higher order functions of predicates and helps us write and compose functions easily and we're gonna see how how we can do that the reason I chose this library is because I want to highlight the way it helps composition and because it's a it's an easy library to read and understand the source code is right there a few high order functions that it provides The Usual Suspects I think they're pretty self-explanatory by the names but let's see a concrete example suppose we have a structure with two fields and we have some way of projecting those fields outside by selecting the name or the number in the structure and we want to sort the elements the structure Elements by name by one of the fields so instead of being very explicit about it and just sticking a Lambda there and doing the the the usual thing we can I I have to showcase the the way we can compose things so we we're composing the less function and select the name and we're providing this as a higher order function for the sort algorithm don't worry about the compose details later and if we want to do find if again we're interested to finding something that it's where the employee number is equal to five whatever that means and yes we could have written up Lambda and be very explicit and be very imperative in style and and selecting what we care about there but I wanted to highlight how we can compose these two these two functions and even have a partial function application by providing five there as an argument to equal uh again to accomplish these things and don't worry if you're if you can use C plus 20 ranges you can do things like this and more with projections so it's it's already in the toolbox you don't have to reach for some kind of third-party Library I just wanted to highlight highlight it as an example and don't worry about trying to parse the this this macro is not that important I think the example here it's much more interesting and again using uh Bjorn's Bjorn valer's lift Library here we are trying to lift an overload set so not just one function so we're trying to lift an overload set of all the two string functions and basically we can try write a transform that could work on uh different kinds of input sequences here we have Vector of integers but they could be anything that can be too stringed uh and transform them in the destination collection which would be a vector of strings so again we're seeing a way of lifting the domain of the function application and again I'm going to draw some diagrams to bring this point home by the way this would be the presentation by Bjorn Fowler to watch the link is there if you want to see more details and more examples uh I'm gonna come back to to lifting in a bit okay let me check on something yeah but first we're gonna have to talk about boxes so I I picked another concept and I need to talk about this so that we can digest to the examples and see lifting in action uh and that the other concept that it's deeply rooted in in functional programming style is uh the idea of type Constructors and a way to capture a value with its context so in C plus plus we have a few type Constructors that are already there in the Box pun intended a unique pointer and SharePoint or vector optional function standard function and many others uh and for each of them we have a way of poking the value inside so we can get the the the value that the pointer points to we can get an element from the vector we can get the value from the optional and so on we can do the function application but uh the idea here is that the what what we should aim for is not looking in the Box the idea is not checking at each step to see if the value we have in this in this container is actually valid is actually usable at a particular stage in the pipeline of the computation the idea is to chain multiple Transformations apply multiple functions multiple move the data around to the transformation Pipeline with its context and at each stage by by different techniques and I'm going to highlight fmap as one such technique we can apply the transformation based on the value in its context and move it further along without querying it at each stage and only at the end we query the result and see if we have a successful transformation so standard optional is is such a such a tool in C plus plus since 17. so to reiterate don't use optional for error handling because that would force you to check it if it has a value and try to use optional to chain computations and build apis that are intuitive and and fluid in the way they compose and of course you can draw inspiration from programming languages that have gained this tool long ago if you want to read more about functors applicatives and why not monads there is a series of articles that I think explain the concepts in a very um intuitive way using pictures so no fancy mathematical explanations the link is there so I I saw to I said to draw inspiration from rust uh in in Rust using uh the option type is pervasive all apis expose this as the vocabulary types and developers are used to dealing with option types and they they the idea here is again don't query the value within try to to chain it or try to do pattern matching to see if you match your value or not huh so the the magic of applying the value should happen uh in a way that masks the the client code from the value Within so we should think about the inter transformation to the context and putting the the the value back without actually looking at it to see if if query the value and let's see some examples uh let's think about capitalizing a string right so we could have a capitalized function that takes the string and returns a string and we can obtain this string from one API that can fail and we might not get a string back so we which we could model this as an optional string out of that API and here we have the the the idea that I mentioned earlier the code actually looks to see if it has a value so that if actually checks and if I got a value from the API then I do the transformation I want to do this is not the ideal workflow and of course we can change that to an optional thing but that's not the idea the idea is building a lifting operation and this is where I go back to to lifting we can think about a lifted capitalized function that works on an optional string and returns an optional string so rather than going from string to string it goes from option listing to options thing is that is like changing the domain and codomain over function so uh that we we hide these details inside this higher order function and we can think about them in in terms of raising the or lifting the the the the the domain lifting the the abstraction so if our capitalize works from string to string lifted capitalize works from options link to options link and yes of course we're we're not going to build sibling functions or duplicate all of our transformations to do this this was just uh to get there there are higher order functions that help do this lifting operation transparently and one such possible implementation would be an fmap function which takes as an argument a function from A to B so standard function takes an argument of type A in terms a value of type B and it does a transformation on an optional so it transforms an optional of a into an option of B and it does so using any function so this is a higher order function because it takes a function as an argument so if map is a higher reflection one of our first examples today and lifted if the exact same diagram exact same idea now just generalized for an F function we now have a lifted F through an F map high order function that now takes us from optional of a to optional of b instead of a to B so instead of going to string to string optional string to optional string let's see and uh if you we want to express that concretely let's say we have a two-stage transformation so we have we wanna uh trim a string and then measure its length standard way of changing these kinds of operation so we want to trim the string any white space and stuff like that and then we'll see we want to see how long it is so at each step we might have a failure in to produce the result so trimming might not yield let's say it might not yields the the result or length might fail of course these are trivial examples but I want to build an intuitive feel about this so we have to raise the the function application domain trim is from a string to a string and length is from string to int gives us or size t or whatever gives us the length of the string and we can compose them using two fmap applications the first lifting operation happens for trimming and the second lifting operation happens for the length function so don't worry about the syntax if you don't like it it gets better another way of writing this if you don't like the standard function root and you have many reasons not to like the standard function root you can write it this way and again this is a higher order function another flavor of 4fmap not the only one where you can take the function as the the function that needs to be lifted as an argument and again it would lift it in the optional of type domain economy let's say we want to build a a symbol table for a program we're debugging or something like that and we maybe we have an API that gives us an IP counter function address currently executing function let's say in a debugger or something like that and we want to get the debug location from this which might be the the function name where we stopped where we're breaking the debugger so um we might have an API that loads a symbol so for a given program counter gives us a symbol and then we want to transform that symbol which might be in some internal structure that we represent in the debugger into some presentable information to the user like a string friendly display string so this would be that way of checking at every step do we have a current program counter could be an option could be unavailable the API have failed did we manage to load the symbol do we have a symbol yes no a board what do we do we return an empty optional and then if everything went okay we're trying to display the string so re reorganizing our our thoughts here we're trying to again compose by lifting those functions and doing f-map so the first the inner F map s US map the the loaded symbol so helps us going from the current program counter through the load symbol function which is the low the lower function and that then gives us an optional symbol type whatever the symbol type is in our in our system doesn't matter it gives us an optional of that type but we don't look at the optional we don't care at this stage if that succeeded or not and then we compose we take this further and we we lift it using the another fmap transformation and we're applying to string to it let's say we have an overload of two string for that particular debugger structure we're dealing with so uh and at the end we're yielding an optional string so that's the intended result intended the goal was display a string of that function name where the debugger stopped so at the very end we get an optional so we get that box and it has a context and at the very end we open the box and see okay do we have a function name there to display or not and you can do fancier things if you care about syntactic sure um we can do the same thing with a vector I don't think this is uh tight optional so the same pattern can be applied to any type of such box and I mentioned a few earlier so Vector would would be another Prime Suspect here for example we can have an fmap function uh again from A to B as a function application domain and inside we can use another higher order function from the standard Library this time standard transform standard transform is a higher order function proof it has an argument which is a function so our fmap uses standard transform to transform a vector to transform from A to B our function is a to B and we're trying to build a new function that goes from Vector a of a to Vector of B so we're we're we're lifting the function into a new context which is a collection of A's and B's so let's see something like this um again we're having the length length function for string and now we want to operate on Vector string and produce a vector of integers or size T if you want to be a purist so uh we could Traverse the vector of strings and apply length to each element and then insert it in the vector of integers of course but we can imagine this might be a more complicated thing where that length operation might not succeed or whatever API we're talking about so again a way to compose this using our fmap lifting mechanism from previous the previous slide we can f-map from string to int and use the length function and now we get a new higher order function so we we have a lifted length function that we applied to the names Vector so the input for this transformation is the vector of string the names and the lifted function the lifted length function which now operates on this Vector but yields a completely new type of box a box of integers which represent the individual length of the items there so we've seen a few Concepts we've seen the type Constructor and we had two examples with optional and vector and this helps create a box that wraps another types so an optional wraps the type within it a vector wraps up models a collection more than one value so a box can hold more than one value by the way so a vector wraps a value of its type let's say integer strings whatever and uh the idea of the context is essential here because it it encapsulates the types and it can carry context along the processing pipeline that we built and we've seen functional lifting and that was a way of creating a higher order function like we like we showed with fmap and it helped us create a new function instead of going from A to B that mechanism helped us build a new function that goes from box of a to box of B where box was optional vector or whatever shared pointer if you want so um we we at any step we try not to break encapsulation so we try not to query the value until the very end and it helped us build composition instead of writing a bunch of if else branches and structural code by nesting conditionals and multiple exit points from the function and dealing with all the the conditionals we're trying to build up a pipeline something in a style of repeated function application and at the very end we we see the pipeline succeeded or not and we have monadic extensions to standard optional since C plus plus 23 and you can even use them earlier if you don't have a access to fancy C plus plus versions there are many implementations of monotic extensions freely available on GitHub I would recommend the one by Cy brand you can find it at Tartan llama GitHub llama and look for optional so let's say we have a string view to int function here where we're trying to um do a type conversion and we're getting a buffer and we're trying to convert into integer if we can and inside we're using the from Charles API don't worry about the error handling and the details there not important what I care about is the processing pipeline so instead of building a function with that deals with all the the error conditions and tries to figure out okay what are we doing what are we returning at each stage when we we failed to transform the the input buffer into a string we're building a linear sequence so instead of nesting a bunch of IFS or Worse buildings and callbacks so instead of nesting we want to build a linear Stream So something that feels like steps that we we proceed through so this is where the and then or transform or or else functions from standard optional can help don't mind the details it's not important what each step actually does just an example the the main takeaway here is that we're we're building uh a transformation that looks linear it's not about branching or nesting within and at the very end where we change the bunch of things that all had optional things in them at the very end we do the dot value and we see if we got something out of it or not uh more on and I think this is very close to to what we can do in declarative style in C plus plus uh but I think this slide from uh Ben's presentation on declarative style C plus I think this is the the slide that's best synthesizes the presentation but I do recommend you watch it I put a link there is about uh what's the signature element so the signature element would be function application and higher order functions and chaining and composition this is one of we want to Target so we wanna stay clear if possible of statements and mutation and um yeah difficulties that come composing with such low level bits so what we have to remember is that Expressions yield values and statements do not might seem obvious but we have to keep remembering that the distinction between working with expressions and working with statements that statements cannot function without mutation I'd recommend another presentation and not because it's about a c plus successor language it's about because it's focused on values and value semantics I don't believe it's yet on YouTube but should be soon from cppcon this year so look out for the values talk from by Dave Abrahams very important I think it's very important to to watch it even if you're not interested in an experimental language more references for Value semantics that I think might help once you get past the principles and I hope I I gave you a good teaser to stir up interest to explore more um I would recommend this presentation by juante Boulevard Puente value semantics the most valuable values I I love this presentation and it's all about value-oriented design and how it the talk actually tries to reconcile functional and procedural programming by focusing on value semantics so that's the most valuable bit out of what we can translate easily in C plus plus C plus plus is very much a value-friendly programming language but we have to learn to take advantage of this and distance ourselves if possible from 2000 style programming of using sharepointers and object-oriented class characters so like functional programming it promotes local reasoning and composition so that's why I think it's important to try to follow some of one best examples there and I think it's pragmatic so definitely worth watching another presentation on values that I highly recommend again from one pay squaring the circle variant value oriented design in an object-oriented system this one is about trying to bridge the gap and see uh a few techniques we can use to retrofit some of these value Concepts and uh working in in this different mindset in a code base that is heavily Legacy heavily object oriented um if you want to learn more about immutable data structures this is something that's a another Cornerstone of functional programming I haven't touched immutable data structures at all in this presentation they're way outside the scope but if you want to learn more this would be a good start representation Again by one pick and um of course we've seen already at this conference we've seen a bunch of presentations on on ranges even some controversial bits so I have to mention um a few of the ideas of ranges and they all stem from functional programming paradigms just a quick flavor in case someone missed the train and not comfortable with C plus plus ranges just a quick before and after shot in terms of I want to highlight the style don't follow the details they're not important I want to get you a flavor for the style so on the left we have a very step-by-step intentional what you have to do computer to solve my problem and on the right something more kind to the goal we're trying to achieve or the higher level Transformations that we're trying to to pipe through so reversing filtering dropping elements taking the first elements filtering on a given predicate and so on again I I think the the idea here is that's why I I I'm putting it side by side is to contrast the the the how and the what what we're trying to accomplish I think we should try the state to try to stay closer to what we're trying to accomplish and be succinct and there are less chances of airing out again another example don't mind the details just appreciate the the differences I think C plus plus 20 ruined one of the my favorite interview questions and that is to split a string how many of you have gotten this interview question no a few few hands so this kind of thing becomes trivial now fair warning I don't think any interviewer will accept this answer they actually want to see the algorithm okay so getting back back to to the pipelines and Doug McElroy's magical script we can try to give a teaser back a few slides back we can try to do a similar thing in C plus plus using ranges um don't try to decompose this in your head I think you can intuitively gain appreciation that this is very much close to what doug had at least as close as we can get with what we have as building blocks so we can we can go get closer to that goal we're never going to get the syntactic sugar and the succinctness of something like Haskell or a shell script commands but we can we can strive into that direction for sure we can have less moving parts and less ifs and simpler code so this is what we should strive for we've already heard a few gotchas from Nico in in his keynote uh on ranges I'm gonna reiterate some of them that I consider important and Views remember that views are rev have reference semantics so all the reference gadgets of C plus plus apply to views it's nothing new just we have to just remember that they have reference semantics as always with C plus const is shallow and doesn't propagate as you might expect sometimes so be aware of that some functions do caching I put this deliberately in after Nico's Keynote just to raise the awareness once again don't hold on to views and don't try to reuse them the safest is to use them at hawk or as temporary values let's say like I had in in my previous examples uh here so use them ad hoc in line where you're doing the processing don't try to hold on to them and if you really must hold on to them if necessary make copies so that because they're cheap and you avoid surprises due to caching and other bits so I would close off by reminding you of Phil wadler we've seen him at the very beginning and I'm gonna draw inspiration here from Ivan again this is how Yvonne likes to close his stocks and channeling functional programming in c plus plus I have to close the same way so um listen to Phil wadler make your code readable and pretend the next person who looks at your code is a psychopath and they know where you live so program so that you don't have any surprises and with that appears I'm on time if you have any questions feel free to ask [Applause] or if we have questions online uh if we run out of time we I can take questions of the record one question on the record no Victor thank you thank you for the talk so um just one question I'm I'm someone who is going to try uh functional programming if you haven't tried yet so uh I'm I'm wondering how the debugging would be uh say with other debuggers ready for functional programming or is it something that we have to watch out for that's that's the most uncomfortable question I get when I give this talk but I I'm I'm glad you did it so I would say uh it's better than debugging macros which is not much uh the idea here is that when I when I try to learn Haskell this was the most difficult part for me I tried to at each step I try to see okay what am I transforming am I getting what I'm expecting in the new list I try to and it's even harder in a pure functional programming language too because it's harder to to Output stuff to see to pick at the program so first of all having less moving parts means you do less debugging you need less debugging because the parts you're composing can be individually tested if you want them the beauty of if possible if you're trying to program in a pure style where the input is processed and it gives an output without mutating external state is the beauty of that is that you can rip the parts rip the the parts and each one can be individually tested because it has no dependency of any external state it just has an input and an output so this eases up when you have a chain of transformation you can take out parts of the transformation and this is what I do take out parts of the transformation and see if is this working okay this is working as expected I put it back then take another part of the transformation is this working now put it back so because you have an input and an output and if possible you don't modify any external State you don't have any side effects then it's easy to take bits and and test them in isolation it's even easier to mock functionality if you want to do tests automated tests and stuff so first it it eliminates the need to inspect variables and watch for for memory transformations and second it's easier to to test in isolation but there is no debugger support like magic uh I think we can we have to close the stream here but I can answer questions uh of the record so go ahead you can ask the question uh thanks for the talk and I pretty much enjoy functional programming and I try to incorporate it in my first code as well but I always wonder whether yeah what is what are your your experiences with performance implications if you change the style to this side you you uh you have to do it responsibly so not not everything is gonna magically be fast so um but I I think this applies in general to C plus plus you can you can really surprise yourself by copying stuff you didn't intend in C plus plus without trying to do functional Transformations so uh you have to be careful at each step if you have concerns about ranges ranges are lazy so most of the time so you can try to be eager about evaluating at certain stages but in generally they try to be very efficient so if your concerns are about ranges uh I would say 90 of the time you shouldn't worry about that they are performant they cost in terms of compilation time but at runtime they basically boil down to almost nothing so it's it's it's like inline functions it it all that all that uh type trades and boilerplate will just go away when optimized but yes you can do an unoptimal stuff you can copy things without meaning to um there are parallels around the optional Constructor for example if we talk about concretely about optional and I'm I have a one more Presentation tomorrow uh where I I give an example where optional can bite you if you're not don't know what you're doing so you can accidentally build and call accidentally call Copy Constructors and do unnecessary things uh but but I think that's not necessarily a problem of working in a functional style it's a problem of not knowing what you're doing in C plus plus in general like the the regular C plus plus foot guns apply to functional programming as well so uh it's it's not a guarantee that uh it will be optimal but having less moving parts means there are fewer chances to get it wrong in my opinion I'm not claiming guaranteed program optimal programs nobody can do that sure thanks again yeah I have to Benchmark more I guess always measure intuition fools you always measure yeah always measure if there are more I don't see people lining up for the mic if you have more questions do catch me on the hallway or around I'm easily identifiable