welcome folks to meeting C++ 2023 my name is Mike and I'm going to give you an introduction to C++ containers and this is really going to be about knowing your data structures or giving you an overview of what's important and again how to use what's available to you in the C++ standard template Library so here's my information if you want to reach out or get in contact or see some my other resources and I'll talk about these things in a moment as well but just so we go ahead and get started again here's the abstract that hopefully brought you to say talk or enticed you to watch later on again our goal today is to get an overview of what's available in containers in C++ 2023 and uh have an idea again of where to start and when to use each of these data structures so the code's going to be available for this talk if you'd like to grab it later or play around with it I've tried to give commented samples as well so feel free to dig into uh what I have uploaded there uh otherwise a little bit about me I'm an associate teaching Professor currently at nor Eastern University in the US in Boston uh and that's my primary role and on occasion I do do Consulting on computer Graphics projects and occasional training in C++ you can find me on YouTube you can dig around my website or my uh courses page as well uh where I have additional trainings available now today we're going to be looking at the standard template library and the containers and there's many different containers in fact I'm going to fit in most of them in this presentation to again give you a highle overview but if you'd like to see specific use cases and more again those are highlighted in some of the videos that you can see here programming from literally an empty source file to actually running some experiments and so on so feel free to dive in there if you don't find everything otherwise you can find uh this talk again as a general overview or many other wonderful meeting C++ 20 20 23 talks where you'll learn more about containers and the standard library and so on so let's go ahead and just start from the beginning though for this talk here and I want to just start talking about data and what do I mean by data or data is this idea of what a machine's role is when we are programming and some of you might know what this machine is here on the right this is a prototype or an early uh example that somebody built of a turning machine cre by Alan Turing and my purpose of putting this here is just to inform you or remind you what computer's jobs are to just take data in perform some operation and give you potentially a new result and transform that data out that's it it's kind of comforting to know that that's all computers are doing at the end of the day because then we can think about how we approach this process and improve it over time but in order for us to pragmatically write software that's going to be useful we probably want some higher level abstractions so that we're not just looking one instruction or maybe one bite at a time and trying to figure out what to do with it so we have some fundamental data structures as one of the ways for us to help abstract this process and help us think about how we're transforming and storing data and so on and that's the purpose of a data structure right this idea that we're able to store and organize data similar to an analogy of how you might store data on a bookshelf or in a drawer somewhere computers are going to try to do the same thing with some highle abstractions and some of these are given to us in libraries or maybe even built into the programming language so that's the idea that we want some ways to store and organize data and that's why you're here to learn about various containers that we have for data available in C++ so fundamentally to sort of start building up this analogy and understand what we've got here in C++ we have built in arrays so again most of you are going to be familiar amiliar with this idea of creating a raw array of some amount of memory here and you can allocate this array on the Heap here so here's a visualization of where an array of nine integers might fall into memory arrays again being a sequential chunk of memory all of the same data type okay so that's the idea and we can index into this memory but again this is our first way of sort of organizing data in this nice sequential structure and we can allocate this statically so there's a few examples on the right here just showing on the stack allocating exactly nine elements for example in this fix size array or below here we can dynamically allocate memory if we need more so in the instance that we need to make a huge allocation again that's an option to do that on the Heap by requesting memory from the operating system from new here and doing a large allocation so this is perfectly feasible and legal here for us to do but we do have to be a little bit careful here when I do this allocation or request for memory from the operating system here with new here because I need to make sure that I delete this memory here and this is effectively us doing some manual memory management and that if I'm requesting well what is this one million integers here that I'm actually freeing that memory when I'm done with it of course these things become more serious when you have a loop or long running program to make sure that you're not leaking resources but regardless this shows us how we can allocate some large contiguous sequence of data and even pick the size at runtime and again that's the point of having statically allocated versus dynamically allocated memory here with this example shown with new so that's the difference here with how we're allocating memory so fundamentally beyond the built-in array structures that we have we also have what are known as linked data structures so this is a way to sort of expand or contract data structure but we're really just thinking about it as sort of a fix size unit so maybe one node or one Link at a time here and in C++ we have built into the language pointers which is one of the mechanisms where I can sort of Link or point to the next node in a sequence of data I'll show you an illustration of that in a moment here just again so we have the full visual picture in our mind here of how these data structures work and and these link data structures can be used to create well individual lists as shown here or trees that Branch left or right or maybe they have multiple links like in a graph so again very powerful way to store organize our data which is the point of data structures so again usually when we're thinking about a link data structure we're thinking about some sort of node here so I'll draw your attention to the right side of the screen here where I have this struct here with a node and I have some data here and a pointer to the next node that I'm linked to so that's Illustrated roughly with this diagram here where I've got my data an integer or perhaps some other type and the node pointing to the next struct that consists of some data and the next node until we maybe run into a null pointer or some Sentinel value that tells us hey we're going to terminate we have no more data in this link of structures now with link data structures thinking about this maybe from a memory standpoint we don't really know or have a guarantee that this memory is going to be contiguous maybe we have some idea but again we don't know if we're allocating these nodes with say new for instance that they're going to be one after another and that leads to other important discussions when it comes to Performance and some ideas we'll touch on later but hopefully you understand this fundamental idea here of how we can add nodes together uh quite nicely here in this structure here and this is a link structure or maybe some sort of list which is often implemented in this manner so we have these building blocks these fundamental building blocks for organizing our data built in arrays maybe they're static maybe they're on the Heap so we can do large allocations and linked data structures where we can connect through pointers and we should also consider that I can combine those two ideas to this third picture on the bottom right to have link structures of arrays or we could even flip that around and have structures for instance a lists of arrays for instance so however you want to think about it just these simple abstractions allow us to build more in intricate and interesting data structures already so that's the general idea with our building blocks now of course if I've already alluded to depending on if we have a linked or a contiguous data structure this can lead to many tradeoffs and some of you have learned about various data structures again this might be review for you and you just want to see the containers but for those who haven't again how we organize our data really impacts the performance again imagine going to a library for instance with one huge bookshelf one book after the other or a library that has things organized in sections maybe categorized that affects how long it takes you to find what you're looking for same thing with data structures and often time we categorize them with the access time for retrieving something the search time to find something and then other things like how long does it take to add a new piece of data or in the library analogy a new book to the library such that we can uh have room for it in that library or otherwise remove something so again these are some of the tradeoffs that we want to consider and along with this some other things or factors we think about with our data structures are whether they're fixed or resizable um you know maybe they're just allocated one time so again there's many different trade-offs here sometimes even just the ease of use of a data structure so you can observe this and you can visit this website here if you'd like to take a look at or refresh a little bit when it comes to complexity of your data structures but let's go ahead and proceed here now here's the good news for us it's that all that knowledge you've learned or maybe are learning right now about different data structures well that's going to come in handy because we can just literally choose the right container off the shelf for us because C++ comes powered with several data structures or containers as they're going to be called for us to use so let's go ahead and take a look at the standard template Library here getting a little bit of a brief history and then we'll keep working towards containers here but everybody should know at least a little bit about the history of the STL uh that was proposed by Alexander stepanov around 1993 and then sort of incorporated or released in 94 and officially adopted in 98 but this idea that we should have some built-in data structures and that they should be generic meaning I can work with integers or a custom type that I make strings Etc so that's the idea and sort of the power of this and then I should also be able to use some of those containers and data structures with things like algorithms and so on so generally speaking we have the standard template Library available with many different compilers from many different compiler vendors and it's supported fairly well on pretty much every platform where you can find C++ so again here's a view a high level view of the standard Library here and you can notice we have lots of tools available again today we're going to be focusing on something known as containers our data structures which we've begun talking about and we're going to be talking about specifically the ones filed under the containers Library section there's other things like pairs tupal strings bit sets Val arrays and so on that are available and interesting to perhaps know about that are also containers or data structures but again we're going to focus on the core containers so here's our overview here's where we are with all of our containers uh and various libraries and as mentioned here's where we're going to focus just this piece today so within the containers Library there's actually four main categories of our containers that we want to take a look at here so I've got sequence containers associative containers container adapters and unordered associative containers and this is roughly how we categorize them in C++ and this is probably similar to how you might think about them in terms of the data structures sequence things that are sequential associative maybe some sort of key or value uh relationship there unordered well specifically telling you that they're not in any order and adapters is kind of a funny one but we're going to think about these as an interface to using some of our data structures okay so let's go ahead and proceed and again with C++ containers here and again the motivation here for using these versus say building your own data structures is one because you you get these powerful already built uh data structures uh available with your C++ compiler so again they're generic in the sense that I can just have for instance in this Vector which is one of the containers we'll talk about a collection of integers or I can create my own user defined type here UDT and also use that it's just as simple as uh populating the parameterized template here and that's really it and of course you can take advantage of uh the cad class template argument deduction just populate data if you're not exactly sure and C++ will usually do a pretty good job of figuring it out though I recommend usually putting in the type here so anyways with containers they're generic meaning you can use them with well any data type that you come up with and there's also some interesting ideas with having generic data structures here so this is a little bit of an aside but if you're really interested in templates or playing around with this stuff once we you learn about a container like vector you might also learn that hey maybe a list is a better way to solve this problem and effectively you can just swap one for the other whether that's for ease of use or safety or performance or whatever reason you can actually just effectively swap these out so here's just a little illustration here of something known as an alias template where you can pass in the data type uh and the container and just replace with uh my type here so you'll see that that's been replaced with the previous example there just some fun stuff you can play around with but again motivation for the containers now secondly the containers are well tested meaning that again the result of Decades of engineering and iteration on these containers means you'll at least find somebody who probably knows how to solve the problem on a web form or on your team uh because again the STL has been around for a really long time and again is typically well tested Ed by hundreds of thousands say of seat bus boss developers and the third and final Point again because they're part of the standard template Library they work well with things like the algorithms and iterators that are provided with C++ so I can kind of see that iterators are the glue between where I'm storing my data and how I'm accessing it and what I want to actually do with that data on the algorithm side of things and here's just a small example showing you how to filter some data that's been generated so again this is the idea with containers you can pause the video and digest this example if you want but we can see that everything's being touched on here I've got a container with a vector I've got some algorithms here for generating data or otherwise copying and filtering that data and then some iterators telling me how I want to move through that data and access it okay so that's the idea there all right so with that introduction here let's actually get to talking about the containers here now that we're really excited here and we can think about our sequence containers well here they are array Vector deck Ford list and list so what are sequence containers first and foremost because this is how you'll see them categorize is how you can talk about them or search for them on the internet if you need extra information but again these are containers where you're thinking about accessing each element one after the other meaning that you would say next item or plus plus to literally increment pre- or post increment to move an iterator to the next element or if you have Random Access just 0 1 two you know thinking about the actual index so you can see that they're all laid out in a line here as opposed to a tree or a graph type of data structure here and you'll also observe that this means that we have some that are contiguous and some that are linked data structures as we talked about at the start so some are back with an array and some with a list so array Vector deck list and forward list are the five sequence containers that we're going to take a look at here so let's go ahead and start with array I'm going to provide for all of our containers here a quick snapshot that we can see what's available and you can go to CPP reference or your favorite other documentation source to see these elements here but what I see here with an array again it's a generic data structure meaning there's going to be a particular type and we're going to actually set the size of an array at compile time again an array here stood array here's a type here's the number of elements that we'll have and here they are okay looks exactly or almost exactly like a built-in array that we talked about at the start of this talk and this is something that's new since C++ 11 this idea of having a standard array data type and again functionally it's exactly the same as a raw array so it's going to be stack allocated meaning we have this contiguous array or data structure we can't resize it if I say it's five elements it's going to be five elements as Illustrated on line 23 here but again we use it just exactly like an array here but we get some power with this abstraction here and again this is something that you might consider in your programming career sort of interesting that sometimes even if you have a very primitive structure you might want to add a little bit of abstraction for safety or improving your use case here but we can see that we have member functions like at versus just directly accessing the data at for instance will give us some bounds checking and I'll throw an exception if we would perhaps Say Hey I want to access this element at index 5,000 or something you know beyond what we have allocated uh so that's the idea here now there's other several uh several other useful member uh functions that are available again you can take a look at some of these in the documentation or here forgetting the first or the last element or the size and size itself is actually a really nice one to have if you've ever worked with raw arrays because sometimes you have to think about hm was it stack or Heap allocated well here we always know it's going to be on the stack and we can just see what the actual size is here there's also really other nice property of standard array because it is a container we know its type now what this means is when we pass arrays around in functions is they don't Decay to pointers or any other weird sort of stuff they are always standard arrays and we always know their size so again arrays a nice abstraction now looking at this from the container perspective here arrays again are static they're fixed at compile time we have random access and if we want to search them we can sort of run our favorite searching algorithms right if if it's not sorted we need to look through everything to see if an elements there if it is sorted maybe you can run a binary search or perhaps some other algorithm on it on a few other notes as mentioned again we know our length the interface is also because we get to choose similar to other data structures so as we're going to talk about other data structures or again containers the C++ way to talk about it uh we'll see these at front and so on as member functions so when I think about out if I want to swap this actual container maybe for something that does expand that's a nice uh an easier change to make so in general anywhere where you're using a raw array you probably want to just go ahead and start using a standard array if you're using C++ 11 or Beyond which I would recommend anyways okay so that's with an array let's talk about Vector which is perhaps one of the most popular data structures in C++ again we can see that it just takes in some sort of type here and it's got this allocator parameter here now usually we're happy with the default that's what we're going to see 99% of the time or more perhaps for some of you and that's what we're going to see in this presentation but this is a hint that we are allocating memory at runtime so that this is an expanding data uh data structure or an expanding container okay and similarly you'll see some of the member functions that we have available again you're going to see lots of repeats which is a good thing because we have a sort of common interface that we can use if we need to swap containers okay so let's go ahead and take a look at Vector here with some examples and again this is a dynamic array that's probably a better name for it so don't confuse it with a mathematical Vector if that's what you're thinking about things uh but the idea here is when I have a vector I can actually push in elements to the back of the vector and that's what's going to cause it to expand over time or I can also remove Elements by popping them from the back and then that will contract the data structure now regardless this remains a contiguous data structure that's how things are laid out in memory here but again it can expand or contract which is different from the array that we just talked about so this is a again resizable container so again this is sort of a more accurate view or visualization of the vector uh data structure here meaning that there's some pointer to memory that we've allocated on the Heap and then internally we're also keeping track of the size and as well the capacity the the capacity is the maximum number of elements that we can store in size is well how many elements that we've actually pushed back into our Vector so again that's some bookkeeping that's done by the implementation of standard Vector so let's go ahead and just just make sure we understand this before we move forward so let's say that I go ahead and push back um some value here like the value uh 99 and you know some value is inserted here oops and I'll actually update that to the five just so that matches our visualization here let's be clear here so if I rewind here for a second I have 1 2 99 1 and then I'm going to just push back five which add adds to the end because again I said that this data structure could resize now interestingly if we flip back and forth between these slides here you'll notice my Vector has grown quite a bit more than just pushing back the one integer five and that's because this has done what's called forcing uh an expansion or a reallocation of our Vector now again what's going back if we keep flipping back and forth size well we've of course added one more element here that's relatively clear but our capacity has actually doubled here or really there's some Factor here maybe it's 1.6 times larger maybe it's twice as big it doesn't really matter it's sort of implementation uh defined here but the point is if I put something on in the vector I'm likely to add something else later into the future so often times behind the scenes the vector will actually double it's kind of like when you go grocery shopping usually you buy food for more than just that day right you kind of decide well I'm going to need to eat in the future so you buy a few more groceries or a bigger uh size jar of something uh and that's the same idea with the vector because you're likely to do some operation again like add to it because it's expanding so in this way it makes it cheaper the next time we add an element because we can directly do that at index number five 6 7 until we need another expansion so that's that's the idea here now of course you might say well mik that was really wasteful so what if I truly only need five elements maybe you've measured maybe you know exactly what you need well then you can only shrink your vector and that'll make sure that you're given exactly or or relatively close to whatever your actual size is right this capacity it might choose a nice number like a power of two or something again that sort of implementation uh defined but let's go ahead and say that we're going to reduce this capacity to exactly the number of elements we have five in this case on that uh again is more efficient if space is more important to you so again these types of things have been thought about they've been implemented and you don't really have to make sure you get all your pointers right it's probably a fun exercise to implement your own Vector but again you know it's nice to have these tested data structures so what happens though if I want to insert 42 here but this time at another index I showed you push back but we do actually have an insert member function because that' be nice to be able to just arbitrarily insert data anywhere so this is something where we have to think about our containers and just understand exactly how they work for convenience and small programs this is great but again at scale we want to think about this so let's insert 42 here and what you're going to see has to happen is well I need to do that expansion again I need to effectively duplicate my vector and again maybe that's by some specific factor for the purpose of this visualization let's just say it happens to add one element and we have to copy one over to its index uh two over to its next spot 99 to the next spot Etc so that we leave that spot where we want to insert available and then we can construct or insert that object there in this case it's just an integer and then we need to free the previous memory and then make sure that our internal pointer inside of the vector which again the standard library takes care of for us points to the newly allocated memory where we've copied everything so that's what's going on if we want to insert at an arbitrary position in a vector so let's sort of compare and contrast this with what's going on with what we previously talked about if I just want to push something back I might have to have a reallocation and copy everything but in the average case most of the time I'm able to just put something in an empty position here and that's great if I want to insert at an arbitrary position that's not say the very end I'm going to have to copy that Vector again and move everything in uh a new position here so just something to consider with our usage of the vector data structure so in this way vectors are much more more flexible than arrays we have to be a little bit careful with our insertion operations on occasion but again this container is going to do the hard work for us because it's already been implemented and tested very well in the C++ standard library but again it's just useful to understand how this stuff works and you can query capacity and size and so on uh to again understand what's going on when you're inserting elements here now as an aside of course because C++ is a language that allows us to get a lot of performance out of our code we do have a handy function known as Reserve which allows us to just say hey I think I'm going to need six elements from the start and just Reserve that capacity right away and then you can do lots of uh insertions um or push backs rather without much cost here okay so there are some ways we can dig deeper and I just want you to know about those so when it comes to vectors again their Dynamic and their memory allocation we can have Random Access just like an array and if we want to search we might need to look through every element or maybe a binary search and so on now the vector is typically our default container for performance and flexibility so just keep that in mind as you're doing your development again depends on the problem you're trying to solve but vectors usually the goto all right and again as mentioned here were just the notes on on the little optimizations and ways to get performance again thinking about some of these operations like reserve or shrink to fit if memories are premium and uh again that's the idea now string which we're not going to talk about is effectively a vector uh that's handy for working with uh character types but again you might have a vector of bytes or something so again there's there's reasons to have these as separate data structures okay so let's talk about their deck which is something that you you might not realize as being used a lot behind the scenes but it's an interesting data structure and this is what's known as a double-ended uh Q so you can see a visualization of it up here meaning that we can grab the uh front elements or an insert there or the back of the queue and insert elements there as well so that's the idea of what a deck is or a double-ended q and it's interesting to note that they're not necessarily A uh data structure that's fully contiguous like the array or the vector we are seeing that is a linked data structures here and it is something that's linked set of arrays or nodes okay so that's the idea so let me give you a little bit more of an honest picture of what a deck looks like on a implementation again you could implement this several different ways but most likely what it's going to look like is your deck data structure is going to have some sort of mapping so if you want the zeroth element you're going to go to sort of the zeroth chunk that has something and map your way over to maybe some uh tinier array of maybe two or four or whatever the implementation decides uh is reasonable uh in those elements here so in this way we have this mapping that's very interesting so what does this mean for us as far as how a deck works well observe that we have these question marks which indicate empty uh we can actually insert at the front of the deck relatively quickly and the back of the deck so this almost solves one of the problems that we saw that was interesting with the vector where if I did insert at position zero I had to do this huge copy with the deck that's not so much of an issue because we can just insert an element uh at the very front or the very back uh with much less expense without having to copy the entire data structure we just have to update this I'm calling this a map here but it might itself be a vector that points us to the right uh small little chunk of data so that's the idea of a deck so we can see how decks used the innerface however is extending upon what we could do with the vector so again we'll see familiar member functions like push back but we've also got this push front here which is a operation that we could do in constant time now I will tell you what the deck in the middle of the deck we still have to be a little bit careful uh with our uh insertions but at the front and the back we can do quick insertions so again it's a resizing data structure we get the random access that we enjoyed previously and this search uh uh times stay the same based off if it's unsorted or uh sorted all right all right so let's look at a linked uh data structure here which is a list Now list itself uh again is similar to the deck but this time explicitly one element per one of those chunks here and in fact we don't need this additional if I go back here abstraction with the map here because we have nodes that just directly point to the next node so a list is usually implemented in C++ is a doubly link list meaning that you can insert quickly uh because it's a list data structure a new node here so whether you're pushing back to the end or inserting as long as you know exactly where you're inserting maybe you have an iterator you can insert to that location very quickly now if you've got a Traverse the list that is going to cost you say o of one time or o of end time excuse me because you do have to Traverse the list but in some cases you have the pointer available and you can do quick insertions otherwise so in that way it makes it a relatively uh flexible data structure in how it can be used and the other thing with lists the particularly standard list which is connected uh link list or doubly link list excuse me is that we can access the first note and the last note very very quickly because we often times have pointers available uh in the implementation that give us the front or the back of the list quickly so that's the idea with our list we can see a few different examples and there's other interesting operations we can do with lists as well as other containers like splicing them and moving one part of the list to another list so if you're doing these types of operations those are quite nice and there's also merge operations as well that are nice to use so the list itself is an expanding again data structure it's easy to create nodes and add other nodes on it um but we need to pay some cost if we need to Traverse it right we don't have that random access like we had with the vector now briefly I'll add a new uh data structure as far as uh is added in C++ 11 which is known as a forward list and you can see that this one's well a lot simpler in terms of How It's actually implemented it's just got a link going one way so again it's still a sequence here but we can only really add elements one at a time here so we can do this quickly by just creating a new node at the front of the list but we can't Traverse forwards or backwards So In This Way Forward list is just a very space efficient uh implementation of a list and with less power so it's a lightweight container that was added this is just a simple singly link list so the performance characteristics are going to be the same and it's going to be fast again if you have handles to each iterator that maybe you store or cash over time but otherwise you're going to have to pay the cost of traversing the list okay so with that said we've gone through the sequence containers here and I want to briefly uh talk about some of the gotas with these containers now in some ways I'm just going to post this I know it's a wall of text here um but there are a few things that are important with any of the containers um and worth knowing now that we know how few of the containers work just um considering when we're pushing back our containers own the data okay if you want to actually construct them sort of in place there's an in place function for that which might reduce copies so again you can revisit some of this stuff as performance becomes more important for removing data we do have to think about uh how this works a little bit now in C++ 20 we have erase and erase if which makes things easier but these data structures and containers want to work quickly so when we remove something sometimes there's little tricks to just move where the actual end iterator is uh and then we can call erase which will do the cleanup for us so keep that in mind now also be careful if you have other things like pointers um within your data structures uh when removing so that's just a note about that and generally speaking take advantage of the member functions were available okay so some other common gotas are this idea if you have other iterators and I've mentioned this idea a few times saying oh this can be really performant if you know have an iterator maybe somewhere in your data structure uh and in fact with lists it's less of a problem but I do want to highlight this problem that can occur with say vectors for instance if you have some data structure that's shared and this idea that maybe have some iterator pointing into a vector here at some position and the idea is let's go ahead and push back say element 7 here and immediately you should recall that we are going to have to add another node at the end of this data structure and that's going to force an expansion or resize here of say eight or whatever that new capacity is going to be but our iterator is still pointing to the old memory uh where this uh Vector uh the internal data used to live live here so we say that that iterator is invalid now so you do have to be careful if you're going to have an iterator that's going to last a long time and point to some data structure here and that's what's known as iterator validation okay now there's some other things that warrant probably their own talks on thread safety but you can kind of read through the notes here and just understand that it's safe to read from a container with multiple threads um generally speaking right we can have lots of threads reading uh from our containers of data uh we can write to different locations as long as they're truly different and accessed you know by one thread at a time but if we're simultaneously writing to the same location in our container well you're going to need to figure out some sort of locking mechanism or or way to do a uh a safe access without getting a data Race So by default you know there are some issues that we need to think about or some abstraction that you can add on these building blocks of the containers all right so here's also the C++ reference um take on various data structures and some of their tradeoffs as a review of what we've looked at okay now let's briefly talk about some of the container adapters and I'm not going to have to spend too much time on these now that we're actually familiar with the sequence containers but the idea is that these adapter sort of reduce or restrict how we are able to use some of the data structures so that's what an adapter is it's not something new that's implemented rather it's something built on top of say a deck a vector or a list that restricts how it's working and again I'll leave some of this for a perhaps data structures course but you've got a cue for instance a first in first out data structure first element that I push in will be the first element that gets popped out when I call the corresponding pop operation so you could imagine that we could keep track of people in a grocery line for instance with both a list or a vector type or a deck type for instance I mean these could be different ways for implementing cues behind the scenes and that's exactly what we get with a Q here if we look at the data structure the container by default is going to be a deck right that's something where we can quickly push and pop things off the front uh rather and push things on the back very quickly so a deck in a list actually are the two uh fundamental data structures or containers that we've looked at that we could use to implement a q here Vector actually wouldn't be a great choice uh because again removing from the front would be expensive and we'd have to shift things uh as we previously saw so that's what a q provides us and again if I go back notice that this list is much smaller right it's restricting how we use things so that we abide by this behavior that we want so it's actually a good thing that we have built in here so these adapters themselves um I'll briefly cover as we'll want to move on some other stuff here but again they're Dynamic right because the underlying data structure is a list or a deck which can resize okay and we really have to think about I mean some of these operations don't make sense like searching um you know that's not the uh interface that we actually want right we want this first in first out Behavior so that's with a Q with a stack again same idea except it's last in first out uh and we have a top in of a front operation because that's usually how we think of or visualize a stack uh and we don't necessarily want a stack and a queue to be so easily interchanged okay so we want a little bit of difference between those interfaces so if you try to use some of these template tricks or just Swap all of your cues for a stack you would want to think about it for a little bit so I think that's a good thing that not all the names actually match up I think that's a very um important thing to think about when you're designing um generic data structures and containers and so on um so this time you can actually use a vector though just thinking about what it's doing you know you're pushing things onto the back and able to remove from the back that sort of makes sense uh that a stack could be used okay they could also use a deck or a list as well and basically the same performance characteristics as a q now interestingly there are priority cues again uh similar interface to a cu but this time the elements are sorted in a way here and you can see this visualization here from fluent cpp.com which is very nice uh showing that you have the highest priority element on the top and then there's sort of this Heap like data structure behind the scenes that you could use to implement a priority Q so again Vector is actually going to be the default here but you are going to have to provide a custom comparator so that we know what is the greatest element if you're not not using a primitive or otherwise Library C++ type so what do I mean by that well here's a tiny example of a priority CU where you're pushing in some numbers 32 33 31 and if you pop them off it should come off 33 32 31 in uh greatest uh order descending downwards uh but if you create your own type which I've provided a link for a video of how to do that then you need to have some sort of comparator pass as a second argument here for the template so we know how to figure out which object is greater than or less than the others so that's the idea okay uh and finally in C++ 23 we get something known as a flat map now this is something that you might have available in your compiler depending on if you're on The Cutting Edge at the time of this recording in 2023 and these are new set of flat data structures there's four flat map flat set flat multimap flat multi set and so so on um but I'll go ahead and show you uh later on in this talk what a map is and what a unordered map is but C++ 23 we add in a flat map and this is a way to basically take a tree and flatten it so you get a contiguous or sequence like the data structures or the containers that we've been talking about before uh vector and array for example and be able to access the elements very very quickly because they're contiguous in memory uh which is a very good thing for performance so these uh data structures and I don't have an example for it uh quite yet here um so I'll actually uh remove that but the idea is uh because it's on the cutting edges we can get better performance if we're just sequentially looking through these elements here in order to understand this though I think we're going to have to look at map and unordered map which is well what's coming up in this next section here all right so let's get to associ of containers and unordered associ of containers so we can understand what's going on uh with that flat map and just some other ways to look at our containers here I'm going to talk about these two containers side by side specifically focusing on set map unordered set unordered map and the other two um we'll kind of understand I can summarize in a sentence effectively but the main thing to take away from these is that just observing the name one is going to consist of data that's unordered so again you can think about a library with perhaps no ordering of the books but we'll talk about a fast way uh a smart librarian that can still access book very quickly versus asso of containers which are actually ordered okay they don't have the word ordered in front of them but the underlying data inside of the container is in fact ordered so here's a visualization of each of them and on the left side I've got a standard set which is one of our associ of containers here and that consists of a set of unique unque keys so you won't see any duplicates here 2 5 4 7 9 8 and so on and they are in fact sort of ordered if I look through this tree here 2 four five 7 8 nine okay this actually looks like a binary tree right so I have some way to look at if I'm looking for the value five to say well is it greater than or uh less than seven it's less than is it greater than or less than four then I move this direction right so this sort of binary tree is the uh underlying um idea with these associative containers now on the right side in the unordered set I've got a hash table here so the way that this fundamentally works is you have a table here and you have a special what's known as a hash function that'll tell you where to look next so if I feed in this value five for instance I might pass it into a hash function that tells me which bucket or region to look in and let's go ahead and say we have a simple hash function here that just mods The Key by four because I have four buckets here uh just as an example and it tells me okay uh five mod four gives me a remainder of one so look in this bucket here and that's all the other values that have that same property and then I sort of just look through that small subset so interestingly what this allows us to do is get really fast lookup times for our um Keys here that we're looking for in this set here in fact both are pretty good this is log based uh search time here because we're doing this binary search but this is on the average case if we've got a good hash function uh constant time okay now constant time again might be a few steps and in fact if we have a few elements that keep falling in the same bucket that could be problematic but that's the idea here now that's the idea with a set we just have the keys directly but often times we might want the keys in some Associated value and that's what a map does again think about a phone book for instance you put in um and you can think about it either way whether you have someone's usually their name as as a key and then the value would be their phone number or you could actually have it the other way around because the phone numbers might be unique and then get that person's name uh but that's the idea here that now we have a node or some sort of struct here that has the key which is what we're going to well in the case of our associative containers sort by this key so again same sort of binary tree dog and then alphabetically cat would come before and pig would come after so whether you're moving left or right in this tree is how that works and then as you move through the keys then you can grab the associated value okay so there's some structure here or perhaps a pair of key and value now the same uh idea of key and value pairs holds true here with the unordered map but again uh we run through a hash function which is just a table to hopefully give us constant time lookup on this example over here on the right I've given you an example where well all of our keys are lining up to the same bucket so usually that's not so good and you can actually look through unordered map in the interface and look at what the bucket size is how many buckets you have and calculate the load factor and if you have too many things going the same bucket you want to sort of reorganize or think about that hash function again you can check out some of my uh videos on how to figure that out uh from scratch but again this is the fundamental way that things work okay so here we go um again uh just discussing that idea now as an aside here I give you the one sort of sentence description multi Set multimap uh and unordered multi set unordered multi map they don't really allow us anything super super interesting in the sense of what I want to talk about today other than that you can have multiple uh keys that are um you know that I'll sort of get organized here um so that's that's the idea with those all right so let's go ahead and look at our associa of containers and then we'll look at the unordered uh versions here briefly of set and map again set all keys are unique and in sorted order and you can kind of see the interface here I'll show you with an example but because behind the scenes we have some balanced tree that means that we're getting logarithmic performance here we've got to search through that tree but on the plus side these are sorted so if I wanted to access all the elements um or again look through a phone book for instance then as I add you know lots and lots of entries my actual access and search time is still just logarithmic versus linear in the the time that we are adding elements so that's very very powerful for us and we have that nice sort of Behavior now for maps we have again similar to set but a key and a value pairing so this allows us to not just have keys right we have Associated values uh with them so typically what this means if I draw your attention to this example is we'll have a pairing uh for our key and our value in the map so we need to specify when we create a map the key which in this case might be a string and the value also a string in this particular case and you might also use like a using or something uh using key equals stood string using value equals stood string just to get these things sort of straightened um in case you get confused on the ordering but that's just a suggestion but we can see how we have this uh new pair here cat that we can insert directly into our dictionary which is another name you might know map by okay so the unordered set and the unordered map are going to be largely similar but these unordered data structures come to us in C++ 11 which is a new uh thing uh that was a welcomed addition here so that we could get data structures that effectively give us on average constant time lookup here and constant time search and that's based off of having a good hash function that can tell us directly in some table well where exactly am I grabbing an element from okay and these data structures like um many of the ones we've looked at previously set map unordered set unordered map they're all Dynamic we can expand and add entries into them okay and then finally the unordered map as mentioned again a hashtable uh data structure very similar uh interface but this time we want to store pairs of entries and we can see again um that this is basically a dropin replacement for what we've done with the map but this time with unordered map so we're getting constant time on average um uh insertions access uh and search it's only on occasion where we have to resize perhaps if we add a lot of entries um that we will have some uh as that load Factor grows some performance penalty but again there's various tricks where you can set your initial bucket size and so on with these containers okay so some got you before we just wrap this up is um it's important to note that with the associ of containers you can just use at to read and see if you've got some value one thing that I've noticed with new uh programmers in my uh classes is the operator uh when you try to access something it's uh a read operation perhaps you might be ATT um attempting but if that key doesn't exist or that pair in the case of a map if it's a key and a value it'll actually create it so that's something you just have to keep in mind here so I like using at for a read operation and you might want to have some abstraction for like crate or something if you want just up to you but um that's just something to keep in mind okay so let's go ahead and wrap this up because we've looked at a lot of stuff here I mean we've done a full tour of the C++ container uh Library effectively there are some examples of course you can pause as you need uh to look through some of the code here but I hope that gives you an idea of some of the tradeoffs how these containers uh look behind the scenes and again choosing the right container is often something that can give you a big uh boost in your performance um or maybe just the ease in solving a problem right that's why some of the things like the container adapters actually exist all right folks so I'd like to thank uh the organizers of meeting C++ for allowing me to give this talk you for attending and hopefully you got a nice introduction to C++ painters and you know even if you had a little bit of knowledge maybe you learned some other cool tips and tricks uh or can point other colleagues who need a start here and containers to this talk all right folks thanks for your time and attention and again thank you meeting C++ 2023 for having me here I'll look forward to talking to you all uh soon in the discussions or in the comments or wherever this ends up posted all right take care folks