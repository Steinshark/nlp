so what this talk is about so first of all somebody told me that you're supposed to put up a link to your slides and then speak it out loud so this is tinyurl.com Dy meet CPP 2023 right it should open from the phone fine so now if I see you on your phone I will assume you're very intensely looking at your slides all right so um I appreciate you tired by like stay with me raise your hand if you at least in part write C++ for performance yeah so this looks like you know substantial percentage of the room like almost everybody we give up so much for performance like garbage collector is nice like it's slow but it's nice like we cannot check array accesses like everybody else panicking right core dumps I hate core dumps but all of those things are there for performance um and simd as a technology I appreciate don't know most of you don't know what it is is kind of the same way it gives you very serious performance improvements at the price of your comfort like hiring people is worse than C++ and C++ was already hard right all those things so uh raise your hand if you wrote any cimd this is much more than I expected this is very cool all right like please tell me afterwards what did you do but I suspect you didn't do this stuff because it's a bit weird that's not what usually people do we're going to do mcmp copy if set intersection and sort right so the thing is that algorithms are very different and I'm just going to explain algorithms this is kind of the closest you can get to a college course on algorithms except like on CD and dance in an hour so it tends to be pretty difficult if you can ask me questions and you you don't understand you can shout I will try to answer and if we don't make it through everything who cares like it's not a marathon I know what to come okay let's do mcmp so mcmp right two arrays can you see my corser Perfect Two arrays we need to compare them return like you know less equal greater is there a C+ plus standard algorithm we could use if we wanted to write this ourselves there are two I know of anybody stood equal not quite because it justs your bull there are two what how would you implement St equal internally with which algorithm mismatch yes that's one the other one is C++ 21 it's called lexic graphical compare freeway so now you know all right so what we talking talk about mismatch and mismatch at least in code will do something like this so you take a bite from each array and you compare them one after another right then you look at this and like can you make this faster who can make this faster okay yo so eight bytes at a time you can do eight bytes at a time exactly I'm going to assume that's what you said like all right so you could do eight bytes at a time right and Theory comparing eight bytes should be the same instruction as comparing like one well almost the same instruction as comparing one bytes except you do eight times the number of Els right okay there are a couple of like nasty things about it like your pointers are not aligned you have to do unaligned loads uh there is like a tail there that is annoying that is less than eight by the way in C++ it's a bit small but you do unaligned loads with M CPI okay you copy from the pointer to the integer and will do the right thing all right who thinks that if this was beneficial compiler would do it for you five six I don't know like very few people ah you don't trust me very much and don't trust your compiler you're correct everybody else the compiler doesn't do it for you so this is stand that mismatch for chars this is whatever I wrote within 64s does anybody like there are two reasons why compila didn't do it none of them good and can guess okay yo I didn't quite hear the uh I don't think so because you don't write so the answer was alas sync I don't think so because you don't write anything anywhere so it shouldn't be a problem anybody else okay so think about this like the way that Mis much would be written it would be written while we don't reach the end end right or while we didn't find the mismatch so it's not quite equivalent to loading eight bytes at a time because it may be possible that you just said I have a million elements but you interrupted the second one and that's it right and you don't actually have the million elements the mismatch has more guarantees as a standard Library function so they could do it that's the first reason and second reason there is not a way to do it like there is function called SN CMP right which has exactly the same properties like you compare strings until certain size and that function is vectorized I'm not going to explain how you can ask me afterwards but so the compiler could do it even in this restrictions anyways this is standard mcmp and standard mcmp yeah you practically cannot see it somewhere it's 32 times faster more than 32 times faster than our standard mismatch right and it's about four point something times faster than in 64s and uh why it's actually not not that smart there are smart people wrote this and I did some really clever things but for most part uh they do the same thing we did within 64s only they know that on my machine you can use 32 byte registers and that way you get 32 times speed up right cool so what we're going to do today is we're going to learn how to write this kind of code right uh okay so ah uh I didn't mentioned so this techniques where you use one instruction to process multiple pieces of data is called syn instruction multiple data that is simd right and this big registers that are specifically designed for it are called simd registers we're going to access them through e Library there are many different ways um it's a library it's on GitHub it's boost licensed it's developed by J Fu Jean La Prest and me however like we don't care really about the library today right if you want to learn about the library there's a talk online called simd and C++ 20 if of a new era right uh and we we just care about algorithms anything that generates you see the algorithm should do something like that and in the library there is a if algo mismatch which ideally should do what um what we wanted here let's see how it performs so this is n64s this is standard mcmp and this is if Alis much is a little bit slower than MIM CMP um like because they write specifically mcmp they did more tricks that uh I didn't do here however uh this is x86 on M1 uh if Miss much beating standard mcmp substantially on this Benchmark and I know why and I'm super proud of that I can tell you afterwards if you want to know all right so kind of like seems like if Miss if Mis much is the correct thing right I mentioned a little bit like on this machine on that machine thing is that when you compile something you have default Target right you compile for some like fairly old computer right to in order to run your binary everywhere and that old computer doesn't really have all the SD ition you would like to use so in order to take full advantage of SD you need to compile your code correctly I'm not going to explain how I'm just going to show you it's important right so uh this is um eal Mis match without just all free and this is compiled correctly for that machine and it's a 2X difference right so both of them beat in 64 because we know more about that default machine but still okay so let's look inside mismatch uh and inside the if Mis much you'll find F diff with the zip which is very cool we're really proud of that even the Rangers libraries it took insane amount of effort to make this work but that's not quite helpful as far as algorithm is concerned so let's assume that we're going to write this by hand so okay uh can you somewhat see it all right COC so what we we're writing here is this code that will compare two really big registers right so first we need we so we accept two pointers right uh this is where we're going to take our really big registers from and first we need a type for a register in if this is called if wide right and so this on my machine will be 32 byte register okay um I'm going to load a 32 by register from both pointers right this is our starting to compare those 32 mites then we're going to compare them for equality so in many SD libraries even included operator equal not equal are overloaded to return you not just one Boolean but like a bunch of booleans so here we return the special type logical and this is like 32 Boolean values does it make sense cool right and then we call something think called first true which will compute the position so okay um let's have a look at example right so 0 1 2 3 0 923 right the second element with index one is true right in this case first true will return us one right if there was nothing there it will return us a null opt cool all right so uh most of the time we will not find anything like imagine you mis much you go and you compare they all equal you go to the next one compare they all equal right so in this case there is no much and we just go to the next register otherwise we need to compute like Okay so this was one so we will adjust to the place where they mismatched and return that okay there was a mismatch I'll give you a second to look at this in case you can uh you can ask me a question if you want to perfect I will assume not everybody's asleep does much H does much is much is a bitfield m much is optional uh PT optional integer right so if you have a position like let's have a look at how first through works I will show that in a second okay but hopefully if this question still stands please do ask me so I'm going to explain how first through is implemented under the hood because it's kind of important for understanding how SD Works um there's a caveat that SV there's rmsv very fancy new extensions those are very different and there F to doesn't work like this okay so this is our logical logical is usually some special CD register right representing 32 Bulls in our case and we want the first position position of the first true which is this right okay so on many platforms uh there is a special instruction that says any are there any truth at all right and if there uh and this is our null opt case right we can check oh was there a much no go to the next 32 B uh otherwise what we do is we construct something in if we call Top bits so this is a simd register and this is an integer right where uh it's a bit mask where each each integer represents kind of like uh true or false by bit hopefully makes sense the only caveat is that to be efficient it's not always one bit but we pretend on the interface that it is one bit right sometimes there be two or four but all right so if this is an integer and this is an element you want position of the element you want how do I get it quiz anybody sorry Pop count is the number of set but you are very close this SC forward in Stand C++ standard it's called count trailing zeros right so uh this is little Indian integer this is like so this is a first zero this is the second zero this is like so we want to count that this is standard count trailing zeros we know at least about this okay so um okay uh all right so yeah um and I'm just I'm just going to show you this for for the sake of the code um just so so this is the assembly that function compiled to let me make this quick bigger I know right and so this is top bits construction like this function um so on e86 there isn't really any that we use so we just always construct top bits with this this together becomes an any um well this together becomes an any right and this is bit scan for what we talk about so this is like the whole first through becomes like free instructions if you didn't understand this is fine it's just showing Co instructions okay there is a standard proposal that you may be heard of of standard Sim so let's have a look how what we do in if compares to what they do they have different philosophy but you can algorithms will will map fairly well so what we call wide they call Standard SD what we call load they have a method called copy from what how logical they called standard CD mask they have the same not equal operator and finally what we call first through they split into two functions one is called any of the other is called reduce mean Index right and it requires that any office CH so they split office I'm perfectly fine with this except I think that reduc mean index is a completely awful name all right so if this kind of mismatch happens um mCP kind of makes sense this we're going to go to copy if unless you want to ask me about mcmp like how it tails is completely outside of the scope for this I'm happy to talk about that all right um so copy if right like the first time I heard about copy if it kind of like completely buffed me because copy makes sense like you take a big register you load your store right how do you copy if there is this notion of um compress in CD programming right uh it kind of looks like this so you have a register and you have a musk and then you take all the selected elements and you kind of push them to the front so the reason I call this notion of compress and not like a compress function is because sometimes this is horribly inefficient right to do exactly this so instead in if we have a bunch of different functions that all have the word compress in the name and um that you use for different scenarios where would you you would use this instead uh the one we want here is something called compressed copy so I have an input array a musk and an output array and now what I do is I take the selected elements and write them together to the output and then it will return where it stopped so if you had this function who thinks they can write a copy if okay I have a few hands right now think about it you load the register you you test it okay you get the predicate and you do compress copy okay uh there are a bunch of variations to compress copy one important one is safe unsafe so what unsafe says is that it can write a little bit of garbage on the end right so basically it's going to like move elements in your register around and then it really wants to write the whole register which means that there is some elements that were not selected written to the end the second variation is sparse dense basically do you expect a lot of matches or not um yeah like sometimes you want like just one element per register or something or two on average all right let's talk for a second about the interface of copy if so this is the interface of standard copy if first last output return and output iterator does anybody see a problem for us I'll highlight it so the output iterator means that you don't know how much space you have which means you can never use unsafe compressed copy you always have to do safe and that is very slow right so uh in Eve everything is ranges based and then there's like you know input range output range and now I know I can write the whole output range and I can use unsafe compress like there is a little bit of a check because of this for safety now which obviously we all hate I'm working really hard to remove the last safety check from there no worries all right there's a bit of a problem right so imagine you have a million elements and you copy them into an array of two elements right like okay you would expect that at some point you fill in the two elements and then you would like to stop right so it will stop but you want to do something with those two elements and continue so you would like to know where did you stop in the first array unfortunately I couldn't make that work like just just this is just hard so for now just no luck by the way I talked to Bryce about this uh at some point Bryce liba who led the parallel uh thinking the standard committee because they have standard ands now and I looked at that I'm like how are you doing standard ands and the idea there is standard Tek is allowed to allocate so what it would do is it would allocate you a buffer copy if there and then you copy to the output you know not amazing but it will give you some speed UPS all right let's talk about how compressed copy is implemented there are two versions in E Library fundamentally one is sort of pure CD where we just throw a bunch of like complicated SD instructions in it and this is way too much to explain here so I'll just give some main points right uh so on some very fancy platforms you have instructions so IX 512 some have SP have some um our main implementation is based on the work of the teof flower user acit um with really tiny lookup tables uh if you have BMI 2 and it's well implemented Peter cardz proposed a really good solutions that we use does anybody know Peter cardz by the way like the name on St overflow like he answers yeah I see one hand Peter two Perfect Peter cardz is amazing person who answers like every xh6 question on stack Overflow it's insane uh and finally uh there's a switch and Shuffle solution uh proposed by zason we use a different switch and Shuffle solution but we still acknowledge has contribution all right the second uh implementation I will explain here and it's SD scaler this works remarkably well for sparse output when you have like very few mat we have the input we have the register we have the mask let's construct our top bits and let's effectively do first through right so count trailing zeros and then we copy the first selected okay now the clear the last selected bit do another first through do another copy so this is a loop where we go through all the selected elements using count trailing zeros if you have one or two mattress this is very good I'll show you in a second uh so this is independently what proposed by Peter cardz and AR all right benchmarks uh so this is standard copy if Benchmark no elements are copied all of the elements are copied half the elements are copied okay this is a sparse uh so this is the second one that I show you CD scaler uh which has bit scans and you can see that it performs really well when you have very few matches so in 5% for example it will give me here three and a half times speed up compared to the Scala Baseline right same computer same machine three and a half times speed up of copy and this is a bmi2 cdcd solution it you see it performs very well everywhere and it gives me like whatever um three times speed up here question looking at this graph of just standard copy if do you you see anything weird okay yeah you copy more but give me a second if you copy if what will be the worst case you copy zero elements half the elements all the elements half right but here is not half here it is half right so this is shorts basically what happens with with shorts I have twice as many elements in the same size and my processor can no longer remember all the branches so the branch predictor starts messing it up right and when the branches Branch mispredict happen the Sim diversion gives you more than 10 x speed up because it doesn't really have any branches all right this this M1 on M1 The Spar uh didn't really work but the SD SD solution gives me what uh four times speed up and this is M1 shorts I just thought it's really cute that it draws an m on M1 all right so what about the CD proposal well they have this function called uh compress right I explains that it's kind of not ideal for some platforms so they think that they maybe can be able to optimize some of this stuff but the worst case scenario is basically you will have to know whether or not you can use compress by the time you get this the processor will be much faster much better much newer so hopefully you will more you will have compress actually shipping okay actually how we doing on time let's do sort first sort is like qes and set intersection does anybody have a question about copy if I can answer that size of the elements you copying what do I mean like ins versus shorts versus so that's a very good question uh generally speaking with simd um like the size the the performance depends on the register size uh so if you have let's say 16 bytes you can put there four integers or eight shorts generally speaking it means that uh the speed up for shorts will be twice as big because you can do eight shorts at a time and not and four Ins at time uh for specifically copy if uh you will end up in a situation of for chars you cannot do 32 times you can do only 16 times like was the way I wrote it on my machine Okay cool so let's do sort unfortunately I did not Implement sort like it is I haven't gotten there yet it's a lot of work but other people did here everything I read on the subject I'm not going to name everybody but I'm going to name like specific people I take explicitly from all right the key building block to sorting an array is to be able to sort one register uh the first time I saw this idea uh came from like a Blog called a question of sorts uh by seven degrees of freedom which I thought was keute um and this kind of how it works I'm going to explain how you sort two elements and then I'm going to say and then and we sort the register okay all right so this is my register it's not sorted and five frame step one I'm going to shuffle the elements around like Shuffle is a operation where you take the elements in your register and you move them around here I'm just swapping adjacent elements so I have five free became free5 now I'm going to do Min and Max Min and Max are both ver like between two registers right you take element from here element from here Min element from here element from here Min countes fre fre 5 five make sense cool oh sorry and then I'm going to do something known as a blend where I take it's a mixing of two registers together here I take one element from here one element from here this way I got the register sort two elements register and it turns out that shuffle minmax and blend are enough to sort any CMG register it's just a bit again too much to explain here um if you want to know how to do it there are a couple of keyword words you want to look for so sorting networks and specifically everybody use bonic sort this one I have implementation of and I still don't understand it like it's very confusing it is it is so non non obvious all right but works well okay so now who can say me there are three functions that build up a quick sort who can name them like partition it's the second one in my my list so I'm not going to show it yet P selection partition and the third one no insertion sword so quick sort doesn't make sense Beyond certain sides so when they go to like 16 elements or something they do insertion sort every implementation does something like that so okay this last one uh let's see how we can build all of those right so this last one is fairly simple so what if we partition up to a register size and then we sort the register right and then you have like small sorted component of like eight elements and then you sort the eight elements the whole register sort make sense cool let's talk about P selection is there a way that somebody sees that you can use sorting over register to help you with pavot selection you need one pavot to be clear okay somebody name me p p algorithm something first element fantastic doesn't help sort here like but anything else well these new random element right but most of them are like medium of three medium of five like so medium five is a different one but you select some number of elements you select the medium between them right and you can do selecting the medium with Sim Dort so let's see how that look this code I took from x86 s ort Library um like the top contributor seems to be raak develop um very sorry if he's not actually the most important contributor but he was seems like the most commit at the time I looked all right so this is what they do in uh Intel so they select elements with equal step right through the array then they do something called gazer where they load all of those elements together into one simd register and finally they sort and this is your medium value I want to talk about this gazer thingy if if what I'm sorry yeah I want to talk about gazer the first time I saw gazer I was like this is the answer to all of my problems I'm going to write just everything with Gaza it seems like super powerful instruction the problem is it's slow and there's no magic to it right it's is either there is an instruction or they do one by one into array and then load that there's nothing there and um basically regardless of how it's implemented you have to do the loads right well whatever you can do two loads at the same time on xh6 right so you will have to do that those loads no Grace but here I I had never been able to use gazer to speed up anything so far I know some other people have um but here it pivot is kind of not the most computationally expensive so it's fine all right so now partition partition is tricky uh I take this from uh sorry all I take this from this goes to 11 block by uh Dan uh Shor I believe uh his nickname is damage boys that's easier to Google all right this what they do so um let's take a register from each side of our array and just throw them away somewhere like we're just going to store them on a stack whatever we just want some space we don't care about the values now we're going to take take an a register um we're going to load it and we're going to sort it and then using first through we can find the first position where the pivot would fit right you compare everything about the P you you find first true so this way we just partitioned a register right everything here is less than P everything here is greater than P now to be clear this is not in amazing way to partition register on many platforms you can do some compress like tricks to do partition but for the general purpose of something really weak that can be not bad all right now what we do is we take this partition register and this is our space like so this is two registers wor of space this one register worth of space let's write it into both sides and then we're just going to say everything be before this is sorted uh partitioned everything after here is partitioned as well and this is uh whatever this is free space this is free space so we can try to continue algorithm by selecting a register here because what what will happen um we have enough space for register here we will have enough space for register here all right have a think for a sec because I know this this is this is probably the most difficult one like you have a space you sort the register you put in two sides boom you have some partitioned you will have enough space if you load the register from one of the sites okay if you kind of didn't understand at this point it's fine um so uh yeah I don't have the benchmarks I don't have this implemented but just some numbers say 10 x some num say 17x I don't know like the measuring sort is notoriously hard but clearly there is something there uh I think the Intel s disort is now in numai all so how are we doing 30 20 we we'll we can do like most of set intersection tell me when it's five so we can take the questions or whatever all right we might not do the numbers but we can do so all right so and turns out during my practice runs that not everybody is very intimately familiar with all the standard algorithms and they cannot tell me out of the box what that intersection is it's all I have to explain so set intersection is one of the merge algorithms it take two arrays and do merge like thingy specifically it looks for equal element so you take element from here equal element from here compare them and the smallest one at once when you find the equal element you write that to the output all right um if you have that can be duplicates like it's just AR race sorted AR Ras but duplicates are allowed the standard defines very well what happens with duplicates we will not uh we'll just relax that requirement so and then you go further and finally get uh the second one all right so there are two implementations of set intersection uh one is simd scaler look look something like this so you have the first array and ideally it should be smaller array than the second one and you have a second array now what we will do is we'll take one element from the first array and we'll take a register from the second array right and then what I will do is I will take this element and write it into every element of this register this is sometimes known as broadcast because I wrote One value into everything and then we compare this register against this register so think about it like in this scaler version you compare element against element right here we kind of been optimistic we will compare one element what if we compare it against first second third boom right all of them and then maybe if all of them are less we can just Advance right by the register size and if not all of them well let's test for equality and then we will test one against many for equality right if the if if equality is true we have to copy to the output boom we found the intersection and we advance the first element array okay I see some nodding I really appreciate you nodding this is really nice all right the second one is harder uh it's from this paper faster than native alternative for 66 vp2 intersect instructions uh by G Mia scaners kind of looks like this we have two arrays and this time we kind of don't care if they're the same size or not it's fine what we do is we take a register from each of the arrays and then we do really expensive operation called has equal in which Compares each element from the first register for equality against each element of the second register and then what we do is we do compress copy so what that did US is uh basically we intersected the two registers now we need to advance how can we advance well okay let's look at this element like the last element in the first register and let's try to find it in the first uh in the second register right so any matches for things after it uh cannot be here that's for sure so we can advance f to here right because anything here cannot be matched to anything here same thing we do in Reverse so for take this element look in the other uhhuh okay that's not a question yeah it's a bit tricky thing about this what is really nice is that even if you have very intersected arrays you guaranteed to advance quite a bit if you don't have duplicates you can try to prove that you Advanced by a lot but okay let's talk about has equal in so it's actually like there there was the alternative to vp2 intersection stru there's an instruction to do it on like6 but we I don't have it and in the papers they don't suggest to do it they suggest to do very silly thing so you have first register and you have a second register okay let's compare them against this and then let's rotate this register so that way I can compare against you know against the first element against the second element and against all four elements like each one this seems like a lot right like just just whatever instructions but think about it so this is not always a rotate to be optimal but it's always one instruction right almost like as good as it gets right uh so this is equality and this is um or like ideally this is port five this like you know whatever part Zero part one so in theory if everything works out you can do three of those in one cycle which is like which means that you should do like the number of Cycles you have in the register Elements which is pretty good in fact in the paper because they target like really fancy instructions they merge these two into one instruction by being really clever okay so how we do 10 minutes let's do set let's do benchmarks 20 how it was 20 20 minutes all right so um this is a set intersection Benchmark like just standard one on the left uh it intersects small array with a big array right so this is 5% of all elements 95% of the elements here is half and half the number of elements stays constant the dist the difference is Branch prediction right now this is um uh let's uh do this one so this is a simd simd version right so SD SD version is um about one and a half times better on the left and whatever four point something times faster on the right and the simd scaler version which was really simple is actually ridiculously good this is 20 times speed up on the left right almost 20 like whatever crazy and this is again even in the situation where I would not expect a good speed up where there say same size it still gives me like four and a half which is also very nice um okay this is M1 on M1 the SD SD approach didn't work but the SD scal approach still gives us a really good speed up this is 10x right this is two and a half all right uh in defense of the people wrote the paper right so I'm Target on M1 we have a 16 by CD register on x86 this6 I have a 32 by SD register you can see that here it performs relatively better I suspect this is a dependency that the bigger register size you have the better the sdcd approach would perform they target 64 bit byte registers so they should maybe have another layer of speed up over this okay all right do you have questions about sort s section or sort it's also Co no all right uh so I really appreciate people who work with me so Z Falco and jant la like they work with me on the Eve Library uh and all the amazing people who share their research online and I can look at it and finally you can find the library uh on G Hub uh you can find the slides again tinyurl.com Dy mecpp 2023 uh I did a similar talk with different algorithms called my first simd I cover Sten um find uh reduce in in inclusive scan and remove um and uh there's a talk about the library CD and C++ 20 if of a new era and finally on slack on CPP L slack who is on CP L slack I see one person you should be on CPP lenss log it's a just type CPP lenss log into Google and we'll find it like it's a really cool place uh they have a simd channel which is very low volume with very smart people who will answer things and you know low volume until I'm renting but so that's it for me if you have any questions I'm happy to answer [Applause] one question to more system architecture rather than now the software side if I would use simd operations M on a hyperthreaded hardware would this become uh a shared resource then because I probably only have one simd per core or po per CPU so my my hypothesis would be disabling hyperthreading would remove like the shared resource of the simd so uh I can I can try to answer that to the best of my understanding of this caveats applied that not the really Hardware Hardware expert all right so with Hyper so your CPU core can do four instructions per CYO right uh like if you have really fancy maybe more like I I just always count as four so uh if you can do for instruction you can do like two editions right two SD editions or uh whatever one Shuffle right how much do hyper threads fight for those resources I would not expect that to be any different from scaler curve right people definitely use hyperring or not use hyperring but all depends on whether or not they can get up to 3 point something something instructions per per core in something like a compression yes you can like smart people wrote really good compressions or encodings right they will get to up to four and their hyping will be a disaster something which is memory bound hyping is life saer like so I would not expect any uh simply specific issues here okay thank you um how did the cach sizes on your machines compared to your testing data set for your benchmarks everything fits into that for okay did you do any benchmarks with memory bound data uh for for n for this no like so it is true the the the thing is that um the simd code has this problem which is basically it's not really problem but you do whatever with regular code you do eight bytes at a time here you do 32 bytes at a time right you exhaust your cash much faster buer uh so um there actually there's a paper by Alexander stepanov where what they do is they do some really fancy compression I didn't read the paper I just read the up star but they did real fancy compression to kind of trade off compute for just speed of loading data from memory right but just it's not that you couldn't predict a cach misses just couldn't load data fast enough um yeah so uh it is true that sometimes you will be Memory bound and seemd will not help here like I don't know but as far as benchmarking goes it's also I'm trying to Benchmark an algorithm and everything else is kind of additive to that so yeah I don't I don't think that would give me much soorry okay regarding multicore and simd instructions do you have any experience with the frequency scaling implications of simd instructions he it's a question about frequency scaling that's that's Som like a remarkable thing that everybody of okay let me tell about frequency scaling if we have time um so your CPU have something known as power I learned this last week I'm repeating what I heard uh the your CPU has something know as power license right uh on x86 on AMD you have just I don't know if they have power license they don't have this issue uh and I don't know anything about that so you you you have a power license power license goes like uh normal integ operations as float operations and that includes uh IX uh 32 by uh integer operations and then you go 62 by float operations 64 by 62 by float operations and 64 byte integer operations and then you go into 64 by FL operations what doesn't matter point is that um by default you run at of normal floats uh so 16 byte floats 32 byte um uh in right everything here is 32 by ins we would not have experienced any issues unless you have high frequency Trader and you do something very clever that I don't know like so all of your standard SD functions like standard lipy functions will be so if you call sterland it will be C2 by like just well um right so when you switch what happens so you your CPU cannot just run those instructions it has to switch the power l license and there's a protocol so it has to request a new power license while it request it runs at really low frequency gets the Restriction pops up to the new frequency right runs for a bit there then it will uh like um then you know after while you don't execute those fancy instructions you'll be like okay maybe I can switch back so it drops again requests a power license and comes back up that was at least the story for for a while I don't know maybe they say that the new intels are better at this than they they they used to be uh all right so basically what happens you use one instruction that just kind of didn't matter and then all of a sudden your CPU frequency drops that's one of the big problems with 64 byte instructions on top of other things so generally speaking as as a rule of thumb you want to use 64 bytes on x86 only for really big compan computations right like again caveat here not I never worked at Intel I like don't necessarily know everything okay uh you mentioned something about uh making sure to compile the code correctly yeah would you be able to elaborate a bit on that uh so well the the 64-bit one would be the one so there is a in even it's a complete mess I'll fix that but uh generally speaking there is a flag that you pass uh to both tocc and Clank I don't remember but you can control the simd wids so it doesn't go to 64 bit because by default um something like you know transform transform right or transform reduce will be autov vectorized and sometimes I see Z vectorized with 64bit instruction so maybe compile introduces that problem for you as a flag uh you want to compile with a specific architecture in mind so just March it's very good for somebody like me who has a server right and I just compile for that servers or like whatever I have three different servers and was also compiled it's bad for um people who have to ship code to people right like I he I talk to I don't remember his name is a Game Dev person okay uh so and he says that you know that people really complain but they have like we we old processors with some really really fancy gpus like and they really expect the game to run very well um so what what they do instead there is they do Dynamic Dispatch they try to determine at run time which instruction you have or which instruction you have and then they select uh with something like if this is fairly hard to do the our suggested solution and that Solution that's popular in this indust is you do DLS so you take your kernels or whatever was expensive things you put them into some special thing you compile that as DLS uh and then at run time you load the corre one uh in if Library there is an example of how to do that with cake uh that's my kind of for General answer but just March cool thank you