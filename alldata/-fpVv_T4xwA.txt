we looked quite a while ago now a younger version of myself looked at modes of operation which is how we combine a block Cipher like AES into a workable encryption scheme that we can use let's say for internet traffic and actually the most prevalent form of authentication online now is as GCM which is as in galwa counter mode now we mentioned galwa counter mode very briefly in passing but I thought given how important it is and how much we use it like you know if you're looking at a video now a likelihood is it's encrypted using asgc maybe it's worth asking you know what is that right and why is it useful let's look very briefly back at counter mode which is how we use AES to encrypt a stream and then we can show what's wrong with it and what galar counter mode adds to that you've got a block Cipher that encrypts um 128 bits at a time that a lot of block ciphers do this they have different block lengths but as is 128 bits if you want to use as on anything that isn't 128 bits you're going to need to pad to a multiple of block length and you're going to need to have some kind of scheme that you can use to apply it multiple times and there are as we've seen in the previous video there are good ways to do this and there are very bad ways to do this right so let's just very quickly recap counter mode because we're going to extend that into gallar counter mode we've got our encryption using our block Cipher so this is our encryption using key K and we might have multiple blocks encrypted this way now your first thought will be be well let's just put the plain text in here and get out the cipher text but that's ECB mode and that's very weak counter mode uses a an initializer a random initializer to make sure that your encryption stream is different every time so we'll call that n right so our number used once or our Nots right and that's used to make sure that the encryption scheme is different every time and we have to absolutely make sure that you don't use the same pair K and N again what you do is you start off your encryption by saying Okay so this is n + not and this is n + 1 and n + 2 all the way along your stream and what you're essentially doing is actually not encrypting your message at all you're encrypting this counter right this random and this counter and that produces a string of random NS and on so n one one n n n one one One n one n right for 128 bits and as is very very good so even if you put in a very let's say your your n is zero and you just you'll get a very very different output here than you will here and here and so on it looks very very random and that's very helpful and then actually for encryption we're going to use good old exor so we're going to say okay here's our message message one this is going to come in here we're going to exor it with this and that gives us our Cipher text one and we're going to do the same thing so message two Cipher text two and then uh M3 I could have done two blocks and it would have been quicker C3 so this is to find scheme right because what this does if these counters if this n is random right we're not going to be able to predict what they are the K is a secret so this essentially this key stream here these zeros and ones here here and here are also a secret which means that the encryption using xor here is a secret and so you can look at C1 C2 and C3 but have no idea how to get back to M1 M2 and M3 and this is also quite fast you can parallelize it and things like this the problem is that it has this issue that stream all stream ciphers have because this is converting as into a stream Cipher that it's not protecting the cipher text and what does that mean well it means that if if you think about how the decryption would work here we're actually going to reverse these arrows so we're still going to produce the exact same keyst stream it's just we're going to put the cipher text in and get out the message the EXO reverses its effect a second time so that means that suppose I change some of the bits as an attacker in C2 those exact corresponding bits are going to flip in M2 because of the way the EXO works and so even though I couldn't read this message I could affect it and it's very difficult to tell that that's happened it might be that your message no longer makes sense but it might be that the recipient of the bank bank transaction is now changed to me right and that's great for me but not for anyone else what we need to do and what I mentioned in the previous video is we need to add something here that computes some kind of check sum or other cryptographic tag of some description that says you can check against this and say okay these haven't been changed they're secret we know that and they haven't been changed and then you've got the best of both Both Worlds you've got something that you can't read and something you can't manipulate so this is what gallar counter mode does when you see as GCM that's the advanced encryption standard in galar counter mode what you're actually saying is we're using ases to perform this encryption but we're using counter mode and we're calculating this galr mathematics across the cipher text to make sure that they also haven't been changed and that's what we're going to talk about now just think sort of a sort of high level what we're trying to do here what we want to do is have some kind of tag which I'm going to draw in a box here right and this tag needs to summarize all of this so that if any of this gets changed when you recreate this process during encryption your tag is going to be different to this tag and you can go whoa stop there right someone's been fidling about that's the idea this is an authenticated encryption scheme and so the idea is that when you decrypt so when you encrypt you create this tag at the same time you're encrypting when you decrypt you're going to check against this tag and make sure that it hasn't been changed and that's part of the process if you actually use this in a library they often raise an exception if a tag has been changed in any way right so what do we need to make sure hasn't been changed well is it the plain text not really because the plain text is not being sent to the recipient so they can't recompute the tag I suppose they could decrypt it and check but it's easier given that a plain text and a cipher text are inherently related just to authenticate the cipher text let's draw in Orange um the bits we want to authenticate so we want to authenticate the cipher text we also really don't want people fiddling around with this number used once either so ideally we would we would authenticate this number used once and that way the encryption key is already known actually to both parties so we don't need to authenticate that although that's sort of implicit in this system the other thing you might want to authenticate is the length of the message because the length tells you that you know you haven't accidentally removed this one or inserted some some more data or something like this and so this is what we're doing as well the way the as GCM is going to work is it's first going to calculate what we call our um our authentication key or our hash key right so this is going to be used in Computing this T based on these right and we call this H so what we're going to do is we're going to take 128 zeros so 0 0 0 128 times I've run out of paper right and we're going to encrypt that using as and that's going to give us H okay and you can ignore this Arrow because it's got nothing to do with it right now that hash key is a secret it's it's deterministically generated from our encryption key because it's just encrypting all zeros but remember as is very good so when you encrypt all zeros you're un likely to get all zeros back again you're going to get something random looking so we've got a random looking string of 128 zeros and ones then what we're going to do is we're going to take our first counter um and so actually I need to change my indices now right because I've totally messed them up and you've already noticed that this doesn't match this right so let's say this is counter one this is two this is three right and we'll pretend that didn't happen what we're going to do is we're going to take n plus KN we're going to put this through our encryption scheme and then we're going to pass it down over here and we're going to join this in at the end right over here like this it's going to be used on our tag okay and what that's going to do is protect this secret H from being recomputed within here right now what we're going to do now is for each Cipher text we're going to add it to our existing tag which coming in is zero and then we're going to multiply it by H now you might think how do you multiply two 128 bit numbers together well actually the answer is you do it in what we call a Gwar field right so this is some finite field arithmetic which maybe we can throw into some extra bits but in essence it's very similar to the mathematics of as it's just the 128bit version instead of the 8 bit version which we were seeing in AES in essence you treat these values as polinomial so you know x s + one multiply them together and then you reduce them and so whenever you multiply this by this or this by this you will get another 128bit value which sort of looks a bit random it's kind of like a modul mod it's very much like modular it's just slightly more complicated than just a remainder after division when you when you have integers but it's very very similar in terms of the way that it works so what we do is we take this uh Cipher text we're going to multiply and I'm going to use the confusing X symbol for multiplication which is not the same as xor it's rotated and we're going to put H in here right like this and then we're going to take this and we're going to I've realized I've not left myself enough room but we'll make it work so we're going to EXO this in here and then this is going to be multiplied by H and then it sort of works it's not very elegant is it if you look online they have much NE to diagrams but they've done in vector graphics and everything uh so and then this this comes out here and it goes in here and it's going to be multiplied by H so what are we doing well every time we're adding this Val Val into our tag we're making sure that this value is represented in the ultimate tag that we're producing by multiplying by H we're essentially adding some secrecy right the idea is that you can't just trivially recompute this tag by exing these together or doing some other sort of trivial computation to work out what the tag would be and given the H is based on our secret key it's going to be hard for any attacker to do this now we want to finally authenticate our length so we're going to take our length which is which is the length of our message and any data we have and I'll talk about that in a moment and we're going to take this and we're going to EXO it in like this and we're going to do one final multiplication by H and then finally and i' I've realized I've not left enough room at all we're we're going to take this masking key here and we're going to sort of squeeze it in via another exor and that gives us our tag does that yeah you you can fix that in post right um now what so what this is doing is protecting this equation essentially this is a large equation that we've calculated based on our Cipher text and based on our value H encrypting this L here and putting it inks that and makes it hard to recompute right so what have we got by doing this well if you change the the key none of these values are going to match up your encryption is going to fail that's good if you change any of the cipher text in transit so let's say you intercept the message you fiddle around with a few bits with a view to attacking it well this sum is going to now be different and so this tag is no longer going to match and if you change the number used once or any other part of your scheme that's going to happen right so during decryption what you're going to do is the exact opposite you're going to take your Cipher text you're going to EXO it with your key stream and get your message back but while you're doing that you're also going to compute this sum here and derive your tag and then before you return any data to the user you're going to go right does that tag that I received match a tag that I've just computed and if it doesn't you know something funny has gone on right now it could be a mistake just in transit or it could be something malicious because we've authenticated the length here we also know that we're not know no one's removed this or added another message in Block in here or something like that right and that's something You' want to avoid well I'm thinking how often is this happening so we kind of like um imagine I'm downloading a website is that like once for every website or is it for every block or is it for every chunk of it's once for literally every message you ever send right it's which so when I say it's prevalent I I really mean it right this is every time you send a packet that's encrypted unless you're splitting your data over multiple packets which for the sake of argument let's say you're not it's every message if you download image off the internet you do it if you download if you send a get request to the internet you do it right every time you send a message you always compute a tag like this so that on the other end they can say okay no one's changed anything and you've got to think actually think about how how important this would be if if we didn't have this process so I could flip bits here and your message would decrypt you could change credit card details when they were going along you could change bank accounts you could change people's passwords you could do all kinds of weird attacks that would let's say it we just don't want them to happen and so if you if you calculate this tag what you do is you get that assurance that this message is unchanged from what the sender actually hoped you were going to get so it's it's basically like a very not it's like a complicated seal on an envelope right it is like a complicated seal the the important thing is actually and perhaps this is something I should have mentioned right but the important thing is that as an attacker you shouldn't be able to recompute this so let's think about how that would happen well I know the cipher text I know the nons it's not a secret right I don't know the encryption key okay so what let's suppose I want to flip a few bits here and recompute this tag so that I can supply a valid tag which is essentially an attack a reasonable attack on on on GCM what I would need to be able to do is work out what H is because then I then I can recompute it you know I can c calculate all of this including my altered C3 if I wanted to as long as I have H but I don't have H because H is the secret encryption of zeros it's based on my key yeah the encryption of of of you under my key and so as an attacker it's going to be extremely difficult to recompute this tag unless you can obtain H and there are some attacks right so for example suppose you suppose this number used once suppose you think well that can't be right let's use it twice right a number used twice um then you are in real trouble because you can EXO the two messages together and you can essentially remove this tag right and you can then find using essentially a standard polinomial root finding algorithm what H is and once you know H you can start recomputing altered messages change length messages anything you like and attack the system which is a real problem perhaps the one thing that's worse than someone tampering with your messages would be someone tampering with your messages you don't know about it right because then you don't know to discard that message right that's a huge problem so um as GCM is really really important and actually the only other alternative really that's in modern use is Char R20 poly 1305 we've already talked about the Char R20 Cipher the poly 1305 message authentication code is a similar principle to this and the idea is that you have that tag at the end that you can verify the message hasn't been changed so if you go on your browser now and you look at your security tab you'll see in all likelihood it's done this right and many many times just while you've been watching this video so what I haven't mentioned and what will probably be driving some people very cross in the comments is that you can actually stick other data in here in this bit where I've admittedly not left myself enough room right so I'm going to use my smallest of writing to do this but you can imagine a situation where maybe you want to encrypt some data but you don't want to encrypt all of the data but you still don't want that other non-secret data being changed so for example imagine you have a packet of data on the internet where the first part is the header which is where you're sending it and the second part is your encrypted payload you can't encrypt the header because the header's the address right but on the other hand you don't want people spoofing the header or changing the header in any way and so you'd really like to authenticate that as well maybe you have a database record and you're keeping the primary key authenticated but not encrypted and you're encrypting some of the sort of personal details let's say so what we have here is something called I'm going to draw in a a d and I'm going to draw it in Orange because it's also authenticated but it's not encrypted so this is an example of an aead authenticated encryption with Associated data scheme this is additional authenticated data and the idea is that we add this into our tag and multiply by H in exactly the same way right and I absolutely have not left myself enough room so this would be this would come down here it would be multiplied by H and then it would come up here and be exord in with our Cipher text and you can do this for any number of blocks of associated data as well and that means that now this is also protected so you would you if you were sending this message on the internet you would send your public number used once you'd send any Associated data and you would send all your Cipher text and then that is enough information for the person on the other end of the line to decrypt the message look at this if they need to and verify the tag right so um that's why this is called an aead Cipher and actually if you use something like TLS 1.3 that's all there is now available right Char R20 poly 1305 ASG CM these are two aad ciphers and those are the only two available what does a tag look like is it literally just a string of numbers good question so it's 128 numbers right zeros and ones often we might truncate the tag just to make it a little bit more manageable to 96 bits but you've got to consider you don't want to truncate it too much because if you only took the first bit of a tag then you've got a 50/50 chance of calculating a matching tag on on an altered message so essentially the length of a tag is something you'd have to decide to be honest I would just use 128 bits because it's space in in most internet traffic is not that much of a premium right you know those extra few bits at the end are not are not really worth worrying about some of the rounds we do in columns so we mix a b c and d and then we mix this column and then we mix this column ABC and D in this column sometimes as GCM uses gf2 to the 28 which is a big version of the 2 to the8