okay and now to something completely different given your various interests and languages Science and Mathematics which four famous people living or dead would you invite to dinner and why oh okay that's a really good one um okay so um okay I'm gonna okay let's let's um let's start with mathematics um because uh let's start off with mathematics um Pierre de Firma I would like to I would like to have dinner with him and really ask him what did you actually write down when you wrote that thing in the margin and you said that you had this elegant proof what did you have in mind so that we could actually find out if the Thousand pages of Andrews Wild's proof is necessary um you know if if firmap didn't actually have deeper Insight that we have been unable to recover or if you just made an error I think that would be interesting um I Feynman the business is Rich fireman I would I would enjoy um I would I really like to meet him um obviously by a time machine I use a number of his quotes I found in I find a lot of his thinking very fresh and inspirational I mean he's not a perfect individual but he has a very practical relationship to knowledge and yet he also draws on an immense amount of theory but he makes his his approach to science is engaging uh it is playful and but he's not superficial I think that I for me I think that'd be absolutely fascinating um in terms of uh I think in terms of language I think a really interesting one I'm going to pick some of user live um so Ling from a Linguistics point of view um Noam Chomsky who is who's still I I would like to I would like to talk to him but perhaps I would like to talk to a past version of him um because he had some particular theories about language and you know I've read his uh stuff that gave us the whole idea of context free grammars regular Expressions all this kind of stuff I think that would be really really interesting um uh to really find out the other side of it um where he's coming from because he presented in a very Academic Way and he's certainly and he's got a lot he's got a lot on a lot of subjects to offer so I'd take him present or past but I think a past version of him could be quite interesting um and I think I think I think we're also um I'm going to go for a computer scientist as my last one um and uh Barbara liskoff um I followed her work for many years she's she's still alive but I followed her work for many years I've managed to accidentally avoid everywhere she's ever spoken um she is perhaps a little old now to be traveling and doing talks um uh but her contributions to distributed Programming type um you know our concept of types uh type systems modular systems um paradigms language design all of this stuff I I think her work has been immense not just in the 1970s but the influence that it's had um I I think that would be really you know it should be somebody to meet um if I could possibly afford to but you know yeah great questions great question level okay um let's ask you about testing regarding unit tests what is your take on writing mocks versus calling real code and unit tests there are some debate about over mocking I heard right yeah I think we need to there's a lot going on here and I'll I'll take out the separate things to give you to give you sort of a sensible answer um the original vision of mocks was to help you design interfaces that was the original idea most people don't are not aware of that and they don't use it like that they use mocks as oh my goodness I've got an external dependency I need to block it out or I've got some kind of slow dependency on the database I must mock it out that's how a lot of people think they think MOX is a way of dealing with a dependency Mass it's like no no the whole purpose of mocks was so you didn't have a dependency Mass it was to cause you to design the idea of using the mop from a test driven perspective is you learn what interface you need you don't if somebody doesn't come along and say hey I've got this code you can use it and you use it you don't do that what you do is you say my application needs this functionality you're offering me this much functioning I don't need that much and it's not the right shape for my application so it's a good implementation but let me write the interface that I want so I might adapt it so what you're doing is you're inverting the dependency you're inverting the way you think about interfaces you take it from the consumer perspective I'm a piece of code I would like some facility what should that facility look like to make my code easy yeah so from that point of view I think mocking would be great and I wish more people would do it I would people I wish people would do that original philosophy of mock driven design because our apis would be smaller our classes would be smaller everything will be smaller and much where you know the dependencies would be much better managed so that's my first the first point is yeah I wish people would do that um the next thing is when it comes to but for me the most obvious boundaries when I talk about mocking and when I introduce mocking it is to do with the most you know when people are saying where do I Define the scenes where I should or should not be mocking I tend to come back to a very simple definition and unit tests what do we mean by unit test and for me a unit test is something that um is isolated from external dependencies um and therefore put it another way a unit test the outcome of a unit test is based on the code of the test and the code that is being tested that's it if it passes it's because of this code if it fails it's because of this code okay that's it there's nothing else and that's a unit test what if I am testing with a file system well I can have perfectly correct code in a perfectly correct test but I might have the wrong permissions the files might be full hey well you know it's uh let's refer back to Toyota um I can have perfectly correct code a perfectly correct tests and my test and my test can fail in other words it's not showing me there's a problem with my code it's showing me there's a problem with the outside world um what if I have code that um seems to work uh in the presence of threads um and then one day it doesn't work in the presence of threads the only reason it was working was actually broken all that time the only reason it appeared to work was because of something external to my code the scheduling policies of the operating system so basically if you're dealing with anything where the correctness of the outcome is not based on the code that you're looking at then that's not a unit test and that doesn't mean I'm not saying it's bad I'm just telling you it's not a unit test it's not fully isolatable so from my point of view is you want to get as much you know and sometimes we will then talk about these isolated aspects we will need to actively isolate them and there will be something we call what's on the other side of that well for testing purposes how do I how do I do it unless I use a mock okay so therefore I would be using it in that case um I wouldn't be using the real code as a unit test I'd be using that as an integration test and I might but my integration has to be a lot simpler and also you know my unit tests can be a lot faster and my overall design a lot more Loosely coupled a lot better separation of concerns so that's the way I approach this one what about the problem of overmocking the problem of over mocking tends to come from when we see a bunch of code and we say oh here is the code and in our head we think I can't change the code but I need to test it and maybe that's just in our head maybe it's actually a reality of um the the choices that have been made that we have not made and cannot change at that point you end up with a code that's already a mess of dependencies and you do end up with over mocking because you have mocks returning mocks returning mocks it's very complicated if you were to design it with from the beginning you would say no no we don't need this tangle this one idea should become two it's two separate ideas separation of concerns um which would lead to separation wealth dependencies and so on so yeah over mocking um that's one source of over mocking the other sources where people start testing implementation details rather than interface details or semantic details and that's a very common thing because historically another term for more mock testing was Endo testing we don't use that term anymore but it's testing from the inside it's like you're testing callbacks You're Expecting certain things and that becomes very tightly coupled to an implementation if you change that then you've over specified it and you've broken it so these are so that's kind of where I sit on this I don't think it's a I don't think it's an easy decision it's not a one or a zero or black or a white um but I do see a lot of tendencies that lead to over marking test with real code as long as within your control don't don't don't factor out testing Can you know I've seen people actually sort of say I'm going to mock out the container that I'm using as my private representation no that is absolutely not the way to think about it um that container is private it's private for a reason it's an implementation detail but your interaction with emitting events to something else that receives events that's an external detail that deserves to be marked so I hope that covers that covers quite a lot um I'd only spent a few days talking about this but yeah hopefully that's giving you a reasonable idea and a reasonable answer yeah I think let's see um