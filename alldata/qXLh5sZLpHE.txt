so at this point you probably have a lot of code that you are working on and you might want to optimize that code or you might actually want to find out where it's being slow so in this video I'm going to be going over how we can profile it we're going to be using a native module called C profile so to do this we're going to go ahead and import C profile and we're going to import time so we can use the sleep function to simulate some requests because we're going to be making a fake website backend so it's going to make API requests it's going to be able to refresh the page and so on just so we can see where our program can be improved and we can actually get how long it took to execute certain parts of the code so first we'll go ahead and create an API call and we know API calls are very costly functions so we're going to go ahead and just type in sleep for two seconds and we're going to return none of course you would probably want to return some Json or something but we have nothing to return here then when we have some data we want to process it so we're going to create a function called process data and the reason I'm writing these functions out is so that you can see exactly which kind of code we're going to debug and find out why it's running slow and where it's running slow so this is going to be for I in range 10 to the seventh power so that's a big number and we're just going to pass so it's just going to waste a lot of time for us it's going to Loop through this for no apparent reason but it is going to delay some time then we need to sort this data so we're going to go ahead and sort the data and when we sort the data we're just going to use this for loop again but we're going to make it a bit more costly by making it much bigger and we're going to go ahead and process the data inside so when we sort the data we're also going to have to process the data after and now there's just one more function we need for our website and this is going to be called reload page and reloading the page is actually really simple all we need to do is process the data and we're going to sort the data and we're going to call time.sleep for just two seconds now try not to concentrate that sort data already processes the data we're just going to process the data and then we're going to sort it for some reason and it's going to process the data again and then it's going to sleep for two seconds just to simulate that it's reloading the page and this is just to show you that we have a lot of processes going on and finally we have our main function where all the action actually takes place so that's going to take the API call then we're going to sort that data and then we're going to reload the page which is going to just do whatever it does so these are all example functions and very shortly I'm going to show you now exactly how we can profile it so now as always I'm going to go ahead and create my names equal to main check to make sure we're running this in the correct file and now we can go ahead and create a print statement that says Timing program just so we can tell that the program's actually working and that is not frozen and finally inside here we'll go ahead and call cprofile Dot run and we need to pick a statement and for this one I'm going to use the main statement which contains all of the code for our entire program and we need to pick a way of sorting this so to sort it I'm going to go ahead and sort it by cumulative time so that's just called come time in the program and there are many ways you can sort this I am going to be leaving this page in the description box down below it is a stack Overflow question that shows you all of the different kind of sorting methods you can use with C profile so if you want to profile it by the name the line the number of calls the Primitive call count that's up to you I'm going to leave this in the description box down below but we're going to really concentrate on the Bare Basics of C profile so you can jump right into it so at this point we've created the entire program now let's go ahead and run this program so we can understand where our program is taking time and the main part of this tutorial is teaching you how to read the information down here because the first time you look at this you might be thinking this is a lot of information so first of all we have 13 function calls that have been executed in 8.2 seconds so that's already telling us how long our program took to execute then we get the ordered by which tells us how we are ordering this so we're ordering this by the cumulative time how long it took in total so the whole program essentially this part here the module took 8.29 seconds and that is the cumulative time that we are sorting this by now let's make this a bit smaller because I want to go through this line by line so here we have main which is on line 28. and as you can see we have these three calls and in total that took 8.229 seconds because that contains all of the logic that we wanted to profile and profiling this is excluding the if name is equal to main check because all we decided to profile is the main function so the cumulative time is going to be 8.229 seconds for Main and each time you call Main it's going to take this long so that's not the problem that's our main function it's allowed to take that long then we get the reload page function which is Right Above It And since this is a function that only contains functions inside here it's still going to give us the cumulative time for this function of reload and the whole call time for reload page now where this actually gets interesting is on sort data because inside here you can see we have two pickle columns and we have a total time and a cumulative time so this is the part which really gets confusing why don't we have any total times here and per call times here what we do in this row down here and to explain this let's go to sort data and it's actually quite simple what's the first per call tells us is how long it took to execute the logic in the function of sort data so if you have any native logic such as this for loop it's going to calculate it right here and it's going to tell us that's how long it took to just execute the logic inside here excluding the process data part process data is only going to be included in the second pickle for sort data so the total time for sort data with the local logic of this for loop it's going to take 1.8 seconds and since this function was called time in our entire life of the program it took 3.6 seconds but the cumulative time was a bit longer since we did have the process data function which up here waste some more time it did add a few more seconds here and it did increase the cumulative time and if you're really curious about how long process data took as you can see down here you'll find that on line 10 we have all the information about process data it was called three times so the total time it took in our program was 0.55 seconds and it took 0.183 seconds per call and the cumulative time and the pickle time are exactly the same because we have no added functions in the process data you'll also notice that sleep is a built-in method so it's going to calculate it as its own logic which means if you call sleep it's going to say sleep took two seconds to execute all the logic inside it since it is native logic and the total time and the cumulative time in our program was 4 seconds so let's try doing something different let's go down here and change the sort to total time so taught time and if we run this we're going to get a different graph it's actually going to be the same graph except it's going to be ordered differently so now with the total time we can see where our program is actually taking the longest we have the main function of course but here we can see a function that took four seconds for no particular reason so now to optimize our program we can just go ahead and do whatever we need to remove that part so we can remove it here we can remove it here and when we rerun this program we should have a major optimization which is of course a really fake optimization because we just purposely slowed it down but now when we rerun this we'll be able to see that we only have sort data which is taking the longest time and we can try to optimize that again if we want we can go ahead and say hey we don't need to do all of this we can actually set it to the second power and if we rerun that we're going to have an even faster program so now we have main that takes the longest and that's perfectly acceptable since that is our main point of the program but we can still choose to look and profile our code to see what takes long and possibly improve the time of the execution so that's actually all I wanted to share with you today on how you can use cprofile to profile your code and possibly optimize it it's a very powerful feature it's native and it's super simple to use and it gives you so much information so in case your program's going slow in certain parts just put C profile in there somewhere create a main function and just throw it in there and you can even just see profile independent functions in case you want to see how the functions are working but I believe I covered everything that was necessary in this video do let me know in the comment section down below if I missed something important I would love to hear it and possibly make a video that goes much further in depth with profiling but anyways with that being said as always thanks for watching and I'll see you in the next video