welcome to asy fundamentals where we learn about how to build asynchronous python web applications from the ground up today we're talking about the difference between application callables and application classes the asgi standard defines an application as nothing more than a single asynchronous callable that takes three parameters a scope dictionary that tells you information about the current connection and receive and send functions that are asynchronous functions that allow you to send messages to a client and receive messages from the client of the current connection however when you define an application using any of the big ase frameworks like starlet or fast api you don't see this application callable instead you typically define an application as an instance of some class like in this case we define our app is an instance of the fast api class so are these big frameworks lying about supporting the asgi specification well no of course not they actually are defining asynchronous cbles you just might not have seen it in order to make instances of a class callable we define a dunder call method so let's see if fast api has a dunder call method it took a bit of scrolling but we found it inside the source of fast api in the fast api class we find a dunder call function and it's an async def function and what do you know it takes a scope a receive and a send so actually instances of the fast api class are asynchronous cables and the same thing goes for instances of starlet applications there are als also asynchronous cbles and the same thing goes for middleware and responses and routers many of these objects are asgi applications even if it's not apparent when you first look at them as far as the asy spec is concerned your asynchronous callable application doesn't need to be a literal async def function any asynchronous callable will do to include instances of a class that has an async death thunder call if i create an app that's an instance of this app class then the call meth meod of that instance will have it self parameter bound so it will act just like the app up here where it will have just three parameters scope receive and send copy paste the body from above and these two are functionally equivalent but the real question isn't whether you can have your application be an instance of some app class but why you would want to do this in this simple example it looks like defining a function would have been the better way to go since there's less typing and less steps involved but for most real applications you'll probably want to stick to this application class pattern and the reasons for doing that are basically the same as the reasons for defining any other class classes are places that you can hold state in and they can be useful for maintaining invariance when i define an application there's going to be a lot of different things that i want to be able to configure everything from roots to middleware to startup events to exception handling i've got to hold all that information somewhere so let's put it in a class instead of using global variables you may still use global variables for things like your login configuration or other truly global objects but anything that's really specific to a single instance of an application you should really be storing inside that application object particularly because you might have more than one application object during the same run this could be because you're literally running two asgi applications at the same time or because you might have sub applications like one application is mounted at/ api and the other is mounted at the root or you may be constru many applications because you want your tests or test modules to be independent of each other so you construct a new application for each one hope this helps thanks for watching i'm james murphy and i want to thank my patrons and donors for supporting the channel you can also check out my software consultant company at m coding.