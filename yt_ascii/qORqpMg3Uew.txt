today we're going to be talking about a very common technique in python called memorization which allows us to cache results and speed up our functions by a significant amount and that can mean that if we have a function that takes maybe 30 seconds to execute this is going to help it take less than a second so let's go ahead and jump right into it i'm going to be explaining how it works and i'm also going to show you an example on where it can save us some time so to get started we're going to go ahead and import from funk tools we're going to import the wraps and that's going to help us with creating our property wrapper then from time we're going to import the performance counter so we can see how long it takes with memorization and without memorization and we're going to import system because we're going to have to use that to edit some of our computer settings now first we're going to go ahead and create the fibonacci function so it's just going to be called fibonacci and it's going to have an n inside and it's going to return to us an integer and if n is less than 2 we're just going to return and otherwise we're going to perform that infamous recursion so return fibonacci n minus one plus fibonacci n minus two so this is the basic way to create fibonacci numbers in python and now that we have this let's go ahead and test it out we're going to create the if name is equal to main check and we're going to go ahead and get the start time which is going to equal the performance counter and inside here we're going to go ahead and assign to the value of f the fibonacci of 30 and the end is going to be a performance counter as well so we can time it now all we want to do is go ahead and print f just to make sure that the fibonacci is working and we also want to print the time it took so time is going to be and minus start and we're going to add seconds to that now if we actually go ahead and run this with 30 inside that we're going to see that it's going to execute nearly immediately as soon as we start adding numbers such as 50 it's going to start taking significantly longer and what i'm going to be showing you is how to make this compute a thousand times faster so literally i'm going to snap my fingers and it's going to instantly calculate it thanks to memorization and that also works with numbers such as 2000 right now my computer is struggling to even calculate 50 for fibonacci it will show in the console eventually but it might take a minute it might take two minutes i don't really know how long it takes on my macbook m1 but it's computing everything and it's incredibly slow so while it's computing i'm going to go ahead and create the property wrapper for the fibonacci numbers using memorization so we're going to create this right above the fibonacci we're going to call this dev memo eyes and we need to insert a function because it is a decorator and let's go ahead and create a cache and the cache is responsible for storing results so that we can reuse them and that's going to save us a lot of resources on our computer when we're creating computations that have already been made so the cache is going to be there and we're also going to create something with the wraps of course we need to create that and we're going to create the wrapper and we need to pass in the arguments and the keyword arguments and in case you're curious about how decorators work i have created a video on that a couple of days ago so i'm going to leave that in the description box down below in case you want to know how decorators work and what this is and why we have to add a function here it's going to be in the description box down below but otherwise we're going to continue with this wrapper and the first thing we need to do is create a key and the key is going to be taken from the arguments so it's going to be whatever argument is given plus the string of keyword arguments now if the key is not in the cache then we're going to go ahead and add it to the cache so that we can use it later so cache at the index of the key is going to equal the function with the arguments and the keyword arguments so we can just recall that if we have it and at the end of this we're going to return the cache at the key if it exists and as with any decorator we need to return the wrapper without the parentheses so as you can see here it's a very simple technique we use in python to create a cache all we need to do is create a key for the cache and now every time we see that we've already computed a value we can just use what we used before it's going to be already computed and it's going to make the program significantly faster and keep in mind that during this entire time the function we call down here fibonacci 50 still has not computed down here so if we change this back to 20 and run the program again it's going to compute nearly instantly as you can see but as soon as we went for something such as let's go to 36 this time it's going to take a bit less time it does take significantly longer 1.8 seconds is a lot for such a small fibonacci number but now thanks to memorization we can go ahead and type in add memoize and if we go ahead and run this it's going to run instantly this is 5.2 to the negative fifth exponent so that's an incredibly small number and just to show you exactly how powerful this is before we couldn't do 50 now if we insert 50 it calculates the result instantly down here and let's make this bigger and not only now if we go ahead and try to do something such as 2000 we're going to get an error because we have a maximum recursion depth exceeded error which tells us that pretty much we've gone too far down we've made too many recursive calls and earlier you might recall that we went ahead and imported the system module so here we can just go ahead and type in system dot and i'm going to set that to 10 000 which means we've now increased the limit of our system in how deep we can go with recursion so now if we go ahead and rerun this we're still going to get an instant result as you can see right here this is incredibly fast with the 2000 number in the fibonacci sequence we can even go ahead and say 3000 and it's still going to compute insanely fast so that is the power of memorization and this can be used generally in a lot of recursive functions or any functions that use values over and over and over any place you want to try to not compute the same value over and over is a great place to use memorization and it really takes nearly no lines of code to create by hand there are some functions out there that are pre-made that can make this easier to use but i don't see why you would want to avoid just creating it by hand if it's that simple but with that being said i really hope you enjoyed this lesson on memorization do let me know what you think about it in the comment section down below and definitely let me know if i missed something it's very easy to miss things when you're trying to teach them of course but as always thanks for watching and i'll see you in the next video