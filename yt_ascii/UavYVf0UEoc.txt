memory management is one of those things in programming that we often want to ignore we want to try and automate it away and if you've got a garbage collected language it usually works most of the time until you become concerned with things like really high performance or really low latency or really high concurrency or really long running processes or really predictable performance or really constrained hardware we're now basically covering most most servers most apps most embedded devices most games there are still a surprisingly large number of areas in programming where memory management is very much our problem to deal with and even more surprisingly there are very few tools to deal with it what have you got there tool zero is do it manually maloc and free tool one i guess is reference counting there wasn't that much else until fairly rec recently rust came along with it borrow checker and said hey here's a completely different way to deal with managing memory at programming time well my guest this week would tell you that as great as rust has been it shouldn't have just been a new tool it should have been the start of an avalanche of new ways of dealing with memory and resource management in general i'm joined this week by evan nardia and he's built the programming language veil as a way of road testing his three favorite techniques you may never have heard of generational references linear types and regions and he's convinced that at least one of those is going to form the future of programming maybe he can convince you too he's certainly going to try as we explore what they are how they work what they offer us as programmers and if they're so great why don't we have them already i'm your host chris jenkins this is developer voices and today's voice is ev [music] vardia i'm joined today by evan nardia evan how are you out there i'm doing pretty good how are you i'm very well very well i'm looking forward to being taken to a certain level of hardware and memory management school by year yeah this will be fun yeah yeah but before we get straight into that the reason we got started on talking about the topic of memory management is a language you've been designing called veil my opening question with new languages is always why do we need a new language what do you feel is missing from the language world oh what do i feel is missing from the language world there's a bunch of things and i i think the world needs them a reasonable person would disagree yeah the the thing i i really think the the world needs is is someone to explore things like linear types and regions i think those are a huge like missed opportunity in today's languages and it's the kind of thing where it's like you can't really can't really imagine like how awesome it would be until you use it and even i couldn't and i'm like i wonder if this would be cool i don't know i should build it and find out and so i did and i found out and it's pretty cool okay the classic hacker mentality yeah absolutely yeah so i know oh god i know about linear types a bit from some excitement in the hascol world about it and if there's some excitement in the has school world it means it's about as far from mainstream as we can go yeah so unpack what are linear types yeah linear types i call it higher see why in a second a linear type i'll explain like the academic like the high level explanation first and then i'll talk about why it's cool so linear ypes are an object that you can't just drop on the ground and by that i mean like you know every function you have have variables x y and z and then if you say return 42 x y and z just kind of go away right because they go out of scope and garbage collection just takes care of them yeah that's how normal things work linear type let's say if x was a linear type the compiler would say you know on the return 42 line it would say hey you didn't do anything with x you can't just drop it on the ground so x is a linear type and the reason it's called linear is because you have to use it exactly once and by just dropping it at the end of the function you use it zero times so so the question is like why is that useful that sounds like a headache of the way i described it you just compiler er nobody wants a compiler erir but it would be really cool for things like let's say a handle for an active thread that's running in the background all right if you got a thread running in the background you probably want the result of its computations right but if you just drop it the most common reaction to you the coder just dropping a thread handle thing the function is to shut down the thread and that's not always useful and that's not always what you want to do sometimes that's an accident so it would kind of be nice if the compiler told you hey you just dropped this thread handle on the floor do you want to instead i don't know like check its return value maybe like join it in other words like wait on its return so linear types are good for things like that good for the way i like to think of it is tracking your tracking responsibility or tracking things that you hoped you would eventually do like the last example i'll use is in the 7dl which is a 7day really intense hackathon i did like three years ago i was making a little rog like game and rog like games are like little terminal games they're really low graphics and so in that seven days you really get to explore you know your skills and algorithms in gameplay and in that i had a cash a hashmap of what are all the goblins on the level and what was it oh yeah for every location on the level is there a goblin there so it's a hashmap of location to an optional goblin reference but i you know past years i had all these bugs where i would forget to remove things from the cach right because as you know the two hardest problems in computer science are naming and caching and luckily other things solve the first one but linear types really help with this second one i made a linear type attached to the original goblin itself that represented hey this goblin is probably still in the cash right so inside my goblin i had a i called it a goblin in cash token it's just an empty object and whenever i tried to drop the goblin the compiler would tell me you've got this goblin in cash token now and you haven't done with anything with it and i'm like oh that's right i need to remove it from the cash and so then the only way i can remove it from the cash is to trade in this token that's the cool thing about linear types they make sure that you remember to do things in the future which you hoped you would do this is kind of like this is a bit like defer isn't it it's trying to solve the same problem in that do this thing in the future because if i don't remember to i'll have problems absolutely and the difference between this and defer is that defer works really well for a specific scope and it's really readable and i really like how languages have pulled off defer the one thing that i wish defer could do which it can't really is to make sure you do things in some other scope than than your own like for example when i made this goblin that was you know like 30 seconds ago in some other deep call stack back then and like we have long since returned from that but we still want a way to track and you know uphold the promise that we'd remove it from the cash and that's what defer can't to it can't do things it can't influence the future past the end of its current scope okay that's a very nice way of looking at it to influence the future not knowing where the future will take place exactly yeah yeah yeah okay so is the idea then that you create a language that does this with all all memory all resources or just opt in for certain kinds of resources prevail it's optin you can make a language that does this for all kinds of resources in fact you could make a programming language that literally just use the linear types for everything it's weird it requires some like mental acrobatics but it is possible but no i think the power comes when when you can opt in for certain resources i like to you know you know threads caching sometimes file handles other things like that really shine with linear types yeah i can think of a couple of places in my recent programming work where it would have helped on closing connections to databases yeah okay so why do you think it hasn't gone mainstream then if it's cool and useful there's it's a really good question like it definitely hasn't gone mainstream yet i think probably the biggest reason yes okay here's the exact reason it hasn't taken off it's because of it can only kind of work in languages with single ownership and i mean that in the c++ sense not necessarily the rest sense single ownership where one reference has responsibility for this object and for c++ people that would be the unique pointer class for rust people that's just kind of how things work in rust in general but also the box class for hcal folks that would be kind of like the linear type like that's the one i don't actually know what it's called in hcal but the the linear type is kind of like the one reference that's responsible for this object where it won't go out of scope until this reference does and once this reference goes out of scope it's unreachable that's kind of necessary for linear types and the reason i say that is because if you have let's say you're using swift or some other kind of reference counted language you've got you know two or maybe like three like equal references to this one it's kind of hard in a reference counted language to say every time you drop a reference since that might be the like you know that might not be the last one but maybe it is the last one in which case you need to check are you the last reference and if so like please handle this linear type that's contained in the object you would have to do that every time you drop a reference and that's like really hard so in any kind of language with multiple references to an object that would be not a great case for for linear types but if you have one sort of privilege reference one owning reference then it works a lot better so like what i mean by that is in rust you might have a you know a a box which is the the main privileged owning reference to an object you might have a bunch of borrow references temporarily pointing to it when those gl escope you don't have to do anything you're not responsible for the object but when that box goes out of scope you really do need to handle that linear type in the object i'm talking about a theoretical r that has linear types right yeah and and in veil it's kind of the the same way you can have an owning reference and you can have a bunch of non-owning reference which are all generational references which i would love to talk about too those are super cool but you really do need one reference to be like the the main owning reference so you know all that's to say this kind of feature would only survive in a language like c++ bale rust ostr i think inco maybe and then the reason it hasn't taken off in rust in and c++ is because of the destructor the way that we think of destructors and for people who haven't used a lot of destructors because i do java in my day job a destructor is it's something that is run like for example let's say have x y and z variables in a function and x isn't just an integer let's say it's a i don't know a spaceship right and when you destruct a spaceship you want to you know safely turn off its engine in a very specified sequence or else things will explode right so in the destructor for this spaceship x you have very specific tasks you want to do however there was what i believe was a misstep decades ago when they decided that the destructor would have to take zero arguments and the reason they did this was actually a pretty good reason and that's that if someone throws an exception you know in the middle of this function you know after you have created x and before the return 42 if someone throws an exception or a panic or something it's going to blast its way through all of the call stack destroying everything in its path right yeah and how can it safely destroy the spaceship if it doesn't know what arguments to pass to its destructor right yeah and so that's why a destructor will need to have zero arguments however i think that was a misstep i think that there should have been a zero argument on panic or on you know exception function instead of the destructor and then if they had a specific function like that that could be called by panics and exceptions that means that there's no reason your destructor couldn't take two three four five arguments and would that get you that would get you the ability to like for example if you wanted to so okay let me answer that there's a specific there's a nuance here you can you can do linear types without that but you can't do something which and here's what i wanted to talk about higher r ai i high r ai is a special kind of flavor of linear types and this is where all the coolness of linear types comes and this is what makes linear types really useful in my mind if you have like going back to my past example if you have a goblin in your level right and it and you have with it a a goblin in ash token which is also a linear type you want to be able to destroy these two linear types at exactly the same time and the way you can do that is by passing into one's destructor like let let's say you pass into the goblin's destructor the linear type for the goblin in cache token or vice versa yeah yeah this is just a long-winded way to say that it's extremely useful to be able to pass two linear types into the same function and that gets you a pattern called higher ri which helps you maintain a bunch of invariant about these two things being destroyed at the same time or these three things or four things at the same time or you want to do all these operations at the same time or a past operation returned a linear type that wanted to make sure that you did some sort of future operation and that token you can take in at the same time as other linear types that's higher ri that's what really prevents the the bugs like with the goblin cache and so on okay so i think i'm going to need another concrete example to help me with this yeah yeah so let's say that um let's say that you have a a spaceship right and you want to make sure that it is eventually returned to the shipyard and in a very specific way i'll explain what that means later you want in that case you want to make spaceship a linear type right you can't accidentally just drop it on the floor so the only way like and how else would you destroy it right the only way that you know you look around and you're like how do i get rid of this spaceship it's like stuck to my hand right like how do i drop this you look around you look in the documentation it's like okay yeah the only way to destroy this spaceship is to return it to the shipyard and and the shipyard it has a function called you know return spaceship or like take spaceship dispose spaceship maybe but that function also takes some other arguments if a shipyard you know is is taking in its spaceship maybe it wants to take in the cargo it got from its mining of the asteroid or maybe it als maybe it expects like the satellite it just retrieved like like you know if you want to do a future operation that future operation is probably a function call and that function call is probably going to take multiple arguments yeah so that's why we can't that's why we can't just say yeah this this future operation is going to have zero arguments that's you know that's why we say if an exception or a panic comes in it should just call this operation over here we can't do that because that panic or that exception doesn't know these other arguments that are going to be needed to safely dispose of this for example spaceship this seems like it would be quite nice for library authors right because as an existing library author i can say you've got to give me this these things before i can create you a a database handle and you'd also be able to say along with that and you're not going to be able to get this thing unstuck from your hand until you make sure you give me these things and i can like i can control my caller's life cycle exactly exactly it's a really good way to uphold invariance and i saw really really insightful comments on hacker news about a year ago and they said that there's kind of you know we talk about correctness all the time programming languages and correctness is a really really good thing but there's two halves to correctness there's safety which we all know about and then there's something called liveness safety is the idea that you know something bad won't happen right if you could think of a bad thing you can think of a way to prevent it like for example like hascal and rust prevent use after free that's a bad thing we don't want use after free those two both prevent that from happening liveness is the concept that something good will happen right and so you can kind of think of memory safety as a well it's it's the safety half of things liveness is the it's the linear linear types of the liveness half of things and once you start programming with them you you start seeing all over the place like you know anytime you're writing in a comment like oh make sure to remember to do this like that's the that's the mental you know you start to recognize and you're like oh i need a linear type right and so you remove that comment and you feel good about it because you just remove some complexity you know move the comment and and you just wrap something in linear type and you just get this good feeling like you know this is going to happen right like you can't mess this up now you can't you don't have to rely on your memory so i see linear types as the other half of safety making this you know correctness thing we're all trying to get towards yeah i'm willing to bet there's someone out there training a large language model that spent 17 hours chewing through the data and then forgotten the call that writes to the file with the results right absolutely yeah so these things could be very very nice save a lot of pain absolutely so it seems like we could take this in two directions like how maybe we should start in user land first how much does this change the way you have to program it's a super good question because there's a lot of interesting consequences this changes well you know you can see how it could make some things easier like i just described there's also some things that it makes a little harder and let's see some of you may have read the article called what color is your function and it's about async and a weight and i guess i can see dr that one when you use async await if you have somewhere deep in your call stack that wants to pause execution while it waits for some network response to come back in or some thread in the background to keep running you would use a keyword called a wait which will suspend the entire thread or cod routine or whatever you're in in a specific way that the that the main event loop or the runtime you're in can deschedule your current cod routine and add another one yeah and this is slightly different than threads this is assuming you don't have threads or you have a good reason for not using them problem with that is that this await keyword and the async keyword that often comes with it they're they're kind of viral right if you have it your parent function will probably have to have it and then its parent function will probably have to have it and then its parent function will proba have to have it and this is see this all over the sorry goad no i've run into exactly this when i first started using it in javascript it's like how do i get out of the loop where i'm just tagging everything as async how do i actually run this thing yeah yeah yeah and like a lot of people see that as kind of inherent complexity and like you know you can't really avoid that that's wrong you could totally avoid that this is something i call a viral a vir what did i call it infectious viral constraint or something basically it's a constraint that just spreads throughout your code base even to parts of your code base that just they don't care like right like this like you i have a function that's like it's a helper that just i don't know takes in a list and calls a given function on it you know it's a map you know your map function suddenly your map function has to have an async variant because what happens if the callback you take in is async and you're calling the call back oh you have to be async so like this kind of viral thing spreads all throughout your codebase and unfortunately linear types kind of also have this this kind of same behavior but not in the function call stack they have this behavior in your data like for example if you have what's a good example if you have a bunch of if you have a list of you have a list of these linear types that represent your threads running in the background this list now is linear right if this list lives inside some sort of a resource you know thread manager that resource thread manager object is now linear because you can't accidentally drop anything on the floor that would indirectly drop that contained linear type on the floor right yeah so suddenly if you imagine your entire program's data hierarchy everything up to the top has to be a linear type if it contains a linear type and another another example of this kind of infectious stuff is like rust's borrow checker if you have a an amber sand mute like a a mutable unique reference every parent in your call stack has to have these these mutable unique reference and so that's the one that's the one downside because we don't like infectious constraints like this we don't like it when something spreads throughout the entire code base like this i just wanted to use this feature and now it's rippled through my entire code base what have you sold me exactly and and a lot of people are thinking like well you know aren't you talking about static typing in general like static typing these types just ripple throughout your code base right if you have a function that takes in a you know a spaceship and you don't have a spaceship that's got to be rippled upwards until you find some colar that has a spaceship right yeah the difference is that the first three things that i described asyn weight the unique reference in rust and these linear types these can potentially spread throughout your whole program but static types you can kind of cut off the spread you can you can limit the damage by for example taking in an interface or you can store the needed object inside another object that you have access to instead of taking it as a parameter in static typing there's a lot of there's a lot of escape hatches and ways you can kind of contain the spread so that's the downside of linear types is it's one of these infectious constraints but didn't you say that in veil it's opt in it is opt in yeah so for example if you have a spaceship it doesn't have to be linear but if it is linear then the constraint spreads and this is exactly why it's opt in by the way this is the one reason i didn't make everything linear right because i i wanted to believe me i really wanted to i'm like this is so cool and like i'm an engineer so i'm like i see a cool like idea and i want to apply it everywhere even where it doesn't you know it shouldn't be so that's the reason it's not it's not linear is because i i don't like infectious style constraints that's also the same reason veil doesn't have a traditional borrow checker like rust yeah oh okay okay so i'm i'm dying to get into the under the hood part but i'm just i've got to ask you on a personal level do you think if your day job is java programming do you think there's any chance of retrofitting these kind of linear type systems to existing languages like java a super good question i haven't thought about this in java context i think you would have some success up till a certain point you would you would be able to annotate certain types as linear if you you know if the compiler also came with a constraint that where you had to choose which reference was the primary the owning reference and then you could kind of see making your way towards this this higher r ai linear type nirvana but they would run into the same problem that c++ and rust kind of run into which is they expect a zero argument no no they don't java doesn't have destructors okay so the only remaining obstacle then would be that [music] yeah it might be possible if you could do that yeah i'd have to think a little further about that there might be a reason i can't think it off top of my head okay we'll leave that as we se project perfect so we've talked about how that will change things in user space as a developer but what does it mean for the compiler writer does it change how easy or hard it is to build the language yes it does change how we need to build a language and it makes some things a little more difficult i think the biggest example was when writing the the list class in the standard library and the hashmap class and the set class we needed to to write them so that they could gracefully handle containing linear types and there was this very specific line in the standard library in the list class where i had to write list is a linear type if it contains a linear type and that was that that hurt my brain so much so much i remember just like slamming my head against the table of this one coffee shop on i'm like how i know this is possible like there's definitely a way to make this work and and it it came to me finally after like my fifth dose of caffeine it was that we don't annotate on the list class that you know this is a linear type if is a linear type i made it like the the struct the class it's yeah i should say the struct for the list doesn't know anything about that we do instead is we say we enable a zero argument drop function only if contained type t has a zero arg drop function and that was kind of the what what made it click for me it's that we don't really tell a type that it's linear what makes a type linear or not in veil is whether or not a zero argument drop function exists for it right there was few there was a few other ones like that but that was the one i most remember and that's the one i have the most brain damage from okay is that something that gets then exposed in some syntactic way to the developer i mean are you just saying are you just worry about writing drop functions or is there some kind of you're talking about predicates right you're talking about you could have done it with a predicate that says if i contain these thing things with this trait i have this trait is there some kind of constraint predicate thing leaking into user space in vil not into user space luckily well it means depends what you mean by user space if you the the library writer have this line above your drop function that's pretty much all that you have to do if you're using the list function you don't have to have any special syntax to handle the list you don't have to do anything differently the only thing differently you have to think of is like you know when you get that compiler error that says hey you just dropped this list of spaceships on the floor like what are you going to do about it that's the only thing the user has to really think about but but did you mean user space like like including the standard library and so on yeah i think i think so i think you know you put on two different hats when you're writing the compiler versus when you start writing your standard library have you made have you given yourself another birden and another set of possibilities yeah yeah yeah it is kind of a nuisance to think about for some of your types whether they would need to be linear there's this there's this upfront complexity and this is part of the kind of viral spread problem that i was talking about where you have to think when you're writing a struct is this going to contain a linear type actually i take that back you don't have to think about it when you're writing the struct you have to think about it when you're writing your drop function like is this going to take an a linear type ever and if it does will will i eventually be able to just add this you know annotation to this drop function or not it hasn't been that much of a problem in practice but also i've only written a total of like 30,000 lines of veil and that's really not enough to get a good feel for the extent of the problem so far it seems like a good trade-off i don't know how it would work out in real life yeah right yeah i can certainly see the upside i don't know how programmers will take to it in the large but you can almost never predict that you just have to do your best with what tools you think are good right yeah i i think that programmers will like the tradeoff because it's really nice to know that you are not going to forget to remove this from the cash because like if you've ever debugged cash problems they're the worst they're awful right but if someone's writing something simple like a command line tool that just transforms this chunk of data to this chunk of data yeah this this could be a nuisance if they come across it i see quite often working with kafka it has if you don't remember to disconnect from it cleanly you know it works almost exactly the same except the next time you run the program you'll have to wait two or three minutes while it figures out if you're the second person connecting on the same clust on the same group or if you're entirely new and the old guy died yeah and it's like that's it's not the it's one of those problems not the end of the world but if you solved it cleanly for everyone it would make everyone's life just that bit easier yeah yeah that's important to yeah okay so i don't feel we fully unpacked your other favorite cool thing which is higher r a i i want you to give me some more on that starting with reminding me what the acronyms for yeah yeah so sorry i wasn't very clear at all this usage of linear types to track future responsibility that's what i call higher r ai so for like you know when you had that shipyard that was taking in the spaceship linear type and also a few extra arguments that was a certain pattern of using linear types to remember what you had to do in the future to make sure the compiler enforced you tore down this spaceship in a in the way you originally expected to okay i've misunderstood so the h higher is referring to the fact that you can pass several linear types at once into the into the drop command higher i don't know really know why oh yeah okay so the i call it higher r ai is because it's kind of a superpowered ra ai ra ai is it comes from c++ as far as i know i've done a lot of research and trying to figure this one i have no idea where the term came from but the first use i saw was c++ it stands for resource acquisition is initialization which is a horrible acronym by the way that means nothing it's gobbl to right like i love i love the concept of ri and i cringe every time i have to explain the acronym to someone so if you see me just like dying inside that's why the ac acronym means nothing the closest i can like war my mind to try and make it make sense is that resource like i try and flip it resource initialization is acquisition i can't i can't it's it's so hard anyway the concept is that you have a constructor where you take in some sort of some sort of arguments and your object holds on to those arguments so that in your structor you can use those arguments to tear down something like for example a really common use case is a file handle you know back in back in c in cand we've just got an integer file descriptor and unfortunately if you've got an integer file descriptor you know x you can just drop it on the floor and you didn't close your file and that's unfortunate and then c++ came out with r ai which is if you wrap it in a class which has a destructor that's automatically run it can make the correct call out to the clos file in in the disruptor that's automatically run but that doesn't quite capture the the beauty of this linear types thing that i've been talking about where it can take an extra arguments and it can be called with other linear types handed in and you know you can have you can be sure somewhere else in your program like like they can be sure that you will eventually call this destructor with the right arguments that's higher raai it's raai plus linear types i guess you could say and i didn't know what to call it i'm like i can't call it superpowered r i because like well i could the marketing department code yeah exactly chose higher i don't know if that was a good call or not but fair enough it's definitely better than ra i i++ yeah i did consider that yeah yeah and you're right you're right okay what what where should we go next in the world of veil because i know you're excited about regions we want to go there next yeah i love regions so i i think regions are i i hesitate to to say this with too much confidence but i really do think in 20 30 years and not because of veil at all but because of everyone's efforts on regions i think in 20 or 30 years regions will be commonplace and they'll be like just the part of the main paradigm of of software because of all the benefits they have so let's see where to start with this one let me start in a reference counting world i was just kind of playing with this the other day now veil isn't reference counted but when i was thinking of regions i'm like hey this could help reference counted people too and i'm like i should tell all my reference counting buddies about this so here's what happens let's say that you have a function where you know you're riding a little rogue light game and you got your goblins running around and on every single turn a goblin wants to figure out like what do i do like and they usually have logic like is a player nearby okay if so i want to run at the player and be scary right is the player not around okay maybe i want to like walk around in a random direction like is there is there a is there a garden at my feet cuz goblins love gardening every one knows that right and if there is you know you might want to you know do some weeding like plant plant a few seeds just basic like you know you want to figure out what the goblin wants to do and that is just by its very nature a a readon kind of operation you read the world and you figure out what you want to do and you do that by like comparing weights you might do some pathf finding right there's a very interesting opportunity in there since it's read only if the compiler and the language know that this operation is read only then you can mark it as a peer function and and i can feel like you know functional programming people all across the world being like yes those we love peer functions right and i'll tell you why they're so cool and why they work really well with regions and reference counting in a garbage collection that's because if you can mark this you know figure out what i want to do function as pure and the compiler can track that sufficiently well then it can know that during the functions execution you might make a few more references to you know the level or other goblins or the gardens but by the end of the function these references will mostly go away right and so in the outside world outside of this function and all the data that existed before this function their reference counts this is the weird part the reference count integers in those objects don't have to change it's since you know you're not changing anything in the world they don't to change and you're probably like thinking like well wait a minute but what if you you know made a new reference inside your pure function to this other goblin right and then you return that reference and it's like okay that's the spot where you'd want to dig through the hierarchy and then go reach into those you know pre-existing objects and increment their reference counts but that's much less they're much fewer of those than the temporary objects you created during the pure functions execution and i do have numbers for this now actually at least 65% in just a regular sample program i ran of at least 65% of the references were these temporary kinds of references that didn't survive the pure function call and those didn't need to like if you think about in hindsight those didn't need to do the increment and decrement on the objects they were pointing to if they were pointing into the pre-existing data this is making me think of like garbage collection where we say okay well this is huge sweep of things where we don't need to worry about any garbage that may be created yes this is very similar to i i forget what it's called it's like the the generational theory yeah it's something like that but the it's a it's a it's a very wellestablished observation in garbage collective world that if you have a function well no just in general short-lived objects most objects are short-lived and you use them once maybe twice tiny little bit and then they're just gone and very few objects need to survive any longer than a few function calls regions are kind of a way to go the compiler which objects are going to survive and which objects are not going to survive that's really nice because for reference counting you can eliminate the reference count operations on the ones that don't survive for garbage collection i'm glad you brought garbage collection up regions help garbage collection in that regard in that they can in theory i think right i've got no proof for this sorry they can in theory give the garbage collector a precise hint about where to do its collection you can tell the garbage collector hey this function is a here function and garbage collector you should copy the returned objects the returned object out of that pure functions own private heap and then just blast away the heap right and garbage collection is really good at doing that but this particular hint could make it even better with careful use of this hint you could remove these these these giant spikes that kind of build up over time like for example without this you might have a a latency spike every five seconds i don't know but with this you can kind of smooth out those spikes by giving the garbage collector more targeted information about what regions no longer exist and what objects should be copied okay so the upshot of this then is that we reduce the amount of time spend garbage collecting and the amount to kind of stop the world pausing yes for for something that sounds like it's not going to leak into programmer space this is entirely under the hood in the language is that fair unfortunately no yeah this would require you annotating the function as pure and then depending on who you ask it'll also require in the function signature no sorry the function signature won't won't change except for that pier inside this specific function nothing will change either but let's say that you then call another function which is handling both i'll call it pure data from the outside world and also some you know temporary data that was created inside your perer function it has to keep those separate and it has to know which is from which quote unquote region and so those functions that you can call might have to have region annotations or some other way to conceptually keep those data separate so the compiler can know at the end of your perer function the exact boundaries of the data that it can just throw away yeah so this could require some annotations there are some languages out there i think 42 and that's spelled f o r t y and then the two count to the number of languages that support this yeah no no yeah the the 42 creator reached out and he's like hey evan i love veil except i don't love the annotations that you said you might have to have and so we debated for a long time and he made some really good points i still believe that annotations are a lowcost way to get a lot more flexibility out of the system but if you value simplicity then i can definitely see why 42 its approach is sorry if you value syntactic simplicity 42's approach could be really nice yeah i i'm okay with the syntax for it i the thing that worries me if if you say that this model is going to come in to be one of the standard paradigms in the next 20 or 30 years oh yes i can complete that argument okay i'll finish my question and then please do so it's like how are you going to teach people both how this works they've got a good mental model and the benefits of doing so because there's a cost to learning more than there's a cost to typing annotations yes and i can imagine well i've experienced a lot of us kind of hear like wait annotations oh like is this like bar checking because that's really hard right like we don't want to learn bar cheing like well a lot of us don't want to learn it i love bar cheing and but but its annotations are really hard because like whenever you find that you have to have annotations you're in a case where compiler can't figure it out for you and and answer to that is that region annotations are actually really easy and really simple because they don't come with this extra rule about they don't come with the extra alias ability exor mutability rule they don't come with the the rule that every object has to have one writable reference or multiple reader references so really regions are just like any other static typing concern it's like you know if you have know if your function takes in a marine and a in a spaceship right this is equivalent to the difference between those two types right like if like like consider a function that takes in a an a apostrophe spaceship versus a b apostrophe spaceship those are just one extra minor step in the world of static typing those aren't a whole paradigm shift and another way to answer that would be that this is inherent to what we're doing already we kind of already mentally track what objects are in what regions we kind of already like if you if you look at a pure function or just look at a function and someone asks you like is that pure in other words like does that function modify anything from that sub world you'd be like no no like obviously from the name you know it just says get right and if you're in half scale like the answer is always yes right easy and and then you know you can kind of read the function and just kind of look at any particular parameter and know sorry you can look at the function and any of its local variables and you can kind of reason out like is this from before the function existed or is this a temporary variable errors is something that's going to get returned it's very easy to answer locally like what those are and there's no viral spread of complexity there's no extra rules that come along it's it's really just annotating you know what era this data comes from okay and is it i'm getting the impression from this that if i add pure and it's right then i just get some free memory performance boosts if i add it and it's wrong the compiler tells me i'm wrong if i don't add it at all it still works i just don't get the memory boost yes that's specifically how veil works yeah okay that's a particular property of veil that i've been chasing since the very beginning like i believe that you know 90% of your program doesn't need to be optimized that hard right and in that 90% you want to prioritize things like flexibility simplicity stable apis and so on you know maintainability you want to make it map onto the real world and humans conceptualize like as much as possible because that's part of simplicity but for that 10% that's where we'd want to add annotations like pure we'd want to use a a few more linear types for performance reasons that i haven't really gotten into that's when you want to you want to be able to opt in to these these ex this extra 5% of performance or sometimes more than that yeah i really believe in optin i believe in compiler hints like that to make certain areas much faster yeah yeah that's yeah i can totally see the appeal of that so perhaps we should talk about what your motivations are with veil because on the one hand you make it sound like you want to be the guiding light for the next 20 or 30 years of programming on the other it sounds like this is just your memory research playground maybe it's both and more but tell me it's not much of that first one i i want to be one more hint to the world there's a lot of people working on regions like verona microsoft has a really cool project called verona which is blending regions and bump allocators and garbage collection in a really cool way that's going to have a lot of performance there is that 42 language like i mentioned i there's a bunch of us languages that working together will be the guiding light i hope and and there's other languages like ustal who's pioneering mix borrow checking like from rust and linear types and so that's i'm really looking forward to that so i'd say it's more of the lad that this is just kind of my research project and it gives me something to blog about because as you've seen i love blogging mostly as just like a a vehicle for delivering my snarky side notes into the world i've seen that link to your blog yeah if anyone's read my blog posts like like they can tell like i have so much fun writing these little side notes these footnotes yeah so i think you asked why veil the reason i'm working on veil is because like there's so many things that people don't realize are possible in the world today and like we kind of tend to get stuck in this mindset where you know like like you know before russ came along we're in the mindset of there's garbage collection there's reference counting then there's things like c++ there just unsafe with some other features but unsafe and then russ came along it kind of proved is all wrong right where there's there's now this this third memory safety approach right but then we kind of just fell back into the same mindset right like for for something like when did russ come out like it i think it's 1.0 was 2013 and it was in beta for long before that so i'm just going to say like 10 to 15 years for 10 to 15 years we've been in this mindset that there's just nothing else out there there's just three memory safety approaches and that's kind of sad to me because like you know i i know that i've known that that's kind of been false for a long time right and it's and and also it kind of it kind of takes all the fun out of the exploration when everyone believes that the the problem is solved and so i want to show people with veil that there are a lot of other ways to do that that's why veil it's it's three it's three main ways of doing things are generational references which are the the fourth memory safety model it uses linear types under the hood which are arguably the fifth memory safety model and uses regions which are arguably the sixth memory safety model so anytime someone's like there's no fourth memory safety model i'm like well here's three more so now there's six so that's that's that's one of the big motivations for writing veils because like i wanted to have something that i can blow people's minds with on the memory safety front and then and then it turns out in in exploring that there's like 10 more past that and i just been collecting them over the time and i'm like oh this is this goes much further than i thought that's that's the main reason i'm working on veil the second reason is that there there's other features besides memory safety that are really cool that i think people would really like if they knew they were possible like perfect replayability if you can take non-determinism out of your entire language and make it so the entire language is predictable then you can get really cool benefits like the ability to you know have have a beta test or you you have a a special program special compiled program out to your beta testers who have opted into this particular feature where it records their inputs and if you have a recording of their inputs and you know the entire language is deterministic in other words there's no randomness creeping in from the language then that means that they can just send you that dolog file and then you can just hit play and you can reproduce their program so if you've ever had some frustration dealing with repro steps at work it's just gone but that problem it's gone like they send you the log file and you just hit play and you're done and that was actually kind of tricky because non-determinism can creep in in so many places the worst place is just memory unsafety right so suddenly you have to have memory safe language the second hardest part is threading and so now you have to figure out a way how do i make this program run deterministically but also have threading right and there are ways i won't go too deep into them but i'll leave that as an exercise to the reader okay i think i think we want to unpack a bit of that cuz yeah i've i've i've had that kind of experience in the early days of elm where it had a kind of time traveling debugger that worked by recording all the messages that made a state change on the system yes yes it kind of falls down as soon as you start doing networking stuff and they because it's compiled to javascript they didn't really worry about threading stuff how can you how what's your how do you actually get rid of enough non-determinism for this to work yes okay so i'm glad you mentioned javascript because that is the one language that has any hope of pulling this off in in today's in today's ecosystem right yeah i i actually i thought there was other languages that could do this because if you have a memory safe language that has no threading you're pretty much like 90% of the way there like python would also be close but it turns out a lot of languages like python and c they they let non-determinism creep in and very specific like you could count them on your hand and you're like oh no you were so close for example c the string classes hash code function is non-deterministic between runs if you've got a string hello my name is evan and you get a hash you just print it out you might get like i don't know 123 million and four right and then run the program again and you get a different number and i'm like what why what what could be non-deterministic about this turns out it's on purpose for security reasons oh and there's ways to do this perfect replayability deterministic thing without compromising security which is also cool oh yeah so the threading thing the trick to making this work with threading is that you would need to record the not the timings you would need to record the sequence numbers of every message you pass in between threads and what do i mean by that so think about goang for a second goang is just regular garbage cleed languages language where you have channels to communicate between the two threads there's no i won't talk about mute textes yet let's pretend there's no mute textes yet you just send a you know a hey this spaceship filed fire fired this missile message from thread a to thread b so if you want to keep things deterministic in the presence of threading you would attach a counter an integer to that message we sometimes call them a sequence number in the networking world and it's basically the source thread saying hey this is the you know 15th message i have sent on this particular channel yeah and if you are are in recording mode for this program when you receive that message you just record from you record into your recording file that hey this next thing i'm doing is i am receiving message number 15 from this channel and right yeah so if you if you are in replaying mode and you have you know you're listening on a bunch of channels at once to keep things deterministic you would just look your log file from the previous run and be like oh okay i should be paying attention to this thing over here this channel over here waiting for message number 15 specifically and you might be wondering like why do we even have the integer right the integer is for when you have a many to one channel you have multiple people writing into the channel the the integer helps you know like who it's coming from and what to wait on and what particular message to wait until they arrive love so that's kind of how you would have perfect replayability in a threading world okay that sounds good but it sounds like you've also just created a headache for anyone writing in network library now they have to write it in two modes whether they're faking sequence numbers or actually doing the job in hand is that true no actually the any library authors don't really have to do anything to support the way we deal with things like networking and reading and writing files or reading and writing configs or user input is that the language itself will intercept the data coming in from the ffi boundary so what i mean by that is let's say that you are you are opening a file right under the hood that's going to be a call out to bees well it's going to be a call out to a rapper like as we do in any language we make a little wrapper library around c's f open and f read and f close and fite and that wrapper library is so that you can ffi out to see you can call out to unsafe c code you can call into other languages code right the language knows about that ffi boundary it has to know about it because it has to be special specially you know crafted sorry the language has to support talking to other languages and the language knows very well what's going on there so inil that's i forget the keyword for that i think it's just x turn like like c is so when it sees ex turn on a function it knows that's going to be out in c or rust or zig or something like that and it also knows that if you are making a special build for this replaying and recording it should also insert extra assembly instructions that will copy any data that is coming in from ffi so if you're doing a function call out to c then there will be extra instructions that will copy the return data that's coming from c if c is calling into you into veil then these extra instructions will copy all the parameters and that means that the language you know knows the specific for well yeah any language will know the specific format of any data coming across the wire and for the case of f read it's just going to be a buffer of bytes and so the language will literally just copy the buffer of byes straight into the the recording file and sometimes that can get big and so i'm kind of tossing around the idea of enabling you know ignoring files which you know are just constant static like you know a lot of files aren't going to change between runs of your your program right so there there could be white lists like that but the short answer is that the language can specifically automatically record what comes over that ffi boundary yeah okay and then at at debug time you flip another switch that says okay replace all those external calls with a replay function exactly yeah yeah okay okay you know what this reminds me of i see a lot of people in the kind of cfa stream processing world and the actor model world and they're both trying to do this thing where they've got a network of data coming in from the outside world transforming maybe having concurrency issues and figuring out how to debug that with without completely rerunning the whole pipeline do you think you could if you does vil have anything to teach people debugging that world give me a second because that's kind of blowing my mind hold [laughter] on i think it could i think it could i don't i don't know you know much about the kafka world because we used different technologies at google but it's seems to me that recording messages and their sequence numbers is probably a solved problem in the kafka world like whatever solutions you currently use probably involve you know recording the messages and putting them on a file somewhere and i wouldn't be surprised if the missing piece in that world was the non-determinism of languages like if they didn't exist and you asked me that you know that question like knowing nothing about kafka how would you design perfect replayability in a kafka world i' be like you can't it's impossible languages suck because they're all non-deterministic and like cs you know c's string functions strings hash code function just returns a random thing every run and like why you could tell i'm scarred by that and you know what side rant here they do it on purpose like like go's hashmap or dictionary i mean it it intentionally returns a a random sequence every time you iterate and i'm just like please anyway they i i i should be kind of they do that for a good reason it's to protect against hash attacks because there's certain exploits where if a attacker crafts a certain input that they know will end up in the hashmap in the same bucket then they can just run memory out and reduce your runtime sorry maybe not run memory out but make it so your application goes to a crawl because they just turned your constant time patchmap lookup into a linear time linkless search anyway but that's that's not a problem you can still have that as long as you record all of the inputs to your program and you don't well yeah i'll leave it at that anyway so back to this kafka thing if i didn't know about veil i would say you can't because languages are non- deterministic you can't guarantee that this java program or this you know c or go program will return the same thing every time you could get close and you could have some success if you have really strict guidelines on not using certain non-deterministic things like you'd have to use a specialized map function sorry specialized map class in go you'd have to somehow avoid string hash codes in c and that's really hard i've tried it javascript would have some hope here so if you had kafka with javascript you could probably get pretty close with that but but veil yeah veil's contribution to this area in this question is that it shows that languages can be non-deterministic and so i guess if you somehow record like so i guess if you somehow note for any given operation what were all the packets that went through you know what are all the machines that they went through and you collect the recordings for all those machines then you could perfectly replay anything even in a distributed server world there's hope for a better world of debugging yeah yeah few few what they i think i've heard you use this term heisen bugs bugs that aren't there when you're looking i hate those okay heisen bugs heisen bugs so anyone who's who's done enough you know multi-threading stuff has dealt with heisen bugs heisen bugs like multi-threading is just hard to debug because the cpu just decides based on like the phase of the moon and what day it is and like you know butterfly effects in japan we whether or not it's going to schedule this thread at the same time as this thread right yeah and it's only when this thread is scheduled at the same time as this thread that this bug appears and so when you're trying to reproduce a problem that the user sees and if you can even figure out that it's because these two specific threads run at the same time that's when the bug happens why do how do you reproduce that like you can't control the cpu and what threads are put onto what cores so like there there's kind of two hard parts there it's even identifying that that's the problem and then reproducing it once you know that's the problem that's aisen bug because like you think the bug is there you know it's there but every time you look at it and every time you try and debug it it just disappears because you have no control and it depends on the face of the moon yeah yeah yeah i i'll add in a part three to that which is when you are pretty sure you've solved it are you absolutely sure you've solved it yeah you can't know yeah yeah yeah but if you have the recording from the user and you can use that to reproduce then you can see if your fix worked and modul large file sizes you could keep that in your test suite to proof that scenario yeah yeah that would be good so it seems like there is a a lot in your language research playground of veil i think we should wrap up so should i be pointing people to veil to play with learn from co-develop with you so i wouldn't suggest that anyone uses it for anything serious because you know it's still very prototyping and the compile times are unfortunately still pretty slow i would point them at my blog because i like writing stuff and i heard people like reading it that's where i kind of tell the results of everything i'm doing and the directions i'm going to explore yeah i' point them out the blog okay yeah there aren't that many people working in language research that are that readable there l lot of academics writing academic papers which aren't famed for their readability your blog is a nice way to get into this stuff so i shall link to that in the show notes evan thank you very much for joining us has been fascinating thanks for having me thank you evan you know i love it when you can't quite tell if someone's trying to push the boundaries of what's possible or if they're just playing with ideas often because the two go hand in hand so well i'm thinking of there's a great book about richard fainman who was a physicist and an inet tinkerer i think that's a spirit we could all learn from i'll put a link to biography about him in the show notes because i really enjoyed that also in the show notes of course you will find links to veil some of the other languages we mentioned and some of the other sites came up in that discussion if you scroll all the way to the show notes to find that you will also pass links to the like rate and share buttons if you've enjoyed this conversation please take a moment to click them and make sure you're subscribed because be back next week with another journey into programming at play and the future of software development until then i've been your host chris jenkins this has been developer voices with evan nardia thanks for listening