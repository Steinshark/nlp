typescript is surprisingly okay for compilers my general thought is that they're going to be talking about the type system and it's the fact that you could just do these basic like union types type discrimination right you kind of have tagged unions in in typescript you know what i mean you kind of have it you just have like a type that's a string i use it all the time it's also kind of a pain in the ass there are two main historical trends when choosing an implementation language for something compiler shaped for the for more language sector tasks like a formal specification or a toy hobby language oh camel makes most sense let's go oh camel we got an old camel shield in the house for example see plazoo webassembly reference interpreter for something implementation centric and production ready c plus is often chosen llvm clang v8 hotspot are all c plus plus these days rust is a great new addition to the landscape it is influenced most directly by ml and c plus combines their strengths and even brings something new of its own to the table like seamless safe fearless concurrency still russ leans heavily towards production readiness side of the spectrum classic i believe what i just heard here is that production readiness spectrum is how far away you are from haskell so what i'm what i'm truly hearing from this is that that there's this thing called haskell it is in the center this means you are not ready for production then there's like you know then you got like i don't know you got like some lisp in here maybe some o camel and now you're really not ready for production then you have like rust right and now you're pretty close to production okay and then on the outside you have like c plus plus you have typescript you have go you got like and you got python you got like all the languages out here these are production ready systems okay it's kind of like idaho or not idaho ohio you're either in ohio you're threatened near ohio or you're just in disillusionment that you're not threatened by ohio this is pretty much the same thing except with functional programming at the heart of it so haskell being the least production ready go c plus plus typescript and python being the most production ready you get the idea i think you guys get the idea while some aspects of it just like or like just works build system help with prototyping as well there's still extra complexity due to attacks due to the necessity to model physical layout of data the usual advice when you start building a compiler in rust is to avoid pointers and use indexes oh yeah i've really always hated that i'm not going to lie to you the whole like use indexes for everything in rust to be able to do anything with like tree shaped or graph shaped data it's just such a pain in the ass because now you have to like you just it's just extra data you have to keep around that has to be updated and any mutations can cause oddities and all that kind of stuff indexes are great no they're not in large code bases they allow greater decoupling side tables can stay local to relevant modules improving performance and index is a u32 and nudge you towards a struct of a raise layout okay i agree with this the entity component system style great we're on team i'm on that team sort of a more flexible computational strategies indexes are easier easier to serialize or plug into incremental compilation frameworks but they do make programming in the small significantly more annoying which is a deal breaker for hobbyist tinkering well i mean the problem is if they're programming in the small the problem is that your program is one large programming in the small like at the end of the day it's just one big ass programming in the small and so you just deal with indices like until you can do the wrapping interface around it to where you don't know about the indices like that entire thing is just one ass pain but o camel is crusty is it is there something better is it is really okayable crusty my brief exploration into ocamel says that i could be very excited about oh camel sure i may not be using stuff in production right we're pretty close to haskell at this point probably not production right probably not going to be using it for production but my small little lsp file parser i really enjoyed it like i genuinely enjoyed building that a no camel today i realized that typescript might actually be okay question several question marks it is not let's see it it is okay sorry i'm sorry it said typescript being okay i'm having a hard time you know processing that so my reading skills just went down the window because just a little bit earlier talked about like just works build systems up here okay you know it's emotional right i'm just emotional for a second okay it is not really surprising given how the language works but it never occurred to me to think about typescript as an ml equivalent before so let's just write a tiny tiny typescript type checker in ts of course so we start with dino everybody loves dino am i wearing my dino hoodie is this the dino hoodie no that's not a dino hoodie see a love letter to dito oh wow dino i love you oh dino i would just like to let you know that i think you are very very very very very very beautiful i'm not sure what just happened there honestly i don't i don't i don't know what just happened there i think i made a mistake [music] i agree with you i do i genuinely agree with you karen i will not do that again okay can you get up can you write a letter for me and just say sorry to all the five dollar a monthers for what i just did thank you karen [music] but the tldr is that dino provides out of the box experience for typescript this is a pain point for o camel and something that russ does better than either ocamel or c plus plus i'm pretty sure oh camel at this point is pretty much straight out of the box isn't it different my wife does not know about my dino face okay she doesn't real talk i think because dune and opam just like you know you just install what you need and you get running you know what i mean but dino does this better than rust it's just a single banary that comes with linting and formatting there's no compilation step and there are built-in task runners in watch mode a dream setup for quick plt hacks okay okay fair i i see what he's trying to say is that it's just so simple there's no anything to it and then there's typescript itself which which it's sufficiently flexible yet lightweight ceremony type system okay that's a fun way to kind of describe typescript so that's a fun way i like that let's start with defining an ast we're hacking we won't be bothered to make it an id friendly concrete syntax tree or incrementally friendly only store relative offset street and we'll just tag ast nodes with the location okay so there you go locations of file line column even here we already see high level nature of typescript string is just a string there's no thinking about the u size versus u32 okay can we all agree that this is just the world's worst thing in the universe technically correct the best kind of correct can we all agree that whenever like like the lsp i'm dealing with right now when you get an lsp message the line and character offset is u32 so when you're actually using it you have to convert it to a u size use it and then you have to go back the other way it's just so annoying you're not even on this train okay i can buy that usually an expression is defined as a subtype as we want to tag each expression with a location that represents that would be slightly inconvenient for us so we split up things a bit location expression kind perfect it's an interface always very careful about interfaces because you can actually do collisions export expression kind as it's bull expression int all this kind of stuff this can be super annoying because that means your expression has to be a tagged kind like an expression bool has to have an expression i'm very doubtful of these little t's in here these t's feeling very worried about these t's you the thing is is you feel like you're doing the right thing with generics and typescript and often they get so unwielding you made such a mistake one thing more as we're going for something quick we'll be storing inferred types directly in the ast nodes still we want to keep raw raw dog and type checked ast separate so what let's see so what we are going to do here is to parameterize the expression over associated data it stores a fresh parsed expression would use void as data and the type checker will set it to type here's what we get all right we get the t expression type we got that there we go a definition of express expression binary could look something like this let's say we got a binary operation left hand side right hand side okay export binary op all right so there you go here's the type discriminator that i was talking about by having the type discriminator you have to have this and then you're going to really fall into this problem with like t has to be a pretty danger generic here export binary off which is going to be added blah blah blah blah blah oh wait a second this isn't type hold on this isn't typed oh this makes it really interesting because this is not type discriminated this is a non-type discriminated piece of data which means that when you're checking you can't directly check is bull expression right there's no operation here or there's no type that says is bool is boo is booling is [music] boolean note that i don't introduce separate types for each add expression sub-expression all binary expressions have the same shape so one type is enough sorry i just got stuck on bully and but we need a tiny adjustment here our expression kind is a diff is defined as a union type to match our value of a union type a bit of runtime type information is needed got him got em i'd like i could see it to the future this is where you say pre-read you you say you say pre-rent this is come on please your supposed you're supposed to not believe anything i say that's like your job chat that's not my job okay thank you it's kind of ridiculous that you guys are just assuming i know everything however it's one of the core properties of typescript that it doesn't add any runtime behaviors so if we want to match one expression kinds and we sure want and and for sure we want we want to give a helping hand to the compiler include a bit of run time titty information manually runtime type information that's what it stands for it definitely stands for runtime type information definitely that rehearsed on tag binary let's go tag binary means that it's only possible runtime value for tag is a string binary yep similar to various binary expressions boolean illiteral and literal expressions have almost identical shape almost because the payload boolean and the number is different typescript allows us to neatly abstract over bend the bam oh this is where it's starting to get this is where things are starting to get a little bit goofy you're going to start making you're gonna start making some you're gonna start hating your life where's t used where the hell's t why is there no t wait what is t 's not even used here finally the flow of the control flow expressions we only add if for now is t phantom type what's t phantom type you're a phantom type i mean it's it's a literal type it's definitely being used it's not phantom data there's no i don't think there's a phantom data in typescript maybe i'm wrong here i okay hey to be completely real though just to be completely real the tia silent classic tia silent i don't really understand what phantom data is i know it's used on one cell or not one cell but it it it's it's used in a ref cell and and maybe one cell and all these other ones i don't really know what it means okay i know that there's phantom data i don't know what it does though okay real talk i don't know what it does tj i hope you're ready for this finally flow control expressions all right looks good flow control expressions if expert is if here's the expression then branch else branch oh what about if then branch shouldn't this be like an array of those i don't know how this works this concludes the definition of the ast let's move on to type inference starts with types all right type equals type boolean or type int okay bool type boolean cons tag bool type interface and take int tag equals this type let's go okay by the way i hate this i want you to know right now i hate this what you're doing right here makes it such a pain in the ass sometimes there's all sorts of problems with typescript when you name them the same thing our types really are really simple we could have gone with this but let's do a bit more more enterprising then we start by defining different types for integers and boolean types as these types are singleton so we also provide canonical definitions and here are another typescript ism because typescript fully erases types everything related to types lives in a separate namespace so you can have a type and value sharing the same name which is exactly what we want to do we're used for defined single tense i know you can but it can be such a pain sometimes especially if they're not it could just be a pain finally we take advantage because like there's this one problem where people sometimes will not export the type but export the constant and then you can't have the type but from your functions you export the type sometimes typescript gets goofed up on which one is it trying to export from a function the interface or the concrete type i've had just all sorts of problems with it finally we can take advantage of our associated data parameterized expression and write the signature of infer types all right as it says on the tin enter types fill let's see fills in a type information into the void let's define the details okay let's see infer types we got this one it comes in with this thing expression contact case cass cast me daddy all right there we go we have all these nice little these right here there's one problem though what we really want is something like inferred type equal switch yes you'll want something like that but in typescript switch statement switch is a statement not an expression so let's define the generic visitor isn't this great isn't typescript just fantastic need a primagen bingo card for streams tj what are you saying about me prime complaining about names of types and values called it okay don't do that to me i don't know what you call this but i hate all of this in ts trying to figure out what something is and i find unions of unions of nested types of unions of maybe it's a skill issue but i can never follow it's not just that it's also that all of these things that you're building requires pre-watched damn it ryan winchester they're on to us but not only that but it also requires a bunch of runtime programming to get over this right you don't have syntax to like to support what you're trying to do i find that to be the most difficult part all right visitor here we go bull there we go into binary if okay good i like visitors you know you gotta have that uh visit tfr expression t visitor t of r all right let's see return a v bool expression kind kind kind kind kind okay nice so this must be the value visitor okay armed with the visit we can ergonomically match over the expression infer types types const visit expression bull type bull that did this this there's those little ones that they're doing earlier result type binary there you go the if type fantastic result types result type let's say okay here we go ast binary add oh hey don't don't stop the music let's see result type okay so we're looking at this stuff we're returning out types i feel like we're we're still missing the type on the way out right it's not inferring the type well enough i don't think before we go further let's generalize this visit visiting pattern a bit recall that our expressions are parameterized by the type associated data type checker yep all right where's this i want to see the thing where it actually makes it into something worthwhile because the thing that you're missing here is that you have a type you do this visit you do the operations on the visit and then ultimately what ends up happening is that ultimately what ends up happening is that you have this problem where you still have to do the same check everywhere right like you don't actually get any syntax or pulling out right it doesn't actually auto complete to something specific it doesn't actually type narrow you just have this generalized type that you constantly have to untype into the the specific thing constantly and not only that but hey small critique creating an object and a bunch of functions every time inferred types are called you're going to have a really slow compiler okay your compiler is going to be really really slow you realize how many times you're going to create this object it's crazy time okay it's crazy town all right all right transform maps an expression carrying t into the expression carrying v by applying an f a visitor classic t into the v with a visitor okay we all know about this all right what is our what does it look like transform in a base we take the this one this one okay yeah wait what's this one oh that's just like a one that's not actually a thing okay confused me there i was like wait what is this syntax i don't i don't get that i don't get that at all we got int binary okay or recalling transform doing all this so we're building up the tree build up the entire tree now that we have the expression kind in both the expression u and expression v literals don't depend on this type parameter and typescript is smart enough to figure out this without us manually reassembling the same value with different types this is where the magic of a visitor vv happens the code is pretty regular here though so at this point we might actually recall that typescript is dynamically typed language and we write a generic traversal using object.keys while keeping the static function signature in place i don't want to i don't think we need to do it here but that's some comfort knowing it's possible object.keys is a bane of my life object.keys is one of the banes of my life in any library ever created and is emotional i don't know why you even have to say that it should be out now implementing type inference should be a breeze we need some way to admit to type errors though typescript would be trivial to accumulate errors into an array as a side effect but let's actually represent type errors as instances of a specific type type error pun intended bane's of life called it oh gosh come on we're not calling anything this is my life it's now or never and i'm not gonna live forever okay you think darkness is your ally bane called it you guys are calling the strangest things okay and you happen to be right you happen to be right type of key of object that just feels so stupid to do okay the fact that you have to do this all the time makes me wanna like just makes me want to cry a little bit okay it's not a love this is not a love sign okay this isn't love okay this should be a sad face that you have to do that hey what's your object it's this defined type what's its keys i don't know i don't know what they mean right like why do you gotta be that way all right and for types all right there's a lot of inferring going on here hey totally cool but i'm tired of reading code very awesome astute readers will notice that our visitor function actually takes a extra asd location argument typescript allows this argument only in cases where it's needed cutting down verbosity okay okay and that's all for today the end result is pretty neat and concise it took some typing to get there but typescript auto completion really helps with that so i'm gonna okay i'm gonna give i'm gonna give a little something here here's my big problem with typescript here did you see all the work that was required to create these types there was a lot of work to create these types remember this whole production ready thing this is my problem with ts ts actually looks more like this okay okay ts right here the t and the s like this here's the problem with it is that when you're working with typescript you find yourself programming a completely separate flow of logic right just like a completely separate line of programming and that one single set of programming you have to do with all types and then once you're done you then go and you then program your actual program and when your program needs to change you need to go over to your type system and figure out why your types aren't doing what they're supposed to be doing right you know what i mean like it's just this super annoying kind of like you know like it's i'm not sure it's like it's bimodal programming i'm not sure how else to describe it other than that and that's really frustrating whereas it does seem like in in the o camel world oh camel doesn't seem to have that problem because if you effectively can infer everything about the type system through and through so when you make a change it makes the change to the types through and thus leads you to just knowing where you've goofed up the type as opposed to having this completely separate vertical of just type programming you know what i mean i wouldn't call it bipole i'd call it bimodal bimodal right because it's like you have to have a type track and you have to have a programming track and the type track is purely so you don't screw up the programming track but the type track can be very unwieldy and sometimes super annoying so there's like this level of knowledge you require the thing about typescript that makes it so interesting is that it is super powerful types it's like like you saw that's a super powerful language to program in you can do quite a bit with it but there's like you're good at typescript and you pretty much plateau at your goodness and then there's just like it's it's a non-differentiable function and then for you to get any better you pretty much need to go here because this little spot in between these two means you pro program pure pure shitty types okay this this is a portal all right this is a portal we'll go here and we'll go here and just go right here all right this is a portal right here and this portal happens to go to this other portal that i was just drawing right over here which looks like this right here and we're gonna jump in here and we're gonna go back to that nice blue i had and then we're gonna go back down here and then go back over here and let's make it a little bit more orange there we go and we're going to take it and see and you're gonna come right out of here and guess what's down here guess what goes down here hell actual hell exists down here okay you go in here you go through here this you're probably pretty still fine at this you're pretty still fine at but there's only one person that can work on this thing and so your life is just absolutely scumbag or you have everyone that can work on this part but then your type system kind of sucks and you just have annie's everywhere okay you just have annie's that's your life a bunch of enemies that's just what happens you have any as user you know why because you can't be bothered to program for three days such that this just works automatically instead you know what it is you know you you know it is so you do that okay this is why typescript can be very very difficult i smile like the terminator don't i i think i smile like the terminator the name is i mean it wasn't that bad i mean typescript it was a pretty cool little type system that was made for the compiler i totally agree that you can do it but i want to ask you a question a quote by old jeff goldblum just because you can doesn't mean you should i know i screwed up the quotas like they're too busy to see if they could to ask if they should i get it okay i get it but i'm just saying again