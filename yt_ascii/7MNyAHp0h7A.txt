so i think it's time to officially get started with the talk so welcome everybody to breaking dependencies type eraser so i think by now most people know me but just in case my name is cla eagleburger i'm perfectly happy if you stick to the first name so i'm claus and indeed what i do for living is i do c+ training classes consulting i've written book i'm organizing a c+ user group the one in munich and i do some freelancing work at at conferences so in other words i do a lot of c++ which is not boring at all the topic yes this is a topic that i really like to talk about design software design and in particular i like this type eraser design pattern so i have given a talk about this in 2021 i think this was the first one in a series and i've talked about all the good properties of type eraser which i believe are huge and and there's an amazing amount of good things so pretty much we we resolved the solid principles really beautifully we reduce duplications quite a bit we get rid of inheritance hierarchies pointers manual dynamic allocations lifetime etc so this talk was pretty much about the design why from a design perspective this is good to have and good to use i did not really have the time to talk about the implementation details though which admitted might get a tricky and indeed i also did not really have a lot of time to prove that point yeah the performance is this truly improving performance and so this is kind of the second talk in a row but don't worry if you've not seen the first one you will definitely get the point so first very quickly just a few slides motivate the idea then i will actually do rerun of what i've done in the other talk for about 20 minutes however we will already start to talk a little more about the design sorry the implementation details and then we will talk about the optimizations good ones that you can also use for all kinds of other things but things that will potentially really make the difference why you might want to use this technique after all okay so why using this type eras idea so let's assume we have some command that command design pattern a good old g of four pattern and we have all kinds of commands print commands search commands execute commands all kinds of stuff oh well traditionally classically we would implement this in form of an inheritance hierarchy this is pretty much exactly what we would find in this gang of four book and would of course pass by pointer to base this is not really what we do anymore today right immediately some people cringe look at this ah i would use a stood function of course this is pretty much exactly the same idea i pass in something that i can call something turns a void and takes an int but it's simpler it really is so much simpler i have the same commands that i can just pass without any kind of inheritance that's nice that's beautiful so there are no inheritance hierarchies and this is totally non inuve you can start to use this even though you might still have an inheritance hierarchy you don't have to change any code to get this working this is amazing we have less dependencies also there's no pace class that tells us what exactly we have to do we can implement these commands as we see see fit that's great we have less pointers in fact in this little example i have zero pointers i've not any allocation in my end and so i also don't have to take care of any lifetime that's great too it's simple because we have values val values instead of pointers and references i would argue this is one of the big changes that modern c++ brings us we prefer to use values it's just simpler it really this is simple and potentially we have even better performance good stuff that's a that's a pretty big list of very positive attributes now let's take a look at a second kind of similar example let's say that we have shapes and i know my classic sample and come back to this in bit we have different kinds of shapes circles squares and triangles and again classically would use an inheritance hierarchy to do that but again this is not really what we do anymore this is kind of the old style when we didn't know better now today we would use value shape that kind of encapsulates all of this and it you can just equip with circles squares triangles or any other kinds of shap and so that's pretty much the same thing i've shown before just a different problem and it has the same properties no inheritance hierarchies it's non intrusive anybody can bring a new shape and this will just work there are less dependencies because of that less pointers and again no pointers here no manual dynamic allocation no manual lifetime management values and so it's simple it really is simple which is from my point of view probably the most important important thing and again perhaps perhaps you know performance is a little better we'll see so this is what we want to do this is just better so this is not a new idea this is now quoting the pragmatic programers from 25 years ago yeah the from the book the pragmatic programma inheritance is really the answer so what would you use instead what do they say well more compos and that pretty much is what i'm going to show we buil on composition and so typ might indeed be the answer that we've been looking for for yeah for a couple of years perhaps even decades with this i do not want to claim and i should stress this for real i do not claim that this is the one solution oh this would be totally wrong and totally inaccurate but it is a great solution that we can use for many many of our applications all right so let's take a look at how this stuff works by means of a simple example that though yeah i i should make clear what i'm actually talking about the term typ rati is pretty heavily overloaded and unfortunately yeah you might might get a wrong idea so typ ra is not a void pointer yeah sure i know nobody officially claims i'm using void pointer but it kind of kind of gives you the idea there is no type now i've lost all the type information type erased that's not what what i'm talking about then pointer to base again i'm kind of losing type information by going to the base class but again not what i'm really aiming for and also something i've heard too much unfortunately st variant so out of this list here stood variant is definitely the thing that definitely is not type erasure because you see the types right in the type of variant yeah you enumerate them yeah this is definitely not anything that has to do with typ now what i will be talking about is a templated constructor in a class plus a completely non- virtual interface that's it kind of if we again take a little venture into design then it is a little more of course it is a combination a very good combination of a couple of design patterns namely external polym bridge and prototype all right let's take a look at this by means of this shape example yeah and i know this is the point where a lot of people start yawn oh my god okay i totally agree with you this is a boring example and this is also what my colleague um lucas back at some point said i am tired of this example but i don't know i don't know any better one that's the point it is a classic example which i know you which i believe you know and that's a good thing so you can entirely focus on the typeia part and just ignore the rest yeah the rest should be pretty familiar so we're going to draw a couple of shapes so we going to start with shape classes like the circle pretty straightforward nothing special there's a constructor that takes everything the circle needs at least the radius couple of gets couple of data members great there may be other shapes of course squares triangles rectangles you name it yeah anything that you need the one thing that you should note at this point is that none of these shapes has a base class good and none of these shapes knows anything about drawing good as well from a design perspective this is exactly what we want to have why should the knowledge about what exactly to do be inside these classes i want to separate this as a principle behind this this is the single response ility principle so my circle squares and of course all the other shapes don't need any base class then of course they should not know about each other that's a pretty important point too and i don't need to know anything about their operations good then what i do have is okay i admitted at this point a base class it's not called shape though it's called shape concept for reason at this point but but note especially it's after all the other shapes meaning this is not the base class that circles and squares need to know about this is just some other base class and then there is another class most precisely class template that we call shape model that shape model that's the one class that truly inherits from shape concept no other class needs to know about this base class so this is the one although of course it's kind of many this shape model takes a shape t so this shape t is well any shape this is circle this is square rectangle any concrete kind of shape and it stores one of these so that's kind of it it inherits from the shape concept it's a class template that takes a shape t and it stores a shape t that's it okay of course i cannot do a lot with this at this point therefore let's add operations to the base class as we would usually do so perhaps we want to serialize two but we most definitely want to draw pure virtual functions because at this point i just don't know what to do at this with with shapes these however are now the affordances that must be implemented by the driving class and so we do we implement this do ziz and to draw in the drive class what should you do at this point how do we see how do we draw a shape well we don't have to know at this point we can simply forward this to some other function say free function which i know again sounds a little shocking to some people but stay with me this is not something we have to do but this is no first first approach so we zeroize and we draw okay then yeah this what what i just said note do is merely just making possible that there is no name collision so i call a free ziz function do seriz just prevents that there's any any anything weird happening okay so nothing nothing special all right what i'm using here is actually not something that i invented this is an ages old design pattern this is what we know as the external polymeric and design pattern so it's not the shapes direct that have to build a hierarchy it really has been externalized the entire polymorphic behavor has been externalized this is a pretty useful pattern that was described first in a paper in 1996 so it's not one of the gang of four patterns it was kind of described two years later after the book but it's a pretty good read so this here is pretty much what this this design pattern tries to achieve allow c+ classes unrelated by inheritance and or having no virtual methods to be treated polymorphically these unrelated classes can be treated in a common manner by software did uses them so that's pretty much what you have just done we have provided a completely unrelated class hierarchy okay so back to this oh one more slide so this allows any shape to be treated polymorphically circles squares rectangles they now all have some kind of virtual behavior wrapped around them this has helped us to extract implementation details good that is amazing and it removes all kinds of dependencies to the operations so again circles squares don't have to know about drawing good and this of course now creates the opportunity to extend quite nicely all right good so far then what else do we have to do well we of course at some point need the operations the real thing serialized draw for both circles and squares this is now as a necessity because we call it from up in in this shape model class these functions however they don't have to be implemented in one way i can have many of them so in say one file you implement draw with open gill and say another file use another library vtk vulcan 3dx whatever you have in mind i can have many different implementations which is nice so by means of any mechanism that you'd like from compil time to runtime polym yeah link time polym included you can now switch behavior quite nicely and none intrusively anything is possible draw shapes well okay this is a little function that just draws the shapes and not just one many of them a vector of base point managed by unic pointer i traverse all of these and i simply draw them which is pretty much what i would use in an usual inheritance how you keep it now i just wra this stuff okay and so i put this together in a main function where i first okay appri this super long type a little bit yeah let's call this shapes i create an empty shapes vector i create a couple of shapes not in a usual way perhaps so i create a circle in a shape model allocate this thing every shape model whatever template parameter i give is a shape concept and so i can put it into this vector of shape concepts just as i could use any usual base class and then i draw this stuff good however you you do not look excited from its design point of view this is already amazing but you look at me and say clous this is still good old object on programming this doesn't feel modern this feels like 1996 or perhaps even 1994 golike okay i hear you so let's modernize this a little bit let's modernize this by just wrapping this this external hierarchy in a class so we put this into a class that we just name shape okay now you might get idea while i had shape concept different name we needed the name so we have now a shape particularly note that this inheritance s key goes to the private section external code will not care about this this is a true private implementation detail of this shape class all right then this class of course has a couple of more things most importantly it has a data member a uni pointer to a shape concept a pointer to base that's the thing that i used before and i just put it into the shape class and kind of hide the thing and then i give this of course a public constructor yeah of course public else i should i used this this constructor however is not quite simple it is a templated constructor that takes any shape t circles squares rectangles whatever you have it takes a shape team so it deduces the type because it knows the type can instantiate the according model so the shape model for that given type puts the shape in this model allocates the thing on the on the free store and assigns it to my pointer two shape concept because every model is a concept so i store it by means of pointer to base okay and that that pretty much erases the type so when you put a shape inside say circle then you lose the information you just have a shape you have an abstraction and that gives this technique the name type eras all right now of course there's a l more okay i should mention this too that's again a design pattern this is what we call a bridge design pattern and this name might have given it away that's a pimple yeah so we have a pointer to implementation nicely hidden in this class nobody needs to know about this is my personal implementation detail all right now i want to serialize and draw shapes now i introduced a couple of fr functions now friend sounds nice except in c++ now usually we don't have a lot of friends but this is good friends the real friends yeah this is friends that we call hidden friends so it is not really member functions it is free functions technically these are now instantiated and not not in sted but they injected into the surrounding name space so i can call them by passing a shape but wrongly used when i really have a shape so this is nice this keeps the the overload set small and convenient all right so i can now draw and serialize shapes what i do inside however is kind of obvious so i take my pimple and i serialize or draw now i call the functions in the concept and this will not draw the thing whatever is in here because the virtual function will just go to the real thing the model and will do the real stuff nice all right so that's pretty much the idea of typ rati just wrap the thing in in a little class okay deso it's a shape and naturally if we're not talking about values i want to be able to copy shapes it's a very natural thing to do but now i have a pointer to base only really it's typ rati i kind of don't know what i have to copy so this other thing also just has a pointed to base should well that's a common common problem a problem that you know might also know a solution for so in the base class we now introduce another function we introduce a clone function ah some people not i know that i've seen this before this is a correct a design pattern yet again they're they're everywhere yeah once you realize what a design pattern is you see them everywhere you cannot avoid them whether use inheritance templates or whatever they're always there clone the clone function the base class is pure virtual simple because i don't know yet what to copy but the derive class that implements this clone function and creates a copy of whatever it stores because the the model knows it stores a shape te so i simply copy the thing note that this okay this is what we call a prototype design pattern and note i used the copy constructor here this is simple this will always do the right thing i don't have to think about this anymore and if things change if whatever i do changes this this model class this line will always be the right do the right thing good it's it's robust and stable all right the copy operations now simply use clone so i asked you the pimple to clone its content and i will get a copy i don't have to know what it is and copy assignment well this is where the copy and swap itm comes in quite handy so in these two lines i pretty much first call the copy constructor and then swap my my unic pointer good some people now say w copy and swap two lines of code is too much okay for those of you who feel this is already too much code yes of course you can squeeze this into one line it's the same thing but for some reason many people are pleased to see it short cool all right copy we can copy so we have a natural shape we can create copies of that without actually having to know what it contains now there's the move operations move actually turns out to be non-trivial it entirely depends on what you want to achieve so there are a couple of options how we can deal with move option number one we can just default them this is simple perhaps even super convenient but note that of course i have this pimple only what happens if i move from a unit pointer it's empty so if you feel like okay an empty shape is something that i can deal with that's natural this is okay then you can just default the move operations but this is something that some people don't like this does not really feel like values if you copy a circle usually you do not evict some circle and suddenly it's it's empty okay so perhaps this is simple but of not desirable okay if you have if you feel like there should be default constructor too then perhaps this is the option you're looking for because the default for unit pointer would be null poed to option number two we can just not implement the move operations we can just omit them and no no no no i didn't say delete them that is something different if you delete the move operations you forbid them you say no no no no move that's again that would be very surprising for users so you do not want to implement them because you have the copy options move would simply be gone and if we attempt to move would result in car vibration so that definitely gives you value behavior nice except for the fact that of course now you cannot move efficiently and your move operations are not no except because they allocate okay also kind of simple but perhaps not exactly what you what you desire and option number three we do not implement the move constructor but we do implement the move assignment operator that may be perhaps kind of a mixture between the two i've mentioned before so if we do not want our shapes to be empty then we have to do something that the unit pointer is never null this is something we can achieve by copying instead of move copy constructing instead of move constructing but for move assignment we could swap our pimple and this is no except so perhaps this is a tiny little bit better a little more efficient in the case of assignment but you see this is interestingly not trivial this is definitely something to think a little bit about but it entirely depends on what you want to have what do you want to have what is shape for you is it a true value like circle square etc would be or is it perhaps a little more like a pointer perhaps like an optional in some sense that it could be empty something you have to decide so this is definitely an implementation detail all right draw shapes the little function that draws shapes now takes a vector of shape values oh this looks better and it simply draws the shape that's this little hidden friend it draws the shape it looks nicer and talking about nice oh you haven't seen the main function just yet that one is breathtaking that is amazing that's the the main function now so we have a vector of shapes just this we start with empty vector we add a circle we add a square we add another circle wow i know this is the point where people usually don't say anything so gasping is the only thing i usually hear because this is beautiful and simple it's actually quite unusual that we can just add different things to a vector yeah but this is the abstraction so we can really put different values in there as long as it's a shape as long as all the affordances are implemented this will compile then rroy and as we'll do the same thing so no pointers anywhere okay now some critics would say but vector uses pointers yes internally we don't have to deal with pointers our life is simple our life is easy i do not have to allocate dynamic memory on my own again vector will do something but we don't have to deal with memory good simple so we don't have to deal with lifetime management it will just work you will never have any any any problem with that it's simple it's values value semantics instead of pointers and or references so the one thing that hopefully was obvious it's simple simpler code and this given that this entire discussion about safety security etc that definitely is a very nice contribution this shows that we actually have what we need we have simple code that works without all these traps that we might might usually have great so from this point of alone this technique is just amazing all right that's a little more though you know some people are still not quite happy some people feel like ah these three functions i i want more i want something more to h to to configure the thing what can i do oh there's a lot we could do so right now we have the shape concept and the shape model class in the private section all right but nobody saids that this is the only shape model oh no internally we can do whatever we want it's it's some hidden implementation detail so why not just introducing a a second class okay i me extended model is not a great name but perhaps it's good enough so we extend the model how well by allowing us to configure how to draw i just do this for draw and leave zer li alone we can draw this draw strategy is put in here so note this extended model al is a concept any model is a concept or implements the concept and i'm using now the strategy design pattern and this here oh sorry going back slide that here that is the point where i now in the constructor take a draw strategy and i store that draw strategy in addition to my shape this could be anything really anything this could be something that uses open gill this could be something for vtk 3dx and this could also be something just for testing purposes some little thing that doesn't really draw but proves that everything is working well it's even greatly and easily testable nice gets better and better in addition to this first templated constructor we not just add a second one one that also takes a draw strategy drawer which i put into the according extended model which again is a concept so i can initialize my pimple with that and this will work good and so this is the point of dependency injection of course and so in the main function i now have everything that i need to decide how to draw right here so i'm now like some output i can do this by for instance passing a lambda nice all right i know all of you are looking pretty pretty excited all of you are now thinking whoa i have to do this right now i cannot stay the third day for meeting c++ i have to change my code base okay stay seated we're not quite done yet so we have used it to extract implementation details that is good generally we have created the opportunity for easy extension that's what the open close principle usually tell tries to tell us we have separated the interfaces good we have reduced duplication a little bit okay removed a lot of the dependencies yeah circles squares and all these are kind of trivial classes now makes things simple you removed inheritance hierar keys removed all pointers removed all manual dynamic allocations the lifetime management issues and improved performance performance performance performance is a tricky thing you know once you mention performance in the room of c+ was delivers everybody is wide awake and everybody is like oh i want to see the numbers okay the numbers that that's always the problem if i not show some numbers there will always be some people that complain why why didn't you show that why didn't you try that why didn't you use this ah so i will show you some numbers but only if you promise me that you'll not complain afterwards so do you promise not to complain about the performance results whatever i'm going to show okay no it's always the first row right they the most problematic okay so unfortunately i have the slides already so and i know him i know where he lives so it's okay so what do i benchmark i have now a couple of shapes actually four which is still relatively small number but definitely better than just the two that i've shown i generate 10,000 randomly generated shapes randomly means i try to hide it from the compiler how many shapes how many squares etc do i have then i run 25,000 translate operations okay first thing to discuss why translate well because it's simple yeah translate means moving the center point by some offset this is simple and it's the same for every shape that is an advantage so it doesn't really depend on how many circles squares ellipses or rectangles i have and okay the benchmark is a little older so i used gc1 and clank 12 so and and yes this is the machine i used for that an 8 core intel core a7 all right here are the numbers the classic solution that we started with is okay so fast okay just numbers the typer solution is okay not better yet but this is already pretty important point from my point of view we've improved a lot of things but we did not lose anything from a for from a performance perspective it's just the same which is not entirely surprising because after all it's a virtual function call but this is great which means we now have the ability to optimize inside this class easily without having to change a lot of surrounding code and this is now exactly what we'll do so let's improve a little bit by two techniques that that i want to show and of course there's so much other things that it could try so let's start with the small buffer optimization if you're not thinking about ah haven't heard this before small small small string yes exactly that's exactly what we do for a string class too for very good reasons it's it's really important but now we do this of course for bigger things than just characters so this is what we started with this the shape class always at this point really always for whatever shape i have allocates it always calls make unique which in the end is of course just a new that is something that we can definitely improve what if we get a really tiny shape like say a circle circle is small might may contain perhaps a center point an a r rus that is something that i might store right inside a shape object all right so let's do that this looks a little scary right away but i will walk you through so let's first change this uni pointer to base into a bite array b this is the first time people real oh my this could actually work against but it will be totally safe i promise you so you now have to of course stood bite one bite we have to decide how many bytes we need at this point trust me we'll improve on that too we just decide this is 128 bytes and i put this inside the class so nobody can change that it's an implementation decision then super important super important never forget that alignment a bite aray is not aligned there's no other data member in the class that would realign this coincidentally so we now have to make sure that this thing is proper al properly aligned how i don't know we don't know what we'll get so we just take a guess say 16 bytes aligned so it's a little overlined it might be sufficient for many cases but this is just okay so this is now put into this spite buffer all right this is now the thing where we will store all our objects all of them the circles the squares whatever you got but of course again wrapped in some model so this is now ex oh this first we have pimple again but pimple is not a unique point anymore it's now a couple of functions that do a reopet cast okay and you thought it couldn't get even worse after the bite aray we know of a reed cast okay again stay seated it's it's not as bad as it looks like this is safe this is okay this is the one thing that you can do you can interpret btes as the real thing now this the c+ standard says there is this is okay and since we have aligned this properly there is no nothing to worry about we kind of know what we're doing and it is very nicely hidden inside the class anyway so the pimple function returns a pointer to the base type interpreting the the data that we have truly stored all right then the constructor now now the constructor the constructor still takes a shape t we still need the model for this shape t all right however we now have to make absolutely certain that everything we're doing is correct so we now in assert statically that the size of the z is never bigger than the buffer size it's less or equal then so this is something we can of course do at compile time which oops which is great because we can never never use something that is bigger than this buffer size and then we also check the alignment of course now we can at compile time check the alignment of this model which depends on the alignment of the given shape type so it's never overlined yeah it always will fit in this b array and now if it does we we put this into this bite array with a placement new so we at this position whatever pimple returns we create the model that takes the shape good so note and this is truly small side note we use a global placement new that looks a little weird however experience shows that yes there are people out there and no no no i'm not looking at you not accusingly at least there are people out there that actually overload place the the type based placement new operator i know hard to believe right they have no shame but okay in order to avoid that problem we use the global one and this is okay now this is much harder to to change so this will do the right thing okay now some of you are thinking correctly do we really have a place menu today is this something that we could use to construct ad for the c++ 20 algorithm oh this is a great choice we could do this it's a little inconvenient though because we have to pass a pointer to an m at this point all pimple gives us it's a pointer to concept though so we would have to use another cast i avoided this i do it manually but generally speaking construct that would be a better choice i i believe all right shape concept and shape model are pretty much unchanged from an interface perspective but of course couple of details now do change so it's still the external pism design pattern but the imp mations has the implementation has to change clone no longer returns a uni pointer to something no no no there's no unit pointer involved anymore clona takes a pointer to the memory where i want to create the new thing so takes a concept pointer in the driving class this is the memory location where i create the copy so pretty much the same thing again just that i take the memory address from outside okay and again i'm using the copy constructor because again this will always do the right thing whatever i change in the model class all right it's the same pattern again just well with static memory there's another function though that might catch your attention move why do you move need a move operation well because sometimes we might want to move a some some from this static memory into this this inclass memory to somewhere else of course clone would work too but there there's optimization potential so we introduce move that takes a concept pointer and implement this pretty much the same way except that we move the other thing it's not empty though it will be just moving the circle or the square it will move the thing that is stored inside this model just nice so perhaps from this point of view this is simpler from a semantics point of view all right going to the destructor in the destructor i'm using destroyed that's the right choice destroy at the algorithm instead of calling it destructor manually but still this is necessary we create manually we have to destroy manually this is it is required so this is a little increase in complexity but not a not a lot destroy it is is doing a good job here then the copy options super similar as before except that now i would copy into this buffer and so it's a little bit about buffer swaps instead of the the unic pointer swaps all right and move well that really is simpler we don't have to decide what is the semantics everything is inside the buffer and so i simply would call the move operation instead of the clone one and i pretty much do the same idea yeah here move and swap in the move assignment operator again so the small buffer optimization we can improve a little more so initially i just decided we have bytes and an alignment of 16 bytes it's not not a bad thing not at all but we might want to change that we might want to sometimes we want a smaller buffer sometimes we might want to have a bigger buffer okay so what could we do well of course we could make these to template parameters so we could say a shape has two template parameters non type template parameters above first size and an alignment and this would enable us to just configure this thing from outside okay but we can actually do even more what we have here is now a a shape that always stores in this in-class memory it never allocates which is great so you have full control of memory there's never any allocation but of course it limits i can only use shapes that have up to 128 bytes of course we have to take into account that there is model two and the model wraps some virtual functions be around this there another eight bytes for the virtual pointer this might be a little small and so perhaps you want a little more flexibility we can gain this by perhaps just providing a storage policy at this point we could say well sometimes you need just inclass memory and sometimes i just want to to allocate perhaps there is also some kind of hybrid idea so again i'm using a strategy design pattern to just enable a lot of different behavior so only dynamic storage just something on the stack or in class and potentially some hybrid storage that's all it takes i now can configure how the shape works this is nice but i should be honest this is something that perhaps limits us in another way so imagine we have now shape for dynamic storage all right this my shape one whatever it contains we might have another shape with another storage policy how would it work to copy from shape one to shape two okay that may be an interesting question what about the hybrid storage thing if i move shape one into that how would that work and of course the same is true for all kinds of assignment copy assignment move assignment these mixed operations might now mess things up quite a bit but i think this is this is definitely story for another day this discussion would definitely go way too deep way too deep and of course you know what happens if you dig too deep right of course you know yeah all of us know it never ends well yeah okay yeah the doria are now a little smarter if they would be alive okay if if you now used this smart buffer optimiz small buffer optimization then the performance is drum rolls faster a little bit okay i know this is the point where everybody was super excited and now everybody is super disappointed hi however this is 10% right and i have to admit that in my experiments i allocated up front and i just used the stuff i actually do not reallocate again and again that would make an amazing difference i don't have proof but i've heard that people say well suddenly our performance was at 10% yeah so we gain 90% of performance it entirely depends on what you do these 10% said just because i do not use free the free stack sorry the free store but the stack this is already quite quite cool and you know that in c+ plus a single percent performance improvement is already quite quite attractive so imagine that you come back to your company do a couple of changes use typ ra and suddenly gain 10% in performance whoa you will be the hero of the entire company for at least a month right yes very very attractive okay this is one thing we could do and i believe this is definitely something that you should try even if it looks a little meager it actually works out really well there's another thing though that i want to demonstrate we have this this nested inheritance hier inside the class okay but it's of course means that for every type that we that we put in this shape class we introduce another virtual function table and we also have these this double dispatch not double dispatch that's the wrong word but we have these two ind directions the vp pointer brings us to the virtual function table and from there we actually find the real thing that's something that we can improve because it's all happening inside the class so we can manually implement virtual functions but it's actually not as bad as it looks like so and i combine this by showing you something slightly different something that i believe you really should see because from my point of view this is way too good to not know so say we have these circle and squares i have a draw a function that is supposed to draw the shape and in the main function i create a couple of shapes and draw them okay with this one draw function we could now just pass a shape constra whatever okay this is nice that's a function that works with an abstraction with any shape we can draw whatever we get a circle a square etc however the keen observer will now complain because the shape might allocate internally just to draw a circular square we might actually yeah allocate memory create copies create a lot of effort and this is something that people usually don't like i should point out that this is by the way not just just with our shape class you have exactly the same problem with st function and any other type rati type to but there is something we can do easily in just one slide we can implement something that i would call a shape view ah that term already sounds familiar a shape view all right so how does this shape view look like so first of all i introduce a templated constructor all type classes have a templated constructor that that's a given that's part of the technique this again takes the shape t we do not want to allocate now though so how do we store any possible type that we get any shape type okay just for the record also for he here in the first row he he said it it's not my fault no it's not he said it we use a void pointer okay people in this room thought it would not get any worse yeah would would think i would not sing any lower once again it was his suggestion but at least i make it better i have avoid const pointer much better okay because it's really a reference to cons pretty much like what what string view is to okay so we take the address of shape stored in this void pointer we can take the address or again something to make it perfect we can use st address off again this is these these little quirks if anybody at this any point would overload the address of operator this would do something weird this works all right then we introduce an operation by yeah a a function pointer a pointer that returns void this was our drawing thing and it takes a void cons pointer one of these things and i have a new data member i have a not really function pointer that's the type function pointer which we might initialize to another pointer now that operation now needs to be initialized how do you do this well by means of a lambda so in the constructor in the constructor i formulate a lambda define a lambda that takes the shape because i do this in the constructor i know for sure what this shape type is i know that so i can type safely and easily without any overhead convert back from the void pointer to a shape t and draw the thing oh oo okay that's usually taking usually takes a couple of minutes to sync in yeah and you also have to overcome this oh no a void pointer feeling but this is perfectly type safe and there's no allocation there's no no overhead except for of course the usual function call okay and then just to be able to use it and i restrict it to draw again i introduce one of these hidden frs again which just does all of this so we take our little shape so the given shape view actually use the draw operation and give that operation our shape pointer so that this here actually happens and again this is the free function from before wow so a reference wrapper for again type raia but no allocation at all all right so what if i now use that what if i use this technique to implement virtual functions well drum roll it works well on some compilers some compilers actually like this a lot so gcc in this case is super happy about this clang not so much so of course they implement virtual function a little differently and so perhaps one is more friendly to the idea than the other but still what i just shown i would use this totally irrelevant from of the performance it just this is super super nice standard for any kind of abstraction yeah string view kind of types for anything that you might have now the obvious question is what if i combine the two would i gain something i did not so perhaps it was my implementation but it did not turn out overly successful okay perhaps it was wasn't just my implementation feel free to experiment a little bit i don't know all right so which brings me to the summary type is first of all a templated constructor plus a completely non- virtual interface and again a combination of a couple of very useful good design patterns and i think this combination is just one of the most interesting design patterns today absolutely absolutely and without question because typ raure significantly reduces dependencies it's one of the best ways i know to separate concerns absolutely it is about value semantics something that is not just trendy it's it's definitely something that we are striving more for more and more it does improve performance if we invest a little more into that but definitely does not decrease performance good it improves readability and comprehensibility okay now this of course makes people complain but this was so complicated you needed 60 minutes to explain it yeah sure but think about this running code think about the main function that came out of this amazing this is so simple for readers that i think it really improves comprehensibility not inside the class but outside of course and so it eases maintenance if people can understand the code better it's easy to maintain and so i think this is a very good default choice so this is why other languages use this internally you don't see that but it definitely is all right thank you very [applause] much what you may ask a question if it is not about performance you promise not to complain right okay so about the performance that you showed a small buffer optimization so two two questions first is there any reason why you didn't use align storage in instead of the bine storage but now is deprecated so i thought there's probably good reason why they don't like this anymore and okay but it is an alternative up to 20 i believe i i forgot second question what i don't like about the stack or hybrid approach usually is that it doesn't really compose very well when you have more in member functions do do you know of any technique to to reduce this so if you truly exclusively use the inclass memory i don't have any solution it it does not stack well indeed because you're limited in space yeah your your shape type has a certain size it does not fit in another shape no this is something that you can only solve by dynamic memory sorry more question hi hello claus thank you for your talk this pretty much at least the first part resembles of sean paren talk about conent based polymorphism and let's say my question is is how would you combat with boilerplate code that you need for a lot of class karches in your in your code in your code base i mean this is for example one class hierarchy but you have a lot of them in your code so how would you combat with that to rewrite for every hierarchy and the second question is what is what is happening with polymorphic value type will we will it ever get in the c++ 23 for example or not what is happening with 23 is out so sorry in 26 at least so the first question first okay i already forgot what exactly was the question first one how would you okay complexity i think overall the complexity is reduced because the surrounding code gets simpler so you hide the complexity and capsulate the complexity within class if you have a lot of inheritance hierarchies though i would not argue that you should replace all of this today with typ rasure it is a good thing but of course changing things introduces bugs if you have a very very strong test coverage per this is a thing but it still creates a lot of work and effort and many people don't want to pay for that so i think this is something to use for the next thing that you start the next hierarchy you could also start with a typ thing and then fade out the inheritance hier key because it's now inside the class this is what we usually do yeah just rewrite things that use the thing and once that is in place you can just easily reector the old thing and this is something that can take a lot longer time than if you first rem remove the hierarchy and immediately need a replacement so i think it's dupal and i think in the end there's less complexity you have still to write some code inside it's all inside which now brings me to the last point here i'm not the first to say that this should probably be some kind of core language feature eric neer couple of years ago actually for the first time said we would like to be li to be generated by the compiler if i write a concept and describe the affordances the compiler could generate such a type for me might be an option okay the second question i don't know exactly what the road map is for polymorphic type i don't know sorry i i take one from the online audience how about using car usually recording template pattern any you one need type raure of virtual based class and use concepts so we can make sure the type has the required functionality yeah it is not so crtp that was the question is an alternative but definitely a totally different area of design this is dynamic pism ser to be a static pism if you don't need dynamic pism if you can resolve everything at compile time you don't need this you have other means to do things i would not use c too i would just use a concept and perhaps a teag class to say this is part of that group and that's easier today this is dynamic pism and so i think these two play other realms i think we are out of time all right thanks again thank you