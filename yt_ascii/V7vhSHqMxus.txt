how do you solve problems with computers i mean fundamentally how do you think about taking something that's happening in the real world and making it into something that can run inside a machine we have a few different answers to this in our industry one is object orientation think about the problem as a series of objects or creatures that have behaviors and those objects talk to each other and trigger each other's behaviors causing the system to move forward to the solution that's one approach another popular approach is the procedural one you think of problems as being like things that need a recipe you break a complex problem down into simple problems you pull the recipes off the shelf that solve those simple problems and combine them back until you've got a solution recipe for your big problem and there are more those are two ways of tackling it there are more ways of thinking about software design design and whichever of those approaches you pick it's going to fundamentally shape the way you write software and the tools you choose and the way you think about solutions themselves so i always think the more of those perspectives you have loaded into your brain the more flexible a thinker you can be and in the end the better a problem solver you become to that end we're going to try and add a new perspective this week we're going to talk about an old but new way of looking at this called event sourcing which i would categorize as the two whats you look at the world and you say what happened and what does it mean that's my summary but it needs some more detail so joining me this week to provide it is someone i've always had great fun chatting with bobby calderwood he's been building event-based systems and consulting on event-based design for years now and he's going to take us through what event sourcing is why it matter matters to software developers and to a business how you do it how you think about the world as a series of events and how you do it well what tools you need and why you should add event sourcing to the list of ways in your brain you trigger when it's time to solve a problem we have a lot to cover in this so let's get cracking i'm your host chris jenkins this is developer voices and today's voice is bobby cwood [music] i'm joined today by bobby cwood bobby how you doing man good chris how are you i'm very well very glad to see you it's been a while yeah likewise likewise i i very much enjoy coming on podcast where you host so i'm well thank you very much yeah we so we i'm going to pick your brains about a big wide topic which you claim to be an expert on i know you are an expert on we'll see we'll see yeah the jur is out we'll see at the end of the podcast yeah yeah we'll give you a final score like a my borro dancing thing yeah perfect but the topic is event sourcing right which i i got into event sourcing from a weird angle i got into it from elm as a front end development to oh yeah so my definition might be different to everyone else's i sometimes think so i want yeah sure sure so the finding of ent sourcing greg young has actually written on this very recently he's been so greg young is sort of the the father of event sourcing sort of coined the term and and and identified the pattern the pattern's been there in information systems management for hundreds of years right like we've had this idea for a very long time but he named it claimed it you know sort of sort of built up you know a lot of developer mind share around the idea so kudos to greg young he's and then just recently he's tweeted out you know a very short text trying to you know get what is the essence of this thing that we call event sourcing because over the years you know a lot of stuff has grown on it like sort of barnacles on a ship hole but really at at the core of it he and others in the community and myself included believe that it's just that system state is a reduced function over the events that have happened in that system right so by writing down the events we can do a reduce or a left fold and and come to the to the current system state and that's really it right that's the whole magic of you know this big thing event sourcing it's really just that the system state is a function of the events that have happened in the system you derive it from things that actually happened yeah yeah that's right and that's that accords with our notion of cause and effect and the way that our our brains record narratives like we're very you know storytelling is a big part of the human condition and how we think about things and and that's because we think about things logically we think about okay this thing happened and then this other thing happened those two things together caused this third thing to happen and now that's that's why we're in the state we are now right so that's that's kind of how our brains work is that true in the you know sort of the sense of particle physics i don't know you know that's that's a philosophical debate we don't have to quite go into but but in terms of keeping track of things in terms of you know keeping records of what's going on in our systems of automating you know business processes or whatever it's it's a good enough approximation it's a model that works provide something really valuable to our understanding of the causal history of some particular thing that we're interested in studying or or interested in keeping track of okay well let's let's dive into that because you say it it provides value what value does it provide why should we care about v souring yeah it's a great question and sort of as we stand here at the at the dawn of the ai age right where well we've got these these machines that can think in terms of cause and effect and can can take the accumulated experience that they've been shown and then infer or or or induce new ideas you know from from those past ideas our information systems more than ever need to remember what happened we got into sort of this bad habit so they are t the alternative to an event source system is sort of a a snapshot based system you know where we're just we've got the current state of the world which is necessarily a summary of everything that happened up to this point and all we've got is that summary but we haven't remembered the story we haven't remembered how we got into that state so it's a bit like watching a you know a football game by just taking snapshots of the of the scoreboard right we're looking at the scoreboard the scoreboard summarizes everything that's happened in the game at some level and every time the scoreboard changes we just sort of look at the scoreboard that would be exceptionally boring it wouldn't give us very much wrch information about what was happening in that sporting event and and it sort of defeats the purpose the scoreboard is important it captures you know some important summaries of what's going on in the world but i think we'd all much rather watch the game right so that's yeah and there are other like my knowledge of all sports is like wayfer thin but i'm going to try and join you on this metaphor you get in games these days like the amount of time a player spent in a certain zone on the pitch or something and that's that's something you can only do if you kept the narrative of all the things that happened and reanalyze in another way right absolutely absolutely and in american football so i played american football in college and in college it's you know in high school it's really fun in college it's sort of like a job it's like you know you sit and you watch hours and hours of game film of your opponents really because oh absolutely so in preparation for the game i would probably watch between 20 and 30 hours of film on this week's opponent and the reason you do that is you see what types of schemes they run whatp you know which player you're going to be facing what their techniques are like and so forth so you do all of that because you're deriving something very important apart from the outcome of the game right we we these are games that we're played in the past we know who won these games but that doesn't really matter for our purposes we've we've taken that same information and we've repurposed it for the purpose of training ourselves to play an opponent rather than as a fan of watching the game or observing the game or whatever so it's taking the same information right the course of the game and repurposing that information for a new use same thing's true in event sourced information systems you can start with sort of what you think the information is the the information system is supposed to be or maybe it's transaction processing role and you capture all the information that happens in the course of transaction processing and then all of a sudden it occurs to you or it occurs to some smart product person like hey we can use that same information and derive new value from it just like your new statistics right how much time a person spent in zone or how much you know how many shots they took on goal or whatever other statistic we want to summarize apart from the score that's capt on the scoreboard you have all that information so you can come to those new conclusions you can derive those new insights from from those events those event data which you can't in a in a snapshot based system that information's lost irrevocably lost it's gone forever and you made that choice you made the choice to lose that information by doing a snapshot based system instead of an event source system yeah yeah i often think that the kind of post a child for this is like without wishing to criticize object orientation is based around the idea you have a state stuff happens you react to it but you forget it that's right that's right and you you destructively mutate that state and now whatever it was before is gone and within within a single process space like a single memory space in a program that becomes really gnarly when it comes to sort of concurrent programming and paral parallelization where it's like two different threads could be looking at that thing and all of a sudden it's something different and now it's like well everything all the work that i've done up to this point is meaningless because somebody changed what i was looking at kind of thing so that becomes really difficult within a process space but zooming out from that to sort of the broader enterprise information context when i'm a business and i've forgotten everything that happened right up until the the present moment and all i have is sort of like here's where we're at now how do i reason about the the future how do i extrapolate from my past experience and try to predict what's going to happen so both from an sort of process perspective you know with object orientation and some of these other practices as well as from sort of an information management information systems perspective at the business value level you're sort of losing stuff all the way down so it's like this cascade of of lost value by not hanging on to these things you know hanging on to what's happened in the past yeah yeah i kind of think one of the places where we've we've always remembered this is probably finance because they have the regular the auditors drop in at the end of the year and say what's your past stream of events they don't phrase it that way but that's the question you're ask sometimes i phrase it a little more aggressively like if your current account balances aren't in harmony with what's happened over the course of the year with these transactions somebody's going to go to prison or get find a lot of money or whatever yeah but no but that that's exactly right right we have to be able to justify you know why is they count balance this or why did we assess this much interest on this loan and you have to be able to go back and justifies well we assess this much interest because the balance was this at this point in time and so you have to be able to point to the past justify the present which is which is common in all human endeavor right we always sort of have to keep track of those sorts of things certainly in finance i mean double entry bookkeeping's been around since like the 1400s so you know we've been doing this for a very long time where we say record the facts okay now derive new facts from those original facts that you know that's something that we've done in finance for a very long time so i think the finance world is sort of in good habits around that what i learned though when i was in the finance world i was working at capital one for a lot of years there's a bit of domain blindness going on there so within the the very specific you know domain of of the financial ledger you know kind of the core banking systems everyone was very disciplined about keeping history and making sure that we could audit everything and all that and then sort of in every other domain in the company right what our customers addresses were eh just throw away everything just keep their current address it's like well come on you can't like you know so so there is a bit of this domain blindness where it's like when it comes to one particular domain we see the value of event sourcing but then we go build another information system that's sort of outside of that cor financial domain and it's like ah just crud is good enough keep current state throw everything else out kind of things why do you think that is is it i me let you speculate actually i have no idea domain blindness is is very common and i think the you know from the from the dawn of the computer age everything was so expensive everything was so cost prohibitive that we wanted to keep our programs efficient we wanted to keep the the dis space that we required really low certain information systems you know main frames and other other types of systems embedded those sort of cost oriented assumptions and so i think it's just a developer experience thing i think that's just the habit that we've gotten into as developers is yeah let's just mutely sort of in place mutate these data structures and just keep the the summary of what's going on and you know maybe we'll keep some of that other stuff around but we'll keep it in a non core non system of record place you know we'll stream it somewhere file somewh yeah that's right we stream it in splunk with our application logs or or our analytics or whatever but yeah it's sort of not in the core domain and i think the purpose of event sourcing is sort of you know flag that idea say hey you know we've been keeping records for most of human history in this history preserving event sourcing kind of way we bailed out on that you know from like 1960 to 1995 you know and now we're we're trying to like or maybe i'm generous maybe it's like 2015 you know we we we sort of bailed on that idea and we're really focused on minimizing dis usage and you know just keeping what we absolutely needed to keep and now we're getting back to the point where it's like hey discs are free right we can just keep all the information around but that's going to require sort of a a paradigm shift of of this you know several generations worth of developers habits and and impulses and inclinations to change to make event sourcing the default like it probably should be instead of the exception i always think i mean yet there's there's a learning curve to go back and forward to doing it the old and new way right sure sure i developers will sorry go on oh no please i always think developers will pay that learning curve cost if they see the value that's right and you could argue that maybe we just need event sourcing in finance because there's the value of it is so obvious and so high especially when the auditors come knocking on your door and maybe the irs and the fbi sure sure but is does it have value in other domains can you do you have any like examples where it's worth right now absolutely so you know anywhere where you can imagine deriving new facts from the facts you've already captured so you know the the the primary domain you know the sort of the the transaction processing state sometimes people call that like the aggregate or the aggregate rout right this is the the thing that you use while doing the sort of transaction processing stuff if you can think of deriving other conclusions besides that that sort of transaction processing state from your set of events there's definitely latent value there that you're missing so i think about the the aggregate route is like the scoreboard of your of your football game the events is the stuff that happens in the football game if if there are other things that you think you can derive value from other than just the score of the game then there absolutely is is value in event sourcing right so we've already identified some in our sports metaphor we've got sort of these alternative statistics that are useful and interesting to sports geeks and then there's also the value of observing that game to prepare to face that opponent right so there's already sort of these two different domains outside of just the scoreboard and who won the game where where the the events of that game are interesting and have value in that sports metaphor so taking that to other sort of business domains like yeah absolutely i i really can't i would struggle to think of one where i couldn't derive new facts from the work that i do or or the things that i write down as events in the course of automating a business process there's sort of two that obviously jump to mind you know one is analytics right we've talked about that a little bit it's kind of like your statistics you know hey hey there's a a statistics that we can derive from what's going on that are interesting apart from the the results or the outcome there's something interesting about the process that maybe we can do process improvement maybe we can do better in the customer journey you know hey there's a hot spot here where the where something is happening over and over and over again and maybe it shouldn't be maybe we can smooth that part of the process out right so there's a lot of sort of analytics we can do on that kind of stuff yeah you always see that in like online sales where job one is to actually capture the sale and process it you got any success in that the marketing department want to know what's stopping us getting more sales that's right reduce friction where's the next friction point absol abely so all of that really and and we've gotten in this bad habit in software of separating out the analytics from the work that's actually being done in the information system you know they're two different systems and you have to do them differently in the code you've got to have your analytics layer that's just writing these sort of events out and then you've got to do the actual real work of the transaction processing but it's like why would you do that when you could just do all of it by storing the business events right so that that's one area so about that i would liken to sort of these alternative statistics right shot on reading changes yeah that's right that's right the other one is one that i'll more lik to sort of preparing to face that opponent by watching game film and that's training ai agents right we were future opponents to that that team that we were watching on film and we were training ourselves by exposing ourselves to how you know they were going about their process we could anticipate them or we could tell what kind of plays they were going to run and what type of situation that sort of thing so we were training ourselves on that data we can do the same thing with automated agents now where you say hey we've got all this event data it tells a very clear story it's this sort of mostly structured you know say json or whatever kind of data let's train up an automated agent and see if it can reduce friction or see if it can do some you know magic where it can build a conversational interface on top of our existing user interface or whatever i mean there's the sky is really the limit on sort of training these automated agents on your event data which you just simply can't do with a succession of snapshots of the scoreboard you just can't do it yeah or stuff simply simple stuff not quite as glamorous but very useful of like suddenly all our customers are searching for i don't know a blue hat with a feather in it and if we could react to that quickly before we hear in the news a week later that some star has wearing that particular kind of hat you can say pulling the signal out of the noise yeah absolutely yeah reacting to the leading edge of what's happening y y absolutely so yeah i think there's a lot of benefits that way the other benefit that is sometimes hidden because we get really excited about the analytics and we get excited about the friction friction reducing we get excited about the machine learning and ai stuff the other one is a little more pedantic but but still very costly for enterprises and that's just system integration right when you have a system that's recording everything that it's doing you can create a really loose coupling integration with that system by simply just observing what it's writing down right it's okay we're just observing the events that they're writing passively we're not interacting with that system we're not issuing it commands to change the state whatever we're just seeing what it's doing and then downstream we can do all sorts of different stuff we can create new projections of state we can kick off some process we can u sort of issue a trigger to you know hey this user bailed out on a cart you know they they put a bunch of stuff in their shopping cart but then never checked out let's kick off an email and send that email to them saying hey did you forget something you know that sort of thing so there's all this sort of systems integration stuff where where your systems become much more easily extensible and and more loosely coupled the more you employ this pattern throughout your information systems because you're making the events available and that that relates to one of my like mottos which is the least coupled two things can be is just with data that's right that's right that's the maximum decoupling point is just information yeah yeah and there's sort of a bit of a decoupling reuse paradigm i don't know exactly how they're proportional but everyone talks about reuse so hey let's reuse this let's reuse this reuse is good but it depends on what you mean by reuse right are you talking about reusing the same class or the same interface in your in your code architecture or are you talking about reusing the same business occurrence to generate additional business value i think the latter form of reuse is is infinitely more valuable than reusing my interface in my class or you know in my code architecture right but we we focus a ton on reuse at the code level and we don't focus much on reuse at the data level like hey let's just let's just see what business value we're generating in the course of these information systems and and multiply that and reuse that and keep you know deriving value upon value there that's going to produce a lot more for the bottom line than like oh yeah i was able to you know dry up my function and only have two function implementations instead of three and you're like okay that you know that doesn't really matter right in the macro scale like that's not saving a ton of money or generating new value whereas the sort of reuse at the at the business data level absolutely is yeah and we should have feel like we understood that at one point in our history and we lost it because i'm sure edgar cod had figured that out back in the ibm days when he was deriving sql right yeah relational data make the data accessible without assuming people will use it that's exactly right well and that brings us to sort of the the last really interesting aspect of this this idea of event sourcing as being system state is a function of all the stuff that happens in the system which is that there's no real query language there's there's no sort of imposed usage pattern by by storing the events you can sort of build your own query language of just the different functions that reduce ser those events to come up with new things and we've already touched on this briefly you'll almost always have one that's sort of the official story that's the transaction processing state that's the one that's making sure everything's consistent and we're doing our jobs right and all that kind of stuff but then there's there's an infinite number of other functions that can operate on that same sequence of events and derive new facts and new conclusions or recommend things to do next or whatever right that there's there's sort of a a whole bunch of functions in that in that space that domain space where you can drive new things and it almost becomes its own query language right so in event sourcing there's not really a query language necessarily it's just function of the of the stuff that's happened in the system yeah big old basket full of folds yeah all the fults all the fults so we're getting into this you we are beginning to imply certain architectures and certain technology choices i can feel you almost about to say public immutable log things like how do we if you like this idea and you want to start implementing it what are the technological choices you make yeah and that's a great question because that there's there's you know every few months a blog post comes out saying like event sourcing is hard or you can't do it you know with your current text stack or you can't do it on kafka or you can't do it with x or whatever and it's like it's such a simple idea like you can really do event sourcing with a file on disk right you just a pentant to the file like that you know and at some level that's how kafka and systems like it work it's just like okay it's a pend only file and we've got a nio file handle to that thing and we just sort of you know append new stuff to it and flush it to dis and all that kind of stuff but so you really can do that right if you if you are smart about how you structure your code the repository where you store your events is sort of maybe the least interesting thing about like what you're doing right you can store it in a flat file on disk you can store it in a relational database you can you know there there's a lot of different sort of ways and techniques you can use to store these things but but all these sort of event stores have to have a set of characteristics in common right you have to there sort of a you must be this tall in order to be an event store sort of idea and that is you know you have to be able to it should be immutable you you you touched on one of those things right your your log of events should be immutable but there's also this sort of idea of i need to be able to see the events that are in there already before i write the next one because i want to make sure that you know i don't double write an event for example you know i got to guard against certain of these sort of distributed systems problems right where we've got two rights of the same information in there and now you've got extra events that downstream you have to sort of filter out or whatever so there there's sort of that idea of i want to make sure that the world hasn't moved on from where i thought it was when i issued the command to to write these events down so there's techniques like optimistic concurrency control that allow for that where you can tell your event store you know a good event store will have this api or this sort of characteristic built into it where it's like hey write this event down provided the world hasn't moved on from from the last time i read right that gives you this this ability to say you know read my events as of you know this point in time right as of you know event number 55 read those events build your state show the user the state based on those events the user makes a decision issues a command in response to that command you say okay now we're going to append some events under the world but some other user somewhere else may have already seen that state and issued a similar or or a you know contravening command and so you want to be able before you write any events down you want to be able to look in there and say like hey has the world moved on if not you know succeed to and write the event if the world has moved on fail the right alert the user tell them hey the world's moved on you might want to reconsider what you're about to do i can see how you build a system that way but i'm going to have to chall challenge you on this because absolutely isn't the event sourcing way to say well user a said do this user b said do that we record both of them and then it's the fold that makes that decision what that means maybe maybe so by having yeah the classic engineering answer is it depends and and it depends on what you want to do if you if if if your domain says that both of those inputs are equally valid and we need to sort it out after the fact like certain crts like automerge do exactly that automerge with all of its fanciness it's an amazing piece of technology it's just an event log at the bottom right you're just writing these events down and it's clever about how it sequences those events that come in concurrently from different actors and then just as you said the fold which actually produces the current value or or that converges the current value so everyone sees the same value given the same log u the fold sorts that out and you can either have multivalued fields where it could be this or it could be that or you just say last one in winds or whatever right you can sort of tell that fold function how you want to resolve that so certain types of event source systems do that but in other types of systems you want to say like you know no there needs to be some level of sort of uh i don't want to proceed if things have moved on right if if if the world's moved on from from a certain point i want you to fail that out and so in in a good event sourced event sourcing event store it'll just give you the option not the obligation but the option to use this sort of optimist concurrency control setting and say hey if if this particular event stream has moved on past you know this off set fail the right and we'll try again u and that gives you lots of different ways to sort of retry until that thing succeeds or right it just gives you the option you can just do fire and forget you know just capture all the events and then figure it out in the fold or you can say like no we need to be more careful than that we need to be more consistent than that and and you know stop the world a little bit i'm can you give me an example of where both are good because i'm kind of leaning towards the the capture both m so that we can one day have an analysis process that says do you know what we've got a lot of concurrent users trying to edit the same document in this and that's the fact that's interesting yeah yeah yeah so you're sort of alluded to the the classic use case for keeping both is concurrent document editing right if i if i'm building a google docs like thing where i'm you know trying to you know changes are coming in thick and fast and we need to just sort of like capture them all and figure it out later like that that's great that you know for for systems that are highly concurrent you know lots of of edits and changes coming in really fast that idea of sort of perpetual reconciliation and just you know capture everything and then reconcile it after the fact that's definitely the right solution there for a lot of like enterprise line of business applications that change more gradually and the consistency is more important than the availability right so in in editing availability is paramount right we just want to accept everyone's edits and everyone you know we don't want anyone sitting there with a spinner on their document because that makes them really frustrated it's a terrible user experience right so so that's why sort of accepting all those changes and figuring it out after the fact is sort of the right use case in in the editing case but for things like a financial ledger or whatever you know making sure that the same transaction doesn't come in twice because someone kicked out the power cord and we you know we just have to be a little more consistent than that we have to make sure that we don't double charge someone's credit card we make you know what i mean so like that's the that's the the sort of things that happen and have an immediate adverse user effect and then if we sort it out later we can give their money back but it's like hey sorry you already drew you already overdrew my account and now i can't afford diapers like you know that's not a great user outcome for that person so being able you know having this ability to sort of introspect on the log and say so long as the world hasn't moved on from here i know that what i last showed the user is the current state of the world and so that they're making a decision with the latest and best information possible and then they write and and then someone else comes in does the same thing they see a view of the world it's consistent at the time that they read it and at the time that they try to write something else down they have you know the system has at least the option to say yeah you know we only want to commit to this decision if that information that we showed the user was the very latest possible information and nothing's happened in the meantime yeah yeah okay so does that imply a certain tech stack though i'm trying to make you commit here yeah no no absolutely and and i'm and i'm trying to to be the consent engineer and be like i don't know it depends but yes it does it does imply give me a menu of nice so the original sort of the original category or the the original system in this category of like event sourcing event stores is event store db it was started by greg young back in kind of 2012 2013 time frame great product now it's a company event store i'm friends with the management team over there ceo is a really great guy so really good event store it's written in net they've got clients in a lot of different languages and it was sort of the first one to say you know to to offer this sort of data model around streams of events and then this optimistic concurrency idea of saying like okay for this particular stream succeed if it hasn't moved on fail if it has moved on and you know that gives you that kind of optimistic concurrency control guarantee they also have another really neat aspect of their data model which is the idea of like an entity or a subject in the stream so if you've got a big you know information system so so for example like autonomo which is the little toy information system we built for the confluent course it's sort of this uh autonomous vehicle ride sharing thing where okay i'm an owner of the of this really cool you know autonomous vehicle i park it in my parking lot you know to go to work but i don't want to just sit there baking in the hot sun i want it to go make me some money so it it drives itself off and goes and picks up you know kind of ride sharing like riders who request your ride and then the system schedules it for them and then they get in the car it drives them to their place and they they get up so it's that kind of a system when you've got you know a lot of those coming in there's lots of different rides and there's lots of different vehicles and if system state is a function of all the events that have happened in that system to find the state of any particular ride you'd have to like replay all the events for every ride that's ever happened and that's sort of prohibitive right that's that's not going to be performant it's gna you know that you're gonna have lots of lots of issues there so the ability to sort of filter the event stream and say i have only care about events about this one particular ride i'm just tracking the history of this ride because i want to figure out if it's got scheduled yet or if it's dropped off a tuesday yet or whatever you know i want to be able to display in that user's app you know your driver is going to pick you up in 5 minutes or whatever you know i want to be able to display the current state of the ride somewhere you don't want to have to reduce over every event that's ever happened for all rides ever you want to just focus in on that so that's what these what we call fine grain streams are good for you can say hey i'm gna write to this named stream you know rides these are all the events about the rides in the system but i'm g to indicate that this event is for ride you know 1 2 3 4 5 whatever that will aggregate back up to the rides event so it'll show up in the overall stream of all events but it'll also allow me to say like know i just want to see the streams about this ride really quickly reduce over the five events that have happened to that ride and figure out where it is in its process rather than the five million events for all rides ever so that that notion of sort of fine grain stream is is important how's that implemented is that just indexing the events as they come in yeah and and really what an event store is doing is just a right ahead log of of events and then you build these sort of this index of streams on top of on top of that right so really an event store is an event store system in its own right it's kind of got its own little right ahead log of the transactions that have come in and it's got the the set of indexes built up around stream and subject event stb builds several other projections around event type so you can actually just see all the events of a particular type in total order and all those things so okay you can view it in slice and dice it a couple of different ways so yeah that's sort of the first system of its class there's several other in in that category kind of along with evident db or event store db i i just i just spilled the beans we actually my company evidence systems has just written one that's very similar it was inspired by event store db inspired by a database that i worked with a long time ago called datomic a couple of other systems and it's basically solving the problem that a lot of bloggers have pointed out where it's like hey you can't use kafka for event sourcing right so when people say that what they're saying is yes kafka is a durable immutable log but because it doesn't have these characteristics like the ability to look at a stream of events or the ability to fail right you know in that optimistic con currency control way if there's already an event on the stream right because kafka is so eventually consistent in how it sort of processes those events with the producer and consumer a lot of people have have stumbled they've tried to use kopka as their event log ran into a few places where this sort of eventual consistency was not okay for their use case and they're like ah we can't do it it's it's impossible it's not the right thing can you give me an example yeah so one of the classic apis in an event store is look up an event by its id right i wrote this event down last tuesday i kept its id around some place i would like to see that event please kka just can't do that right you'd have to spin up a consumer you know scan through consume over the course of of all the events that have come in identify the one with the id write it down someplace and and go on right so that's doing a a full scan like that every time is just not performant it's not you know the best sort of developer experience it takes a lot of sort of distributed systems complexity to do a very simple job so that's one and event store db can do that our product evident db can do that you can just say hey show me this event and it'll pull it from the index this particular event or show me all the events on this stream easy show me all the events on the stream for this particular subject easy and you just get back those things so it's really those indexes on there that that set events event store dv evident dv some of the other event stores apart from kfka where evident db is a little different we sit on top of kafka so we're actually writing down all of our data to kafka it's all a big complex kafka streams app and we're you know writing down our our batches of transactions to kafka as a log and then we're building those indexes to make it really performant to query you know where the database is in terms of that thing and then we also provide that optimistic concurrency control api that event store db also does which is hey you know when you go to write check those indexes make sure that the world hasn't moved on and then only succeed if if the if the database is in the state we expect it to be in right so what we're saying really there is for an event sourcing system you would like let's not try and say anything too definitive about the entire industry for an event storing system you would like some kind of reliable wrer head log yes plus some kind of mid tier state manager that's really building indexes as a kind of what's the word i'm looking for state you can access on the way an intermediary state intermediate state that's that's got the right operational characteristics to be able to it quickly and cash it and all those sorts of things yep and then combining those two things at right time i want to be able to consult those indexes before i commit a right to the right ahead log so it's yeah putting all those things together it's the right ahead log of transactions it's the indexes built on top of those transactions and then it's the ability to say to fail or write in a in a in a perfectly consistent way a lariza consistent way fail a write to that right ahead log if the indexes aren't in the state that the that the writer expects right is there a particular set of indexes you always create or is it like custom defined or both so is like a default menu of indexes plus you can custom define yeah no so that that that's an excellent question and it's sort of an interesting it's a little bit of an interesting uh like database theory question right like so a relational database yeah that's right so a relational database has a right ahead log and it has a set of indexes maintains on top of that right ahead log and then it has a query language for writes and reads that ensures that the log is in the state that is consistent with those indexes that consistent with the the writer or or the user expectations right so very similar type of system and different indexes build or sorry different databases build different indexes depending on configuration and user preference and all those things right i can tell postgress to build me an index on this column on this table so it's really fast i don't have to do a scan of that table to find the thing i'm looking for i can just say here when it's equal to this i can pull out that record so it's much more complex in the relational world and there's tons of math that like i don't understand that you know governs how those things come into being and how you can elevate certain query clauses to make the queries more performant i mean there's just tons of really excellent work done in the relational world to to make that a performance thing in the event world it's like a lot simpler which is why i felt oh yeah i could probably build this you know trying to build a relational database i'm like forget about it i'm not enough i'm not a good enough engineer to like even tackle that but in the event world it's rather simple so the schema that we use for our events is an open standard called cloud events cloud events is great yeah cloud events. it's really great open i think it's a cloud native computing foundation standard i can't remember exactly but it's it's a standard it's been adopted by a lot of the the vendors and and it's a very simple schema and and the way they've managed their standards process is really great like it's they've got a very well worded standard and and it's very simple but the idea is you know each event has as a schema and so there's certain fields that we can count on being there right any of the required fields in that cloud event we know have to be in there so all of our events in evident db that we write down are cloud events so we can count on the presence of of certain fields being there and there's another field which is optional which is subject which is exactly that sort of fine grain stream it's that entity identifier that says this event is about this thing and that allows us to build a subject-based identifier there's also a bitemporal extension field on on cloud events where you can say you know effective date i think is what it's called or something like that but there's some sort of field that allows you to say i know this event came in this order but really we want to think of it as as if it had occurred you know last tuesday or or this morning at 9:00 a.m. or whatever like when you're backdating a deposit that's right backdating a deposit is a great example a lot of banking use cases rely on this sort of trickeration to say like yeah these events you know these transactions came in in this order but we're gonna fudg it a little bit and shuffle them around so that we can come come up with a better customer outcome they actually do this in favor of the customer more often than in favor of the bank because they're forced to by the government they they you know if certain transactions would come in in a way that would cause multiple overdrafts for example they resequence them so that only one overdraft will happen or at least they're supposed to it depends on the bank you go to most of the time but they're supposed to uh process those transactions in such a way that it will minimize the number of overdraft fees that the customer hit with so if i you know write a check and it overdraws my account and then i make a deposit and then another thing hits and i make another deposit you know it will have over overdrawn me two or three times in there it'll say like no put all the deposits first and then put all the debits second and then we'll see where we're at and see if if there's any reality in which this wouldn't have occur cost yeah that's the way you have to pretend actually happened that's right exactly so so that b temporality becomes really useful so in evident db we build a stream index so you know what what type of event is it you know or or you know what bounded context is this event coming in you know so in our autonomo example there's sort of a stream that's about vehicles right this is people registering their vehicles for the service making their vehicles available requesting the return of their vehicles that sort of thing and then there's a a a stream that's about rides which is you know w ride got requested the ride was scheduled by the system the rider got picked up the rider got dropped off all that kind of thing so two separate streams of events and we we index on those streams so that you can say like okay here's the total order of the just the events in this stream we maintain a total order of all the events per namespace so so we're multi-end it we we allow for many database kind of name spaces within our system okay and all of those all the events within a particular database namespace are totally ordered and we maintain a total order on those things but then also you can sort of drop down into a particular stream and say hey just show me this particular stream and then within that stream we say hey just show me the events about this particular subject and then you can totally order them per subject you can even if you get clever you can do that across streams and things too so yeah so really stream subject and then boral indexing those are kind of the big ones there are a handful of others so each event has a type so you can if you want build an event index on type i don't know how useful that is event story db has that i don't know what anyone uses it for in event story db but they have it i'm sure they have it for a reason and i'm sure some customer at some point asked for that right so you can you know index the events or look them up by type and that sort of thing so yeah that that's that's really the the main api though is is really i'm going to transact a batch of of events and i can specify sort of constraints on those events and if all those constraints hold the whole batch goes in if any of those constraints are violated the whole batch fails so you get that sort of atomic level right of multiple events once which is actually something evident db has that u event store does not have event store is one event at a time that you can write in so we we have the ability to sort of automically transact batches of events in or not depending on those constraints those oc constraints so that's kind of the right api that's it that's the only right api and then the read api is you know pull me a stream or pull me a stream for a subject or pull me a stream for a subject in a bitemporal reordered kind of way so that's that's how we we provide those apis to the end user very straightforward it allows for reasoning about the system at a particular point in time we're we're able to do a ton of caching in our clients for doing that sort of thing we have a unique sort of feature in our database that in the client very much like datomic so datomic had this really awesome notion one of riki's best ideas and that's saying a lot because he had a lot of really great ideas yeah yeah but one of his best ideas was the idea of of the database as a value so sort of the the operational part of a database which is the thing that you write against that's sort of the connection that thing's stateful it's like you know got network stuff in it and you're you're talking of this thing that's a machine and it's you know going through a a succession of states over time right so there's the connection and that's kind of the stateful machine bit but then you ask the connection for a database value you say hey you know show me the database as of this point in time or show me the latest that you have access to or whatever and then you get a database value back and that that database value has true value semantics so no matter what happens you know rights can keep going into that database you know as much as they want they can fast but that database value maintains its consistent point in time view so you say like once i've asked it for this database every time i ask it for some stream or for some subject or whatever it's always going to give me back the same answer so you can use these database values in functions in functional programming because it has value semantics rather than reference semantics that are going to point to some changeable thing or for the sake of listeners that aren't quite the closure fans that you and i are yeah yeah yeah why don't you define what you mean by true value semantics for datas yeah yeah so value semantics means that it's a it's a value like the number 42 or you know some immutable map or something that where it's stable over time so one of the key constraints in functional programming is if you call it's called referential transparency if you call a function with two arguments or or or with an argument multiple times it should always give you the same answer right so if it's a true function in the mathematical sense if you pass it arguments that are the same you should always get the same answer you know out the back end there are exceptions of course like you have to have random number generators and some other types of things but really you should be building most of your programs up out of these pure functions because they're very easy to reason about you don't have to think about change and when things change and concurrency whatever if you have pure values and you're just passing those values to functions and always getting the same answers back it just becomes really easy to reason about your system and test it and all that so that's one of the big virtues of functional programming you introduce databases into the mix and everything becomes complicated now you have to have mon ads all over your program because it's like i don't know everything can change at any point and so i have to just hedge through my whole program if you have a database that provides you value semantics you can take that database value and even though under the hood it's composed of references and it's referencing out to these other places it's stable and so it doesn't change over time you know regardless what happens to the database more transactions are hitting it or whatever that database value is what it is and it'll always return you the same results when you ask it questions so you can pass that database to a function and sort of always get that the same answers again so it participates in in pure functional programming in a much nicer way than these nasty stateful you know machines that you have to wrap in all kinds of monads stuff to make sure that you're so by treating the database as a pure value you get things like consistent queries y across database for free that's right that's right and there's a a in this type of database because it's all made out of events there's tons of cacheability in there so right when i have a database value you know when i first get that from from the connection there's probably a lot of network activity i'm i'm downloading all the events and make sure but now they're all cach and so now i'm asking it questions it feels like it's inside of my program it doesn't feel like i'm talking to something way over there across a wire it feels like everything's right here in my hands so now we can think of this thing not as you know the stateful connection in intermediated by this you know stateful protocol but something that's present something that's in in my program in a much deeper sense than if you're dealing with an om or if you're dealing with you know executing sql queries and getting back these big data sets and you know you have to sort of be really conscientious about when you ask for that data set because sometimes with sql stuff and ors if you ask the same question twice it'll give you two different answers because the database will have changed under the hood and there's mechanisms for letting that omm thing know in memory so yeah there's a lot of complexity built into these sort of interactions around databases we're trying to simplify that out and say hey let's simplify the whole notion of a database down to just the things that happened and then some indexes on top of those things and then let's simplify the interaction with with the database so that we have value semantics in memory so we can you know use these things in functions so we can ask it questions and always get the same answer right so we're really trying to sort of really dramatically simplify it down push that complexity out to the edges to be handled by the platform or the system itself and not to burden the developer with all the crazy distributed systems stuff yeah yeah there's a lot of clever stuff going on under the hood but at the programmer level let's try and make it look just like a series of values exactly which is nice are we are we implying that in order to do event sourcing or to do it well you have to get into functional programming no and in fact the i like you sort of came to event sourcing from a weird angle most of the event sourcing thought you know from greg young through the sort of domain driven design community taking it over has come from an objectoriented perspective right people talk about aggregates as if they were objects people talk about you know sagas and and you know projections and commands and events and stuff it as if it was sort of this object hierarchy of things and that's fine right if that's your your style of programming i think that works there been a lot of really good thought put into that stuff but functional programming again i'm i'm not a great engineer so all that stuff is too complex for me i can't keep it all in my head so i need something simpler and for me functional programming is much simpler and in fact but it's kind of weird right nobody's really talked about functional event sourcing until really just the last couple of years people have started to apply this functional programming lens to event sourcing to distributed systems as a category right so applying these these really simple ideas from functional programming to this event sourcing idea goes back to what we said at the beginning right system state is a function of all the events that have happened in the system right so that's that sort of left fold idea or or the reduce idea that's really from my lens if you ask or if you read on the internet if you if you know read martin fowler's blicky or if you read you know a lot of the stuff that's been written about ev sourcing it really does have a bit of an object-oriented lens on it in sort of the popular mind share but again there's some really great writers out there right now who are talking about the deci pattern right so the decider pattern is this idea that there's really in most information systems especially sort of line of business information systems there's really only three functions that you need to write and that governs all the business logic in your whole system right and it's decide which is okay the user's telling me to change state but i don't know about that i don't know if the system's in the right state i don't know if what the user is asking is reasonable so let's you know let's look at the current state let's look at the command that they're sending us and then we'll decide okay if this is a reasonable thing we'll emit some sequence of events to be appended to our event log if it's not a reasonable thing we're going to return an error and say hey try again man like what you're asking for is not reasonable or the systems moved on or or your you're your expectations have been violated in some way so we'll give you a chance to to reconsider this this idea right so that's command that's really our sort of transaction processing moment where we can tell the user no and we can say like you know we're protecting the consistency of our system here so and that has a very it's a function and it has a well-known signature and we understand kind of what that is right yeah evolve is the second function and that's really just the reducing function that you'd have in a left fold where you say give me the state give me the next event and then i'll return you the successor state so right if you start with some initial state and then you can just process each event with the evolve in a left fold kind of way that allows you to compute the state as of any sort of point in time along your event stream so that's evolve and that's really just about projecting these events into and building state the way that we've been describing kind of the whole podcast and then the last one is called react it's a less used function but it's the idea that like when some condition outside of my world or that i'm observing is met or if some condition inside my world is met i need to take some sort of action so this allows for sort of integration between systems right i'm going to observe some upstream state or or stream of events and then when some trigger you know condition is met i'm going to issue a local command and do some stuff locally or i'm going to look at my internal state and when some condition is met i'm going to reach out and invoke some foreign command to cause change in some other system so this is the way that we sort of bridge between between these event streams and between these different systems but anyway all of that is to say you have this little thing that has three functions in it so you can build a functional type out of that thing people have called it the decider they've called it some other things too but that that little decider really encapsulates the entire business logic of your whole system and so that thing you can now do all kinds of stuff with it because this this it's pure functions it doesn't know anything about databases it doesn't know anything about distributed systems it doesn't know anything about event store db or evident db or event logs or cfare anything right all it knows is just the pure business logic of the domain of the business problem that you're solving so now you can compile that down to say web assembly and it can run in your client and you can do all your event sourcing and deciding and all that stuff in the client writing stuff down to you know indexdb or whatever or you can compile it and run it in the server as an api and now you have this really well-designed sort of stateful api that you can run or you can compile it down and run it inside of your database like evident vp so we can do a lot of things like that where we can start to build projections so going back to a question you asked a little while back what indexes do you build and can there be custom indexes well we build kind of the baseline set of indexes that i described you know subject stream boral yeah and then and in the future this is a future state of the world users can provide their own code their own deciders their own evolved functions and we can build projections on the fly as new events come in we can just run their logic you know build up the next state stick it into cache someplace and now you got sort of this perpetual userdefined projection which is basically the index that the user wants it to be right so that can run on the database side instead of in the user code and so now that's very fast to query and all that kind of thing so there's a lot we can do with that where it's like this userdefined indexing or this userdefined materialized view like you might have in in a relational database but it's a materialized view that's just a function it's a function in your native programming language that we've compiled to web assembly and and now we can run it anywhere so right yeah yeah it's sufficiently universal it seems like a new entry into the attempt to boil down what is programming to its simplest form that's exactly right follows you know in in the the tradition of the jvm and and you know llvm and all these really very sophisticated attempts to find the sort of universal computing paradigm web assembly is super interesting because it has sort of one in the sense that it's already embedded in your browser and it's already sort of in the the platform of of the distributing computing world which is the the web right so it's it's in those standards and so you know the jvm never got there llvm never got there it's this place where you can compile any language down to a common bite code format these things with the just recently in the web assembly world they've crossed the threshold into the component model which allows you to you know write one of these things in rust and one of these things in go and one of these things in c and one of these things in java and they can all interoperate with each other through the component model so the through the standard bite code interchange format so really interesting world right now in the web assembly space there's lots of really cool stuff but this idea of taking these functional programming ideas pulling from the world of event sourcing and domain driven design pulling from the world of ka and event streaming pulling from the world of web assembly and database design we can sort of triangulate on this really interesting set of ideas to make it very simple to write event source systems in the language of your choice with a very simple sort of infrastructure setup you know our goal and my company evidence systems our go is to make it so that you know line of business developers who are trying to build these sort of business capabilities these apis that encapsulate business capabilities they should only have to write business logic they shouldn't have to care about web requests they shouldn't have to care about databases and kafka and distributed systems and all that kind of stuff they should just be you know working with their business matter subject matter experts and and their product owners and they should just be encapsulating everything that they learn in code pure stateless functional code and and you know once they have that they should be able to plug that into the platform and the platform should take care of all the data persistence and all the web request handling all that kind of nonsense right so that you can sort of facilitate teams going much faster this way right let's just focus on that business logic you don't have to be the full stack developer that has a phd and 17 different things you can just write code that encapsulates business logic and you can have these really well defined apis with these good characteristics and these really nice operational non-functional requirements met and all that kind of stuff yeah that would be a nice future to get to i think that that does leave one hole that we need to address and this could almost be a whole podcast in itself so let me see if i can get let me see if i can get a quick answer from you and you've hinted at this with like we're just leaving the programmer to make decisions about the business domain yeah and you've also hinted it with we've got this ride sharing app which is just a stream of rides and a stream of cars there is a decis decision to be made in every system about how to structure your events which events do you capture how do you encode them and how do you segregate them into different streams of events can you give us some guidance on the design space yeah absolutely and that's the space that i've really spent the last sort of three years really diving into and my my recent training that that we just released with confluent so it's on confluent developer it's called practical event modeling and and it addresses exactly sort of the question you just asked which is you know how do i define what an event is how do i figure out how to structure it all those sorts of things the best thing that i found for doing that is a technique called event modeling and adam dimitri who's you know really close with greg young have sort of come up together in this world of of event source system design he invented this technique sort of related a little bit to alberto brandolini's event storming similar sorts of ideas but okay simpler and more focused on the actual system design rather than on sort of exploring the domain and problem space so it's you know you can build this event model it's a very simple sort of graphical modeling technique you have your subject matter experts in the room you have your product owners in the room you have your ui designers and your architects and your data people and your security folks they're all in the room with you sort of doing this collaborative exercise where you define out this world of of events right command event read model which is like a snapshot of state and interface and and you define out you know kind of all the interactions and the system and by capturing it sort of graphically you just you enumerate all of the different state changes in your system and so your whole system design is based around the state changes that that take place in it it's it's actually really interesting one of the one of the issues that the industry has been wrestling with lately is you know on the heels of this mckenzie paper how do you measure developer productivity how do you measure the contribution of a given developer and right mckenzie and and their team of you know crack consultants they think they've cracked this code they know how to measure developer productivity you know right away a bunch of the sort of signatories of the agile manifesto are like no you can't like we've already gone down this road several times you know how to measure developer activity not developer productivity and the and there's worlds apart and anything that you measure developers are going to game in order to make themselves seem more productive and and get the raise that they need to feed their family right so like you you can't equate productivity and activity when you've designed the system in terms of the state changes on the event model you can break this model down into what we call slices which is basically like okay here's one state change user clicks something on a user interface it issues this command that gets handled by our web tier and then we record this event to our event store that slice is a state change it has a concrete well- defined business value you should be able to after you've done this for a while your development team should be able to say like okay this is going to take us two days because we've done a thousand of these state changes in the past and they all take about two days so now you can really start to hone in on here's the cost for this slice here's the value or the business benefit of this slice and now you can start to make real business decisions around developer productivity which feature should we tackle first which features should we cut when should we stop developing you know all these really hard kind of engineering management questions that we've tried to answer over the years and we've had lots of different answers for and agile tries to handle them some ways and waterfall tries to handle them other ways by having a design and by having that design really define the value of your information system in terms of its state changes and its state views and its interactions with other systems well now you can really assign pretty concrete value to each one of these slices and you can break these slices down so the event model to answer your original question yes it contributes immensely to the proper design and discovery of what events happen and how do we group them into streams and so forth if you do my training on confluent developer it'll take you through that process and it'll show you how we designed autonomo using this this process and it'll show you kind of each step in the way of how we find out that yeah it's it's a working example so we start with that example in the very first module and then we take it all the way through so it helps to to arrive at the proper system design but furthermore by making that system design kind of the contract that we're all working cords it actually gives a lot of these management benefits right so product owners can see what they're going to get managers are going to see you know here's a clear estimation of when we're going to get each of these things and here's the ones that are done and here's the ones that we're still working on and whatever so in terms of it management and you know having a good working relationship with the business stakeholders event modeling is is the best thing that i found for both designing the system and managing its its delivery okay okay i i i feel like i'd need to go through that a few times myself to believe you but i want to believe you and absolutely no it's a big claim it's a big claim do not take my word for it please like go you know the training that i do is great adam diy trick's website event modeling. org is great you can go on there and he has a lot of resources in there but you know this is something that i'm doing with customers right now and showing them how to both design these systems and manage their delivery this way and it's it's given huge benefits so for me this is like this is it this is all i'm going to use for the my career i found kind of the way to you know it does it's not a silver bullet there's no silver bullets in engineering but in terms of business information systems i think we've sort of cracked a bit of the code of of how to quantify and enumerate the business value how to gather the requirements how to properly design out the system in terms of its state changes and how to transcribe that visual diagram into code using those techniques that i described you know the decider and and some of these other things so there's a lot of u there's a lot of value there and look it doesn't apply to every type of software right you can't write a compiler this way you can't write a video game this way you can't write a you know graphics processing engine this way right it's not a software design pattern it's really a business information systems design pattern which is a small small subset of kind of the software world but but for that small subset man event modeling functional event sourcing hard to beat those two things in in 2023 i think i'm going to leave you on that campaign slogan yeah that's it that's it functional domain modeling yeah love it bobby thanks very much for taking us through it that was a lot of fun chris thank you so much happy to join you and hey if we have to do another you know podcast to really dig into the nitty-gritty i'm happy to do it excellent thank you very much we see you again soon thanks chr bye thank you bobby you know one thing i think we will have to do a follow-up episode on is using event-based systems for building user interfaces i think it's a great way to structure uis and as i said it's how i got started down the event systems rap rbit hole i may have biases here but i love it and i'd like to find a way to share that with you but until such an episode if you want to find out more about event systems in general you'll find links to all the things we talked about in the show notes as usual if you're wondering where to find the show notes they're just down there down in your app suspiciously close to the like and subscribe buttons and the share and rate buttons all those lovely little feedback mechanisms in general so if you've enjoyed this episode please take a moment to send some feedback my way before you head off and head off we both must so until next week i've been your host chris jenkins this has been developer voices with bobby cwood thanks for [music] listening