hi everyone in this episode we're going to be starting work on our custom terrain shader for now just getting it to draw different colors based on the height of the terrain and over the course of the next few episodes we'll be adding in support for textures and some other fancy stuff let's start by creating a new shader so i'll just right-click create shader and we'll use the standard surface shader as our starting point so i'll just call this terrain and let's go onto our mesh material that we're using and set the shader for that to our custom terrain shader alright let's then open the terrain shader up and for those of you that haven't worked with surface shaders before the main point of interest here is the surf function which is going to be called for every pixel that our mesh is visible the main thing that we want to do in this function is set the color of our surface at that point and we do this using the surface output standard parameter and in particular by setting its albedo property so for example if i delete all of the stuff in here and simply say output dot albedo is equal to 3 0 1 0 and this referring to red green and blue and then save this you can see that the entire mesh turns green ok so ultimately what we're going to want to do in this shader is blend between different textures based on the height of the surface so it would be very helpful to have inside of our surf function is some value between 0 and 1 telling us how high the terrain is at that point now by setting our input struck to have a float 3 called world poles we can get the world height of the surface at that point but we're obviously going to need to know what the lowest and highest points of our terrain are in order to get that value between 0 and 1 let's start just by deleting all of this extraneous so we don't want any of those properties and we don't want any of these variables here either we are however going to want a float called min height and another float called max height we're now going to need one of our scripts to send the shade of the values for these two variables so the script that has access to that sort of information is our terrain data script so let's create over here a public float and let's call this min height all right we'll make this an accessor with only a guest property so we'll tell it to return uniform scale x mesh height multiplier x the mesh height curve evaluated at zero all right and then for the max height that will be pretty much the same thing we'll return uniform scale x the mesh height multiplier but this time it will course with the mesh height curve evaluated at one all right so we now have a way of getting the minimum and maximum height of our terrain but it shouldn't be the terrain data that is sending information to the shader because we have our text to data script to do that so let's create a new public method recall this update mesh heights and silikal taken material as well as a float for the e min height and a float for the max height i shall then say material dot set float so we'll send that value to the shader ramp in the shader we called it min height as well make sure you write it exactly the same as you in the shader otherwise obviously it's not going to work and then we pass in the min height and do the same thing here material dot set float max height and passing the max height value all right walter here let's just add the create asset menu attribute all right now we're going to go into the map generator and when we generate a new map data just at the end here we can say texture data dot update mesh heights let's pass in our terrain material as well as terrain data dot min height and terrain data dot max height now it's worth noting that these values are actually going to be correct if we have applied a full of map because then what used to be the highest point in the terrain might have been flatten down to a fairly low point so we're going to have to account for that later on for now we're just going to not worry about it so let's save this and in our terrain assets let's create a texture data asset just call this default texture and if we go into the map generator let's add the default texture asset into the texture data slot and let's also add our mesh material in there all right so now we're going back into our shader let's use the information we now have to set our terrain to be white at the highest points and failing to black at the lowest points so using our world position y value we want to get zero if it's equal to the min height and one if it's equal to the max height so let's create a little function here that returns a float that we can call this inverse lap so we'll take in a for the minimum value b for the maximum value and then just a float value for the current value all right we'll then simply return the difference between value and the minimum value divided by the difference between the maximum value and the minimum value this is assuming however that value is actually in the range of a and b so it's not less than ae or greater than b but we don't necessarily want to assume that so we're actually going to saturate this result which just means to clamp it in the range zero one so now in our surf function let's say float height percent is equal to inverse lip and we're passing in min height max height and then input dot world paul's dot y let's then set our color to be simply high percent one note if you're not used to working in this language which by the way is cg a variant of high level shader language the function has to be declared before you call it so if i were to put this function down here we get an error because it hasn't been declared yet so i'm going to put this back over here save this and go into unity and now we're going to want to generate the map and so now that we've sent the and maximum mesh height values to the shader it's strong a nice gradient from black to white of course since we are using a full of map here as i talked about we're not getting the full range of values so until we sort that out let's go into our terrain assets and just turn off the fall-off map and for the same reason just make sure that your noise normalize mode is set to local for the time being before we continue our work on the shader i want to address something that's a little bit annoying so if we go into our text editor script let's just do a little print out when the mesh heights are updated you can say debug log heights updated and we should see if we save this and go into unity then when this recompiles it will get a heights updated call however the meshes turned completely white indicating that those values have not been set in our shader and the reason for this i believe is that when the scripts recompile and we get our own validate callback which ultimately leads to the heights being updated it then sets the heights but the shader recompiles after that and so the heights get cleared as a workaround for this let's head over to our updatable data script and instead of notify of updated values being called immediately when on validate is called we're instead going to make use of the editor application update callback so we'll say unity editor dot editor application dot update and we'll subscribe our notify of updated values method to that and then because we don't want this to be called every frame thereafter we will immediately then unsubscribe it from that callback once the method is actually called so this will just delay the calling of this method until the shader is actually finished compiling so if we go back here you can see we now get the score back and the values have been set in the shader now the one thing this doesn't address is if we actually make a change to the shader itself say i just add a comment here and save you can see we don't get any call back for this and the shader loses its data so because i'm not aware of any call back for when a shader finishes compiling the only thing i can think of to make this slightly less painful is to make it that if we manually update our texture asset it then reloads the previous min height and max height values so to make that happen let us create a float up here called saved min height as well as saved max height let's remove this debug log here and before we update it we can just say saved max height is equal to max height and similarly saved min height is equal to the min height that we receive then when apply to material is called we can update the mesh heights passing in our material as well as the previously saved min height and max height values all right if we just wait for the scripts to recompile we should get our callback as normal and this should work fine but if we go into our terrain shader let's make a change i'll just delete the comments and save you can see this clears here but now if we manually update our text research that reloads after a moment all right so with all of that out of the way we can start making some more rapid progress on our shader so as i mentioned we're going to ultimately be blending between different textures but for now let's just get it working with colors since that's going to be a little bit easier so opening up our texture data script let's create a public color array which i'm going to call the base colors as well as a public float array which i'll call the base start heights so each of these floats will just determine the starting height for each color and there will be in the range 0 to 1 so we can just add a range attribute here 0 comma 1 okay and then when we apply to material we want to say material dot set color array let's call this the base colors and pass in our base color array and we'll also say material dot set float array call us the base start heights and pass in of course based our tights now what we'll also be passing in a third thing material dot set int this will be called the base color count and i'll explain why we need this in a moment but this will just be base colors dot length all right so going to the shader we can make some more variables here int base color count then a float 3 for our base colors this is an array but unlike in c-sharp the square brackets come after the variable name not after the type all right and then float base start heights as always remember of course that these need to be spelled exactly the same as we spelt them over here we won't get any sort of error things just won't work so it's a very easy way to go wrong now what we do need to do is initialize these arrays with a certain size so we're going to create a constant static int called the max color count let's set this equal to say h is the maximum amount of colors we can have and we'll pass that in there and now maybe you can see the reason for having the base color count because the size of these arrays is always going to be max color count but we're not necessarily going to have that many things in them hence why we need to know exactly how many things we have in them so what will now do in our surf function is loop through all of our base colors so for and the syntax here is exactly the same as c-sharp in i equals 0 i less than base color count i plus plus will now want to set the current color but only if the height percent is above the corresponding base start height so let's create a variable called draw strength and we want this to be 0 if the height percent is below the base start height and 1 if it is above the base start height so we can set this equal to sign of height percent minus the current base - so base start heights i so currently this will be negative one if the height percent is below the base start height and one otherwise so we want to clamp that negative one to instead be zero and we saw how to do this before using the saturate function alright so now we can simply say output dot lb rho is equal to base colors i multiplied by the draw strength but hold on there's a problem if the draw strength is zero then we will be overwriting the output albedo with plain black but we don't want this if the draw strength is zero we should instead retain whatever albedo was set to previously and we can do this by saying output albedo is equal to the current albedo value multiplied by 1 minus the draw strength plus the rest of this so if draw strength is 0 then this whole term here will be 0 and this will evaluate to 1 so we'll be setting the albedo just equal to itself in other words we retain what we had previously that is great so let's save and go into unity and all sorts of errors this is just because our arrays are currently empty so let's open these up let's just start off with a size of 2 for both of these and i'll make this say red and then blue and let's just turn on auto update and it turns out that that isn't actually what it was complaining about so let's go in here i think i spelled something wrong yes i didn't add a g in there which is very bad so just save that let's go back here and update this and there we go so our second slider is going oh point five which determines the starting height for the blue color and see if we move this down then that starts lower down and if we increase the value of course the blue starts higher up and the same thing for the red if we make this start above zero then it will move up and just a plain black will take its place okay so what if we want to add in a third color let's increase the base colors to three and we'll also increase the base start heights to three but now the shader here is complaining because our arrays have been resized so the way to get around this is just to save the unity project and then update and should be happy now so let's make this color say yellow and move this over here all right now got three colors just to quick something i forgot about you'll notice that if i save this then this of course all loses its data and if i press update nothing happens but if i change the values of one of the sliders then all our data comes back which is a bit strange the way to fix this is to go to our updatable data editor script and when we update we're going to say editor utility dot set dirty target which will just notify that something has changed so it knows to update it so now if we save and go on to our text editor and update you can see that works fine all alright so that is everything for this episode in the next one we will just continue working on the shader so until then cheers