first off i think everybody in chat right now i want to see some clappy signs for jose okay give me some clappy signs it is a full-time job to merge people's prs and do stuff and guess what they don't get paid a lot okay and you know what building something is fun maintaining something is okay listening to people's ridiculous demands sucks and i feel genuinely bad for this guy so let's let's listen to what's been going he's archiving null ls i've been struggling to find the time and energy to maintain dollar s or ls yeah i said rs that's that's rust by the way especially since i no longer use neovim as my primary editor oh goodness i'm not confident about my ability to adapt the plug-in to 0.10 and beyond so rather than let the repo silence rot and give the false impression that it's still under maintenance i'm instead choosing to archive it on august 11 2023 almost my wife and i's 12-year anniversary almost let's see any user or organization who wants to fork the project and take over maintenance should feel free to do so the majority of open issues slash pr are not actionable so i don't see the value in transferring the repo i'll be traveling for most of july and do not plan on reviewing issues or emerging prs between now and the archival date if there's community consensus on a fork i will update the readme to direct users there and mention it in the final arc archival notice commit to make users aware via the plug-in managers but not otherwise nullrs will remain as is so this is actually really something to be a bit of stood over and i think i could see this happening which is you know neovim has been iterating really fast adding apis adding new features adding things for people to be able to create a more and more immersive experience in every single one of these minor updates come with like a ton of new better more amazing features and i can totally see myself being burnt out especially as each one of these come you have new things you can do with the editor and it's just like when will one point outcome i have no idea i'm not a part of their planning but it's just like there's a lot of difficulty with maintaining projects that move on several axes and so i get this because like something like null or ls you're you're aligning two moving targets right you're alike by the way i have i i hurt my hand this weekend i didn't get i didn't get bit by a vampire that's just an ouchy i was moving some furniture and my wife accidentally crushed my hand accidentally pushed the couch when i was holding on to something and it just landed on top of it i'm just happy it didn't break my hand but she actually hurt me twice there's also one of my thumb too besides the point it's just it's it's very very hard to do this i feel genuinely bad right i sure hope someone takes this over but you know when you're when you're maintaining something that bridges the gap between two moving pieces of software it's honestly one of the hardest it's one of the hardest things ever so why shouldn't it be built into neovim neovim should not make these kind of decisions neil them should build the best language client possible right that's what they should build they should build a feature set in which adapts to all language like that adheres to the language client spec as best as possible ability to integrate with the editor pop-up menus inlay hands gutter warnings all those little things right it's up to the implementers to do what they want to do with the language client right so the language client here this little language server right here in all our null ls is taking and taking all that information starting up the required servers and then piping all that information back right that makes sense because you don't want to create you don't want to import this functionality directly in because just like ls went archiving someday some other project may go archiving right so neovim just creates all of the features possible it does not create the actual implementations for individual clients which makes perfect sense right you got to remember that there's about 30 people that work on vs code there's about five people that work part-time on neovim and their features are almost parody and some features are way ahead of vs code like you just gotta go that's pretty crazy that's pretty crazy that that just exists like the fact that neovim exists in any form at all is crazy unpaid charity has brought it all the way to this point where they've been able to pay i think it's like been like a hundred thousand dollars over the last year or two years right that's not you're not winning you're not paying five devs on that kind of salary all right so we brought on tj to kind of talk about some of the challenges of null ls so i want to mention a few challenges that anyone thinking of taking over maintenance of null ls should be aware of due to its architecture the plug-in is uniquely exposed to neovim changes both breaking and non-breaking almost any change to existing lsp related code has a non-zero chance of breaking null ls and this is not likely to change unless core maintainers tj right here you're a core maintainer that's you and you've worked on the lsp stuff too right i did and i worked on diagnostics as well okay and and this is not likely to change unless core maintainers decide to open up apis for code actions and formatting really quiet oh they're really quiet here let me make it louder talk can you talk for me a second hello hello chat turning up turnt up there you go you got turned baby all the way up to spinal tap 11. there we go i'm gonna yell again should we blow up here probably take your headphones off i'm gonna yell you've played a big role in a lot of these things you probably understand this you want to kind of give us a little bit more of like what does this mean yeah my guess is basically so i'm not super familiar with no ls internals but my guess is basically like my understanding is code actions is kind of just like a free for all for lsps right which is pretty much like you can kind of do anything you want right sometimes like oh i'm going to import or i'm going to do all these other things and some of them have like chains of a bunch of different commands that they have to go back and forth and they're like custom commands and all this stuff so it doesn't so it doesn't really like surprise me that people have trouble with like doing code action things especially if you're trying to support like what literally any lsp could possibly imagine doing now like i said i actually haven't read like nalas's in null ls implementation but like not everything that null ls has is actually an lsp right so there's like some complications with it just could run like a linter and it just like puts it into lsb or something right well the code action for like oh prettier can fix up this thing is not really like an lsp code action it's like some complicated other mix of things right so that just kind of lends to a situation where it's very easy for things to break if you want to change anything with how code actions happen because you're kind of like shoehorning all these other things into like an lsb step so what he's saying is okay what would be nicer can i jump again for a second is is is it fair to say that code actions is kind of like just a super opaque api in which yes you pretty much just send a bunch of arguments and only the thing on the other side has the secret knowledge of knowing it so you have to like it's it's per lsp super specific that's yeah there are like some things that work like generally but it's possible to just kind of end up doing random things or like registering your own custom commands that should happen or other stuff like that so the difference is like compared to diagnostics is we decoupled diagnostics from lsp specifically right now there's like a vim.diagnostics module and lsp consumes that module okay right and this is for like highlighting errors information that kind of stuff right yep so we flipped the script on that we're basically like okay cool so this seems like a broadly useful idea diagnostics right like you have linters and you have lsps it doesn't have to be an lsp right it should it can be any tool and you should be able to put your own diagnostics in stuff easily too there's no reason that it like has to be just like just that right so so that's so i think that's where what he's getting at with like this idea of if we made it more like diagnostics and we had something like vim.code actions you could hypothetically do the same idea for this or for formatting vim.formatting maybe there's some way that we need to be able to like chain multiple formatters together change ranges of formatting or it's kind of a complicated question right because you need to order like which one should go first or especially yeah typescript land you have like eight different tools running on every buffer right like i don't know why you have to have eight different tools it is a good point that the problem that the the null ls is also kind of you know doing here is that we also have an environment that's highly fractured because you have yes you have you you do genuinely have several tools running all doing orthogonal things to your javascript typescript which yeah they might be fighting each other or producing like not the right thing if you run them in the wrong order right like literally it's actually really really true i'm going to show you a little example of this let me just make sure that this is not uh here we go i i wish i wish i had something up right away let's just go to let's just go down to the test so there is something that's really really simple that you can do that just proves this do a try catch and have it such that you cannot have any empty blocks and then try doing something like this and try going you know like ts or it's like es lint it's something something ignore next line something like that yeah and then try running it it will pretty or prettier will reformat this line in such a way that sometimes i forget if it's this one or if it's with the for loop or there's there's one that will cause it such that you can't actually ignore this line anymore because it will reformat your line and so you'll get into this position where you actually have to rewrite your code because your formatter your prettier will reorient it and then your linter will say no it's broken and then you'll reformat it to put your comment in the right place and then it will actually just struggle with itself and fight back and forth yeah so like this kind of problem will get blamed on null or less because people don't understand their tools right so they'll be like it's no less fault and it's really like well actually it's that seems like a typescript problem like i don't know what to tell you but like that would be frustrating yes i actually ran into this problem legitimately in one of my it took me like 20 minutes to get it to be correctly solved in ci because it would not stop flipping a couple places because of a change to prettier and it's just like this is super annoying this is just like the world's most annoying problem i've ever seen in my lifetime yep so that's basically like so the proposal would be right like how can you register things that are going to do formatting and like put it in some way that like users don't end up running them in the wrong order and all this other stuff right and those are difficult questions to ask that are maybe not as like high value as adding diagnostics as a module right because like you can just you can just write if what you want to do is run three different tools on your typescript thing you can do auto command star.ts buff right pre and then write a function that calls i'm going to call prettier i'm going to call you know eslint and then i'm going to call this and if your company runs them in the opposite order then you just move them right like it's actually not that hard if all you want to do is run these or like write a command that does these every once in a while right so yeah to me it to me it sounds like a problem that neil them can't solve because you cannot predict the ordering and the worst thing you could do is give some really convoluted you know api in which you can add in priorities and then now you got this whole like problem you have to deal with and then it's going to cause just a whole nother set of priorities of people effectively doing like z index 10 000 on you and then you're just like well sorry they went with bang important and now we don't know what to do yeah so i think like like it's a reasonable request right like from a side that like it would be nice if we standardized on some better way to do these but it's not at least like i said i don't know exactly the problems and all this is happening but like it's difficult for me to predict what it would be in the same way that we predicted for diagnostics and like how how it was like very clear and there was also no other way to like do it right because like diagnostics is like an editor thing how do we display this how do we like standardize ways for things to display that makes sense but how do you handle formatting that's like a kind of difficult question over ranges we already have some built-in ways to do formatting right there's already format expression there's already some of the these other settings that you can do to like manually do it but what people want is like auto magic formatting of just this perfect range for these other things right so that's it's kind of it's i it seems harder to to solve for me yep all right let's go to point two the null ls repo contains both the core null ls code and a large number of built-in sources almost 300. i don't know what that means but that sounds like a lot so exposure to upstream changes is high oh by sources null ls is a linter among many many things and so it must have a bunch of different yeah this is the thing that i was talking about earlier that when you're caught between two moving targets like that is one of the worst possible lives to ever be in because you're just constantly fighting one side all always yeah and i don't really know what the sources really look like like i said but i know that you can just type like oh the formatters that i want to run is like nala last dot linter.es lint and it will like it knows how to run es lint or like pretty or d or things like that right those are all different things that you just have those are those built-in sources for different tools okay i mean that makes sense this this is because people complain when they have to install two plugins right everyone's like oh i can't believe that i had to install two plugins yeah right but then you got it on the other side right so then you just basically said i actually don't care about maintainers i'm gonna make them have to do everything and manage all of them inside of themselves instead of being able to like more easily distribute like the workload of those different things right yeah so i'm actually finding a very similar problem right now with because i've been i i've i wanted to try out lsp zero and mason for a year and just like yeah just like what does the automated path look like is it a very viable path and with o camel yeah i can't find any documentation or anything that will change what it how like how it chooses what to install so i get the oh camo 5o lsp but okay that doesn't you know you you can't use that on certain sorts so then you get into this weird thing where you're going to switch you have the same version yes and so i wish it could use my switch as how it chooses the lsp because then i can install each lsp for each switch and then it's all beautiful and everything works together but it can't do that because of the automated process so it's like well now i'm in this funny spot where it's like this is the this is the limitations of having an automated pave path because it doesn't understand the thing that's happening yeah you should just do opm install in your switch and then tell like your lsp setup to look for okml lsp server right like that's what that's what i would do yep okay anyways let's keep on going there's no easy solution here i've thought about deprecating all built-in sources and urging interested parties to maintain bundles of null ls sources for different languages ecosystems but most part the willingness hasn't been there yet you there's no way you're going to inverse this problem like prettier is not going to maintain their own version to illustrate the scale of the problem you could do like like another less dash ts repo or something like that right where maybe someone like works really hard to just make the typescript ones work i think that's kind of the proposal yeah but the problem when someone has to actually do it yeah you have to get 300 effectively at most 300 people to agree to this at least you're gonna have one person trying to maintain all three you just recreate the problem but you're distributing the problem as opposed to and it makes it hard to manage like if you wanted to change something in null ls what are you going to do like now it breaks that other plugin so it's a difficult problem for like any kind of thing that does this kind of tooling yep oh yeah because then you effectively you've just recreated the problem he's talking about for neovim you've now just created in all ls because now when you want to make a change guess what yep you're now breaking everybody else yeah users have infinite variety of configuration environment needs especially in complicated ecosystems like python ain't that the truth ain't that the truth as above this doesn't have any easy solution but but the issues help illustrate why the current approach isn't sustainable a large percent possibly a majority of users use null ls via neovim distribution lunar van lazyfim etc which adds indirection makes issues harder to debug absolutely i think this can be solved if i had more discipline about directing users to these distributions to report issues upstream first and only come to null ls repo once they're confident the issue can be reproduced independently but it's a constant source of friction what how do you feel about a lot of these uh like these things i have my own personal opinion i'll give it afterwards but what's yours on lunar vim lazy vim chad vim well i'll just say the first thing is like there's no chance that just because you tell people to report issues upstream and get a reproducible bug that's standalone there's just no chance that it's gonna happen it's still gonna be a constant source of friction and you feel like kind of a jerk like because you're basically saying i'm not gonna look at your thing i just go talk to somebody else and like even though you're right it doesn't matter you know yeah perception's still nine tenths of the law like even if no matter how right you are you look like you look like a shirt yeah so that part kind of sucks about it so my opinion on distributions like more generally is there's a range of like distributions some distributions are much better than others just like there's you know software that's better than others i think some of the newer strategies are getting better some of the people are thinking oh like maybe we should really think about how can we make sure that we're just like following the rules of how standard neovim does things and then like extending that right so that you can think of oh i see that i want to do this and now like the way that i would do that is the same here and there so then i can do other things i think i think like i've liked what i've seen from lazy them mostly because folkit does like a really good job of thinking about these kinds of things and it's really easy to turn things on or off but it it is really difficult like in the context of this article to ever have any sort of like independent reproduction right because they don't know how to rebuild their setup anyways yeah right so so it's not like so if you ask for a minimal repro they're like well it's a lazy vim at this version and on my computer and you're like well that's like man that hurts thank you for reporting this well first off bulky he's really really great so anything funky anything funky has ever created has just been fantastic so a big fan so i've never heard of lazy i've never tried or really heard of lazy vim other than like in passing so it could be cool to explore one day but my general take on these distributions are they're a stop gap right they give you what could be available but then it's someone else's keybinds what makes sense in their brain and often would make sense in one person's brain doesn't make sense in another person's brain and then they do things and install it in certain ways that are maybe different than how you would do it and you got this whole problem where it's just like you're trying to conform to someone else's idea yeah i just find them very very hard to to use beyond just like oh this is what neovim could be like cool yeah i mean that's why like i i like at least recommending that people explore kickstart end them right which is one of the projects that i've helped with is because like the goal of kickstart is it's basically it's basically one file it tells you everything that you need like we literally every single line is documented of what's happening you can read it top to bottom and basically like understand exactly what yep what it is right and so you can lit like it literally tells you everything tells you what what's happening what we're doing and like it's all the way done with a bunch of documentation and 500 lines right which is like that you could sit down and do this in an hour and understand what's happening yep and then we have like a few examples of how you could start branching off into like adding other plugins or adding other you know adding other config so like i think at least it's worthwhile for people to explore something like this maybe you still want to use a distro like that's totally fine but you know the nuts and bolts then at least with the district then you can go okay so this is what they're doing underneath the hood they're doing these x things i can figure this out yep and so like kickstart is made to literally just be forked like you fork it and you do your own stuff with it afterwards or you just copy it out and put it somewhere else like it's that's literally the goal of it so it's not like a distribution in the same way so that's kind of that's kind of my perspective i think a lot of the distributions actually have decent like docs and ideas and things inside of them but a lot of people pick the distribution because they say i don't want to spend any time doing that and so then they don't read those anyways which like that's that's where we come back to that pde right that personalized development environment where i think like it's not it's not wrong to use a different editor like you can still be an awesome dev and use other editors there's literally nothing about any of them that makes you like a good dev or a bad dev i think it's more about like personality and do you enjoy some aspect of making things personal for you and like exploring those things if you do then any of them could be a good choice and if it's not then like you might want to try something else that's fine it's like it's cool you know they'll still love you all right here we go just like the milk man yeah just like the milkman probably your father still loves you okay anyways number five i did not foresee the that built-in sources would be far and away the most popular feature of the plugin so many parts of the architecture are not as user friendly or flexible as they should be in particular it should be easier for users to write maintain and customize sources both on their own and to share but it's hard to make significant changes now without breaking things yep classic i mean this is why neil them has so many things that you have to think about long before you actually release it because this is this is the exact this problem this happens yep definitely taken together these issues may justify a total read write similar to the jump from neovim lsp installer to mason neovim the current repo structure by the way mace it's pretty great i mean i like the idea of mason again oh camel part was a little bit hard but everything else is pretty great the current repo structure is especially hostile to semantic versioning which i think is a big leap forward for users and maintainers for my part i am agnostic about the right path for null ls from here on out but i'll mention that i'm skeptical that feature parity and sustainability can be achieved without some level of buy-in from neovim core so do you think that there's a do you think that there's something that neovim core could do to make it easier for null ls or is the problem really the ecosystem or just really trying to tie together x amount of sources yeah it's it's hard to say because i don't know exactly the parts that have been breaking like across neovim versions and also you know nola last started like pretty early in the lsp journey you know like 0.5 0.6 and like the lsp system itself has matured a lot since then so there's a good chance you know you'd probably end up making different decisions about how you architect the whole system or the ways that you might add configuration points or different things like that right that may make it so that actually some of the you know sustainability things have been achieved over the past you know three releases i so i don't actually so i don't actually know without looking in particular obviously in general neovim's like philosophy is interfaces over implementations right in the sense that in core we like to expose interfaces so that people can extend the editor in a way that makes sense for them and that provides a much lower maintenance cost for like neovim core right so as we've talked about before we don't have 30 full-time 35 full-time you know microsoft employees working on our editor just directly only on just the editor and like we don't have a 30 million dollar budget or things like that so we can't just say like oh this feature would be useful for some people we will include it right we have to think about what the cost is and like the structure and just like as mentioned before when you add something people use it and abuse it and so then you have to think about how can you prevent people from accidentally shooting themselves in the foot so i i all that say is basically i don't know of course that's not that's not a very fun answer to the question but basically like with at least in my opinion we're generally open to finding interfaces that work especially if we can they don't require huge amounts of work for core and we have a really good justification for that yeah okay how many people right now actively maintain neovim that's a good well it kind of depends what you mean like actively maintain i don't have a good i don't have a good grasp on like how many people are working on it like or like working on apr you know let's say every week that's kind of hard to answer okay how many people would you say work on neovim developed by x amount of devs what would be the general accepted answer i don't know that's a good question i haven't really ever thought about it in terms of like people working on core directly there's probably like i don't know we'll just say tanish maybe but like they can't work on it full time obviously right so there's it's not like it's not scary work yeah right and it's also like oh something came up in my life so i have to pause for two months or something you know so you're like okay cool so so it's really hard so like you wouldn't you wouldn't be like oh it's a 10 person company you know what i mean like most of the time for in terms of like we have funds right now to pay people and like usually the max amount of people that we pay to work on neovim a month is one yeah so how much what is neovim's budget i know it's all open it's under that open whatever do you do you happen to know off the top of your head you'd have to check like open collective what what it is at right now like in general we don't we don't necessarily have like a budget we just like if someone's gonna work a month full time then we pay them for a month basically yeah and it's a fairly low salary to compared to what they can get considering the work they're doing yeah and like no other you know it's just like writing them a check it's not like they get you know insurance or anything for the months no 401k match no stock vesting so it's it's it would be a steep decline for lots of people working in tech yeah it's for experience it is for experience though it's true i mean it's money still for working on open source which is pretty good yeah yeah okay it's just it's those are interesting things i think a lot of people don't think about open source in that in that sense where it's like you got to remember that there's hundreds upon hundreds of issues that are just not issues right they're just not issues but they get filed someone has to say something someone has to take the time to understand what the person said then respond to that that's like a full-time job like that's like that is it's very very difficult then we have some people who are who like actually volunteer a lot of time to basically just manage issues and like reply to people and i'm like wow you're a hero yeah i mean that's but you do yeah i know it's it's it's incredible what can be done and so i'm always very impressed by neofam it's sad that you see this right here because obviously i mean this is not surprising at all open source is a pretty brutal place it can be difficult yep do you want to maintain issues is that is that what would you you'd like to do no would you like to also be called an every day no i don't want i don't want those two things in my life well guess what open source is for you come on in and you can do it for free anyone can do it now yeah yeah well thanks for watching things on this appreciate it yeah i think it sounds like you know there's a path for it's not like nalalas is getting deleted you know i think there is potentially a path forward or someone you know can offer some idea for for a rewrite you know what i mean and i think that but this is why so actually this is a great example of like when people say why doesn't court just add something this is a super great example because people have been saying for a while like oh no the last should just get out of the core and then it turns out oh hey there's actually some fundamental flaws that make it not very sustainable and so when people say well i'll just add everything to core or just do it today and just make any of them super easy to use and simple so that it's really easy for everybody every situation every time no matter what no matter architecture plugins language right like okay sure sure that sounds good except then sometimes you're wrong and then you have to backtrack and then there's breaking changes yeah right or a huge maintenance cost so that's yeah you could just have 35 engineers plus 30 plus million dollar budget a year full-time benefits that's the other option that's the other option too yeah exactly so okay in other words open source is extremely hard you have to choose you have to say no more than you say yes because every time you say yes you're saying yes not today but you're saying yes for the lifetime of the software because it will continuously come up over and over and over again yeah all right hey thanks for this little this little talk appreciate you no problem tj i hope everything goes well with nola and jose is really nice i've had some interactions with jose before and so hopefully it all goes super great okay if you want to do things this is a great opportunity hey wanna start an open some tragic hey there you go this there you go here's one this is right in your lap yep neovins ready for you to come and contribute also find out you can do your rewrite and explore even if it fails and it only works for you it's good yeah yeah honestly that is good i try to convince people to do that all the time does that learning is does not mean you accomplish someone something that's actionable learning sometimes is just going through the process of doing something even when it fails i mean look at haskell like they're only learning they've never they've never even built anything so it's like they're just there learning and they seem to be having fun i mean except when they talk about their experiences writing haskell usually it's upset and people leave in the community but like they're having fun yeah they're writing papers yeah i think back to school i think wow my favorite part was writing academic papers i just wish i could do that for a living research i'd love to do that my life side effect free sounds amazing honestly i just want a heater in my office that can't do anything all right now that we've sufficiently made somebody angry somebody's seething right can't wait for these comments the comment gin the name is the haskell legend