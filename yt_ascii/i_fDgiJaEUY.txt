pron i'm coming for your article my lovehate letter to co-pilot i don't know where i'm at on my lovehate i'm still actually completely on the fence with co-pilot right now i'm i'm going back and forth constantly so maybe i do have a love and a hate for it i'm not really sure but i i i i want to see your thoughts on this because man i have just so many things i'm not really sure just as post malone expressed a lovehate relationship with alcohol i'm here to share my mixed feelings about co-pilot this is the most already this is the most zumer ass article i've read in a while the bittersweet tool has been in my toolkit for a while despite its frequent frustrations i find myself relying on it more than i'd like only after disabling the ai did i notice the changes in my programming habits due to its influence yeah i have someone that i i i really want to i'll let you cook for a moment but i have some that i've noticed that i'm kind of really coming that i'm realizing what is happening for those unfamiliar with co-pilot here's a quick introduction co-pilot is a tool that attempts to understand your problem and then searches github for matching solutions and suggests it to you yeah for many let's see for many is this tool something they love as they can create the solution faster as they can just wait for a suggestion to be recommended and apply it as fast as they can and then move on with their life went up again using co-pilot and chat gpt i was amazed at how much faster i could create things however i haven't anticipated how it would change my approach to system creation or how it might affect my perspective during development and how it made the engineer within me smaller okay okay interesting interesting i like where this is cooking as software engineers developers or programmers our role is not just to understand the problem and find a solution but also to rite good software this means while certain solutions such as using clone and rust may technically work there may not see that they may not be the best practice for example it's generally advisable to minimize the use of clone in order to conserve memory dude lean in the clone okay you know what last time i checked f your b borrow checker f your lifetime just go deep on that clone anyways if you're unfamiliar with clone it essentially copies existing memory into a a part of memory and provides a new reference to this new memory while this might not sound problematic it can be quite detrimental for instance if you clone something that is a 1 gigabyte in size you allocate another gigabyte within memory yeah this could likely be avoided by properly utilizing reference and ownership rules another issue is that you could potentially overload the memory causing your service to crash okay all all very all very fair right all very fair all right co-pilot might even suggest using clone we could apply the suggestion and proceed however instead of doing your job or our job we may end up relying on solutions provided by an ai that might not understand the real context this can be problematic i've noticed this happening when i first started learning o camel there were instances when i waited for a suggestion even though the solution was just two lines of straightforward code one instance i can recall is that when i was parsing a url co-pilot suggested using a rex which is not ideal due to its potential for bugs instead i solved it using the following code nice i' i'd use a redx too bro removes the engineering out of software engineering one of my major issues with co-pilot is that can diminish our problem solving skills instead of analyzing a situation finding a good solution ourselves we increasingly delegate this task to ai over time this could diminish our engineering mindset i'm just trying to think about this it's almost like reps matter reps do matter reps most certainly matter especially in programming man i go back and forth on this one so hard because i really don't know if this is bad or if this is good i will say that the type of code i write is different if i do and don't use co-pilot i find the code that i write i they they're they're they're different enough they're substantially different just because the the rate in which i write sl the rate in which i think and how i come to my conclusions are just different and so it leads me down different paths at the end of the day is it worse is it better and i have a hard time with this one i think for things like obviously summing an array in javascript there's no sum function so you can't just go like sum like right it it doesn't have a really great standard and so you have to write a sum array function who here has written the word sum or who's written the function sum like 9,000 times going either with reduce a for loop whatever it was over the years you've probably done it a kajillion times in javascript right so it's like hey can co-pilot just write that for me okay cool right cool but the problem is is that we don't just write some functions that's where my this is where my whole tricky thing comes with my mindset over this which is where where is the line that you're effectively just operating on a primitive and you just want co-pilot to fill it in such as the sum function versus actually making a critical piece of logic that's going to dictate part of the shape of your program which actually as anyone who's written enough code knows that small decisions do add up quickly when it comes to larger programs like i wanted to like my big thing is is that my big kind of like set in my mind is that co-pilot automates the tedious tasks right the things i don't want to do that's kind of like my ideal state in my head but again programming is not just simply removing the tedious tasks and therefore i get to solve and write good code the problem is is that those tedious tasks can often have a disproportionate impact on the shape and the way we write code and so i have this really kind of like this lovehate balance between it where i find it i i i write software and i'm not sure if i like the software more right i'm not sure if it actually is buying me more time sometimes i almost feel like using co-pilot for this specific case can be a fan bargain meaning that in the moment what i'm doing is actually like okay this makes sense let's use this let's use this and then afterwards when i kind of realize as i'm going through things that i realize i've kind of maybe gone too fast in these type of things then i end up troubleshooting some things that i should not be troubleshooting and i end up writing code in a specific way that may not be the way i want to write code and then all a sudden i'm kind of getting really really upset you know what i mean and so it's like am i handing myself a fian bargain i might be for instance when we encounter a bug our first instinct might be to ask an ai about the bug rather than trying to figure it out ourselves luckily i do not have that as a first instinct believe it or not at this stage the ai is less capable than you you may find yourself in a loop where you keep telling the ai no this doesn't work and the ai keeps suggesting new code ironically the solution could be as simple as changing a single letter in the c as we learned with the whole call ball thing it could be literally a period another issue is that you might create a solution that although functionally is subpar due to not leveraging your own skills i will say on this first one the big danger with this one this is my like huge danger of programming right here is that debugging i consider to be this is where me and b uncle bob are vastly different i consider debugging to be a chief a chief skill of a good programmer i think that if you are offloading your ability to debug or to to get errors explained to just constantly rely on something to explain an error i think that you are robbing yourself of like the like the single best skill that takes time to like develop it was one of my first lessons i learned from a professor which i thought was really really smart i can't even remember who said it i want to say ray babcock i'm not really sure dr ray babcock but anyways i forget who even said it but something along the lines of cs 101 is here to teach you to program but more importantly it's here to teach you how to read errors and i was like huh okay okay and i've had that kind of in my brain for a long time good old babcock yeah i can't remember if it was ray babcock or not it could have been denby starky it could have been a few other people if you're called ray babcock you don't need a title like phd it's a fact i don't know it's very interesting it's like a very interesting way to put it which is that learning to code is equally as like equally required to learn learn how to read tobg to error messages and how to how to work with errors is is a very kind of like eye openening thing for me and that's one of those things that i do worry about when it comes to this is that we we also live in a completely different world i was building little cli programs to print out a house whereas now we're hooking up 10 disperate tools to make a website and somewhere along our plumbing something has gone wrong and we just receive generic error from library right and i think it's very very simple to be like i don't understand why vite won't build this chad gpt tell me why vite won't build this it's it is a different level of debugging fair very fair wasn't that just a joke about semicolons absolutely not the man was entirely too smart the man was like a a sigraph champion anyways i believe it's common for us to become complacent when ai becomes a significant part of our development process i experienced this myself recently when i was building a as sasl authentication for postes in oam and encountered a tricky bug instead of manually insert inserting print statements into the code to debug i copied the code and the erir and handed it over to chat gpt the solution came from a combination of reading squeal x code and realizing that i had overlooked a small detail we stopped learning oh this is an interesting take this is very interesting i wonder if this is i wonder how much this is actually you're so focused on getting to there's something actually there's actually a really super super interesting thought here which is that you hear it all the time i just want to get everything out of the way so i can complete the project that's like that's typically why people use like say vs code why they you know why they want to just use javascript for everything they want to be able to use all service third party services to just solve everything underneath the sun right like i'm not even disagreeing with those things they do truly remove an entire set of problems so that you can just solve the problem that you're trying to solve right or you're trying to build the thing that you want to build but part of the problem of learning is that learning is not the end state what i mean by that is that let's say you try to build something it fails you try to build you try to iterate on it it fails you build one more thing it fails you build one more thing and this thing works and so you take this and you write a tutorial where was the learning not really much learning went on there right not much learning went on right here this is where everything that was good happened right anyways as a software engineers we continuously continuous learning is essential we often learn by problem solving addressing issues and devising solutions however overreliance on ai and our development process can hinder this learning we may apply code without fully understanding it which can be detrimental in the long run i think really experienced programmers using co-pilot are much less likely to do this does that make sense i think that makes i think that makes sense is that i think to proportional to your familiarity is the likelihood that you will apply code without some level of change from co-pilot just because you used an ai to solve a bug doesn't mean you should rely on it every time a similar issue arises this could be a significant issue especially there's i told you i was going to have a few a few alerts go off flip take that alert out don't let people know i'm using windows to stream this can be a significant issue especially for new developers it's crucial that we will be able to feel the code we are working on programming is not just understanding code it's about connecting the pieces in a larger puzzle to build a solution and it takes time to understand this and it's really important in the beginning of our career and also why learning programming takes time yeah i would say it's something like that like my ability to to look at a few print statements and deduce what has happened has greatly increased over the course of the last 10 years and and it's something that i i i absolutely love that experience when i can look at a few things and go okay my understanding of the program plus my understanding of these print statements i can now walk through all of the code and find the exact spot that things are going wrong i just i find that very fun i believe we learned faster with ai see that's the thing is i'm not sure if this is true i don't know if this is the same thing like that's the problem is is that i'm not convinced that learning is short cutable i i really don't know about that like some of my greatest learnings have been me painfully thinking about trees especially with avl and things like that where it's just like i had to just absolutely think on my own and until i came up not with just the solution but how i derived the solution and so that way i don't ever have to think about the solution again i know how to derive it like internally at the most like in parts of my body it's just different it's a fully different experience bad take prime not going to lie access to information easier is obviously good for learning notice i never said anything about that notice none of this classic youtube l notice we never mentioned any of those things notice that i talked about the process of learning and how good it is to struggle being able to derive on your own means that it's just it has literally deepened within you it's harder to forget it's you understand it at a more fundamental level it's like deleting from a binary tree a binary search tree like to understand deleting from a binary search tree if someone just says in order predecessor or in order successor you may have a certain view of it all but if you understand how case one deletion works which is just deleting with no children and case two deletion which is deleting with one child you really do understand case three deleting with which is with two children and you can kind of understand this at a very deep level and you can actually see the swapping and you can see how it works and you can see how it deletes like you get it at a fundamental like level and if someone were to just simply tell me that if the information was fully available and i could just read it i would get it right here but it would go away so easy and i wouldn't like know it know it there's a there is a fundamental difference between knowing it versus something else right there's there just is right you can have all the surface level knowledge you want right i can tell you right now it's called like in other words i i i often use the phrase like the hidden know of something right we all know how to cook an egg you take an egg crack it into a pan put enough heat on there until it's thoroughly cooked or cooked enough to the point you like it take it off the pan and eat it right that's easy none of us like there's no extra information here that's needed right but there's the hidden knowledge of being able to make a good egg which is just through experience and doing things wrong and you can't there's no abundance of readable information that's going to teach you how to avoid raw dog and an egg to the perfect amount right there's there's like there's this there's this thing that exists it's the hidden knowledge of a process and so i know people love shortcuts they everyone wants a shortcut but hidden knowledge is just almost impossible to get via a shortcut imagine having the bite string from which you need to parse values ideally you would do this piece by piece extract the first value printed then move on to the next value repeat this process until you've gathered all necessary values it's common to print the initial data for transparency however as ai becomes more integral to development and begins to handle such tasks for us there are situations where starting from scratch becomes challenging due to our reliance on these tools and we end up stuck one day we may face a problem that ai can't solve and we might not know where to start the bugging this is because we are so used to having someone else handle it for us this is why i always advise new developers to try to solve problems themselves first before asking for help good i want to let's see i want them to understand what they are doing not rely on me i do like that i don't think we're just argu we're literally arguing semantics at this point i don't think it's hidden knowledge i think it's personal touch when you develop and do it yourself over relying on someone to tell you no i mean this is literally arguing over semantics semantics is we're both saying experience okay uh rick and gracie talks about hidden jiu-jitsu the innate knowledge of how to connect all things you know which is transcendental and not communicable yeah okay so it turns out me and the hoist the hoist gracie family have have something in common which is this hidden knowledge right i do think that it is very very very important to like think about that and that whatever that process is is extremely hard to get right it's very very hard oh good luck on that one i if you you if you already are at the national level you already know what you're doing go do it anyways yes books and teachers are a shortcut to learning absolutely you can also use ai as a teacher but if you use ai to do the task for you it's different right i don't really think we become more efficient i also don't believe that we necessarily became more efficient by using ai often we might find ourselves stuck in a loop waiting for new suggestions repeatedly in such situations we could likely solve the problem faster and perhaps even better by using our own brains instead we often associate efficient programming with the ability to produce large amounts of code quickly however this isn't necessarily true great statement by the way a single line of code can sometimes be more efficient and easier to work with than 10 lines of code ai is effective at generating boilerplate but often foils fall short in providing quality solutions that's what kind of what i was talking about when it comes to like shape of program i find myself changing the shape of what i write because i can write code maybe faster i'm not even convinced i can write code faster but i can use less mental effort to do something if that makes sense maybe that's better in the end but right now i'm not convinced i've critiqued co-pilot for a while but i it's worth mentioning that it's not necessarily bad to use it providing you choose the appropriate time i use co-pilot but only when i'm working on simpler tasks that can easily it can easily handle like generating boiler play code however i only enjoy it occasionally i've noticed that it's crucial not to rely heavily on such tools so doing let's see as doing so can lead to negative habits like waiting for a suggestion and hitting enter repeatedly to find a solution dude the co-pilot pause is a real thing co-pilot pause that was there was a video recently that we watched about this and the co-pilot pause was such an amazing observation i absolutely loved that hold on beautiful wife beautiful wife take it out flip flip take it out hello beautiful wife ai can pose a significant challenge for new developers it's tempting to let ai dictate the path to solution rather than using it as one of the many potential paths this often leads to developers accepting the code returned by ai without truly understanding it however understanding the code is essential for new developers i hate that i feel like a boomer i hate okay can can can i just take a second here i hate the fact that if you say that you're not sure about co-pilot people think you're just doing a boomer take that you're an ai doomer and all this crap it's annoying right because how can you like how can you objectively measure something if not using it means you are means that you are unreasonable effing reactionary goons i know and so there's something that's really frustrating about that that's like how can you objectively measure something if you're if it is considered faux paw to have a negative opinion about it my the problem is is it's an npc take see typically the funny part about this is that people who say this are the ai pro people who are literally the biggest npcs of them all like dude this take is such an npc take that it's painful it's a true npc take where'd you get your opinions from ai what's ai the world's greatest npc it's literally a median you got an you literally got a median answer out of you you got the most middle of the road generic oatmeal answer possible such an npc take sorry devon i saw deon in here devon the long i'm sorry that your life sucks now i think it's i i think the empathetic explanation is that people feel like ai empowers them and they don't want that to be taken away so this is where i typically say that empathy makes terrible rules sympathetically i look at people who use a lot of these texts and watch them struggle with very simple operations when they aig is around the corner it [music] um the problem with the pro the problem with empathy is that you make rules because you feel like cuz you know like who here would stop pain if we could everyone would say yes and so empathy typically makes bad rules because you if you're truly empathizing with somebody you are feeling their pain which by the way is quite arrogant of you quite the hubris by the way to have to say you can empathize with people but b it means that you're willing to make rules that are probably disproportionately affecting your current situation or the one that in which you're having empathy for where sympathy tends to make better rules here and so when i look at these things i don't look at stuff because i'm like oh i don't care that they you know it's not it's not i care that they feel good in the moment because they feel like they can make real progress what i want is them in 5 years to be really good at what they do and so the sympathy of the situation is that i feel that it sucks but if you want the more important outcome you need to choose something that is harder right and that's the harder thing is you have to make the decision now so for everyone that's new you can choose whatever you want choose to use co-pilot all you want don't ever write a line of code that you don't have to at any point go for it but i want to let you know that you you should be solving the biggest problem in your life which is being valuable at what you do being good at what you do being trying to actually make it your own and find the joy and longevity in it because you're going to be doing it for a long ass time and so however you think you can solve that problem the best you should do that my little word of wisdom that i personally found to be good is that in the struggle i've become significantly better that's it so you can choose how you wish to solve your own problems and if you also just so you know if you think that here's here's like a kind of an obvious reason why this exists just just apply a little bit of critical reasoning just for a second why would just just hear me out on this one why would microsoft give co-pilot free to every student answer that question if you can't come up with a good ass answer for why that makes sense like chat gpt makes way more sense than co-pilot you may not realize this but you're the product dog and not only are you the product you're the future customer customer of yourself not only are they going to use you to train to get better they're going to then make you pay because you effectively become very dependent on said tool i'll give you a quick little quick little quick little story right here quick little story i've just started to kind of get back into go programming i've been doing it for a few months and over the last few months everything i've done thus far have been using copilot about a week and a half ago i just simply started my new pc and i just forgot to sign into co-pilot like literally that was it i just oopsy daisi that is it in fact look at this uh let's see neim right here if i go here and go to a knit. lua no not here lazy a nit right is it in it yeah yeah yeah if i go like here and i look at my undo tree 14 hours ago is when i just removed co-pilot for my list it's it's just been there i just i just literally forgot to sign in like that's it i just oopsy daisi and i just forgot to sign in that's it right and i did this about i did this a i did this a couple weeks ago right or i did this about two weeks ago and so hold on let me get right back up to here all right and so doing so i started writing good morning bco i started writing a bit of go and it's actually was this part that really opened up my eyes i started writing this part right here and i realized how many little holes i had in my understanding i could totally write this code with co-pilot i would have written it much different by the way but i also didn't actually know how to write it i knew how to read it i didn't know how to write it which becomes this very interesting world that you live in is that you learn how to read code with co-pilot you may not actually know how to write code and i realized that even though i've been doing go go for a couple months when i turned off when i turned off co-pilot i found myself feeling really weak like i was struggling and i was like wait a second did i just am i a readon go programmer oh i'm a readon go programmer my code that i'm producing is in the shape of what what co-pilot wants it's not in the shape of what i want which i am pretty i'm in the end i'm i've been programming for a long time i'm a good programmer but due to the fact that i'm a readon programmer in this new environment i'm producing middle of the road 50% code cuz i can't like i can't write it myself and i became a co-pilot andy anyways just this kind of thought process that i've been having and i've been thinking about and i'm not really sure exactly how to it i can just tell you that since i've turned it off i felt a bit of relief do you know what i mean i felt like a relief and the relief has been that i now can write go even though i've only been writing go now for like two days without co-pilot i feel way more like engaged with it i feel much better with it i actually feel like i can think about solutions much better now i feel like my skill in just reasoning about go code has gone up a ton and so it's like me who's programmed for damn near 20 years 15 years professionally if i can get bamboozled into realizing i didn't even realize how bad i was at said language due to co-pilot man all of a sudden it's like right now i am i'm having kind of like an existential crisis because i kind of realized maybe what has the last 6 months done to what has been going on inside of me so it was a skill issue it was a skill issue but it was covered because there's somebody else's skill that could have covered up for me i don't know it i'm i'm really like like i said i've been feeling a lot of relief from this and i've been feeling very confused about this all okay ausc skill issues one last thing before we call it a day damn it netflix you got to go upwards the name is a little disappointed by netflix stc but hey i'm really happy that i've been off co-pilot and guess what i actually have perceived i did perceive a momentary slowdown but i'm starting to feel like that momentary slowdown has largely left i'm starting to feel like i'm you know sometimes it's good to have leg day a jen