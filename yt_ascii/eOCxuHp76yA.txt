all right turbo repo is a high performance build system for java script and typescript okay hold on i have to get that out of my mouth you know i i said javascript and just right when you say that i immediately tasted like stale chips it was like like they're kind of wet it's disgusting i don't want anything to do with it we're reimagining build systems taking inspiration from tools like buck and basil is it buzzell or is it basil is it bazel i tasted regret mostly it's what the form of regret tastes like is eating stale chips at night in your bed okay that is the feel or is the is the taste of regret buzzel okay it's buzzell to make it accessible for everyone at the heart of turbo repo is a very simple idea never do the same work twice i like that we accomplish this through incremental builds parallel execution and remote caching parallel execution is not doing the same work twice just throwing that out there but i like i like where this is going i like what's happening in npm run build yeah npm run build cash got em npm run build cash got em wait why is this one faster than these two oh 38 minutes and nine seconds oh i thought that was 38 milliseconds as he uses as grown and our product needs have shifted we decided to start incremental migration from go to rust in the 1.7 version in this article you'll learn about our motivations for this migration and the problems we are finding rust solves for our team this is interesting the original decision for turbo repo to use go followed in the footsteps of es build as the javascript bundler written and go es build is fast and avoids much of the initialization overhead of node.js additionally goes developer experience is tailored for iteration something we needed as we learned more and more about what developers wanted from turbo okay okay that seems reasonable i think that's a reasonable choice in the early days of turbo repo these properties of go gave us exactly what we needed for the project to be successful however as turbo repo code base has scaled and merged with turbo pack goes begun to underserve both our core team and users in the area that matters most to turbo all right comparing go and rust we've been working on several other migrations lately and have enjoyed opportunity to refine our approach doing a mock migration for the bbc's open source front end from react to nexjs dog fooding the next js13 app router for forsell.com i actually think this is one of the best ways to develop anything right here if you can dog food your own app this is the best way to do it dog food for those that don't know it just means that you are building something that you use and so that's a very important you know fast because a lot of times people build products they don't use themselves and there is something really bad about that and any major technical migration there's a lot to to consider and the decision shouldn't be taken lightly in particular a language migration is quite demanding asking you to wait to dimensions like the strengths weaknesses and community of a given language according to your specific business and technical context in our case we need to compare go and rust to figure out which language is going to serve us best okay excited i'm excited and you've never used dog fooding really people never use dog fooding dog fooding is like a total normal term is this one of those things that programmers say that people just don't ever say is that what's happening right now never oh my goodness oh my goodness okay hold on i gotta do a pull i'm too i'm too excited to know the answer to this real talk how many people use the term dog fooding herd of dog food before today yes no there you go i want to actually know because this is interesting this is a term i use all the time oh the demand dies i'm actually i'm personally shocked that this exists that 64 have never heard this you think i'm getting trolled by the poll instructions is not clear dogate by keypad oh [ __ ] okay we're reading this shut up let's see disney go favor simplicity over expressiveness as a side effect of that decision means more errors are caught at run time where other languages might catch them at compilation with a service running in a data center you can roll back fix and roll forward at your convenience but when building software that users install the cost of each mistake is higher absolutely i this is a great this great call out right here i love this kind of thought process because it really changes how you approach software is how easily can you revert for us it's worth using tools that prioritize upfront correctness we fully recognize the mismatch of ghost priorities and what we're prioritizing as a problem that we've created for ourselves yeah the nice part about goes that it has a much more complete type type system than typescript but it still uses a bunch of this interfacing for everything and that is problematic in of itself the rust language and community has prioritized correctness over api abstractions that trade-off we care a lot about when working with process management file system other low-level os concepts shipping software to our users machines love this this is all beautiful this is all beautiful this means additional complexity is surfaced into our code base but it's necessary complexity for the problem we're trying to solve i wonder if it is technically necessary because if you're trying to solve this with another language how hard is it i find myself battling so many little errors that i don't really realize are happening because i'm having to use typescript in some ways you know what i mean rust type system and safe features allow us to put guardrails in places our code base where we need them the languages expressiveness allows our developers to encode constraints that catch errors at compile time rather than github issues i like it i like that ghost performance for simplicity at the file system was created creating problems for us when it came to file permissions absolutely go let's user set unix style file permissions code a short number that describe who can read the file yep you can do a you can do a little octal right little zero leading number right while this sounds convenient this abstraction does not work cross-platforms windows doesn't actually have a precise concept of file permissions surprise surprise windows sucks go ends up allowing us to set a file permission code on windows even when doing so it will have no effects so one thing i like to do personally is just never support windows okay it's that simple use a unix-like system or get the [ __ ] out of here just get out of here stop go use windows for gaming okay windows for gaming is great i love it okay i love it all my software i write at netflix i have zero support for windows okay zero support for windows i'm sorry i'm sorry i'm sorry suck it suck it suck it suck it suck it hey most people in here are a bunch of arch drive arch users anyway so it's not like i'm really offending anyone i'm sorry for the normies that are using windows all right it's wsl2 is great okay tough guy i get it wsl news great all right but i do use windows for gaming and for streaming so i'm actually this is a streaming computer the one i'm looking at right now watching your little text run by shut up shut up on contrast robust explicitness in this area not only made things simpler for us but also more correct if you want to set file permissions code in rust you'll have to explicitly annotate the code as unix only if you don't the code won't even compile on windows this surfacing of complexity help us dude i love this tell me this is not amazing about rust right like this is a really important point that i think that people don't quite catch which is that like these type of little catches make your life so much easier despite the fact that they're kind of a pain in the ass to always have to deal with you just don't have to deal with them as much and this is really important facet of of russ i think russ has a fantastic ecosystem of high quality open source crates absolutely they have clear focus on what they care about an example of where to benefit from this alignment is when we have to interface with native libraries written in c or c plus plus as we built out turbo repo we've started to rely more often on native sea packages like aziz z stud as a stud a library that helps us compress our cache files interopting with these native libraries and go requires us to use seago which switches from pure go tool chain to a much lower c tool chain moreover the switch is global process which means that if we use a single native library we have to build our entire code base with sigo damn in rust this interfacing with native c libraries is far more contained libraries such as buying gen or cxx creates oh csc sacs creates safe rappers and don't require global changes to our builds even better many libraries come with these rappers already generated for example we ported git interfaces to get to create get two interfaces with a c library lib get to i dude i use lib get to it is confusing as [ __ ] just confusing underneath the hood but exposed safe idiomatic arrest api this allows us to get the benefit of both rust and sea ecosystems while maintaining a great internal developer experience dude dude lib get lib lib get to dude damn you should use live get three internally we share code bases that work closely with the turbo pack team for their work russ was a clear choice from day one it let's see this meant that we that as we both continue our work on building tooling for javascript yeah i'm okay code bases we're solving the same problems twice once and go and once in rust absolutely getting aligned means both teams can shift faster by sharing development and maintaining of common utilities in our problem space for instance we are taking a lot of inspiration from turbotax team when it comes to file watching so we can build a feature for smart hot reloading across workspaces sooner oh yeah give me that hot reloading baby russ makes our core team happier let's go that's right the rust affects people all right another great perk our team wants to write rust it's a language that solves what we care about and brings us joy let's go russ chilling 2023 russell the fact that we enjoy writing rust is valuable is valuable by itself in more ways than one happier developers deliver better software your brain is better at complex problem solving when it's happy if you're if we're happier while we work we're much less less likely to burn out absolutely this is good call out rust efficiency means less energy consumption letting us do our part in global sustainability you know that's something that people never talk about which is you should have some level of care right you shouldn't just waste resources you know and and writing stuff in typescript because it's easy you're just like massively overusing resources looking at the past seven years stack overflow survey results were not alone absolutely people love rust we also made this choice with future developers of turbo repo mind web developers are strongly looking towards rust as a second language to learn after oh okay i'm making it more accessible for those coming from tooling images and this enables web focused developers to be able to get involved enabling the turbo community to grow absolutely continuing the migration we're migrating incrementally so it's not completely a complete rewrite overnight right now we have to well we oh my goodness we have what we call rust go rust sandwich mmm i like a good rust go rust sandwich you know i mean rust is the entry point allowing us to choose whether the implementation for a particular command is in rust or go our go code base is able to call rust code 2 giving us pass to keep go around but always but always be able to get to rust check out the turbo ffi crate oh cool we're excited about rust has done already unlocked for our teams and can't wait to finish the oxidation with carcinitization of our odun you know people often mistake that that rust is written after the thing that happens to metal it's actually about a fungus okay the fungus it's actually you should be doing cordyceps in here okay making a little cordyceps joke if you're a high performance engineering team building developer tooling or doing systems work and you're debating rust or go we hope our experiences can be helpful reference for you those are some big words i know turbo' okay there we go i think one thing that they're really missing is that they're not showing they say strong effectively strong ecosystem and developers really like it and it catches bugs up front but the fourth one is that i think it's actually exceptionally easy to hire for rust i genuinely think if you have a non-web three company you would have a line out the door out the back into the parking lot and into the alley where people are getting shanked just to have a chance to have a rust job honestly i think people want it bad and making that choice is a huge hiring multiplier whereas right now if you if you create javascript it's kind of like people expect javascript but no one really wants or loves the job in javascript they want to work in a specific technology i want to work in work world it's all all out the library right so it's like spelled react solid whereas with rust it's like it's it's about rust the language which i think makes a huge difference completely that's it you can cut it now bye bye hey the name's the private gin like and subscribe i got him say hi youtube say hi to youtube say hi say hi say nice things i mean it right now say nice things about youtube right now say it if you know say nice things youtube you suck no you suck nice things about youtube gosh guys are jerks all of you