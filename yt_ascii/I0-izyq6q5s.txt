hi everyone i have recently been trying to learn a bit about how computers work and in a previous video i explored things like representing numbers in binary and using simple logic gates to build something capable of doing addition and subtraction what i'm interested in today though is how a computer is able to actually remember these numbers that it's working with so i've begun by creating this simple circuit following a little diagram i found online if i take this red wire and connect it up here the light turns on what's interesting though is if i then take the wire back out the light remains on so somehow the state has been remembered the other wire by the way can be used to turn the light back off and so we can think of these two wires as being the set and reset inputs to our circuit let's switch over to the little simulation program where we managed to get addition and subtraction working last episode and try create some of this mysterious memory so i have our two input signals here set and reset and together these should control the state of the output signal over here one way we can achieve the behavior we saw is using an and gate an or gate and a not gate the set input goes into the or gate and the reset input gets inverted and then goes into the and gate and you can see the signal travelling along there now the output of the or gate goes into the and gate as well and the result of that is our final output signal but now for the fancy part this output signal gets fed back as the other input to the or gate let's see how this behaves so i'll turn on the set input which makes the or gate turn on which makes the and gate turn on and so now our output is on of course this has also turned on the other input to the or gate so even if i now turn the set signal off the output remains on the only way to change the output now is using the reset signal so let me try turning that on this signal is inverted so it turns off the input to the and gate and so the output switches off as well i can now turn the reset input off and the output will stay off this little setup is known as a set reset latch sr latch for short i'd like to look at a different way of constructing this latch which i think is really interesting but first i'll need a new building block which is an or gate followed by a not gate making what's called a nor gate here the output is only on when both inputs are off so if i turn either of these inputs on the output will switch off i'll write its name up here and then make it into its own little chip okay so here we have our set and reset inputs once again and what i'll do this time is take two of the nor gates and feed the output of the first one into the input of the second both inputs of that first nor gate are unconnected which the simulation just treats us off and so its output signal is currently on this will cause the output of the second nor gate to be off and away that up to the input of the first one i'll also connect it to the output signal over here and finally i'll hook up the set and reset inputs like this so let's try turning on the set input which will make the output of this nor gate turn off which then makes the other nor gates output turn on and so our output signal here goes on we also have this signal traveling along here which we can think of as essentially locking this output into an off state so that it remains off even if we now turn the set signal off and so as you can see the output here has remained on let's try turning on the reset signal now so this will switch off the output of this nor gate and as a result the output signal here will go off that also means that this signal along here is now off allowing this output to come back on which then again locks the output of this nor gate into an off state so that even if we turn the reset signal off the output remains off this setup looks really simple but it can definitely take a little while to wrap your head around what's going on here anyway what i'd like to do next is modify this slightly so that instead of having a set and reset input we have an input for data and a store signal which indicates whether we want to save that bit of data or just ignore it to make this work i'll need to remove these two wires and add in two and gates the output of the first gate will play the role of set and the output of the second gauge will play the role of reset so we want this set signal to turn on if we're sending a1 on the data signal and the store signal is on and we want reset to go on if we're sending a 0 on the data signal so i'll need to invert it to test for that and once again the store signal is on so if i now put a 1 on the data input nothing really happens until i enable the store signal and now we should see the output change to a one if i then turn the store signal off i can again change the data to my heart's content without it having an effect on the output as a final test with the data now set to zero i'll enable the store signal again and we should see the output now changed to zero so this started out as a set reset latch but after a little modification i'll call it a data latch instead let's take a moment to consider this core part of the latch in particular what happens when the power is off so the simulation is unplugged so to speak and we then turn the power on it's interesting because the inputs to both nor gates will initially be off so both of their outputs will be on let's see what happens [music] as you can see i get this weird oscillating effect in my simulation where the output endlessly toggles on and off i was confused at first about why this wouldn't happen in real life but i think i roughly understand it now the signals in the wires are traveling really fast somewhere in the vicinity of half the speed of light what's much slower although we're still talking nanoseconds in reality is something called the gate delay which is how long it takes for the output of a gate to fully react to a change to its inputs so i guess that it looks something like this but now small variations in the gate delay will result in one of the signals getting to the other gate first preventing it from outputting anything like so i'll restart this and we can see it settled into an on state i'll restart again and this time it happened to settle into an off state i was curious to try this out with that little sr latch i built earlier and sure enough sometimes the light was on initially and sometimes it was off so the start state is essentially random although it might heavily favor one state over the other i guess because one of the gate delays could just naturally be a little slower than the other anyway i thought it'd be fun to try replicate the exact setup we created in the simulation on the breadboard just to be completely convinced that it works in real life unfortunately i don't have any of these nor gates and gates or not gates i do happen to own some nand chips however and it just takes some small tweaks to get the same setup working in the simulation made purely out of nand gates like so [music] okay now each of these chips has actually got four nand gates inside of it which you can imagine something like this and of course unlike in my simplified simulation real life requires everything to have a connection to power and ground in order to work so that's what these other two pins are for with that out of the way let's start wiring this together so i am using this first chip for these three nand gates and the second one for these two i probably could have set things up to use just one chip but it seemed easier this way anyway the little light on the left represents the store signal then this is the data signal and over on the other end is the output signal and there are currently zero i can put a one on the data signal by pressing this button but as expected the output doesn't change until i enable the store signal so now the output is one and i can release the buttons and you can see it has remembered that then try storing a zero and that seems to work as well last thing i'll do is just turn it on and off a few times to see what state it starts up in i'm not sure why i find this endlessly entertaining but i do okay so with one latch we can store one bit of data so of course we could just use four of them if we wanted to store four bits of data i'll quickly connect the store signal up to all of them and hook up the outputs as well i can set some data but as we're used to by now the output doesn't change until the store signal is enabled this is called a 4-bit register but there are some potential problems with the current design and to understand them we need to think ahead to how these registers might be used so as an example i'll take two registers which i'll creatively name a and b and i'll quickly connect these inputs up to a and store some initial value in there say three i'll then wire the inputs up to b instead and store maybe a one in there okay i'll now bring in the alu we built last episode and connect the register outputs up to that so at the moment the alu should be adding the contents of the two registers together since we don't have the subtract signal here enabled now a pretty reasonable thing to want to do is take the result from the alu and store it in the a register so we can use the result for whatever calculation we want to do next by the way we can see over here that the alu is outputting 4 like we'd hope i'll quickly wire the a register up to the output signal so we can see what value it contains it's still three unsurprisingly so to store the result from the alu we'll need to hook up the store signal over here and enable it things have gotten a little out of control i just wanted to store the result of three plus one in the a register which to be fair it did but then a few moments later the lu calculated the result of four plus one which then raced around and overrode that value and then the same thing happened with five plus one and so on so to capture just the first result i'd need to turn the store signal on and off with impeccable timing but that's really hard to do reliably so we're going to need a bit of help to the rescue comes the clock which generates a signal that cycles endlessly between 1 and 0 also called high and low at some steady pace this is going to help us synchronize and coordinate everything that goes on inside the computer and we'll pay more attention to it later on in the series but essentially during the flat parts of the clock signal we want to do nothing because the speed of the clock is carefully determined so that this allows enough time for even the slowest signals in the computer to get wherever they're going and let everything settle into a stable state then in red here we have what is called the rising edge which is the very brief moment in time where the clock signal transitions from low to high and then we also have the falling edge where it transitions from high to low we can pick one of these edges let's say the rising edge and decide only to store data into memory at these moments so if we can implement this then in our setup from before it would be storing the data at a controlled time interval instead of just as fast as it possibly can this will give us some breathing room to set things up between those rising edges like turning off the store signal for example if we wanted to stop storing the data that would be really helpful so let's take that data that we built and try modify it to only store the data when this clock signal here which for now i'm just controlling manually goes from low to high now there's actually a number of ways of achieving this but i'm going to take an approach that uses two latches the first latch stores the data only when the clock signal is low then the second latch copies whatever data is in the first latch but only when the clock signal is high let's test this out at the moment the clock signal is low so i can change the data but the output over here isn't affected that data is however being stored in the first latch if the clock signal were now to go high we can see the output has changed to one because the second latch is now allowed to load the value from the first latch again changing the data does nothing because we're no longer storing it in the first latch which is where the second latch gets its data from so hopefully it's clear how the simple little setup achieves what we wanted only storing data on the rising edge of the clock what we've created here by the way is called an edge triggered data flip-flop the trouble with this flip-flop though is that it stores the data on every rising edge there's no way for us to tell it to stop storing the data so over here i have a data and clock signal like before but i've also added a store signal the easiest thing to do would be to use an and gate to modify the clock signal to be low when the store signal is off and of course if the clock signal remains low the flip-flop won't store the data so for example i could put a one on the data signal and cycle the clock but nothing happens because the store signal is off if i turn that on though now the data will be stored on the next rising edge this setup does have a little defect though for instance if i change the data to 0 and turn off the store signal the flip flop thinks the clock signal is low right now although the real clock signal is still high if i then turn the store signal back on the flip-flop will think the clock has just gone from low to high and so it will store the data at the wrong moment this makes me a little uneasy so let's go with a slightly more convoluted approach that doesn't have this issue i'll give the flip-flop the unaltered clock signal this time and instead we're going to modify the data input so if the store signal is on we want to use this data input over here but if the store signal is off we'll instead take whatever is currently stored in the flip-flop and just put it back in to do this we'll need to build something called a multiplexer and for that we'll need a not gate two and gates and an or gate the two bits of data we're choosing between go into each of the and gates and we want to choose this one if the store signal is on and the other one if the store signal is not on then whichever is chosen we want to output it on a single wire so that's the purpose of the or gate let's give this a quick test so i'll try putting a 1 on the data signal but as we designed with this store signal off it's simply taking the zero that's currently stored in the flip flop and feeding that back in and so nothing changes when we run the clock if i turn on the store signal though now it will actually store the new data on the rising edge of the clock as a final test i'll set the data signal to zero turn off the store signal and make sure that that works as well okay i'm going to call this a one bit register and we can use it to make an improved version of the 4-bit register from earlier okay let's see this in action quickly i'll set some arbitrary data turn on the store signal and then pulse the clock to load that in i'll set some different data then and let's try it with the store signal off this time just to be sure that that's working which it does seem to be all right so remember our setup from earlier that was running out of control let's set that up again but using our fancy new clock synchronized registers so i'll load some starting data into both of these let's say five into the a register and then i'll connect the inputs up to the b register and store maybe three in there like before i'll then hook these both up to the alu to add their values together and send the result back to a finally let's connect the store and clock signals up to the a register so at the moment it's outputting 5 but i wanted to load in the result from the alu so i can turn on the store signal over here and then when the clock signal goes high we can see the result has been loaded in because the output has changed to an 8. unlike last time though the new result from the alu is not just overwriting that almost immediately so we now have the opportunity to turn off the store signal if we like and the clock can then keep ticking away but we have the value we wanted [music] so we've created some of the basic building blocks of memory this episode and from here we're going to try scale things up to create our computer's random access memory i hope you'll join me next episode for that but until then cheers [music] do [music] do you