3 2 1 and real life with tonight's session of meeting c plus plus summarize an echo of mine and i need to see that okay can you hear the echo oh yeah i don't hear any echo okay probably somewhere but your camera is defocused and let's record this stuff again okay the technical problem foreign so a little bit of a technical problem because i have an echo here which annoys me but yeah it seems to be gone now okay so let's get started with the session tonight our guest is no wait hello and welcome to medium c plus plus live and tonight our guest is danita engad who is in the committee with modules and has been keynote in last year mini c plus plus so there will be a lot of questions i think if you have any questions in linkedin posts and please in the chat if you have any questions in obedo pros please post them in the q a tab and if you like a question or video please support the question first that let's get started with tonight's session danita nice to have you thank you for coming and please introduce yourself thanks jens for having me i'm very pleased to be on your show and i'm looking forward to an interesting evening with lots of interesting controversial entertaining questions i'm looking forward to all of you and a little bit about me for those who don't know me yet i'm an engineer in from from the profession i'm an electrical engineer everything is self-taught regarding software development started developing software 40 years ago or so and yeah i'm working at a very small company in my hometown nurnberg we are doing special machinery for quality inspection systems in the industrial context and there i'm developing all of these software from from the dsps up to the visualization on on the screen and this kind of stuff and everything is in c plus plus there's nothing else besides possibly a little bit of c on the on the embedded side or in the fpgas and yeah so this is my background first question so i i do want to say if you answer if you put your questions in the limit is 200. characters which i can post to the video okay so please don't have your questions be too long the question is while c plus plus is used from microcontroller world to enterprise distributed systems shouldn't the cpp reference documentation include the safety of these rps example if certain rps could be used in thread signal handles in terms interrupt handlers etc can you put a question into because it was a little bit long yes god is something about c plus plus in the embedded world and yeah so i think it's a question about rp documentation so now now we go shouldn't the cpp reference documentation include the safety of these rps which are understanding example if certain office could be used and thread signal handlers interact handlers etc yeah i think this is a good idea to actually document this kind of stuff at on cpp reference maybe it's it's not too common to use c plus plus in the embedded world because of the lack of support and the compilers so maybe the people who are maintaining the the wiki sites on cpp reference didn't feel to put too much effort into also including this part of information but if you look at the centers document you will find information about for example threat safety signal and interrupt kind of stuff but in many cases you have to be aware of the fact that in embedded you not necessarily have an operating system underneath this is one thing and the other part is [music] your tooling that you get for your maybe microcontroller or an embedded controller or whatever kind of system you're programming for don't support actually developing c with c plus plus on this platform have been bitten by something like that yeah five years or so ago jesus you would have been totally fine with with programming in c plus plus but the tools that didn't support it so it's probably more of the documentation of your for your toolkits for the device that you're developing for and to look for this information over there because it's you have to to to look at the the particular implementation of api functions from the standard many things are not necessarily defined in the standard when it comes to to freestanding implementations like embedded world yeah also i think and whooping news to me that you're involved with cppreference.com i know that some committee members are but i think like this is like a bit of out of context i see that on linkedin already someone is asking like who's putting the examples there and see because 20 examples are still missing this is a wiki project and actually i think most people would be able to contribute to it so if you think something is missing and you can contribute to it try to turn the effort there and we do have a question which i quickly want to show from linkedin when it is necessary to use c plus plus instead of python oh i don't think it's it's a question of necessary or not if you want to use python you're probably not in a system or an environment where the the memory footprint or the the performance profile is of too much importance this is not a situation that i'm in i'm using c plus plus only because we develop system software for our machines and we have a restricted amount of memory and we have a restricted amount of cpu power and we we need to spend everything on the actual functionality so we can afford put more and more work into the software development and this is the reason why we use c plus plus instead of python many things would be much easier to implement using python but it wouldn't help our customers okay let me okay so i noticed many safety coding guidelines including google c plus plus style prohibit exceptions what are your thoughts i'm not sure if the google c plus plus style guide is actually a coding guideline but my thoughts on exceptions yeah it it all comes down to the question of how predictable is the execution of your code in terms of performance deadlines and this kind of stuff using exceptions makes error handling quite easy at least on the side where the exception is the error condition is detected and you throw the exception it makes it more difficult on the on the catch side you probably don't know what what kind of exception you're dealing with and what the what the additional information required to actually learn about the exception is and you're probably missing this kind of information and you need to be aware that the typical implementation of exception handling is not bound in the in the memory space and also not bound in the in the latency space so if you're not throwing exceptions your code is very fast in the non-exceptional case but if you have exceptions you had to be aware that the amount of time to actually catch the exception is virtually unbounded and this is this is something that not every system can afford for example if you're into machine control or in your high performance trading or this kind of stuff you have upper bounds of time that you can spend on handling your errors and in this case you probably don't want to use exceptions at all and so many systems where you want to have guaranteed performance profiles you will probably not use exceptions when i look at my code i'm yeah a little bit in between real-time computing and nothing nothing matters i do use exceptions in parts of my code but there are also code parts where i totally don't use exceptions but you have rather use error return type like return codes or the the expected type from c plus plus 23 or this kind of stuff because i know in advance how long it will take to actually hand this handle these kind of problems so these are my thoughts on on exceptions it depends on on the environment is that you're in and it's not the only only way to to deal with problems in your code or in the outer world so we have another question from linkedin isn't super fast getting unnecessary complicated as more features seem to be glued to the language since that it becomes the most almost impossible to memorize best practices as there are so many corner cases that it's discouraging maybe it's time to make c plus not backwards compatible foreign this is a loaded question yeah there are actually multiple questions in here if i read it yeah so unnecessarily complicated i don't think it is unnecessarily complicated the complication that many people perceive from c plus plus is because we have to catered to many different needs 50 people from working in very old code bases we have the people who want high performance kind of stuff we have people who wanted to be as easy as possible to a program in and all these different stakeholders have different ideas how the language would look like and for people who only use one aspect or have only one point of view this probably sounds like unnecessarily complicated but this complication has a reason [music] on the question by being it's almost impossible to memorize yeah i don't memorize everything i i can't i'm just a human if i need a particular kind of feature it's enough to know that a particular solution for or multiple solution for a feature or a problem exist and then i go out to cpp reference for example or in my case i even look up the standard texts by itself and then i will learn about what i can use and what i best use or possibly avoid when i'm in a particular situation and the corner cases here the chronic aces are something that you see a lot in the social media people are bragging about what a clever solution they have for a particular very specialized problem and you look at it and they say oh you're exploiting this particular dark corner of the language to present a particular solution and i my opinion on that is don't be clever the simplest solution is in most cases the the best one and in particular it's the best for you because a half a year in the in the future you probably don't understand your own code if you're too clever and the last part it's is it time to make c plus plus not backwards compatible here if you've been watching my talks that i've been giving over the past couple of years closing slide they always came a sentence up where i was advocating for actually breaking backwards compatibility in my opinion it would be beneficial for the community at large to not put so much emphasis on backwards compatibility as it has been in the past 20 years well 20 years ago we had not too much of backwards compatibility because c plus plus was still quite new after the delivery of the first standard but now 20 years later we have created a lot of old things that we learned that not really the way to deal with the particular problems but we have to keep them just because the code exists out there and if we don't have a very very good reason we don't want to break this old code but no of c plus plus 20 we have a new feature that actually gives us both backwards compatibility and a good way forward into the future and the feature i'm talking about is modules in modules you can separate code which is following the traditional way how to implement things in c plus plus and b backwards compatibly compatible and on the other hand you can write new code which is doesn't have to look at backwards compatibility and i think this is a piece of the language where we can actually go out and say no particular language constructs are no longer backwards compatible and if you look at the experiments in the soil compiler for example or in in activity ideas that herbsata was proposing at cppcon this cpp2 front compiler that it's very keen on breaking compatibilities with the past just to make a way to what's the future i think this is actually the way to go with c plus plus but you need to be we yeah you you need to accept that we have a new kind of a feature here modules and actually be ready to use it to to give us the opportunity to go forward in this kind of direction okay let's carry on this modules what is the status of modules in c plus 23 and what's like the outlook for okay i see it that we have the language side and we have the implementation side i can't tell anything about c plus plus 26 because there has been no work on modules for c plus 26 in fact you work on modules is more or less finished and we are just working on figuring out particular use cases which have turned out to be a little bit limiting in what we can do with modules this is what is now in c plus plus 23 when it comes to implementations if i want to be honest no compiler has a fully 100 percent conforming implementation right now i'm using modules in our company on a daily basis and but i'm in a very special situation that i can work with just one compiler we are targeting windows only with the visual studio compiler and so we can take advantage of the quite good implementation of modules in visual studio when it comes to gcc and clang this situation is not as rosy as it is in in msvc i've been experimenting in the last few months a little bit more with gcc-12 and clang 15 and it looks like yeah things are coming along but not as quick as many people would probably hope for but i'm quite confident that in particular clang 16 will be a huge leap in regards to the implementation of modules in particular tests as of yesterday or the day before there is a patch merged into sea into clang 16 which should make it possible to use modules with cmake in and clang so this is probably this stuff did you later stuff that i can tell you about the status of modules in in clang and possibly gcc if you want to know something more in-depth you probably have to ask me a very detailed question okay let's go to the next question by returning sda optional or std inspection expected are there less reasons to use exceptions totally so both of these types can help you handle cases where you can't fulfill your post conditions for example you can't produce a result use a optional and if you can't produce a result and have information along why you can't reduce the result you should expect it and these are probably cases where i would have been using exceptions in the past if you can handle situations where your function call cannot [music] produce a result so it can't fulfill its post conditions it's probably a very good idea to to widen the contract here and and use an option or unexpected type in particular if you are able to handle this this error situation very near to the call side so i totally recommend use optional and expected yeah you can also use optionals to if you're in a situation where you use a a deferred initialization this is another use case of optional which is probably not too well known it's not just about return tests but you can use it also in your in your object itself to defer the initialization of parts of your class to a later place on a later time when you know more about the situation the what you want to where you want to actually construct a part of your class the other piece would be an anonymous union and it's something that hardly anybody knows about okay there is a question about career how do you manage to stay enhanced on design and coding all these years okay that's my job and to stay hands-on code in design yeah what's really helpful has been [music] trainings from scott myers in the early 2000s in particular attending meeting c plus plus i can only highly recommend going there and also other conferences but meeting c plus plus is really a conference where you should go if you possibly can and then there are also all these youtube videos from other conferences with very bright people and and highly focused and and and talks full of information that you probably never heard about and can put into your own work and so this is the kind of stuff that i can recommend and then there are books i have been really happy to review klaus little burgers latest book about software design and by reviewing this book i refreshed my knowledge on software design and design patterns and how the application of these what is good ideas and put it straight into my code that i'm writing these days and this is something that i already can recommend buy this book visit conferences read blocks and watch youtube videos so it's a question which you just saw and i want to use this question but this i okay i see format and ranges okay that's it major many major c plus plus 20 features are still not implemented in some major compilers eg format ranges and vcc and crank modules in both and do you believe that the big bang for c plus 20 is ready or reality today okay i can see from the question that is something some person who had seen my keynote that either cpp con or muting c plus plus aware i was talking about big ben c plus plus 20. yeah format as far as i know both jesus you and clang have it now even for the quality of the implementation is not as good as it is in the format library itself actually it is had been a topic of a paper in in the latest standard meeting in issaquah arranges yeah i'm a bit a little bit torn about about ranges ranges is a is a vast topic you have to deranged based algorithms we have to use and i think the algorithms are probably not in too bad shape in gcc but i i'm not well versed in in gcc so i can't say much about it but my opinion on ranges is i have mostly a hard time using parts of the ranges standard in my own code in many cases not using ranges is actually simpler in particulated range views but it could be me so i'm not missing the ranges i wouldn't be missing ranges too much if i wouldn't have it in the in the standard library of a particular compiler well modules is a different kind of thing i wouldn't start programming anything without modules anymore but if you're not using two difficult kind of stuff with modules you can actually use it both in gcc and clank today i've been trying it out and it works and i've been in contact with people who are using modules with gccm clang and yeah you need to be aware that you can run into implementation errors but you can use it and you actually should do it because modules are the best kind of thing to structure your interfaces modules are not about making your compilation faster it's about making your code better and your interface is more concise and the better thought out and so you should use it so in if you really want to you can use all these big bang features in c plus plus 20. today this is my opinion but it also as always it depends on the situation that you are in probably not many people are actually able to use the latest version of gcc or the latest version of clang yeah i think that's the other big problem recently i installed on my machine in gta c11 and that's basically the last thing i can get that's the latest version yeah it's not available i would have to build 12 from source and 13 or 30 in the future do you have in your compiler i think let's see this was gcc 11 now i'd be able to move to 20 the good parts and okay just for 17 then that's my plan for for how to do c plus plus internally for mini c plus plus and my projects okay but if you if you want to want to do yourself a favor go at least to c plus plus 17. everything before 17 is is no fun at all that's i used q6 and it was cute six super 17 is fully supported or i was actually needed and also recently there has been a talk by mark mods released on using qt6 for c plus 20 and was like wow that's that's really interesting because you know mahmoud says working for the cute company and so it's like the the official statement that yes you can use c plus plus 20 with q6 and i'm doing it on a daily basis going to exploit that as much as i can of course because the other thing which i had hoped for that maybe did you think this would be already implemented but that's still missing from trying and gcc i heard the next compiler versions of clan and juices you should have it and msvc has it right now but not in modules yet oh that what do you mean it's not in modules if you comply with with modules you have a feature macro will tell you no we don't have explicit object parameters okay so you only have it outside of modules and the the thing is that as you probably know msvc has a very structured format for for the modules the dbmi the binary interface and they do think this is a is a different kind of function representation and this requires extension of the of the ipr ndpmi and this is not yet implemented there how so this this feature macro actually is enforced if you try to compute a compile to a module some like theory it's not there so some practice not there so you have to implement this without explicit object parameters and with explicit object parameters and have to select the code path according to the value of the future macro okay apart from c plus plus what languages have you enjoyed programming in and which languages would you like to learn okay let's have a look at the clock okay i have 20 minutes yeah just a short overview in order of learning fortran cobble basic pascal fourth oh come java c and tons of assembly languages and and very specialized languages and then the hardware description languages like vhdl and verilog and what i would like to learn yeah maybe i should look a little bit more into rust just to get an impression about what it's all about programming in the and another one that might be very interesting is haskell and possibly early okay there we've been touching on the committee and there's a like a follow-up question from linkedin let's deal with that you mentioned that c plus needs to hand many corner cases as client users that's asked for them but isn't it the definition of scope creep and i think this is a misunderstanding right because we have three different implementations which bring their own scope creep with them so but it's not just free implementations that we have we had at least oh let me say five or six we should not forget etg we should not forget icc and we should not forget circle in particular circle is very interesting to look at and [music] yeah i don't know if this question is actually related to the standardization process yep people probably don't really know about how the c plus plus standard is made the what what's going into the c plus plus standard is stuff in form of papers that are presented to the committee everybody can write a paper and submit it to the committee for thinking about the ideas proposed there and yeah figuring out how to incorporate it into the standard if it actually finds enough people to champion this particular feature and i don't think this is probably characterized as a corner cases c plus plus is a system language that has a very wide applicability in many industries and so i don't think we should limit ourselves to a particular domain only so with this white scope of users that we'd like to address as a systems language we have many many people from very different backgrounds and different needs so i wouldn't actually call this a coda cases and if a proposal is too limited in scope that it makes absolutely no sense to spend time on discussing this paper and find wording to incorporate it into the standard in a consistent way we don't do that so i don't think this is scope creep it's it's actually use cases that are brought to the committee to to give help in in using c plus plus in these particular domains this is my opinion on this kind of stuff with some of the new features it's also that we cannot like release the full feature in the perfect shape was was the next standard i think core routines are a great example of it that the core routines in the c plus standard will be improving with every standard but at the current point that's still very much manual mode and that you need to add a lot of things or use libraries which add those things to the standard which later will be understanded and so let's move on to the next question how were these new features affect the overall performance of c plus programs from my personal experience the performance increases in particular as i've been alluding to a couple of minutes ago c plus plus 17 was a major inflection point in regards of performance if you don't know or haven't noticed with the advent of c plus plus 17 we have the guaranteed illusion of copies of return values and your compilers can do really cool kind of stuff with c plus plus 17 and also with the increase of more cases where you can use these performance increasing features in c plus plus 2023 and we're looking forward to 26 as well so i think the the runtime performance of c plus plus increases with every new major standard this is not necessarily so the case with the compile time performance unless you really let all old [music] solutions to to meta programming go for example is a major problem then it comes to compile times just embrace concepts and your compile time is as good as it has been in the past as i think the committee is usually only adding things to the standard which are not like really slowing down things that's i think also the one to probably know about is the standardization process does take a look at this and yeah there are now with the the yeah there's more emphasis and on security and safety we're actually discussing papers where we might experience or at least we think we may see performance degradation because of ruling out undefined behavior and replace them with defined behavior and if you are removing undefined behavior from code compilers can no longer exploit undefined behavior to do weird optimizations so you need to be aware there's a drawback you can either increase safety and security in your program or you can even go even farther and and give compilers even more freedom in optimizing away stuff that i think is this code that you have written without really understanding the language and and they're punishing you to death with what they actually compiled from your code but the features itself usually are meant to increase performance i think it's a good thing to to not let users fall into traps with corner cases in a language and undefined behavior that i thought this is something that gave them performance but actually gave him only unsafe unsafety okay the super sports ecosystem now has a lot of package managers and build systems is it high time to have a standardized package manager and build system to put c plus forward by the standard yeah there are multiple things in here for one dc plus plus standard itself is a standard is it's a document describes the language and the library it doesn't describe anything about the implementations and the the ecosystem around it it's just not the scope of the standard so it will never be in dc plus standard having said that we have the [music] the study group 15 in the committee and i'm also a member of the study group 15. where we are discussing things like package managers build systems and what we can do to improve things there but even then we were never come to a point where i will be a standardized package manager or a standardized build system we don't want to do that they think it's a good thing to have computing implementations of a standard platforms have different needs industries have different needs and we don't want to prescribe a particular package manager or build system the even worse we have we we would have to then provide a implementation of a package manager and the build system this is something that you totally don't want to do that all members in the standard are basically volunteers or part-time members who can dedicate a limited amount of time on this kind of stuff so every implementation of everything and this includes package manager and build systems must come from vendors or groups outside of the committee and usually this leads to to multiple implementations of package managers and build systems and different thoughts on how to actually do this kind of stuff what we can do is encourage using standardized [music] metadata formats for example there is a new standard on how to describe dependency information not only for modules but for everything and this is actually has a has a paper and is implemented in for example cmake and copilots are writing out dependency information in this kind of standard this is what we can do in the committee to improve things related to package managers and build systems and yeah there will be probably a international standard put forward possibly in three years time from now where you will you can see comprehensive standardized you on the system of package managers and build systems it's not neglected in the committee but we are limited in what we can do yeah and i i also think it's like there c5 plus is not an organization right we have the iso committee and then we have various compilers implementing the standard and build tools and package managers is something which we you know take and into existence now for the community but the committee will never be able to actually like standardize software that's not their job so and when we're talking about the committee how to be part of the c plus committee and how can as a user share my experiences to language and new users let me try to actually have two questions here being part of the committee and how can i use this okay as a user share my experience a language and new users i don't really understand this sentence to be honest i have a bit trouble with the second question too let's let's go for the first question okay let's make let's let me talk about the first question how to be part of the c plus plus committee okay i'm involved into the c plus plus committee since 2009 teen if i remember correctly yes it was cologne 2019. i had a chance to to go there just show up and say hi here i am how is the sausage made and let's see how things look like working in the committee and after six days i was totally hooked and i said okay let's find a way to to actually get in there and yeah if you want to be a member in the committee you need to be part of a yeah of a how shall i put it the empty national parties and you have independent organizations like the the standard c plus plus foundation or the booth foundation there can be become a member and then be delegated to the committee to work on c plus plus this is what the iso process requires of you to actually become part or become a member of the c plus plus committee so it's not as it has been the past 20 years or so it's just you dedicating time and and and mental capacity to work on there now you is you need to be a little bit more formal in the sense that you need to be part of a different organizational or body to actually become part of the iso committee yeah this is what i can say about it if you really want to become a member look out for your national party get in contact with them and ask them to to let them in sometimes you can become a member of your national body for free many smaller national bodies don't require anything of you besides yeah willing to actually dedicate work on it and other national parties require you to be a member of a of a of an organization and you have to pay member fees or some kind of things it depends on your nationality this was fairly focused on industry and companies not so much on us as users so the second part of the question is like how can i or they add value to the language and make it easy for new users and you know so joining the committee is i posted a link to the iso cpp website and i think that srcp website is probably the best part to get started and to join the committee either your national committee or iso cpp also probably as the organization to talk to or post organization it may even work with the linux foundation it's an it's an affiliated body that can actually send people to the isoc committee but as far as i know all members are part of national bodies or boost or the iso standard foundation hey what's your opinion on a possibility that contracts will be accepted for the next standards correct as i said i've been at my first committee meeting was cologne 2019 where contracts were ripped out of the standard as people have possibly know contracts have been already in the c plus plus standard up until july 2019 and since then people are working on getting them back into the standard i'm not too familiar with with what's going on there and i see kind of a of a back and forth between two different opinions on what contracts should look like the name will be come part of c plus 20. there are people who say contracts are very simple kind of things that don't require too much of the expressions that you can write into your pre and post conditions and actually put limits on what kind of expressions can be there for example can there be undefined behavior in the expressions that you put into preconditions and i think this is a totally bad idea on the other hand there are people in particular once in large companies who are using contract kind like kind of things today in their systems who have a more heavyweight point of view on contracts and these people expect more functionality from contracts and as long as these two contradictory points of view on contracts are not sorted out contracts will not be part of the next standard i really hope for this is just my personal my personal opinion i'm more on the lightweight point of view i want a very simple very easy to understand model of contracts which are based on binary predicates without side effects besides possibly termination or logging and everything beyond that is not something that i'm really keen on putting into the standard yeah this i'm just following what's going on there but i'm not too much into the details that because there's a back and forth between these two different kind of camps yeah and i think it's something you should say it's like the standardization work is so big and maybe we haven't even touched reflection today which i'm thankful for you for there's like not every committee member knows everything which is ongoing and the committee and there's some people which i have an overview and then there's some people which are more like working in their corner and that spectrum somewhere in between daniela probably exists so what do you consider to be the next big thing in c plus plus what do you or what what is missing the most okay as i already has probably been alluding to in my keynotes last year i really look forward to much more stuff being done at compile time reflection and meta classes this is the kind of stuff that i'm really hoping for to proceed over the course of the next three years and to become part of c plus 26. i think if you want to do something like serialization locking you you have a hard time doing it in a general way today without reflection and i think this is something that we really can improve on and with reflection comes much more stuff being done at compile time i got into compile time programming over the course of the past year and i really love it if you can do things at compile time instead of putting metric constants and other more information about configuring your classes and this kind of thing by hand just let your code inspect yourself itself and and and act accordingly and accommodate to this kind of information that's already in your code but cannot be used in in more advanced features that you can extract from this information already in your code and another thing that i'm really looking forward is pattern matching i'm not sure if padding matching will it will make it into c plus plus 26 even though we are quite we have a very good shape of pattern matching but there is a new language feature that they have to probably put into the language and these are dual expressions which should help giving us a better way of expressing pattern matching and the actions that are bound to a particular pattern and this all these three dt3 can things that i've been talking about are so big that i i'm not too hopeful seeing all of them in c plus 26 and this is only the language side i'm more on the language side so i can't tell too much about what's going on on the on the library side but what i can see in the library side is any receivers kind of thing and in other terms asynchronous computation i really love asynchronous computation but let's see how this center receivers kind of thing actually turns out in the end right now i'm not working or experimenting with this asynchronous kind of framework i'm using seo as my asynchronous framework and i'm quite happy with it and i'm not i was a little bit disappointed not seeing it in c plus 23 but yeah as jen said the committee is big and there are many different stakeholders with different opinions and i see the benefits of sender receivers instead of seo if you in particular if you want to go into heterogeneous computing and this kind of stuff and i think that's the other point which we currently see in the committee that there's like some things which are so easy they they just could be standardized but they build up on something which will be outside of the standard right like the the socket functionality of an operating system or something and so it's we have to get like some in some ways right now we're trying to nail down a basic framework for asynchronous operation and we're trying to get that right i'm actually quite happy that not we we do not like get it in 23 because it probably has been due to the pandemic out of a scope of of possibilities for the standard so i much rather give this a bit more time have this a bit more seen by more people than having that's the other problem with with the current model if we put something in the standard it is literally put in stone and that's also the the other thing which is the other problem is like once you put it in stone you you really can't remove it anymore because it would break avi or then like if he wanted to introduce a new hashmap it could but we wouldn't would have to use a different name maybe actually hashmap is still available in the standard so i'm a big fan of unordered so we could replace it with something better and i think that this is the beauty of c plus plus if we don't put everything into the standard we have so many libraries out there that we can take advantage of i've been mentioning the aco library i think the ac library is so fundamental today and you can use it in so many places but we can actually be happy that we have it and not have it in the standard because if we had seo and the standard we would probably had a hard time to to use c plus plus on gpus for example you can't put seo and on gpus but we want to take advantage of the compute power of gpus or possibly fpgas and so if you need asynchronous computing you have multiple choices to do so and in particular use seo which is battle tested and proven in time and it's in every application that i use today and have been in the past 10 years and so you are not limited to the stuff what is in the in c plus plus the only stuff that you can't do in the language in libraries is the language kind of things and this is the reason why i'm working on the language kind of thing so that i can have new features that enable better libraries or new libraries that you couldn't feasibly implement today this is my opinion on this kind of thing and so with the same anger on format would you say that using format as a library is better than the standardized version okay like formatting and printing is is so basic i think this belongs into the standard library but this doesn't stop you from using a library with more features like the format library but i think we as a committee owed to all the majority of people who don't want to take a dependency on an external library just to get a decent way of putting stuff onto a terminal or format strings or actually deformity this should format function is not only for formatting it's it's possibly the best way to concatenate strings from pieces if you want to concatenate for example three pieces of strings of of different types maybe a string view and a string and and something from from possibly a q string or whatever it might be the best thing is use format and concatenate this into your final string the the most performant option that you have so just look at what the the library function actually does and have a peek over the the the border of the of your of your small point of view you see things that you can take for finding solutions that you probably haven't thought before with many many functions in the library now we are kind of having a question which is going to be about log free have you used log free data structures such as a log free message key with c plus plus usually like what's in the boost library what do you mind sharing any experience working with it like pros cons in the rest of structures in c plus i'm pretty sure this is from honey yeah i'm i have my own lock free message queue so i'm totally used to lock free data structures my experiences are limited to luxury cues i don't use more complicated luxury structures if i would have to i would totally look into to libraries from the experts in this kind of area i have been using the boost lock free library in the past but back then there have been problems with the atomics and boost and also the the lock freak message queues or circular queues or whatever they have been putting forward in the library didn't need the requirements that we were having in our applications so i couldn't use any library solution out there so i had to do my own yeah but if you don't want to go into look free data structures and this is a really tough kind of thing to go into definitely use libraries and probably the boost library is a good start i am you have been using my love freak message cues because i had a different kind of qualities on either end of the queue so i had to to find a way to to express these different kind of policies and how these skews should behave and this is something that's that's really addressed in the in in libraries that i can see in the and the in boost or in other open source libraries okay i think that brings us to the end of questions for today it's a bit more than an hour that we're now on stream and thank you for answering all the questions angela you're welcome and i was quite happy to see all these variety and this this these many questions it was really interesting and it's i enjoyed it a lot i hope people are happy with what i had to to tell them about my ideas and my opinions and yeah see you at meeting c plus plus forward to that the next guest will be actually someone who is maintaining retinal cute so we will be touching more on maintenance and acute in general and c plus plus standards etc will be interesting in march and until then thank you for watching thank you for coming to anita was a nice and great evening with you thank you and thank you i'm going to take us offline