[music] welcome to my talk tonight i'd like to talk about how i started recently started a new project for c++ with cmake and let's go so at the beginning i kind of first want to start with an overview on where i'm coming from with a project which starts with last year basically learning cmake and looking at cmake generators to get projects off the ground fast and watching some talks and also this year watching some talks so this the talks are going to bring us from 2023 to 2024 and then we're going to talk about the actual project which is a good part of the talk [music] i figured out that for newer projects i should use cake because it's the most relevant build system out there and that's why i started learning cake last year and i went through the learn cake and 12 easy chapters like the official cake tutorial on the cake website and played around a little bit with it but i do not like have plans to become a cmake expert i i want to write c++ not cmake and i knew about cmake generators and i kind of like that idea to have a generator generate the currently good cmake you should use and then you can you know improve that or build up on it and so let's see if that is actually a working idea so what i've been looking at last year is the cak starter template from jason turner and the cake init cake generator on github from friendly anon and my impression with a cmake starter template was that for someone who just learned cmake it's such a strong and steep learning curve you get like yes the perfect kup set setup is is it's is really cool to have but i i wasn't looking for a project which like you know has all those belts and whistles already running and if something is not passing you get emailed because an action failed and then you get another email because another action failed it offers fast testing which is really nice it has cpm which is a package manager for cmake integration which is really cool and jason turner did some videos on this last year so just by looking at this you have lots to learn and the github setup wiard is then basically running and then you get your own copy of this into your repository on github and if you read the last sentence this project gets you started with a simple example of using ftx ui which happens to be also a game so this is what you get this is kind of nice it's an application and it's good for prob to get started to to get running to have working c++ code and a good setup but i actually was looking for writing a library and not an application and i don't need ftx ui and i might now have to see to basically get rid of ftx ui again and have to do a lot of other setup things to get this down to the barebone thing i would like to have and i' i'd like to have more like a modular thing where the g we wizard asks me more things what i what i need what i want and then integrates set and this kind of is bit the idea of cake init which is a very nice project on github but you also can install it via pip it's a project generator which lets you create projects for executable sl applications libraries it does have support for conan or vc package it does not have a cpm integration right now that would be nice to have and and it has like some other things which you can do just when you you know look at this tomorrow at github or later that's generally something nice to look at i've played already last year with the dot 37 version around and now the dot 40 version and since there is since february beginning of february when i this there is three minor versions releas so this is like really really in maintenance this project and under under development [music] regarding the package managers i do not know i suppose that conan is a conan to zero support because it's something new i think which has been added but i'm not sure about that so i i do not have a project with conan support generated by this at the moment i might give that a try i know vc package exists but i personally have a preference for ken so if you compare them yeah one thing i wanted to point out is actually cac init is a command line program it generates locally something on your system and it's not automatically giving you a project setup with github if you're looking for that cake template from jason turner would be better to automatically give you all the other setups and tools which you probably should or want to use or you'd like to see a working example of those so that's really great work and really really wellmaintained work by jason turner thank you for that and cac in fils a bit of a different niche which can help you a lot in getting started and that's what i've been using to do last year but then i was getting busy with a conference again and so i didn't really have the time to to have like really enough time to start a new project and all the other things in the retrospect i'm happy because i can now use gcc 13 and back then i was based on gcc1 because it was available back then to install on the system without compilation and so right now i'm build building the application with gcc 13 which is a lot better with c++ 20 and c++ 23 support like for example today i found out that i actually if i wanted to use sdd expected i could so let's talk about talks i was really looking forward to the talk from mikale about how to start a modern c plus project at meting se with us last year and i had the privilege to to see this talk i think we pre-recorded it twice so it's kind of a a good talk which covers a lot of other angles it covers a lot more of cake i i'm not the person to teach you cake so i'm not going to go into the newest stuff with cake or the oldest stuff or how you should do this i think that it's great to have generators i like generators that's more my thing and he goes through a lot of other technologies and stuff and so that that's a great addition he points to the c plus conan 3 years later talk unfortunately that predates conan to zero i think but it's by mates pus also great great speaker and good info on how the setup with cake and conan is and i guess a lot of what he talks about is still true with con to zero but if you're interested in that we i have a talk on that later too and last weekend i saw that also like you know start your c++ project today was a talk at the c++ serve user group by duzan and i i've watched this talk and it's again very different to this talk this is also going a lot into technologies programs and tools you can and should use for your projects this talk is is a good talk to skim through to watch if you have the time he goes a bit through basil a bit through make it's kind of everything is being touched on and then let me go to cake again we have a complete talk on cake and conan next week with diego diego rodriguez lozada talking about seake and conan past present and future and we're going to see the recording with him so you basically can watch the talk in a group setting with everyone else and watch the chat chat with people have your questions directly answered by the expert re looking watch forward to that it's next week's watch party the first watch party and a few weeks ago was with fash work very well and so next week we're going to learn more about modern cake putting projects up running with conan and how this works with a weekend there has become two other talks from meeting c++ about cake popular these are both from denis bardier which you know more modern cake and oh no more modern cake is two talks which he has given in 2018 2019 and these talks got popular by [music] being in the answer to a question at r/r rcpp and on reddit so two people have like said you know this is cake if you want to learn cake watch those talks so i can agree with that that you should watch those talks and there's more talks and the the reason i'm not giving a cmake talk is just that's not my part of what i i'm about right and there's a lot of other content on it and newer talks on cake probably exist and we will hopefully see more cmake talks this year so if you want to give a cmake talk it would be great to have another cmake talk this year at the conference or at cppp con definitely also will feature one of think and then of course i just quickly want to give a shout out to the learn cute guide channel on youtube they have a cmake series where you can watch many episodes where things get covered in in depth about how to start and work with cake and i'm probably also going to watch some of those videos when i know have to added the generated cake which i felt much more confident in doing with cake init generated code for cake than the json turner version also by researching some stuff for cake i found this tutorial which actually is from last year so it should cover more recent cake and there's of course a ton of other cake online choose the way you want to learn cake and how much you want to cake in learning i for one wanted to see in this here what's for me the best way to actually have the whole setup for s make for various projects be generated and then be it having having it like connected with my ide which is cute creator so i finally had the time in generally to pick this up and my first thought was the one thing i didn't test last year was the ide i maybe missed that cute creater is up to speed and can generate cmake projects in in in the same way or in a compatible way and maybe it would be just as good to use just cute creator and i'd be done right one shop one stop and done so my project is a csv chart tool and i first want to start working on the csv chart lip which is this talk about and then later generate also the application and a gs csv chart cute lip library the cute creator created a library project which is something i was a aware about cute crater having this and then i added in this directory project a cmake library project which q make cute cr lets me do in the aftermath i figured out that the directory project is qake based and then i have just the c project in in the directory which is kind of fine but looking through the c code which came from this i was like ah that's probably not what i want it's completely working cmake code which includes cute which is nice and helpful to have for future projects where i probably will have to implement that but the see make itself was for me too simple cuz i wanted a different setup and this is basically most of the cake which got generated i would like to have at least a cake project which not only includes building the library but also includes building an executable which is a test and i already knew that c inot can do that so my first attempt was just get give me your defaults right that's the other thing which you probably see here the the standard you you'd have to change that it's here it's 17 that's how cute creator got this generated fine with me but i'd like to use c++ 20 at least so this is how i generated it for the first time the result of that was that it's actually too noisy clank tidy is picked up by cute crate and cute creator starts checking like everything and you get everywhere google star guide google star guide and i'm like ah that's not how i want to live so my second attempt was basically for now doing away with clank tidy because cute creator has its own clank tidy cute creator does cling tidy in a different way so and at the same time i don't have cpp check installed at the machine which i'm working with this so i was like okay just don't need that set up at the moment can toy around with it later the examples i left in but in the meantime i'm not sure like i probably going to leave that empty and remove it later maybe but removing it would be an effort this is an internal library and it's not like in a library where i want to actually provide examples how to use it so what i like is the test is basically default executable and cute creator and catch other frameworks need to be added if you don't use a package manager otherwise catch 2 is automatically installed in your project i like one issue with c creator at the beginning was that i only got the source folder with the cpp files and the include folder yeah that doesn't show up in in the tree you can have it show up if you then add those files to the cme txt file again which i did and then it works and it still builds so i guess it's okay and in earlier versions of cute creator i always had like the issue that i needed to build the library first and then the executable and here it's like really nice to see that basically i changed something in the library it compiles links the tests and runs the tests and lets me know if you know my change was correct or not and my only issue with the test executable or generally with this project right now which i have to dive into when i have time for that when it really bugs me enough as i can at the moment in cute creator i can only do debug builds normally i should be able to do a release build but that doesn't show up so i guess i need to add a kit for that or something i need to understand a bit more of this corner with kits and cake and presets and that stuff but that's stuff which i know want to look at when i when i need it so now that the setup is there i think it's time to go into the c++ code and write the library and see how this builds how it behaves how the tests run at the beginning i want to compare this new approach with cake versus the old approach which was based on cute and qake usually now i try to start with the library only which has an executable for unit tests i have focus on standard c++ and try to implement the basic maybe i add some libraries which i need maybe i don't and i add later the cute library tests and a front end i usually try to keep the pure c++ standard stuff in in a separate library for licensing purposes so that this code is not like lgpl as cute as lgpl and in the past i of kind of you know started the cute project which is a ui executable and i focused on features and progress i always have separated cute and standard c++ code if possible but i rarely have put that in libraries or like have this actually more bundled like i can do now there is no qake generator for projects cute itself generates via cute creator basic projects but already like testing is in this not covered and with other idees i don't know if they like generate projects with tests for libraries in in the modern age oh that's the like lacking which is probably one of the reasons why so many things are not in in the state where they where they should be was testing but that's a whole completely different topic so the project architecture i have in mind is like have the ui executable which is the main program it will handle some part of the parallelism but that's like a whole thing i'm not going to talk in this talk about and basically plug together the application and for the charting i'm going to use kd chart as a plan which probably already also will be part of the library which the cute app library which contains for example models the panels a lot of the glue code to connect to the standard c++ code and the csv chart lip is basically what's currently implemented it's standard c++ code for loading and searching in a csv file and then the next step is probably to add the cep library and see that this is kind of you know playing nice that i can then quickly add the executable and then really have like this all being linked together and running and into an actual application so the current version of this chart clip is what i've written and i've already made a lot of changes for preparing this talk and some of my tests and some of the the the the when when when when you go bottom up you you find out that some of the classes which you implement on top have a certain need for some functions which you didn't implement yet and so you need to provide some services from your lower classes to the upper classes and i thought i start with a class overview this is at the top i have a document class which goes into having a container of data sources which then have have a vector of records and the record holds a vector of streamie string view value classes which represent the values that are in a string view in the record okay then i have completely different search condition classes value value range value list and unique at the moment value kind of a self-explanatory and value range is basically yeah i think the only one i have really have to explain is unique is a bit misnamed at the moment has an internal container and only counts the first occurrence of a value as counting and i probably should like rename it to to to first unique or something then i have a condition list which has an enum for being and or and this then gets bound together in a variant to be the search tree which is part of the searcher class and then you have the record holder which later will be again forming a transform which leads to the graph at the beginning i thought that the searcher would basically return the graph but then i realized that i need to be able to cache the search result and not automatically transform it in the end result because maybe i want to have multiple graphs from the same search and especially like when i want to display the result of a search in a graph but also in a map i should not destroy what the record holder has and the the graph transform basically you know the data you need for a graph is not what the records hold the records hold a date and the graph transform is based on on a month right so you will completely be different there and this will be very complex to implement and many graphs will have their own specific classes so that's something which i will have to deal with later at the moment that it's like i have a few toy implementations for this which help me test this but then later i will have to see how this fits into the overall application later and then i have a crtp based class which is kind of linking value value range etc together also condition list and allows me to to build this tree in a variant actually which brings me to the first class which is string view value string view value has a string view into the raw data and then has a variant of basic types and std any any is for the case that a user supplies its own conversion for a field and as any can be anything i know this needs to be i completely its own support and this basic value variant which is those basic types at the moment is string vi bool in long in size t float double chronos seconds and sdn i'm currently thinking about also using struct tm i i don't support time stamps in the moment but i could with konos seconds why i better keep it but stru tm already has like all this data which you want to query potentially while chrono lets you easily do calculations with dates i think in our context in this context struct tm might be the better choice to basically have this all there in memory but strm of course is a lot bigger than this variant at the moment so i'm i'm not sure about that and then i have an enum which holds the indexes of those converted types so i can basically query the index function of the variant to see if that index is currently the index and compare against it [music] i have a conversion function which returns this type currently [music] but when i started thinking about multi-threading it occurred to me that error handler probably will be so error handler is a class which is you're going to see a lot this the first time you see it maybe you should talk about this first error handler is just a templated way of dealing with errors and forwarding and logging conversion errors especially here and in a multi-threaded conversion you would not be able to know of your error handler basically if that conversion has now happened to be erronous or not so this should be an optional or the c++ 23 expected would be something but i think i would like to keep error handler around so that basically you write your own error handler which is also kind of not defined right now i have a class which basically is the interface to this at the moment and then we basically do all the conversions if it's a string view i don't need to do a conversion i can just return raw data right and if the type is already in the index i can just use std get and return that if that's not the case i need to do a conversion and with bool i kind of you know do it like that at the moment which i'm happy with it's probably like still some some improvements in this code to be had but for the moment i'm happy with that and also i do not have the use use case that i actually need a bu conversion at the moment i think [music] i i do use a lot from chars and today also saw that there is already a conversion function on c++ 11 and then i think 14 or 17 added from chars and one of the interesting differences is that from chars does not eat leading spaces so if this field has a leading space the conversion will fail here but if i then try the c++ 11 i think it's sr2 d and s2f and sr2 l version this would then maybe converted so i'm i'm wondering if that's work like you know writing another conversion if this conversion fails and if the conversion fails that's basically where i saw is i from fromont chars i get this error code and then i you know would like to be able to lock that somewhere and to keep this error message basically be constructed here locally that it makes sense in the context when i convert this to std expected i'd have to see if i still need error handler or if std expected can take care of this and then the error handler doesn't not does not need to be brought in everywhere or how this basically then would look with s expected is an interesting question for me in the moment chrono needs extra handling the basic parsing from string to date is well supported if you know your format but basically you're getting a csv which can have everything and so cute has some interesting functions where various text date formats are covered and i probably have to you know figure out how to implement that with here and then try to pass them all and see if one of them catched on and this whole string is for the format string here feel it's like a difficult user interface chrono pass what not was not a level was not a level in dcc1 so i was not being able to use it as i mentioned earlier now i'm on gcc 13 and i still have to look up if it's available but for the moment that is the code unfortunately also with chrono pars i would have to use a string stream and the string stream at the moment i think is not able at least i couldn't find how to use a string view so i have to put this in a string and if the string is you know not having sso enabled by the smallness of this raw data string view we'll have an allocation here which is sad then we read this into a tm struct that's also kind of why i'm thinking that you know we might might you know just put this into the varant and call it call it the day and then we create from that the time t and the time t actually you can then convert to chronos seconds was a time point cast from the system clock and then you're good to go i've recently looked into one of the use cases i have and it came to my mind that i overlooked that a date time could be a date and a time and so that csv file has a date and the time in two different fields and i don't want to provide a functionality to join that together i might do that later but for now i at least want to see that if i can parse this and at least for chrono it's like that you can pass the date but chrono does not have a default type for something that is actually just a time without a date that can be done but you would have to implement that and search that for yourself there's some interesting comments from howard hin on various online platforms about that and actually the test case i had i when i know got this working with this is a test case and unfortunately this test case fails which kind of surprised me because this is basically code which i pass the date with earlier and now i pass the date time was earlier in the test case and then i copied it to part only the date and it fails and i just you know i remove the output i had here for for debugging p purposes this is the line and the reason this fails is here with floor then you get to have the year months date to be april 15th and i assume that has something to do with that we do not generate a time here and then it's you know using the system clock or something i i'm not sure about where this is coming from but if we use round it works i've been looking at like where did i get this and i was like this must be cp reference and i was like oh this is this is also like you know is is this correct for the example code and this this run run this code on this is run this code button on cp reference you can actually run the examples there which is very cool and if you add here round this is actually then wrong so you need you need the floor when you par the date time and that led for me to the question does this actually pass other dates correctly now or does it work for the date i picked so one thing i like to do in my tests now is to write a lambda which gets the parameters i want to test and in this case i use sd format to format this into a string and i need to do this because i need to compare against those integers later to see if you know the cusing with chrono has been correct or not otherwise i could just give it a string view but if i give it a string view i have no idea what the these are and i found it interesting that chrono year is an integer which you know years can be negative but month and days cannot be negative so they're unsigned which brings me back to the string new value class i provide also conversion function where you get already an optional to see if a field has been converted the search condition classes convert and the search transfer classes access the fields but it also now occurred to me that the transform also will have to access fields that have not be converted to an integer and the classic example is like counting fields i have like a field which tells me how many things are in this line and like for example there was tickets ticket sales as a csv file and you get the number of tickets you're not going to search on this usually you maybe search on a date to know the sales from a month and then display that in various things maybe but the counting field might be interesting to you in the in the transform when you know you want to display how many tickets you sold in a month the other thing is that not all of the transformers will have to do sometimes you just want to access the field and basically count it like a counter not like a sum and then you may want to convert it to check for correctness or just accept that it's there and just say plus one yay and this function is very similar to the previous function so i'm not going to spend a lot of time on this springs me to the record class it's basically a vector of string view values and i have a string view for the line here which i'm currently not using but if i ever need it it's there i have two main methods here the one is for accessing a record of the string new value and then there's a condition check which gets the crtp based class for conditions and the error handler and some conditions will not have a way or will not need to access an index or like an actual value in the record they will have to check the record itself so i need to see if that you know if this visitor has an interest in the index itself and if it does not have it then it just you know for example the condition list will just you know need to have the record and then call this function again with all its search conditions and its back door which already brings me to data source the data source class contains the string which contains the actual file that has a vector dra for the headers in a string view a map of the field names to the index and a vector of the records and something i didn't add here recent changed i saw that at least from the point of view of the application i should also have a vector of unique values per field so i currently have this in the data source because it makes sense to generate this once and then basically have this available the search records is just you know quoting things and counting things and returning them at the moment the interesting part is to create this class and its factory function it gets a file system path and then creates it and returns this so we read the file into an ifstream push this in in a string stream and then retrieves the stream the string from the stream and this is basically what this is based on then we have a sync lambda which gets the line and the fields and then basically call s and place back and i think i should you know move the vector then into the records [music] par csv at the beginning when i started those slides still had the comma hardcoded now there is a f del meter function which gets the actual data i check for comma as a default delimeter and for the semicolon also kind of check for the position of the first line and this might have to be you know improved with some error checking that you know we shouldn't do this on on like an empty line or something but at the moment i think that is like usess for then and the par csv function reads the headers and the actual lines with the parse line function and then just generates the various data members which it has received bya reference the par line function is basically an adoption of what of the code i wrot last year but i need to handle quotes with new lines in them and that's basically what i added that's just another mode and i given like multiple talks on pausing csvs last year so this is covered and not that interesting which brings me to document which binds us all together and logging handler is a current error handler implementation i use reference repper here to replace it and basically have a default handler i'm currently thinking that it makes more sense to have the document class be a template and have this error handler be the template parameter that the outside can provide its own error handler instead of having this hardcoded here so that's probably a change which is coming up then i have various functions to to manage this i have an an add fun function to get the csv loaded i can remove the data source i can visit the various data sources the document has loaded and i have a often a size function to return the size of the container for testing purposes and probably later in the application this also will be useful that are the methods for handling data sources and basically i have the same thing for handling the searches i've moved the name of the search into the document and the name for the search is not needed for the search class itself and basically is something which needs to be attached from the application to handle searches right to display this and i'm at the moment not sure like how i do want to do this and what's the best design for this where to put the name should it have a name should the library which just focused on the application handled this these are kind of the design questions which i'm thinking about sometimes which brings me to the crtb based class quickly let me look into the chat someone asked if i have thought about implementing a pure c++ solution for demo purposes no i have not i don't have the time for that i don't want to add a database and i don't want to cache the csv file content in sql database that's completely not the route i want to go okay so there's a question on linkedin i do not have the library currently on github i probably will do that later when it's a bit more cleaned up and i'm more certain about the implementation but at the moment i don't want to have people basically trying to you know send me their prs and something on github when the thing is not done and ready and i i do work on an application here and so the library is not the main focus and i be soon busy again with running stuff for the conference because the conference will be announced in april so let's go on let's talk a bit about crtp i kind of have the feeling that this would be a good way to implement the hierarchy for the searchers and so i've looked around to read up on crtp again and there's a three-part series at fluent c++ which covers a lot of the things which you will see now i know that c++ 23 also has something about crtp but at the moment i do not use c++ 23 so this will not be part of this maybe i you know add this later this is the basic class which i have class derived which is then declared a friend and this base class is for all search conditions the base class and private are the basic constructors to construct the base class i then learned from the tutorial at fluence c++ that you should have a method which is to derived to basically not have to write static cast everywhere and constant methods you would have to write constant static cast constant derived and derived and this way you get around this this way you just call derived and you're done and in this case we need to the two methods which are currently implemented are check and check record and name is the example which fluent c++ has and i think when i add serialization that i can basically save a document with a searches that might be useful to basically have a [music] general name and another thing which would make sense is basically to have like the type id be returned here which i guess you already could do in the base class right you have you have the derived type and you could get the type id and you could return the type id and then that you don't need to imple implement that and the type id would be a nonhuman readable name of the class and in that way derived as a friend and can construct its parent and one else i wasn't sure about how things play out and so i have at the moment not the i'm not sure about the move in the copy constructor at the moment that's there probably will delete it and see if it still compiles as a have tests and see if it you know works as as private i do like to you know when we talk about construction details here i do like to declare these as default because i think it's it's often better to have this explicitly declared as default then to just not have it there or to implement it yourself which you really shouldn't do let's go over value range as an implementation so here we see basically how i check if an error has secured currently i get the lock size and i see if the log size is still the same when we converted this and when i looked at this code and thought about error handling i began to understood that this is basically this code will give you trouble in a multi-threaded environment because between reading lock size and reading lock size again someone else can have converted an erronous type somewhere else and then you do not return and you do not convert this part which has been converted successful so i do need to return the type as an optional and then i have this encoded in the return value and yeah so so lots of that stuff is also new to me optional is a nice thing to have and i see that it's in a lot of places of things which return things it's a good thing to have then i need to have a variant which is basically a templated using declaration on all those condition types i have which is the downside of having it like that but that way we then can construct the variant which holds a condition and so we forward declare the class condition list and declare search value types with string view and all other types in the condition list and then the search value variant is in the condition list class there is an enim for and or and a mode for which just by default and because basically the searcher has a variable of this and by default it should be and that's a good us user interface and if you add a search condition list to a condition list then you have a tree which brings me to the searching part itself so here you see that the searcher had a name but this got moved and i'm not sure if i'm move moving it further but basically the searcher needs to have the condition list and the records of what has been the result and i have an add condition function but of course i should also have a remove condition function which i need to still implement i did this for the document but it's like something which i need to do here too and then basically i have the search record function which just takes a record calls check record calls add record if it's true and returns true otherwise it returns false a lot of those implementations are very easy to write now the transform search result is another thing which i'm now more sure about but i really had to try to figure this out for a week and to look into what actually my you know this is not inside the library the library does not provide the the graph format there's a graphing library i want to use and this is basically what's supposed to go in there so i'm kind of implementing something which i have to look up which what what that is at the moment and the transform has access to the full record and as i mentioned you know might need to convert the field from string vi to a sum or any things because they were not touched in the actual use case for the search the record holder in the moment does not copy the record as the record itself uses a string view so copying the record doesn't really makes sense so i put that in a reference wrapper and then basically every record gets added to this and i provide some inter iterator interfaces that this is easily accessible in a for each loop and it's just a simple class to catch the sear result the transformation as i already mentioned is a lot more difficult in the end the graphs are often number based and i have to figure out what are the things that is needed to be generated from this transform is it like one thing or the multiple things and how how do how how do i want to design this in the future and the whole thing is just you know sometimes of course you could just want to display the search result which is probably something which i do that you can see the search result which is also for debugging purposes when you debug this or actually want to see what what are the records which the graph is based on does it make sense or do i have to add another search condition so i'm definitely also plan to have like a table view which displays the records and then there's the whole topic of grouping you have group on a column type that's easy per month or year so you need i have some functions which basically return a string of a year month or something to group against or an int that's stuff of the future i did a lot of dummy transforms and thought can i you know kind of write some central things which is like the architecture of that and i reuse this architecture i have not come up with something which is reusable at the moment from cute perspective this will need to be held by a class which is a front end to the model view architecture and then there's also like an easier way to do this to basically have q vector be filled with a data and then is that is like one line or one row of bars in a chart data class which you add to the graph but this is basically something which i need to start implementing when i know what cute needs and can test this against cute and i have used model view and cute quite extensively so this is easy to implement copying your data in a q vector is then also a needed thing from from the cute interface and have to see one one when to use one and when to use the other mentioned i want to use ky chart for this which is a very nice library from kdab it's mit licensed so when you have a commercial cute license you can use it when you have an lgpl open source cute version the lgpl stays it has very advanced charts also and has 159 page manual which i've been partly reading through but not completely i have many open questions and this will be a lot of fun for me to implement that in in this and probably the coming year and the next thing to do is basically to write the application library which uses cute things and provides tests for stuff which the application uses and then to have a csv chart application which combines them but also i'm getting busy again i have to still you know do a lot of stuff for the conference and get things ready so i guess i will return to this in summer and maybe not some of the open questions i'm currently thinking about maybe i you know do do some of the refactoring for the multi threaded code which i see that is like a requirement that would be interesting so thank you for your attention if you have any questions please post them now in the q&a section or in the chat and i will try to answer them thank you much yeah i i see someone commenting that cp is deducing this and i've heard about that but i need to look into this and i do not have gcc1 14 at the moment and so actually being able to use deducing this would be really nice but i think that at the moment i'm going to shy away from doing that that's just i'm based on on gcc 13 and i'm probably for the f for the next year going to write code based on that and then hopefully be able to go into gcc1 14 and other adventures and as i mentioned this is currently not on github but i have plans to add this later and we'll do so probably within the year when the whole code is cleaned up and at some some point i have to edit to github anyways to to have it you know basically pulled down to other build platforms and have it on my notebook that i can take it with me and code in my holiday on it and i see that paulo is mentioning that if you need an educational license and you're a student or or like you know a teacher you can get that from cine for brins and yeah gcc1 14 has not released has not been released yet and so i think that deducing this in c++ 23 is very interesting but i also wait for iso to release d+ plus 23 so at the moment i try to learn c++ 20 and i i saw that i like as expected i could use because it's in 13 but i i don't know if it's like worth dragging in a feature like that already and not like have people wait for it and and gain experience with it i'm not an early mover with my code okay so there's no more questions i think we reached the end of the talk thank you for coming thank you for sticking around and