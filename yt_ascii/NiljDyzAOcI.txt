yes the harsh reality of good software yes yes yes if i have to sum up my coding skills after 15 years of software development i would probably go with something like sorry i was watching it literally on the prime react reddit page something like every a good day by the way this might sound harsh but the fact of the matter is a thought of devs f the same dang it i couldn't press it i now recognize this guy's voice we've watched one of his other things before he's really good i'm subscribing i i enjoyed the things he has said before so let's let's listen to this if i have to sum up my coding skills after 15 years of software development i would probably go with something like average on a good day this might sound harsh but the fact of the matter is that a lot of devs feel the same regardless of the years of experience in the world of software feeling like an imposter is normal so weirdly enough if you are pleased with the results of your current work you are most likely wrong let me explain i think there's a lot of a axes here that that are very interesting i i do want to let him we're going to we going let him we're going to let him explain okay we're going to let him explain but i do i do want to like i like to i i'm going to give you a fresh hot take based off that last one which is i don't think things have to be average i don't think they have to be average i think you can really enjoy what you do and lean in and try to and try to get good the thing is is that there's this weird thing that happens whenever you're writing software which is the first time you write software you're really really slow and it's hard cu you're having to google everything and then you get faster and you get faster and you get faster at doing it the more you're the more you do it right and then this other thing happens sorry alerts are on shut up then this other thing happens which is your enjoyment of this activity looks something more like this where once you start learning it your enjoyment goes up and then you've done it long enough and it's like your enjoyment goes down at least this is how i view software and so one thing that i've really found that i like is that one having like a go-to language that you use i know this is the hard part you should have many go-to languages by the way you should really have many you want like go-to languages you want like two or three of them okay this is my personal way to software happiness okay personal opinion on software happiness you have two or three languages and you have pretty much the same thing in all things and then when you build software you can build it efficiently and in different ways each time like right now i feel really really happy with where i'm going with this whole this whole vim what do we call it this this this vim this vim platform for developing games my vim go realtime game engine is really really exciting to be developing right now on stream and i've really genuinely enjoyed it okay is it useful is it awesome are people going to like it probably not do i understand all the pieces individually h generally i do but i'm i'm kind of exploring how i can be really efficient with lua and then i'm using it as a mechanism to make go one of my go-to langu is at being fast so it's like i got all the go goodness i have lua as my base that i'm really good at vi as my base that i'm really good at and tcp protocols that i'm really good at bad things go so i'm using a bunch of fun parts and a bunch of bad parts to where i don't ever kind of intersect on this one on accident because this is where things get really hard you know like when you're year three writing basic react apps and crud apps it's like sagness is right here so like how do you how do you write more decorative and cool things like how do you explore deeper and harder problems a lot of it i have to go get you know on my own but i kind of have like a framework for how i approach a problem i typically don't like to approach a new problem with a new language because i like one part of because cuz then i'm right here i'll be right here i'm just googling everything trying to understand you know and then i feel like i'm really low on the enjoyment difficult is really really you know difficult's way up here right cuz difficulty is like the inverse of productivity and so it's like i like one i like one of these to be true some sort of new problem new aspect new challenge paired with something i'm good at and then i can really try then i'm just learning one thing right and i can move fast while moving slow it feels good i don't know me personally so i don't i think that you have to be average all the time i think you can solve and have a really good time if you can try to figure out how to do something like that that's just me personal me personal kind of thing right writing good software is actually really hard but before going into the details let's acknowledge the harsh reality of building software products the only absolute truth we all end up accepting sooner or later when it comes to software nobody does care real talk no one cares about how hard you worked on your feature oh you stayed up six nights in a row and you develop that feature and then the public goes and uses it and and if it breaks it all you're a piece of  oh it doesn't matter that you just completely slaved away to make something nice it breaks once and people hate you it's so absurd but that's reality and i'm not saying it's good that's just how things work dy is in the eye of the beholder in other words nobody beside your team really cares about your clean code your domain driven design or the layers of abstraction you preemptively added in your code base i not saying preemptive added let's go awesome awesome let's go that was awesome let's go w take this is right or fair i am just stating a fact outside the de team people are way more pragmatic product cares about the customer sales cares about releasing new features management wants you working faster better and preferably cheaper qa simply want you dead nobody knows what hr really cares about but it's probably safe to assume is not your code with this in mind knowing you are fighting an already lost battle let's see why good software still matters and how to enforce it in a world filled with deadlines conflicting priorities remote work and affordable streaming services so far we're starting pretty based we're starting pretty based it is also hilarious that hr was the only one of that group that also later on in their acting career has become super omega canceled hr is literally the devil in this case both in the movie and then later on in real life like that's pretty good that's pretty good that somehow they nailed the the usual suspects so well with hr right there there is a big distinction between working software and good software on the surface it seems like good software makes developers happy while working software makes everybody else happy here's the kicker though bad software that works will eventually stop working there is a mismatch in priorities as long as the software works nobody outside of de team will prioritize fixing it i hate that reality i hate the the thing that i hate more than anything else is the good enough approach the good enough approach i hate it so much because for 20 to 30 to 40% of the time it's the right decision but it's made every time and you just get this backlog of stupid stupid things that all they had to do was be fixed and take a little bit of time to make it a little bit better and it would just make life so much nicer but it always is well it works we got to move on let's go and like i said that's right 20 to 40% of the time but there's another 60% of the time that it just fs you and fs you every single time it's human nature to focus on immediate gains take the profits and then kick the can down the road however in the long run software must be well written so that it can evolve seamlessly and meet the ongoing needs of your organization so i don't know about the that last part it doesn't necessarily have to be well written i've come across some pretty ugly code in the last few years i'm just going to throw that out okay i've i've seen some pretty ugly ass code that works well okay and and people like it and the person who works on it can continue to work on it and so i'm just like you got to keep doing what you're going to keep doing okay buddy keep going you know saying doesn't have to be the bad news is that even though nobody else cares about it writing good software is still your main responsibility on the upside writing good software is really easy at least on paper on one hand your code has to be clean concise i don't like the word clean we should just quit using that that word because it's too overloaded i like the term concise concise and properly tested properly i very we we talked about it yesterday so we won't do it today but properly okay i i i hate the idea of clean code i also hate the idea of even readable code i think readable code is a myth okay readable code or clean code is a myth and i do mean that oh you don't oh you you don't believe oh you don't believe me oh that's funny okay okay okay hey you know what fair so let's just open up the react project at a specific commit and let's how about we grab out let's see let's grab out the reconciler for should we do old js or new js which one do you think would be better to use how about let's just look at react portal no this one's not that one's not that one's not big enough how about some how about some old fiber new okay you know after a while you start working through this thing and you start thinking man this is such like how long does this function need to be damn that function is like how long it's 111 to i mean that's 100 lines of code man this doesn't feel like this doesn't feel good right this doesn't feel good at all man this is not good at all like this is going to be hard hard and then you're going to start then the better part is when you start walking through this code and really starting to understand it and then you start realizing how many layers of abstraction exist here but here's the deal can we all take one second you guys are all saying well react's not good code i'm going to hit you with the inverse the inverse uno people who wrote it think it's good code people who wrote it use it and like it they've put it out there and they've worked hard and long on it to be the way they want it to be so guess what some people think that's some nice clean readable code some people think that that is the worst code they've ever seen readable code doesn't exist readable code is the time of day the mood you're in the familiar familiarity you are with the subject and that's that i mean there is such things as shitty code shitty code does exist but most of the things you call like clean code or pretty code or whatever doesn't exist i'm sorry to tell you this it doesn't exist there there is shitty code though there is objectively shitty shitty code there is objectively shitty code but that's i find more of a rarity than anything else s out so that you and your team can easily maintain and extend it in the there is only shitty code that's my hot take this is not a hot take this is this what everyone should accept everyone should just accept this as normal normal take there's just degrees of shitty code and i'll tell you this much the code you wrote 6 months ago somehow you find it to be completely shitty and when you wrote it it was amazing people qed that's called q e d okay i proved it literally mathematical proofed the six-month theorem okay all code is shitty future on the other hand it needs to be secure and efficient so that your product doesn't require an entire power plant and a vip aws account just to run in production there are enough objective metrics to immediately evaluate your code when it comes to performance if bazas calls personally to thank you for your contribution to his most recent nautic acquisition you are probably doing something wrong creepy [laughter] clean is that how you laugh richly is that why i'm not rich does the does the laugh come when you're rich or do you laugh like that and then you become rich what is it how do you laugh in billions is that i got to figure that out we're going to figure that out thought code is much harder to assess though after all there is a reason you have 1,000 page books on the simple concept of writing code despite being a complex difficult topic there are a few basic principles you can follow to ensure that the code you are writing i really like this first principle this might be the best principle ever fight abstractions think is on the right path there is a fine line between writing good software and writing over complicated usess code experienced developers will tell you that you should always assume unexpected changes when writing code well the problem is there a lot of experienced developers a lot of experienced developers will also abstract to be ready for unexpected change es such that their stuff is so ready to be malleable and movable and all the good things and then what ends up happening the unexpected unexpected happens and every abstraction you've ever written was actually incorrect and you have to rewrite your layers of abstraction into a new layers of abstraction because this time you got it you got the perfect one you actually have the perfect one this time you know what last time it wasn't perfect but this is the perfect one i find that sometimes experience makes you worse programmer than a better programmer this is kind of dumb if i'm expecting unexpected changes those changes are actually exting right of course this is an oversimplification the idea is that products are in constant change and your code has to easily adapt to new requirements abstraction is the main tool you'll use to make your code more flexible but this can easily become a slippery slope planning too much for what might come will lead to premature optimizations which as we all know are the root of all evil david wheeler sums this up pretty well all problems in computer science can be solved by another level of indirection except for the problem of too many layers of indirection the problem of over abstraction can be easily solved david wheeler we're tweeting that that's a great one that's a that's a quote of the day right there that my friends is a quote of the day science i know i spelled ind direction wrong oh i can't fe great now how many how many things all problems in computer science can be solved by another level of indirection and post and too many problems of tion except for the problem of too many layers of indirection the problem of over abstraction can be easily solved with something that's rarely excel it talking with other people software development should not happen in a vacuum you should talk with domain experts to deeply understand the business logic and ask questions as often as possible preferably before you make any software design decisions i have a a small rule of thumb here which is first build the atomic pieces of whatever you need part two make a couple things with those very atomic pieces it can be messy it can be ugly it can be whatever think berkeley sockets right berkeley sockets are like atomic pieces you know listen accept bind right like they just very very simple primitives to work with once you know your pieces and how you put them together slowly after several times you've built something then abstract over these tiniest amount right right berkeley sockets are like primitives is how i kind of look at them you can't really you it's it's much harder to get less abstract than berkeley sockets you're you're you're pretty much at the bottom of the barrel right it's it's not like new tcp server you're you're really stepping it down you're you're down into constructing the server yourself versus new tcp server and i feel like once you've done that a few times you can see the path for new tcp server with a good understanding of the requirements the next thing you should focus on is the form of your code uncle bob's clean code has some great tips and tricks to make your code more readable and easily maintainable if you are not a fan of reading static code analyzers like sonar cube he lost me okay hey i like uncle bob okay i think that it's good to have those challenging thoughts but you have to overcome them okay i mean that i don't think small focus small focused functions is good i think this is generally a bad idea i think generally you find yourself sagge when you get into a a code base that has a bunch of four to six line functions as uncle bob shoots for generally i think that that is it hurts but consistent coding styles i think is fine readable not clever again that's totally domain specific comment and document i'm very wary of comments generally i'm very wary of comments just because comments just tend to go out of date and eventually you get to these weird ones that are like we use seven instead of two because of this and you're just like this seven and two don't exist within this document what have i done test is fine consistency is fine use prettier right one is good use meaningful names like you should cross out two and five yeah i mean five is tricky five when you repeat yourself enough you should really think you should really think of that there's an abstraction being declared you're discovering an abstraction you need to know what the abstraction is but what is it right what is the abstraction you're seeing what have you missed obviously and so like there does come a point when i've repeated like the sixth i know five is a trap though 100% that's the problem is it takes a wise person to let five exist right that's it's it's hard i don't understand to what does it cause the problem is is when you have a when you have a a codebase full of small functions it becomes exceedingly hard to find anything it requires a lot it requires a like to to to to to actually figure out what a function does it requires so much hopping around so there's like i'm always very careful about breaking things up too much you don't want code that's hard to follow i have a i have a friend and and he said something that kind of really blew my mind and i'm still thinking about it i'm not sure if it's right or wrong it's different i didn't like what he made me unfactor something and i didn't like it but he says optimize for reading code on stash or on github which does make you rethink about how you write code you won't pull out as many functions and you'll think about okay really what he's saying is that the context should be all within ey shot of what you're looking at it's it's ey shot development right you should be able to look at something and understand what the thing does right you don't have to learn new abstractions i'm not saying it's great it's just a very interesting take that i've been thinking a lot about if you are not a fan of reading static code analyzers like some on or cube will enforce most of these patterns in a cicd process one big mistake we often make when writing new software is that we take the opportunity of new projects to follow the most recent dev trends and test new technology stacks there is a time and a place to acquire new skills most of the time however this is not during the development of software menant for production the best tool for the job is the tool you know best and if you want to fight me on these please take it to the wordpress devs they still run like half of all known we sites after all the final piece of advice we've talked a lot about the right tool for the job on this channel and like i said pretty much everyone thinks when when people say the right tool for the job what they mean is the tool they're most familiar with i that did not that did not break me at all that literally confirmed what i've been saying repetitively which is people don't have any sort of concept of what what what the right tool is for the job they have what i am most familiar with to get the thing done that is why there is an excel roller coaster okay this is why this exists is most likely the one toughest to accept when in doubt trust your old self and avoid refactoring code just for the sake of refactoring going back to the beginning of this video nobody is happy with a code they wrote 6 months ago i would argue that one of the best skills experience developers have is the ability to jump into a code base fight the urge to rewrite everything and perform the necessary updates in a simpler manner that is a good skill to have by the way define excel roller coaster what do you mean define excel roller coaster what i did gi that was wrong you can't go to last insert that's not how you get to the url excel roller coaster here is an excel flip you're going to have to take out the music likely there you go here is a roller coaster in excel it's literally a roller coaster in excel so when i say the right tool for the job sometimes someone is so good at something the right tool kind of gets misrepresented in their head well wait i thought it was an analogy no i'm literally saying someone will write a roller coaster in excel if you ask them what's the right tool for the job okay this literally happens though it's impressive but when you get too good with a specific tool all tools will lead to ram okay that's what i meant by that comment is people are fundamentally bad at judging what the right tool is for the job and so am i okay i'm bad at it too the bottom line is that sadly knowing all this theory will not make you a better developer good software is the result of previous poor design decisions thousands of lines of spaghetti code technical depth and a lot of other lessons learned from past projects you are not failing you just found 10,000 ways that won't work and if you are happy with the code you are writing today don't get your hopes up it will still suck when you'll have to debug it 6 months from now if you enjoyed it pre-at did i did i just pre-at that did we just pre-at the six months from now no one's accusing me of pre-at it you know why because i lived it okay i lived that one the powerpoint coding was scarier this video you should watch one of these ones next until next time thank you for watching i really dude i really like awesome awesome software i'm sure his name must be awesome coding there we go i like awesome coding i like him a lot i think he makes some really good videos you got to go subscribe to this guy i'll link it in chat for sure go subscribe to this guy really great videos really great videos it's a you know it's the reality of what we do okay if you again if you come into this hoping that it's glamorous and it's good and it's what you see on twitter you'll be disappointed go into this thinking that you're about to solve the problem where somebody is giving you a 1.4 gigabyte tarball instead of the 14 megabyte tarball that it should be because we haven't built the process to actually give you the right thing and now all of your stuff is blowing up and it's taking entirely too long because you have the put enough value to get the thing off the ground and that's what's happening okay that's how life that's how it works okay you literally just realize like oh this is this is this is just programming programming is you falling on the sword of somebody else's shortcut and twitter very specific example yeah that it's literally happening to me right now that's why it's so specific is because that is my current like one of the things i am monitoring is the size of an effing tarball okay it's still like literally the tarball should be no big bigger than may like maybe 300k but we it's down to 100 megabytes so like that's a w that's like a that's a huge w it's not 1.4 gigs anymore with 500 megabytes of json localization in it so like that's a huge win i think we can all agree that when you when push comes to shove we don't need that much localization yeah i would agree i would agree we it turns out we don't need that it's for testing and stuff like that it was for testing it doesn't even we don't even use any of it we don't use any of the code turns out you don't need the tarball node modules directory okay you don't need to cuz you only use a little bit of it it turns out i'm at the point where i like the code i wrote six months ago now instead of writing better elixir i'm trying to learn deeper beam magics to do more interesting things than i did before and also how to optimize certain things beyond the standard lib structures and functions this is a good place to be this is that whole like learn one thing and learn it super super well the thing you don't obviously want to do is end here right you don't want to end here but you can also end in a really nice place where you're actually just constantly comfortable and you're able to solve real problems and you're solving interesting problems like it is definitely a hard balance because you will you will eventually become the roller excel roller coaster guy just got to be careful that one thing oh no i i'm tired of jumping around i did two years of of rust i really started to like it i started actually kind of getting good at rust and now i've jumped over to go i feel like i'm actually already better at go than rust and i'm going to keep playing with that one i i i've enjoyed it and i think i'm just going to stay focused on there and and vim and i'm just going to make a bunch of really really really funny and stupid live video games in vim and go i like that and just get good at that and get good at that and enjoy it literally making a vim roller coaster next like literally i'm making a vim roller coaster and i'm going to enjoy it and sometimes you got to make a vim roller coaster sometimes you just accept the fact you're writing a vim roller coaster vim go temple hdmx yeah all the good stuff really all the good stuff bubble bubble te for ssh or for for twoe applications there's some good stuff out there the name enjoy what you got to do you know at the end of the day just enjoy what you're doing if you can find a way to not look at a problem as inconvenient but as as an opportunity to learn and get better your life will significantly be better despite not actually like being better in any objective way it it will be the same thing you'll just be so much more happy so do that enjoy what you do