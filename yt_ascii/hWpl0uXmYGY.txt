playing with the garbage collection so this is simon death amazing youtuber for those that are wondering no i have not fixed my screen tearing you are welcome i'm still on i3 everyone's like oh don't worry just adjust all these settings i've tried adjusting the settings i cannot get screen tearing to go away but sway somehow alleviates it all so i just haven't done it yet okay i haven't done it yet okay i had the i had the undo sway due to some presentation problems i had and now i'm i'm willing to go back let's get ready you need peacom you're right because i'm definitely not running effing peacock fun i'm running peacock look peacocks now officially running screen pair will still happen it's not pick up okay i don't want to talk about it shut up about this great terry all right here we go we're gonna do screen tearing everybody oh windows helps let's get right to the point shall we is javascript's garbage collector as bad as some people think it is on i wonder if any of these things are me i'm like oh who who said these things are they me because this is really what i you know so me personally so i'm just gonna i'm just gonna come out there and say it it depends on the activity on a server an improvement and garbage collection rate can make a huge difference if your server is under load it can make an enormous different i'm i assume with games you have a lot of the same things it just depends on how they're all made they might all be me i have no idea so let's poke at this a bit and see if we can learn something yeah yeah basically when you allocate memory in languages like c plus plus you have to explicitly free it otherwise you have a memory like playing worms in languages like javascript c sharp java go these are all garbage collected languages they handle a good chunk of the memory management for you yup abstract memory management though also ends up being you know it's not the most efficient form but let's keep on going but it's really lovely to program them right at some point javascript has to decide when you're done with it yup so if i allocate an array here's my array somewhere in memory and then i fill that array with stuff so a number a string really doesn't matter now if i go and null out one of the entries in the array this little blob of memory here kind of gets left stranded now it has no connection to anything anymore nothing refers to it in other words it's not market sweep going on right here we can't reach that little blob and thus it's garbage it's safe to reclaim that memory because nothing can possibly be using it anymore that's the general idea anyway let's see it in action with some code there you go if you haven't read about it i believe v8 has a really good breakdown of this mark and sweep v8 if i'm not mistaken they have like a whole yeah they have their whole talk about it pretty cool pretty neat stuff lots of stuff blah blah blah they also you know they have it for all their v8 stuff it's pretty interesting you know the memory management stuff it's pretty interesting it's pretty cool again i cannot believe that v8 that team has created or created an environment in which javascript can potentially run fast which is shocking all right i will increase the speed done here is i've written a really dumb test that just spam fills and object with random strings and other objects this is called by a request animation frame kind of this is and not an educational comment remove the captions now i keep captions baby get out of here stop telling my business everyone shut up twitch i'm gonna throw punch you i feel like you would in a game loop so yeah there you go okay data set it to empty to start yeah then i loop over and create a bunch of junk in there basically a linked list or random names and these all have to allocate memory the strings take up memory as do the objects themselves this data variable isn't used anymore at the end of each loop so we're achieving our goal of wasting hold on we start at the start oh he's creating like a linked list sort of right interesting approach this is a very interesting approach so he's creating an object with a singular key as far as i can tell take the singular key do this and it's going to create a linked list 20 deep a hundred thousand times right memory enforcing the garbage collector to act so in order to actually test this you need to be able to measure how much time jobs really the memory tab tools button and dig around there but there's actually another way that's slightly less known this is chrome tracing the backbone of chrome's performance testing framework hundreds of benchmarks measuring who knows how many thousands of metrics are built on this in another life i was an owner here and even led the info team monitoring and processing all this data it's pretty cool you can see and attribute time to various calls see ipcs between processes in general it just gives way way more info if you've never used telemetry by epic games it used to be by rad gaming tools this is very very similar to that one there are some obviously you have huge impacts into performance taking all this stuff but it's it's fairly lightweight you can watch you can see a lot of internal tools it's it's the chrome tracing tool profeto for our personnel i think it'll just be easier to focus on what we want to know garbage collection events yep so from here you can start a trace and then start recording you just need to wait a bit to capture enough of a trace just capture however long you want you don't need to wait to 100 percent this uses the doom keys to move wasd so let's zoom in and we can look a bit closely at all these garbage collection events and we can see that we were successful collector i wonder if he has any major gc's versus minor gcs because there's also time in which you hold on to garbage so one thing that he's not talking about is how long are you holding on to it what's the difference between holding on to an object for a small period of time versus holding on to an object for a long period of time they're very very different doom keys i always just called awasty but i guess did was the doom the first one to do wasd oh he'll talk about it awesome oh these minor gc calls are v8 and action reclaiming memory if we're lucky maybe we see some major gc calls in here too they can be very expensive versions of vh garbage collection in action so that brings up an important question before we move on what is a minor gc versus a major gc that's a good question simon thanks for asking that yeah yeah v8 has a great blog post that talks in depth about orinoco their garbage collector and goes through some of the high level details on their collection strategy generational hypothesis in garbage collection i think most items die really young also called infant mortality because why not just use super morbid terms for memory i didn't realize they called it infant mortality damn that is a little dark i guess i didn't i didn't read the i didn't read the wikipedia article on generational garbage collection i mean i knew they called it a nursery that's typically what i've heard is a nursery i didn't realize we're also killed killed the baby at this point it's okay it's strange strange management but as a super hand wavy explanation v8 basically divides allocations into new and old you have the new generation and the old generation start in the new generation so if i allocate a string here it starts out in the new generation specifically the nursery section part of this new generation then a garbage collection pass happens and let's assume that some objects are reclaimed and others aren't yep if our string happens to survive the first garbage collection attempt it gets copied out or evacuated into a sort of intermediate area it's not old yet but it's not brand new either yep another garbage collection event occurs a bunch of other stuff gets reclaimed if at that point we find that our object survives if it's still in use it gets evacuated out to the old generation v8 makes this distinction so that it can apply separate strategies for the new and old generations the minor gc the scavenger is optimized to collect from the new generation while a major gc which doesn't have a cool name like the mutilator or anything does the heavy lifting of sifting through the old generation yes we fast also interesting and interestingly enough when i was at netflix a lot when i was doing a lot of the recent profiling stuff because i added in for one of our upcoming tools i've been kind of playing around with i added in a counter for all the minor and major gcs and i'd keep track of everything that's happening so that we could have performance regressions and then i created something that would spam through the video player a bunch of events and kind of have the whole thing tested so that as we make changes if we make a change that causes a bunch of more garbage collection it will show up on a pr and fail your pr kind of a little clever a little clever thing because you know garbage collection is really real it can certainly cause a bunch of you know oopsie daisies yeah by the way i work at netflix yeah no we could call it the reaper or something so by looking at the trace of our first test we can actually select the first so that means we have the baby killer and the and the euthanizer like what do we call this thing like just horrible names can we just come up with just horrifying names for those two garbage collections minor and major obviously we have the infant mortality and now we need the other side damn there's 10 seconds or so of the trace and we can see that there were 384 occurrences with minor gc averaging about 1.079 milliseconds each and 56 occurrences of major gc at around 0.838 milliseconds each so our test is getting va to do some minor and major gcs so we can change this test around a tiny bit to try and poke the major gc into action i like it so what i've done here is i just take a random subset of the data and i stuff it into this dot stuff overriding whatever happened to be there this dot stuff is permanent never deleted for the duration oh super clever way to test this this is actually a fairly clever way to test this i mean i guess the one thing you'd have to do is go find out how long how often do major gcs happen and you'd have to make sure it happens enough times or how many times what's the frequency of minor gcs and make sure that you can skip enough generations to go into the into the into the into the to the the old the old fogies home for a garbage but this is super interesting strategy love this strategy super cool absolutely love this strategy very very smart because i've done a lot of performance doing and i always have this thing where i usually just use a timer and so normally i never thought about just using a global stuff it and then just keep rewriting over so eventually that data also just dies effectively creating multiple connections to the piece of data super super clever and i'll probably use this in my next test i love that they keep a bunch of random things for a lot longer than a single call of do something stupid and promote things to the old generation when we get a trace of the whole thing and we're just going to select the first 10 seconds or so of the trace and we can see that this is indeed what happens we managed to force the garbage collector to work a bit harder and we've added some time to both minor gc and major gc to try and understand the relationship between allocation patterns and minor gc and major jc does anyone understand why minor gc ended up having more a little a touch more work the effective idea is that remember every single one of those objects had effectively 20 little baby objects on it it was a linked list and so some amount of those objects would last into stuff and so that means your minor your first round minor gc now has to hold on to something longer which means that it's going to have to do more searches in those two buckets before it promotes it out of it right or at least that's like if if if that's exactly how it works you have you know young intermediate old i'm not sure if that's exact i don't know if there's a three bucket generational garbage collection i'm not exactly sure how the garbage collection works but fiddled with this a bit more just means there's more objects to look objects but make them more complex this is the trace here we'll select the first 10 seconds again and looking at it minor gc isn't changing a whole lot but major jc is changing quite substantially nearly doubling the time taken versus simpler cases i poke at this a bit more by adding a setup step to the test where i just allocate a whole bunch of perhaps and store it but i've never referenced in the test but it's there when we look at a trace of that we see our major gc calls getting much more expensive although there's fewer calls to major gc each invocation is taken that's the big kicker right there which for a game would be basically a skip frame something so this is actually really interesting piece of information especially if you're most i assume most of you are working on servers right using servers so holding on to data longer you're really understanding your garbage collection cycles and holding on to data longer like i'm saying dater why do people say dater why do people add r on the end of things with like that end with a anyways because i've heard people say china and dater anyway so if you're building a server and you have to hold on to date it along like you could imagine that a request can last quite a bit of time you know quite a bit of time in computer time data you know i believe data from star trek would say it's an eternity but it would happen and you'd be able to hold on to enough to actually skip through some gc cycles you can make your major ones have these huge long stops and that's where you get these little request spikes and so it's it's fairly interesting looking at the stuff like how can you move out of the major world and into the minor world because the minor world is almost always really really fast and small star trek nerd nerd okay first off brett spiner is a champion okay everybody else everybody else but riker and brett spiner can can just off but just saying people are going to be so excuse me there's a relationship between the american crap you have allocated and how long the gc takes which i mean is hardly surprising it has to figure out what you're using and not using it's not magic if you were using another language where memory management is explicit such as c plus plus yeah it wouldn't matter how much or little you have allocated there's no ongoing cost for having it allocated you only spend time allocating freeing yep whereas in javascript there's definitely like attacks on what's currently allocated yep i tried a few more experiments not only that but there's also remember there's the reason why you saw minor gc also increasing is that there's a whole tax of managing this memory and moving it up up the chain there's you know remember that it's not free so when you create squirrely marks it's not just simply a give me a piece of memory it's give me a piece of memory keep track of that put that into the stuff make sure that we have a link to it then you have to go from there and make sure you check it you have to market like there's a whole bunch see if i could make money so what i did here was i allocated just some random stuff in a loop looking at the trace we did spend quite a bit of total time in minor gcs while time is nearly 10 of the time in fact although each singular call to minor gc was just shy of two milliseconds so not quite the crazy long time major gc took i took another stab at it by allocating sparse arrays and just randomly setting values in there and va kind of laughed that attempt off nearly 800 minor gc calls but they ran in a pretty negligible amount of time i consider 10 to be pretty bad but simultaneously it's a ridiculous setup so maybe instead let's build a somewhat more plausible game setup to see the effects of gc in action again i i'm not sure if games are the best measurement because games theoretically also have you know what's called some dead time some idle time theoretically you know i know that's not quite it you usually have every single team have some sort of allowance they can each have so that way things can all run together i get it it's that's not how it actually works but in a lot of simpler games you have a bit more dead space whereas if you're on a on a you know on a server and you're just constantly hitting as many requests as possible when you're at load every gc makes a real impact into requests you'll actually see a slowdown in requests per second due to gcs and keep on going there's a quick and dirty game setup so what i've done here is a super basic bare bones game in quotation marks i don't bother actually rendering any of this but we do simulate the entities so you've got this list of entities we call update on each one when they die we destroy them then filter them out and we keep a stable population by creating new ones in their stead the entities themselves do some legit work so they have a transform data associated with each one technology health and they have a spatial hashgrid client to track their position in the world you ever hear the story about how quaternions were invented i forget who it was i want to say hamilton is the correct answer but apparently walking with his mother-in-law if i'm not mistaken and then etched the quaternion formula into a famous bridge so clearly whatever his mother-in-law was saying either a was exceptionally inspiring or b was so boring that the only thing you could think of was imaginary numbers just saying this man have video on quaternions too oh really okay cool yeah i did you know i was this florida masters and graphics as well i did a lot of exploring as you guys have you've probably heard by now you're like wait a second you've told me you've tried to do a masters in ai software engineering graphics algorithms what the hell haven't you done okay i spent a couple years in school maybe learning you know maybe i was really into it but ultimately ultimately unfortunately academia killed the rock star what's the video killed what radio killed wait video killed the radio star that's what i was trying to quote and i got that way wrong i can't even remember any other entities they also have this update function to do some random stuff i didn't feel like making the logic extensive so i just repeat it a few times they shoot off a bullet so they create a bullet and that's added to the world let's just face it when we're fully charged we all shoot off bullets if you think about it bullets are their own thing they have a full transform their position is updated according to velocity and eventually they explode and kill nearby things i took a few traces of this running shows a bad one and we can poke around in here a bit if i select the first 10 seconds or so of the trace we can see some numbers for minor gc in major gc look at that major gc shorter in here do you see that major gc right here average cpu i mean average but either way 1.117 versus this one was oh whoopsies that was i was reading the first one that was three seconds calls taking on average less than half a millisecond but adding up to around 240 milliseconds or so there's not many major gc calls barely anything actually the ones that do fire take a little over 1.1 milliseconds each there was always going to be some overhead for garbage collection but at the same time this is written super poorly realistically an experienced game developer will code with memory allocations in mind yeah let's make this a tiny bit better but a slightly improved version of these entities in the main loop we actually reuse entities instead of allocating new ones themselves where i just constantly harp on this all the time looking at a trace of that version though we can see a monster of a difference whereas before we had around 500 minor gc calls this version gets 110 or so and a touch over 50 milliseconds of total time spent there it makes a huge difference of time one really interesting thing that stands out here is that in the first example let's zoom in and look at these minor gc calls they're happening during the frame sometimes multiple times yup meaning that they're contributing frames in the second example they're happening in the idle time between frames which is totally by design v8 specifically built this feature into chrome when it detects there's an idle period that's where v8 has the go ahead to quickly run gc what i kind of got from all of this was that short-lived objects are often pretty cheap from a gc perspective that doesn't mean they're free though but if you can get them down low enough they may just run in the idle time between frames and you may not see much in terms of overhead for it the more crap you keep in memory the longer lived cash stuff the more expensive your major gcs are as we saw with my stupid synthetic test i love this i love i love i love this video i feel like this is just a much better version of what i've been yelling at all of you guys about for like the last two years this is fantastic simon dev you're getting my own code though usually so this could probably be at least partially mitigated in the future by just letting me tell you via some sort of apis it gives hints to the garbage collector something like that i don't know i've given this a full 10 seconds of thought you'd need to actually plan this out more yeah one major problem with javascript though is that although for your own app you might be able to control your allocations yeah third-party stuff you have very little control as far as i know i mean in something like c plus plus it's sort of the same deal but at least you can override memory allocation at a global level and depending on your application extend this to third-party libraries as well in javascript no such luck i can't isolate a third-party library to its own memory pool so that's just something you have to live with another thing is that yeah of course there's a cost of having gc direct management will be more performant when done right but in reality decently made games don't just allocate and free on a win either most do it in a very controlled way i've spent enough time moving systems to different allocation patterns linear allocators pool allocators lifo and scratch pad style frame allocators in order to ring out extra performance c plus programmers may love to toot that horn but even among game devs that was usually handled by just a few people at the studio not everyone in japanese you have some control over memory but it's pretty tenuous mostly it's down to your pattern of allocation minimizing allocations by reusing objects that sort of thing maybe you could go crazy using type this is one reason why i really love using classes is that classes are extremely easy to reuse you get not only do you give the exact blueprint you're going to have to v8 assuming v8 is attempting to optimize things like that is one of the best things you can do is like here's the exact thing that i want every single time right so it's it's fantastic in that sense and then second it's extremely easy to reuse a class because a class you can just make a method reset like you know like a really good thing that people don't realize is that wherever you have to add a bunch of callbacks right especially like web sockets you have like a server that connects unconnects a bunch of web sockets those listeners aren't free it's a it's a little bit shocking how expensive those listeners can actually be and so by taking control of that and having a class that binds itself to methods and then you just simply hand those bound methods every single time and when you reset you unlisten hey you have pretty easy life cycle management but b it actually allows you to not recreate those handlers because not only do you have a function you're also creating a bound function which is a function holding onto a function that gets held on to for a long time it just adds in a lot more right so it's very very interesting but let's save that for another time and lastly how much memory overhead does json curve for doing all of this i do not believe classes have instantiation costs like you're saying i think it's significantly less if you ever have to use a raw object you first off you have to have you have to have an api that is not attached you do not get free lsp okay so baloney right and second you're gonna have to what i mean by that is like okay so if you have a okay so you could imagine you have some sort of const you have some sort of a type you know foo that has oops i always forget that you have some sort of food that has x string y string z string there you go right fantastic this object exists and then you also want to be able to have some functions like do foo one it does it takes in a foo and therefore it takes in a foo and it returns out i don't know a boolean return i don't know food.x plus foo dot why look string concatenation rope strings equals foo why not right okay fantastic now the thing about this is that this is going to exist in some sort of module somewhere and so instead if you have class foo which does have all these exact things up here right here right paste those all in blah blah at least if you have doofu up here right you can do something that's a little bit nicer here which is when you instantiate one of these you at least get food dot foo up hold on 11 up here we go let's go one go down here and go foo one right const foo what is it foo we'll call fu one equals i don't know newfu one there we go blah blah at least when you do this you at least get the method right you get the things hanging off versus when you only use flat objects first off taking flat objects and then you need to reuse them means you have to delete properties off of them deleting is very very slow you also get these structural problems there's all sorts of crazy things that happen but b you also have just like basic lsp you have to know where this method is and if there is literally like still 15 or 20 of these different functions you have to know of all the functions or you have to go to the file to go look at it or you have to do what i think is one of the worst things which is import star as you know foo foo functions from you know from foo right and that is like the most annoying thing then you're then you're looking on this thing for the objects of food then you call you know do foo and then you have to pass in the foo itself i hate that i don't want to do that okay because then not only that you can't chain then chaining totally sucks because now you have to this whole like foo function do food too go bid that right like even if you pass food back out it still sucks right i hate that i hate that i hate that i understand people in the javascript world love their functions and objects but it's super super super annoying having all that crap sorry edward way way easier to have a reset function way way easier to pull objects that's just why i tend to just lean on classes the end how's the performance on firefox etc etc great questions no idea didn't test those maybe next time love that answer throw some comments about what you'd like to see tested in the future until next time thank you simon great guy simon hit that subscribe button right now it'll be linked in the description absolutely loved it simon perfect perfect perfect talk loved it yeah give them some clappies give the man some clappies hit that subscribe are you still using alacrity of i never used alacrity i use i use some terminal from the 80s you know why because i don't care my terminal is fast enough i don't need your gpu rendered text okay i don't need it you know when i press zoom it just bumps up the font size okay i don't need font size for 20.69 okay it doesn't matter to me i just need 420 or 421 i don't care okay i don't care that's that simon's a genius absolutely clearly genius beautiful voice the end