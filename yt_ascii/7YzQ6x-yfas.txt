prisma five faster by default like that's good right i i do like my defaults to be better so this is good all right prisma 5 introduces changes so hey by the way i should probably put a little bit of context on this why am i reading this what are we talking about with prisma what are we doing with prisma well the reason why we're doing this is yesterday we read an article that was like a seething review of prisma and so i want to give prisma a better chance a chance to do you know what they're doing because often you find that seething reviews sometimes are due to not often sometimes you find that they're actually skill issues and they're not actual problem issues so prisma let's have prisma give a chance at showing that they're super awesome because i've heard nothing but i mean i've heard so many great things about prisma so i'd be shocked if the seething review is actually 100 correct okay anyways these changes especially improve the experience of using prisma in serverless environments thanks to a new and more efficient json-based wire protocol that prisma clients use under the hood i mean jason i mean i get it i get what you're trying to say okay improved startup performance in prisma client from a prisma 4.8.0 we have doubled down on our efforts to improve prisma's performance and developer experience in particular we focus on improving prisma startup performance in serverless environments in our quest to improve prisma's performance we unearthed a few inefficiencies which we tackled okay okay they're trying to make things better to illustrate the difference since we began investing our efforts in improving performance we consider the following graphs okay the first graph represents the startup performance of apps deployed on aws lambda with comparatively large prisma schema with 500 models before we begin our efforts to improve it okay prisma client prisma connect prisma find many wow that's a that's a lot of a lot of units okay what's this one this one schema builder db connection dmmf i don't know what that stands for dungeon master and then db queer okay okay the following graphs show prisma 5's performance after our work on performance improvements okay so they've really improved find many that's good i mean i think that this looks good to me i i i like that it it appears to be an order of magnitude better okay okay well done well done i wonder if they talk about the bottleneck here so that's good okay that's good as you can see there's a significant improvement in prisma startup performance we'll dig in and discuss the various changes that got us to improve state a more efficient json-based wire protocol prior to prisma 411 prisma used graph wheel like protocol to communicate between prisma client and the query engine i always thought this was strange i think this is also just like a prisma thing it sounds like you still have the prisma engines you still do some sort of ipc inter-process communication or maybe some sort of localhost loopback call whatever you know i don't really love that i don't really love that idea just in general especially if you're just doing a server not serverless serverless you kind of go you know you're just like performance just make it happen because you just you know the garbage collection cleanup system calls all that crap that's all on that's all on them i just want my stuff to work but if you're running your own server you know increasing all the things leads to slower rps you know so i'm not a big fan of that but i can understand why they're kind of doing it this came with a few quirks that impacted prisma's clients performance especially on cold starts in serverless environments okay so this is probably a targeted serverless change is my guess i really do hope that they also i i because yesterday's seething article really was about joins so i really hope that they talk about that during our performance exploration so for those that don't know joins are done like in their rust client and i think i think that it's because they assume underneath the hood or there's some sort of defaulting to mongodb and so if you're using post gree you're not getting you know you're effectively neutering the database and using rust as a means to join right and so hopefully they talk about that during our performance exploration we noticed that the current implementation added a considerable cpu and memory overhead especially for larger schemas reasonable reasonable people are still suffering from web scale these days i know it's crazy one of our solutions was to alleviate the issue was a complete redesign of our wire protocol using json we were able to communicate between prisma client and the query engine significantly more efficient we released the feature behind the json protocol feature okay i'm surprised they used it just on you know like because i would assume that their protocol is fairly unchanging and that it would probably be easier to use a more efficient protocol betwixt the two you know what i mean i'm still a little bit surprised about that protobuf flat buffers some sort of binary communication something that just makes a bit more sense than jason because jason by itself that when you do it in javascript you're effectively ensuring higher garbage collection right json feels fast because we're slow stupid humans but just on overall can be a big performance tank especially when you can't like say ring buffer out your memory right that's where you're going to get you're going to get a lot of good stuff from that before we begin work on performance the average cold start request looked like this okay so i i assume these things are all concurrent internals is that like the engine it must be some sort of engine it's weird that these lines meet up so there must be some sort of like thing that happens the ski the connect the underlying database connection once that's done then the find many happens which then the d m f down mother dungeon master i don't know what it stands for then the actual db query okay let's see after enabling our json protocol preview review the graph looks like this i am super curious about this how did the db connection how did that happen how does that get so much smaller when you have json versus graphql like how is gra how is graphql adding a whole entire second it does that doesn't seem right something about this something about this seems incorrect because also again why is find many also massively smaller something else they had to do something else because that makes no sense that just adding a json protocol causes causes things that shouldn't change really you know what i mean tons of loading time parameters and like huge amounts like i know but like what okay okay can probably tons i know but what is the loading time huge chain of dependencies okay but is graph wheel that big is that what we're hearing well it's not just prisma connect if you look at the graph if you look at the graph it's both prisma connect and find many right whatever this is so this they don't define ddm dd d m f i really wish they would define that because they don't they literally don't say it once in here and this purple disappears in this graph there's no more purple so what is it what is the purple what is can can someone tell me what it is does anyone know a data model meta format okay thank you okay it's a data model meta format it it is an ast syntax of the data model in the form of json the whole prismacline just is generated based on the dmmf i'm still super confused how that took i mean i guess i don't know the problem real talk i don't know the problem i don't know the problem so i can't speak to it but again i'm very confused why this right here again how did the query get smaller how did how did connect get so much smaller there are market targets fresh gens using serverless and forget that no real company uses it well a lot of companies use serverless i'm not gonna i'm not going to argue against that obviously it's much quicker now i just wanted to know why i'm just super confused like how big was this other client because that's what it says to me is that but that's like a one-time cost because when you use something like import you do not lazy load any of your javascript you load everything that's one of the problems with import that people don't realize is that tree shaking also means that you get like like get right like that's what it means because now you have these huge parse times instead of like having only the parse times you need as they come so there is a there is some things well i mean obviously functions if you wrap things in functions you also get a lot of the part-time benefits you know so if you wrap things in functions functions often don't get parsed it's just like the top level thing and then it keeps on going right it's a one-time cost i know but that's what i assume this one-time cost is because one second of javascript can process millions of objects on pretty commoditized hardware so how are you spending a second doing that how are you spending this long doing it right i just i have a lot of questions here long before any of these things but fine we can move on after a lot of great feedback from our users and extensive testing we're excited to announce that it's just on protocol is now generally available i love that capital g capital a generally like is that a known term is this like some sort of thing that i need to figure out about and it is by default the wire protocol and the prisma client will use under the hood so if you're interested in further details we wrote an extensive blog post that goes in depth into the change we made to improve prisma's client startup performance okay so this could be some sort of good follow-up or something to look at but so they must have done something there all right smaller javascript runtime and optimized internals okay this is good besides changing our protocol we made a lot of changes that impacted prisma's performance with the new json based wire protocol becoming the default we took an opportunity to clean prismus clients dependencies this included cutting prismas clients dependency in half good most codes you use you barely need any of it and you often like one of the problems of javascript it's that you know that article we read about left pad people reach for a dependency so fast that most the things you can do are very very simple and narrow scoped and removing the previous graph wheel like protocol implementations this reduced the execution time and the amount of memory that prisma clients use nice awesome okay that's positive we also optimize the internals of the query engine specifically the parts responsible for transforming the prisma schema when the query engine is started and established the database connection also we now lazily generate the strings for the names of many types in the query schema which improves the memory usage of the prisma clients and leads to significant runtime okay that makes sense because if you have enough items doing it all up front when you only use a little bit of it that does seem a little silly right there's your problem graph wheel like sounds like it was yeah that that probably sounds like it was hand rolled yes because it's like it's not even graph wheel it's like it you know oh someone's talking about something something it wouldn't let's see i also wouldn't be surprised if there are many many many messages between the engine and the client so serialization and deserialization was probably way slower in graphql land than in json yeah that's probably reasonable uh where the json is fast because it's not actually javascript to decode yeah yep well actually javascript decoding of json i think is currently faster or on par with rust and one of the reasons why is that i if i'm not mistaken saturday still doesn't have that good old-fashioned cmd in their in their jsonning whereas whereas like the the javascript v8 jsonning is ridiculously fast you know what i mean it's ridiculously fast so i mean it's pretty good that was right that's what i'm saying is json serialization and deserialization is already really fastened yes it is okay that makes sense compared to hand rolling your own thing yes hand rolling your own thing is almost always a bad idea you're absolutely right sorry my bad sorry sorry sorry sorry foreign in addition connection establishment and prisma schema transformation now happened in parallel instead of running sequentially as they did before okay before we made these three changes the graph the graph looked like this okay so we have we have import prisma okay that takes a little bit of time there connect find many do this db query okay after making these changes the response time was cut from two thirds i'm it's interesting so what does this thing do the schema builder how does schema builder work odb connection oh i see what happens so db connection and then this goes to right here again one thing that always keeps confusing me is that when they say this little feature right here again is that they run something in parallel so they show us something in parallel and what this says to me is this one's larger this one is like absolutely tiny how did it improve db query i think you have a measurement issue to me this seems like you measured something once and you called it a graph it was better and you called it a graph which may or may not necessarily be the best way of doing things because this makes no sense right like how was how was db query faster it's just how is this thing faster how schema builder faster if it's just running in parallel right like i would expect this bar to be approximately the same and this bar to be approximately the same which it does look like it so it looks like these two are approximately the same so they're they're the same read the other article also yeah connection established oh plus these oh okay okay okay okay okay okay okay okay okay my bad okay so there is some other stuff okay i thought it was just that one sorry my bird brain couldn't have all that memory i i'm not rust request now leaves a very small footprint for a zoomed in comparison on how the changes impact your prisma client okay the first graph shows the impact of json based wire protocol okay before json okay good this looks like a great this looks like a much better graph even though this fine to many is a little odd how you know maybe that's part of that maybe that's part of the whole decoding that's actually taking a lot less time cool okay so decoding takes a lot less time i guess that makes sense because now we have this whole no more graph wheel like and so therefore it's faster okay i can buy it hi youtube the following graph shows prisma client's performance after we optimize the internals and reduce the size of the javascript runtime perfect try out prisma 5 and share your feedback we encourage you to upgrade to prisma 5 and and are looking forward to hearing your feedback prisma 5 is a major version increment it comes with a few breaking changes we expect only a few users will be affected by the changes however before upgrading we recommend that you check out our upgrade guide to understand the impact on your application okay so one thing they didn't address which i am still the most concerned about so the thing about prisma that most concerns me is none of these items though this is great stuff i didn't realize how slow this was so this is fantastic great work prisma you did an amazing job joins your query engine still does the joins itself as opposed to what the database does or is that a misunderstanding from the previous article we read i'd love to hear more about that how you handle joins and all that because for me that feels like a no-go right so i would love still do many db queries no it's not so so like for me i i that's like a no-go right for me that's a full on no-go if you can't do simple joins without doing right and so that's you know it's important for me it's important for me okay this is an exceptionally long performance article so we'll we'll do this will we do this we can do this another time this is exciting i'll read it another time we got the main takeaway we'll read it another time but what about the dx i don't care about dx nearly as much as i care about performance okay i find dx is completely subjective if you can write ross wheel it's really not that hard so are you really buying something maybe if you feel more comfortable database migrations huge argument for prisma prisma apparently has amazing database like migration stuff and all that so i could totally buy that i'm on your team that sounds great but is it that hard i think sometimes we we we do these things i know i've seen you i've seen you mention this many times i hear it i hear you i've already said that dx actually reads dicks it does it could be so i i understand that they aren't trying to replicate squeal type joins over molly aren't they trying to yeah i think they are they aren't they in entirely different models they they are but i think they also work with postgres is that true do they work with postgrey drizzle drizzle seems like a squeal builders seem like the best squeal builders seem like the best thing i don't want to be harsh on prisma unduly right i have a very simple requirement i want joins i think i i think me personally i find squeal builders better but that's a me personal again is that trail yes we use prisma and prod with postgres and serverless so this will help a lot okay so there you go so this will help a lot so exactly this right there so a good orm should take into account the benefits and the negativities of each type of database like this is one of the reasons why orms are so amazing is that you don't have to know all the cool things to make your query fast it should do it for you right like that's part of it and so if you are if you're if you're truly just getting roadblocked because of that it seems incorrect second on prisma and plus also only being ts i think is always a disaster i think you should try to build something in many different languages if you're trying to be like the the go-to for everything you know just me so so basic apps is pretty much enough to pull db connections and spend hours writing the queries i mean are you really writing queries that long is select star really that hard you know prisma still doesn't return the total items for pagination with a single query so you have to send two requests yeah see there's a lot of these kind of things which are very very hard to do right this is but this is more of like a typical orm problem than anything else's orms are really hard this is why query builders tend to be really nice it's why i generally rely on query builders because for that it makes a lot more sense because that way you can kind of craft the thing you want and it supposedly is going to give you the best query you know what i mean so base squeal knowledge it doesn't take it doesn't take much to learn absolutely it takes almost nothing most of what you'll be doing in sql is extremely simple it's not it's not crazy i've heard of i've heard of this i've never used it all right anyways i like where you're going prisma keep at it i'm also ignorant in the topic so don't take my word as gospel oh jen