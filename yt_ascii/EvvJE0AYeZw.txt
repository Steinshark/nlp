um before we start who of you is already knows what tdd is or has been in f's great talk right now okay all of you that's great i assumed so much who of you is working on microcontroller okay about a third great so all the rest of you will get an impression what the difficulties in embedded really are the ones who already worked on microcontroller maybe get a few new ideas how to apply tdd but first maybe a little bit of background so i used to be an embedded software engineer i worked in safety critical systems so when i got there i assumed there would be a lot of testing there i mean even before i was a before i was an engineer working in traditional software like server backends and desktop programming and even like 15 years years ago it was pretty common to do unit testing in this traditional software development some people even did test driven development so when i first came to embedded i was astonished that unit testing is not really used that much and tdd was basically unheard of and i think this is still the current situation i mean more more and more people use unit testing but tdd is mostly not used deeply embedded projects so in this talk i will want to get an give an overview what the obstacles are if we can use tdd and yeah present the state of the art and give a few ideas how we can improve from there so this will not be a talk about tdd itself yeah we just saw all of you are basically familiar with tdd so what what's important for this talk is this tdd micro cycle first write a test have a failing test because there's no implementation yet then you get the implementation right and you get to this green part and then really the magic kicks in because you have to safety net if you developed all the parts of your application of your program with tddd you can freely refector change things and you fall back to your tests and you know you don't break anything this is really for for the sake of this talk the most important benefit of tdd and this requires and this is really the heart a quick and automated feedback loop feedback in this sense you try something and you get feedback if it's working as intended now tdd was made popular by kent beck so all of you want to read a good book test driven development it's still relevant it's from 2002 but it gets the basics really good so i highly recommend it so what's different and embedded than in traditional software in traditional software when you want to try it when you want to get feedback you run the program yeah and the in the most simple situations you just click on the binary run it click through the application and get to the part you want to test yeah it's a manual test but you can just do it in embedded it's totally different to to test something in embedded you need to get the microcontroller get the hardware you need to flash your binary on the hardware and then you need to execute it there and you cannot click through it in most cases you need to use maybe sensors maybe send some data to it to get it in the relevant parts of the code so this process is much more manual and timec consuming yet this this ray here of of trying code is really like the standard yeah a lot of people working on deeply embedded stuffs do exactly that so in traditional desktop programming or traditional programming we got unit testing to test isolated parts of the code and this is really the the core of tdd yeah right good unit tests and the key of unit tests is that they focus on some parts of the code and basically can ignore the rest you abstract away all dependencies and then you can focus on single part this means for example if your application has a dependency on a database you abstract away the database insert a mock or something and then you test against this abstraction and you can focus on on your code and the question here is can we do this in embedded abstract away all the code we don't need and focus on the parts we are interested in can we use things like unit testing and embedded and in 2011 there was really ground breaking groundbreaking book on it test driven development med c from james granny who read this okay only a few people i can highly recommend this one as well it's fully applicable to embedded c++ as well it deals with how unit testing can be applied to the eded word and the important principle he established is so-called dual target testing and we will first now focus on dual target testing so basically i will explain the most important concepts from the book and then we will see what is still missing and how we can proceed from there so dual target testing means you run your unit tests in different ways on target testing the part on the left means you run your tests your unit tests on the microcontroller so target means microcontroller in this sense so to do this you need need to develop code and test you do this on your host yeah your desktop machine then you cross compile it so you use embedded compiler like mgcc or kyle you have a binary and you can flash this binary to the target and run the test there and of course you need some way to view the results on the host this is called on target testing you test on the microcontroller and it's kind of slow because you have this hardware dependency and it's a little bit difficult to automate so james grenning proposed a second way he called it of target testing and in of target testing you execute the test on your machine so you don't cross compile you compile with your standard gcc you run your tests on your pc and you view the results there this is obviously much faster you can even run it on the ci so what kind of code can we test with of target testing and what kind of code do we need on target testing for let's first start with off target testing to do off target testing you need to comp compile your code with your desktop compiler i brought a function here cc32 it's basically calculating a check sum and returning this so the inputs implementation is not really important the inputs are range of bytes and the output is a 32bit value so this stuff is supposed to run on a cortex m33 three so an arm cortex controller can you just take this code and test it off target on your machine okay why not exactly exactly we can't this header here probably won't be available on our desktop machine yeah usually a lot of these headers are just shipped with the tool chain so they belong to the compiler and they won't be available here or on our pc fortunately if you take a detailed look at the function this header in this case is only used for some custom 32-bit definitions and that means we can decouple this code we can say oh since c++ 11 we have this standard header std int and a 32-bit value is in the standard so the code can be generalized to make use of the standard header and now it will behave the same on the target but we can also run it on our pc and this is great because of target testing is the fastest way to develop and test code so we can write a unit test like this yeah give it some sample data run the function on it and compare it to some magic value yeah we get from some some example or maybe there are website generators for for csc we can get somewhere and then we know the implementation works you can screw up a lot of things in csc calculation it looks simple but there are so many parameters you easily screw up okay if there are any questions by the way please feel free to just raise a hand and interrupt me i think we have enough time today for that so what is of target testing what do you need to establish it you need a certain setup and for most ed projects who don't use this yet that's a new thing they need to set up a different tool chain yeah you need your your primary tool chain is your embedded compiler like kyle you need an add another tool chain like a clang or microsoft visual studio code or gcc or anything else for your host so if you use cmake for example you can use these toolchain files to to give it another tool chain and then you need to compile parts of the code that you want to run of target and of course you need to integrate a unit test framework for that the good thing is here you are off target on your pc you have basically unlimited resources so you can pick any recent unit test framework like for example catch 2 and then and this is really the critical stuff for for embedded projects you need to make sure to decouple the relevant code from all all hardware dependencies it's really easy to get a hardware dependency when you program for for embedded microcontroller yeah maybe some some included nested header is is some definition that won't work on your on your pc this is really the critical part decouple especially for legacy projects okay but then we can run this code and we can have a quick tdd feedback loop so all the requirements are fulfilled we have automated feedback and it's really quick great so why we don't use off target testing for anything there are two important limitations and the first one is there are risks and unfortunately even in safety critical systems a lot of people are not aware of these risks so i brought a slide here with a little code snippet what you see see are two functions and function one function two they are just printing out their name and returning an int and there's a third function fu taking two int arguments and also printing its name and in the main function you just call fu with a return values of our two functions and if you execute this on your desktop machine of target you get a different result than on target for examp example on the cortex m4 arm cortex anybody knows why this is in this case yeah exactly and this order of evaluation is unspecified the standard says this is up to the compiler implementation basically so yeah the c++ standard just says the order of evaluation of arguments is unspecified okay and this is a definition of unspecified behavior it depends on its implementation so the compiler writer can basically decide which implementation he chooses and of course this can make a difference in program behavior it's pretty obvious so of target test would have a different effect than on target there are much more risks i won't go into details there are other language specific things hardware problems your hardware can have defects you can have bugs in the tool chain if you look up how many open bucks there are in arm gcc you get really nervous and they are losing yeah each week more bucks are introduced than solved most of this is rather you you would hit these behaviors rather seldom but seriously if you do unit tests and you have an option to catch these things that will take you days and weeks in production to find why not use it so for for these risks to mitigate them you need to run your off target tests also on the microcontroller on target only then you test the object code that will really end up in produ there's a second more fundamental problem and this is hardware dependent code so your csc function could use some hardware functions from your microcontroller so for example all these examples will be based on an stm32 microcontroller and this controller has special function registers hardware pery for csc calculation so you see this code really writes to this special function register here and here and returns some value of it and obviously you cannot compile this code for your pc your pc doesn't have these registers it just won't compile and the question now is i would like to write a unit test like before can i do this test this hardware dependent code and the answer is of course you just just need to establish on target testing and this means you have to take your codebase and again integrate a test framework if you use an embedded compiler these compilers for all of you are not working regularly and embedded projects often have to use really old compilers for different reasons and these compilers don't support the latest c++ feature so sometimes you cannot use the modern libraries then you need to use maybe a c testing library like unity or cppu test but you will find a unit test framework that compiles also with your ancient cross compiler so choose a unit test framework and then you adapt it so it compiles for your target and somehow outputs the results yeah maybe stream the results to the u to the serial line and this you can catch on the pc and display so this is in principle pretty straightforward you can have automated feedback yeah you need a setup you can do it and this feedback can be quick the bottleneck is usually the flashing of the microcontroller but for many microcontrollers you can get down to like two or 3 seconds with decent tooling so it's pro it's possible to use tdd for this hardware dependent code that's really important there there is there are no things preventing you from using tdd you can have this quick feedback loop which brings us to the i would call it state-ofthe-art in testing and this is pin behavior i mean we are talking about embedded systems and they are called embedded because they are embedded in some environment and their primary purpose is to interact with the environment yeah maybe measure some some value with a sensor maybe control a motor interact and this interaction happens through the microcontroller pins and only through the pins so a lot of deeply embedded code is about getting the chips to do the right on the pin level how can we test this behavior i mean how can we test this piece of code here it's the the purpose is to set send four byes on the u and it's using the hull library from st it's called cbmx so basically within this yellow function here the code will do a lot of accesses to special function registers to the periphery of the pin to to get these signals on the line and what we need to what we want to know is if we write this code here will this have on the line that's a logic analyzer attached to the pin showing us the result and unfortunately that's state-ofthe-art you program it and you look at the pins and this is really cumbersome because you need special setup you need to access a pins maybe you need to solder to access them you need special equipment like at least a logic analyzer but if you want to send data you need a serial probe if you're working on c you need a can dongle all kind of pery and if you need it you don't have it or it's used by some colleague it's it's really a hazle it's really a hazle so what can we do how to test this manual based testing i just um told you that and it's really the the common way there's an alternative register based testing and it's i would call it industry standard but i think it's deeply flawed at least in the context of tdd so let me elaborate a little bit the idea is to not that we don't need to look at the pins the core idea is hey we have a specification we have our reference manual for all of you who don't know this is a very long pdf very long like a few thousand pages filled with a detailed information on each page there's potentially important information it's crazily dense yeah but it specifies what happens if you write certain values to the registers and the theoretical idea here is okay we use that we rely on this specification and if we do what is written in the specification everything will work i don't need to test it yeah so what does it mean here let's say you are initializing the u here and inside this function there will be a a part of the code that's setting the bout rate the speed at which signals should be transmitted so it should be 115.2 kilobit that's our goal so let's write a test for this using register based testing let's execute this code up to to the init and then we just assert against a specific register we look up the reference manual there is a about rate register it sounds great so let's assert against the content of this register the init function should set it so let's just test it okay how do we get this value and now it's get gets to real fun i mean phil talked about the damine you won't get damine there i i will will tell you that so first you need to locate the chapter for this stm32 the u is in chapter 57 that gives you an impression already you you you you briefly look up how how long it is okay only 86 pages that's okay you look up this register great you found the essential part and it actually doesn't tell you anything about the speed it tells you i know this is a little small in in the back but the contents here not not not so important so it basically tells you what bits you need to write to access a a value called user div okay that doesn't we need to look it up in the manual and then you find an equation and that's that's good the bout rate is some clock i presume divided by the divider by this user div okay great but what's the clock you go further and it's getting smaller yeah you find the clock here and it's divided again by some prescaler and another clock that's all in the u chapter so pretty easy 86 pages but the clock here this user clock it's described in a totally different chapter about the clock tree and this is really the relationship here on the left is your input clocks like an external oscillator and then there are a huge number of configurations and then there is this clock coming out so yeah you need to know all these values to calculate the magic value for br to be sure that it's 115.2 kilobit and i think you would agree this is not fun but okay maybe we can do it but there is a fundamental second problem so the first problem was it's just complex to find out the correct values and it's not the problem is not so much the itself but the interconnections between different peripherals if you need to think about uard you will also configure the clock tree okay but you also need to configure the pins that for example this gpr pin switches to art functionality and really prints out the u stuff so there are multiple components inter interacting with each other so this is difficult to find the correct register values the second thing is much more problematic especially for tdd it's a white box test you test against a specific implementation because what what you did here is basically the same you would do when you implement it and whitebox tests don't fit into tdd because in td you want this refactoring to work make changes to the code base and be sure that your tests catch if the functionality changes let's say you change the prescaler and the br rate registers both by a factor of two this will cancel each other out the bout rate is the same but the registers look totally different so your test will fail so this is a fundamental problem in register based testing so sorry we need to find a way to involve pin behavior yeah to really test what is happening at the pins and not some thoughts about or or assumptions about our implementation test at the pin this is what what will drive success of failure in the in the production as well so what i will now tell you is something we at my company call open loop tests it's a new way of testing code that is hardware related and make ch changes at the pin level so open loop testing makes three requirements first you need to have your pins accessible so you want to test on the pin level of the controller so you need to have it accessible second you have your code accessible so that you can call single functions in the code and see what they are doing and the third and most important one is you have to make your periphery accessible so that you can for example write a test that sends a can frame on the pins so that you you have a test system that can be configured that you can send frames on the pin level or send spi commments or iarec or all the other hardware periphery stuff there are a lot of protocols out there but on the pin level not in some simulation so the following slides they are examples based on our execution platform this is our first commercial test system for open loop testing but the principles i show you apply to everything else yeah you can with with the principles i tell you you can basically set up your own open loop test system so what you can do when you have this kind of test system so the test system here this is important integrates your specific microcontroller there are hundreds and thousands of different microcontrollers so the test the microcontroller will be plugged into the test system now for our thing these little pcbs look like this so small pcbs with an connector and all the pins are on the connector and the chip is basically here and then with this principle in place you can write tests the tests for our system are written in robot framework it's an open source framework really good framework for all kinds of automation if you go into this direction take a look at robot framework highly recommended and all the functionality and the periphery is available here as keywords but yeah we have enough enough time i will make a brief demo let me switch [music] here okay is it readable in the i can increase the size a little bit yeah it's okay great so what i'm showing you here is an online version of visual studio code and this visual studio code is connected to one of our test systems so we have physical hardware and we will test this sdm chip i mentioned earlier now so what i want to show you is u test so let's say we want to check that our device under test do is receiving your data we send data to it on a pin and we want to test that this data is actually processed and is arriving there so on the c++ side we have this function here in a main function we initialize the u basically this is copied from from the cube mx from from st pins are initialized clocks are initialized and then we have here this is important the definitions about bout ray we want to send eight bits we want to have one stop bit no parity and then we start it yeah and it starts receiving here so this is the implementation on our microcontroller and we want to test that it's actually receiving data and for this we register a certain function we write a helper function it's called show reed it's over here it basically looks at the uard looks if there are characters that were already received and prints them now with std out that's it no no magic here in this function that's important stuff make this function available after this register the test system can call this function remember it's for for open loop tests it's required that you can call functions on the on the chip and then just messages from the test systems are processed so let's go to the test sequence here the test sequence as i said robot framework does a suit setup this is executed one time at startup and this suitup suit setup flashes the firmware so it takes the result from the c cpp the binary flash it is it on the microcontroller and then we call this endpoint the the interface to a specific periphery we this case uart our test system is configured to have a uart on these two pins the microcontroller is also using we initialize it with a bit rate no parity one stop bit and eight data bits of course the same configuration we use for the target and that's it we can write a test now test that a single bite is received by the do or the microcontroller same here so for this we will use the test system endpoint to transmit data so let's just transmit hex data of maybe 6b and now the the system will send this data on the pin and we need to read it from the microcontroller so we will use do invoke this lets us invoke any function that registers on the target i think it was called sure received yep so received and then we need to get the output that's written to sd output we save it in a variable this is now a syntax from robot framework not so important and then we can do our assert like in a unit test we can say should be equal and we take the first line of our output and now we need to compare it against the output of the show received function so rxx and then the actual value should be 6b okay i click on compile here and then i run the test so now this firmware is flashed on physical hardware and on a physical pin the data is transmitted and it passes great let's just copy paste this and make a few more bites test that multiple bytes are received let's use 7 c8 d e x 9 e and then we need of course to change the expectation 8090 let's run this test as well it's passing as well and what's important here what i want to show you is the speed of the feedback yeah i run the test or the suit both tests and within seconds i know that the implementation is working on the hardware no menual steps here and to show you that this is really running in hardware i'm opening the logic analyzer this demo system here is connected to a s it's a logic analyzer and the test system can be configured to output arbitrary data to the logic analyzer so we will this we we see the receive and transmit line here so let's start capturing just to see if there's happening really something happening on the physical lines and we are not living in a simulation i'm running the second test capturing stop this is great i need to zoom out a little bit yeah so here's data on the receive line of the uard and these are the three b three bytes we really wanted to sent so you can always check that this is really happening on the pin level and you can compare arbitrary signals this is great for debugging i mean phil mentioned it earlier tdd is about writing tests but in some situations you just need to debug and look at the pin level okay so that's a feedback loop but let's use this i mean we have tests in place let's change our implementation now let's say you have noise on your line and you want to use parity parity is just mechanism that in the ur data one bit is calculated with a checkum yeah and this is done in hardware so we use odd parity we don't change anything else we recompile and the only thing we need to change in our test is the configuration of our endpoint we need to match it of course so let's have odd and then let's assume you do this on your desk maybe you run a single test then you run this f first test that's sending a bite and the test passes awesome seems to work we ship it to production now please not let's run both tests because an error was introduced here i think it's you you won't be able to read it but it tells it tells that it's not received it it should have received 7 c 8d 9e instead it received 7 c0 d 1e and this is one of the situations where an embedded developer pretty pretty easily spots the mistake like kevin said with his special date values and so on it looks like the eighth bit the the most significant bit is set to zero for some for some reason so obviously our change didn't work and for most setups this would have been catched only in production later yeah but we want to do test driven development so we can take a look in the implementation again we set the parity and maybe we are lucky in the st documentation tells us what the parity is doing and yeah it says when par is enabled the computed parity is inserted at the msp position of the transmitted data 9 bit when the word length is set to n data bits 8 bit when the word length set to eight datab bits so they have a pretty specific understanding of datab bits they basically say yeah datab bits is not just datab bits but also parity so they overwrite the data bit here fortunately you can just set it to nine to the word length of nine and then we have the behavior we would expect from other implementations so we recompile it and again we use the tests and now everything passes and this is really only possible if you have automated tests in the case of the execution platform that's how our system is called there's really everything automated so you need to write need to wire anything you can attach all the pins at runtime basically [music] this demo is by the way public so i will later have a slide with a link if you want to play it it's it's free and public you can experiment for yourself so let's go back to the presentation nope second yeah okay great so that was a demo that was the example i just told you and now a little bit summary for open loop testing so the important part is really the setup to do this in your projects you need to make the pins accessible the code accessible you need a way to talk to your code running on the chip and make the periphery accessible so if you need u you need some u dongle if you need can can dongle and they need to be all scripted and automated now then you can build such a solution up and then for each test you write the code compile it for your target and you write this test and run it on your desktop machine the robot code is running on the desktop machine and then we really have a way to use tdd even for code that's behav that's changing the behavior on the pins we get quick feedback it's automated a few seconds if you do the setup right but even if it's 10 seconds it doesn't really matter yeah the important thing is you have automated feedback and that's it basically on just just a summary and maybe talk a few seconds about scope so we saw off target testing you can run all your generalized code on off target testing yeah all the code that's compiling on the pc as well be aware that there are risks so if if possible that in any way run the same tests also on target yeah if it you you need setup for this but then you have all the benefits and mitigate these risks on target testing can be used to test in internal periphery so for example the crypto unit crc flash writing all this kind you can you only need on target testing and the third thing is open loop testing what we call open loop and for this you need special special equipment but you can test basically everything the microcontroller does in the with the registers yeah because the pin level is the most important interface of the chip we should be able to test it there are a few references on the left i really recommend this book here by james grenning it's from 2011 but highly relevant okay that's it thanks for listening of course i'm ready for [applause] questions hi thanks for the talk so my question would be like this on target tests look more like integration tests when we like comparing to traditional this unit integration test separation so like let's say in your projects how what part of like how many how much of the tests belong to on target test and how much of to of target tests so basically all the off target tests should be run on target as well so the the coverage from from everything you can run off target you can also run on target and you should use that it's really a one-time setup and if you it it it really depends what kind of project you're working on most projects we are involved like industri scale projects maybe different microcontrollers and they are running for the the projects running for multiple years so all these project can and they do make an investment in the test equipment upfront so they use all the the testing also on top target if if i wouldn't have this setup you really need to think a little bit strategically what kind of parts of the code are really the most important and focus on that ones i mean if you don't want to use on target testing you can also say i'm using sanitizers and code checking everything and rely on that but in the end these are all tools that also cost money and effort to maintain so i would really introduce always introduce on target testing for serious projects and maybe just it's a bonus slide because you you mentioned integration testing and yeah that's really a it's a discussion yeah what what are we doing here so traditional unit testing is called like component testing and this test pyramid the the lowest level level and if you do open loop test if you do on target testing i would say you are still doing unit testing just in a different environment because the concepts are really the same for on target testing not for open loop open loop is a little bit more up so from from this perspective what you do in open loop testing is basically replace the you use mock for the external interaction that's what it really is so it's a it's a mix between unit testing and in some norms it's called hardware soft tigation testing so this level here did did this answer answer your question good hi i i was wondering cu i i'm a bit familiar with rob framework and it's i know that it's quite the pile of python beneath yes how do you guys handle like even mild real time requirements like let's say i have a i don't know switch the bouncing routine to test take something really simple how how do you handle like even the possibility to toggle the pins randomly fast enough yeah yeah that's a good question so everything that's running in robot is not hard real time so you have basically no no definition how long these comments will execute they are running on your pc so everything that is time critical is moved inside our test system so in the system there is an f fbga handling all the real time requirements and for everything that really needs real time you call specific keywords for example for this toggling example you have a keyword that sets a pin for like an arbitrary amount of time and you can run pulses with like 100 neros seconds or so because the test system is handling and not robot framework is emulating also with this work emulating the hardware instead of running it actually on the hardware yeah that that's a a really good question and there's a lot of debate about it but so people tried this emulating the chips and for the simpler chips like from 25 years ago this kind of worked now and they don't do it anymore because they just noticed the model of the periphery to get it done in simulation is just too complex and has we we have too many faults in our simulation that it that it's really usable so for example arm they they recently offered they call it virtual hardware so basically hardware in the cloud and they are modeling everything up until the pins so they model their cores they are cortex m3 core m4 all these cores they they basically own the the ip and they put a lot of effort into it to make really good models and this is working but from this level on there are just too many many peripheries out there there are certain microcontrollers that offer this but it's really hugely expensive and you always have the danger that the actual model is not really using i mean to to to know that this is a problematic approach look at the erata like make up the erata basically says what's wrong in hardware yeah and you you find it detailed list like 10 pages or so from really intricate things that they did wrong in hardware and they make a lot of tests before they put this hardware into silicon so it's really difficult and i would always recommend to really run on on hardware i have a question is it on i think so yeah so i have a question you said you had some experience regarding functional safety do you already have some experience how much the tff likes your tests no not yet so what i do know is there are different approaches basically to to testing or to to assuming functional safety there are this black channel and white channel definitions and from what i hear so our system was not yet used in a for for certification so i can speak to it from what i hear they really the the norms are sometimes requiring for example an automotive but they try to get around this pin level pin level testing really what they do a lot is like this register based testing yeah it's really a thing even in functional safety and i don't know of any examples that use this test level like this mix between unit and hardware software integration testing for certification if anybody knows an example i would be we should talk later yeah yeah a question to to a test approach that that we've seen lately and grow fond of what do you think about basically unit testing what you can test without hardware interaction and leave the rest to integration tests so the question here is first what is integration testing i mean i i know a lot of projects that use do unit testing and then system testing that's like in in industry projects it's they have a department for testing and they do system testing and what department is running the integration tests in this case and your your example it would be the system test department then the system okay so yeah it's a way to do it what you need to consider is the feedback time yeah so if the basically in in these situations the developer does something and throws the code over a fence and then different department is acting on it and you have like a few days maybe weeks maybe months feedback time and this is not suitable for tdd but yeah in i mean if you have these tests that's a good starting point yeah a lot of projects don't have these tests at all maybe a follow-up question how many bugs did you did you find in the low-level pin tests i mean for this for this to kind of trigger you would have you would have to have issues in either your configuration or in the final hardware right so most of our custom i mean we are selling the test system we are not so so i can not give you precise statistics but most of our customers they are like projects they write their own hardware abstraction layer their own drivers because they just see on the market there are different microcontrollers and they have a lot of projects but they want to reuse code make platform based development so they take the cheapest microcontrollers for each project but they want to reuse code so they need the same hard web section layer so basically they start reimplementing all this code that is sorry that that you see in the for example the h from st i mean if you if you start implementing the hull these functions here you have a lot of work and then it's not just configuration but really testing your specific requirements against different families yeah maybe one is an arm and one is a something entirely else a trior something so it's it's not about configuration it's also about configuration but if if you really use to reap the benefits of this is when you also do the driver programming any others no nothing online okay i think we are done thanks again daniel thanks for listening