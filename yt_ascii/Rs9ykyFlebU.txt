so hello everyone deconstructing inheritance the name of my talk you can find the slides up on the link seen on the screen let's get started so this is my grandmother she sadly died three years ago and my mother and my uncle inherited her when we say that we don't actually mean that my mother is my grandmother and we definitely not mean that my uncle is my grandmother or they are somehow a grandmother also we don't mean that the goods that were useful to be my grandmas are not both at my owned by my grandma and to my mother and my uncle they just passed on like just like values a month is remove them from my grandma to to my mother and my uncle that's that's what we do in real life in software when we say when we have an inheritance we say derived is a base and derive inherits the behavior of the base but both base and derive would share the same behavior at the same time right unlike in the real world in which the goals just pass from my grandma to my mother this talk is about deconstruction and here is the definition that merriam-webster puts up for for the construction and it's we are going to focus on the second part the analytical examination of something such as theory offer in order to reveal its inadequacy that's that's what we are trying to to do in this talk here and we do that because inheritance is somehow important in c plus plus for i'm not sure exactly what's the reason behind it people often think about c plus plus as a mainly object-oriented programming language which is not necessarily true and whenever they say that they often think of inheritance as the main feature that they should be using in insipass class therefore a lot of the code base that we have in c plus class heavily uses inheritance [music] the the talk will focus more on the inheritance not necessarily on polymorphism that is typically associated with inheritance so let's let's quickly go over this why is that we use inheritance in c plus plus we use it to model real world concepts we use it to reuse members we use it for subtyping and this is typically associated with polymorphism and we use it to implement an interface or multiple interfaces or whatever those are kind of the four main use cases for which we are using inheritance in c plus class this is the agenda of the talk has six sections ago within some of them a longer summer there are very short so let's go with the first one simple program are hard and this is a very old problem probably hear it by now let's design two classes a rectangle class and a square class and we have to have some basic operations on them get and set the dimensions and get the area that's it just very simple problem if we use inheritance we basically have two solutions for for this either square derives from rectangle or rectangle derives from square those are the the two two main solutions with with inheritance let's pick up the first one square rectangle is a square this is the the code that you would typically see and rectangle of course derives from square and it overrides in this case get area and add some more functionality doesn't necessarily look right because of several things so first it's mathematically incorrect we cannot say that a rectangle is a square the second thing which which is apparent when when you look at the code is that the rectangle class is polluted by the square members so it doesn't quite make sense for rectangle to have get size and set size of course you can hide them but still you do have them in your public interface one way or another directly or indirectly and then the other thing the list of substitution principle which is always associated with inheritance that tests for inheritance it's broken let's let's look at one example for for this so let's say we have a function that increases the the area and it receives the base cost square and it says the size should be twice the size of one one edge and by doing that we expect the area to be four times bigger than it was before but if we pass a rectangle here that's not going to be the case so this function will not properly work whenever we substitute a rectangle for for a square let's look at the the other way square is a rectangle this is how the code will look like a little bit less typing but still still not right it does fix some things mathematically this seems correct indeed a square is a special type of rectangle the interface is less polluted you you can hide the things that you don't need but it still doesn't doesn't work you have twice as much storage that you need to actually represent the square you only need one dimension and you have two and lsp the least scope substitution principle test that that's broken you cannot apply list of substitution tests for for this and the same same type of test that we are applying here you have a rectangle which is your base class you set the width to be double the the width you had before and because you're changing only the width and not the height you expect the area to be double but if somehow you pass in a square you're going to change both things at the same time and this this will fail so if you inherit a square from rectangle you may break your client code the first fix that you can do here is to to make your classes immutable that is once you construct the the object you cannot change it anymore and this is how it would look like it's still having inheritance here and that basically gets rid of the setters so somehow it fixes the [music] one of the biggest problem there that we have in there but still is not quite okay you you still have twice as much storage you need in this square and inheritance really doesn't buy us anything because you can't do anything with that the proper fix is actually to remove inheritance you have two independent class yes they may be mathematically related but in your code but they have nothing in common and let's look at what bob martin says about this the truth is that squaring rectangles even immutable squares rectangles ought not to be associated by inheritance so this coming from bob martin who's working in ob a lot that that means a lot going on he makes the following remark the class square is not a square it's a program that represents a square the class rectangle is not a rectangle it's a program that represents a rectangle the fact that the square is a rectangle does not mean that the representative share the easier relationship right so mathematically we do have the that relation between square and rectangle but if we transpose that into programs we we don't need to have that relationship anymore and this is another code that i find very very insightful is is useful when trying to other real-world relations to make class hierarchies intuitive but classes are metaphors and metaphors if extended too far will break so in our code when we say rectangle that's just a metaphor for the real thing that we are trying to model the actual mathematical rectangle is not the real mathematical rectangle so in this section we talked about two of the things for why would we use inheritance and in both cases we ended up with a conclusion that we should not use inheritance for for those types of things let's move on the grant is a confusion so what is this is a thing that we keep associating with inheritance let's try to to model a simple system an elevator system we just look at the buttons an elevator typically has a lot of buttons inside of the card outside of the car four buttons stop buttons alert buttons and there are multiple ways in which you can do that again i'm focusing on inheritance you can have a base cluster button and you can have a travel button and you have some some buttons that are on each floor and you have some buttons that are inside of the card and then you have re rescue button and you have stop button so this this type of here he tries to put the emphasis on the type of commas that that those buttons will execute there's another way you can model this you can still have a button base class but you can say i'm dividing this into two big categories inside button and a floor button the inside button is the rescue button button and go to floor button and then the floor button is just an up button on the down button and yeah depending on the type of elevator you may have different things or you can model this in a third way it's just no inheritance at all but just have a concrete path that has some inner details on how the button will appear and what the function will will do and here the emphasis on uh on the behavior of this button let's look at those those alternatives with with inheritance which one is the real world if you look at the elevator that you use most frequently which one do you think represents the real world well to me none of them i don't think of an elevator as having inside and outside buttons and i don't have that image in the real world there is no such thing and part of that comes from the confusion what is a button you can think of a button of an elevator there are multiple types of buttons you can you can have arcade buttons you have mechanical keyboard ui buttons which are completely different from the other types of button you have all bell buttons we don't have electrical parts what's the essential thing of a button you can't properly capture that in in real life some buttons are electrical some are not some some of them stay pressed after you press them some some not some of them you can physically press them some of them like ui buttons you can't just push with the finger there are all buttons in real world we do have a problem we can't simply relate the concepts that we have in software with the real world buttons that we are we have out there in real world things like like button are concept which are somehow the building blocks of thoughts they're just fuzzy generalization i have some idea of what the button means somehow i can press it not necessarily with my finger not necessarily electrical but somehow i press that thing and we typically do that by simultude we can't find one example of the actual button concept in the real world we just have instances of the buttons in real world there is no such thing as the button if you do see one please please let me know if you do find the button in in real world in software on the other hand we do have this concepts as a set of instances and we can't say we have a button in in software and they are just representative for a class of objects that we have there we do have sharp distinction what's what's a button and what's nothing a button you typically do that by regular mix of reconstruction and they are generally algebraically constructed so you have this that and the other that goes into a button and nothing more or nothing less depending on how how you look at it there is a relationship in real world is not quite as we use it in software so in real world you can't think of inside button which is a button you can't find this is in in real world you can you can find it in metaphysics but not not in in actual physics in software you can't find this is a relationship which is typically associated with inheritance but you find it in two different const contexts so you find it whenever you talk about reuse data layout and methods and you talking you you talk about it when you you're referring to substitutability and that is basically the the core essence of lisco solution principle we can pass a derived object instead of a base object in the first one that reuse of data layout methods you can also do it with composition and a little bit more typing and substitutability thing is just the the essence of this list constitution principle we'll talk about the first part later but let's now focus on on the second one and i'll start by having from saturn alexandrescu the is a description of a public inheritance is misunderstood when people use it to draw irrelevant real world analogies a square is a rectangle mathematically but a square is not a rectangle behaviorally consequently instead of either we prefer to say works like or if you prefer usable as a to make the description less prone to misunderstanding that's that's from the republican inheritance issue substitutability inherit not reuse but to be reused so basically they argued that we should completely abandon the notion of either instead try to use the notion works like we have to think of public inheritance as substitutability not is a rectangle is not the square or derived class is not the base class it can be used to be substituted substituted into context in which you can use the base class we don't have such a thing in in the real world you can't model real world with that and what we are used to to say with is a is just a metaphor it doesn't it doesn't make sense it's just a big confusion that that we have in software just to trying to put all these concepts together into one one single place okay so in this chapter we focus on the the model of real world concept and we basically shown that it doesn't quite hold up so we can't properly model real world concept with with inheritance it doesn't work that way at least not in an intuitive and direct way so let's turn our attention to lisco substitution principle we've been mentioning it so far a couple of times let's dive deep into into that i think that's the core of inheritance and if we figure out how this risk constitution principle applies then we can draw a lot of conclusions about inheritance so first let's let's go over what viscose substitution principle is all about so i'm encoding from the 94 paper subtype requirement let p of x be a property provable about object x of type t then p of y should be true for objects y of type s where s is a subtype of t basically you you can use this definition to tell what the side calibration means that's that's the intent of this principle and all the definition which is a little bit easier to process for each object o1 of type s there is an object o2 of type t such that all programs p defined in terms of t the behavior of p is unchanged when o1 is substituted before o2 then s is a subtype of t and for reasons that will be apparent in a moment i'm going to stress on this all programs right so when we think about subtype relationship between between two types s and b or sorry snt or between base and derived we should think about in the context of all programs not just one particular subset of a program but all programs more than one program okay so the list called situation principle sounds good but there are three problems with it and i'm going to go into details first it doesn't work at all in a strict sense secondly if we relax it it's hard to use in this relaxed sense and thirdly we are hoping to reduce the complexity of a software by using inheritance but what this principle tells us is that inheritance will actually increase the complexity in our software so let's look at the strict sense so we have a property phi of base which is true [music] and it's provable to be true for all the objects of type base and we want to see if that property is also true for derived it better be true otherwise this scope substitution principle will tell us that this is not a good subtyping mode and let's define this property v of x is true if and only if x equals base that is if derived is different than base which it is in in our case then this property will be false that means any type of base class and any type of derived class that we will have if we think about this property lsp doesn't make sense it's completely broken let's look at the principle again subterra requirement let x be a property provable about objects x of type t it's provable it's always true for for our base class then a few of y should be true for objects y of type s where s is a subtype of t well that's false it doesn't say anything that we should pick just a few properties is there just for any property that's disprovable about objects of type t that's the problem with with lsp in a strict sense and here is a simple code that they will prove this you can simply check for the the type id of the class and if it's different than the base it will fail you can apply these two to all all of your derived classes and it will fail mathematically this proves that lsp does not allow subtyping if we take lsp in a strict sense let's try to relax a little bit sp let's try to see where that got us so behaves exactly like bass is a little bit too too strict a little bit to constrain let's let's try to find out what are the properties that we can think of returns the same thing as base does that is the same exact values that means probably the behavior doesn't change so calls is actually the same function as bass does same functions even in additions multiplications and all the basic primitives then it must behave the same same performance as bass again it's hard to make two different things to two different two different functions that perform two different tasks to have exactly the same performance return a subset of results that base returns that's a little bit more relaxed has some environments as same in variance as base that's yet to be relaxed the list can go on basically at infinitum i want you to think about when you did the last subtyping that you mean when you derive the class how many of these properties have you thought of and how many properties there are there which you haven't thought of probably there a lot so in a relaxed sense the the first problem that we see is it's hard to find a good property to apply lsp for in order to find relevant properties for our code base what we actually need to do is to survey all the code that we have to make sure that we haven't missed a property that we have somewhere in the code so if some kind of base depends on some property of that base the derived class should better not invalidate that property and how can we be sure of that where we just have to survey all the code and that's an extremely hard problem imagine a million lines of code base serving all that code it's a hard task and let's look at a little bit how things can break so lsp can break for two main reasons when changing the derived if we don't know all the assumptions that we've made about base and the kinds of base and when changing the base class or the clients of base class when we don't know all the assumptions for all the derived let's pick up two examples here to make this clear so we have a button we have some old client code that just pushes the button and after it pushed the button it it asserts that the button is actually pushed assuming that pushing the button cannot ever fail but then somebody later on in a completely different module adds another button a button with safety in which the button cannot be pressed unless some other button is pressed and you can find that in a lot of dangerous equipment that you have to have some kind of a safety well that button with safety invalid is the properties that the client code assumes about the base and this this will actually break the second example let's imagine that we have an old derived class a button with a timer and then we add some some client code the button with the timer does something like you press the button it's pressed and then after one second it just unpresses the button so it automatically goes off you can find those buttons in a lot of places in the real world those types of buttons and the client code does not know about this derived class it just knows about the base class in the base class you see it's it's push and it you can push it and you can check to see whether it's pushed or not and then the client code just push it checks that is pushed it returns okay waits a little bit does some processing and then assumes the button is still pushed but this does not go well with with our button with timer so again it breaks lsp and i try to put on a very simple diagram the source of all the problems that we have with this we have a base class and derive multiple derived classes and the clients of that base class have indirect coupling with the derived classes they do not only depend on the base classes on the base class they also depend on all the potential derived classes that that we can have here and that's a big problem because the client code and the derived class can be in a different models and moreover think about open close principle theoretically i can have an infinite amount of derived classes and i can have an infinite amount of clients to my base class i cannot know when i'm writing those to what the the other party will do and that actually increases complexity because now when i'm writing derived i not only need to know about base i need to know how base is used how all the properties of that the kinds of base will imply about my my base class in order for me not to break that that behavior so if we are looking from this perspective inheritance is not an abstraction because an abstraction should reduce complexity and we just proven that it it actually increases the complexity by by a large margin so to sum it up lsp does not work in a strict sense for any problem if we relax the same sense in which lsp applies then it's hard for it to work and actually lsp tells us that inheritance increases complexity does not reduce it so in this section we we talked about subtyping and why would we use inheritance for subtyping and we've proven basically that inheritance is not the best way to actually not is the only way but the subtyping is not quite okay when used this way so let's let's move on inheritance and friendship in a real life i want you to have this analogy in your head whenever you're you're comparing inheritance and friendship children should be more closer to you than your friends yes you would tell your friends things that you would not tell your children your friends may have access to some information that your children may not have access but in general the children can affect your life far too to a bigger extent than than your friends okay too much analogy is that it's a metaphor that will break at some point let's see the impact of of friendship so the the friendship relationship may guarantee that your friend friends classes can can access to to your members to all your members and that that's a bad thing we know that we we've all been told to to avoid friendship and if you are a little bit careful the good side of friendship is that it doesn't necessarily change the interface of the class you just have to look at the same in variance the same properties that you have for base and the friendship the friend class just have to do the same thing for for it on the other hand inheritance has a different type of impact it can access most of them most of the members so not all the members but most of them but it can change the class in variance as we just seen so you can implement the behavior in in the derived class it completely changes how how base class reacts and it's hard for you to to notice that because that depends on on the polymorphic use that your clients will will have so that means that your inheritance will tend to affect all the clients that you have for for your base class there's not necessarily a direct relationship it's it's an indirect one but still it's potential to affect that thing let's uh let's look at an example here so i do have some strange coupling this is not necessarily unheard of people do that all the time we have a flying thing as a base class with a lot of logic inside it and we have two instances of the flying thing an airplane and a duck because why not they're both fly so we think reuse is good so we reuse flying thing and then we have a user for the airplanes and the user for the ducks whatever that may be the problem is that the airplane user is coupled with the duck user through this inheritance relation that we have so imagine that the airplane user needs something specific for for the airplane a new change in in the flying behavior and that that change is not necessarily explicit in the interface that we we already have so you you have to change slightly of that interface and because you put a lot of of your logic inside the base class or because maybe the the interface is just defined in the fighting even if your your implementation is is in airplane you're going to touch the flying thing base class with that set of change again this is this is not something that it happens all the time it just tends to happen in a lot of cases and i've seen too many examples for for a lifetime in which this happens but when you're trying to make these changes to the airplane user which affects airplane which affects the flying thing you indirectly affect talk the duck doesn't care about the flying behavior of an airplane but it's still affected by those changes and if duck is affected then the duck users are affected and therefore you haven't implicit coupling between airplane user and the dot user and typically in practice this is associated with another thing with some kind of a change inertia in which instead of refactoring flying thing to really decouple the airplane in the dark what you end up doing is add more logic if you add more logic you make your stuff even more complex if you make your stuff more complex then it's even harder for you to refactor it and then the next time you have to do a change you add more complexity to it and soon you reach a point in which the complexity is so high for such a simple thing that it's really really hard for you to change those things so the conclusion that i have for from this is that if you look at it from this perspective inheritance is stronger than friendship because it doesn't necessarily affect you in a short range it doesn't just affect you the the classes that are in in that friendship relation it affects you in a much deeper sense it affects all the clients for that and maybe all the kinds of those clients because as you see this is a transient dependency okay let's move on inheritance versus composition i'll start again by by coding bob martin when he was talking about the rectangles and the square example a box on there is a relationship has been misleading and damaging for decades inheritance is not either inheritance is the re-declaration of functional variables in a subscope no more no less that is if we think about what we said about inheritance bob martin doesn't quite consider subtyping in his statement it's just he says it's just redecoration so it adds even more confusion about what is this inheritance thing well the proper way to do a redecoration is to use composition because you don't have to copy the same code over and over you just abstract it out and put it into some common implementation of course you have to do some small typing in each class saying like okay this function now calls my behavior function which is in a different class but come on it's just a couple of characters that you have to type is not such a big deal and i'm going to quote again from saturn alexandre school for this inheritance is over overuse even by experienced developers a sound rule of software engineering is to minimize coupling if a relationship can be expressed in more than one way use the weakens relationship that's practical and this is actually from the chapter named prefer composition to inheritance composition is weaker than inheritance so whenever you have the chains try to use composition compared to inheritance and since we are talking about composition i think it's worth mentioning uh clausius stock from yesterday breaking dependencies type erasure design analysis that's some form of composition that this he was advocating there i'm not necessarily trying to solve the polymorphism part of of using interfaces so that's why somehow i'm don't necessarily go into that direction but i think his approach in there is a very very good way in which you can solve a lot of problems that you may typically want to solve with inheritance with with a much simpler simpler approach and the the talk was so good that even my cat was fascinated about it so yeah good job claus so why why do we use inheritance in this chapter we just talked about we use members and we show that it's not necessarily the best idea to use inheritance for using members we have composition which is better than that so let's put up things together and let's try to draw some conclusions when to use inheritance and when not to use inheritance so at the beginning we said that we would want to use inheritance so people would want to use inheritance for for these reasons all the real-world concepts we use members subtyping and implementing interface and basically for the first three we went over them from various different perspectives and we've shown that iterative is not necessarily the best thing that we can use there and especially for the the reuse members you can use composition for that subtyping doesn't quite make sense find better ways to to do that but still we haven't discussed about to implement an interface and that's something that is not necessarily bad it can be in some some cases but not not not always and not in this generalized way so we can still using inheritance with with interfaces and as much as possible try to replace by composition again interfaces may not necessarily be the best solution sometimes it's the most convenient one but there can be a good way in which you you really want to use the inheritance you can use it okay so let's go a little bit of interface and let's see how how they would apply so they work relatively okay with the list of substitution principle or you can still find things in each day break but in general it's much harder to break them because interfaces by definition are fully abstract so the only thing that you're defining there is purely abstract is an abstract thing it's harder for you to uh to put their things that would affect the derived in the clients together but you can still have the same the same type of failures that that we've seen before it's just a little bit harder to do that and actually it works really well if we consider the the other solid principles in there especially interface segregation so let's let's just pick one simple example so let's have a duck and we put a lot of things into duck because that's how we i don't know this how we sing to other people just tends to happen the the common excuse is for forgive me the pun we inherited this from some other developer and we do have some different types of duck we have the mother duck we have red hot dog and we do have some artificial ducks like rubber duck and electronic toy dock and they all implement different types of behaviors the first thing we can do here is we can extract out the common things and use composition here and the diagram would look something like this it's not perfect he still has some problem but it's starting to to be a little bit more more laid out you you extract the behavior and put it into some some common parts you will still have some things in the base class swim which doesn't make sense for for a lot of things you for a rubber duck you still have the fly interface you have some kind of a no-fly behavior which doesn't make sense don't fly you don't simply don't implement that but it's a step forward and you if you just go over the next level you can make all of those into just pure interfaces and and use them like that so you would have a pure interface that just have fly have a pure quakable interface that just does the clock thing have a displayable element that you can just display things and then the whole hierarchy simplifies far more again this is not the best solution don't think of it as this i'm just trying to provide a few tips in how you can take a messy inheritance-based solution just by some changes try to to simplify it a bit and for the interfaces i guess the the guidelines would be the classical ones that install it you you should have one interface for each type of client and i think the more important part here is that the invariants of the interface should be directed by the client if you can design your interface in such a way that you can capture in the essence of the interface how it's going to be used by clients then basically you achieve this decoupling between clients and the implement implementations of your your interface there's not necessarily an easy thing to do but i think in most cases people people can manage to do that in that sense if we are going to to achieve that then we can decouple concrete classes from users and when we do that then basically we would have a proper abstraction the interface is a proper abstraction for all the the concrete implementations so once again when we should we use inheritance we basically went over all these reasons and the only valid reasons to implement the interface again not necessarily that you have to use inheritance you have to implement interfaces there are other ways think about the type erasure pattern that claus expressed but that's when when you would use the inheritance and for the other uses it doesn't quite work we plan to use it like that so in conclusion inheritance is full of inconsistencies full of confusions it's overrated and the sad reality that is still overused in you know c plus plus practice thank you very much i'll be expecting questions if you can put them into qma okay so one from klaus inheritance seems to be the only way to design for an open set of types if inheritance does not work would you name an alternative that could that we should use i don't think inheritance is the only way to design an open set of types i think the obvious alternative is the one that you proposed yesterday with type eraser yes it has some inheritance inside but it's private and you can think of implementing the same thing without inheritance it's just more complex but you can think of it implemented in in those terms and the thing that i was not focused in my presentation is on polymorphing so most of the time you want inheritance to to implement polymorphic behavior and we somehow have this mental trigger whenever we think about polymorphism we somehow always think of subtype or morphemes subtype polymorphism is not the only way of polymorphism you can think of parametric polymorphisms which has uses for templates but it's also polymorphism and does nothing need inheritance and the functional languages make a great use of parametric polymorphism c can have polymorphic behavior without using interface without using inheritance sorry so there are a lot of other ways in which you can implement the polymorphism and i think that's that's what you mean by by open set of types i hope that answers the question any other questions there seems to be one other question in the chat ani asks by the way if is a terminology is a confusion here would it be worse to think of a new name rather than with inheritance so i guess even harder than having confusing uh terminology for inheritance is naming naming is a hard problem in software engineering so i'm definitely not good at naming things so no i can't offer a better name for for inheritance and there are a lot of alternatives to inheritance even if we change the name of inheritance to i don't know member reuse or whatever subtype relation the same problems would still appear okay i think there are some new questions in the q and a chat now okay should we try to teach the actually i should read it the other one first how can we enforce in c plus plus that interfaces like a fireball are really interfaces without you can somehow safely use multiple inheritance so only pure virtual function is no data member etc as far as i know there is no real support for this in the language or stl or read more with dot or is it unfortunately we do not have that support in the language i'm curious to see whether the standard committee will eventually move into that direction maybe if we have meta classes then we can force that that type of behavior but i am not up to date with the efforts on meta classes but yes i would somehow really want this this thing in standard and moreover i would want our community to to be more firm on using inheritance for everything is not such a good idea hope that answers the question so radek should we try to teach the community to distinguish between implementation inheritance resulting inheritance and the implementing interfaces resulting subtyping it seems like these two different things are often interchangeable when talking about inheritance yes i think we should do that yes there are times in which you would want to do uh for simplicity reasons you would want to to do traditional implementation inheritance but in general what you would want when you use inheritance is to use in interface inheritance so yes we should we should try to teach the community clause to clarify open sets of types according to ocp i can add new types without modifying next encode oh so sorry so if you add new types without modifying existing code if you are let's say you add new types in the derived part of the system that means let me try to go to that slide quickly so if you add more more classes to your system in the derived part in order not to break your code is you have to make sure that the client is using some assumptions from from the base that are not broken by your derived class so essentially the derived class that you're adding should know about the client code and the same thing if you're adding code on the client side you should know about the direct the direct classes that you have in your system does does that make sense if not please please add another question here okay so thomas you quoted robert c martin several times that i missed is that solid also contains lsp i agree that inheritance is not solving the problems but it is one tool you have with language lesson plus plus there are others but why rule it out completely the big problem we have with software is and that's an unfortunate reality is we have more bad code than good code and i don't want to just criticize the industry if i look at netcode i have more bad code than good code so just the fact that something is there and we have it in our inheritance doesn't mean that it's good we have a lot of code that uses inheritance we have a lot of code in which we try to apply this code substitution principle but it doesn't mean necessarily that that inheritance is good or whenever we applied lsp we applied it correctly don't get me wrong there are a lot of cases in which we apply lsp correctly what i'm trying to prove is that applying it correctly it's extremely hard because it if you're a good if you're a good engineer then whenever you're doing a change you have to know the complete impact of your change and in order to do that with inheritance you basically have to know the rest of the code you can't simply rely on some abstraction that your base class has that's the big problem there i hope that that answers the question okay thank you again for the great talk and interesting discussion if there are any further questions i assume you will be available at the table for a further discussion yes i'll be in the table [music] he has come up one more question is the this substitution principle compatible with protected members from base so i hope you're not referring here about protected inheritance that's a completely different topic which is is somehow a mix between the danger of public inheritance and the safety of it so i'm trying to refer to lsp related to the fact that you have access to protected members the problem with lsp is not is not about how much access do you have to your base class is the problem so how much can you change from the base class if you're allowed to change something from the base class then basically you can break all the client code that's the problem with with inheritance and then that's the problem where lsp is not strong enough to to give us a clear guidance on how to do it i hope that answers the question here's another one regarding favoring composition over inheritance in places where inheritance is to be used i believe composition has a relationship then how the terminology match here so instead of making a plane from a flyable thing we we should say plane behaves like a flyable sorry well we can say from start behaves like a flyable thing that means that a plane has a behavior of that type of things we can do that by an interface and the actual implementation of the flyable thing we can delegate to somebody else who can delegate to to some flying engine for example which can be used by a plane or a helicopter or whatever if if that is generic enough and if that matches the problem and therefore we are not associating a plane with engine behavior in an either relation or behaves like relation we associated with has a relation so plane has forgot the name i just said engine flyable engine i think that that clarifies so whenever we are changing inheritance for for composition we should change our terminology we are changing the the names of the classes anyway i've seen that chad klaus says is it hard that should be the real summary yes that is the real summary it's hard it's really hard to use in her inheritance correctly and it gives us a lot of pain okay it's hard for me to skim the chat for four questions so i'll i'll be going then to uh to the chat rule and if there are more questions you can find me there thank you very much everybody see you there have a nice day bye you