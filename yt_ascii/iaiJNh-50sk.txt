they say one of the keys to intelligence is the ability to make connections between disparate pieces of information and let's see patterns and links before everyone else sees them if that's so then today's guest might be the most intelligent person i know i'm joined by ben gamble and he's just exceptional at seeing the connections between different technologies and different technical ideas and he has such a varied background as a programmer that he's got like a wealth of different experiences to draw on so who better to gaze at the programming landscape with us and ask with all these pieces how are we supposed to fit things together to a coherent system which bits of technology belong in a modern architecture do we really want half a dozen different databases with an event bus between them or will we be happier with just a general purpose relational database ruling the world because you can build a thriving business with just my sequel and python you really can but by the time you're a thriving business are you going to start to wish you had a dedicated analytics database like apache pino for your queries are you going to wish you had redis as a high performance caching layer which bits should you use and when do you make the trade-off to switch and when the landscapes this vast why isn't there a map that's the topic up for discussion today and it's a huge one so we best get started i'm your host chris jenkins this is developer voices and today's voice is ben gamble [music] i'm joined today by the inimitable ben gamble ben how's things things are great if slightly warm today i suppose yeah yeah it's cooking up in england it really is we had a wet and remarkably cold summer until literally this last week or two it seems yeah that's the joy i think i used to know this italian person who said she couldn't understand where the english talk about the weather so much until she came to england and then the weather's so interesting because you never know what you're gonna get you really don't like what's funny is one person in my team who literally lives it turns out within walking distance of my parents and we've been going to the same library for the last 30 years without knowing this he's so he's 10 miles away from me and we normally have different weather cambridge you do know it's quite funny okay we'll save that for the meteorology book trying to explain why that would be i've got you in because you you just you've got one of those avalanche minds whenever i poked it i get just an avalanche of information coming out that's why you're here i want to get into that but before we do one of the reasons you have so many perspectives and angles on programming is because you've got such a varied backstory you've worked in so many angles of the industry so i'm going to start there gives us your biography sure thing so i got into the industry the usual way a lot of programming at least usually most people do which is you want you see video games you think i want to make those and you then you go to the local library at the time and then find a book that says learn c plus plus there's a lot to answer for why do we do that to children i know i know and then my mother well there's a course down at the local college you can go to for that so me age 11 was surrounded by postdocs growing up because i was growing up in cambridge yeah right learning c plus plus to some some like nvq level of stuff way back when back in 1999 and so that's where it all started and then at school's lucky enough to be able to play with everything from microchips coding in both basic yes actual basic on microchips oh wow you some assembly and had a fun maths teacher who used to run c sharp courses during lunch times every now and again and so i kind of got into it through all this and then the fateful thing happened of i found modding tools video games to build and an attempt to break every single video game ever from hacking data files in things like gta 3 to using the unreal engine editing kit to basically build my own levels and then occasionally mod games oh wow yeah that's a freaking way to grab a teenager's imagination it really is because you just give them a bunch of tools and say are you smart enough well first instinctive yes yes i am let me go prove it and then the answer is no no i wasn't and all i did was learned a lot about loops and what doesn't work and how to crash a game oh very easily if you do something on some fun things like how many like what scale actually costs and things like actually there are limits to what your machine can do and there's a real reason games designers make certain levels certain shapes so you can't see things around corners so they can lazy load them in oh yeah yeah that was a serious thing back in doom still a serious thing today all right yeah so like portal rendering kind of like to doom did this a bit but it kind of really became big in the build engine and the dark project was really famously a portal renderer whereas this is the idea as you render things through little portal doors to the next zone and never be on that and turn it back to the story was i went to university originally to do some some sort of avionics engineering which i hated and then transferred to astrophysics so i have a degree in astrophysics which i basically spent 90 of my time trying to avoid physics basically every computing module you can imagine every stats module you can imagine electronic engineering model modules and then enough physics to get by and still get the qualification basically i spent i got i i basically said and was kind of hooked into various little bits and pieces which was the first version of unity came out on pc in a mac product originally and being a friend tried to build games on it still a good friend we were building we're chatting about building games in san francisco last week because we didn't know we were both flying out world being a small place and then after uni i got my first job at a consultancy doing technical consulting and management consultancy i got that by talking about minecraft mods i built really i know yeah so i used to build world generators to kind of plug on top of minecraft and i was trying to build things world worlds based on the kind of equations i've been learning in planetary science things like how do you make a mercury looking world in minecraft oh cool yeah so this is what i was doing at university rather than actually my degree which i really struggled through the end of but also on top of that trying to prove that a 3ds didn't need two cameras so i tried to build an augmented reality system on my own from scratch i don't recommend [laughter] not halfway there and that actually got me hired at the time as an image processing engineer for this consultancy i can say that and there i kind of joined in on a bunch of very large system developments everything from kind of inspection machines format for drugs so the drug capsules you buy have all gone through a variety inspection machines like help design it's the insides of one it was amazing i got to basically play with high speed cameras gigabit ethernet back when it was still a rarity and then like custom gpu imaging techniques to basically say how do we look for the defects and such in in true real time these are you know a million items per day one-to-one rejection as it's sliding along the conveyor belt as it gets printed and then goes over the edge of the conveyor belt you have to do air rejection blowing off the capsules oh cool it looks fairly cool to watch but then it gets faster and faster and faster and you realize what speed really can can go wrong i kid you not the first bit of debugging i did after we couldn't work out was going wrong was an oscilloscope on trigger wires of the camera awesome i found something found an unbalanced lack of a commoner between various ups's in the system oh my god i was like serious oh yes but also very annoying i lucked out by finding it my colleagues at the time said no one would have done that that was a kind of a weird move but it works there's literal debugging where you pull the moth off the circuit board and then there's one level above that which is an oscilloscope between two things watching pulses go by to see if the camera's trigger is actually a proper rising edge in the right place oh god yeah and from there built embedded circuits programmed tiny 8-bit micros and some other bits along and i ended up doing mobile dev because i kind of talked about the augmented reality thing and then then one of the partners overheard that i could write code for devices and asked how long do you think it would take to write an ipad app to do a questionnaire and i said a few weeks shouldn't really be that much more complicated vague understanding of how i didn't know it was objective so you thought it was still c plus plus and then that turned over my desk the next day with an ipad on top it's one way to get the gear three weeks later i shipped the app to this internal thing and it did a lot of it did very well except i had to speed them objective c and i do not recommend and from there it kind of became things like how i increasingly kind of end up in these bigger and bigger systems like like things like like camera systems inventory management systems and then a lot of apps which had to communicate either as iot devices or otherwise and then what happened next was like over time kind of like specialized deeper and deeper into trying to make things a bit more interactive so i had a lot of augmented reality and a lot of just high-speed data things like how do you deal with like low low transmission rate ue uhf signal lines how do you deal with that the answer is it's fine as long as you're accepting a bound rate of nothing almost and i mean like think no no end of null modem level bad right and the thing is right two ethernet ports went in either end so you didn't was it was transparent if slow so that's where i started out and did a lot of things i can't talk about due to the whole thing's official secrets but oh yes one but weird but generally the more secret the more boring right yeah actually and then i left and founded an augmented reality company on google glass so we call bus google glass oh google glass you were actually one of those companies yes so it's still a youtube video race yourself you can look up for augmented reality exercise games yeah so it was a whole idea of run in the park with someone chasing you or a personal trainer telling you to slow down and speed up oh yeah yeah i could see that those kind of things were just like what we did lots of and then like because i've been involved in the launcher by bharti c when i was at the consultancy so google launched webrtc i built an air drum kit for it with a connect so you can do this jammy chrome game if you remember that that was at i o it was good fun and what happened was i realized that hey why don't i just take this tech and reuse it myself so i used like webrtc to do multiplayer games over google glass so you run around playing pac-man with other people in the park i'll have to share the video with you it's it's good fun it was over 10 years ago now yeah i'm always sad that google glass didn't evolve into something yeah it felt like it should have but then like it was always that weird moment where we were telling people about turning on the gps chip and they said it didn't have one i showed them the bill of materials and i showed them the gps strings coming out the device and they were like how did you do that i said do not cry so after that peted out and a bit of pivoting happened i stepped away and was working at the hiking app company for a while called view ranger that was their rd lead doing more recommendous reality on ios and android so cross-platform building of basically ar apps to label mountains oh nice and then like gps app load gps code to start a safety correct positioning in sharp valleys and things like this so how do you de-amplify error how do you make it safe so that all the mountain rescue teams who use this app could actually do it safely right and actually navigate safely around the mountain where it told you they really were rather an amplifying error which you can do quite easily have you pitched any of this to apple now they're doing their apple vision thing they must be clamoring when cook has i have a picture of tim cook using the vision thing with the with the with the labeling mountains so the that app company we had a on the series 2 watch launch there is a literal wwdc thing one of my old colleagues she's on stage talking about the watch app oh cool yes i know for a fact they've seen some of this stuff already right that's that's quite a cool thing feather to have in your cab oh it is there are loads of these little bits and pieces i just wish i was physically there i wish i wasn't i was back at the head office going please don't explode the server please show the server please don't explode the server the firestormer clicks only eventually explode the server right but they were pre-cloud and in a physical machine somewhere in a data center because originally there were a company that launched on symbian but now they're part of actual outdoor active so it's kind of still a big app it was it is hide it had you know five million actives so it was pretty cool time and from there kind of steps away due to a logistics company i've been building in the background for a while upon my own investors followed and then did a ton of contracting along the way for bootstrap startup reasons where i worked at rare microsoft on things like sea of thieves and ever wild oh cool which was good fun worked on ai development there for their kind of games originally it was brought in to bring kind of like literally generative ai thinking into the game was the original remit of bios there never quite happened due to remnants shifting around but that was what i was hired for at the time what year was that that you were trying to do generative ai in games so 2016 2016. okay and we actually had so the and what's funny is we actually built a film very similar to an llm for addresses at the logistics company so there's not a lot of nlp processing behind the scenes where we were basically taking in addresses pulling them apart by parts of speech by additional steps and doing that kind of functional correction across the stuff and then from there i kind of went through a bunch of like things where i consulted the places doing building literal operating systems from the kernel up which is fun and silly to do crazy scale stuff helps there was a great cool demo with ccp games where i got 15 000 players into a actual real-time game so i helped a lot of the architecture for the game itself then kind of like after the logistics company was going on to its high but i failed acquisition kind of burned me out a bit and i went as an exec producer at a small studio for a while and then improbable for a bit as well after the kind of mergery where stuff happened doing big scale things again built some of their built kind of a big initial part of the render that became their metaverse renderer and then i ended up then kind of pandemic hit just before that i left and you my daughter was born sort of a bit better timeout and then joined averley real time i think we met and i was still there yes real-time data real-time data yeah so i was the one banging the kafka drum there and so that was big scale websockets with a hardcore reliability and also mqtt and that was head of devrel and then kind of a position analogous to a field gto called the following champion and then after about two and a half years of absolute hilarious really good fun there because it was getting things like the kafka story sorted out getting us to market these bigger and bigger areas showing what you really do with high-speed data i joined ivan and now elite developer education here though i tend to go by the open source code sommelier these days open source code sommelier pretty large there is one thing i'm jealous of you ivan is you have like so they're a kind of stuff as a service platform right so you've got all the databases and all all the infrastructury playground stuff that you can go and build crazy demos with and call it work that is that isn't let me say a conservative 90 of why i joined it's also kind of the biggest story which is that open source is eating the world and one of my colleagues had this great description of open source which is you're basically leveraging the free cycles of every single one of the world's developers out there yeah because that's what they're doing they're just putting things into open source arguing beautifully productively to some to make something really good because they care and then at someone like ivan where we are still a big contributor to open source we're almost like 20 of like about dev team 25 of our dev teams literally upstream only committed like seriously we have that we have a lot of committers in staff that is a decent percentage yeah it is because of all four founders of postgres committers oh cool now people don't realize like everyone thinks oh we're just we're leeches from no founded by people they've run by people who contribute still i know it's really cool so the dna of the company is about this idea of saying find the best of open source deliver it in this awesome piece of infrastructure and i'm doing like so much infrastructure work behind the scenes so abstract away all those cloud platform layers and just say here's the database get going which leads us on to the main topic i've brought you in for right because you've got access to all these different data platforms a lot of experiences and different ways of building software right and not everyone can see this but you're wearing a t-shirt that says have a nice data so so this is from the cafe summit this year and possibly one of my actual favorite t-shirts i've had so many requests for more people from people people say where did you get that t-shirt it seems awesome cool the other good one from last year putting all that together right let me put it this way i would think a lot of companies a lot of projects say to themselves they have two arguments for generic project x they say okay let's argue about whether we're going to use my sequel or postgres and once we settled that argument we'll argue over whether we should be processing data using python or sql those two questions you're away yes yes this is a the classic dichotomy of there are only there there are there are some answers in the world but most of them are postgres and yes it go this is this is the thing like everyone starts out with thinking what's reach for the tools and we all remember the lamp stack of old yeah yeah it was beautiful because it answered every question you had you needed something you need somewhere you need a machine to run on running linux you need is something to handle the actual requests themselves and reverse proxy them so you had apache you needed a database my sequel was everywhere at the time postgres wasn't really an option yeah it was just a little early in the postgres story and then of course you needed something to actually write your code in and php it got stuff done and they will always give it credit for it got stuff done stuff done and it opened the door for a lot of programmers and lots it had productivity on its side and eventually getting stuff done soonest will win whether it runs or not it's if it really the simpsons it's the right way the wrong way and the max power way i've not heard that quote no homo teams is named to max power and and the answer and put their the question in response to it was it's not just the wrong way and homer says yes but faster foreign php but it's not actually always the wrong way it's just this but it is faster to get there you'll get an answer faster yeah that's another great dichotomy in programming do you want your problems today or tomorrow there are a lot of solutions which are just storing up problems for tomorrow absolutely and as much as i'm often the one saying technical debt is a coin you spend like any other you do end up at the point where sometimes you do have to pay it back yeah and this kind of comes back to this idea of saying like what it like what tools do you use along the way so how do you navigate that decision space generally when would you come off that that path of postgres with python ah so if you're actually at ivan yourself the answer is never ivan is still mostly he's built by postgres committers in python all right that is that is that is that is the religion in this building right however that that aside it comes down to two or three major kind of questions the first is always going to be access patterns what are you trying to how are you trying to access this data what like is it i'm changing am i changing you know the location of single person a thousand times and then being able to query it quickly am i reading the stock market in as a massive stream of data and then acting on the events of change am i looking at flight data for the last 100 years to try and maybe 100 years yes but let's say last 10 years of flight data to work out where i can optimize my flight routes all these data kind of questions are really come down to have a different access pattern to the data itself and you can always say postgres dot dot dot and it will give you an answer and and until you get some specifically very far outliers you will just get a worse answer depending on what happens next yeah yeah you'll be stretching it further and further out from this comfort zone and as soon as you go beyond a certain point what really gets you more than anything else is the cost fundamentally you only really have a defined budget for an answer right and yet then look at the cost that's both for financial cost and a cost of failure right so i'm considering time as a cost in there too yes and this is the kind of like you have a time window bound a success and then a failure window on top of that so if you imagine let's say an example i keep giving these days is you are trying to recommend a movie when you leave the netflix and they leave their seats on netflix or amazon prime or a service yet to be determined you leave that when you leave that video and they need to recommend to a video they have about 20 seconds total to recommend something right or they're going to recommend something wrong and a good recommendation keeps you in the platform or lets you lock in your next thing your actual churn percentage will go through the roof if they don't give you the next thing because you'll just not see what you need to do next and exploration takes time yeah your engagement is massively determined by how fast that answer is so your cost of failure is actually quite large by not having the data fast enough yeah and if the cost of data being fast enough is i now need a hundred thousand cores to run my postgres that's not a good answer anymore yeah and this is where we come back to like costs so i'm kind of abstracting costs as a time versus machines cost here as you could if you have enough machines the time will go low but number of machines do cost going low is another cost itself yeah yeah yeah and then flipside is trading let's say you're trying to make you've got a fill or kill order for 100 shares of tesla if you don't get that right you have a potentially unlimited liability for that okay but this is where it kind of comes down to it is the cost of failure it can be very high therefore having a correct answer in the time allowed is actually something you can spend money on but then it's like come back to why we don't use postgres for everything like these days a lot of the time i'm saying use an analytics specialist database like click house like snowflake like redshift because to be honest you just can't put a few you can't put more than a few terabytes in postgres before it gets very upset with you and and then it just starts consuming calls and then you watch it slow down and you can't do the fast transactions you want to do on it and some of this is just because of what postgres is with this kind of acid transaction model some of it's because of sql but a lot of it's simply because of the way it's engineered is not for saying i can scrub through a very large quantity data very quickly but i can find one answer inside a very in a defined six jumps i think it is b plus three under the hood yeah yeah that kind of implies that this is just a question that affects people with more than a few terabytes so the the fact is that we we have this one the one that the one the most kind of ubiquitously freeing things particularly of the last 30 years of software development has been more store right fundamentally the machines we run on are super computers right like i was at the san francisco computer museum recently and though the cray one was in front of me and i wanted to sit on it like it was a piece of lounge furniture i didn't because i said no but fundamentally that is probably less powerful than the server this this podcast is being recorded to i think my laptop's got a dozen graphics cores and like when did that happen i know i know and these are you know scalable vector units and you think those used to only be in super computers yeah and it's like that is a series that is a serious business when you think about it so if you think that moore's law is basically holding up whatever we use we get away with a lot of solutions which are not optimal but so far in the noise this is where we come back to the kind of some of those ideas of where speed comes from if i'm going to call a database and it's on the other end of a network wire i'm not going to get faster than maybe 50 micros in the same data center 50 microseconds yeah or if it's you know a cloud one if i get better than 10 milliseconds to get there and back i'm already doing pretty well so i don't really need my database to be any faster than about half that network velocity yeah you could find that the bottleneck is actually serialization and deserialization right it is it really often is like we have these novel formats specifically for this and like a lot of things like message pack and protobufs or hopefully not protobus i have a bone to pick there i rant it on stage at qcon about them um but the key thing always comes back to this idea of like everything costs something therefore where do we need to optimize the bit over here and particularly with postgres is postgres is pretty quick and most data is pretty small and most queries are not very complicated if you're not doing a very complicated query you can get away with almost anything i know people who have read it as their primary database because they're not doing anything clever oh it works i know someone who had registered their primary database and the the company imploded one day so we so i once lucked out because by that for a little while we had a very database for about eight months on what startup for a while because we were in a hurry and it worked and we never got put out until like we found out how bad it really was later down the line we realized we were never actually we had a very aggressive caching policy it never actually ended up doing this clever rate module we put in to write that to this properly oh right yeah and it worked for disclaimer purposes i'm not sure reddits are advising that it'd be your primary database of records the website would say otherwise really oh okay a very multimodal story and if you work for redis you're invited on the podcast like genuine though but genuinely they've done some magic and i'm not i'm not gonna i'll say that they have right ahead logs going to disk these days you know they've done some they've taken a fun idea and stretched it so far that it's not that it's but it's weirdly awesome now right okay i have nothing but fun things to say about what readers can do the general answer is should it fair enough yes so yeah push this more into the language space for me though because we talked a lot about databases on the podcast but where does this affect language choice so what really comes down to it is if you think about it like how like most of what we do in programming is try to express a series of concepts as you know in our code which machine can then understand the by the way this is my general statement about llms it's llms do two things very well they make us sound like computers and computers sound like us they're really good at translating between the other they're basically just a way to do it basically a very weird programming language want of a better word okay or a very bad interpreter for a programming language which makes me think of something someone else said about llms which is they don't give you an answer they give you something that looks the shape of an answer exactly and we're missing the compiler of the rm basically yeah yeah the thing that checks that actually you said what you think you said yes i can imagine a borrow checker looking at someone's grammar and going no yeah it's like incomplete course stuff yeah but can i get back to this idea of manipulating data at any kind of scale whether it's the one or the many currently like the de facto is sql that 49 years from 49 years of development and an iso standard behind it yeah and it's you know it's designed to be a declarative language to basically state what you want to happen and then it happens however over time that sort of munges you can do all things in sql i think i may have shared the schema verse with you at one point the scheme of earth if i haven't i need to which is anything you have if someone built a multiplayer space trading game in postgres sequel and the whole game runs outside postgres store procedures no okay you can find it it is open source okay we're gonna link to that in the show notes how i got into postgres i was searching multiplayer space games and found that and was like i'm in if it's powerful enough to do that you're you're interested i i no sniffing me is not really a challenge so i get that sense i really do kind of back to this kind of thing it's like so sql can do most things but should it and is it very optimal for these things and in general it was designed against this relational model which has a lot of kind of like thoughts and patterns from when it originally came about which is the idea of relations are important in data which you normalize our data to reduce its storage footprint because if you remember storage was almost an order of magnitude more expensive than compute for a while yeah yeah it really was so normalizing your data mattered and then we haven't had the big shift probably about 10 years ago maybe a bit more now maybe 15 years ago where compute collapse in price for computing compute collapsed in price a bit but here's what really happened storage went to near zero right commodity storage became a thing so suddenly it's like why are we paying costs to normalize when we don't need to why don't we just make access faster so then we've normalized out our data and suddenly the relational model didn't hold up so sql didn't hold up so we went no sql or not just sql or not only sql or an acronym of your choice basically and you kind of come around again and think wait what we now have a different access pattern like cassandra's first query language was thrift so you really yes api to begin with a while ago it's just came back about that and he says it was good at the time i regret many things about it but this is the kind of thing it's like rpcs are just a language kind of model of choice and that's all sql is it's an rpc language that changes something whether it's data description whether it's data modeling whether it's a query and then you think but why aren't we using something more general purpose because i can transform data with sql if the data thinks is sequel shaped but what happens if i actually want to you know run something a bit more clever like i want to do i don't know a theory a transform right like find the fluency domain is saying so this is very prominent images so if you take it so jpeg is a fourier domain compression so you take an image you split it to the furry domain and you basically do some normalizations there and flip it back and this means that's why jpegs are actually very good at looking good even though highly compressed yeah they're smarter things but they all work on similar principles so you think about it you can't really express a fourier transforming sql unless it's a competition at which point you know competitive codes like it's one of your previous guests talked about that's that is the realm of of of wonderfully crazy i don't approach yeah and instead you'd want to approach into a more complete language but the problem is now is imagine you've now now you've given people with python and access to your actual database and they're running python in your database are you actively worried about that i generally so it i see personally i like the idea of it until everyone says but when what happens if someone puts something of a demolicious query and it starts doing random things across your network yeah so how do you sandbox it i've seen in the wild java stored procedure that decided to be a good idea to start a web server yes yeah and it was malicious that was just a really bad idea i i've had that bad idea literally had that bad idea myself so that kind of stuff is why on average you don't let people run code directly in the database other than lure inside many things it seems but it's really powerful because suddenly you have arbitrary compute and we like arbitrary compute because if i can manipulate the data where it is i'm not paying a network cost yeah right i can use the fact that i have a you know a big cpu there doing my heavy lifting and my web server can be nice and state stateless it's like one of those benedictions may your services be stateless the better does that i mean some people would argue that that that's a mistake of how you're looking at the database and you should actually split it out into the storage layer in the computing layer ah yes the share everything bizarrely model which has two separate parts naming their costumes share nothing has has every has the computer story shared yet share everything doesn't which is kind of like one of those interesting kind of moments of i see where you're going but the naming came out funny yeah so i cannot understand where these things go loads of services now do this like famously snowflake just dumps everything in s3 loads of databases street secretly dump everything s3 these days hell warp stream have rebuilt kafka with only s3 below it yeah they have very interesting looking thing and it's modeled now like a lot of like a lot of these kind of prometheus backends like thanos where you just have agents writing directly in desk three are kind of like almost a data lake model like the kind of iceberg or hoodie tables hmm the problem ends up being that once you're in s3 you're the whim of s3 s3 is way faster than it should be for what it is way faster it's also way more reliable on the scalable than it should be it's actually almost black magic under there but fundamentally it's still 100 mils to do a change or a read yeah and that's that's partially network hot partially you know the actual s3 itself but also the actual api itself is not that fast fundamentally it's okay once you start streaming but you've got to establish and re-establish connection and you're starting having a problem so when you're on a local disc you actually end up this thing where it's like literally two orders magnitude faster yeah that makes perfect sense and the question is where can you afford to pay it so if you can afford to have it in s3 it's probably a good idea but if you can't afford to have an sre it's you you don't realize it until you've already paid the cost and you don't know you're paying it and that's where you kind of end up with these hybrids and a lot of why i'm working right now is around this idea of like how do i do hot and cold storage at the same time so creating local disk is just another layer of cash fundamentally yeah so i have some clickhouse examples where i have tape i have i have dictionaries which are literal key value lookups covering half my memory of my literal ram i have then i have a hot layer which is a material a strict materialized view in local ssd and i have my cold extension off in s3 which is either scrubbing across parquet files from a delta a data lake or it's just reading files i've dumped there myself and then i have tiered storage but multi but more than just the two everyone talks about yeah yeah is that because you just like the idea is that practically useful do you think people should be doing it so the facts are going to look like that that's what i'm getting at i started out thinking this is fun like i often do yeah and what can i do next because of the because of clickhouse is a massive box of tools but then what happened was you come across the simple fact of you need the right tool for the job and this is where we come back to those language choices why should i use r or python today versus sql if my problem domain is too complicated to easily express this sql i probably shouldn't but then if i wanted to but if i want if i have a regular query i'm running on repeat let's say it's you know i have my my i have my streaming analytics coming in right which is let's say every single position of every single vehicle in my fleet of delivery of delivery drivers coming in also the state of every kitchen of all the restaurants we work with we're a food delivery company today yeah i want often want to know a view of every single restaurant against where their delivery driver currently is that's just a key value pair series of key value pairs yeah but if you think about how much scrubbing you've got to do to get that view out of something in s3 that is disproportionately expensive yeah yeah right i want to do it once to have it ready to go and this is where you get to those optimizations of it's not just faster by two orders magnitude or three it's cheaper by four because i'm not paying for every single one of those network hops along the way yeah and when you actually want to start getting these big answers you start needing to think how do i have small data if i want big answers fast i can't have lots of data change when i want to change them otherwise my calculation is just going to start stretching into near infinity and we can only put so many cores in before it stops making sense because otherwise you end up a simple factor that i'm hopping between cores hopping between threads hopping between servers and then back to that wait house fast is my network again yeah i'm sure now this feels like to play devil's advocate someone is going to hop in and say hang on you're trying to join two large data sets you're back to postgres of course yes and the answer is i wish if we could i think ben stops it puts it is best of if we could get away with just postgres we would it was quite fun and the answer is like you always aren't joining something but my argument then comes down to if i pay the join once and only once all right and then have the secondary table ready to go am i good and if you just have these kind of cascaded views of your data and this cascades all the way up this is not and this is kind of the big conceitative where i work right now is i don't have to just say this tool is magic i can say this tool starts here stops here and then i go up the tree because now i get to say and now let's go really fast never read his cash on top yeah yeah okay so give me that map then and i'll allow you a bit of a plug here for for ivan yes okay okay so given the service is on offer where do they start and end so to give you a kind of example of like let's say let's say you are that a ride share company or a delivery company would also but it's e-commerce e-commerce is whatever everyone everything is e-commerce strictly because everyone so give me the restaurant one because i like that because i've not heard that one before give me the restroom you start with many drivers streaming their locations so you've got lots of quick data coming in yeah so that's mqtt and then we're going to absorb that into kafka because kafka beautifully matches webqtt i wanted to give that talk but they said no the qtt because it is just the iot language of choice yeah but you can put web sockets there with ably or something else it doesn't really matter just need to get that data in quick and it's streamed so then we've got the stream of data coming in from kafka and now we're going to build what i like to joke about known as the kfc stack and it's an actually good joke because it's kafka flink and clickhouse but also because we have 11 products which are our herbs and spices oh god okay i guess we had everyone signing in the room and i was like this is saying that's the proof of a good pun if you can make the whole room great yes yes and literally one of my team just go nope and walk away from it okay so what happens then is you go into something like flink so flink is kind of the stream processing engine does your and not to say that it's going to go away as it's actually slightly older than spark which is funny it has been around that long but it's kind of very good at this kind of distributed streaming processing thing like take the kind of concept for captive streams but wrap it up in something that will handle all of the offset management for you the checkpoint for you so you do a big kind of let's say join denormalization and then like you split out the data you convert it to avro you make it in some properly easy to process formats then you put it into so you're in cafe right now then you stream it back to flickhouse so you have your long-term store being built live so this is where you have data going back into the time but then it's still in kafka so we can do more because kafka and pub sub means you then have a hot cache in redis so this is where you do geo ads so the kafka connectors for reddit have the ability to actually add the data to geo sets in redis so now what i can do is build a hot cache where every single driver is for geopoint queries while i'm doing all the rest of this in flight no real cost anything else are in real time i do the same thing in my restaurant so i have two caches give me give me the restaurant in its current status give me the driver and their current status but now i want to do one step more and queue up another kind of nice quick easy access table to say give me the best thing for my current situation so i'm going to do now is i'm going to join the contents of my drivers in flight with where they are so i now have a so now i do is i have a averaging over a window so every 20 seconds i might say dump out the drivers and their locations and their current content in their current direction so when i do a select from to calculate nearest driver please i have a nice you know approximately hot cash to know these are the people in the snapshot window at which one i can ask the really hot cash to say where are they really and then i can safely make that join but it gets better because this is and i have more than one subscriber so that restaurant data is coming through and i now know if my restaurants are starting to meet their capacity or not because i have previous historic data in click house to say these restaurants can only really handle 30 or 40 orders per second so i can do a join or your orders your max orders per second and say anyone's like to exceed that recommend them down put them lower in the list so i don't ever end up over indexing on the most popular restaurants yeah one egalitarian i want my everyone in my restaurant platforms to experience you know an even load but more importantly i can't give a bad customer experience you know this whole thing we do is because of customer experience yes yeah always so now what i've got is the ability to recommend the right restaurant at the right time independent of how loaded they are so the load just goes if the logo is too high on on the local place that serves the best pineapple pizza it's going to go down the tree yes that's an in-joke and you'll probably have another guest on here at later point who will make it more apparent foreign but when that goes down the order list because they're too busy no one is going to suffer neither the restaurant having to say no nor a user getting frustrated and this is where it's most important here is we're doing this in real time you don't have to re-query and see full restaurant full restaurant we're just not going to return it to your app because we know and we also know not to give a driver too much things we know when the driver is not actually going to make a turnaround point we can give a really accurate assessment of cycle time actually the driver we suggested might have you know might be the closest but he's on break because we have his current state before we make the decision right yeah yeah so you are in that stack you're advocating for real-time data spending the cost of materialization once per notification and having that ability to have the historic views turned into it's basically so often i turn this as extract transform load and optimize because like the key problem always ends up being is i've loaded this data but if i don't optimize it i can't really use it outside of a dashboard yeah so how do i make long-term historic data usable in real-time scale so and your answer to that is picking specific data tools for the job exactly and you never have a stack of one tool if you have one magical tool for me and it's not postgres i'm going to be surprised yeah at what point should a problem should a solution start going beyond postgres into this what is definitely a more complex and expensive stack oh so the answer is as late as you can get away with and that's familiar and no later the inevitable fact is slightly too late is nearly always the case yeah but it's we get to this point where you can be quite forward-looking because none of none of these things are hard dependencies on each other that's the magic of doing a proper distributed architecture with something like an event bus between them because we can start with postgres at a clickhouse next we just federate start just start draining the long-term data out straight away no additional tools required and then we say actually we need this data to go more places let's start with pubs up start with rabbit mq if you need to go lightweight go to kafka when you realize rapid mq is you know it's still it's still pre-version one so maybe it has a problem yes i will batter mq first but it is still below version 0. it's not version one yet due to reasons racism yes at this point i believe it's naming convention more than anything else yeah we could go into a whole separate rant about what version one actually means but let's not yes yes i believe marketing is the technical answer but yeah the idea is you incrementally build one of these systems and the reason you normalize against something like doing this on event is because once you decouple the systems a little bit and say i'll bring the best thing for the best for the right job and rather than over stressing any individual system is at no point does your main transaction system fail if any of the things downstream fail right you still take orders right you can still have a rougher guess that your driver is going to get there or not get there and it allows you to have this ability to say well i wanted to do this transactional system in postgres but now i've gone too big let's roll cassandra let's actually go massively massively huge let's make sure i can't fail any given point in time no single point failures so wally cassandra let's say i'm doing shopping baskets now this is my favorite little demos i built mostly to try and prove a point to a local supermarket let's say over my baskets are big scale i'm using change data capture i'm pulling that thing out of cassandra tables because i can go to any scale and now what i'm doing is matching that my baskets with my actual inventory so now i know when i've exceeded the percentage of i might have actually tried to sell too many oranges today right therefore i can do is message my top by top few people who are either my subscribers and say lock in now and don't get a substitution because i now know roughly who is going to be disappointed ahead of time because i've seen it happen as it happens but as my stock levels change in real time as well i need to have both yeah in that so two questions and they may be the same answer in that stack what's the place for transaction heavy processing ah no actually i'll say the second question where does because all we everything you've described feels like analytics-based programming so processing so i fall into that camp of being more into the event sourcing world and arguing the transactions are kind of a flawed concept okay so the idea of a transaction is it's atomic consistent isolated and however it's de-turable durable yes between the two of us we can pass we are sort of a computer scientist we're confused we're computer enthusiasts so the point about transactions particularly is personally everyone says distributed transactions are hard and any system with two systems is distributed so we've already in distributed transactions before we even started the second part is that the first thing you must do for a transaction to be really stop time because of your transaction is only ever going to be consistent within a certain time slice it was ever in you can only be atomic assuming no other rights happened at the same time it happened which means you're already time slicing in ticks which only means your consistency is time sliced to that point in time at which point before i want to refer to it that time point has passed so either it's an event source which when i materialize my events and it is consistent or it's not consistent so it's the ever classic that bit of the quantum world of incremental time but also just the idea that i believe that we have this kind of touchstone of acid compliance assuming it's assuming it's the only way to do things whereas actually it's never really held true it's like cat theorem it we normally get one not two right if we're on a good day we get on a good day we get one and a bit okay yeah but it doesn't actually matter as the other point because the trick here is if we can make everything go quickly enough one the likelihood of a change low enough that was statistically we're good enough but also you think push into event sourcing and avoid the transactional system entirely so dial it back is lowest footprint as far as you can like you do need like you do need guarantees where transactional systems offer really good guarantees though i argue that what they consider to be guarantees are soft and then they admit they are just because of you've used computers for a long time i've used computers for a long time the one thing the longer use computers for is that you're more surprised they work than you were there yeah yeah every day i'm more surprised anything works yeah yeah absolutely this is because the more you see these systems the more you know what's going on the more you realize that none of these things have a consistent view of the world so we basically assume that postgres mysql or one of these others has a pretty damn good view of the world so we'll trust it to a certain point as that kind of starting point and then as we kind of cascade down the stack we basically accept that we are not event we are eventually consistent in a defined time frame of assuming no more events popped up you know be consistent and that is literally the model we have to go for because of any system will be on a certain level of complexity is going to be somewhat consistent of best there's a great talk by i can't remember her name anymore kafka summit we're talking about the idea of like using completion patents that's exactly that was anna mcdonald great talk best talk i heard there genuinely we'll link to that is the best talk of kafka summit i've got a humble opinion i have i i have written a kind of a follow-up a literal follow-on to it for out full thing four just didn't get accepted but like it's now cornerstone of i talk about a lot because i've used exactly these patterns before and they for exactly the same reasons it's just that this was like that crystallizing moment of i need to talk about this more and is it that exact thing if we can achieve consensus it's not a problem but we've got to pay for it somewhere but we don't need to pay for it where everyone assumes you do so outbox patterns they're fine but do we need them take me through that i'm in a bit more detail so outbox basically says that we have our transactional table we join a bunch of things we output to another table and we just follow the log of that table right where i'm going to argue that fundamentally we're doing some processing let's just throw that into our stream processing engine which is a bit further downstream and have the events as is and get no delay okay so why not just use flink for that downstream and rebuild it at will and have all the information when we need it rather than assuming like we not only need a limited subset now this doesn't work in banking or some of the highly regulated things where you need to show certain things are true therefore showing three things work in one database is much cleaner than during the work across 10 yes yeah and it's more likely to be true frankly one would hope these days i have been surprised yes also early days of certain databases i won't mentioned led me to believe that publishing to dev null was a slightly more it was at least deterministic compared to some of them i probably guess which databases you're thinking of but let's let's duck that well they they i know and if you know the one i'm talking about it got a hell of a lot better they bought somebody who fixed it okay it's my sequel isn't it oh it's not oh is it not it's not oh okay i because my sequel oh my secret from that and they bought something and got a hell of a lot better well that that definitely did yeah that but that was all that but then you're thinking aren't you might be might not be correct it's one of those possibly say that why a tiger is really good okay yeah i get to say it yes but generally is an absolutely awesome tool these days in fact it is so good it actually causes problems because people don't model the data as much as they might need to ahead of time oh yeah yeah yeah is the wonderful safety blanket until it isn't yeah because the other lesson of relational databases which was modeling your data and understanding your domain data model as a primary concern yes i think that's an art we've lost in programming it really is and when i came so i came into databases originally through cassandra and the idea of not modeling data to me it seems 100 alien because there's only mobile your data and if you start in hard-type languages like c plus plus or or haskell for a while for me as well as you i think cool yeah absolutely you have this idea i don't understand everything has a type yeah i always like the rich hickey quote everything has a schema the only question is did you write it down yes exactly and then he wrote an unstructured language and i'm i'm at this point you know two of these things do not agree and i do not know where you're going with this no i i love what plugger can do i just can't i can't wrap my head around its thought patterns required yeah i see i love the thought patterns my what killed closure for me not killed but retired let's say is i found in haskell i could do everything i liked about closure plus static typing and all benefits that come with that i went the other way it was the problem right because i started out in haskell and i got closure and i was like but now i have json objects flying around and i have no idea what they are and i was like i need a magnetic expression here because this is not a pure function i'm doing something and there's no first class monet now it sort of just implied as a closure and i was like oh it's not quite what i needed yeah okay so without delving too far down into mona and so let's take back to something you said earlier do you think the problem with putting something like python yeah processing stack is malicious code right if you have wild python running into let's say i built a tool and then i let you put code inside it wild code is always a problem and sandboxing is not easy it's the short version but this is again without using the m word that's something in haskell that lets you sandbox what a piece of code is allowed to do and it works really well yes any hope of that pushing out into our data processing languages so this is kind of like in my opinion the number one reason sql is still too damn useful to go away is it limits what you can do to a subset of very useful queries someone has already done some heavy lifting to make fast yeah and it's also the promise of wah sound if you yeah where i'm going right and webassembly the idea of leaking these kernels that bake down to a known api set and then embedding them inside your software this is how cilodyb does its udfs is because it's running assists it's running on some of the c plus and if it's being used to find functions that you embed into the database language yeah custom code basically and the only thing to do there is have some way of sandboxing it lure can be sandboxed because it was designed to be javascript is bizarrely enough is pretty good at this as well because it was designed to be sandboxed inside the browser okay yeah yeah it was actually originally a sandbox language why they didn't use lua at all is a thing i will continuously ask is lure would have been a better choice it's also smaller which makes it more of thinking for embedded languages yeah and it's a more rational implementation i mean you can actually write to a spec i guess that's a short one as well which makes it very happy but yeah and the idea of being able to push this you know a code which is sandboxed into your database is super powerful like but you always end up with this kind of dichotomy once again of saying why don't you just query it which is so spark all of it is you know build data frames on a distribute system and then do stuff and then put it somewhere else so let's pull it all out put it in memory across n systems and put it back and it's great until you realize how much that can cost at any speed cameras isn't flink doing that as well so flink is if you run it the same way as you run spark and this is where we say about amortize versus bashed costs so if it's if you're having to do something in memory of speed there's no option but for the data in memory right so we should pay that cost once and up front this is the transform bit of that extract transform load optimize step so my my thesis is do as few calculations as you can as upstream as you can get away with right off the end query pattern so because in general queries is sql as an end user is much easier than writing code to talk to some custom data store i've cut i've queried bits on a on a chip before i do not recommend like if you look at some of the old game save formats they are literally bit reads for bit flags they are very horrible and it's why you get things like in i think i can't remember which game it's like starfield the new one that came out recently oh yeah that's the new bethesda one corrupted save files where you have to do some ridiculous stuff to uncorrupt them like you've got to like if you cover where it is but if you do something you'll freeze your game until you somebody's your game will freeze until you swap your character's gender backwards and forwards because because it will set a bunch of bits that will reset things right oh god yeah no those sorts of bugs shouldn't exist but you can see why they do and you you can oh and if you've ever been in these kind of things where you've just got to get these weird formats working you just go i tried i could test edge cases but then players happened yeah and hence we end up with this idea of saying what happens if we just constrain the data language down and say don't allow someone to write custom code to write custom bits on a wire because like yeah do you think we'll see a future with more custom constrained languages is that what you're saying i so i've seen a lot of declarative languages come out recently it's a project i do some things every now and again with chord tremors or tremor.rs and it's a screen processing engine written in rust but it doesn't it exposes the rust api if you want to go deep but its default one is in fact just its own domain specific language which is the declarative and very there's a very defined spec for exactly these reasons they know what it can do they know the engine only has certain types of things externally imposed inside it but for one of a better thing as long as you constrain what the user does you can highly optimize it when it hits the when it actually hits the actual engine itself you submit it can be factorized as in like simply optimized out all the loops can be unrolled because it's a known thing it's scoped problem but as soon as you unscope the problem you just don't know how long it's going to take and which basically makes whichever makes your sas vendor very very happy or very very sad as you were at the lavender that clocks up a million dollars in 10 minutes horror stories yeah yeah but the other half of that is simply that like it also means you can rationalize it better because i've written a lot of stuff from c upwards and you end up having to you build your own constructs as you take them around and kind of functional like the best thing about functional program is it teaches you how to think in terms of composability yeah you compose all these bits together in your head and go right i'll bring this compose model with me and go and that's super powerful but most people don't want to do that they just want aggregate distinct go yeah i don't want to have to work out what bloomfield do you need to run a distinct query yeah yeah and that's the great thing about sql right the declarative nature it's the few one of possibly the only declarative language that's really stood the test of time absolutely like before this i was looking through the kind of the wikipedia page of fourth gen language is to try and find any i recognize beyond that yeah and i didn't buy volumes i've used most things i thought until i'd looked at that table and went hmm none okay like you know there's there's something to be said for like xml could be considered one of these things like there are all queries written in xml fairly oh so some of the some of the xml query languages sure yeah and then we xpath for json as well yeah and those kind of tools have different query tools but they're basically just modeling sql to the new domain yeah and that's kind of the access to a degree css is this whole thing i like there are on the list of things you know you have to choose some things to ignore and css is very high on my list of things oh baby dragons okay we won't trigger any traumas trauma is just complete lack of understanding okay fair enough no for my sins i have written far more front ends in raw c than anything approaching javascript oh my god okay it's just the nature of what you do and this is the kind of the running joke is when you meet anyone who's with a significant amount of domain expertise you always end up with someone with a lopsided skill set and mine says oh you don't write javascript very often yeah so perhaps to wrap this up then that we can touch on that problem because there's always the danger most places don't get the ideal architecture for what they're doing some of that is structural management cross-department constraints time budget but some of it is not knowing what you don't know you're not knowing that mqtt would be the ideal solution here or that click house would actually massively improve your solution over there any beyond just stay curious and keep learning if you've got any suggestions for how people can like fill their toolbox so i'll be cheeky and say listen to this podcast it's a kind of cheekiness i love thank you feel beyond that like the classic way i always the thing i the way i've genuinely learned a lot of what i've learned is just a key is you pull up a tool which you never get at least one and you see what it can connect to and you list you just list down the connectivity so i found kafka because i needed a queue system and i was looking for what what oh you know you can google for what queues you want to talk to but back in 2016 you probably wouldn't have found kafka i found it back then because what i was looking for was a way to make things durable on disk in long in logs literally which when i was digging around i found that exact phrase but these days when i'm learning things i'm mostly finding it in the documentation of the tool i'm already in there's some really powerful tools which have federated like let's say you've got the clickhouse documentation you list the number of federated tables it can offer that's so you don't know about amqp and you thought what is this thing it seems to be able to be materialized out of inflict house i'm like what is amqp and then you can go on this little learning mission to see what's next oh so you're basically learning what you currently know as nodes on a graph exactly and this is what the way i tend like so the best thing about graph theory to quote brand is that everything could be either a node or an edge right and fundamentally like if you think about things as a series of nodes you're never going to need more than one i would love to give the talk where i make everything just postgres and use the postgres instance for every single thing from the queues to the processing engine to everything else it will work for a defined definition of well enough to prove a point yeah yeah but you know so that revolute do exactly this by the way if you look at their published architecture oh really yes but then again they went down in a big way recently so i was just reading a revolute horror story this weekend that much postgres is a bad idea but you kind of come back to this idea of saying when you need when inevitably you have a problem like i don't know like the classic one is i want to do a delayed task right this is one of the most genuinely hard problems i keep coming into is how do i start a task at a defined interval time in the future and the answer is there are very very there are lots of lots and lots and lots of average answers to this question yeah i want to find a good one i think to reference that talk that you mentioned i think anna mcdonald's answer would be that's probably not actually what you want to do exactly and that is the thing it's like you very you don't like being time independent is possibly the most powerful thing you can do yeah and it comes down to this idea of saying you want to do this and then you keep exploring you go well i have a cron tab no please stay away from the crime tab and then you go well i can do chron in the database better and then you look at tongue like temporal.io which is a wonderful which is not quite one of these dag processes of erecting a cyclical graph processing engines but it does have all these primitives like delay x and then do they think that sounds interesting is that what i should be using and you look into it and you work out how it's doing it you realize yes for some things ideally never but it's like having a ttl check effectively just as t it does a really clever ttl check in like whatever the base database it's using is and then extracts that into your programming language for you but then it comes down to this idea you say well what's next and you say well i need to get the data out of that so change it to capture there's tools for it on my database and this is why like a lot of why i have a lot of fun at ivan is i get to say yes like generally like we all know that kafka solves a lot of problems and definitely not all problems and it's fundamental and i will challenge that statement of it being the new data lake any day of the week but that's for a different one i'll have that argument another day that's a different argument yeah the key thing here is it could be used as one at a pitch yeah and i disagree wholeheartedly because for all kinds of reasons but the key thing here is like but what would be better and the answer is well like you know hoodie and iceberg have first class integrations with it so why don't we find the thing which is optimal for the tasks we have and with ivan actually i start with click house because you can write divert those but they also do that wonderful compression across columns yeah so i'm like to this dream i have one that because all these nodes that connect to each other dream of actually building a map of computing exactly and there's like a lord of the rings thing there yeah despair and then you have like the and then the signal goes through like the beacon fires at the tops and the data lake will be drawn as a real lake with things in it we'll be with the black marshes yes as you can guess the true dirt shines through yeah on that point perhaps we best leave it with the dream of a map of programming exactly and the idea of being able to traverse it with the right tool at the right place yeah yeah and not get lost on the way oh we would we wish probably would even then because it's fun right it's always fun and that's kind of the joy of it all is the answer the answer is it depends it's kind of is always thrown out as a bad thing but the answer is it depends mostly because we have more than one answer and many of them are pretty okay yeah yeah and some of them are most of them are worth knowing for later for one day in the future yes and it's always great to be able to say yes but yeah on that note ben gamble thank you very much for joining us and filling us with some new things to put on our map well thank you very much for having me it's a pleasure as always pleasure see ya thank you very much ben we will be continuing to draw that map of the landscape over here at developer voices so do consider subscribing if you haven't already we will be back next week with more in the meantime you'll find links to the things we mentioned in the show notes along with ben and my contact details if you want to get in touch and if you have a particular expertise in some corner of that programming map let me know i'm always scouting for interesting new guests new tour guides to show us around places and with that i will leave you until next time i've been your host chris jenkins this has been developer voices with ben gamble thanks for listening foreign