okay hello everybody so got a program with guts and i this is a talk i've done today i've done variations [music] so let me think i'm getting some interesting interactions let me just okay that should be fine okay so what i've got is feel free to ask questions as we go there's some variations of this talk material that are out there but i decided you know this time i'm gonna do it slightly differently i'm gonna i'm gonna throw in some new code and and just have a look at look at things from a slightly different perspective because testing is certainly something that i go i talk about quite a lot so let's start off with the easy stuff this is what i look like in the real world when i'm standing up okay so just imagine me doing that rather than sitting in my office this is how to get in touch with me i'm easily discoverable on the internet my parents are generous enough to give me an internet unique name you can find me on linkedin you can find me on twitter so feel free to get in touch with by any of these means but what i want to talk about today is unit testing and there's two aspects here the main aspect what i want to talk about is present in the title program with guts guts g-u-t-s or g-u-t good unit tests which also works very nicely in german because what do you want your unit tests to be you want them to be good don't you i mean you wouldn't want that to be bad so that's the main aspect but i also want to mix in a little bit of consideration as to our workflow how do we run our test what is our workflow for tests of the most obvious ones that i'm going to rest on is tdd but it's not the only game in town so i'll talk a little bit about that but that's not the main goal here my main goal is not to try and sell you tdd is trying to sell you a way of thinking about your unit tests that is well useful and constructive and fits more naturally perhaps with an intellectual outlook on your code so first of all let's kind of think okay we've got some feature development what is the most popular testing style when we talk about testing workflow you know do we write our tests after our after our feature or do we write our tests during our feature what's the most popular well to be fair the most popular testing approach is testing what testing okay we're not going to talk about that one today we're going to assume that you know you think yeah actually i think testing is something that i want to do it is ultimately my code it's like it's the same way that i don't just simply write the code and say it's not my problem whether it compiles it's somebody else's problem and yes i do know of somebody who had this attitude many years ago i certainly know the number of people who have the attitude it's not my job to test my code that's the job of the testing department they find bugs i write the code i'm a developer therefore i am god in this organization i hope we are we don't you're not one of those people you're a software developer that means develop software if somebody said type code if you're a code typist then fine don't test your code but we're trying to get something that is whole here and you know whether you take the engineering metaphor or the craft metaphor there is a completeness that is suggested here so the most common way in which people acquire testing as a habit is this idea of living it long after development and that separation is a bit problematic because it means that typically our code may store bugs it might become a useful bug store that's not very helpful it also means we end up with very separate scheduling but also we end up forgetting what the code was for now it's perhaps good that we get a a kind of a closed box view of our code the problem is though we are so distant from it we don't perhaps understand it so although this has value we tend to prefer the idea of test just after development okay i'm working with i'm testing the feature this but i'm going to test just after the development jacob profit a number of years ago coined a lovely term for this plain old unit testing okay we're going to do it after not a long time after you know where are we november it's not a case if i wrote the code in january now it's november maybe i should write some tests this is more a case if i wrote i wrote code this morning this afternoon i'm going to write the tests and that's kind of just plain on you testing and here the danger is perhaps that we're not thinking about what is the purpose or meaning of our tests and that's an interesting thing you might be thinking what do you mean purpose and meaning surely the purpose of tests is to find bugs if that is what you are thinking then you've come to the right talk because that's not actually the purpose of writing tests it is one of the things that tests can do for us but it turns out tests are far more capable we want a much richer a much richer view of this the danger of the plain old unit testing is we treat the code as a passive patient we it's like oh the code is right i'm just going to check that it's right and i poke it in my product and i'm not necessarily inspired to improve it but i will fix bugs but i do have some separation from it so i get a slightly more objective view but the danger is i also in my head i'm thinking oh i'm done i've done with the feature see the way that it's on the screen i'm done with the feature and now i do the testing and you can hear this in people's language what do you do oh how are you with that feature oh i've finished it oh so are you on to the next feature now no i'm testing that feature oh so done means i haven't tested it right thanks got it this is the problem you end up with a separation whereas it should be treated as actually is part of feature development so these days we do pretty much everything continuously and we want to encourage a kind of a test alongside a test continuously just as you know it's a case of you know hey what did you do this morning i wrote the code oh when are you going to put the semicolons in oh yeah i was planning to put semicolons in this afternoon you know it's i treat that as a separate task it's a case of you do it together of course the idea here is that we are treating the testing as part of software development it's not a separate act you don't develop and test testing is a subset of development not a separate set and it's continuous and when somebody says hey what did you do this morning did you write production code or test code the answer is yes yeah it was they're interleaved it's continuous it's alongside however we want to view it now this is a kind of a restatement and a rediscovery of what we have known for decades and you can find it in andy hunter dave thomas's book pragmatic program it's just a couple of decades old you can find it in the 1968 software engineering conference in garmisch nato software engineering conference they talk about this idea that testing should be interlaced with your development and so test early test often test automatically now this is how we want to think about it now i could draw it like this but let's actually try and show that it's much more mixed in and i've got a couple of choices in terms of my style there's one that is perhaps it's not known by its acronym but this acronym has turned up in has turned up in academic papers iterative test last the idea of i write i write a little piece of code then i write a test then i write a little piece of code then i write a test i write a little piece of code then i write a test in other words i'm always kind of focusing i'm on green okay i'm i'm doing that then there's the other way which is i as it were it's also can used by leading with the other foot now i generally prefer this way that's not just there's nothing wrong with this ways i generally prefer this way and we'll see a little more motivation for that later test driven development this is about testing this is not about testing which sounds a little bit strange given that the name has the word test of course naming is hard and we're not very good at it so that's we'll come back to that one later but with this one i lead with the other foot i'm still doing it alongside but my goal is i'm going to write a test first then i'm going to write the fulfill that with a feature i will come back a little bit more to that but what i want to concentrate on now is the fact that sometimes people confuse the bit that i'm about to say with tdd aleister coburn had this observation a number of years ago says very many people say tdd when they really mean i have good unit tests he was highlighting this issue that we don't have a separate term for that you know i can put tdd on my cv and it means something to somebody but if you write on your cv i write good unit tests that doesn't there's no particular style or meaning to that phrase tdd is a way of doing something guts is the something and the point is you can write guts whether you're doing pouting itl or any other approach you can write guts and what do we mean by that how do we know that we have guts we need to define what we mean by the good stuff so in a blog that i really need to get around to publishing it's been sitting on draft form or medium for ages but i'll still put it there and i assume my words will remain stable a bare minimum definition of what we mean by good test is that when the code is doing the right thing the tests pass that's the absolute minimum and when a test fails it means the code is doing the wrong thing okay nice and simple it does not mean that when you're when your test pass your code works it means that if your code works your tests will pass please do not get those the wrong way around i hear sometimes people get those the wrong way around so and that means basically that if the test fails it means there's a problem you know most unit tests do not satisfy this very simple criteria they are brittle they are anchored to implementation assumptions you know i see people writing codes oh i'm going to calculate the hash i'm going to calculate the hash of this object and you know because i need to put it in an unordered map so therefore it needs to be hashable okay fine and then they calculate they calculate hash and then they assert that the hash equals a particular value you know what if i change the hashing algorithm that test is going to break and it's not going to break because the code is wrong it's going to break because the test is wrong the test is brittle you're not asserting that it equals a particular value there aren't actually very good useful tests for hash or rather there are but they're outside the scope of this talk you're not anchoring to a particular implementation value it's like asserting that the address of a particular object is always going to be the same that's not something you're going to anchor on so there's an important consideration of understanding that your test needs to have the right strength don't over assert don't over assert on implementation specifics because when you do that and you make a compatible change your tests break and somebody says oh your test break because there's a bug in your code no my test bait because there's a bug in my test and there always has been they're asserting on things they shouldn't be asserting on now that's the absolute minimum but that doesn't really tell us what good looks like so what i'm going to do we're in there we're in c plus plus space and let's mess around with algorithms okay we know what an algorithm is a process or a set of rules to be followed in calculations or other problem solving operations especially by computer and in fact geniusly enough in c plus lots of the algorithms to be found in a header called algorithm please do not do this in your project that's a terrible piece of design it was it was bad in the mid 1990s i remember mentioning this to a colleague imagine putting all of your classes into a header called class but actually even worse the algorithms header in c plus plus c plus plus standard doesn't specify algorithms the c plus plus specifies outcomes you are free to use any algorithm that meets those outcomes so the curious thing is that the header algorithm doesn't actually or the c plus by standard does not specify algorithms except in a few limited cases so it's kind of a remember i said naming's hard yeah name is hard so yeah please do not copy the techniques used in the c plus plus standard in your own project take a step back and say is this historical is it accidental and if it is a good technique follow it but the c plus standard is not a source of wisdom it's a source of history and i do say that as having been involved in it so i'm going to show you an algorithm and you're thinking okay kevin's going to land some really cool algorithm on us today and yeah i'm going to land a sorting algorithm on you but i'm going to land a sorting algorithm on you that only came to light last month this algorithm is quite young stanley young from i think university of leicester or possibly de montfort university he's established and came across possibly the simplest and most surprising sorting algorithm ever er i'm going to definitely tell you up front this algorithm is not safe for work please don't use this i mean it's not as pathological as some algorithms i have recently been writing some blogs on pathological algorithms like drop sort permutation sort sleep sort i also have bogo sort in the pipeline and a couple of others including this one but what but what fong notices he says most of us know these simple sorting algorithms like bubble saw very well or so we thought have you ever found yourself needing to write down the pseudocode of bubble sort only to realize that it is not as straightforward as you think and you couldn't get it right the first time curiously enough i actually had this one with my son my youngest son is doing a computer science gcse which is a an exam in the in england that you take when you are 16. and he's doing that and they are covering a couple of sorting algorithms bubble sort insertion sort and merge saw and i suddenly thought bubble sort well i can explain the principle but if i sat down and right to write the code i'd probably get off by one error this is exactly what it says it needs a bit of care to get the loop in to see start and end just the right values not going out of bounds or to handle some flags variables would it be nice if there's a simple algorithm with no such hassle and he said here is an algorithm that sorts an array of n elements in non-decreasing order actually he means non um so yeah it's in non-decreasing order and the algorithm is is quite useful you know it does the right thing here it is it's just like okay now he's not fully named it but i call it he's he has named it here the name i can't believe he can sort so this is he doesn't doesn't otherwise name the algorithm in the page so i call this the i can't believe it's consort algorithm it's quite fun i said that's it yeah it's just two nested loops this isn't not just o n squared this actually is n squared it's straight n squared that's it it will take for any given n it will do exactly the same number of comparisons okay as you said that's it just loop over every pair of ij values in standard double falling way and compare and swap what could possibly be simpler now the first reaction of someone seeing this algorithm might be this cannot possibly be correct and the next most common thing is you've got the direction of the inequality wrong and also the loop indices wrong it's like no actually it is correct and we're going to demonstrate that by using the power of testing so here let's throw an implementation let's let's kind of like concept eyes a little bit i'm not going to go the full concept and then say that it should be less than comparable but you know i'm going to use it swap i'm going to make it look c plus plussy i'm going to use use iterators and yeah kind of translates kind of easily so first thing this book that i wrote a number of years ago got edited and wrote a couple of pieces for there's a really nice piece by jeremy zara so write tests for people that's what we're going to focus on i'm not just going to test this correct i want to find out how to write tests for people and we're going to make a few mistakes on the way well not mistakes we're going to follow things everything's going to work it's just is it the best way to write it are we or do we care about our audience because this is the point that gerald makes who should you be writing the test for for the person trying to understand your code in other words for the person trying to understand your production code we are writing this for somebody who is going to use it or is going to maintain it we are not writing the test for the person who's going to maintain the tests that's a very that's a much narrower audience in one sense but the idea is that our tests are usage code a test is an example of usage which is one reason why sometimes it makes sense to write a test first show me how you want to use it before you show me how you build it okay show me what the feature looks like before you show me how it is run internally but it also identifies our target audience good test actors documentation for the code they are testing now i'll do the first lot of tests in google test and google test uses a two-part naming system and so you might go okay right what are we going to call and maybe i could use the whole i can't believe it can sort that that uses up too much screen width so i'm just going to call this just sorting test sorting sorts yeah that's not really saying much test sorting works or sorting is correct or gives expected result if you are if you are writing tests like this and by the way every test suite has at least something that looks like that test that this thing works test that this thing is okay guess that this thing gives the result as expected in fact you can add loads of words and you know what they tell you absolutely nothing because why would you be testing that it doesn't work the only time you're ever testing that something doesn't work is when you are when you are having to preserve a bug for backward compatibility because people have written against it test that that fix that you want to make is not being made because it turns out lots of people depend on this undocumented feature okay that's the only time if all you're saying is test that this works then you need to find a better way of saying it so well let's move more in that direction this is a little bit better it's not totally where we want to go sorting gives sorted values okay so now i'm saying something a little more specific but there's more we can do so what i'm going to do here test sorting give sorted values and i'm going to take random values let's say twenty thousand rounding votes so this is one of the ways i see c plus plus developers often tackling this kind of problem the first thing they do is they go oh i gotta test the algorithm works and they just generate masses of random data they throw it at the thing and then they assert something about it right the fact that you're using random data is actually noteworthy sorting random values gives sorted values and it becomes noteworthy as we go through we'll notice that now i've factored out how i'm generating random values so let's go and look at that so one of things i can do i can generate the random values how many i want i'm going to use a vector of unsigned and i'm going to use stood round and there might be some people going well why is easiest to rants durant is bad be very clear stood ren's absolutely fine here there is nothing wrong with using stood rand because there should be no effect on the outcome if somebody says yeah but what if you're running a monte carlo simulation we're not what if we're generating a key what if we're doing something security sensitive we're not we just need value we don't actually care about the randomness in fact you can do this with you can actually generate a completely non-random sequence and this test will still work the point here is that doesn't matter i'm just reaching for this because it's kind of where most people are at in terms of their understanding of random numbers and this works it works first time it also means i can avoid having to use the c plus plus standard random number facility which is really cool if you really need to care about random numbers but when you really don't you have to go through an extra number of lines of code if there's one thing that it's good for is writing more code so in other words if i just really want to generate arbitrary values that's what i care about and this is fine i can use back in search right generate and i'm doing that that's fine now this is not fine actually there is a problem if you are going to use any kind of randomness pseudo randomness oh first thing if you're going to use any kind of randomness please make it pseudo-random do not use real random numbers as in that you can get from random device because if there is a test failure you need to be able to rerun that test test should be reproducible that is another quality of a good unit test it should be reproducible okay now feel free to use truly random numbers in an integration test but because you can't reproduce it i'm immediately saying that depends on things that are outside of your control therefore it is not a unit test okay a unit is where we have complete control over the circumstances of execution so what we've got is the the kind of the simple a simple aspect here of just generating generating this stuff we need repeatability i don't care how you do it make sure that people have the seed available so they can recreate it and here we have a very simple kind of example so however you do it this is going to work out the problem here is actually far deeper it's actually not to do with the way i'm generating random numbers is to do with our expectation most people who write this algorithm write it or write this test write it like this there are lots of sorted results that are incorrect what you this is what we're trying to do is what we're trying to do is do this by property we're trying to test by property testing the right property is hard the correct code for this is that you want a permutation of the original this subtlety is missed by most people who ever test sorting algorithms i've seen this in actually in real code you need a permutation of what is interesting is that to get this one right requires that insight so be very careful this test is now correct it now has a better name give sorted permutation of original values but we have a subtle issue here the issue being that it is more complex to get right there is actually a simpler way of demonstrating this correctness however we have converged on our naming style our naming style is based on a propositional naming so this is the book i learned you know logic from many years ago you can kind of tell from the the typeface that it is a little bit old so so we've got something there and that you know that that's kind of cute but what i'm interested in here is the idea of propositions we are going to name our tests in terms of propositions truths for stating how things are or how they might be so in other words only indicative sentences which it makes sense to think of as being true or as being false are capable of expressing propositions so therefore sorting random values gives sorted permutation of original values that's absolutely fine there's another technique and this one is particularly applicable where you are writing code for which functionality already exists or another version perhaps it's a legacy version perhaps it's a sub-optimal version in this particular case i could say you know what we already have sorting algorithms so what i'm doing here with i can't believe it can sort is i am going to prepare an existing one sometimes this is referred to as an oracle in other words i have got an example of what i'm expecting and i'm going to generate all this stuff and then i'm going to generate it using two means i'm going to generate the result using one that i know gives the right result i'm i'm trusting that the the the author of the standard library as the authors of the standard library have done a good job with their implementation and then i'm going to compare it against mine just as a minor point just simply within the context of google test this approach will give you this approach is going to give you better results than this not just from a simple performance perspective his permutation costs a little bit but simply in terms of feedback if there is an error if there is an error this one will tell you false it will tell you that the expectation was not true that's not very helpful whereas this one will actually show you where the diff is so what we see here is kind of an observation for tests to drive development they must do more than just test the code performs its required functionality they must clearly express that required functionality to the reader this is the challenge your test should be an act of specification they must be clear specifications of the required functionality now if we take a step back and do that then we have an interesting situation here where what we can look at is these different cases sorting an empty range has no effect sorting a single value leaves value on change sorting an equal pair these values unchanged the first thing we know from this is that even though we have a single function a single entry point in effect we don't have a one-to-one correspondence this is a very common kind of a test smell i see somebody has a function and they test it using another function it's just like unless this is hard coded to return a single result you need more characterize the cases don't try and fold them all into one and save time because you won't save time the next person along is going to go i don't know what you're doing make it clear it's a writing test is an act of communication so what we see here is we're going to single out the cases an empty range has no effect first thing we're telling people is by the way we know that it has no effect also it works it's not an error case a single value leaves the value unchanged an equal pair leaves the values unchanged and ascending pair leaves the values unchanged it turns out you don't actually have to write any code for the first four tests and you might say well what's the value of that because these are the bits that people miss when they make changes they often we often get the hard bits right and get the easy bits wrong a descending pair exchanges values sorting equal values leaves the values unchanged okay ascending values itself and so sorting mixed values puts them into non-descending order excellent so this works nicely if you want to throw in the random tests for scaling that's really good now that's kind of that's that's kind of a kind of a nice little example of actually how we think in terms of specification the idea of your tests are specification oriented that's the kind of the focus we're trying to give and the let's have a look at them open it up a little bit so if i look at this from this point of view then this is an adequate test this is fine you know i'm just basically there's not a lot you can test there's no point sometimes i see people trying to test the size of the vector there's no point in doing that because there's no way that i can't believe it console can change the size of the vector the size is immutable it doesn't modify it the only thing we can actually meaningfully assert here is that he doesn't throw is that true well that actually isn't true now this is a little more true so this is a little more useful the most common class of error that we experience when dealing with any form of algorithm is off by once overruns in fact i still think that buffer overrun is still in one of the top 20 most common defects that you find security vulnerabilities you find on the internet so yeah off by one's very popular and we can actually demonstrate this thanks to the range capability we can sit there and put two markers at each end here's a z here's an a i'm going to sort the empty range within that between the z and the a if there is an overrun then one of those will get clobbered or moved of course this doesn't deal with off by two errors but as i said statistically off by ones are far more common than the off by other numbers if you really want to go to town on this then use a type that and use a build that gives you a range checking iterators but in this particular case this is sufficient to make a particular point and we can do the same thing again for a single value leaves the value unchanged okay so i'm going to put the maximum the minimum integers at each end and then i'm going to sort the one value 42 and that that's going to work out that should just work out fine now we will find if we look at this we're going to see a really kind of common feature so the for each usage scenario the tests describe the context the starting point all the preconditions that must be satisfied illustrate how the software is invoked describe the expected results or post conditions to be verified okay so the there's a three-part rule here the three-part rule is rediscovered and reinvented time and again the three parts there is a befall there is a there is a there is an action there is an after there is the past the present the future there is the three act play and we can describe this sometimes people talk about as the three a's a range act assert and so if you want you can label it if nothing else put blank lines between these put blank lines between these i you could if you wanted abuse the label facility of c plus i generally don't recommend doing that particularly because if you've got your compilers on any decent warning levels it'll tell you these are unused so you know if you want to put the comments in make them comments don't make them labels you may have come across given when then the there's sometimes people talk about ask about the difference or they think they'll give them when then something special in behavior and development well no it isn't actually it's it's identical to a range actor sir they are directly one for one equivalent i tend to prefer given when then because it also is much more requirements oriented so the from that perspective the the requirements orientation is a little more helpful it makes it a little bit clearer it gives us a consistent vocabulary that we use everywhere this is precondition operation post condition this is kind of like the triple you know this is this kind of stuff so there's a number of things here that are are worth pointing out now i've got a question in there an observation from mark about taking the address and standard function is undefined behavior it's perfectly fine in this case it works i'm and i'm yes i am going to get away with that because there's an interesting thing it's it's undefined in the standard but it is defined in an implementation so just for simplicity i put that one in there i should have put a disclaimer but i really didn't want to put all the machinery of here's how to do random numbers simply i always rather than make our job hard i'm going to make it so that it works on pretty much every characteristic implementation you can find i should have put a disclaimer but thank you for pointing that one out mark now the behavior is actually undefined behavior by the way is an artifact of specifications there's no such thing as code that has undefined behavior and i'm happy to debate people on that one it is undefined with respect to the standard but it is defined with respect to every implementation or every implementation where it works so that's a clarification so let's talk about coverage from time to time i hear people asking what value of test coverage they should aim for or stating their coverage levels with pride this is something martin fowler observed when he talked about test coverage as he points out such statements miss the point people can easily gain a statistic it does not mean that a metric or a statistic or an observation does not have value yes sorry i've just observed observe yes observation if it doesn't work it's undefined sounds like javascript yeah javascript makes undefined defined it's really quite bizarre it's very difficult to talk about i find actually talking about javascript i find very difficult anyway so there is a point here about being careful of understanding what you're doing with coverage sometimes we try and make numbers do things that they're not supposed to do for us and sometimes people make a an observation yeah daniella thank you very much yes we could put a we could wrap it nicely in a we could wrap that around nicely in a lambda and and that'll do the job still makes the code bigger but that will do the job and it doesn't even have to have a name which is nice so there is a notion here of understanding how we talk about our code and our structure i expect a high level of coverage this is brian merrick making this observation another signature signal traditionally agile manifesto and brian is originally a tester he's also he's got a very nice equivalent kind of inquisitive way of looking at a lot of development practices sometimes managers require one there's a subtle difference now this is kind of an important distinction because i find that most people who quote coverage stats don't fully understand why they're doing it and they also don't really understand coverage types so let's talk about the fact that we can gain the stuff there's a thing called goodheart's law once a metric becomes a target it loses its meaning as a measure now that doesn't mean that we immediately start gaming it it means that subtle effects happen in human psychology named after charles goodhart he was a professor of economics he said any observed statistical regularity will tend to collapse once pressure is placed upon it for control purposes the minute you start making your observation a control target then it loses its value as an observation so be very careful of that if you say oh we're at this percentage coverage here and in one month we need to be here there's a very good chance you can achieve that the question is at what cost are your tests any good ah yeah worry about good unit tests it turns out that you don't actually need any assertions to have good unit test coverage which also brings us to another point and i'm doing it deliberately at this point i have been doing what i advise people to not do i have been using the word coverage on its own please if you mean statement coverage say statement coverage okay there's lots of different kinds of coverage statement coverage is the easiest one of the easiest to measure and it's therefore the one that people quote it's also one of the easiest to hit 100 i mean if you're writing new code and you don't have 100 statement coverage you really got to ask yourself how did you fail so badly to achieve such a simple thing because it statement coverage is just we touch every single statement at least once to 100 statement coverage is possibly one of the most trivial things you can ever do to achieve 100 state coverage is only a problem for people that don't unit tests and for code bases that do not have unit tests it is a very dull achievement for anything that is new code where you are writing new tests it is really it's it's not even it it's not even a thing okay and importantly if you are driving by this it is incredibly easy to gain let's pick on sorting mix let's let's sort the mixed values and put them into non-descending order okay so i've got a number of values here i'm going to sort them i'm going to do that so what i'm also going to do is i'm going to delete all my other tests if i write this one test case i get 100 statement coverage we're done if that was our goal we are done okay be very careful please do not use state percentage statement coverage so please don't use percentage coverage play say statement coverage if you mean statement coverage say it remind people that there are other kinds of coverage you're not done psychologically the problem is when we say 100 we think there can't be anything above that you're not done okay the point here is there's statement coverage there's function coverage which is off the top there's loads of different kinds of coverage that are even more trivial and then there's branch coverage loop coverage condition coverage multiple condition coverage all of these are potentially achievable from a point of view of 100 this but they get progressively harder as you go down the screen and then we hit the ones that you're unlikely to ever achieve path coverage parameter value coverage state coverage it is unlikely that you will even get to one percent on these to give you a rough idea of parameter value coverage what that means is that if i have a parameter to a function that is in 32-bit it to achieve 100 parameter value coverage requires me to have two to the 32 tests for that okay that's what that means so no you're not going to get 100 on that one so be very clear about the kinds of coverage you're talking about it's not so in other words i'm not saying statement coverage doesn't have value i'm not saying 100 state and coverage doesn't have value it's a really simple one because sometimes it's very easy to spot when you drop below 100 statement coverage because of dead code because of something that you had not accounted for and so therefore it's a it's a good way to detect unreachable code and what do we do with dead code well we find it and we delete it it's not a technical issue it's a cultural issue so in other words this is one of those things where tests will support a style and mindset for being able to eliminate code now there's some other things we can talk about in terms of achieving sort of decent coverage and understanding the kinds of coverage we're getting with our code things like mutation testing so again those are outside the scope of this tool let's talk a little bit about unit testing 1970s style so alfred ijo peter weinberg and brian kernighan awk developed the orc programming language lovely scripting language which sandy was displaced by by pearl which i am delighted to say i've never i was never i was a big fan of orc never a fan of pearl and i've been a fan of most description languages since pearl so i'm delighted to see that pearl has kind of lost its mindshare and market sharing has been kind of not quite white from the face of the earth but it's going the same way as orc but orc is a lovely language and it started off as really an experimental research language just messing about but one of the things that they did i found really interesting in an interview with alfred ajo and this actually i found another interview with brian kernighan where he mentions it a bit later but in an interview with alfred he talked about the fact that here they were in the 1970s and he said any of the three of us who put in a new feature in the language first had to write a test for the new feature so it turns out that these guys were doing test first development in the 1970s test first development if you like or test driven development is very much a philosophy of 101 coverage in other words you cover more than you actually have code for that's a psychological thing it's not really 101 please don't try and correct on that the idea is you're always overreaching you're always trying to specify more than what you have and it's a simple way of ensuring you maintain high coverage so any continuous form whether it's itl or tdd maintains a high coverage level naturally it's a consequence of that you're never looking to reach it you're just looking to not fall from it okay it's a very different psychological outlook if you are looking for coverage beyond the standard metrics a simple review approach is to kind of categorize things and say well what are the kinds of things that i've got i have simple cases okay do test the simple examples i remember chatting with one developer probably c plus plus probably a c plus developer a few years ago who it took 20 minutes to explain to me why he wasn't going to to write a test that was going to take him five minutes to write he said oh it's such a simple case you know you're never going to get it wrong honestly if you've used software for more than a few minutes in your life you will discover that it's normally the simple cases where people have the blind spot because you're so busy remember you go back to that code you say right there's four things i need to change one of them is really hard you really concentrate on getting the hard thing right you completely get the others wrong it's often the simple cases where we trip up so having those cases in place is not that we're testing that they are correct we're showing people that they are entitled to the assumption that they are correct and we're clarifying what we mean in these cases we also have common cases so i'm building up a venn diagram here because obviously some simple cases will be common and some common cases will be simple but not all simple cases are common and not all common cases are simple so we've got that we've also got boundary cases the edge cases and then we've also got error cases just out of interest if you've ever wondered how to draw a venn diagram with four overlapping sections so that you get every single combination of them this is how you do it it's a tulip it's a flower the ones you normally see on the web with four circles just overlapping that no that doesn't work that's incorrect you can do this up to five and then i think after five you have to break out into the third dimension fortunately i only identified four general categories this is a really simple way of looking and doing reviews when you're with a colleague let's review stuff and go through and say okay do we have simple cases do we have something present for everything and of course it may be in this case here but the idea is you're trying to cover stuff okay now so what we're going to do is i'm going to switch to a different book it's got the word java in it now actually the piece of advice here i edited this one last year on the lockdown i finished editing it with trisha g from jetbrains about half the advice in here is actually not java specific and it but it is you know it's intended broadly and one of my favorite examples of this is piece by marie van dyke use testing to develop at a software faster she talks very much about the qualities of what we'd say is a good unit test and she talks importantly about one of those things if we're specifying the idea is that i've got a kind of living specification and the idea is my test is going to give me feedback if i take a specification or interview the idea is it tells me what is not yet met in in a number of cases a point there is your tests are informational your tests are an act of communication a failing test should tell you exactly what is wrong quickly without you having to spend a lot of time analyzing failure this means each test should test one thing this is good old-fashioned cohesion exactly what we want for our individual functions and our classes and our subsystems make it focused on one thing a test that tests two different cases is not testing one thing it is testing two things use meaningful descriptive names now that's a little bit vague we need to be more specific don't just describe what the test does either we can read the code tell us why in other words this is this idea of the specification show me the intent the purpose don't show me the mechanics i can see the mechanics that's not the bit when i read it and importantly when it fails i want to understand what is the intention the specification that is failed honey asks a very specific question when can we expect 97 things every modern c plus plus programmer should know i do not know what i do or okay there's two answers to that question and i'm not speaking for the publisher here although i do have a good relations with folks at o'reilly my understanding is that they have been approached about a c-plus plus one but they have chosen to take a different path with that and and so they're not they're not going to be doing that which i think is a shame because that was going to be one of my follow-up suggestions or rather leave it to somebody else to follow up and i was going to be happy to help them and contribute so so yeah i don't really know the future of that if you look at the 97 theory seven things then it's kind of taken a slightly different direction in that sense lucian i think you've just described the yeah and i wasn't gonna be specific peter i knew it was you but i didn't know if you were on the call i didn't want to make anything specific but yeah peter i peter approached me about this idea i mentioned it to him peter approached as a peterson had approached o'reilly and unfortunately they said no and i think that's just a policy direction and i also know there's a couple of other things that would they moved in a different direction as well which is a shame i think lucian's observation about 97.00 every modern cbs program should know i think that's that's a javascript one actually not a c plus plus one java c plus plus does have more than enough integers and probably more integers than people ever need it's javascript it's going to have the the decimal point and the floating point issues so the observation here is that the feedback we get from a name should help us understand whether or not a failure is because we have updated functionality but not yet updated the tests what we might consider to be a phase error in other words yeah yeah i'm working on it and i forgot that bit great thanks i changed the code but i forgot to update the test and that's a reminder the the issue is it's either that or it's actually a genuine bug so therefore we need to understand the intent and look at the intent and go oh yeah i forgot to update that test or oh i wasn't expecting that okay there's something properly broken here and then oh you meant losing you meant thousands oh honestly yeah there's 97 000 things every morning but yeah then that book is gonna take a few years to pull together so let's start now mariet's observation never trust a test you haven't seen fail is a good one because sometimes you don't know that you are testing something and this is also by the way one reason why i find the test first style quite a useful one because it does make sure that in the midst of all the copy and paste all the assumptions and all the things i know that the next step i'm asking for behavior that does not yet exist and if it does pass then i must have done something wrong okay or there's something wrong with the code base and somebody's already implemented it okay so that's the way i look at it but more broadly do check every now and then just tweak something mutation testing or whatever manual mutation testing or automated mutation testing or a test first approach let's take these tests let's take that intuitive switch that people sometimes do the less than people go oh that's got to be the wrong way around it needs to be greater than what happens when we run it against those tests yeah we find out that actually those tests are just fine now what i'm going to do is i'm going to finish up with a kind of a quick look at another example let's move to abstract data types yes it is that barbara liskoff list substitution principle very same barbara liskoff did a lot of really interesting work in the 1970s on programming language design and data abstraction she basically she and her team basically came up with adts and a number of interesting ideas some of which influence c plus plus some which would be influenced other languages and there's this whole idea you're trying to characterize most of the time when people are working in c-plus plus and they're writing classes they're not doing object orientation they are actually doing adt development the details of that paradigm i will leave as a discussion for another day but we are kind of very familiar with this i'm going to pick on the idea of a queue and we might say well we have some kind of queue it has a length i'm going to use the language of cues in other words i'm not going to use the language size i'm the language of q's is horizontal a queue is a horizontal metaphor as opposed to a stack which is a vertical metaphor so i'm not trying to make this fit in with stl naming conventions so i've got a length i've got a capacity which is the maximum length i've got the idea of being able to enqueue when we're full we that does not enqueue and we've also got the ability to always dq so we're able to pull something from it and that's as always we're not saying there are no error conditions in this we're going to keep it simple now in principle we could have it as a kind of a decoupling between a producer and a consumer perhaps different threads or even in the same thread the point there is that you know we can use cues in a number of cases all queues are effectively space-time decouplings however we use them if you look look at any application wherever you're using a cube whether it's an inter-process queue whether it's a simple queue for holding values that you're going to pick up in the same thread later you're decoupling either through space or through time or through both but space-time decoupling is probably not the best name for it i am going to also just basically say i'm going to eliminate copying behavior from this because in principle i could be talking about something that is shareable between threads and therefore has locking behavior and that doesn't really make any sense to copy those around so i'm going to disable that capability the example i'm actually going to do is is not based on that at all it's going to be single threaded but as a point of principle for the interface i want to keep that stable so let's get rid of copying behavior let's understand what we mean by queues a queue can be buffered it can have a capacity therefore it's bounded and it's asynchronous however we choose to use it if you're in one thread it's still asynchronous because you queued the values and later you pick them up the one you want to avoid is the idea of unbounded queues those are not necessarily a good idea if you have any any form of consumer that fails then it means that you're just going to fill up memory that's generally not good which is why we in production so unbounded queues are unbounded queues are not really things you should have in significant parts of your architecture they're fine for toy examples but you really all cues should have should be bounded in some way if they have significance we can limit it even to one a single place holder a mailbox if we make it single use then we already have a name for it it's called the future the other side of it's called the promise we can even in principle have a zero length queue which is basically a synchronous rendezvous however that's not where i want to go with this code so i'm basically going to say we're not allowed that they must always be buffered so what i've got is i've got a capacity i'm taking that explicitly and what about the implementation well barbara liskov says program is concerned only with behavior that object exhibits but not with any details of how that behavior is achieved by means of implementation this is important it basically answers the question sometimes people say how do i test the private stuff either you do hash to find private public or a better answer you don't why do you want to test the private stuff okay you test test stuff that you can use if there's something that you can't use then you're not interested so if your private representation is doing something that is so complex that you feel that you need to test it then that normally tells you you have a separate abstraction you need to pull out and test that in other words it needs to become a first class abstraction we are testing from the point of view of usage we would like our code to continue to be stable so that refactorings do not involve rewritings of the tests as well okay the idea is i refactor and i achieve the same behavior and confirmed by a test so i've got an implementation there i'll leave that on the screen for a moment that's not the bit i'm interested in let's say i'm using a deck the idea is it doesn't matter whether i use a deck or a list and we're all good no public access and that's the perspective we're going to take for this i'm going to use catch different testing framework phil nash did all the hard work i came up with a basic idea of the defining nesting principle and the decomposition of assertions but phil did the real heroic stuff and actually turned into a proper open source project and she did i did it as a proof of concept but his work absolutely brilliant there's some really good stuff in there if you've not checked out not checked it out do go and have a look now for a lot of people they'll sit there and go okay maybe i can structure it like this i've got a q specification and then i've got how many operations i've got a constructor i've got the length i've got the capacity i've got in q i've got dq you know what that's a really bad set of tests because each one of those tests doesn't really test anything meaningfully you can't actually test length without doing something else yeah to test length you need to construct [music] yeah so in other words links will also use constructor but to really test length you also need to be able to enqueue and dequeue ah yeah and how so this is the most common way that people write tests for classes is they do one test per member function this is obvious it's intuitive it's incredibly common it's almost completely wrong in every single case we need to take this much more structured example of thinking of a specification and this specific example q is a highly stateful life cycle based object and nicholas nielsen has this lovely observation you know we really need to learn to think in states i find many developers are not used to thinking in the states and life cycles as he says in most real world situations people's relaxed attitude to state is not an issue unfortunately however many programmers are quite vague about state too and that is a problem so if we represent the idea of the queue we have a capacity and we have a length we've got an idea of fullness there and we'll go okay well it's mostly non-empty so i could draw a simple state diagram i've got my precondition here you cannot create a new object that has a capacity of zero we've got our transitions when we dq and empty it becomes empty and it's not an error mode when we enqueue it becomes non-empty when we enqueue in non-empty we remain non-empty when we dequeue and the length is greater than one we're still not empty we dq and the length is one then we become empty otherwise it goes to zero yeah but that's not really the full life cycle model we haven't really talked about fullness there's a different behavior when we're full from when we're known for so we've got a hierarchical state machine okay and this is what this is in harrell notation i'm not going to show you all the tests i just want to show you the high level view of the tests the use of nesting is simple and powerful and allows us to represent in a very specification oriented way the structure that you've just seen in that diagram okay we have the initial we have the initiation then we have empty queues and non-fgqs then within that we have not full and full and within that we describe the relative behaviors with respect to the state that they're at what we're saying here is that we are structuring our tests according to in this particular case the initial state is it empty is it non-empty but non-full or non-empty but full in other words we use that as the top level it also suggests by the way so in other words this is not just an internal narrative for each test case this is actually a broader structuring principle it also suggests we can structure our tests according to the action we're doing and also the consequences of what we're doing okay so in other words we could choose to have the top level be outcome not generally useful very useful for classifiers this one is probably more useful these are the two that i use most often if you want to make the give and when then thing even more explicit actually in catch if you want to here's here's our simple example of an empty cube becomes non-empty when the value is enqueued what i do here is i just there is there are actually some macros that reinforce that so given an empty queue when a value is in cube then it becomes empty i can choose to enforce that structure should i wish my general preference i generally lean towards just doing just doing the just keeping sections but should you want to emphasize the given when then vocabulary that is you are free to do so and what we'll do is leave you with one final tweet one modification i have about one minute for questions then one final thing i might want to do is to deal with some what might refer to as endo testing i'm actually going to generalize the options i'm going to say we're going to have callbacks on when we hit empty and whenever we hit full whenever you try and do an operation and it's full you'll get a callback you won't add an element but you will get a call back when you hit empty and you try and do something that can't be achieved because of emptiness you get a callback and so i can use a nice designated initializer approach for this kind of stuff and i you know often people get very excited saying you need lots and lots of mock objects actually no i just i did promise lambdas you don't need all of that in c plus plus if you find that you're firing up lots of mocking frameworks take a step back you may find there is actually a simpler design in many cases here this is actually all that we need we just pass in a lambda we increment notified an empty queue notifies by callback on dq and you've attempted an operation that has no meaning and and there we get it was called once and only once and that kind of keeps life a lot simpler so there is a point about all of this all of this this artist this artist austin cleon has this lovely book called keep going a lot of this is about slowing you down and this is one of the most common complaints hey if i do this unit testing it's going to slow me down and people come to me and they they hope that i'm going to say no it isn't and so i tell them yes it is there's a very good reason you want to slow down it's not a typing contest if it is then you're probably writing too much code and you probably need to take a break it's impossible to pay proper attention to your life if you're hurtling along at lightning speed when your job is to see things other people don't you have to slow down enough that you can actually look as software developers your job is to pay attention to the things that other people miss we do this in code reviews we do this with supporting tools we can do this in tests the idea of tests is to slow you down over the minutes so you can speed up over the weeks that's that's the right time horizon but also to ask questions you might not otherwise have asked so also thank you to lucian and and jacob for answering marcel's question about the test framework catch it specifically catch two worth checking out so as i said questions so let me quickly answer some of the questions that are kicking around in the q a two questions there and so i may have answered thorben's question let me go to the second question there what's c plus plus unit test frame what do you like best and why i like basically what i use these days i use google test and catch and those are the ones i use i like catchphrase expressiveness because i'm allowed to use that was my original design premise with the prototype that led ultimately led to that called heathrow and heathrow i wanted to make sure that i could use full strings i wanted to make people think this is a specification in fact my macros are actually slightly different named my top level macro is called spec to really reinforce stop thinking about this like i'm testing a thing i'm trying to make it i'm trying to check it's okay i want you to think about it as a specification i want you to exercise a different side to your mind so that is why i like catch it's got that flexibility it supports the hierarchical structure really nicely i like google i like google test because actually it's quite straightforward for what it does and it pretty much does what it's supposed to it's fairly ubiquitous it has two-part naming not end part naming but that's a good start for me jonathan asked a question how do you test concurrent code interesting question i'm going to presume you multithread it because if concurrent means co-routines then that's easy if concurrent means multi-threaded then that is technically in the sk outside the scope of this talk not because i've not covered it but because it's actually outside the scope of unit tests unit tests are about behavior that you fully control unless you have suddenly come into control of the scheduler you don't control that it's it's effectively something that is an external it's external to your control how do you test it you can write unit tests but you have to be small statistical about it there's a lot of extra stuff you have to do and yeah that's you're not going to do it in a way that you wrote you ran the test it failed remember i talked about repeatability at the beginning the lack of repeatability or guaranteed repeatability is one of the reasons that's not a unit test you can test them but it requires a different approach in a different philosophy but you can use many of the techniques we have described you just have to be a little more statistical and cautious about your conclusions so honey has a question do you think breaking down test cases into simple functions a given block usually takes more lines of code to fill up preconditions is would be a good approach oh right so the there is an idea you can br one of the things that catch allows you to do is to factor out common given blocks effectively which is really useful in other words you end up if there is a chunk you have to take a hit on then you only do it once sometimes factoring out simple functions that create the right data for you i think that is a good approach but be careful that you name them and offer them in a meaningful way do not say generate test data because i don't know what that is in other words i should be able to read the assertion of a test and read the given and understand what i'm i'm getting if i can't see the intent of the function you have abstracted to shorten the setup in the test then that's going to be obscure to me okay so yes do that approach that's that can be very useful but do make sure you communicate the intent the idea is that when somebody reads through it they go given this where given this when that then yes i was expecting that or i can see that that is reasonable or even that surprises me if they sit there and go given in it when we call an operation then we're expecting this result it's like well no i'm not expecting that result i have no idea what init does i have no intention in that so make sure you don't lose communication but yes do abstract because otherwise sometimes when you're testing authentic data it's just like here's a thousand video frames yeah you're not really gonna kind of put that into a given section you have to get that from elsewhere so final question from the q a section although i may have missed something uh no no we're good on the chair another question from hani what do you think about the following regarding good utes preferable max unit test case length i just noticed this morning one of our legacy code bases with a 500 plus line unit test case at this point you need the scream emoji one g-test test case testing multiple test scenarios right so the first thing here is i don't think it's good to have a maximum test length because again whenever you specify a target people will meet it and in ways that are unintentional okay but you are right to say hey that that's have a smell indication it's an observation and actually your conclusion here is the way i would go how many cases are being tested in your test function if it's more than one case split the test function okay what you're seeing there is one g-test test case testing multiple test scenarios one scenario per function keep it nice and simple in that sense so that should be your trigger you know you initially you go wait a minute i have to scroll through a test that's not a good sign your second trigger is then what are we testing we're actually not testing one thing we're testing lots of things well hang on that's a decomposition there so i wouldn't put a number on it as a hard limit but use use numbers you know if you have to scroll through it use that as kind of a a warning sign so right thank you very much for your questions your thoughts your observations that's been thank you very much jens also for giving me the screaming emoji there in the chat exactly on demand and perfect so i hope that has been useful i'm going to go into the lounge now i recognize there's another talk starting in three minutes so thank you very much for your patience in my overrun but if you want to hang out i've got i'm gonna go into the lounge i've also got an ama tomorrow afternoon where you can pick up any other any other observations including some of my throwaway remarks you go hey kevin i don't feel that's true that is the perfect opportunity to turn up and harangue me with those questions tomorrow so thank you very much thank you for your talk kevin that was a great talk and yeah so if you want to hang out with kevin in the launch that's open and also the boosts of the tool and book there are now open so enjoy the rest of the conference and thank you for coming and then i guess i end the stream now and see you in the launch