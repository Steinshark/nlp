so welcome everyone i do encourage you to ask questions or even if you have comments try to come up to the mic and interact i've given this presentation a couple of times already and i'm i'm gathering feedback and new ideas so i'm already working on a version two of this presentation for next year because folks have been very enthusiastic to to come up with even more suggestions for c plus myths that we can chat about and speaking of chat and the whole popular twitter these days the c plus community is very large and it's quite vocal sometimes when it comes to controversial issues and we like to have opinions strong opinions and have debates on on various sometimes insignificant topics and we might fail to see the big picture and i think the problem is that we're very fragmented on on many of the topics that we talk about were fragmented based on the breadth of the c plus plus ecosystem there are so many industries and niches and interests and domains where c plus plus is used and we each bring our background and our experience to this conversation from what we work with or from our past experience and i think that's okay and i'm going to reference bjarnes elephant metaphor there but in a different shape apologies to the vegans in the room but this is my my take on it so we each see a different part of c plus plus and we care about certain features or certain goals about our programming language and we feel the need to impose those opinions upon the whole community and there's a lot of good sources of information out there there's almost standard cpp core guidelines there are plenty of best practices out there some of them quite opinionated there are established idioms that most of us follow their books yes books are still a thing there are very nice conference presentations and of course there's stack overflow and you are going to see a lot of very interesting takes on some of the subjects so sometimes i think it's difficult to distinguish between serious debate or foundational arguments versus just plain gags or fun stuff and i'm guilty of some of that myself and mixed up in all of this there's also plenty of myths and some of them stem from obsolete information that's still out there not just books but articles and even stackoverflow answers that are deprecated by today's standards and there's plenty of bad teaching materials yes i've seen plenty of those and speaking of teaching this is something that's very important to me i often do guest lectures at my alma mater and other universities where they invite me to do a workshop or present something and doing one in a couple of weeks and i care a lot about how we teach c plus plus as a beginner language what are the intro courses for c plus plus and how we how we approach bringing new folks into this community and in the c plus ecosystem and some of the items that you might see here today might feel silly or might feel trivial but but i do constantly hear them when i talk to students when i talk to interns and folks joining this c plus plus ecosystem if you want some of my takes about teaching c plus plus in one-on-one courses and algorithms i have a short presentation from accu last year speaking of stack overflow as a source of truth and learning i think we've all seen threads like this one where someone may come in without much experience and really desperate to understand stuff and they encounter people that are less friendly let's say and try to be the good gatekeepers of this community by pretending that everyone should have the same experience and knowledge as they do so let's try to be a more welcoming community let's try to remember that each of us have been in a situation where we learn something new and we need help so let's be more helpful how this thing started so the motivation was a couple of months ago oh more than a couple of months ago now time flies when you're having fun during the pandemic so some time ago i had to chat with jason about some of these topics and we said we're gonna do a stream together it's a very long video i don't really recommend that you go through all of it it's a more than two hours and we just riffed we said we're gonna do an improv session i gather some of the topics that i've heard frequently and we did the kind of a list of things that we want to talk about but the whole session was completely improvised where we try to write code and discuss some of those things that we cared about and it was quite popular last i looked it had over 20 000 views and the reason i i want to give this talk and i've i've done it a couple of times now is that i try to instigate a healthy dialogue around some of the subjects and others and i want to encourage people to feel comfortable raising questions about maybe things that some consider trivial or already known or solved but i want to encourage people to feel comfortable to talk about them and raise these questions and i want to encourage others to be helpful so just to set up the game as expected to i'm gonna try to put some tags on on the items like confirmed or busted and of course we all know the staple response for programmers it depends so let's test this before we get started io streams are slow that was just just to confirm it not really a myth c plus plus 20 modules will solve all of c plus plus his problems we all hoped it would but no and core routines actually shipped in c plus plus 20. i would say that's highly questionable without proper library support we've already seen two good presentations at this conference on co routines if you miss them i encourage you to catch them on youtube later and i i think i've seen over 10 maybe more presentations on google routine so far and i'm still learning i'm still trying to wrap my head around what we need to do and go beyond trivial examples and fibonacci generators i really love this this slide from kevin henny this is from a few months back at c plus plus on c i chuckled so hard when i when i i was in the room for this one i think it really captures what we got there okay so i think you got it how it works so like i said this is part one of this series i i intend to to do more and i encourage other speakers to join in in the bandwagon and maybe roll their own i think the the older folks in the room might remember times where stack overflow and forums were not such a popular thing where and where we used to reference item numbers from squadmeyer's books like item 14 item 21 in code reviews and in discussions and we even had a guru of the week series where we had interesting idioms or gachas so i i like the number scheme and i'm trying to emulate that so let's dig in first one printf and the family of related functions are very fast and this usually comes in the context of people trying to stay clear of io streams because they know those are slow and and have their problems and they they think the printf family of functions are the the the better alternative and when you set the bar that low yes they're better but they come with their own issues and not all as opposed to ios streams i my experience in talking with folks is that not everyone understands the problems related to printf family of functions and i have a case study here so for s printf it uses the global locale global local and it acquires a mutex lock to access it so as we already know that mutexes are bottlenecks on mac os as printf which is part of system libraries ends up spending almost all of its time inside the related mutex lock so there's a link there to a short case study on blender where they replaced s printf with lib format and they got a almost 4x speed up on mac and around 20 speed up on windows and i think it's worth reading and the the takeaway would be here that we have good replacements now we have c plus plus 20 format and 23 print and if we even if we're not there with our code base there is lib format which is easily incorporated and easily used in any code base so i do recommend to go for the safer alternatives and in general i think this opens up a broader discussion around functions that actually use locale underneath because i feel that documentation sometimes fails fails to highlight this aspect and we might not always want or consider acceptable performance implications of this so we need to be aware just recently another local issue long-standing local issue has been fixed in microsoft stl i have here just the the person that reported it and small snippet of the the guilty code code block no need to study the details that's not important but i'm trying to raise awareness is that you should really look into the functions you're using for formatting and make sure you benchmark and you consider them appropriate for your particular use case and see if your library standard library implementation or your system libraries that deliver those functions actually do the right thing and they don't exhibit performance issues moving on on tooling i think our species are always depending on tools and we've been on a constant thousands of years pursuit of building better and better tools for each of our use cases and this applies to our younger discipline of building software programs so we're always in the search for better tools we always complain that our current tools are not good enough for what we need them to do and i care a lot about this and one of the things we keep hearing is that c plus plus is not easily toolable we like to compare ourselves with other programming communities and reference their magical tool chains and their refactoring capabilities and their all-powerful build systems their package managers and so on and i i care about this because i've spent almost in all my 20-year career building tools building developer tools guys i spent a lot of time building some of these tools and i recently joined microsoft to actually help improve the tools i've been using all this time that's because i care about the how we we use our tools and about the developer workflows and how to ease them just recently i wanted to highlight one of jason's c plus plus weekly videos and i very much liked the the take away there that we are in a golden age of c plus tools and i just wanted to capture some of the the things json listed there it's it's not a comprehensive list but i think it's a good starter list and i'm sure not everyone is well aware of all everything in that list i put links there so it's easily to you don't have to sequence to see the small text there so the problem with the the tooling ecosystem in c plus plus is that there are too many tools we don't have a one true build system we don't have one true package manager or we don't have the reference compiler or the reference library we have many implementations we have testing tools profilers debuggers and we have for pretty much any workflow you can imagine we have a few alternatives and some of them are known some of them are not well known and i think this is where we we should do a better job of advertising this diversity and getting to know the tools and be more experimental in our approach be willing to try a new a new tool that we haven't heard about maybe i'm hearing of dr memory for the first time let's see what that's about let's see if that tool is better than what i'm using let's see if it can help in my project and in my team so we should be more more experimental more willing to try new things and learn about this set of tools so the problem for c plus plus is not not the lack of tools is i think it's the problem is that we have too many of them and we need to get better at learning how to use them and no matter if we're talking about a static analyzer or or sanitizers or refactoring tools or build systems whatever the tool might be the the what we need to do is try out to see what fits for our projects and our needs and what's most ergonomic for our workflows and get to really know how to master that tool i think that's important i say i i think the problem is some tools are have maybe a difficult learning curve so we need to invest a bit more time to get to understand how to use them they may lack proper documentation or examples but if we feel that we might gain insights into how our programs work or if they might help us in our daily workflows we need to invest time to learn those tools to learn all the switches to learn how they work to to discover their quirks and report bugs or to help out improve them if we can and i think the it's worth pursuing mastering the tools that we think might help us let's move to the the other one standard x is too slow for production use this is actually slightly embarrassing jason and i in when we did the live stream we spent i think around 10 minutes trying to write this piece of code yes it's embarrassing and it's on video and and the reason is that we didn't know how the api works by by heart we had to look look it up on cpp reference to see okay what do we need to pass here so and it actually is so slow to compile it it actually times out compiler explorer so if you know json he used compiler explorer to to mock things up and we had constant problems there and we it's it's i say it's slightly embarrassing that the we were not able to figure out how to use this api so for sure for at least for us it doesn't feel intuitive to use and it's a trivial example we were trying to parse something like a key value pair some sort of config files so it wasn't a complicated task at hand and it it it comes with many many gachas so for sure we had difficulties and we constantly need to check our assumptions about a particular function or constructor in the api and it was slow to compile of course it was very slow at runtime as well and even for simple examples we need to be careful about the performance gachas we need to be careful about the regex constructor about the c-match expressions we're using and where we place them in the program just make sure they're not on the hot pads and and we don't completely tank our performance for no good reason so for better or worse this is what we have in the standard but we're not forced to to use this all the time so i would urge you to consider the alternative and use any regex library that you you feel comfortable with or you have experience with i do recommend this one cadre which is very fast to compile it has a much cleaner api and and i i feel it's intuitive to use even without checking the documentation too much or the other examples it does support string view and it it builds regular expressions at compile time i put the link there and just show offense quickly who's already aware of ctre even if you're not using it okay i would say that's more than half of the room that's good news now start using it okay let's and we do have hana here in the room by the way and you can ask her questions if you want or even say thank you so moving on i talked yesterday about standard optional quite a bit but let's see it from a different perspective now i've heard this more than a couple of times and it always annoys me a bit standard optional inhibits optimizations and complicates apis and let's break it down let's let's analyze the the performance implications first again i i took a very simple example here we have a get size function that in turn calls a value retriever function get value which might yield or not an optional string based on some condition so this is the most the simplest thing that we can we can do with something that might or might not yield a value that's why we might use an optional right and if we look at this we already see if we're inspecting the the stand block order we already see that some somehow the compiler figured out the the result already so the the length that we requested is five and it somehow see so through everything so we we didn't get an explicit call to get value from as the code states in on the left and if we squint really hard we can even see the the bits of magic in in how compilers layout code and we we have our little string right there so the compiler pretty much sees through all of this we don't have any direct function calls or we don't pay any abstraction penalty by using this optional indirection here but you might say this is a it was a trivial example it was a short string in literal so if even if we go for a longer string and we force the compiler to to go to the hip and no it's no longer able to use small string optimization there we see the allocation there but again the the compiler is smart enough to to cease through all of this and figure out the the length of the string easily 23 at the button there so in situations like this i i think this is not a a complicated task for any of the compilers that we're using but there is a butt standard option comes with some performance gaches so i did a small change over there i i'm not sure if you you notice the change from the previous slide i basically hoisted the the content of the string into a standard string variable now so it's no longer previously let me go back maybe it helps so previously it was directly returned and now i hosted it in this in the standard string so superficially this seems like a harmless transformation and even even for more complicated example my we might we might fail to see when we do changes like this we might fail to see maybe if the function is more complicated and it has more return paths or we return different things from the function it's it's very easy to fall into this kind of trap and i do see this in real code so it's it's not i don't think it's in an exaggerated worry and it's a silent thing and we if we analyze the implication we immediately see that compiler has to do a bunch more work here i have a side-by-side diff but that's not important it's considerably more work and the reason is that we are now forcing the compiler to do a copy constructing of the string so because we we have a mismatch our function expects to return an optional string and we are giving it a string to return and it just works and the problem is this constructor for optional which constructs an optional object that contains the value initialize initialized as if direct initializing an object of type t from the value so this is intended by design because it eases using optionals but it comes with performance gaches in some situations so we need to be aware when we're need to be careful to match what we're returning from functions and not fall into performance traps like this one oh go in the wrong direction sorry about that and now the other part of the story standard optional complicates apis and this is where i spent a bunch of time yesterday when i talked about boxes and lifting and other functional programming idioms and the idea here is that i said optional is is like a box and we wrap a potential value with its context and we shouldn't really peek into the box and try to to check the value at each step of our processing ah if possible we should try to avoid using optional for error handling there are better ways to to do error handling including expected now by the way there's a an expected presentation at this conference i think it's the next time slot after this by ivan so when in doubt do inspiration from other apis if you're not unsure on on best practice to compose things like this if you're if you know or you're comfortable with other programming languages which have been using this for a while much longer than c plus plus do try to draw inspiration from those and the idea is to use higher level functions and try to construct processing pipelines out of optionals and chain operations together without checking at each step to see if we yielded the value or not the idea is to be goal oriented rather than involved in the mechanics of moving the the the enclosed value there i do link to an interesting an interesting mini series of articles here about some functional programming techniques and things that should feel comfortable to everyone even in c plus plus with concepts like application f and f map because we use these kinds of things even if we're not aware of them this is a not a high prerequisite material doesn't require any formal math knowledge or category theory or anything i think it's it's a very interesting intuitive series i mean it really helps with pictures nice pictures so don't try to look inside the box don't try to if else around optionals to to see if we have a value and do branching and decision and control flow based on whether you have values inside or not and don't try to extract it until it's really necessary we try to be lazy about it take it at the end of the pipelines so i did talk yesterday about boxes and lifting very briefly we need to use higher order functions to change the domain and codomain over functions from a to b to optional and optional b so we need to use techniques like fmap to do such a thing i'm not going to go into details about them now because i presented them in length yesterday and you can catch a version of that presentation from cppcon or from this conference when it comes online later so i won't go into much detail now very brief example let's say we want to transform a string representation of a number into a number and of course this might be an operation that might fail and don't worry about the details the mechanics of the the transformation using from charts there i do care about the the chain of operations that we're doing and i want to point out the the way this code is structured rather than being a highly nested series of if elves or inversion of control or any weird callbacks the idea is to strive for something that feels sequential in nature feels linear like steps in a pipeline and we see here hints of our monadic continuations for standard optionals that we got in c plus 23 and don't worry even even if you're not on on a tool chain that supports this already there are quite a few implementations out there header only implementations that you can easily adopt the one i would recommend if you need to use a third-party implementation is the one by side brand just look for tartan llama on github and you're gonna find a tl optional so look at the the and then continuation look at transform there i try to pick up something that sounds reasonable in a real world scenario don't care too much about what we do in each of the transformations it's not that important just appreciate the nature of building things like this in in a sequential fashion as opposed to having a bunch of if else in a longer function and at the very end we actually opened the box with the value function you see at the bottom there to see if our processing yielded a real number or not so i think if we learn about the good idioms in using things like optional if we we're trying to leverage the experience other programming communities already have around such concepts folks that are familiar with rust or other programming languages which have been using this for a while might appreciate this more but i do encourage everyone to steal from other communities that have more experience look at their apis look at how they build libraries using such facilities and try to see if we can do the same in c plus now moving on we have a good tradition in c plus plus over time to give really good names to to our functions think about empty size length and other good names we we come up with for our standard library standard move doesn't move standard forward doesn't forward standard remove doesn't remove and standard function is not really a function and i'm gonna pick on one that i hear often surprisingly even from folks that give presentations on stages like this so standard move does not move and i'm going to start with a simple example i have a simple echo function that takes two strings by constraph and prints them and i pass in a standard string that i construct nothing fancy here the expected results no surprises so far of course and now let's try to move the greeting inside the first argument of the echo function and this is where i hear gasps and weird expectations from folks learning c plus plus for the first time or folks that are moving from older c plus two c plus plus 11. and they're surprised by by the behavior they expect that something happens when they call the move function there and i've even seen stuff like this honest to god i've seen it in code and again nothing happens and the misconception here is that they expect that standard move actually does something every time because they've seen it does something in other contexts and what happens here is that standard move is just a fancy cast and there are plenty of code bases out there and i'm learning about more of them especially in the in in gaming in in game studios and projects that are not using stl or newer c plus plus versions they're actually roll their own they have macros for stuff like that so it's it's not a novel thing as a community we've been using stuff like this for years and standard movie is just a fancy cast and the reason this doesn't do anything is because a constraint ref just binds to that r value ref that we're building there so nothing really happens here but it we if we make a slight change and an important one and we modify the api to take strings by value and i think this is where i've actually seen folks try to do parallels with how rust borrow checker works and lifetimes but for c plus plus this really changes things and if if we run the same piece of code we see that one string got in and the other one didn't and the reason why this now behaves differently is now is because now we're actually calling the move constructor for the string because we change the api for echo function and we we are now requesting that we invoke the the move constructor for string and this is what happens on clank on gcc is the other way around and the reason is that we just have a different order of evaluating arguments there but it doesn't matter yeah this still example just moves on both arguments but the idea is to understand that the move has a meaning in a particular context move by itself is not important it me it really matters in what context are we moving in one context are we trying to cast that reference to something that is movable from so of course this one is busted and sticking to the point of function arguments and our echo api there always pass input arguments by const reference folks that have been doing c plus plus for a while this know this well it's it's one of the items in scott myers books so it's a classic and let's think about this a bit let's say we have a two constructors for a widget class that stores some kind of id inside and we have these conversion constructors for constructing widgets with some ids and this is the classic and surprising idiom of using two constructors one by r value and one by construct i think most folks that are comfortable with c plus plus 11 have this in build in how they work but i this idiom doesn't scale well i think we we're all aware of that as soon as we have more than one such fields that we need to construct from we have a combinatorical problem we just i don't think it's humane to ask for programmers to be able to write this without doing mistakes but sometimes we have to and there's a new pattern that we can use relatively new where in situations where we intend to take ownership of those of those variables and we use the the so-called sync pattern where we actually take them by value mind you be aware that the constructor takes them by value now and it just sinks them in to the fields of the widget structure just takes ownership of them this is what is known as the the sync pattern in case you want to give it a name same thing applies for setters so feel comfortable if you see something like this don't panic in code reviews don't run away try to understand and again we take ownership of that new thing again folks coming from or folks that have some experience with rust and battle checker and lifetimes i think appreciate this more let's try to analyze it a bit in detail to to understand what happens here i'm calling the setter function giving it the string literal directly and what we have we have to create the string excuse me with a string literal value and then we do a move assignment into the data member as instructed by the code if we host the the string literal into a standard string variable sorry about that slight difference we have to create the string with a string literal value we have to make a copy of the string now as instructed by the api signature and then we do a move assignment into the data number so slight difference if we do a standard move there then we create the string with a little value we move construct the string and we do a move assignment into the data member now if we have the the classic full-on overload set of of setters for a name one by construf and one by r value ref then in our example there where we have the standard string in a hosted variable we create the string with a literal value and then we make a copy of the string and that's it and we fall on the onto the the first overload of set member a set name so technically this is more efficient because we have one less move operation than the case where we use the sync pattern so in in some situations the sync pattern forces one extra move and if move is expensive for your type let's say maybe you're implementing something that has an internal buffer in terms something like small size optimization kind of thing and move might be something that costs something then the scene pattern is not the optimal way even though it's more ergonomic but you have to measure and sometimes you do care about for example if you're doing repeated operations and you're trying to reuse a variable you do care about the capacity the allocated capacity so this is affected by using things like the sync pattern and sometimes you you want to just take the value without resetting the capacity you already have the memory you already have allocated when you're you're trying to do this in a repeated kind of fashion let's say a for loop so the sync pattern i'm not claiming it's universally superior i'm just claiming it's more ergonomic and you shouldn't be afraid of using it or when you're seeing it in code reviews there's even a one i just want to raise awareness about this there is even a client tidy modernizer check to perform this transformation automatically and at scale so it works very well i i've actually used it in in large projects and it's one of the checks that are high quality in terms of getting it right not all quantity checks are perfect so you can play with it if you if you want to see effects in your code base you can run it just just as an experiment just run it through a project it's it takes a couple of seconds minutes depending on the size of the project and just examine the diff and be amazed and maybe run some benchmarks that i hear that helps too and if we're on the topic of c plus plus move semantics we we like to we're almost proud of how complicated things are and some of us make a good living out of explaining it but i think here the even even if i when i learned rust i struggled constantly i was in a constant battle with the compiler and the borrowed checker because i i just didn't get it coming from c plus plus but i think it's a it's the superior way to go here rather than than reading books or hearing presentations like this one just have having this baked in the compiler and not letting you shoot yourself in the foot i think it's it brings an immense value to the table and there are efforts in c plus for this as well there are efforts at this moment to bring lifetime annotations to c plus plus to have hints in the code somewhat similar to lifetime annotations in rust to to help us catch these kind of things whether they're lifetime issues or performance gotchas to help us sketch them while we compile there's a big effort at google around this thing and in in the clan community in general so it's not everything is not all about successor languages another myth is about const we hear that we should like const and use it everywhere we hear that you should use const expert everywhere and i just want to quickly raise awareness that in c plus plus const can come with some costs with some performance gachas so const all the things is not always the right idea we have to think about some of the identity patterns and again i have to point to json here and highlight just a few situations where costing things will actually hurt you in terms of performance don't cost non-reference return types don't cost local values that will need to take advantage of move on return implicitly by the compiler and be aware here that this might be even more complicated if you have multiple things you're returning from a function so if your function is something simple it might be obvious if you're building something more complicated and you're returning different kinds of things you might miss it duncan's non-trivial value parameters that you might need to return from the function you have a parameter and you you're you are going to return turn it think the trivial example is like an identity function something like that don't cost any member data and the the theme here is that being eagerly enthusiastic to to use const everywhere will actually inhibit move on return in in many situations so it will hurt the performance because it will inhibit compiler optimizations so you need to be aware to stay away from from these these patterns and if we're talking about const member data i think most of the time it just doesn't make any sense it breaks simplicity and explicit moves it breaks common you see cases for assignment and your this is not the way to achieve immutable data structures let me tell you so don't cost all the things think about it first should be a good first thought but think about the consequence in some situations moving on to another one may call data members private this is typically seen as a good practice in object-oriented programming enforces encapsulation all the good things object is in control of its internal state but we need to think about what invariance we need to preserve for that type not all types do have events to enforce we need to document those invariants and assumptions and we need to construct apis so that they're easy to use and we offer the the right contract for for those apis so if the things we're building don't need to enforce and maintain some invariance or ensure a particular contract with the caller don't just wrap everything in getters and setters like inertia like java like a java reflex think about the complexity you're adding and i'm not talking just about boilerplate and functions that you need to sprinkle around don't add com necessary complexity just because you might need it in the future i might need to control how this setter works or how this getters synthesizes a property or something if you don't need it now don't do it because aside from writing simpler types that are simpler to use and simpler to document and simpler to refactor you and yeah also constructors don't don't just add constructors for your types if you don't use them you might just need some braces there so don't add constructors if they don't do actual work in constructing or helping constructor you're constructing your types and the idea here is that you're you're paying technical debt in advance your your building stuff something more complex than it needs to be without having a reason to do it if there's a good reason do it otherwise don't do it just because of inertia or just because of everything needs to be an object and everything needs to be encapsulated reflexes that we've been taught into sometimes trucks just want to be strucked you know i do recommend this presentation by kate gregory abstraction patterns i think she she presents some very very good arguments in this regard in how we build abstractions in general in programs the presentation is is already online i put the link there i highly recommend that you see it and yeah sometimes stocks just want to be strucked and if we're on the subject of structs i have to recommend mike acton stock if you haven't seen it already i think you should i mean like drop everything just go away now and see it it's well worth it it's still unpopular opinion in three plus plus commit community but i i'm sticking to it and i i think it's it was one of the best c plus plus keynotes ever although i still remember the audience gasps and they they knew who who were the who were in the inviting at the conference to keynote but i i don't think they expected the results but it's a it's a it's one of those stocks that makes you think and i think that's the point of a keynote not to show you something fancy something new but to change to shock you to change you how change your mindset to reframe your context to make you think about what you're doing so it's all about data transformations and software is about transforming data and performance is all about smart data layout and thinking about memory access patterns for particular workflows and how you organize your data around those memory access patterns and squeezing every bit of performance and about the the vector of structs or structs of vectors so how you explode your your fields out of your op mindset and just consider an index in some parallel arrays as your entity or traversing so i think it's a it's a well provocative story there and if you want to practical and more recent take on that andrew kelly the the inventor and lead developer on the zig programming language and compiler actually had a very interesting talk a practical guide to applying data oriented design in and he very much channels mike acton he even has the hawaiian shirt there and it's a it's a it's a story of using and adopting this mindset this style of programming and rewriting the the z compiler in such a way and gaining tremendous performance another myth iterators must go when i i first did this talk i tried to do a romanian accent and imitate andre but it fell flat but because nobody knows i'm romanian too so there's a famous this iterators must go was a famous presentation that he did in 2009 and i recently was able to discover a recording of this and i put it there really recommended and highly influential presentation for our community so influential that stepanov was pissed off by this presentation and said that alexandescu is on a crusade to eliminate iterators and he had a very long rant about this in his programming conversations lectures at amazon before he retired so and this series of presentations is very high quality i do recommend well somebody did properly destroy not stepanov but after more than 12 years and this was very revision and i do consider this there are a few flavors of this presentation but i think this one is the the the most exhaustive one from cpp21 iterators and ranges and very compares how iterators and ranges work in different programming languages with advantages and disadvantages and very very compelling examples so i highly recommend watching this presentation after you watch andres so yeah iterators must go plausible we do have ranges but we still need iterators in my opinion just watch various presentation he goes in plenty of detail there and i'm going to close up with missed zero there all right the foundational myth for c plus plus as i consider it is that new c plus plus new things that come up in our language are usually considered the enemy of the old and i love this quote by pablo halpern before before we had feature x we were not unless able to program c plus plus so why do we need it so we we constantly have to evaluate how we how we develop c plus plus how we learn about new features and gain experience with them and not everything new is necessarily good or universally applicable in general there's solve existing problems but we need to gain experience with them we need to learn where they're applicable and not just blindly using them just because they're new and shiny and at the same time we don't have to be overly conservative in rejecting the new and just say okay i've been programming for 25 years like this why do i need i know optional or whatever or i have my own why do i need a standard one why is that better so we need to think about embracing the new so yeah i invite this i reiterate i invite other speakers to join on this series if they have opinions or fresh stakes i'd recommend another one that i consider a sibling talk some programming misrevisited by patrice raw i very much enjoyed this one i was in the audience at the time this was an inspiration for me totally different things different topics even more challenging for the community very controversial stuff highly recommended and it's a lovely presentation watch out your sound level patrice tends to be loud and in future episodes some of the topics i do plan to to cover not binding contract but i do plan to visit some of this stuff and even draw some parallels to a famous successor languages there so thank you and i hope to have a nice chat with you folks on these topics i think mostly offline okay [applause]