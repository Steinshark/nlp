hi everyone in this episode we're going to be getting our pathfinding code to run on a separate thread so the pm never freezes up when we're searching for a pass we'll start in the past request manager script in here i'll start by deleting all of the stuff that were no longer going to need so the current pass request and the past request queue as well as is processing path and the entire try process next method then the bodies of request paths and finished processing paths we're going to be completely changed so let's delete all of that in there and now the request path method instead of taking in all of these different parameters we're simplifier to just take in a single pass request struct called our request now if a unit wants to request a pass truthful have to create a pass request so we'll need to move the struct outside of the class so that it can be accessed from elsewhere so it saves that and go into the unit script and now when we request a pass we can say new path request and pass them all of the stuff and we need to do that again over here you pass requests and pass in all of that all right let's save and go back to the path request manager so in here we'll want to start a new thread so up at the top let's add using a system dot threading so that we can create a thread start variable in the school thread start and set this equal to delegate open curly brackets and in here we need to put the method that we want to call on the new thread that will be instance pathfinding dot find path currently find path is a private co-routine in the pathfinding class but we'll change that in just a bit this will take in a request and it will also take in a callback for the finished process path method so let's pass that in now all right add a semicolon here and then we can start the thread by saying thread start dot invoke all right now when the finished processing pass method is called we'll want to return the result - whoever requested the pass so we're going to need this callback in order to do that so as an additional parameter here let's take in pass request original request alright so now we can access the callback but what we must be careful of is since the defined path method is running on a separate thread and it calls the finished processing pass method from that thread that means that this method will be running on the separate thread as well and if we simply say something like original request callback and pass in the pass and the successful now suddenly our units on path found method will be running on that separate thread as well and that will cause all sorts of problems so we need to get back onto the main thread before we make this call back so what we can do is add all of this relevant information that it's the callback the path and be successful to a queue will define up at the top of the class and then inside of the update method which of course is running on the main thread we can then get that stuff out of the queue and use it to make the callback now in order to do this we'll need to be able to store this information inside of a single variable so let's create a struct which i'll call pass result and this will have a public vector free array for the past public boo for the success and finally the then call back from the past requests yeah all right we don't want to make a constructor so this command i and select these three members is going to be initialized and then other the top here let's create our q so q of type pass result i'll just call this results equal to a new q of pass results and then in here we can say pass result result is equal to a new password oaks with past success and original request callback we then want to add the result to a queue so we say results dot n queue and we add our item so that's the result now also have to be careful of is if multiple threads are running this method simultaneously and at the same time they all try to include the result then we can get some strange behavior so to avoid this where we first want to lock the results queue so that only one thread can access it at a time we say lock results and then open and close curly brackets all right now let's create our update method for it update and india will say if there are items in the results queue so if the count is greater than zero then we'll say items in q is equal to results dot count and then we can lock the queue lock results and i will say for at r equals zero i less than items in queue i plus plus will get pass result result is equal to results dot dq and then we say result callback and we pass in result dot pass and result dot success as the two arguments alright so now that we have this plus result struct it magically cleaner if our finished purchasing path method doesn't take in all these different parameters but rather just a single pass result variable called the result so we no longer need to create that here because that will now be created inside of c pathfinding class so we will need to make the pass result structure accessible to the pathfinding class so let's just cut that and paste it outside of the paths request manager class while we're here we should make both a struct public so public struck bus result and public structure parts request we can then save this and head over to the path finding script and injuring to delete the start flying path method because we're going to be calling find path directly so this is no longer going to be a coercion it's just going to be a public void and its parameters have changed so instead we take in a path request collect a request and tota takes in a callback so action and the one parameter is the path result can call the scroll back now to get our start position and target position we just use request path start and request dot path end so i'm coming down to the bottom here we've course no longer want a yield return null because this is not a collision anymore and instead of calling finished processing path directly we use our callback and we pass in a new path result with our parameters being the waypoints the success pool and our request dot callback okay so since we're now using this callback we can get rid of our reference to the pass request manager up here as well as the yet component call in the awake method and then let's save that and go into unity looks like we have an error an object reference is required to access non-static member finished processing path so in this static method as passed in this non-static member as it refers to it to go to add instance dot and then that should work fine all right let's run this to make sure that the path finding still works and let's quickly try it with multiple seeker objects just to make sure that nothing strange happens all right that all seems to be working correctly now one thing that was pointed out last video is that if i take this target object and move it a very small amount can sometimes get this index out of range exception and what's happening here is that when we call retrace path we're getting a waypoint away back that has nothing in it so what we'll say here is that path success equals waypoint dot length greater than zero so if there are zero elements in the waypoint theory then path success will be set to false you can save that now and that problem should be gone so that is everything for this episode until next time cheers