>> sean: we've looked at chomsky and we've looked at finite 
state automata, and you've given me a sneak preview about what might be next, and my first thought was "what do all these notation marks mean, and where do they come from?" >> dfb: chomsky instinctively went for a notation that appeals to mathematical logicians or theoretical computer scientists 
nowadays -- very tight, very compact. what he would basically say about a programming 
language identifier, which we're trying to define, is that everything in chomsky's
world is a sentence. we've covered this already in the car park: "a legal sentence in this language is five-five-five-five-five." so everything's an 's' in chomsky notation. what he would say about the identifiers problem ..., 
in sensible languages, we've got to start off with a letter. i'll call that l. and then, the tail piece of the identifier. well, it could be nothing at all because a single letter is an
identifier in pretty well every language. but the tailpiece could be more letters, more digits, in any
combination. fine. now, round about the time late '50s turning into 1960, there
was a whole bunch of them defining the language algol, which was the first language to
be designed by a committee and ran into all the usual committee problems, but when you
think back to that era, fortran was there, cobol was there, they never, until later
on, had a formal definition. the algol people said we are going to use something like
chomsky notation to define what's a legal program. john backus and peter naur, who were on the algol 60
defining committee -- backus was famous as one of the big inventors of fortran; peter naur, a very famous european computer scientist -- they said we need something that is more self-explanatory. and they invented a notation that looks like this:
pointy brackets! yes, this early on! and we are going to say, an identifier - not a
sentence, it's an identifier we're trying to define. and rather than using chomsky's arrow, which they felt might
occur in the middle of a program and cause confusion, they wanted a "is defined as" operation here which wouldn't
ever occur inside a program. but they wanted it to be clear it was part of the definition. and they said, "easy, we're not going to call it l, we're going
to say ". and you see the advantage straight away: that you can then
say, ahh!, it's a letter followed by a tailpiece, which we'll call . by putting things in the pointy brackets, we're saying:
we don't literally mean that you must look for the characters l-e-t-t-e-r on your input, no, we mean
"anything that can be a legal letter". so further down here there'd be another definition saying a 
letter is an 'a', a 'b', a 'c' (...) all the way up to 'z', and all that. the tailpiece is far more complicated because it's any mix of
further letters or further digits, but there could be a definition for digits. but the point is, they're readable things here, they're readable
notions as they're sometimes called. and they are pretty well self-explanatory, far more appealing
to be setting out a definition of a programming language, than you forever having to remember, "oh, a letter capital
'd', is that a digit or is it a denominator?" you know. of course the theoreticians say, "oh, it's far too verbose, but
yes, i expect i do understand. you've got to make it clear to people who have got no brain,
exactly what's going on." so this was very popular for defining languages. >> sean: so this is a bit like having a how-to guide, is it? like
saying "this is not programming; this is how the programming works." yeah, exactly, it's a blueprint for legal programs -- all of them
-- they've got to fit into this template basically; that's what the formal definition did. and the interesting thing, as many of you are yelling at me now
is, "this is xml, isn't it?" it is the forerunner of xml. xml, as some of you know,
started of with a thing called sgml, which was its earlier form, but it was refined into being xml. and right back from the early sgml days, somebody saw
backus-naur form notation and said "that is going to be fantastically useful for what we
want to do." the characteristic of this [bnf] stuff is that you never ever
see it in the actual language itself, and we can see advantages in actually making these appear
in documents. now, we all know this, don't we?! we all accidentally see a listing of
our web pages that went wrong and you see things like . so this is xml, be clear. you see things like . >> sean: and actually, if anyone right-clicks on the youtube webpage
and selects 'view source', they're going to see all this (...) 
>> dfb: yes, they're going to see this, all of that. but what the xml people realized was that so long as you
introduce the "end-of" slash -- just elaborate the notation a bit -- you really could use it in
an actual document. say: "the paragraph starts here" and "the paragraph ends here". the break-line here, it starts and finishes, it's just a marker,
and most browsers are tolerant if you miss the slash out, but, you know, theoretically that should be there. so, they gave it some new lease of life, really, by saying, well,
we're not going to just keep it in the abstract, we're actually going to use it, within documents, to clearly delineate
where things start and where things finish.