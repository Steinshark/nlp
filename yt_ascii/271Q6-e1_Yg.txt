everyone please warm up your monads it's time hasc is very competitive with c and on some benchmarks it is faster how is that possible with all that hcll does on top of the raw c code how can it possibly be faster in this episode i talk about two advantages of hasal that can make it faster than c so typically this is what i say when it comes to this type of stuff which is when someone says x is faster than c what they're actually saying is that i didn't write c that good but i'm really good at writing this one piece of code and so therefore c is slower than hull or x is faster than c because i can't write good c that's what it means okay it's like literally it is it's literally the original skill issue but i'm willing to hear it out i'm just saying this is skill issue number one this is your classic skill issue how is hasell faster than c my name is eric normand and i help people thrive with functional programming so usually languages are compared to c right it's kind of like the standard benchmark language to say like oh this language is only a factor of two slower than c right most languages are slower than c by the way every time you see someone do a comparison of languages in c you know what they do almost 100% of the time they always do the worst version of it right like you'll see like javascript is only 1.5 times slower than c and it's always doing a bunch of math equations and you're just like dude the reality is that your web server everything you do is in a bunch of math equations is it surprising that javascript can compete on a small function with c yeah it's not that surprising because it eventually gets jit it gets turned into just like as as best representation as the engine can make to run this one small function over and over again is there anything impressive about that no it's not right because you're because that's not what happens what really happens is that you have a piece you have an object that you build you go and do an await you go and get more information you add stuff to the object you go and do another await you come back you push some stuff into arrays then you take that crazy object and arrays and you turn it into a string meanwhile every single response that comes back not only do you parse its json you also send it to zod to be validated in which zod is not fast it then goes through and compares the structure and zod to ensure that it actually is a correct object and validates at runtime that its type is the type expected to be and so of course that's where all the slowness comes from it does not come from a couple math equations it comes from all the other stuff because now that you've held on to an object over two separate awaits you've held on to the object long enough that maybe it got promoted from the nursery cach to the intergenerational cash and maybe it goes from the intergenerational one to the long-term one you don't even know how long you held on to that object and the next thing you know now you have major gc's all over the place causing large slowdowns maybe you're running on a multi-core machine but maybe you're not running on a multi-core machine the difference in performance on a non- multicore machine versus a multi-core machine is huge in javascript because all the garbage collection optimizations rely on multiple threads and when you don't have that it just gets completely destroyed in performance and so whenever i hear these things that's what i think of right is here is an unrealistic case in which we can perform nearest the same speed and when especially when you get into like the more higher level languages you have this idea of like well we lost a lot of speed but you don't have to deal with all these problems that c has like you know you don't have memory leaks because we have a garbage collector you don't have to deal with like when to when to free the memory garbage collector supremacy is a real thing the fact that you don't like there's there seems to be nothing more exciting than garbage collector plus arenas right you get to control a small amount of memory in a very fixed way or it's just garbage collection like to me that is like practically the perfect level of of memory management because for the most part you don't care about most memory but there are some memories in which you want to care about and to me that is like that's that's that's a real thing you want to because then you can make the parts that you need fast fast and the parts you don't care about you don't solve by cloning which ain't fast and you know just all these niceties add up but it's at the cost of speed but then you have something like haskal that is often faster than c in hat mentioned and it's faster than c let's go it's the ultimate language the benchmarks it's very close to see when it's not faster and it's not like oh it's twice as slow no it's like right there it's like within a few percentage of c and very often it's on the other side it's faster than c i'm doubting so hard right now because the only way i can possibly think hasell is faster than c is if somehow they figured out how to do things in less machine instructions right that their compilation is actually just genuinely better comp i i first off i don't even know if is hasell a compiled or is it is is there a runtime i thought there was a runtime which means it's not even compiled which makes it even more conf confusing but if it is compiled okay so it's compiled therefore it uses llvm so is it getting like somehow better better it's either or well damn that's confusing so what's going on okay let's see it okay so there's actually two things at least these are the two things i know of that are going on the first is optimization hasal has a lot of knowledge so the haso compiler is given a lot of knowledge about the program in the form of types usually and those types are algebraic types can with an expressive type system prevent all sorts of issues at peer functional programming this is the function about to happen than what the types in c are not only is it the types but it's also there's a lot of the semantics of has about to make a argument here comes give the compiler a lot of leeway let's call it a lot of wiggle room for optimization one of those is again by the way all of the optimizations he's about to mention should be doable in c okay i'm just going to throw this out there i'm just going to throw it out there that anything that you do should be doable also and see i i have a very i i'm having a i'm having a big doubt coming on right now evaluation so in c it's strict evaluation you put a function there you know it kind of executes one line at a time you know is how you should think of c executing so it's going to call this line everything on this line is going to finish before we get to the next line right yeah but in high school that's not the case what you can have you can call something give it a name and it doesn't actually do anything yet right and so the compiler can actually analyze it and a lot of times figure out hey you never use this in this branch right so i'm not going to do it yet until i know that you're in this branch and then i'll i'll do it or it might it might never do it like the analysis gets so complex it might just remember how to do it and in case you need it it'll be there but it won't do it so there's a lot of stuff that you could in theory hand tune if you were a a very very good at optimizing as a programmer you could hand tune and say oh there's a certain case where i won't need this value so i'm just not going to calculate until i really really need it but it in in practice that gets so hard it gets so complicated is that a skill issue did did he literally just claim skill issue i mean i'm not going to say like again garbage collectors often can lead you to more like better code than you doing it in rust and it's a skill issue it's fully a skill issue the thing is in in rust you'll like i've se i've made rust programs slower than go programs because i'm not great at rust like i i wasn't the best person ever on it because i was trying to i was still in the learning rust phase right and so i was not able to write a server as fast as i could write it and go just simply because some level of garbage collection prevents all cloning whereas you find yourself making clones and doing things in a different way in rust because you're not good at it so there is like most certainly i do not doubt cloning or skill issues play a big role in how fast you write your code that you're just not going to do it right and so hll can do that haskell just does it in the program doesn't have to think about it right so you can do some analysis you can figure out when something should be is going to be needed anyway might as well just calculate it now you can do some analysis and say oh it's only needed sometimes so i'm probably won't do it yet and and then sometimes it just punts and just says well i don't know how to analyze this but the net effect is that that is faster another thing is it can do a lot of because because everything is pure it can do a lot more optimizations of like moving code around and inlining and doing more stuff at compile time that can't be done in c and those is that statement true it's all llvm but is that i mean i could understand that if you know everything as peer there's some things you could do that would be different right like i i do get that that that that there has to be some level of optimization that you can do there but also if everything is pe it also means you're creating a bunch of new objects you have to forever create new things that unless if it's i know i'd love to see some examples unless if like that's so that's like where i'm struggling with with is there has if you're making something like that there has to be coping or some other thing going on which is just notoriously slower than you know mutating memory could be the optim way okay maybe maybe show us yeah i want to see the video let's see let's hear here let's see if he does it in the video are typically thought of as like inlining people optimization that kind of stuff but hull can has a broader range of maneuvers that it can do that let the code get optimized really well and that's nice so what i what what i hear from him what i'm hearing here is that if you are an average hcll developer or an average c developer it's easier to write better code in hll than it is to write it in c which i wouldn't ne necessarily argue that okay that's a fine argument to make that you can say that it's easier to write like again when i first started learning rust it was easier to write a go program faster than it was to write a rust program because i kept finding myself cloning and doing silly things so fair totally fair but you can't say that in an absolute sense meaning that anybody writing c can or writing hll will ne ne necessarily be faster than writing c so it's kind of like you're getting the benefits of the high level like you can code how how how it should be read right i'm coding for another programmer i'm just making it very readable but then the compiler can kind of transform it into something that's better to be executed on the machine okay that's number one that's optimization but number two is potentially even bigger and that is that oh gosh hasal lets you use better data and algorithms and i need to explain because okay yes they're both through in complete okay so let's take that argument i agree but let's take it off the table no one made that argument ran kril though that does sound like an argument hkers would make well are they okay they are touring complete okay just making sure actually made this argument and that's where i got the idea for this episode from he was talking about rust but it applies equally to hll so he has been doing a lot of system programming in his career and a lot of it is done in c because it needs to be lowlevel and his his argument goes like this well see you know if you need a data structure it's and see it's just kind of hard to do anything more complex than a link list or you know maybe you could get a little bit more complicated but link list is kind of you know you write link list all day long because that's like it's something that you know you're not going to mess up and it oh man you just got question marks from low-level learning when you get this many question marks from llll you know he's upset when they when he says this this isn't a good representation right you're kind of straw manning the average c developer or what the average c development experience is oh since you can only do link list and c that's what you do i mean granted i've written a lot of link list and c so fair take in that sense that you do write link list and see they're very great to write it but you can also write a tree and see a linked list is a tree it's just a one-sided weighted tree right it's the worst optimization of a tree you can also write arrays you can also write dynamic arrays in c does the job and it's fine right hash well can actually because it's higher level it can actually manage much more complex data structures and do so in a correct way right so you can write it gives you tools to write data structures that are known to be more efficient for certain access patterns right and linked lists are very linear they so so every you know not every access if you access the first thing it's not it's constant but in general you're accessing things conant inside the list randomly right let's just say that's what your algorithm is and so any access so you're so you're accessing stuff randomly that's linear and so if you do that in loop wow you're quadratic already right so in hll you can replace that link list with something else like let's say a tree right so now you're act i just claimed i just made the claim that a linked list is a tree let me explain why i say a linked list is a tree all right so we got a little linked list here right a goes to b b goes to c okay are you ready for this are you ready it's it's a tree yeah yeah the conspiracy theories were correct linked lists are an effing tree yeah this is an unbalanced binary search tree on accident didn't even i know i know people people are shook right now just i'm just saying that we could totally do this hold on on the only point here is that most data structures are somewhat swappable like your implementation can be abstracted over data structures that is still copium it is still copium i agree with it but i you know i'm just letting you know like when you say something like you can replace a linked list with a tree you've effectively said nothing at all right because a linked list is a tree now if you wish to have a second link instead of having say a next you can just name it left instead of next and then you can have right for the other side so you're saying a link list is just a unary tree i mean really it's just a it's just a poor l formed binary tree if you think about it that's all it is is it's just a bad binary tree now you could say okay well technically you don't use the memory position for each one which is also a graph it's also a graph this one would be an ayylic directed graph commonly referred to as a dag okay i have a meeting at 1300 but i want to see how this ends okay i'll keep on going i'm gonna keep on going i'm sorry i'm just i just need to get that out there just because it's it's very important for people to understand that that point access is logarithmic you've already saved a bunch of time in terms of complexity time complexity and so that is another way that haskell benefits overse that by the way i do want to make one quick thing by using a tree or a linked list you could be inefficient as compared to using something like a array so if you had some values that could be stored on on the stack and you had and you had a nice like array a contiguous memory spot even though you have to search in a linear time it can be faster than o of one access such as a set because a you're not jumping around to crazy memory spots but b you're doing this really close locality of memory searches whereas it's very hard to do that with something like like a tree you can't i mean you could you could a heap is an array if you think about it so could you model something like that yeah you could you could you could heap it hard and say the same thing but again now you're just like the argument is completely lost here which is choosing like of course course doing a quadratic search over a large set of items is always going to be slower than a logarithmic search over a large set of items right when i say large i mean n has to be sufficiently sized if the problem is complicated enough where or big enough where really you should the difference between in access complexity in big o notation complexity between a link list and a and a tree boom it's it's a big enough difference h's going to win but just make it a tree and see that's not an argument just make it a tree and see and it's simply a matter of how i do see what he's saying though is that it's very simple to have this tree in hasal so if you program it like a 1d grug head then yes it's easier to do that but this is kind of like it's it's too much of a straw man for me to accept much complexity can you handle now of course if someone wrote a tree in c and you imported that library and you you know included it in your c code you would start competing again with haskell right you could do that sure but do you do that is that a possibility in these benchmarks it might not be a possibility whereas in hasell you could do that you could write it yourself and i find that this is the case a lot of times in higher level languages you know it's a okay i got to say it one more time a link list is a tree if you can write a linked list you could write a tree the end right c is very low level java's higher level than but then scala is higher level than java closure is higher level than java so it's a spectrum and what happens is as you tackle these benchmarks sure c's going to win because it's very small problems right it's like you know calculating something with a known algorithm right so like people have been optimizing the c algorithm for that years so they know exactly how to make it fastest but when you're dealing with more real world problems bigger problems very often you do need garbage collection and higher a better concept of of data type and data structure than c will give you and so that's what happens so just so if he's saying you can only rely on what's built into c then yeah i could understand that because you pretty much just have a raise i get that tree issue yeah it's not a skill issue it's a tree issue like i mean i understand the argument that hcll gives you more out of the box and thus you can solve a lot of things in a more efficient way just off the rip agreed i think we can all agree with that if that's the argument he's making then i think i get that argument right like just like with c++ how easy is it to make a vector it's very very simple the stl is is very very good right and so yeah does that mean c++ is faster than c no is it easier to get off the ground than c sure right can you do the same thing in rust absolutely is it easier to get off the ground in rust than c++ well you have to dye your hair blue first but you get the idea it can be easier and so it's like is that is that like are those fair comparisons i wouldn't say they're fair comparisons and it's not just about data structor there's other facilities of the language just as a little anecdote i heard a story once where there was a competition to see who could write the fastest program and it was c versus java and it surprised everyone especially the c programmers but the java implementation won and it won by a lot and the c people are like no it's not possible it's you know how could this big monstrous vm beat our highly tuned tiny little c program and they started reading the java code and you know you can imagine them like huddled there with their print outs like ah then they all like no look they cheated and what they were pointing at was in java they had used threads they used multiple threads to solve the problem whereas in c they didn't okay c11 has the new thread api the one before it has p threads can you not use just threads right like what is this this doesn't sound fair if you have a if you have a problem that could be massively parallelized easily then of course it's faster than not parallelizing it and they considered that cheating well yeah if you were okay that's fair if you were told which program is faster at doing x and you assume that you can't use threads that is totally fair take go oh that's cheating we didn't think you could do that of course we could make this faster you want us to use threads as well p threads came out and who knows what but it was c11 right c11 has the new thread api right which apparently is really nice c11 thread thread threads right there's like a it's it's this new yeah you get you get all these like you get this new nice operations for very beautiful nice thread stuff that makes things a little bit easier to use which seems really really nice i have never i haven't used i i haven't built a lot of things in in c the last time i built something in c was a video driver last year and the time before that was a twitch irc bot was it in c that was fun i liked the twitch irc bot i want to do that again i want to do that again but let's keep on going so see you can see the you can see the the problem here right like you can see why they consider it cheating because they're used to benchmarks where it's just one thread purely sequential code and it is really hard to write threads in c compared to java and in java it's very easy to write threads is that true i i'd say in some senses probably true is it you don't think so i mean i think there's some things that are easier in java to write threads for right like just like in rust it's really easy to write a thread in rust right and to do stuff and not die in some weird way but beyond that like if you're vaguely familiar with the p threads library i feel like you should be able to easily do this fearless concurrency i know it's not really a fair comparison of course things are easier in java in the sense that you you spawn a thread right and you just have way less things you have to be concerned with because you have so much help from the garbage collection and all that but at the end of the day is it that much easier the hard part isn't in spawning of threads the hard part is not effing your yourself and creating mutexes or atomics that you have to constantly rely on to be able to do anything the hardest part is the paralyzation which is equally hard in any language i don't know about this i'm actually curi i'm most curious on low-level learnings one p thread create my thread boom let's go right i to me the paralyzation not the thread yeah threading seems easy it's the communication between threads that is hard do you have a non-locking cue that i can add stuff to are we using semop are we using mutases what are we using to control all the stuff right that's one thing i've been wanting to play more around with in rust is i always use a semaphore and a series of clients to send stuff out why not spawn hardware threads and use and use non-blocking cues to divvy up the work and try that out to me that sounds actually like a more fun experience to do well i'd like to try that yeah go weight groups another exact same version yeah spawning spawning threadlike material in go is the e easiest i just go like this go funk go funk yourself so does that mean go is superior to c well i mean i would argue no and to start new and so you know yes what you do it is what do you do who won well i say the java people won because that's the whole point of java is it makes those kinds of things easy it makes threads on you know crossplatform really easy it makes garbage collection crossplatform really easy and i think that the same thing is true of hll you know if it makes writing a data structure that gives you an advantage over a link list let's say easy and so that's what you get that's what that's why it's faster all right if you have some ideas about why hll is faster about these high level languages how they could be faster than a low-level language where you get to control everything and highly tune the you know the code down to individual instructions if that's the kind of thing you like doing how is that even possible do you agree with me disagree i'd love to know you can go to lc.com podcast you can find ways to contact me email twitter linkedin you can also find all the past episodes they have audio video and transcripts text transcripts i i find his comparison completely unfair the first part i found actually to be the most compelling right the the first part was the most compelling meaning that it is very easy that there's a lot of really great optimizations that can be done with say pure functions and stuff that just makes it really easy to do the right thing to me that seems like that seems like a valid answer right okay you're right maybe it's easier to do the right thing in the 80% case true but to claim that it's faster is just silly i can talk about part two if you want but it's too hard to do in chat neovim runs into that problem what do you mean part two can you talk about part two oh writing your own data structures in neo in c i mean the hard part yeah is part two argument writing the right data structure i mean the hard part about it is just c right you there's it's very you can't you don't really have generics you can't make a a i mean i've seen someone do it with macros which is disgusting but you can build a tree dedicated to a singular data type you know i i i mean i understand that it's it's harder in c right i've written enough c to know that it's harder and c to do things like being hard and c it's not just about generics it's probably about the code and reuse yeah yeah yeah exactly no i'm on your team i mean generics is what makes these a lot of these things more reusable but he's not saying it right there i know i'm on your team i'm fully on your team i i know i know the the general problems of c someone who i've written enough c to know that i'm bad at c right i i've written enough c to know that i would probably write rust faster generally just because i could write it faster and i could probably be more correct faster in general c has generics really you going to toss like a void star at me next that's the generic no npm andc literally unusable fair fair void star d nuts anyway it's not just about a code you write it's also about getting a code from other people and being able to replace parts of your stack yep no all that's completely fair c makes it harder for sure 100% i am 100% the the thing is is it's not so the phrase how is hasal faster than c is just wrong what it is is hasal has better development experience than c would be the better thing to do would be the better thing to say because absolutely anything you can write in hll you can write in c right all right it's easier idiomatic hascal is faster than c you can't say that either you can't say that because i don't know if that's true right you have to show me the pro i mean you can't say that you can't say that idiomatic hascal is faster than c pig c that's copium that is copium idiomatic hascal is faster than c is copium dude these the the comments on this video on youtube are going to literally just be filled with either hasal lovers and telling me i'm wrong or people going what the hell's happened here yeah it's not just compared to dick measuring in benchmarks then it would quite valid take this is fair how is has fast than c once again yeah i know i know you're playing the devil advocate i'm on i i understand what you're saying i just don't think it's a good i just generally don't like those kind of arguments again as i made the argument earlier today which we'll pull up here comparing speed not difficulty see wins and speed yeah that's fair if you're saying it's easier to write stuff in hll i'm probably on your team honestly right look at this i even tweeted this out this morning if you do an x is faster than c article it only means one thing you're not writing c right right like this is 100% i even pregamed this article with a tweet cuz i knew for a fact this is what was going to happen at the end of the article which was literally skill issue at the end how did i miss i i know it is charo chot chot it's always that it's always that pre-at pre-at yeah plus typically that's not the question we want to ask okay so what's the more interesting question i think to ask which is how easy is it to write fast code to me that's the more interesting one and so something like rust makes a more compelling argument or something like go go is the 99% case it's still really fast but it's really easy to write and so to me that's like the what's it called that's the better argument to make which is how do you generally write fast code use a language that generally produces fast code now is it going to be the fastest no it will not be the fastest but will it be fast enough that's what you have to ask yourself right odin might win that odin could win that odin odin's a very interesting language that i wish i had more time to play with i just wish i had more time but o camel is my next one right javascript allows you to write really fast in the beginning and then you hit what i call like the c of complexity where as you start writing you start hitting these things where things start falling apart in weird ways i think this generally is what he wanted to say except that hasal is not easy to write yes i know that's the that's that's what i'm laughing on the inside about which is hascal is historically not known to be easy to write like that's not one of the phrases you would use to describe your hascal experience which is easy to write that's just not it right like i mean even to get started in hll how much of your wardrobe do you need to replace with tie-dye t-shirts like that's another thing i don't even know if it's true right like how many do i need before i can even be remotely effective then someone's going to explain a monad to you but using a burrito and you're going to be so confusing so confused all right hey the name is i'll probably never learn hasal but i'm definitely going to learn o camen