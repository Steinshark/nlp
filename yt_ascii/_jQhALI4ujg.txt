so a link list is kind of the first serious data structure you learn about because it's very simple and it's actually got a structure when array has got a bit of structure but a link list is kind of slightly more complex we can do some more interesting things with a link list so a link list is made up of nodes each node stores an item of data so it could be a number it will be in our example because it's easy to write and it has a reference to the next node in the list if we wanted to store the numbers one two three and four in a link list it would look something like this each node stores a value and a pointer to the next node so the value is one then we have another node with two in it and the first one points at the second one and then if we want to have three we can add that where do you put the link is it in the new thing or is it no if you're adding things at the end of the list the link goes from the existing node to the new node if you're adding things at the start of the list list which you can do but you can't do it with an array because where do you put it you've got nothing you don't have access to what's before that in memory you know you're going to trample over something else and cause problems if you want to add a node at the start of the link list say you want to add zero to this list we could just create a new node somewhere doesn't matter where in memory actually is they don't need to be next to each other these arrows can just point to anywhere else in memory so if we wanted to add the node zero to the start of this list we create a new node put zero in it and then point it at this element so in l list we have two special nodes we have one called the head and one called the tail so the head is the the node at the start of the list that points to everything else the tail is the node at the end of the list that is pointed to by previous node and points to nowhere in general you with a link list you need to keep track of at least the head the tail is kind of optional you don't have to keep track of the tail necessarily so this node is going to be the head of our link list so we'll have a some reference somewhere probably you know a variable called head that points to this node so if we want to find things in the list we can go to the head and then we look at it's next pointer and this one's next pointer and this one's next pointer the last element in a link list the tail of the list you'll notice this doesn't point anywhere conceptually there needs to be some value here we can't leave it as uninitialized memory because it'll be an arbitary number it will point to somewhere who knows where in memory and if you follow that link and try and interpret it as a node you're probably going to make your program crash what we do is we we point it at at null so in c or java it's called null or it'll be the number zero like a memory address zero which is interpreted as null or in python it would be none i think it's i think it's null in most languages if our node points to to null then we know it's the last item in the list which is nice we know when we know we've we've we've gone through the whole list and found every element kind of reminds me a little bit of a sort of treasure trail where you find something and then it tells you where to go next yeah i guess it is like that so yeah i mean similarly to that you can't you can't find a middle clue without having to find the one before it so with a link list you don't have random access or constant time random access to to the elements so if you wanted to find the the last but one element in the list you need to start from the start keep counting forwards probably until you get to the last one and then oh it was on for that i mean if you want to get to the 10th element you you have to go through 10 times so in an array you can access the 10th element really easily you just say get me element 10 it multiplies the width of the variable or the width of the item by 10 and jumps that far in memory with a link list you can't do that because they're stored in arbitary places in memory you don't really know where and you can only get to them by following the links so if it's a 10th thing you've got to follow 10 links if it's thousandth thing you've got to follow a thousand links because they could be buried anywhere in however many gigabytes of ram on your computers yeah these could be anywhere in memory you could be jumping around all over the place yeah that's the the only way to get there is to follow the links sometimes we might also want to maintain a reference to the tail as well as the head so we can just point tail at this last element and this helps us if we want to add elements to the end of the link list because if we know where this node is we can stop it pointing at null and point at a new node and then point the new node at null what happens if you need to add something in the middle of the list or let's say we wanted to add the number 26 in between one and two you know who knows why but we we want to do it so what we need to do is create a new node somewhere do matter let's let's put it here that contains the number 26 we need to break this link so that's no longer there and we add two new ones one for pointing from the node one to 26 and one pointing from node 26 to two if we wanted to do this in an array what we'd have to do is we'd have to shift every element after one down one that would take n operations and then put the number 26 in the gap we just made by moving the two along so with the link list after we found the place we want to insert the nodes it's constant time insertion because we we're breaking one link and creating two more and that that doesn't matter how many noes there are in the list we're changing three links breaking one adding two searching may take up to you know if we want to insert after an element with a value of three where we going to have to search through the whole list and that will take up to n so up to up to the number of things in the list the actual insertion is constant time also if you want to remove an element from the list that's that's quite easy too what we do we would we break these two links and then we create a new link joining one to two again there's a slight special case for inserting and removing if you want to do it at the head or the tail you need to change the head or tail reference to point to the new node that is the head or tail so if we wanted to remove the first node in the list we would break this link we would break this link and then we create a new link from head to the new head of the list similarly if we insert we'd point the head at the new node if we deleted the tail we point tail at that node create a new one we point it at the new node these link lists we've looked at so far are called singly link lists because they each have a single link to the next node in the list now there are also doubly link lists so a doubly link list has a link both to the next node and the previous node the nodes look slightly different they now have three compartments i guess so we have the value still here so we've got 0 1 2 3 each of these has a poin of both to the next node and to the previous node so next previous and of course not forgetting that goes to null and that goes to null so you can kind of think it's it's a breakr trail but it goes both ways so if you want to you can start at the head and go down to the tail or you can start at the tail and work your way up to the head still you don't have very good random access because you've either got to go from the tail and backwards or from the head and forwards okay so a practical example of where i've actually used a w link list in almost the real world in your web browser you visit a website you click some links you go to the next page and the next page and the next page and then in the top corner you can click the back button and go back a bit and keep going back but you can go forwards again and then also you might go back a bit you might click another link let's see how this works as a link list i'm just going to draw the data compartment cuz it's easier so we start with main page at the start of the list this this points to null this will also point to null as soon as we browse to somewhere so yesterday i was looking up on wikipedia there was a link to nasa on the front page so i went to look at nasa so this points back to here this points to null because we're browsing nasa and then read a bit about nasa clicked on the neil armstrong article this points back at here and points forward to no because it's the end of the list from neil armstrong i started reading about apollo 11 so points back to neil armstrong and forward to null so while we're going forwards we know which page we're on so we're on apollo 11 so we're we're pointing at apollo 11 here there's my hastily constructed non blowable pointer so i think enough about apollo 11 i'm going to go back a couple so let's go back to neil armstrong now we're reading about neil armstrong again so on his page you know if you want to we can go forward to apollo 11 click the forward button but okay we go back a couple back to nasa our back history is still there our forward history is still there however we decided to click another link on nasa we decided to look at the international space station page so there's a link from nasa to the iss page so we click this now we break this link we we no longer have neil armstrong in our forward history we're now at iss pointing back to nasa and if we go back to nasa from iss we're we're at iss we go back to nasa we we can't get back to the armstrong anymore we have no we no way to get there every time we're on a page and we click a new hyperlink we break the previous history the previous ford history goes away and we create a new node that that represents the current page rom are there any other things this sort of code gets used for yeah so you might do this with something like undo and redo history in a program like word or or notepad or something like that some sort of editor every time you click undo you go back to previous states but your redo states are still there until you do something and then you've lost all your redo history unless you're using something like something like vim which i think stores all your undo and redo as a tree and you can eventually get back to the things so it doesn't ever throw anything away but but for most ones would you say it's breaking the chain yeah so you break the chain you you throw away all this future that you you've you've gone back from and it's gone to look at the names and make the names meaningful so instead of doing that you can use a thing called an array which is one name that points to multiple items of data which we store next to each other in a contiguous block of memory so