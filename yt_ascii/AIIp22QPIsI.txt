well thanks for coming and i guess we can start now to rest your minds yes the t-shirt says move semantics but in serbian it technically half serbian mve is still is english and full translation would be semantic and not even c++ developers would get it they would assume it's like some dancing stuff funnily enough if this e had a hat or a half hat it would be the way it's spelled in check and would you know it i'm from seria living in prague right now but enough about my t-shirt about me now i like to emphasize this part where that to be a teaching assistant because i see this in a way as part of that meaning i need you to interact with me like if if you are completely quiet i'm going to assume that either you didn't listen or you didn't understand the word i said and i go into panic and not good for anyone so like if anyone want can just like nod or give me like yeah yeah move it along but don't worry i do have at least three plants in the audience and like victor already did the entire talk about how layout is important for the abi compatibility so it's i say it's going to be good with that i guess we can start thank you so you have decided to create a class right you tried all the other ways and you just have to that there is nothing else and yeah well you need some member variables and you need some member functions some static some private public protected all the stuff right and the way it's usually done is you write truct or class you write a name you open and close the braces put a semicolon and it's like you open a bag and just throw stuff in there with reckless abandon just like don't sorry it's just don't think about it and when you're done you're like yeah it's good and then sometime someone else comes along and it's like oh this is a nice bag i i have some more stuff to to put in there of course the first thing would be you should probably learn the solid principles or at least the s of the solid principles but that's not what this talk is about this how many would you agree that this is something like the code you would write no one nice nice is it because of the exception is that what's what's keeping you back okay so yeah there is this perfectly named my struct that has two integers one double triples and a string name because without it nothing makes sense with the name we at least know what it is good so first let's start with the standard and by standard i of course mean the cprf because yeah i'm not going to read the standard this is just to set like some terms and the basically the the rules of the game now first thing i want to emphasize because in previous versions of this talk i always forget is that i will not be talking about virtual inheritance because it complicates things and i only have an hour and also i try to avoid it if possible so everything i say like from this point forward just assume that there is no virtual inheritance at any point now non-static data members contribute to the size of the object the only thing that matters to us for this talk are the non-static member variables and yes there is also a name data members or member objects and i will try to stick only to member variables hopefully it's going to be bit less confusing that way other stuff like member functions and if you define a class within a class doesn't impact the layout or inum or static data none of that matters like only thing that matter are the non-static member variables and this is the simple part which is that you're gu guaranteed that the object is going to be in one continuous chunk of memory and the first member variable is going to be at the zero offset looking at the the object you are however not guaranteed which the member variable is going to be first but that's the fun part and you can imagine like the class that i showed previously looking something like this in memory except that these bulls would be smaller but was too lazy to adjust the size of the table elements and last night we actually had this somewhat lively discussion about languages spoken languages not programming languages and yeah there was this like a point with czech and slovak language where people from czech republic can understand slovak but or is it the other way around i don't remember but the point is like there is this there is one way understanding they are kind of speaking the same language but not really and that's basically how i felt reading this part of the cppf and the standard like i know it's english because i understand every word individually but like the sentences not so much so before c++ 11 you were guaranteed that within an access block and an access block is all of the variables like when you write let's say public and then you write some variables until you write something like protected or private that's like one block and you were guaranteed that all of the member variables within that block are going to be laid out in memory in the order in which they were declared however you were not you not guaranteed the order of the blocks so they could be moved around then they changed it and also like if someone knows if i'm misunderstanding this please correct me like i don't want to guess light people here so inos f 11 when reworking pod they changed this and now we are not talking about blocks we are talking about me variables member variables individually so basically member now member variables with the same ais are going to be relative to each other in the order they were declared but they could be moved around and of course that there is kind of an obvious question which is why and there is the at least i don't know any good answer like in theory yes the compiler could do some optimization here and that's probably why they left it but also think about it they could change compiler could change its decision how to lay out data from version to version breaking apbi constantly and like we've learned that we don't guarantee abbi but we also don't want to break it luckily c++ 23 came along and this is the the whole reason why i actually kept this slide there was this paper which does exactly what it said makes the order layout mandated the same as the declaration order and if you read it or at least just the conclusion it basically comes down to this first of all no one did this like no one played around with layout unnecessarily so either compiler developers are good people or they're lazy and both are completely understandable and the the second point was that it really wouldn't make sense to to like keep this rule and no one understands like the rational why we had it so let's just remove it and no one is even going to notice so now everything is as you as you'd expect and there is this another paper and i have no idea what the status is which basically says let's add an attribute that is going to allow compiler to again mess with the the layout but this time we are actually going to tell the compiler in which way we want to we want it to mess with the layout like you can say smallest and then it's going to like solve the knapsack or no backpack problem and figure out the optimal way to order your data or i think the compilers are allowed to ignore your attributes so compiler implementers can still lazy again no idea what's the status of this it's expect accepted or is it even being discussed so next we have this thing that are subobjects member objects base class subobjects and array elements don't care about array elements member objects are actually member variables and base class sub objects are as you can imagine subobjects of base classes the point of this is that for the purpos purposes of the layout base class sub sub objects and member variables are basically the same thing and there are going to be examples that are going to illustrate this better and just for the completeness of course if we have subobjects we have complete objects which is things that are not subobjects the next thing is that every object needs to have a size and the funny thing is it says also yeah i copied this like from cppf i was i did not care to to write it in my own words so it says that each object object needs to have size which is non zero we are going to for now ignore this overlapping non potentially overlapping part and bit fields are going we are going to ignore completely the funny thing about this is it doesn't really says it's unsigned or anything like that so technically it can be a negative size i mean not really but if it were possible it mean it would mean that downloading ram would be possible you would just need a bunch of objects with negative size adding memory to your computer so it was not a lie but in reality yeah it needs to be non zero meaning it needs to be at least one or greater also if you don't like the jokes or are they are confusing just let me know i will stop and the last thing is like there is a lot of text here so like don't don't bother reading it's more like notes for me if you have two objects of same type and same lifetime they need to have distinct addresses well if if they are different types also yes but that's like a more obvious part this is again going to be shown later but in essence each object object needs to have a size greater than one and needs to have a unique address well no sorry greater than zero and unique address so yeah like if you have something at this address the size is at least one so the next object can be at the next address of course link to where you can read this more cool go on yeah the next thing is the alignment now every every type has this thing called the alignment requirement it's a size t and it's a power of two and the easiest way to think about the alignment is to think that the address of the the address at which the object of this type can be allocated needs to be divisible by this number which is is called alignment you can use align of an operator or a function stood alignment off to get the alignment requirement of a type and you can also use align as to set the alignment requirement for a type the limitation of the align as is that it needs to be well basically needs to satisfy the requirement of the align m which is it needss to be power of two and also it can only set higher alignment requirement so like if you have an int which is 4 byte you can only set it its alignment requirement to eight or 16 or like more not less and we also have a bunch more of these functions i'm not going to go into them because not really important for the for the purposes of this to but i'm going to mention not to use the last one and like just don't and there is also well the the o the o or the processor itself kind of requires has some like expectations for the alignment alignment the point of this is that the processor never really loads one bte even though you can address one bite is going to read one word which is four or eight bytes and yeah we are kind of taught that the objects should fit if possible in one word or or if it's possible like don't get it between two words because then you need two loads to to read the object and that's just terrible like performance is just down the toilet but but is it is so this is from the l's blog and i would just like to note this is from 2012 basically what he did he took integers of 4 bytes or 8 bytes and just misalign them to see what are the performance differences and you will notice that on a core i7 processor there is basically no difference and on core two there is like minor difference of 10% now 10% is of course not that little especially when talking to c++ developers but who is using core2 processor this day so don't worry other thing is of course like you actually need to go out of your way to to misalign data so just like don't do anything stupid and you're fine with that we can i hope move to examples yeah yeah i guess some thumbs up yeah also like feel free to ask any questions as soon as they pop up or if anyone is following the online chat like i would rather not get to the end and find out that there is something from the beginning that was misunderstood so we have inheritance we have these three base classes and two of them have an integer and then we have the class that inherits from all three of them of course all the examples are god on on god bol i assume that presentation is going to be available if not it's definitely on git so you will be free to play with it size of the first is as we'd expect four because that's the size of the in the size of the second is one because even though the second basee doesn't have any data it still needs at least one by in memory and the third is of course four and now the size of the inheritance is is eight okay so like no elementary school maths 4 + 1 + 4 is 8 beautiful and the reason for that is okay yeah yeah maybe some of from the back row not the first row okay so let's let's just quickly go through this base classes the slide says usually and it says usually because i don't think it's mandated anywhere but in general if you have base classes the subobjects of the base classes are going to be before the sub object of the most derived class and uh the no sorry that's actually the next yeah sorry that's actually the the next slide and yeah as mentioned like empty stat stateless classes take one bite except that they don't really have to and the compiler can do empty base class optimization in essence what happens is that the class i think the stateless is a better name for for the classes that have no member variables like it doesn't hold any state which means it doesn't really need any space it needs an address and we have already addresses for other objects so why not share so yeah the compiler can do empty based class optimization meaning it can share the space from other parts of the class with the with this stateless class and this is where we get to the c++ part which is it's compiler dependent yes we have three major and i don't know how many minor compilers but i have only played with the three major of course because i mean i can't go through all of them so now we have a bit different example which is the second base is the b class of the first and third base and like i kept the names the same because copy paste is easier than you know renaming everything and again second base is size one second first and third base are size four and what is the size of inheritance so we got 8 9 and 12 well it depends and of course that's why i mentioned it's compiler dependent so if we ask gcc is going to say eight if we ask clang is going to say eight and if we ask msvc it is going to say 12 it's absolutely refusing nine like in any way but also like victor have a bug so yeah i don't i don't care like just for context victor victor from prag and he works in in microsoft he works for like v works on visual studio but as far as i'm conern he works on microsoft so like if i buy an xbox and my controller dies i'm like going to big turn i have a proximate idea where he lives and i know where he works so yeah good but people were told that anything we can do well not anything we can do with the inheritance we can do with composition i but we should favor composition over inheritance so first second and third base are the same and now they are not based classes they are member variables and the size is we got 12 and 16 and the 12 is correct and it's correct because alignment yes so i haven't mentioned it like first time i went through alignment but the alignment of this entire composition is going to be the same as the alignment of its largest member variable and like it goes down through the inheritance so in this case it is going to be four because both first and third are size four and have alignment requirement of four so yes we are going to have basically nine bytes of useful stuff and then we are going to have three bites of padding so they lied to us we cannot do empty base class optimization with inheritance or can we can we i don't know yeah that that's also a good answer i don't know it's why we're here isn't it so since simp plus past 20 we have this attribute no unique address and i like it because it actually perfectly illustrates what the what the purpose is like no unique address i have this second base but it doesn't really it's a it's a member variable but it doesn't really need any space so it doesn't need a unique address so yeah it can share with one of the others and yeah everything stays the same and composition is now eight we have effectively done the empty base class optimization a bit more about this no unique address yeah so you apply it to member variable when you declare it and this is a this is like if you remember i mentioned that the size needs to be greater than zero unless it's potentially overlapping well this makes it potentially overlapping and now it basically shares the space or well shares address with some other member variable or like base class and yeah there is also this part that uh if the memory is not empty then the padding can be reused but i haven't played with it and i don't think anyone really has and also it's since c++ 20 and also microsoft had because they had it from i don't know when they still use the msvc colon colon no unique address while the gcn cl just have no address so you can use a micro for this we love micro don't we and now we get to like more interesting examples now this doesn't really make sense why would i have four stateless like objects because they don't carry any state like one should be enough but let's just have fun right if you do it this way they are in the middle like all three compilers agree it's great if you put them in the beginning then again all of them agree also great if we put them in the end they disagree and microsoft actually here does the better thing i i guess but what we what if we have five because four is just not enough now in this case again gcc and clang are in sync so they basically do the same thing and microsoft just doesn't want to play along same thing happens if you put them in the beginning but if you put him in the end then my moft does the the right thing you know one day we hope all that the compiler implementers are going to agree on how they do this this stuff so we don't have to go to godbolt with three compilers and like see what happens but not today not today so like donate to god bol please and with all this craziness of all these rules we have this thing that's called the standard layout type now the purpose of it is that if you follow the rules that this thing requires you are going to get the same layout from all the standard compliant compilers now the rules are no virtual functions and the no virtual inheritance if you have base classes they all need to be of the standard layout type and you cannot have the same base class twice because well as if we've seen empty base class optimization may not work and if you have member variables all of them need to have the same access and all of them need to be in the same base class or in the most derived class and there is this is standard layout type tra that you can use to check if your your type is a standard layout and there is example for like anyone who wants to go and play with it but if you want to take a closer look at like how it's actually laid out in memory first thing you can use is this offset off it's actually from c it's a macro so you put a type and you put the name of the member variable and then in then it expands and gives you the offset of the that memory variable within the type and example from the cppf we have distruct s it has a a char a double a short and another char and you call offset off and it gives you the offset so like the char is at offset zero which which basically means it's at the beginning of the object then the double is at eight because of alignment requirements short is at 16 again alignment requirements and then the next chart is at' pretty obvious i would say yes yes yes but that's not enough that's not fun enough because we have no information about the base classes and we want to know we have to know we lose sleep over this so all three of the compilers have this flags and like just a kind of a fair warning these are compiler developer debug flags so not something you should use or can practically use in like build but they are going to dum dump the layout of the classes in the well either in a file for the gcc example or in the terminal for the others yeah like one note for the clank and just see for the clank so it's dump record layouts but depending on the version you're either going to need to use this cc1 or x clang i don't know when they chang it like when i originally did this presentation it was cc1 and then in the meantime it changed to it stopped working so i moved to this is clang xlang and for same thing for the gcc thing it's like either f dump l class or dump class hierarchy and also the gcc thing is going to damp to a file that's going to be named like the name of the file that being compiled. class so you can't use it in in compiler explorer and msbc has stayed consistent with the with the name and this is here i've used the the examples from the clank because i find their output the prettiest and also like the the sorry gcc1 was pretty sparse with the with the information now i'm just going to use the or i'm not can we yeah okay sorry i guess not so yeah i mean i actually wanted i just wanted to use the cursor because of the online people but the the projector is not going to work and yes i do care about people that are here more than online people so on the left hand side we see the offsets and then in the bottom you see the size of the d size i forgot what that is but it doesn't really matter what what matters to us right now is the size of and the align and the nv size is like non virtual size and nv align is non virtual align for us it's all the same simply because there is nothing virtual going on here and then you see the name of the struct and then you see its member variables and on the left hand side you see the zeros or 48 which are the offsets yeah so here are the first second and third base and then there is this composition with no unique address which is just like the first example of a composition where we did not use the virtual inheritance sorry noic address so we see that the first base is in the beginning and the int b b from the first base base is like at offset zero like right at the beginning and then at offset four we have the second base and it also like says it's empty but then at eight it says it puts this third base and it's of course the c it's member variable and so like all in all we get the the size of 12 when we get aligned requirements of four if we use the noic address then we see that the second base or the member variable of type second base is at the same offset as the first base or the in b b from the first base so it is it it's exactly as it says no unique address like it's using the address of this thing because it doesn't hold any state does doesn't need any actual memory and after that the third base and then this is the inheritance and like as i've mentioned the base class subobjects and the member variable sub objects for the purposes of the layout are the same thing and it's i think best illustrated in this in this example with no unique address because you will notice that the only difference is in this case when we use inheritance it says base in the brackets and here it doesn't but other than that everything is exactly the same and this is the the class from the beginning the myru the infamous myru we see okay in bull in bull double bull great but this is i think the the most fun part part of this dumping the the records layout is that we now see the string how it looks and how it's basically implemented at least this part when it comes to the layout we see that the string has this aloc hder and data plus and that thing that aloc hyder has this base class which is an empty base class al ator which is again which is uh which again has this empty base new allocator for the char and it has a pointer mp and then there is string l of the science type and then yeah there is this we also see this like small string optimization the union of the car buffer and the the size toop allocated capacity and also like the the entire size is 64 and alignment requirement is eight and also like you will notice that this like okay the first two bulls are well okay bull is just true or false so it's tech it technically needs one bit but we kind of need entire bite we we cannot makes we cannot have size of 0.1 we said it needs to be like a greater than zero but really needs to be a whole number but here because of the alignment it's four bytes so instead of waiting instead of wasting seven bits we are wasting 31 bit and the worst case is actually after this double because then this third is value three set is at 24 and string starts at 32 meaning that we are wasting seven bytes and seven bits really based form and now let's take a look at the the the examples that kind of confused the msvc the inheritance which has size 12 yeah like i no idea what happened here so you see that the first base and second base it's fine it's at zero and then for some reason the the third base is at eight so don't know why it put like the padding there we see that the clank did the same thing for the start but then put the third way where it should be so i don't know fix it victor now that would be ai break don't do it or actually you can use this as a is a pin that's going to open the flood gaze and like oh we break this like let's break everything destroy the the abi and this is the example where they kind of agreed on like the size well they at least agreed on the size of the the object but we see that microsoft is at least consistent meaning that the s1 s2 and s3 are going to share the memory with the f like it's going to look before the the is going to look to the object that's declared before to share the memory with it while the clang for the s man shares with the first base but the rest share with the third base like seems pretty arbitrary but you know it's how they did it so yeah it kind of seemed like they agreed but no no we don't do that here and finally yeah sorry forgot about this slide but for now just don't assume assert like you don't know what the compiler is doing you know do something like check the offset off or check the size or is standard layout or whatever just you don't know what they're doing and any questions just needed an excuse to drink some water finally the performance the only thing we really care about right right now i have these two sorry i have these two very simple classes one is good data and the other is sinful data now the sinful data is sinful simply because it's wasting space in the good data we have integer and two bulls and because of the alignment requirements we're going to have two padding bytes but in the sinful data we have also one integer in two bulls but because there is one bull then one integer then another bull there is going to be bull padding integer bull padding meaning simple data is going to be 12 bytes and good data is going to be 8 byes 50% difference in size terrible now i've create now the the only things that i've implemented for this very simple structs are the constructor and less than operator for the sole purpose of illustrating that they are functionally if that is the correct word the same meaning they encode the same amount of data and the constructors are the same they take the the same arguments in the same order simply because the code would be simpler i don't need to implement things twice and the less than operator is implemented because of course there is going to be a sort and i don't want to use the spaceship operator because i want the values to be compared in the same order leading to the same evaluation so i don't want the the performance of sort to depend of on the number of swaps it should be like the same it should just depend on the fact that they are not laid out in memory the same cool yeah so for the setup ryzen 7,000 whatever yeah like i originally did this like a year ago when like this was a flex it was completely new processor now it's just sold not that fun there are new ones and manaro i i don't remember what the version was when i did the test when i did the benchmark but it's just to show that i use arch which is required it's like the most basic version like i it's like ubuntu i just installed it like everything is default but it's arch so i can say i us ar that's the important part i used like google benchmark because it's basically the the industry standard and for each data point there are 100 iterations and the data sizes go from 100 to 1 million with 100 increments generate data is going to create a vector and then it's going to run the reserve space and then it's going to random generate u values for the good and sinful dat data 4h is just going to iterate through all of them maybe there is some like basic operation happening sort is just stood sort and accumulate is just stood accumulate and it's on git so you can go and like complain about my code style and tell me what's wrong i will ignore it but you know if it makes feel better do it now i do apologize for for the graphs they are not the most visible but like i just dumped all of the benchmark info into a csv file and there was this python script i found online that generated the the graphs and i couldn't be bothered to like fix the size of the fonts and stuff so yeah it's f i don't unless i have to i don't do it but in essence what you need to know is that this x-axis is logarithmic so it goes from like 100 to, to 10,000 to 100,000 to a million and this is just cpu time this doesn't really show much this is the the benchmark for the generate this is the relative speed and well the blue line is the good data which is supposed to be the baseline which is supposed to be the better but see here that the the sinful data is for the most part actually better the time when it gets like close to the good data is basically when we get out of the cach and when we get out of the when i think it's when we get out of l2 cach and then when we get out of like cash entirely it's just chaos that's what you usually see at the end of the the graph but we see here that the sinful dat is actually better in this case so you know is like they always say measure before you optimize and now we have for each and in this case we notice these bumps and these bumps most probably coincide with the when we get out of l1 and l2 and then l3 cach and we notice that like consistently the sinful data is going to get out of the cash sooner than the good data then like by the time the good data gets out the performance pretty much evens out until we get out of cash and tha and then it's just chaos again and in this relative comparison it's yeah you see these bumps the bumps are basically the places where the sinful data has left the cach but the good data hasn't yet and then they catch up and then the end is just the end and we have sort sort yeah this doesn't really show much but relatively speaking it's usually faster to sort the good data compared to the bad data but the difference is somewhere like 2 three% which i guess should not be surprising because we randomly access stuff so we don't benefit from cash locality or stuff like that except for this very specific case and i don't know which value is this but again it's 100 iteration it wasn't just one off it for 100 times it was 35% faster to sort the sinful data than the good data don't know what happened there and we get to the accumulate which is the only one that did what i wanted it to do to illustrate how how good it is to to have like good layout here it's like it's consistent right it's just consistently better to to have this good layout compared to the to the bad and in relative we see that it's not just p it's much better again i don't know if you can see the the numbers on the left side but it basically goes up to like four times faster with the no yeah four times faster with the the good data compared to the sful any comments surprises wishes nothing perfect i love the cough it was like perfectly t like and yeah usually i just like to leave references for the stuff of used if you want to go into more details the first talk is actually going to go into the layout when you have virtual inheritance if you're interested in that go check it out the rest of the stuff are the blogs i've used and of course cprf which you know may not be the best place for learning c++ but if you are interested in like concrete information it's good and yeah i'm not like going to go on twitter or facebook and argue with people so you will not find me there but if you want to shoot some zombies on steam i am there and yeah with that i'm done with my part so i'm open to clous [applause] hi thanks for the presentation it was very nice i just have a question though when you present the good data and the seamful data if you pack the seamful data would you expect to get the same results or will it behave as the good data yeah so h i would say yes but let's just go back i didn't use p because like you shouldn't i've said it and i will repeat it yeah like my assumption here is that the size is the only factor that contributes to the performance so yeah like maybe there is something in sense that the int is before the two bulls meaning like in the order in which they are accessed like for for the less than operat we access the int and then we access the the one bull and the second bull so maybe because the bull is before in they are you know but i think like with the modern caches it should be big enough to to fit it's it's eight bytes it's like one word so i i think that like if they were packed it it would be the the same performance yeah okay thank you y hello hello good presentation would you say in terms of of your results so could you say is inconclusive there's no there's no real conclusion we can draw from this i suppose yeah if you mean the performance yeah yeah yeah it's inconclusive because i did the same test on my other computer which is some older int intel processor and some other operating system it's like ubuntu something and the results were different very much different and also like in my original talk on a local meetup i did the i did the benchmark live but instead of having so many iterations because it took like two days to to run all of them i just did like 100 1,000 and stuff like that and in that case it was very consistent in terms of like yeah the good data was always better in this case when you do 100 200 like if you have more data points more more runs then it gets the story is a bit different so yeah it's it's it's not the perfect benchmark by any means so like if anyone wants to like criticize g is there and yeah it's somewhat inconclusive but it's also it's also to illustrate the thing that has been said many times measure before you optimize like maybe you have sorry maybe you have exactly this number of elements where you have insanely better performance with sinful data and you just do that okay have you done an analysis of data consistency so you mentioned that especially once you're leaving l3 cache that it's all over the place did you see a big jump in in speed consistency or how's the overall consistency here u i honestly haven't done any like extensive analysis okay this was supposed to be like a very short fun benchmark i kind of assume that the compiler is no longer allowed to pack the bu values because it introduces a data race if you access the boot from different threats so you would have to synchronize because you only have we size access this is possible i don't really know what the the the comp okay so why aren't we making fun of it like vector of pool because it it prefers the dense layout our efficiency see yeah i mean i i'm not going to comment on vector of bo so honestly don't know like also padding is not that bad because like this is the biggest crowd i've talked in front of but there are so many empty chairs that it's like it's half empty room so it's not a big deal so yeah that um can you go back to the slide where you show the comparison operation which one for the sinful data and the other one you mean the code yeah the code did you use that same comparison for the sord benchmark or is it on the is a different one on the slides yeah yeah it's this it's i think that might explain things because i don't think it's consistent because you can have one value that is smaller than an other and if you do some comparison in the other order it's still two because if value of the first one is smaller than the value of the other one then that will return true without checking the boo if if you compare it in the other order then that will return false but you then compare the booleans which can still return true so you get an inconsistent result for smaller and that violet the assumptions of sort okay if i'm not very mistaken and if i have explained it properly not entirely sure right so like the the whole reason i implemented the less than operator is because and also the reason why i implement the the constructor is that i use rand like the cand with the same seed every time so the idea is that the data is always going to be generated the same so basically the values of value b1 and b2 are going to be the same and then if if i call the less than operator it should evaluate the same the basic idea is that like if i have the same data with the same way of comparing but with different layouts what is the the difference in the performance so i don't think there is any inconsistency here but uh if anyone disagrees speak now yeah maybe mistake maybe i misunderstood something sorry thanks okay need to get ready hi i'm not sure i get it right so maybe you can kind of reiterate the point so that's using a 64 sorry i said ask questions as they come up don't don't wa no no no no like i'm sorry this is precisely the reason i said just like ask as soon as you but i believe in you we can do this so yeah does does that's using a 64 environment versus a 32 bit environment make it worse or better because i understand if a boolean makes pushes a integer because they don't both fit in the same 4 byte alignment but if you have 8 by alignment does that mean you can put two integers densely so okay for the for the os part like the four the four byte word is just like how much the processor is going to to load so okay i think i i get the the the point i'm not sure yeah i guess like if it's 8 byte then everything is going to fit into one word it's going to be better but it's like nowadays it's more about the cash line it's like more about the cash line and cash size than it is about the the world size okay thank you okay i'm going to to the end well yeah i guess that's it thank you [applause] yeah i don't get either