let's get rusty let's get rusty boys developers hate rust despite stack overflow claiming rust is the most lov can did google just f up what what is this what what is this view you just did google it's like half there half not there what is that all right there we go language year after year i haven't seen this much genuine hate for a programming language in a long time it's gone so bad that merely mentioning russ that's a w that's a w can we can we can we get a w here let's go let's go that's a w right there can trigger developers but this hate isn't all unfounded and it usually stems from five reasons the first one being lack of job opportunities to which i just oh let's hear what he has to say have to say the second reason dev not there's one thing that i he remember of the jobs that are available it's still like 75% crypto bros solon's going to make it man like d is just like that's you know what i'm saying you know what i'm saying and and the second thing is is that if you watch the stack overflow survey from last year last year to this year there were more people satisfied in using rust percentage wise at their job but there were less people overall using rust at their job and they used percentages they didn't even like it was even the oh my goodness dude it was the that chart i'm still triggered to this day by by rust foundation chart or whatever whoever runs the rust chart charting year bye it was the most misleading nonsens thing i've ever seen in my life dude it was marketing to like a it was marketing to a tea and it was confusing as it as it gets developers hate rust is the syntax people say it's verbose complex and downright ugly for comparison let's take a look at the map method which transforms a collection of one type to another type the function signature in javascript is extremely simple whereas in rust it gets pretty complicated we see generics trait trait bounds closures the size trait and this signature ain't nobody knows what the size trait is okay a i know there's a lot of people in this chat they're going to be like oh i know totally know that no you you don't you don't know it don't even try it with me you have no idea what's going on doesn't even include lifetimes so yes the rust syntax is more robos more complex and frankly more intimidating than a lot of other languages but there are some good reasons for this rust is a statically typed language which favors explicitness in its type system and it also has to model things like memory safety in its type system the benefit of this is that it reduces ambiguity which in turn reduces errors the map function in javascript doesn't tell us what the type of the input parameter should be or what the function returns if anything developers have to dig into documentation to figure that out this opens up the door for runtime errors because a developer can literally pass in anything to to this function the map method he he does make a really good point which is if you're unfamiliar with just static i mean rust is a particularly egregious version of this all like it does just simply have the most verbo syntax but if you're familiar with any statically typed language you will quickly become a fan of it because you no longer have to go and like guess what the thing does or go and like read documentation on the internet or use your lsp to bring it up and try to like infer the types through whatever you're looking at you can actually it's like right there and so there is something that's very very nice about having a good function signature and this is really what typescript you know this is like half the reason people love typescript is the fact that you have this in rust on the other hand tells us exactly what it expects as input and what it returns as output the code documents itself and developers are required to follow this function's contract otherwise they'll get a compile time error by favoring expl a syntax and having a strong type system rust ensures your code is predictable consistent easier to refactor debug and maintain it's all i'm curious about that last one easy to refactor i i would challenge that one once you get into lifetimes like if if you went from like make it work make it correct make it fast kind of like approach to software the making it fast once you start throwing in one lifetime it will it it will propagate through your whole code base it's not it's it's it's a very leaky odd thing that happens easy to refactor i mean i've refactored some rust i've i've done quite a bit of rust and quite a bit of refactoring of it and it's a fairly easy language to refactor like it it's not that bad it's just that adding stuff to it especially when you're surrounding especially like lifetime stuff is is a really can become really difficult and then refactoring in that sense becomes really difficult and so typically all the stuff i write that i used rust for i just used clone and just avoided it it during pretty much the entirety of the process until i really determine that i need to make things better what's the opposite of refactor reflector a reflector is where you take the program and you change it and you make it worse also worth pointing out that rust is constantly evolving and improvements are being added to make the language more ergonomic so if you've shied away from rust because of the syntax or the type system i completely understand but i encourage you to give rust a try and experience that warm fuzzy feeling you get when you successfully compile a program and that it's basically going to work how you expect at runtime the third reason developers hate rust is i do want to say that typically in a statically compiled language like you get this with go as well but less so with go you get a lot of this with zig much more with zig zig zig is like pretty close to rust as far as it goes without all the the difficulty of rust and and the comp comp time is just it's so compelling i want to write more zig i just don't have reasons to write more zig you know what i mean i i just want more zig in my life but if you even any statically typed language if you can compile it it's already a step you know it's it's already a step in the right direction you're already more safe than a dynamic language because they say there are better languages out there first of all we have c and c++ which are both lowlevel and performant if you're looking for simplicity you can go with c and if you're looking for a language that's objectoriented has modern features and a mature ecosystem then you can go with c++ not to mention that both c and c++ are established widely used languages with plenty of job opportunities on that that's very fair that's very fair those it's actually fair when he says simplicity what he means by simplicity isn't that writing c is simple is that the language itself is simple right like you can you can learn all of c syntax in a fairly short period of time so c is simple simple does not mean easy so you have to understand the difference between simple and easy and so that way if if you don't do that you're going to you're going to you know you're not going to understand when people say these phrases because like how short you could like k&r the book k&r is like what you could read it in a day it's it's simple it's just really hard okay other hand you have go a language that's laser focused on simplicity great for rapid development and with a excellent concurrency model it's especially great for building network services such as web servers apis and microservices it's also great for cli tools and automation scripts and there are plenty open go job positions and then of course we have zig a hey by the way mr rusty over here giving a positive review of go that's a lot of respect on him you know know people have to be able to recognize the strengths like i recognize the strengths of what makes typescript good and it's the same thing it's like tailwind if you overuse tailwind you get into this place where i think you you no longer make it good i see the same thing with typescript typescript has a bunch of really strong points when i'm developing a front end i'm going to use the typescript compiler i'm going to use js doc to like enable those things because i dude javascript without any types is crazy talk to me and so like i i'm fine with all those things how come you never recognize the greatness of c cuz i don't wear plead pants pco i like which that also focuses on simplicity in fact their tagline is focus on debugging your application rather than debugging your programming knowledge which i feel like is a shot out rust but i'll let it go for now zig has by the way zig is is absolutely incredible it is one of the most clever languages i've ever seen no hidden control flow no hidden memory allocations and no pre-processor or macros this results in fast compile times and seamless compatibility with cn c++ without needing bindings or wrappers it also includes some safety features like bounce checking and comes with a package manager and testing framework so with all these it it also remember it also has options so you you avoid the whole nil thing a lot it also has it has these nice little typed unions so you can do air handling more kind of rust styles where you can get the value or the error it has some nice keywords around it so you can try the function and pull out the error or or pull out the value or return out the air there's a lot of like there's there's a lot of nice little things like it isn't comp time kind of like macros comp time is kind of like macros it's not quite the same right a rust macro it's more like a declarative macro but you're just writing zig that's the difference is that a declarative macro in rust you you write out there's like still a lot of b a bunch of special things and symbols you have to know and then doing a procedural macro is even harder right it takes a lot of mental overhead but doing a comp time thing is you're just writing zig and you're saying instead of like int you're saying type it's like a generic it's like a it's a it's like the halfway it's it's more like writing a generic right you get that you get that experience where you're just writing the code and the generic is just kind of placed in there and you can do the operations on it it's really it's really incredible and then you just instantiate or i'm not even sure if that's the right term you specify the comp time what you want to use i want to be able to have a q with an int i want to be able to have a q with a this and it will make sure that at compile time it has those it's very very clever options why would anyone use rust now i'm not going to sit here and tell you you should use rust for every single use case even though that's absolutely true you should use the right tool for the job and there are certainly cases where c c++ go or zig is the right tool but russ solves a major problem in the system's programming space in a way that no other language has rust gives you an extremely high level of performance coupled with an extremely high level of memory safety in zig if we create an array with one element and then deallocate that array we can still attempt to access the first element which will result in the program crashing at runtime in rust this is true this is true if we tried to do the same thing we would get a compile time error because the ownership rules would prevent us from making this fatal mistake this is why we're it is it is better like that that is a good reason typically you use defer so zig also has defer so you can actually execute code after the function ends which is super cool i love that from go by the way you have that option but nonetheless he's absolutely correct you can still do you can still get a use after free seeing russ get adopted for critical software like cloud infrastructure at aws the world's largest operating system sys windows linux and android and mission critical software in the aerospace industry automotive industry and other embedded devices for these use cases rust is proving to be an excellent tool the fourth reason developers on i i will say that i think that if zigg came about earlier and was in a slightly more mature state i do think that zigg would have beat rust in a lot of these positions like right now linux it's it's pretty much c with some rust i honestly think zigg was such a shorter step to get in and i think z provides a lot of the safety features you need i think zig like for infrastructure if zig was further in i think zig would have been chosen just because it is just i think zig has a lot of it has a lot of opportunity it's just still too immature at this point though it's getting a lot better it's still not quite there but it's very it's a very compelling language hate rust is because they either think there's too much drama or too much hype i get youtube comments all the time saying rust is useless it's overhyped it's going to die out soon etc those and look maybe you don't have a good use case for rust or maybe somebody at work is forcing you to use rust against your will and despite seeing a clear benefit you see all these people online preaching the gospel of rust as a member of the rust evangelism strike force i get it sometimes we could be a little much everyone is entitled to their opinion but the numbers and success stories don't lie russ's momentum is continuing a million new russ developers joined the community over the last 12 months r subreddit has now surpassed the c++ subreddit and r continues to be voted the most loved sl most admired language year after year and we continue to see industry adoption by tech giants like microsoft aws and google so is the hype real in my completely unbiased opinion yeah russ might be a little overhyped but the hype is certainly real but this is a really good take i really appreciate this take which is there's a lot of momentum and twitter is a really shitty place to get information so yeah it's probably hyped up too hard on twitter but it is a great language and it is seeing adoption it's just we got to get the jobs you know the jobs still aren't there i think that's the biggest thing is that if jobs start opening up to like the average person i think that it will become huge i'm seeing a lot of fs what kind of fs are we talking about so i just want to make sure is this fs as in the stream or f as in this no f i don't f yes are you guys effing around on me right now are you guys effing around on me stream is fine you just just the you just dropping a bunch of fs oh my goodness reload reload dude you can't be you can't be you can't be just dropping fs like that dude casual casually effing me is just not the way to get me to notice you actually it is it is exactly the way to get me to notice you please don't casually f me okay it's like i trust you guys i trust you guys so much i know coordination was the key a bunch of you started saying f confused me got me scared don't take my word for it look at the numbers look at the success stories and try it out yourself on the other hand some developers hate rust because of the drama it's no secret that the rust foundation has had its share of controversies entire teams leaving the restrictive copyright policy draft which sparked backlash and other governance related issues besides these specific issues some developers see the foundation as too woke in general as a result of these controversies a fork of rust was created called crabing to protest back did we just get a tech travy savvy mention did we just get a tech travy savvy mention right now did we get it did we get it did we just get a did we just get a cameo by tex every tr i will take a quick moment i don't know what he's goingon to say about the crab ling i do want to take one quick moment to defend why i think it shouldn't exist and one reason why it should exist one reason why it should not exist is that it doesn't solve any direct problems and what i mean by that is that creating a fork just create a fork doesn't solve anything but i will say creating a fork keeping up with things and showing that there is a community of people willing to contribute to it is saying like hey we're upset you you should listen to us and i think that it's good to remind everybody that you know you any project on the internet is only as good as its users and so it's kind of like this it's itself is useless as much as it is useful like that's what everyone who makes these things should understand is that rust is only as good as the people using it and you should try to make it so that the people using it are are happy right like that's that's your goal fracturing the community is always an l i do agree with that fracturing the community is always an l but having that as like this is like it it's not like they're trying to diverge from anything if they were diverging from it and adding new features or trying to actually do something with crab l that's not in rust then i'd say that that's a big loss but it's not that instead it's just like it's just literally a mirror with a renamed rust to crabing and so at that point is just saying hey the community wants to hold you accountable and so i can like that i can appreciate that leadership and bureaucracy now as someone who created an entire channel dedicated to rust i definitely have some thoughts on this in general i think the drama is a bit overblown i do genuinely believe that the rust foundation is trying to do the right thing and even though they made mistakes they did also respond to the community's feedback and made adjustments ultimately i think it's going to take quite a bit more than some drama to derail rust momentum the fifth reason developers hate rust is because it's too hard and when people say rust is hard they usually mean it in two ways first of all rust is hard to learn you need to know a bunch of prerequisite computer science knowledge in addition rust is a low-level language which forces you to think about number five skill issues how things are laid out in memory and russ has a pretty complicated and unique type system things like the ownership and borrowing system traits and generics and macros which take a considerable amount of time and effort to learn the second way rust is hard is that it's hard to read and write again it has a pretty complicated type system and verbose syntax you have to deal with multiple string types smart pointers lifetime annotations i mean you can't even write a linked list without having a mental breakdown in addition to the type system and syntax there's also the borrow checker dealing with compile time errors all the time can be very frustrating and definitely slows down productivity in fact according to the 2020 3 rust community survey the biggest reason preventing people from learning rust is its difficulty but honestly rust is not the problem don't blame me perfectly skill issues are the problem design language on a skill issue if you wanted something easy then learn let's go can we come on can we get it can we get some claps here we got it we got we got we got it got the skill issue oh my goodness pre-at it's so pre-at we're so over language that's made for five-year-olds like go jokes aside i i boo this man boo this boo dude i'm just i'm emotionally wrecked now i'm em the i'm emotionally wrecked i know this is a very valid concern which is exactly why i created let's get rusty in the first place to simplify rust education and make it accessible to everyone and that's what i'll continue to do if you want to jump start your rust learning journey get your free rust cheat sheet by heading over to let's getet ry.com sheet hope you've enjoyed the video and remember to stay rusty this is actually a really good video and i think it had a lot of good things to say especially number five being the whole point about skill issues in rust honestly the b checker bar b checker is is not crazy it is not hard it is it it it itself is not a hard concept it's once you kind of put everything together it starts getting more and more difficult when you want to have imples on traits and async and everything all together then you start getting things that are just like it much harder to reason about and harder to like make it well i made this joke and and people tried to dunk on me it's just that they're doing the worst version of the dunking which is making it too trivially easy to like the trivial case is always trivial which is rust being a mostly functional language its biggest difficulty is using functions as values it's it's actually it was once you get beyond like the basics it becomes really difficult it becomes very very difficult yeah because you have to really think because if it's just like a peer function then it's easy but once you start hitting into some closures sprinkle a little bit of async in there and doing things you can find yourself running into some situations that make it harder you have to do a lot of you have to do a lot of changes and move async move like there's just some things you have to think about doing that become more and more difficult and i if you haven't done it you're going to say it's easy but until you've done it it becomes you know it takes a little bit and it's all practice in the end and and eventually you get really good at it and or at least you get mild at it everything becomes an arc yes or an rc ref cell an arc mutex or an rc ref cell like it all becomes that because you have to use it in certain ways and it becomes difficult but there are a lot of things that are really nice about rust honestly i do trust when i compile a program generally i trust it more just because i don't have some stupid things that i tend to do in other languages just because it forces me to only make mute the things that are mutable and so for me that's really nice right like it it just is i i tend to appreciate that i find myself any plans for rust courses on boot. the hard part about doing a good rust course is that people feel there's so many different ways this is kind of like my second big critique of rust is that there's so many different ways to skin the cat and that's one thing i really really really dislike about it which is anytime you do something someone else also says no this is a better way he would do it yeah tjs wants to focus on doing a rust course and so like that's a real difficulty is having everybody's tell you a different way you could possibly do it and so there's something about that that's really frustrating it's actually one of the primary reasons why i'm learning go is go typically there's like really just one way you do things and there's one pattern that's kind of coming about that people seem to really like and like that's it so either you have config as a struct or you have yourself this new like function option parameters and like that's it and it just feels easier you have like one way to do something i do miss pattern matching i do miss a lot of these higher level features but i also don't miss lifting right i also don't miss all the lifting and extra things you have to do in rust to make it work and so it's like it's kind of an in between i'm not sure which one just like a 5-year-old what would a 5-year-old say i'm not sure really which one i like better honestly rust or go i actually have no opinion yet on it that's not the way to do rust by my course yeah it's just there's a lot of there's a lot of that and so you really have to think a lot a lot a lot more doing things with rust and you're going to have you're going to find yourself arguing with yourself on different ways to go about it and so i find like honestly that's where i find a lot of the skill issues come from is that there's so many different ways to skin the cat the name the primagen the rusten really years of it absolutely loved it