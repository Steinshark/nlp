anyway this talk is what we have been waiting for and the grammar error is intentional but first i am staff software engineer in boen at toyota starting next week actually and i co-chair of evolution working group in isp committee and chair of study group of at for compal time programming and yes yesterday two days ago we pushed a reflection to evolution so don't ask me about it you know me for ct i did talk 2019 and 2018 about it and lighning updates i did talk last year also about ct h which is compile time sh to and implementation it was fun implementing i actually wanted to learn how to write these functions so i implemented them in compile time and co and that's a hint because that's the talk today because i love javascript and i know i'm on wrong wrong conference but i love javascript how many of you love javascript okay three for hands great thing i love about javascript is you can easily prototype in it and you can easily get done what you want without dealing how i will work with this socket and how i allocate something it just works most most of the time so at the committee meeting in vaa and at cpp now conference i was kind of little bit bored in meanwhile and i wrote this thingy it's a search engine and you can just type there something like let's say thread and it will search cp c c++ draft and you can just click on it and it will open for for you dcb c++ standard here and this is like definition of threat and i will go back and you can look for different things like vel ruptor there is a vel raptor veloy raptor yes for those of you who didn't know that is a specification of volatile because they are like dinosaurs they should go away so it's interruptor anyway let's go back and hopefully sorry i don't know why this is not going the bar is not going away and yeah yeah back so i did this search engine this little thingy works like like this it will look at every three characters as three three gams look at the reverse index and calculate intersection for all of the index parts and give you list of all documents and occurrences of the andram you looking for and then you will merge them together and you will get a list of documents sorted by number of occurrences it's really simple algorithm and in javascript you can do it lazily because you can you don't need full index you can just fetch download only parts of the index to do the search on client because everything is happen in javascript on client so in javascript you will just write fetch your and wait for a result and store it into constant result and you are done easy how would you do it in c++ which library would you use boost a you will need to implement your own http engine boost beast it's mostly for web websocket you will probably use qu but qu is cap api so it won't work easily with strings and everything so you will probably spend quite a lot of time trying to make something like this in c++ it's it's hard because in c++ we like to work like think about pointers and bits and performance and this is like there is a dls network api resolving and everything but fortunately i like library coral so i decide to use it but let's go back to javascript because i'm going ahead of myself you can download multiple things by prefix and then combine two promises from theet to one promise and return them together and you can ait on them to both to be finished and even javascript in browser is single threaded it will run in parallel because it's asynchronous so you don't know which will finish first i think that's quite nice utility and you don't need threats for that i don't i mean all javascript developers in the world don't know how to do threats because they don't have them okay you have aent keyword which makes your function as synchronous so it will return return promise with something you return from it and name of name is where prefix and fetch fetch and the thing and promise actually have syntax highlighting so enter lip curl how many of you use corl at least once in last month that's quite a lot i would say like 20% because it's quite nice library api is actually even when it's in the c is kind of c++ friendly and okay how many of you who at least once use lip curl write wrote their own rapper in c++ yeah it's kind of like homework for everyone who is using lip c so lip c is kind of old older than some of attend is here and it's nice simple api and you can use any protocol that is a protocol for http obviously https ftp but you can also work in ftp and many other protocols even like ipfs ipfs is intern interplanetary f system it's kind of google it it's interesting so lip c looks like this you will initialize handle check if actually it's correct because you don't have exception so you need to check it and then then set options you you want to download and that you want to follow also a direction in http protocol then you call perform which will block you for all ao and when it's done you need to check if it's not error if it's an error you need to print the error we are in c world so print f and then release all memory okay and if you want to write a result into object i'm going slowly into c++ world so i have string and i have a right data option and i provide a pointer to string and then every time i get some piece of output i can just append it into string that's like the mod operand what you do with lip curl and then return return size you you got and provide right function which in my case is a lambda how many of you know what d+ means in front of the lambda yeah few it's explicit casting into function pointer so easy perform easy perform i call easy perform wait for the result check for the if i was successful and through exception and return the result okay so i'm writing my own rapper for cor so i'm creating my own easy handle with constructor constructor it takes url because every time i'm using i'm passing some url there is structor to release memory properly there there are some options so i can set another eur later maybe to enable following location or write into some container which is appendable it's a template and i have function since perform which will block and do the io for me okay so i i example i will create handle allow following location provide string to output write into string do the s perform it's explicit so you know that it's it will block and then if i'm fail throw exception otherwise result this is something which everyone in c++ world who wrote a wrapper around cor did something similar so but i want to be asynchronous so i want my function to return return some promise of string i want to evate on the perform on the io and when i'm done i want to return the output string into the promise so how many many of you use score routines one two three four just few why because they are scary why scary because standard library doesn't support cortines yet only in 23 you got generator but nothing like task or promise it's too complicated every time about you see talk about coroutines there is so many customization point and and it's also i heard this quite often it's too new it's actually four years old in standard and it was standardized got into standard 5 years ago it's too new my friend from unnamed company wrote something with cortines and he was in middle and then site leader came to him and told him no you need to sc this and you need to use our own like light straight models because curtins are too new and that prob problematic wow tell me about job security anyway so but you can think that functions are just specialized coroutines because cortines can be seen as generalized functions or functions can be like specialized because function in c++ on any like normal language is just something it takes something and return something it take something start once and end once and will never get back into itself so they have one starting point one entry point they can have multiple exit points you can have multiple returns and they behave as a scope you always put them on top each other so it's really easy to have like system stack which just push something on memory so you don't need to care about where memory will be like allocated or something like like this you have color which call some function return from function call another function return from another function another function and so on so on but it's really easy to like to see what's the lifetime of your objects and variables in your functions because they are always in scope ri is the building blocks on one c++ but cins can have one starting they have one starting point and multiple entry points you can start them suspend them and then enter them again so they can be suspended resumed they can have multiple exit points as function but lifetime of cortin can left past your color so it's really it's much harder to argue about the lifetime so you don't know so i kind of fails that's the reason actually why cortin c++ they because they can be optimized and you don't know how many variables will be there and how many variables will survive suspension point so compiler cannot know how big they will need to be so that's reason why they are allocated on heap but optimizer is trying to very hard to give you option to actually run them and optim like put them into stack if it's possible but sometimes it's not possible especially if the ctin will survive your color and you cannot have it on on stack so you need to have it some somewhere else you can have like allocator for that so it can like look like this you have color you call it like generator and immediat immediately it will be suspended and then you will like resume it it will run for a while and then suspend it back then resume suspend resume suspend so you can write a generator code that's like basic codin and it's in standard you can just write my fun my my something r generator and co co coed coed and it will work you don't need to know what's what's happening behind but generator has a property that it will behave kind of as a function so lifetime of generator is tied to to to the object in the function you are calling it from so it's easy to argue about the lifetime but coroutines some some people miss like think st like threats but coroutines are still in one context in one function like in one threat and just sometimes they are suspended and some other cortines can be run instead but with threats you need to spawn threat and when some io is blocking you it's actually going to usually to kernel and you are blocked and then kernel will schedule your threat so they are kind of heavy coutin are much more lightweight but with coroutines because they are multiple usage and designs if you actually write your own cortin type you are responsible for that you are because it's like cooperative multitasking like windows 3.11 your application must count with that sometimes some task will be suspended and something else will happen and that's the reason why it's really hard to create a coutin type in standard library because we need to find some general like be like trade which can generalize everything or not and maybe it's maybe it's easier to let other libraries vendors to came with other solutions and then look later but this is like chicken eg problem because no one is using cortin because they are library support and no one is writing library support because no one is using them sorry so let's say javascript function on the left divide it's not i bound so it doesn't make to do it cortin but i did on the right divide with two parameters check if it's zero throw exception and at the end result the difference is sorry difference is the asn keyword on the right function it returns promise in c++ it's similar let's say divide function in a in b check exception and cor return in c++ we don't have the assin keyword in front of function or some like other mark and the committee in it etal wisdom decide that we will use coore return co yield coate i know it's ugly but it gives a compiler hints that this actually is cortine so it should look for something called promise type of coroutine based on its return type function int in this it's my type which representing this is a function returning int and because it's cor return compiler will build some machiner inside around it but from color side like if you look at header there is no difference between normal function and cortine just call it and it will give you object of type function int but internally as it it will build it will spawn coroutine do something as you describe in defunction type so you need to use at least once coate co yield cor to like make them defined as a cortin and sorry and when you do that comp look for coroutine traits type of your return type and also of its argument arguments so you can specialize also based on the arguments to give different traits it's a specialization point and every specialization point for ctin is there for reason they are complicated and sometimes to understand them you need to understand all of them so which is like again chicken egg but i hope i will help you with that cortin trait is just simple struct which take the return return type argument and if there is a promise type as part of your return type it will use that that's the default one so you usually don't need to define your cting traits but you can and you can create something totally different it's type name arguments and if there is a promise type and then just pro provide it but model of ctin is little bit different you have program stack and you call your function something which will give you the function t in my case which which contains only cortin handle think about like white star pointer to cortin and the cortin object itself contains three resum point promise type of the function and cin frame resum point is address into code where the cortin will resume when you when you resume it and function prise type is something you can it's user provided by the library author you can specialize you can provide some different behavior for exception for result how to evate on it but what you want that's think you wr and ctin frame is actually stackless stack of your function everything every variable which will survive suspension point so any time you you suspend between uh in lifetime of some object will be put in cortin frame and optimizer will try to squeeze it to small as possible so it can reuse it memory and so okay cortin handle is just kind of white star vo star thing of size of pointer and it's provided by standard library and it contains few function it's it can be typed or it can be not typed if it's not so the handler can know about the promise type inside promise type you provide or it can be just void star it's polymorphic because it's really useful to combine different types of cortines together so you can destroy it because as i said cortines have different type of lifetime so doesn't work so you as the owner of the like the opening object of the cortin handle it's your responsibility to destroy it maybe as ri but maybe some bit like it's it's on thread pool so when it's finished maybe or at the end of the program or maybe even never then we have resume function and if cortin is currently suspended and you call it it will resume your outine which means it will on stack create a space for every variable which is unique for only for the bet suspension points because that that doesn't need to be on the stack for stackless part of cortin frame and it will jump into the coroutine it will jump it it won't call it will jump you can check if the coroutine was finished which means it like reach the end of the coutin code i don't want to use function name because it's not function but it's it's also expic operator b so you can just check it and you don't need to call the do done and if it's typed you can actually access the premise type from it and you can from promise type you can actually get a decod in handle at the end it's just like probably from perspective of the machine code it's just like it will take point address of the premise type and substract few bites on it and will'll give you cortin handle from and then you can actually take address so you can actually convert cortin handle into void star pointer and back from it which is really useful to when you are interacting with c style api with u data member so my function as i'm implementing my function as a ctin to show you that it's not that hard the function type the one which user interact with contains contains some promise type i will get that later contains protein handle of my premise type handle and it will initialize with the handle and when is destroyed it will destroy the the coroutine itself so function behaves as a normal function so everything inside of function will be destroyed when the function is destroyed kind of and i can access the result with get or explicit casting so go back a little bit cortin can be kind of you can think cortin every time you get like it's kind of like lambda you will have everything which will survive suspension points it will store in like like lambda capture plus the reson point and it will store address of the fair s point and every time you call the this lambda coroutine it will jump to the resum point first time at state one it will do something and just before it will suspend in this case implemented as a return it will store the address of next point and then it will suspend the rtin which is just like exit it and next time you will run it it will be here and then another suspend point and etc etc this is like homemade cortin and each suspens point suspend point in cortin body is marked with coate or co yield it's it's a hint that compiler needs to do some transformation of the expression into the suspension point every time you call coate on some expression it will evaluate the expression and check if the expression is avable call function a already of the of the result type and if it's if it's not ready that is the result of the expression is not ready yet then it will mark point after the expression after the coate so it can be also inside of the expression not just after the part of the expression let's say mark as a point and then if a suspend function which needs to be there of the result returns void it will suspend current routine store stor like it will suspend and return it will call the a suspend function and return if it's suspension point a suspend return b it will call the function check the result and if it returns through it will suspend and if it return some other cortin handle which means jump somewhere else it will jump just jump there so it's not like function when you go go there and go back go there go back you you can just go there and when you suspend you can just jump somewhere else so it it's more like a graph and when you are resumed when finally someone decide that this function the avitable we are we are waiting on is ready that the result of maybe i called do read on socket when when it's ready and it will resume my coroutine i will call function a resume which returns what i ask for so we have some standard availables suspend suspend always and suspend never they are like useful build types or when you are writing routines suspend always will suspend you always it will never be ready and every time you call it a suspend it will return void so which means it will suspend always and resume is returning just void because it doesn't make sense to return anything else and never will obviously will be always ready and it will always return void the a suspend function will never be called so our function and insight there is a promise type there is a function in each promise type you provide or when you implementing a library type which is called initial suspend when you run coroutine it will gather arguments and then immediately it will call initial suspend and coate on it internally and decide what what it will happen in my case i don't need my function to suspend because i can execute it immediately so i'm returning suspend never then there is a final suspend point when the function reach the end reach reach end of his body or it's exception is thrown or you call coron it will call final suspend and at the end i can suspend always i can suspend never i in this case i'm doing suspend always because inside of the premise type i will store the result and i don't want the result to be destroyed so i can actually reach it later because there is like function get a return object when c is called before is any suspension compiler will call get ron object after this promise type is built and you can take premise type created from the handle type from the premise type and build your own function like your type in my case the function and that is a place i can st store a result of my function and if there is an exception i can store exception pointer here and every time i call cor return compiler will transform it into calling return value with my result and i will store the result inside of the promise type to be used later and when there is exception compiler will call un unhandled exection and i can start extion pointer or do something else or at or late whatever i want then we go back and constructor will just take the handle and it's constructed from the handle if i destroy the function i will destroy the handle as i did before and get will check with assert the micro routin is done if there is an exception i will retro it so it will behave as a function if i try to get the result from it it will throw if there is an exception other device i will get the result and i return to my user it's a function it's function as a coroutine everyone knows function so let's write function divide with like this thing like transform it so i will a function divide and when i call it function divide it will return me function end type because it's a function returning function in which is kind of just the cortin lambda which stores the arguments a and b inside of it i'm just marking as cortin frame it's like pudo code don't use it like it won't work it will first the do the initial suspend and coate on the result and then it will w the body of the of the coltin in tr catch block so if b is zero i will to exception otherwise i will call do return return value on the promise type return return the result and jump into the final suspend point if there is an exception i will call unheld exception in my promise type i provided and at the end i will just do the final suspend and will never go back because from never suspend always i will never go back because this coutin after that will be destroyed if you try resum function resum coroutine after after it reach final suspend it's ub so let's say i wrote cal promise type promise promise and promise types are two different things promise is promise something from cur and promise type in this context is the coltin promise type but this is just promise so my promise type will be similar as the function i have inside i have per type and i have constructor i i don't want to be copyable but i want to be movable i can i want to destroy it if it's not empty i want to assign it and the promise from cor itself is avable so i can actually aate on it so if i my handle my cortin is finished then i'm ready because i return something or throw something then if i suspend and i get argument is sometin which is suspending on me i can look in my promise type and that is function someone is waiting for me someone else some other ctin is waiting for me with this argument and i return return something else so i can jump to do something else meanwhile and when i'm when the is awaken i will just check for the exception retro it if there is exception otherwise get the result from outside from the promise type okay so promise type of the of of my promise is just similar as the function promise type but with few differences inside i have cortin handle of someone who is waiting on me so when i finish when i reach my final suspend point i can jump to other co routines so when i start my routine which is from like associated with coral i have some schedule and i in the schedule i'm about i'm going to start and i will never suspend i will immediately start the code and when i'm final suspending at the end of my cin body i will take my premise type and i will never be ready for the suspend point which means i will suspend then that doesn't make sense dear assume and every suspend i will get when i i'm suspending i'm getting always my handle my own handle and i will tell schedule i'm done but in inside of my premise type i have a vor which is awaiting on me or maybe it's empty and if someone is awaiting on me i can resume them because result for them is ready and i will just return my special suspend aor and there is a function someone is waiting for me which takes some polymorphic cortin handle store it inside and tell schedu which is like magic thing somewhere else that i'm going to suspend and please choose someone else who can still run so then i have aor lazy perform which will take kural handle and it's always never ready and when i suspend i will just associate the coroutine the my handle my cortin handle with the coro handle i will convert it into voice start with the two two pointer convert pointer i don't remember and in li that is private private pter i think option and you can store just op like some pointer in your handle to which is not touched by the library and then i will tell schedule please suspend me so it will return suspend always or or some other like it will return some other handle to run because i'm telling schedule i'm suspending jump somewhere else and when i'm finished i will return return some result type which contains error code from the coral so i can check if if i coate on lazy perform which is just a result of the a handle do perform so i can check if it's error if it's completed and etc etc so i have ctin which is calling my my cortines so i call my coroutine and immediately start because i there are two types of coroutines immediate and lazy javascript is using immediate coroutines so whenever you start coroutine it will start executing immediately python is using caz one so they are not started until you ask for the result in my case because i love javascript as i said and it's on record public record already i'm using immediate coroutines because as a javascript so my cor one coroutine will run until it's blocked because i need to download something i need to fetch something on internet so it will suspend but in color okay it doesn't know what to happen so schedule will learn about existence of my co routine and do something with it but i didn't coate on the result so i can start another co routine which is also immediate so i will call it it will run for a while it will suspend and i still still not coating on any coroutine so i can run another coroutine third one it will run it and it will suspend because i think so schul now knows about three coroutines three three started from the perspective sched and now i will run the col and now i'm coating on the result now i actually need the result for something but schedule sees three cortin which are all blocked or actually four because color be also coroutine which means everything is blocked so it must do some io so actually what it will do the color if i'm coting on blocked coroutine it will tell schedule complete something for me do something for me because i cannot do anything else so schedule will do the io and first ctin which will be finished i don't know which one let's say two will be finished and then when it's finished schedule everything is still blocked so schedule will get an complete something some io so it will finish cortin one okay cortin 2 is finished everything then i finally coating on cortin two and i'm moving forward now i everything on ctin 3 it's blocked and everything is blocked so i need to again ask scheduler and it will finally do rec in three and i i'm finished so you can actually start multiple like multiple jobs and actually do the slow work which is io network later so schedule type in my library is kind of easy you have two variables one is number of running task number of block task when i start coutin premise c promise i will tell sch that i'm starting so i will increment the number of running task when i do final suspend and select next from the cotin from the final suspend point i will decrement number of signing task and select possible next cor and if i call suspend and select next i will increase number of blocked co routines and select something else and select next yeah so here when i'm doing the final suspend that is the aor intin promise type i'm passing so if there is something i i'm giving hint to schedule that this can be run so select next will take the hint if there is any and if if it's there i will just decrement number of block task and around the now unblocked cortin because it's waiting on something which finally is there but if there is no hint and number of running task is different than block tasks what i will do i will return no opco routine which is special library thingy which will immediately suspend and like it's like return in c three it will just go back to like to de color as i did in the image when i'm blocked and everything is block it's not not everything is blocked something can be still around i jop to to color of my current c routine and then number of running task and block task are same so everything is blocked and i need to do the iio i need to i'm calling io and the io will return handle of theine which i associated with the handle and decrement number blocked and return thein i get and because this function will get the handle to someone was awaiting i will just jump into the find now unblocked cortine the complete i and cortin function i will get that later so enter li qu multi api how many of you with lip curl use multi api little bit less than with with eas because easy api is really simple multi api is a little bit more complex but it's actually really simple you have other handle you have like a multi handle which is like set of all handles you can add there you can remove and then you can perform on over the set of the handle and after you perform that you can actually wait for something to happen for iio and after the something happen you can actually ask the set if something was finished and it will give you information about first finished handle so complete io and lettin is infinite cycle which will call perform only multi api i did i ier to and if there something finished i will get a raw handle from it and extract the cotin handle from it and return return it and if something wasn't finished i will just wait for a io because i'm blocked everywhere and try again so when i'm when something is finished when i finally download something or it's time outed i will get a coltin which will wake up so fetch i'm yes i'm making fetch happen do you know a mean girls movie okay crickets nothing it's a it's awesome movie it's it's kind of full of memes you should watch it and i'm making fetch happen so fetch function will take your as a string because i'm taking the value and there is a number of attempts so i can actually try it multiple times and i will return content of the ur as a string so i have string with output i i have the easy handle with the auto with the ur i will write into the output string i will follow red directions i will try multiple times if there is no attempts left i will throw exception and there can be exponential back off but it's a slight rare but then i will try to coate on the perform which will give me delayer perform and it will suspend cent coroutine and do some it will jump some else until it's ready and then if i failed maybe i tried download only part of it i can try to just resume and continue like download big size yeah yeah sometimes it's useful sometimes it's not and if i got a response code different than http 2xx i will throw exception it's not available or s server error whatever and if i'm successful i will return the output to user and i made fetch happen so utilities around it you can also wait for if you have multiple promises you want to download multiple things like in javascript you have promise. all you can just take rench of promises and a return vector of results as a promise so you take the like value type of the arrange so what's what's it returning you will extract the result of the promise somehow and then you will just take premises and convert them into vector and because you need to m materialize the promises into some result type and then you will resort the output and then for each promise you will iterate and coate on the result and coron this itself is coroutine you can coate on so when uh the result is like when a result is ready everything every promise of the input is done ready you can do it also with like rench ring like optionals if you don't like ex exceptions you can like have multiple optionals and if all of them return success then you will get optional of the successes otherwise it will give you uh no op so it's similar but if some result will fail it will give you wrong optional it you will n opt and otherwise you will build same vector of results and return return it then you can have also this function but you can also have like all tech and create operator pipe so you can actually interrupt with ranges nicely so you can take just ranges of promises and just pipe it into all and it will just pipe it into this function same like different styles it optional and it internally it will just pass the range into the function and return the promise and you need to create object all because it's of object it's not like function just like pipe all and you don't need to use like any braces or parentheses nothing so everything together let's say if we have resource with eur and content you have function fetch resource which will take your r store it into the resource and download the content and return object containing address and content and then you have function fetch all which will take your return vector of resources you will coate on the you will download let's say web page with ctr you will extract all absolute links just you can pipe it into ctr then you can transform it because you have only your rs it will transform it into fetch resource which will download the resource oh create promise of the resource and then wait for everything to finish and it will give you vector of the res source downloaded in parallel yeah and if you want to write research engine i did in javascript you can search function you you can provide number of results you want you can just take the text you are searching for look for the sliding window of engrams you add also their position then download all the engrams you want with some function fetch engram and and shift the position then you can sort them by size because it's like it's intersection of interset of all like of all the chart so you want to start with the smallest one then you fold them left with first element as the first one with some function index in intersection which will just calculate the intersection you then you will f the results again because you got like all the occurrences document and position so you will reduce them to actually document id and count you can look for only partial sort of top and results resize it and return to user and you write your own search engine based on engrams which is download l downloading the index from web and hello world with c looks like this sorry you can download to commments wait for all go evate and use seure bindings and you have hello world thank you and 10 minutes we have time for questions so if you have any questions please shoot i maybe i will shoot you down but you can look for the library on my github and also you can play with the search engine on on my github iio pages no question at least some might be a stupid question if so i apologize no question is stupid don't challenge me okay regardless you implemented all to wait for the finishing of all co routines how would i go about implementing something like any to wait for the first one to finish of the ph yeah you can same style as like if you have like all routines you can actually write in jaas world it's called select i think which will actually associate to like final suspend point cortin which will like wait for them and destroy everything else and first to finish it's in the library it's not on slides because it's a little bit like lower because you need to like spoke around so it's not that clean but yeah it's there so that would require modifications to the schedular part and sorry would that if i understand that correctly it would require modifications to the schedular part yeah yeah schedule on slides is little bit easier than in library itself makes sense and it's still in the library it's not perfect because it's javascript i love javascript so it doesn't think that there is multiple threats yet so it's like single turnone it will be thre local sched i would love to have like schedu which will exist only for like call three of all you are running so it will be like a one context one c three but that would need changes in standard art okay thank you okay any other question yeah yes so you said you implemented it to perform the operations eagly no yeah it's immediate cortin so they will start immediately when you do something yeah and the iio itself will be will start when in moment when everything in new c three is blocked so it will run everything as as much as possible until you need to actually need to wait it was kind of hard to implement and like to like try multiple parts but yeah i think it's better than because then just start when you like cotin you are only waiting for because this will allow you to actually do parallel downloads parallel streams of downloads and in one threat and for business cl like business type of code usually don't need like multiple threads you just need like download 10 files and com combine them maybe yeah i'm i'm asking because in the senders receivers model they want to they advertise for lazy evaluation basically yeah because as far as i know that they also like running with thre pools and this is a little bit different like there are different models and what is colorful yeah yeah one question towards prematurely stopping co routines so for example in your search engine user just type the new letter i don't want to receive any of the previous search results anymore i want to now start over the search with my new search string yeah in that case if the c is currently not running which will probably not be case because if you called the search function it will start cting until it's finished but if you from like some s channel you can put some that like cancellation if you if you knew that ctin is not not running it's safe to call do destroy onit handle and it will safely remove like destroy all the object itself even like like recursively cortin reference it from inside so if detin is not running because it's not threat so if it's running it's running then you can safely destroy it okay and this is one threat so there is like actually like no one else like on side so with this model it will need some changes but it can be also kind of done but first you will need to like pa the schu and inside of sched which is outside of cortine to destroy the cortines okay and then also adapt minorly my code waiting for the promises to stop waiting for it and wait for the new you promised okay thanks okay so we have one question from the online audience is it possible to overload memory allocation either using custom allocator or pmr yeah yeah you you can provide any alloc allocator you want and it will implicitly use you can pass it as argument to premise type and you can that is operator new for the promise type and there is also like it can be done it's it's not that hard but you need to store the reference to your allocator inside of the premise type so you are also safely destroyed so you need to provide operator new and operator delete for your cortin cortin promise type and that's all okay thank you okay thank you it was fun and it's a great conference and enjoy like two more days of it yeah