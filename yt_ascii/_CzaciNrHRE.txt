welcome back everyone to asi fundamentals today we're talking about how and why to do startup and shutdown events in fast api and other asynchronous python applications this video is sponsored by myself my company does code reviews contracting and training check us out at m coding. all right let's get started with a basic fast api example here i just have some imports mostly that we're going to be using for later the only one that really matters for now is importing fast api and then we're going to be running our application using uv corn this is pretty standard setup at this point when we run our application there may be some things that we want to do on startup before we start serving any requests or on shutdown after we finished serving all of our requests with fast api you may be tempted to open up your autocomplete and let it suggest on startup and on shutdown for you that's wrong deprecated don't use them instead fast api also has these onevent decorators that you can use to specify startup and shutdown events like this also wrong also at okay okay they're not wrong they do work but they are deprecated the issue with this startup shutdown api is that startup and shutdown are not independent events i often want to reference things in my shutdown event that happened during startup and i also want to reference the application itself which in this case if i wanted to i would be forced to use the app global that's fine if you only have one application but if you have multiple applications like sub applications or just two applications running simultaneously then that can be a problem i'd really like a reference to the actual app the more modern way of thinking about it is that an application has a single lifespan that includes startup events and then eventually shutdown events in fast api the lifespan is defined using a single asynchronous context manager that takes a reference to the application instance most often this is done using the async context manager decorator from the built-in context lib fast api will run everything up to the yield as startup events and then everything after the yield as shutdown events you can of course define your own asynchronous context manager manually but the vast majority of people prefer the decorator approach so i'm going to stick with that in this video the way that you hook up your lifespan as the lifespan context for this particular application is by using the lifespan parameter to the fast api constructor that would look like this except of course lifespan is defined later so let's swap these things around there we go let's bring up a terminal and run our server as you can see we see the startup things was run during startup and then when i do a control c to shut down we can see the shut down things running after i control c so what kinds of things would you typically want to do during startup and shutdown during startup you probably want to log something then you probably want to initialize any long lift connections that your application might be using like a connection to your database to any aws services you might be using like s3 and to your caching service like a redus client in order to synchronize application settings like whether or not registrations are allowed at this time you might have some settings that are dynamic you could use startup as a time to pull down and initialize those dynamic settings at which time it's probably a good time to do some sanity checks on your settings so that you don't you know crash production and then you might spawn any long lived background tasks like something that collects metrics periodically every application is different so do what's right for you but these are some pretty common ones on shutdown there's not usually as much to do but of course there logging finalizing any metrics that you have and potentially emailing devops to let them know that a production server just went down hopefully an intended shutdown so this is how you can use a lifespan in fast api and this exact same code pretty much works for starlet as well but this series isn't just about how to use fast api it's more about learning the fundamentals and understanding what fast api is actually doing and how asgi applications in general handle lifespans let's try to understand lifespan events in general by writing our own application class an asi application is a single asynchronous callable that takes a scope dictionary defining connection details and two asynchronous cbles receive and send for receiving and sending messages by defining this thunder call method instances of this application class are ai applications see my previous video on application functions versus application classes to hear more when we run our application we immediately see that uvicorn receives a lifespan connection this isn't a connection with a client this is basically a connection with uv corn itself that encapsulates the entire lifespan of our application there's only a few kinds of messages that are part of this lifespan connection first we'll receive a lifespan startup event which is rq to start doing all of our startup tasks once we finish with those tasks we should either send a startup complete or a startup fail failed message you must respond to the startup message with either complete or failed if you don't then your application is going to be stuck and you won't even be able to kill it because as you can see here in the source of uvicorn the server we're using they capture signals so if you do a control c trying to kill the program if it's in the middle of startup uvicorn is going to capture that signal and wait until startup is finished it intends to rea signals afterwards but if there is no afterwards because you never finished your startup then you're going to be stuck just waiting and you'll have to kill it with kill minus 9 it's a similar story for shutdown you receive a shutdown event and you must respond with either complete or failed the lifespan connection is incredibly simple these are the only six messages that you have to worry about this is a complete list so let's see how to implement something similar to what fast api does let's start by just taking in and storing our lifespan context manager then let's define this hand handler handle lifespan that we'll use whenever we see the lifespan connection scope and let's just give ourselves a little bit more room in order to write this function the only two messages that we're going to receive are startup and shutdown so let's write those two receives after we receive the startup message that's our cue to start running our startup code which means we need to enter our startup context we enter that async context by using an async width statement passing in the lifetime and ourselves as the application instance entering the async context manager runs our startup code so if we make it inside the wid block then we successfully completed and we send our startup complete message once we send startup complete our application can begin accepting other requests in the meantime we just await receive until we receive that shutdown event python ensures that our exit code runs automatically when we exit the async with block so as soon as we do then we send our shutdown complete message and this is what i'd call the happy path if everything goes well then this is all the code but if any of our lifetime code throws an exception then we need to send a failed message so that our application can shut down nicely so let's add in a try indent all that and we need to catch all possible exceptions here including system acting exceptions so we do an accept base exception we do rease the exception so that uv corn can do whatever it needs to do with it on the way out though we send a failed message the question though is did we fail during startup or did we fail during shutdown well it just depends on whether or not we successfully started or not yet so we start out with started equals false and then if we successfully completed our startup then we've started so if we fail before we've started then it was a startup failure if we fail after we've started then it was a shutdown failure so we just fill that event type in here and we're done running our application once again we see that it acts just like it did when we were using fast api instead of our custom class we see our startup things here and then when i control c and scroll up to where that happened we see the shutdown things happened let's compare our implementation to what fast api actually uses just like we defined a lifespan handler both fast api and starlet both pass their lifespan events down to the router so we're inside starlet's router class here and it has a lifespan function which takes scope receive and send overall it's very similar we start out with a started variable we receive our first message we have an async with entering a lifespan context we didn't have anything about this maybe state i'll talk about that in a second we send our startup complete message set started to true and then await our shutdown message we catch any and all exceptions and depending on whether we've started or not we send a shutdown failed or a startup failed message otherwise we're in the nice case and we send a shutdown complete so what were some of those minor differences though the first thing is that because we're in the router class we can't pass in self here because self would be the router not the whole application which is what we want starlet appears to be getting the application instance out of the scope but in our case there was no application instance in the scope all we had was type asgi and state and the app is definitely not in there well the scope is just a dictionary so let's put it in there let's just go to our top level call function in our application and the first thing we do anytime we receive any kind of connection is put ourselves the top level application as the app variable in the scope now no matter how far down we are in calls as long as we have access to the scope we have access to the application and we didn't have to make it a global variable then if we wanted to we certainly don't have to in this case but we could do what they did and access the application through the scope the next major difference was to were actually using the return value of entering this context they called it maybe state i'll just use state what's happening here is whatever you yield from the lifespan so in here if i yield one 12 three that value becomes this state so what is starlet doing with this state well first they check whether or not you did return some state and then if you did return some state it looks like they're treating it as a dictionary and updating the state variable inside the scope okay so we can copy them if we want we can say if the state is not none then update our scope ignoring the error checking they were doing we can just throw that in if we want to copy them but what is the purpose of this taking a look at the lifespan event again the state that we're talking about here is actually this state that's appearing in the lifespan event so what we're saying here is that if you want you can yield a dictionary from your lifespan function and and if you do that dictionary will get merged into the state of the lifespan scope okay so i don't want to yield one to3 but so what what happens if i yield ab what's the point of doing something like this running our application again we see our state is empty when we print it out because we printed it out basically immediately before we actually did any of the lifespan events all we did before we printed it is add in the app variable which is why we see the app variable here we can start to see the purp of the state variable when we send our first connection that's a real connection by using curl of course we get an error because we haven't actually handled any http messages but uvicorn at least gives us the scope so we see all the details of our curl request and along with them is this state dictionary that contains exactly that a that we yielded this is the main purpose of the state variable in the lifespan scope whatever you put in there a shallow copy of it is passed to each and every subsequent request so if you wanted to you could put something like a machine id that you want to be copied and have available for every request but in all honesty if you're using an application class you don't really need this because of course i could have just stored the machine id on the application class if i really wanted to and finally i've saved the most useful piece of information in this entire video for the very end got to keep you watching somehow right or wait if the video wasn't useful you probably would have just already left well thank of it as a reward then remember uvicorn captures and cues up any signals that it receives during the startup phase which means that if there's a chance that something you're waiting on might wait forever then there's a chance that you might not be able to shut down uvicorn at least not without doing a kill minus 99 to prevent that possibility anytime there's a chance that something might hang forever make sure you wrap it in a timeout if you're in python 311 or later you have this really convenient async io. timeout or for earlier code use async i.4 same thing goes for shutdown and if you want your shutdown code to run even if there's an exception then make sure that you wrap it in a try finally as well that's all i've got thanks for watching and thank you to my patrons and donors for supporting the channel if you especially like my content show your support by becoming a patron on patreon and once again this video is sponsored by myself check out my company atm coding. we do consulting contracting and training