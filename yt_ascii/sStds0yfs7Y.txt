welcome to your daily dose of lee code today we're doing the question reverse link list let's read the question given the head of a singly linked list reverse the list and return the reverse list okay so what are the key takeaways from this the first one is that this is a singly linked list the second one if you see an example three we can be given an empty list and the last one we're already given the definition for our node and another nice thing is based on the problem statement we can calculate the best conceivable runtime or the bcr and the best runtime we can do is oven since in order to reverse the list we kind of need to visit every single node to do that okay now let's think about some solutions to this okay so the brute force way of doing this is what if we just turn this linked list into an array and then reverse the array and then turn the reverse array back into a linked list it's not the prettiest but it gets the job done alright let's write the code for this okay first things first let's check if we even have a head node if we don't then return none if we do then let's get started let's make our array and then let's make a a variable called current and this will be a reference to the current node that we're on and now let's loop through the linked list where every time we visit a node we're just going to add it into the array and then once we're done let's reverse this array and then let's create a new node based on the first element of this reversed array and now change our variable current into the head of our reverse link list and then we're going to loop through the array where every element that we see is going to be the next pointer to our current list and then by the time we're done we have our reverse list so just return it the time complexity for the solution is surprisingly o of n since all we're doing is just iterating through the list multiple times and at least for python reversing this array takes them all then so being specific it's probably like all of 3n something like that as for the space complexity it's all then since we had to make the array and that takes up all n elements and then we had to make the reverse link list which is also another n elements but even though we got our ideal runtime we can definitely do better since if we did something like this in an interview you i mean we solved the question but they'd probably be like tried it and then they'd ask you can we do better as a follow-up question now lucky for us if you notice at the bottom of the question there's a follow-up and it says a linked list can be reversed either iteratively or recursively could you implement both and the answer is yes because i'm here let's do the recursive way actually because that one's a little bit more tricky at least to me but before that let's go over the strategy for this so instead of worrying about the nodes themselves let's actually worry about the pointers since if we implement this correctly all we really have to do is just reverse the pointers not the nodes themselves so how can we do this recursively well whenever we think of things recursively we have to think of the base case and then the recursive case the base case for this situation is one if we weren't given a list so there's no head or if we're on the last note in our list and since we're worrying about the pointers there is no next pointer if we hit our base case then we're just going to return the head now let's think about our recursive case when we call this function we're going to get the end of the list so from then we're going to work backwards where we start at the end of the list and then we end at the beginning but for the recursive case there's going to be three steps to it the first step is to reverse the pointer the second step is to detach the reverse node from the original list and then the third step is just returning the new head which is our reverse linked list let's do an example for this since it is a little confusing so let's say we were given a linked list of one two three four five let's check the base case do we have a head and do we have an x pointer we have both so let's move on so we're going to call the recursive function again and this is going to happen until we have five because it hits the base case that there's no next pointer so we move up in the recursive stack and now we're at four so in our code we're going to have a variable that keeps track of our current reverse linked list which is based off the results from our recursive function and currently it's at 5 so now we're going to reverse the pointer and this is where it's a little weird so remember our head is currently four so what we're gonna do is head dot next dot next equals head the reason we're doing this is because ed is currently the second to last node in the list and head.next is the last node in a reverse list that we got from the recursive call so by saying head.next dot next equals head we're essentially moving this current head node into the end of the reverse list it's a little confusing but it'll probably make more sense as we keep going through the list okay so now that we reverse the pointer which moved this node into the end of the reverse list there's currently a cycle going on because this is still connected to the original list so all we have to do is just detach the pointer by simply saying head.next equals none we're not pointing to anything anymore and now that we finished all our three steps let's just return the reverse list that we have currently and we were at four so now we move back up and now we're at three so now we're gonna do the same thing first we reverse the pointer so now we'll do head.next dot next equals head and remember head.next is currently four but we changed four four is now the last element of our reversed list from the last recursive call so when we say head.next.next we're actually making four point to three since it's currently pointing to none since we detached it okay so now that we've reverse the pointer next step is detaching so all we do is head dot next equals none and then the last step is just returning the current reverse list and now we go back up to two and then we do the exact same thing so now we've reverse the pointers where we say head.next.next equals head which is just making three point to two and then now we're going to detach this reverse node since it's currently doing a cycle and then we're just going to return our current reverse list and now we're back to one so all we're gonna do is make two point to one and then detach the current node's pointer to stop cycle and then we return the reverse list and since there's no more recursive calls we're done this is the list okay now that we're done with that let's finally code this up first thing we code is our base case which is if we currently don't have a head which means an empty list or there's no head.next which means we're on the last node if we hit this case then just return the head and now we move on to the recursive case so we'll create a variable called the reverse link list and that's going to equal the recursive function which is just self dot reverse lists and it's going to be head.next and now we're going to do the three steps so first step reverse the pointers so head.next.next equals head second step detach the pointer to prevent the cycle head.net equals none and now we'll return the reverse link list now you're gonna hate me for this the time complexity for this is o of n and the space complexity is technically o of n because we're making n recursive calls which means this method is technically as efficient as the first one we did but if we're being really picky this one is a bit faster so sorry about that but that's how interviews work you can't get what you want okay now last but not least let's do the iterative solution this one's way easier i promise we're still gonna use the same idea of just reversing the pointers but instead of a whole recursive function we can just use one variable and this variable will store the previous node and this makes reversing the list really easy since all we have to do now is just switch the current pointer to the previous node and we'll keep doing that throughout the whole list and by the end of it the previous node will have the reverse list so let's code up the solution alright so first thing is let's make our previous variable and it's going to be initialized as none and then we'll make our current variable which is just a reference to the current node that we're on and now we're going to go through the list and the first thing we have to do is make a temporary variable for our next node and we have to do this because since we're changing the next nodes pointer we're gonna lose the value of the next node all right so the next thing we do now is say current.next as you previous which means we're just switching the current node's pointer to the previous one and now we're going to move on to the next element so we're going to increment our pointers so previous is going to equal current and current is going to equal the next element which is our temporary variable and by the time that's done we reversed our list and that's going to be in the previous variable so we're just going to return previous the time complexity for this solution is o of n and the space complexity is of one since we simply just change the pointers in place alright so that's the three main ways of solving this problem so if anyone ever asks you this you will be ready i'll see you guys in the next video so see ya