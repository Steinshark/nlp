this is a list comprehension that allows you to define one list in terms of another list and is reminiscent of set notation from mathematics the elegance simplicity and power of this notation makes it in my opinion the best feature of python now what does it mean to be a best feature of a programming language to me it's a feature that makes you fall in love with the language and the feature that makes you enjoy programming in the language for many years so the basic notation is a for loop over some input list nums and a function like f of x that computes something for each element x in nums in addition there's a filter conditional like if g of x some function some expression that filters the elements of nums and only keeps the ones that pass this conditional let's look at an example input list nums one two three four the list comprehension squares each element of nums so x times x for x in nums and so that creates a list that contains 1 4 9 and 16. simple beautiful and now to add a filter to keep just the even numbers we can add into the filter conditional the list comprehension x modulo two equals zero and then the result is the squaring of the elements that pass the filter which is four and sixteen now some would argue that you can achieve the same kind of results with for loops or more direct comparison is the map and filter functions which are also available in python so what would that look like to square each element in the list you could have a lambda function that does the squaring and a map that applies that lambda function to each element of nums that's the second line the code here and the third line you can add a filter to that so first apply a filter with a lambda function that does the module two equals zero conditional and then on top of that on the elements that pass the filter you again do the map function of the lambda that squares each element now i believe this is also beautiful and powerful notation but to me it's not nearly as elegant pythonic and readable as the list comprehension notation i already did a video on the most controversial python feature which in my opinion is the wallers operator it comes into play nicely with list comprehensions now if we take some difficult to compute function like fibo here which computes the nth element of the fibonacci sequence the one line ternary operator implementation of the function written by me untested i'll leave it to you as homework to test if this actually works and i threw it in there to give a shout out to two other things i enjoy which is recursion and the ternary operator the if else notation of which in python i think is another beautiful design choice that makes an otherwise cryptic looking ternary operator actually readable to our human brains and so if we take then another definition of numbs that goes from one to six we can create a basic list comprehension that applies the fibo function to each element of nums resulting in the familiar fibonacci sequence of one one two three five eight now if we wanted to also add a conditional which is where the walrus operator comes in we can compute fibo x and assign it to the variable y via the walrus operator's assignment expression and then do the modules 2 equals 0 check to keep just the even elements of the fibonacci sequence and then in the actual output of the list comprehension we can just use the variable y as opposed to recomputing the fable function so the result of this list comprehension that uses the wallace operator is 2 and 8. so list comprehension actually creates a list objects computes all the elements in the list and stores the entire list of memory while the generator expression stores just the iterable object and computes every element in the list one at a time as it's being queried so for most people the list comprehension is probably the default choice it's used when the size of the list is not crazy large especially when you want to reiterate over the list multiple times it is faster than generator expressions depending on the context it could be two to three times faster so speed is essential you want to use these and if you need different list methods like especially the slicing notation you should be using list comprehension on the other hand you should use generator expressions when the range of the sequence is large or infinite or if you want to construct iteratable generator objects which are great to impress your friends with i should mention i'm really grateful for the sponsors that support these videos and the podcast in this case eight sleep so if you enjoy these click the links in the description to get a discount and to support my efforts thanks for listening and remember try to learn something new every day you