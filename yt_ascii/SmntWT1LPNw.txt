rust manages memory with an ownership model which is quite unique and really powerful but what is it exactly and how does it work and why do we need it why can't every language just do what python does we're going to find out today you may also wonder is arion codes now becoming a ross channel i didn't sign up for that don't worry i won't turn this into a rust channel actually i don't really see it as a python channel either that just happen to be the language that i started with it could just as well been typescript or java or visual basic somehow i don't think the channel would have really worked out if i had picked visual basic mostly because i would just go completely insane anyway regardless of the programming language you use even visual basic you need to know the ins and outs and be able to read code and identify problems if you want to learn what to look out for check out my free workshop on code diagnosis this teaches you a three-part framework to look at code and detect issues faster it's about half an hour and very practical to join just go to iron. go/ diagnosis the link is also in description of this video the rust ownership model has three main rules the first is that each value in memory has a variable which is its owner the second rule is that when an owner goes out of scope that value in memory is dropped the memory is deallocated and the third rule and that's the most important one is that there can be only a single owner at a time and these strict rules tools are what allows rust to manage memory so efficiently it detects many issues already at compile time the resulting code is often as performant as code written in c sometimes even more performant and it's an incredibly robust solution to the memory handling problem however the consequence is that as a ross developer you need to be explicit about ownership and make sure that it's dealt with properly in your code let's take a look at a few examples here i have a main function that declares a string and assigns it a value then i assign the value to another variable from s1 to s2 and then i try to print s1 you already see that there are compiler issues here so if i do cargo run then it's going to compile but we see that we have an error namely we borrow a moved value so this is precisely the kind of issues that you can run into with rust so we have a variable that points to a value string that's being stored on the heat it's dynamically allocated and then here what happens is that we move ownership from s1 to s2 and that means that after that s1 is no longer the owner of this value in memory and we can't use it to access that value this is not allowed what i can do is use s2 when i run this program now you see it runs without any issue what you can also do is that instead of here in this case where we move ownership from s1 to s2 by performing this assignment is to borrow the value that s1 points to and that's what you see here that's by using a reference so we still have this s1 variable that i also declared here but then s2 is a reference to a string and that contains a reference to the location of the value that s1 owns so in this case s1 still owns the value but s2 borrows it and then you can use either s1 or s2 to print the value so here i'm still using s1 which is still the owner of that value so you see that still works but you can now also use s2 because it borrowed the value but it didn't become an owner so both work in this case another difference between python and rust is that in rust by default things are not mutable you can't change the values if you want to change the value you need to put the word m from mutable in front of the variable name so that's what i did here and now because s1 is mutable can change it for example i can do s1 do push string which adds a string value to s1 so we're mutating it if i remove this mod keyword then you see that the compiler now gives us an error that s1 is immutable so in order to change s1 we need to make it mutable and by default everything is immutable and the same goes for references so here i have s2 which is a mutable reference to s1 and then i can also use s2. push string and then at the string if i remove this mutable part here you see that we get an arrow here that s2 is not mutable so let's put the keyword back there and then when i run this you see that we get the modified string so let's go to the next function here we see an example that shows you there's a limitation on the number of mutable references we can have to a value because in r you can only have one mutable reference in this case s2 is a mutable reference so we can change the value through s2 but if we try to declare s three also as a mutable reference we can see that we can only borrow the value as mutable once so this doesn't compile so rust doesn't allow for multiple mle references to the same value and that's because of memory safety because if you can modify something from different places that's going to lead to all sorts of issues this is one of the key ways in which rust ensures memory safety without using a garbage collector but it does mean that as a developer you need to be aware of these limitations in the lang here i have yet another variety of the main function let me run this as well so we see this runs without any issue what's happening in this version is that we still have the s1 string but now i'm using clone to create a copy so now there are basically two values in memory instead of one rust has traits which is a bit like protocols in python but they are checked at compile time and in this case there is a clone tra that tells ross that some object has a clone method in this case string has the clone trait so we can call string. clone and so this creates a deep copy so we now have two values and if we modify s2 it doesn't affect s1 because that's simply a different value in memory and here's a final example so this also works if we on this this prints hello so this is by using slices so slices allow us to have a reference to a part of a string and you can see the type here also looks different it's s strr that means that this is a string that's allocated on the stack and you can see that because we take the slice we know the length of this so we can actually store it on the stack because we know the length so we can allocate it there we don't need the heap and that's why a slice like this is of type s str which is a stack based string versus string with the uppercase letter which is stored on the heap and then when we print this you see that it prints the first five characters here's another example of stack allocation so we have a main function that declares variable x and variable y these are integers and then we simply print them so if i run this then this is what we get x = 5 yal 5 straightforward right but here this is allocated on the stack so this is unlike the string with the uppercase character it's allocated on the stack and that means that whenever we use these values like here for example i assign x to y that this creates a copy so what we saw before with references mutable references borrowing values that's only on the heap on the stack everything is copied and that makes it fast but it can also have performance issues if you need to copy around large objects but with basic values like integers or floats it makes way more sense to use the stack instead of the heap for them here we have again the string example from a few minutes ago so this is heap allocation so this allocates string on the heap and then this assignment doesn't create a copy but it moves ownership so that's the key difference and like before if we move own ership here then we can't use s1 anymore what happens behind the scenes is that the value the string value is stored on the heap but the pointer values the memory addresses are actually stored on the stack in the examples onto now there was just a single main function where things start to get a bit complicated with ownership is if you start having functions calling other functions that need to pass values as arguments so here we have an example which has a very simple function called do something i'm not sure what the empty space is here but it gets a string a heap allocated string and then it's going to simply print that value and then i have a main function that declares a string and calls this function when i run this code there is no issue but if i then try to print the string after i do something with it you see hey now we have an error why is that because well s1 got moved the ownership got moved to the s value here because this is a heap allocated value so the ownership is moved here and now you see that we easily run into problems so one thing that you can do is use a reference instead of an actual heap allocated sy and then we also need to supply a reference here and now we see that this works because now we didn't transfer ownership we simply created a reference so in calling other functions this is always something to be aware of and in this case actually there's no need to use a heap allocated string value you can also use the stack for this because we know the size of the string so now in this case this still does exactly the same thing in simple cases like this the rust compiler can easily infer ownership and how long the lifetimes are of these various references and values that are being moved around but there are some cases where rust can't easily infer how long a reference should be valid and for that you can use lifetimes which are a way to tell the ros compiler how long a reference is valid and here you see an example of how that works so lifetimes are indicated with values like this you can give them different names if they have the same name they have the same lifetime so here i'm using a lifetime label a and this means that the value that's being input here as an argument has the same lifetime as the value that's being returned as a result and you can have multiple lifetimes so here i have an lifetime a and a lifetime b and this part means that b's lifetime is at least as long as a's lifetime so you have some flexibility in how you deal with this so now now if you run this code you see that prints the longest string is hello world and that's simply the the result of this main function but i if i remove this indication like so then i try to run this again you can see that the compiler gives me an error that it can't infer the relationship between these two lifetimes so you have to show this explicitly now lifetimes are not something that you're going to encounter every day this just in some cases you may need them when you write rust programs hopefully in the future we can get completely rid of lifetimes and rust compiler can actually infer it in all cases that would be ideal but for now we still have to do this from time to time talking about lifetimes if you have a lifetime passion for programming you might want to join my free discord server link is down below there's lots of nice discussions there about programming software developments in general so overall the nice thing about rust's ownership model is that this is being dealt with at compile time and that means that while you're developing though you don't have to explicitly think about deallocating memory you still have to follow certain strict rules related to ownership and the nice thing about that is that it forces you as developer to think about how you're using memory and what i've learned i've been actually working on another side project for a while developing a tool in rust just to learn more about the language and what i've learned is that this actually leads to better design because when you're not dealing properly with memory when it's unclear where a value belongs and how you're moving it around it's can often be a sign of bad design so if you run into a bunch of ownership problems instead of creating copies of everything you may actually also want to rethink your design so that it fits better with the way that you're using memory i thought that was a really interesting thing that happens while i was working bit more with rust so there's definitely a learning curve here i just scratched the surface today of rust ownership model because otherwise this video is going to be way too long i do think it's very powerful i like that this happens at compile time so it allows us to create much more stable robust programs without losing in performance so overall rust's ownership model is a powerful tool that allows us to write fast typ safe code we don't have to worry about manual memory management and there's also no overhead of an automatic garbage collector the ownership model is a big part of what makes rust different from other languages and that's also why it's such a great language for system programming but i'd like to hear from you do you have experience with rost ownership model did you play around with it what did you think were you comfortable using it after a while did you notice there were some patterns or behaviors occurring after using it for a while let me know in the comments below recently i did a few other videos about rust as well in particular if you want to learn more about how rust compares to python and where it difference next to the ownership model that i talked about today you might want to watch this video next thanks for watching and see you in the next one