one of the biggest roadblocks for new embedded programmers is hardware with a confusing amount of options available none of which are free getting hardware to learn on is often a hard first step to overcome luckily with qmu or kimu you can skip the hardware and learn embedded code right on your desktop in this video i'll show you how to set up an embedded rust project and run the code without access to a development board before we start hit that sub button to be alerted when i put out new videos like this on a weekly basis so to get started here in our no hardware rust embedded adventure step one we have to do a little bit of project setup to set up our project we're going to use this repo here the cortex m quick start github repo underneath the rust embedded user on github so this project is a cargo repo that is set up with a bunch of dependencies to be able to quickly produce binaries that are able to be ran on the cortex m0 or 3 processor luckily this project also has roles in the cargo files to do qmu emulation with those binaries if you don't have the board so i'm going to show you guys how to use this repo and get it set up to do that kind of development so we'll do git clone on that repo and i'm going to call it rust no hardware because that's the whole point of this video clone that down should clone pretty quickly it's actually pretty lightweight we'll go into that folder rust no hardware and run sublime in that folder so there are a few changes we have to make to make this project able to be ran as it currently is set up right so to edit this project we need to add a few things step one is the author so the author is me i'm always the author of my own code obviously and then name the project something fun like app you know very very boring normal title okay take this app here and also copy it down in the bin area to the name of your binaries call them app as well so with those changes you can actually build a program right now that would build for the cortex arm m3 processor we need to actually check out what program we're building right so if you go to the source folder here and go to main dot rs we're gonna kind of walk through line by line what this code is doing this is actually pretty different than normal rust if you're only used to building rust for a regular like linux environment there are a couple major changes to the structure of the program and we'll walk through them line by line so line one here normally in rust when you build a program you use the standard library the standard library brings in lib c and all this other kind of you know not bloatware but just heavy code that normally an embedded ship can't handle so by saying no standard we replace the standard library with the core library kind of a more lightweight version of the rust back end then we say no main normally when we use the standard library it looks for a main function and instead we're going to say hey we don't necessarily need a main function we'll take care of that elsewhere line five we are setting up a panic handler so when the board has a panic and an event that it can't handle by error handling we need to tell it what function we're going to run and on line five we say use the panic halt function that comes from the cortex-m lab then we do two dependencies cortex-m-sem for you know assembly inlines like assembly knob and then line 12 we use the cortex m entry point idea right so on line 14 we actually use that entry so before we said we don't go to a main function we will specify the entry point of the board on line 14 we say hey the entry point the first function to be ran is this main function here on line 16 we run an assembly knob to kind of give main some code to contain and then we end it with an infinite loop because in this you know embedded programming the board doesn't exit it just runs forever so if our code ends we get to this infinite loop state that's also seen here on line 15 with the returns exclamation point and russet actually means that the board does not return it it just doesn't that's like the no it's not a nun type but it's like a none so we want to actually make this code do something more meaningful so we're going to actually get rid of the assembly dependency here in line 16 and then we're going to from another you know dependency we're going to say use vortex m semi hosting so this idea of semi hosting is what we're doing here where we're building the program for a different target you know like a cortex m processor for example but with the idea being that we're going to run it locally that's the idea of semi-hosting and within the semi-hosting library there are two things we need the first being debug and the second being host print line that's a macro by the way and we'll put a semicolon at the end of that line the debug library allows us to do things like exit or return from the board which in embedded doesn't actually happen but when you're semi-hosting you want to be able to say hey at this location end of the program cleanly just just wrap it up and then h print line is host print line which says if you're doing a semi-hosting environment where you are hosting it in an emulated environment on the host you know forward to the host a line that you're going to print to standard out so that's kind of the idea behind semi-hosting so here we're going to use that host print line function and it's actually a macro so we'll end it with an exclamation point and then treat it like a function kind of like printf and we'll say hello world exclamation point new line and then don't forget as a standard rust ism have to unwrap your result to make sure that it didn't return no value and then after that we're going to do our semi-hosting debug we're going to call the exit function and we're going to return the exit success value and again all this does is in the event that we are doing a semi-hosted environment in kimu this will end the program here as opposed to going into an infinite loop right so that's that's kind of useful if you're doing something that you are running in an emulated environment so now that our project is set up and we have some code to run the next thing is how do we build this code so first off like i said before this is getting built for a cortex m0 processor you need to make sure that you have the build chain in rust up to compile down to that architecture so to get that we're going to do rust up target add thumb v7 none e abi so we're going to copy that target to our clipboard and we're going to run this command i already have this build chain installed but for you guys if you don't you know it may take a second to pull down the build chain and get that put into your your rust up you know package handler so once we've done that now what we can do is tell cargo to build and build it for the target thumb you know that target up here and once we do this what'll happen now is cargo is running through the configuration file the cargo.toml and it's running through all the dependencies and figuring out what dependencies and subdependencies it needs to be able to build our program so after it goes through it builds these it compiles them all it'll finally at the end of the program you know spit out our binary and i'll show you guys what that looks like when it's all wrapped up awesome so now that we've you know built our program finish dev notice that there are no errors we can actually go look at our program by going to target thumb that's the target name and then debug that's the release we're doing and then here file app is our our program right this is the output of our program and it's a 32-bit elf compiled for arm abi v5 what we can do is we can use the arm regular build chain the not not the rust build chain we're in a flat binary now not a flat binary but we're in a binary format now we can use object dump to dump out the application and kind of check out and see what it's doing so here in object dump we see that we have the reset vector you know this is when the board starts up it does something and this is it setting up the board using the cortex m3 library and eventually once we get done resetting the board and getting it all set up we go to our main function we can go to main and here is where our main happens and eventually you see that it calls the semi-hosting you know standard out print function so pretty cool now you know we have this program but in this video we don't have a board we have no board we can compile it to luckily this project you know the cortex m quick start project has a little little hack we can do to run the program without having the board if you go to the config.toml file you'll see in the description for the target we're building for the thumb v7m we actually have a hidden runner command here so again in rust runners are things that instead of you saying cargo build you say cargo run it will run this program we're going to use the kmu system arm with the cpu being set to the cortex m3 to run our program without actually having the board so that's pretty awesome go check that out real quick so we do cargo run attack tac target this target and you see here it gets done building it again and then it runs our program with that command and we see hello world being ran so that's pretty awesome we're able to run our program without actually having the board but what does that actually do for us well in the event that we wanted to try to do something new that may break we need to have some kind of introspection on the board to figure out what's breaking or what's hashing so qmu actually has a really easy interface for using gdb in our functions or in our programs we can go over here in the qmu command line we could say tac gdb ecp double colon three three three three that's gonna be the port it listens on and then we can also say attack s so what the capital s does is it's it freezes kimu when it starts up but so we can connect to it with gdb so we'll kind of test that out real quick we'll do the run again i didn't save the config file we'll do the run again cool so now it's hung it's waiting for us to connect with gdb and then in a new window we can say gdb multi-arc and then our app so it's loaded our app into gdb and now we're going to do is say target remote local host actually we do tcp double calling back slash localhost one two three four that's the port we specified in our command over here cool so what we've done now is we've connected to our target localhost 3333 we are in the cortex mrt reset variable the reset function because again the board is in a frozen state and now we could debug it if we wanted to right you could say lay next we can get kind of the functional rim with in rust we can do lane next and get the assembly version of that we can get the the register state we'll just type continue c and eventually the program runs and over here on the left we get hello world because the program ran and then exited so this is pretty cool i think if you're new to roster you want to kind of learn something embedded but you don't want to just go back to c you want to learn a new thing i think russ is a good place to start a lot of times people have a hard time getting into this realm because they don't have the hardware to do it so by using qmu you can get into it pretty quick and i think this project here the cortex and quickstart is a good place to start so if you guys like this video or you learned something do me a favor hit like hit subscribe and go check out the video linked here we'll see y'all in the next video take care bye