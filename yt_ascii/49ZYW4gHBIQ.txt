hi my name is niik and let's talk about views no let's talk about one view we have introduced a new technology in c++ 20 it's called views and there are a few things you should know about it and we have a couple of views a couple in c++ 20 even more in c++ 23 well there are a few issues you should know about this while in the past i have mainly complained now let's just look at one specific view and see how to use it right or what are all the essense and all the things you should definitely avoid and that is let's look at the filter view and how to use it because that's one of the most important views we have we want to filter elements of a collection i think that's a pretty common use case and you should know how to do that and you should especially know what not to do so this is a view no this is a vector this is a container and this container let's print the elements of this container i hope you can see it in the back a little bit so that's all the elements we can print and i have here another container let's use a set and let's print all the elements there so far there are no views that's just common code and we can print this and we can apply and enable this code by having a print function that takes a template parameter a generic collection iterates over the elements of this collection and prints out the elements with a space inside and at the end a new line so far that's code you all know so in c++ 20 we have the ability instead of using template parameters to use all auto and to qualify auto with some constraints like for example here saying it has to be arranged we iterate over and we read the elements so it's an input range we read only once so that's fine good so now let's look at views we have a feature called take for example where we can say let's take from this view the first three elements all let's take from another view three elements and while this syntax requires nesting there's another nice syntax which means let's use a pipeline for that so that say let's print out all the elements of collection one piped into the take into a view that takes only the first three elements and do the same for the second view by the way if you wonder why with the second collection the elements have different order it's a set which internally automatically sorts the elements so and we can combine these filter elements and these pipeline elements and say let's take the second collection only the first three elements transform the elements to convert them into strings and then append an s and let's print all these elements so pass that the whole thing to a print function and here it is that's the output so that's the basics and the cool basics of c++ views so there are a couple of other examples this is a nice example let's iterate over a map a map is where the elements are key value pairs so let's have a couple of composers of classic musics and their year of birth so we map the name to the year of birth and so let's yeah let's iterate over yeah let's iterate over some of them well let's only iterate over those who were born after 700 and i also only need the the names so yeah let's pass so let's on the right hand side of the range based for loop use not just the composers apply a filter and that's a filter view looking at the second element which is the name the the year of birth whether it's greater or equal 700 let's take the first three of them and then let's take so because the elements are key value path let's take only the names and that's it yeah and that is where we iterate over with this range based for loop so an ad hoc what we ad hoc create create is yeah a view on this components filtering out only some elements filtering out by value filtering out by position and then taking only part of the elements to to transformation convert the pair into just the keys last example let's use an iota view which is cheap container to generate numbers starting from one so one 2 3 4 5 let's have a filter so that we only allow to use multiples of three let's drop the first three elements let's take the next eight elements let's have a transformation with the elements and then pass a whole view on the right hand side of a range based for loop so that's the result 12 15' until 33 seconds we have here yeah eight elements first three skipped and on the m mul of three cool great technology everybody loves that how does it work it is important to understand how this works so because this is for example not working like a unix pipe this is totally different and the approach is roughly as follows if we have a vector then the key api we use each and every container and every collection and every range we have is we have an interface where we iterate from beginning to the end over all these elements so if we print out the elements what we have to do is let's initialize an iterator with the begin and start to iterate with plus plus over the elements as long as we are not at the end and with star we go to the value so we iterate with the position with star we go to the value and that is the key api we are using here of a container and we having this api since c++ 98 it is one i it's probably the key reason for the success story of c++ because we have one way to be able to deal with all these different containers because at the end you iterate from beginning to end and that's also in finally called by the range based for loop now please note what we do here step by step so for example we asked for the collection for the begin and then we get the position of the 47 then we go to that value print it out and with plus+ we go to the next element with star we print it out with plus+ we go to the next element and so on and so on and so on this api we also want to apply to views so now let's instead of printing all the elements of this vector let's use a view well let's use two views here so one is that we take the collection and pipe into a filter view and that's what we talk t today talk about and that filter view says let's only use elements which are m which are greater than 10 no less than 20 okay it's similar next later slide i have greater than n don't know okay so less than 20 okay and then pipe the whole thing into a transformation negating all the elements just as one example so here's how it works as i told you the pipeline is just a short and and special syntax of the following that we say let's apply the filter view on the collection applying the filter that filters on the elements that are less than 20 and then on that view we pass that view as input to a transformation view as saying now and if we need each value let's negate the value so that is the pipeline is just another syntax for what you see here the interesting thing is as you see on the right that each view does not create elements as we would do it in unix if we have a pipeline so we generate values the values are store in a que and then comes the next part of the processing we don't create any element yet we just describe and specify how we want to process the elements so all we have created is roughly this data structure you see on the right we have a collection providing the usual api to iterate over elements on that we wrap the collection with the view the only information inside the view is we need a reference to the underlying collection and then the predicate so how do we want to filter and at the outside again we provide the usual api of having begin and and for the iterators plus+ star and equals equals and so on and the same we is happens if we now use a transformation it's again a wrapper on that view and that means let's negate all the values so let's iterate from beginning to end again using the same api as we have used before in print to print all the elements of a collection so that is the situation we have here nothing has been processed yet we only create a data structures now let's start to iterate and that is the moment we create values and we print values and we deal with elements so at first let's call begin so we call begin for v2 for the transformation view that begin call goes to begin for the filter view that call goes to begin for the collection and the collection says okay you want the first element yes here it is it's the position of 47 it's an iterator it's not the value it's a position of 47 so this position comes to the filter view and the filter view looks at that and says you know what i only allow certain values so i need the value so what the filter view now does it says oh it called star to say here let me go to the value and then it looks at the value and says that's not okay so i need that's not an element i can accept so i it goes to that view and says plus+ and with that plus+ we get the position of the next element here in the filter with star we again look at the 11 and that is okay so two things happen here the filter is a little bit tricky and therefore also a little bit expensive and more expensive than other views the filter to to deal with elements needs both the position an iterator and the value because it has to decide whether to let it through so with that information what does the filter pass to the rapper not the value it passes the position it only needs the value to know yeah yes or no i use it so we are we are still at begin for the transformation transformation is still waiting for the first element and that is what is coming back here the second element is coming back to the transformation the transformation just passes it through to the caller so the caller gets the position position an iterator that indirectly refers to the second element of the collection that's then the state okay so we want to print out the value we just called begin and now let's print the value so we go from our iterator we got back from the transformation and say let's start so go to the value that has delegated the q up and says but wait a minute when we go to the value then the transformation says something oh wait a minute when we need the value i have here something to do with the value so let's negate it so when you want to have the value i negate it and that is a value that comes back with the star operation and we print it out so that's it you see a couple of things here so for example begin might be become very expensive so think about the first 1,000 elements are greater than 20 so we iterate over all these elements look at the value and that takes time that's a linear operation if we double the elements that are greater than 20 at the beginning of of that collection it we double the performance the the the time it takes to find the begin so begin can become pretty expensive and which is new so far before c++ 20 we didn't have any container where begin was expensive so okay we have it let's go to the next element that is again propagated through all the views to the collection that goes to the next position so we had the position of the 11 so now we go to the zero filter looks at the value value is okay filter gives that position to the transformation transformation says yeah i give it back because it i only care when we look at the value it comes back but when we then look at the value transformation says oh and by the way let's negate the value and that happens so on and so on so next time we call plus+ from the outside the filter calls plus+ twice because one element does not fulfill the requirement and then at the end when we call plus+ for the last time then yeah we jump to the usual end or it's not clear that we we logically get this position but at the end that means that this view returns something that is equivalent to end its end it returns its end it says that's it and that is here now the end of the whole collection so the loop if this is step by step what we do in a loop at the end the position is at the end so we have done our iteration okay good perform performance we have to talk about the performance of this we are un into trouble as we have just discussed if there are 1,000 leading elements begin suddenly becomes expensive so we have to deal with that in some way how how expensive is this is begin that's one question we have so let's look at it and let's use for example a simple example and say let's have a filter on a vector so and in this case let me start with a different view that's a drop view that's simply a view that says let's skip the first three elements okay we call begin begin goes to the vector and then well because of drop drop says let's ignore three values but fortunately we don't have to call three times plus+ because we have a vector inside so a vector allows random excess so we can jump directly to the fourth element but that is what what is happening under the hood even if we go to the thousands element it would not be very expensive to call begin here just two cards so in a list it's different if we have a list the problem is we don't have random access there so if we have say we want to drop the first three elements that means we have to three times three three times call to call three times i think that's correct english three times plus+ and of course you'll see that this is significant more expensive again if we go if you drop 1,000 elements this begin becomes incredibly expensive well incredible there worst things in programs but it matters so begin is cheap in this when for a drop on a vector begin is expensive for a drop on a list and the key question is do we have random access can we jump ahead and elements and and if yes as we have for vector that's cheap if not that's that's expensive okay now let's come back to our example we want to talk about a filter now some people seeing that slide and some programmers seeing that slide says okay so i should use a vector only as a container and i'm fine with performance well no yes if we if we have a list and instead of drop we're using a filter now my the example is greater than nine so let's call begin we cannot com we we have to look at each element and find the first element that is greater than nine good this is in this case also the fourth element and so three times we call plus+ similar to the drop example but with a vector this time it doesn't get better because as we have discussed we can only know whether which one is a is a fourth element if we look at all the values of all the elements so we have to inspect all the values and that means we have to go plus plus plus plus plus+ and i should maybe even tell here that together with plus+ we call star so we even look at the value of this element to decide whether this is the right position or not begin becomes expensive so even for vectors if we use a filter view so in in in fact if you use a filter view it's always expensive because we have to look at each value of each element to decide which one is the false value or which one is the first value that fits or whatsoever there is some rumor that c++ cares for performance and therefore we have the standard template library saying you know with some iterators you might be able to call push front with some you can't depending on whether it's cheap or not with some iterators you can jump ahead three elements with some you can't depending on whether jumping ahead three elements has good performance some containers provide the index operator some do not depending on whether the index operator is cheap and the same principle applies here we want to protect you from bad performance one way is we teach you all the other way is we don't let you program bad performance so let's look h okay when we have a vector and we want to drop n elements let's look at some of the typical things we might call for the container as a whole so let's call begin let's call empty let's call size let's use the index operator and it turns out everything is more or less che cheap well by cheap we mean doesn't matter how many elements we have we can directly jump to the right element we can directly find out whether it's empty we can directly find out the size because the we just have to substract from the size of the vector the size of this drop parameter and and we can directly jump to the nth element we just have to add n to the element so all these operations are cheap good let's take a list and drop and you just saw already that begin became expensive so we have to yeah we have to end times call plus+ and mt is fast because we don't have to iterate through the elements because a list has a size member size is fast for the same reason and the index operator is slow again so we have to go to begin and then so nend times we have to drop skip elements and then idx times we again iterate through the next element so that's even worse than begin we want to protect you so let us only provide you what is good to use and the surprising answer is we skip the index operator but not begin but it's not so surprising if we have not no begin anymore we have a problem and itating from beginning to end so that's a key operation we need so now let's use a filter and it doesn't matter what the under the hood we have a view and a a drop view or we have excuse me whether under the hood we have a vector or whether we have a list everything is expensive so it's more more expensive or even more more expensive so begin yeah we have to apply the predicate until we the first time we find an element that is true so guess we have 1 million elements we're looking for the first element that's greater than 20 if there is no element greater than 20 we iterate through the whole collection and find out there's none which also answers the question is the range empty or not when we apply the filter it's as low as the previous example because we only let empty is just it's a begin the end so that's it so size size is interesting size says let's apply the predicate a couple of times well we again we have to iterate over all the elements so that's even worse than begin because begin only goes to the first fitting elements so sizes even worse because we not with begin we don't stop we go even further and and have to really look at each element and index has the same problem to jump to an element we have to know where's the fifth element for that reason we have to look which element counts and which one not so we have um yeah similar problem like size so again let's discuss what do we provide as an api for a filter view you know what size we don't like and index we don't like mt is okay okay good yeah because it's easy i mean begin is okay it's not okay but without begin we cannot use that whole system and when we know begin we know whether it's empty so then we have it size is not there so that's interesting vector filter has no size member so we usually think we have a size member in collections the only exception is the forward list which does not has a size member now we get a lot more ranges where we have no size member and now that becomes interesting because if we now drop elements we need the size or find out when we drop it whether it's empty we need the size but we cannot cheaply compute the size there is no size so suddenly having a drop behind the filter becomes interesting for some reasons okay h so how do we deal with that problem and now we come to some issues i mean you have seen already some issues but now the question is how do we deal with the constraints and the performance constraints we have so far it looks yeah if you have a drop the index might work might not work if you have a filter size might not be there well if you need a container that needs size size you might have a problem afterwards so a filter in front might cause some trouble good so let's start to use the whole machinery and we all learn by example we look at simple example and say oh that's cool i i i i you look at two examples to say oh i understand how it works and yeah vector print cool list print cool vector pipe to take cool list pipe to take cool vector pipe to drop cool list pipe to drop not so cool those who have seen my keynote here last year no i was in the in a close to depression when i got this problem because i didn't know about that i i just saw what the hell is going on here okay so usually when you come into such a problem you to try out a few things so what i tried out put list to drop at the right hand side of a range based followup and it works yeah no why okay so yes why okay so here's the answer as i told you and as we just found out begin may become expensive so on a drop it's expensive if the underlying container is a ve is a not a vector so not a random excess range so if it's a random excess range everything is nice if not there's a problem with that we have to call plus+ plus+ and plus+ so somebody calls begin and then calls empty on the same view oh then we twice have on the right hand side to to call begin and then three times plus plus and if we drop 1,000 elements we have to call 1,000 times plus plus so we came up with a cool idea let's cat begin once we find it so begin modifies the view if we have a filter we have the same so if you call begin you look at each element even at the values so that i should fix the slide to say plus+ comma star comma star comma star and then we have found the element that the first element that fits and that's 47 here so now we have the position of 47 we never want to do that expensive computation again anymore because now we know where begin is so let's cach begin and that also applies if we have a vector under the filter because again we have to look at each element whether this value applies and so what we do we cach begin caching begin has some interesting consequences so let's summarize here that some c++ views cach begin so a filter does it all times drop for example sometimes depending on what's inside side why we drop on and these are only the the facts on c++ 20 use and c++ 23 we have even more that cash so that has an interesting consequence so the first begin might be more expensive than the second begin for a view so just for a container calling begin is constant time so it doesn't matter how much elements we have begin is cheap and also by the way size and also empty is cheap we just return the value because we have all information inside if we apply drop it depends whether we drop on a vector or on a list and if we drop on a list then the first call has to iterate and find the right element and but the second call off begin is cheap everything else is cheap if we have a filter we have the problem even if we have a filter on a vector so the first begin is cheap the others are ex excuse me the first begin is linear so it's expensive the others are cheap size we don't apply provide okay and empty is also the first call of empty is cheap unless we already had begin so one of them having called initializes the other yeah in the c++ standard we have a nice saying about that in the c++ standard we say begin is amortized constant that is interesting because normally we say constant it means this size does not matter linear means well we grow linearly so we double the number of elements we double the the the amount of time it takes to iterate through over the elements or do do something with the elements so armorize content means yeah it might be expensive but over time it becomes cheap only once or a few times it's expensive well unfortunately the first time but because so that means always it starts expensive so and it's interesting we have a new requirement in the standard in c++ 20 we introduce concepts as named requirements and we say the requirement of range is not that begin is cheapap which would be true for all containers but not for all views so we say now a range is cheap if it's amti constant so that means the first begin might be incredible bad per incredible bad performance but the with the second begin it becomes better that's a little bit cheating that sounds oh all is great now how often do you call begin when you iterate over elements one usually one time and do you reuse that rarely so i would say excuse me but in 9% of all use cases begin is expensive now and it's linear now not amortized constant that's marketing good so that's one thing that's one consequence so but there are more consequences and now we come to the point why the code did no longer compile because the point was when we hear pipe a list into a drop we modify the view the we modify the view because we cash begin and the whole problem what we have and have we have also if you use the filter let's call print vector pass to a filter that does not compile because we cach begin print at the beginning calls begin begin modifies the view and unfortunately there's a const which is very typical because we learned it 15 20 years that it's perfectly fine to iterate over the elements of containers when you declare the containers to be con  all your code iterating over elements just reading them declaring them cons does no longer work for some views this video is not allowed to be shown in us huh no okay good no not good bad because obviously that confuses programmers so why does that not compile and and trust me the er message is not nice so at this point i started to claim and said um excuse me why the hell did we standardize that we come to the answer later and what should i do now what i what should i do to what should i teach to my programmers there was no real answer well or to say i got 15 answers so one of them was saying oh that's that's easy let's take a a sub range of a list piped into a drop instead so that's the only thing you have to teach you to your programmers okay because a sub range is a view that internally caches begin and for that reason suddenly it works well it catches begin and because it initializes begin at when it's initialized so when it's declared and therefore we we don't have to the first begin call does not modify the view anymore yeah so you only have to write the code as follows call print for sub range of a vector piped into a filter easy to teach huh good next option was let's use universal references al to with to m per some standard fellows call that forwarding references which is a little bit silly because this is not forwarding this is forwarding if you call forward on a universal reference but forward reference the the un term universal reference came from scott meers and some people don't like scott meers in the standard comput sorry that's off the record ah damn it's recart good doesn't matter human beings we are human beings when we standardize sometimes it's really a little bit strange okay good anyway i call this universal reference because it's universally referring to something it can refer to l values to r values that means to temporary objects or objects with names so universal reference is a very good name for that and the good thing is it doesn't make things const because you cannot use one m per here 1 % would not compile because this is a temporary object alter with one m% does not we cannot call so that's the way we solve it and everything works fine great so the only thing we have to teach is to programmers forget about const when you declare something just declare type and two ent which to some way changes the whole picture of c++ to programers i would guess and that will be interesting about the consequences we have then in this community so in i think in the next hour there's there's a session about how to teach cus plan interesting good and ah oh sorry if we use al to with to ent so it's not con be careful be careful there's another problem the problem is the fact that begin caches means begin is a right call does modify something and that means if you have two threats calling begin at the same time you have a problem so calling print and sum so we print out the elements and we want to compute the sum in one thread maybe not so tricky but just indirectly over some ways yeah it's it's all fine until you pass a list into a drop or a vector into a filter then this is a runtime error that that compiles but there's a runtime error undefined behavior okay filters be careful you cannot use when you use a filter view you cannot use cons to iterate but be careful if you do use cons if you don't use cons be careful because also iterating is a problem with the filter okay so in that case use cons auto reference good we have a couple of other options take by value and maybe constrain it to be just a view because copying containers is expensive maybe you want to pass a container then use all maybe you have overloaded a print version for views they take by value and other print that take by reference and call the other view print function okay i skip that because the fun part starts now so now we come to my favorite filter example how to use a filter so i don't know why you use a filter i use a filter to find elements that have a problem so sometimes this happens and you want to fix a problem do you agree that this is a common use case for filter let's find all the elements that are even let's iterate over them and fix them well that's not a fix that's at two for the moment one four 10 okay let's do it again great works now let's fix it that they are even so let's add on the one yeah first time second time oh interesting yeah because the first time we do that we cach begin so the next time we use this view it has a cache begin that element is definitely processed and then later on we don't find an element anymore but the behavior is interesting i mean okay that's a runtime error well that's that's unexpected behavior it's not undefined behavior that's unexpected behavior good now we are smart in the standard committee we said no no that's that's undefined behavior that's broken code don't do that oh yeah of course how how do we specify that we say you know med modifications of the elements of a filter view iterated is permitted but results in undefined behavior if the resulting value does no longer satisfy the predicate we are fine in the standard committee because we told you so okay now you know if you use a filter you can't use con so without using cons be careful not to call it currently and then don't modify elements in some way some is okay some is not so patrice said this nice example so i write my computer game i want to have find the monsters who are dead and bring them back to life that's undefined behavior yes don't do that you only have to know the roots burning them is fine provided they don't come back to life you never know with monsters that burn up okay that's a different thing so to be honest yeah we have standardized a view in with a filter where the use case find the broken elements to fix them does not work and it's even worse it compiles and has undefined behavior so it might look like it works but it's broken sometimes you see it because when you use the view twice that something strange is going on sometimes you might not see it sometimes you might only see it with some certain values and and it's a runtime error and if there's one thing we just learned in c+ us it is that programmers are fed up with unexpected behavior so we are in a situation where we can no longer say it's up to the programmer to make things right the problem and the knowledge you need is too big now that's why we come up with new languages okay good anyway is this all no let's let's look at a few other examples 10 minutes left so i can use a few more things so this is those who have seen my keynote saw that already last year that's a vector that's a list we have four elements we want to drop the first two elements that's the specification of of our view let's insert a new element at the beginning and let's print the values they there now think about we are not using drop here we should use filter here same problem but insert new elements call print again one of those has cach begin one has not in a filter all would have have cach begin so we would say now let's add new two new elements but because we have here use cach cach begin yeah we have different output and what is really crazy a few things here if you copy the view the cach is gone and that also applies to filters and if you print out the elements earlier you change the behavior of the program because you cash earlier and that is really that that's i don't know i can't believe that anybody in the standard committee thinks this is good design so we a print function changes the behavior of a program that is what we standardized what maybe i'm too old but i learned caching caching is an improvement in performance but should not have an impact on the functional behavior maybe i'm too old now the bad news is that we have one more problem now we are not allowed to use const so when we iterate we have to use a non-const container let's use a print here well this is print but think about we do something else here this is fu so we have a great function to make sure you cannot accidentally modify elements it's called c begin we standardize it in c++ 11 good oh this does not work on views because it's not provided in c++ 204 views okay ah yeah but we have sd c begin and in c+ 20 we have s rang c begin you can use yeah and then it works good now let's accidentally modify the element it's not so accidentally here but things like that happen so if you pass a view that compiles because the view may or may not propagate cons to the elements and c begin might not work so c begin is broken and c++ 24 views both forms now the interesting thing is it's not broken if you let the view operate on a temporary object so on an r value if you let it operate on an l value it's broken on an r value it works fine what why [applause] well the reason is i think we have a fun returning a vector of it so here we use it to initialize an l value and then we apply a filter so we still need the vector so we have the vector and we have the view on it and i told you we have a filter view on a c well in practice by the way it's a filter view on a ref view on a c but that's only to separate the mechanisms of using it as a view from what does a view concretely do so when you use a temporary collection not sure why this is red and this is violet but okay so then you get a different situation because if you have that you are creating a view on a temporary object that temporary object would be destroyed at the end of this statement so the view would filter elements on a on a temporary collect ction and for that reason we do something different we move the returned collection into the view and that is instead of a ref view we need an we use an owning view now an owning view has the container as member while the ref view has the container outside in that case the usual roots of c++ apply and they say if the object is const the member is const so here we here we propagate constness but here we don't propagate conness and that leads to the strange behavior you you just saw that we have what you have seen so depending on whether you you use temporary objects or not const regation is done so here's the example begin does not work it's not available c begin is available ranges c begin is also available and if you accidentally modify things that's a compile time error for vectors but not for views unless you take an r value on the right that is c++ 20 and c++ 23 ranger c begin is fixed c begin is not fixed for reasons you don't want to know but sometimes i think the standard committee hates programmers but okay that has an important consequence don't use stdc begin since c++ 20 anymore or in general in more general prefer if you have a function in std range and in sd use the one in sd rangers that's a better one that also applies to several other rules sometimes it's easy to teach that sometimes it's about fixing a problem you never heard about and i never heard about so that's it how do you use a filter view okay it's very easy just follow these advices so don't iterate when it's c but that's easy that's a compile time error good don't con conly iterate that's not so easy that's a runtime error don't don't and that's really strange if you modify elements while iterating make sure the predicate still applies that's the runtime error so that's your obligation con may or may not be propagated that is depending on different use cases a compile time error if you're lucky if you're not lucky you have unexpected behavior iterating might change the state we've seen that because caching caching earlier changed the behavior of the program and a copy might not have the same state so what are the consequences is pretty easy don't use const don't use concurrency don't modify elements or be very carefully don't think const is working and if you copy things might be unexpected and yeah so are there still use cases we can use a filter i don't know that's it so i'm not sure yeah how to use a filter view yeah so now you know how to use a filter view well you know how not to use it and by the way all these problems could be fixed all of them each and every could be fixed we just have to remove caching we just have to fix con's correctness the standard committee thinks that's a bad idea to fix filter views because we have a good reason for the current behavior uh the reason is in case there is a filter and behind the filter there's something iterating more than once and in case your filter elements have a long gap until the first time an element fits the predicate so if you all have this condition then this behavior is better i have a problem with the priorities of the standard committee in the meantime so yeah that's honestly that's where we are so if you like this behavior say thank you to the standard commune if not the only way you can do send back reports over back reports because you said the filter is not working i think that's the only way we can fix the broken standard committee thank you very [applause] much yes i'm part of the standard committee i'm broken i said yes so time is over i'm here around a little bit so you can ask me questions but i think that's it thank you very much