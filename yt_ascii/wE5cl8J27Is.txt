uh we'll be looking at oblivious transfer which is a a technology that involves sending data such that only a part of it will arrive and the sender doesn't know which part will actually arrive it will be the receiver choosing what they can read to give you an example to illustrated is a problem where you want to know who has the most money no one wants to brag about how much money they have but they've decided that the richest person needs to pay the bill for dinner so now you want to compare who has the highest amount of money but you don't want to reveal to the others how much money you have so they all run a multi-party computation protocol where they input their amount of money and the protocol will spit out the winner the person with the most money but it won't reveal to anyone involved how much money anyone has that's a sort of application that you could do with oblivious transfer but let's first talk about oblivious transfer itself the most basic protocol is called one out of two oblivious transfer i'm thinking of two values now in this case i can think of the two values of these two cards now obviously you don't know what these values are but i know what they are right now you're not supposed to know this but this card is the seven of diamonds and this card is the nine of spates but you don't know this right i'm putting them here and i want you to read the value of one of these cards but you don't want me to know which one of the two cards you've read right so you're thinking of a bit bit zero corresponding to this card the seven of diamonds bit one corresponding to this card the nine of spades and i'm not supposed to know which card you're thinking of so i give you these two cards and then you open one and look at them while i'm not looking at what you're doing right mhm so now now you know either the seven of diamonds or the nine of spades i don't know which one you know but you know one of them and you don't know the other right so that's the sort of physical example of it but how do we do this with cryptography how do we do this electronically right we might naively think why don't i just encrypt the two values i just encrypt seven of diamonds with key zero and nine of spades with key1 and then you can ask me for key zer or key one ah but if you do that i will know whether you were thinking of zero or of one so that doesn't work what if i give you both keys key zer and key 1 then i can look at both then you can look at both so that's also broken right we have two requirements which is i can rely on the fact that you can only read one card and you can rely on the fact that you can read at least one card after your choice so in order to do this we can modify rsa a little bit to accomplish this and this is the sort of most well-known one out of two oblivious transfer so let's refresh our memory on what rsa is there's there's a video that i did about this topic we don't need to know all the details there's really only one important fact that we need to know so rsa works in the modular world so to remind ourselves if we have a number x mode let's say 12 what this means is that we divide the number x by 12 and we are only interested in the remainder of that in other words if we have a clock with 12 hours and it's 15 hours well 15 / 12 is 1 with a remainder of three and it's the remainder we're interested in right so all the values we'll ever see will be between 0o and 11 because we're computer scientists we we like to include zero there so instead of 1 to 12 it will be0 0 to 11 now rsa works in this modular world as well but instead of having a small number like 12 we have a big number n and n is a is a really really big number like a th000 bits nowadays is already considered to be not enough you know every once in a while n will have to go up as our computational power gets bigger so but let's say that n is 1,24 bits right so then you have a a message number n and you're doing your mathematics modulo n then the special property that we have for rsa is that there are two values e and d such that if you take x to the power e to the power d this is equal to x modul n now how this property is created you'll have to look at the rsa video obviously we have to just accept this as a fact for oblivious transfer so one party say ellis can generate e d and n such that this property here that desirable property holds now how can we use this property for oblivious transfer i'll draw something called a message sequence chart to explain the the protocol so we have two parties involved ellis and bob we're drawing a line here and here and this allows us to sort of visualize the communication between the two parties if we draw something for ellis on the left or for bob on the right so on the outside it means that it's their private information that they're not sending and if we draw an arrow from ellis to bob or from bob to ellis it means that they're communicating this information to the other party so ellis starts off with two hidden messages so let's call them message zero and message one in the example before message zero was seven of diamonds and message one was the nine of spades right and now alice wants to communicate this to bob but only one at a time so the first thing she does is she creates a public private key pair in rsa right so she generates the n the e and the d with the property that we just discussed she keeps the d a secret that's her private key and she sends n and e to bob that's the public key part n and e are sent to bob the next thing she does is she sends two completely random values to bob these are values smaller than big n but generally quite large random values let's call them x0 and x1 so these are just random numbers that bob will receive now b bob before anything started thought of a bid right he wants to read either the top card or the bottom card so he selects which card he wants to read and call that bit b so that's a value he's thinking of now after he receives the two messages x0 and x1 he will select a value xb right so if he's thinking of zero he will select x zero and if he's thinking of one he will select x1 so after bob receives x0 and x1 he selects a random key k then with that k key k which is a secret for bob he does the following computation he takes xb plus k to the power e all of that modulo n he can do that because he was given e by ellis so he knows that value he was given n so he knows that value k is a value that he randomly selected and so is b xb is simply one of these two values depending on the value of x so he can compute this and and that value that's a single value let's call that value v what ellis can do is she can take the value v and privately compute two versions the first one is p0 which is equal to the formula she just got which is v- x0 to the^ d similarly p1 is equal to vus x1 to the power d so again this is something that ellis can compute because she's given the value v she knows the values x0 and x1 because she created them and sent them to bob and she knows the value d so she can simply compute p 0 and p1 now the final step is where the the magic happens she sends two values to bob which is m prime 0 which is defined to be m0 + p 0 mod n and the other value is called m prime 1 which is equal to m1 + p1 also mod n and this allows bob to then do the final step which is to compute mstar which is equal to m prime of the bit he chose minus k+ p b and what it turns out is that this value m star is equal to m p and that's exactly what we want right so bob at the end of the protocol now knows mb so to illustrate this protocol let's go with the bit that you selected right you selected the bottom card which was bit one so we have b is equal to 1 and we fill in this value for the protocol so m0 is going to be filled in as the seven of diamonds and m1 is going to be filled in as the nine of spades i'm then thinking of some crypto values we're not going to ineni those and similarly for the random values doesn't need to be this complicated what is important here is that xb here is of course going to be x1 so v will equal x1 plus k to the e mod n then i will compute p 0 and p1 so what will p 0 be and what will p1 be let's start with p1 because that's the interesting case so p1 will be the value v what is the value v well okay p1 is v minus x1 all of that to the power d now we can instantiate v because we know now because you chose bit one that it's x1 + k to ^ e so this is equal to x1 plus k to ^ e which is the value for v - x1 all of that to the power d now obviously x1 - x1 cancels out so what we're left with is k to the^ e to the power d more than and that's the whole magic of rsa k to the^ e to the^ d was equal 2 k mod n right so it nicely cancels out and what we're left over is a value k so p1 is equal to k now for p0 this isn't going to work we're not going to do the math for p 0 because it's not going to lead anywhere right because the value v is x1 + k to ^ e and if we then subtract x0 and raise that to the power d it's not going to have any nice properties so let's ignore that for now so p1 has the nice property that is equal to k and p 0 does not have this property now if we look at the final computation here we see that m prime 0 is going to be m0 + p 0 that doesn't have any nice properties because p 0 doesn't have any nice properties but m prime 1 has nice properties because it's going to be equal to let's work this out m prime 1 is equal to m1 plus p1 p1 is equal to k so that means that this is equal to m1 minus k if we then look at the definition of m star m star is equal to m 1 - k + k which is equal to m1 and that's exactly what we wanted so this is how oblivious transfer works now the other question is how do i know that you can't read the other bit of information i'm not going to go into the technical details here but remember that the definition of p0 was just some random formula to the power d if you can work out any random thing to the power d then you can actually break rsa so the whole point of rsa is that you can't work out a random number to the power d unless you know d which you don't so that's that's where that comes from it the you know there's a lot of technical details that are very interesting but that don't fit into this video so now we have one out of two oblivious transfer how can we get you know more interesting versions of oblivious transfer let's first instead of thinking about small pieces of information like a single card what if i want to send you a file you know rsa only allows small messages because our messages m0 and m1 have to be in the domain of n right if they're bigger than n they they definitely can't can't work and n is a,2 4 bits so any message longer than a kilobyte we're not going to be able to do this what we can do however is we can take two files file zer and encrypt it with a symmetric key s0 and we can take file f1 and encrypt it with symmetric key as one i'm now going to send you both encrypted files and i'm going to now run the oblivious transfers on the symmetric key so you will only know the symmetric key of file file z or the symmetric key of file one depending on your chosen bit and i don't know which chosen bit that is so that is how we can send entire files using oblivious transfer and now the final step which is one out of n one out of n oblivious transfer so what is the trick here so we'll do one out of four oblivious transfer as an example and after that it will be i think quite clear how we can generalize this to n so what we do instead of having two files encrypted with symmetric keys we're going to have four files now and based on your choice you can read only one of those files and i won't know which file it is so the first file we're going to call it file 0 0 for the binary notation of a two bit zero so file 0 0 is going to be encrypted with s upper zero lower zero and all of that will be encrypted again so there's two layers of encryption with s upper one lower zero and we do this for the next file f 01 which will be encrypted the inner key so that's s upper zero is going to be zero again because the first bit is zero but the outer key this time will be as one because it's the outer key but then the subscript here will be one because this bit is one similarly the next up will be file 1 z which will be encrypted by s0 is going to be one because the inner bit is one and the outer bit is zero the same is true for the for the fourth file in this case both the inner and the outer key will have bit zero so now now we can do a little tree of oblivious transfer so i do an oblivious transfer and you're going to either select inner key zero or inner key one so that will be s0 0 on one side and s0 one on the other i won't know which of the two bits you've selected and that means that i don't know which one of the two symmetric keys you've selected and then we do the same for the outer key so you either select at your will s10 or s11 and this is true in both cases so that means that at the end you've made two choices for two bits and this allows you to then have a pair of symmetric keys let's say that you went for zer one so that means that your inner key is zero and your outer key is one so that means that you have the following keys you have keys s0 0 and you have the key s11 and you can now decrypt file 01 and you don't have s10 so you cannot decrypt this you can't decrypt this because you don't have s01 and here you also can't decrypt it because again you're missing one of the two keys of course you can now instead of having a tree of depth two you can have a tree of depth three or four or five and this means that with logarithmically many oblivious transfers i can make you select one out of any number if you then want to select k out of any number i can simply run the protocol k times is that the best way of doing it no but it's it's a way of doing it so of course there's a lot of technical details and a lot of optimizations to be had but i think it's really cool that i can send you some information that you can only read a part of but i don't know which part so the applications of this we've mentioned multiparty computation so here i want to go into more details about this later so there's a particular protocol called garbled circuits and which is extremely powerful it allows you to run any arbitrary logic over any arbitrary input without any of the parties learning any of the input it's it's very powerful and very cool but there are other things you can do with this another one is private information retrieval so let's say that i'm a data storage and you don't want the people making the queries don't want the data storage to learn what they are interested in right simply the metadata of people keep accessing the same file might in itself be a privacy violation so there are some interesting ideas surrounding there as well this is one of the worst things that can happen so instead of using a single input we need to use two inputs the other input being again sean maybe you can tell me reasons why g3 should be more similar to g1 and maybe reasons that it should be more similar to g2