so let's talk a bit more about rsa now we've covered rsa a few times on this channel it's extremely prevalent and important public key algorithm and it's used a lot in digital signatures and things like this we're going to skip a bit over how rsa works in all the mathematical detail but you have two keys right you have a public key and a private key and what typically rsa is used for is you sign something using a private key and when you verify something you verify that signature with the public key now the public key is going to be some value e and a very large number n and the private key is going to be d e and n are not secrets so this is public and d is the private key e is usually 6 5 5 three seven which i mentioned before best number ever and then n is a very large somewhat random number right and it's gonna be somewhere like two thousand bits maybe even four thousand bits long so how do we calculate n well when we generated this key the person who has the secret key they generated n by calculating p times by q these are two prime numbers so they use some kind of primarity test some kind of random number generation to generate two random values p and q multiplied them together used this n this e and various other bits of mass to calculate the private key and then and then essentially for the sake of this conversation delete all this intermediate information and then just publish enn on the web somewhere or on a certificate now i was reading an article the other day by a researcher called hanno bach and what he'd found was that there are various systems that are using a library that generates a weak value for p and q right values for p and q where we can break the rsa key and essentially recalculate d right which is absolutely not what you want to happen right if you have a server but signing things with a private key and you can work out what that private key is you can then sign things as that server and so essentially pretend to be that server right there's a huge problem because you can basically convince someone's browser that you are an online shop and it would be really good idea if they gave you their credit card details right so that's not that's not what we want to break rsa what we actually have to do if you imagine you've just been given n right we have to split it into p and q right now why is that let's talk a bit about that process right so you've got e n as an attacker you've just been given e n and what what our goal is to do is to calculate d so let's imagine that you can factor n into p and q right so you can say okay i've worked out what p is and i've worked out what q is then you can calculate something called the euler totient of n which is actually in this case equal to p minus one times by q minus one right now we're going to skip over what that is and why right but the point is as an attacker that's what we're interested in doing as an attacker we factor n into p and q we can't use this formula to calculate the total of n right and then we can use this equation e multiplied by d is congruent to one mod the totient of n i shouldn't put an extra bracket in there i don't know why i did that right so what does this mean well it means that basically what we want to do is we've got e because it's public e is six five five three seven all right we wanna find some number that when we multiply by e we get an intermediate value which when we reduce mod the totient of n we get one again all right and if we do that we've calculated our private key d because that's the actual formula for calculating d now normally you wouldn't be able to as an attacker compute this right because you wouldn't have a totient of n you don't know what p and q are because you just give an n you're not given the factorization p and q so you can't use this formula so you can't calculate total n which means you can't do this right that's essentially the how it works the key here is that p and q are secret right so could we calculate the total event in some other way yes right you could use brute force it would take you longer than a lifetime in the universe or some unrealistic amount of time the fastest way really to calculate the total of n and hence to calculate the private key is just to factor into p and q now factoring in which means finding its prime factors is not difficult if n is small right so if n is 30 well one of the factors is two all right two that gives us fifteen three and five that that was it right so i'm not a genius it just wasn't very difficult now if n is 4 000 bits long or 2 000 bits long and you don't have one of the factors as two so you can make your problem instantly double as easy this is very very much more difficult right it's so difficult there aren't very many good algorithms to do it unless you choose p and q badly so imagine the p and q are the same right in which case p is the square root of n right there are algorithms for that right that's not so difficult so my suggestion would be if you're picking random primes p and q you don't use the same prime twice right that would be the first one but the other thing is what you might accidentally do is generate two prime numbers quite close together right so you know you can imagine that if this is the square root of n one of them might be a little bit bigger and one of them will be a bit smaller but they'll multiply together to get n if they're only very very close together you might imagine intuitively it's a little bit easier to find what the factorization is and then once you've factored it you can just do these steps to completely calculate the private key so a really good method for doing this when p and q are thought maybe not to be that far apart is fermat's factorization algorithm right and that's what this researcher hanno was using to do his attack and the way it works is basically like this so we know that n is p and q right now there's also another neat trick that we know which is that some composite number n is the difference of two square numbers right so it's going to be some some a squared that we don't know minus some b squared that we don't know now we can also rewrite this as a plus b times by a minus b right now we're not going to delve into too much detail right but this is basically the core of the algorithm now that's p and that's q or vice versa it doesn't really matter which one if we could work out what these intermediate values a and b are then we can use this little formula here to work out what p and q are what i've done is rewritten a formula i haven't actually shown that we can do it any more easily but we can rewrite this to be b squared is equal to a squared minus n what we do for the fermat's factorization algorithm is we say okay what's a good guess for a well a let's say the square root of n is about roughly where we want to start and we want to start moving up through the a's to try and find plausible solutions to this equation so we say that our initial guess for a is going to be the square root of n and then the integer immediately above that that's the ceiling function so if the square root of n is you know 0.7 we just go up to the next integer above right now we do that so we pick our a we calculate a squared minus our original n and we see what we get out and what we get out has to be a square number it has to be a number that has an integer square root because if it doesn't this doesn't work right and it didn't so what we do is we add 1 to a and we try it again we square a we subtract the original value and we find if we've got a square number right now this is not trivial to do in terms of the amount of computation to calculate these large square roots and things but it's not that bad and the interesting thing about fermat's factorization method is if p and q are fairly close to each other this will give you a solution for p and q extremely quickly you'll do a few iterations you'll get an a where you square it you minus n and you've got a square number then you know what a and b are and then you can do a plus b a minus b to get p and q and you've broken rsa right so let's have a quick look and i'll show you so we're going to use sagemath for this right now i love sagemath essentially think of it like it's python but with a bunch more maths in it you know if you use matlab or octave or some other mathematical library or mathematica or something it's one of those kind of things i like it because it's it's got a lot of sort of helpful stuff for photography but also because i know python quite well and so it you know it's easy now it's a command prompt that says sage on it but actually it's basically python right so i can write normal python now what i've done is i've got a weak n right so what i did was i picked two random primes that were not that different and i multiplied them together and got an n and i've forgotten what the primes are and deleted them right so n equals and i'm going to paste it in and it's a very very large number i don't know how many digits it is but some number of digits is quite big i can go n dot n bits is 2046. so it's actually it's marginally smaller than 2048 but it's not bad right now so n is my n is my very large part of the public key let's say my other component is 65537 as an attacker what we want to do is break n into p and q and calculate the total of n we can calculate the private key d and then we can recall kind of as a havoc on the web but don't by the way now because i haven't chosen p and q properly at random they are actually quite similar so the first half of p in the first half they were 1 000 bit numbers the first half the first roughly 500 bits were identical for both and then they're random on the tail end like the second half and that means that they've got still got 512 bits for a different they're not the same number at all and if you were counting up from one to the other it would take you many thousands of years to do but this factorization method breaks them very very quickly so let's code it up let's first calculate our initial guess for a right so a is going to be the integer square root which is essentially the integer down from the square root of n plus one so that's for ceiling right i could have couldn't just use the sealing function we won't dwell on it so a is some implausibly large number and what we're going to do is we're going to calculate a squared minus n and see if that's a square number and then we're going to increment and just keep going until we get one and then we can calculate p and q so i'm going to write a little bit of code to do this while true don't use while true most of the time i'm cheating while true let's calculate b squared is equal to a to the power 2. minus n all right hopefully this will work and then if is square as an aside the thing i like about sagemaths is they've already implemented things like it's square so i don't have to borrow intermittent by myself sounds like a lot of work i don't like doing a lot of work for my attacks so if b2 is a square we've already solved the algorithm right so we're going to do then we're going to calculate b is equal to the square root of b2 otherwise and then we're going to break and out of our loop if not we're going to do a equals a plus one right and it's already finished all right i think it was about ten iterations of this before we hit on the correct day it's just ridiculous how quickly this works so i can say a is that number b is this number and so we can now say p is equal to a plus b and q is equal to a minus b and then we can just do a check so p is this is p of prime p dot is prime thinking about it primality test witness numbers yes it is right and i could do the same for q so it's looking good and then the last test is to see if p times q is equal to n so n is equal to p times q true right so we factored n into p and q now actually i could now calculate the the private key so let's suppose e is six five five three seven right then what i do is i calculate the total of n so five n is equal to p minus one times q minus one and then we have to calculate the multiplicative inverse which is d d is equal to inverse mod it might be mod inverse let's find out of e and phi of n d oops that's not true d there we go so e is that and d is that so i've already calculated the private key not a lot of work incidentally the algorithm you use to calculate the multiplicative inverse is the extended euclidean algorithm so that's implemented in here as well i know you said that this is for kind of like weak numbers yeah potentially could it work for any rsc so this will eventually return the answer but eventually it is is it relative when the numbers are very close to the square root of n then this will return within you know 10 20 30 maybe a maximum of 100 iterations will return the number right for any you know so for example for thousand bit numbers if the if the last 500 bits are the same they are way too close together if you were actually generating values for p and q properly you wouldn't want to generate values but you almost even had the same number of bits you know they want to be somewhere around 102-4 bits but you don't want to enforce it and maybe and maybe you need to make some effort to generate them properly so one way that they generate which is not entirely uniform but it's not bad is you pick a random number and then you just increment it and find the next prime up from that number so what you would not want to do is pick a number and find the next prime up and the next prime down or something like that because they're only going to be maybe a thousand or 100 apart that's not going to work they're going to be very close to the square root so what you do is you pick some random number you find the next prime you pick an entire different random number maybe not even the same length five and x prime and then they are going to be sufficiently different if the numbers are very very far apart the factorization method becomes you know impossibly slow because you're doing all this extra square rooting and things that you don't need to do right and they're a better factorization methods out there so you wouldn't ever use it apart from in the really easy cases it didn't take me long to prove whether or not this was a week a week number right so what you could do and in fact what this researcher did was look at some publicly available keys and just find out where they're weak by just simply whether this returned within 100 iterations so it's extremely easy to find out if this n has got weak a weak p and q and so you have to be extremely careful generating these random values right a lot of thought goes into generating random primes then i am going into just doing the justice of in this video right it's it's not simply a case of calling math.random and then is it a prime like there's a lot there's a lot to it idea it's called psyche it's out it's after doctor who isn't it right so it's been a while since i've watched doctor who but the idea is that doctor who keeps showing people this blank piece of paper and it's psychic paper which means that they see some identification that means multiplied with itself 29 times on the clock and the number i end up with is'.