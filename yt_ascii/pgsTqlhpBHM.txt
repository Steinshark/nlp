all right hey look at this goang co-creator rob pike says what we got right and what we got wrong i'm into this i'm into this because remember we're kind of in that mode right now where we're going through remember this is 2024 the year of goang for me i'm going to give it goang minimum one year of full effort on all side projects i can to see can i love goang now i i will be i will be real for a quick second my goang thing started technically in february in january december i did write one more tool at netflix with with a buch of rust and it was fine but now i'm going to now it's it's just go from here on out for a while all right goan co-creator rob pike what we got right and wrong i'm curious what he thinks they got wrong all right an excellent standard library and pack packaging system i mean packaging system did kind of come a little bit first class concurrency support and a focus on readability among the traits that keep god devs happy i will say one quick thing even though we have even started a quick let me let don't don't let him cook i got an opinion instead goang devs stop with the onlet variables what the hell is this what what what world do we live in like you know like if we go like this websockets g gia all right if we do websockets gia where are you github all right please please okay i know websockets i can tell you all about the rfc i know it pretty well i'm pretty good at it i know i could do all this stuff let's see they have compression client go sums join mass prepar prox to go server test which one's going to do the actual thing here let's just go in here and i'm just going to look for this 126 that should be probably good enough for me to be able to find it there we go connection found what i'm looking for there we go all right so here okay so let's look at what we got here we got w final bu c w.c equals c like what the hell are we looking at what am i looking at i'm pretty good with go but why do you got so many onlet variables why are these all one letter pretty much stop this what the hell's w why are we doing this to ourselves what happened in here why you got so why you got to do this why you got to do that just just just put just dude like this n's and p's and just yo dog just stop it stop stop it stop it when you do this if you name a variable nn you get the length of p and you get nn out of there your shit's up okay you you're done messed up blocky it's time it's time to get the hell out of here okay i hate that i actually i just i like i literally hate this by the way one does not simply get the length of p and okay i just want you to know that one does not simply really l take oh my goodness you got okay okay hit me why is it an l take flip turtle flip turtle why is this an l take come on come on yeah okay double n is too far i agree with you double n is too far come on because dark because dark mode no one cares dude what damn it flip damn it flip you can't just meet me from a previous video okay that's not this is supposed to be a live interaction piece okay dang it flip take this part out okay you don't you don't flip take flip out flip you take flip out right now  anyways let's see right here all right okay now now we not done doing this there was a there was a treat for attendees at gophercon au in sydney australia the city where ghost specification was first drafted original go co-designer rob pike gave a talk commemorating the 14th anniversary of the day the go programming language launched with a talk looking back on what we got right and what we got wrong by the way go 14 years old like that's all right i like it i like it you know i like htm x has roots all the way back into the 90s i'm liking go it has roots all the way back to 2010 i kind of feel like i'm starting to like old things right and go's just pretty much nice c that's all go is go is just convenient se that's how i look at go pike began by remembering watching as a as the website first went live on november 10th 2009 the whole world learned what we'd been up to boomer confirmed absolutely boomer energy coming out of here 14 years later there is much to look back on pike told his audience promising to explore larger lessons learned pike emphasized he was speaking for himself and not the go team or google go was and still is a huge effort by a dedicated team and a huge community but he went on to deliver a talk sharing lots of inside memories insider memories about the early history go along with some useful insights on what's important okay awesome let's i want to what's the takeaways give me the takeaways people go's five original creators that discussed what made go popular for a 2002 article or 2022 article in communications of the amc in the article pike joined with kent or ken thompson russ cox robert geser and ian lance taylor to point out that go was specifically designed for concurrency and parallelism leveraging the power of new multi-core chips while handling ats scale workloads yeah i would say that this is go's like greatest this is go's greatest achievement is their concurrency model i know i know elixir fanboys are going to tell me i'm wrong that elixir is better okay i don't know elixir well enough to say that it's better okay but i absolutely think go has one of the greatest amc mentioned bye bye bye bye bye this is this is acm ac academic computer computing machinery what what do it stand for magazine is it magazine or machinery what is it again anyways i used to participate in acm competitions won a regional one once it was awesome elixir mentioned and get get banned but they also they also credited go's ongoing development focused philosophy for its success as well as thriving community and its contributions yep yep yep yep it's a new theme pike revisited in his november talk our original goal was not to create a new programming language it was to create a better way to write software if it didn't take 45 minutes to build the binary i was working on at the time go would have not happened i love this by the way this is the greatest reason to do something something is when you are massively inconvenienced by something and this is real this is genuinely real like if you like right now there are multiple companies with large enough javascript libraries and ba or code bases that it takes over 10 minutes to build the thing the first time like you should just take a moment and sit down and think about what you've done when you're do when when this happens you need to rethink about why you are at the position you're at because it is a huge inconvenience to have this right if you're doing c++ stuff why is it happening right you know c++ is unfortunate is the way it is i don't think you're ever going to get out of that apparently mold makes it a lot better st pike was sharing with the audience his detailed list of things we got right each was crucial to the ultimate success of go for example they made sure go was easy to parse which in turn made it easy to create tools like idees as well as go's official language server go please yeah this was by the way this was like the 10 thou again this is why i largely think typescript has been so successful in compar in comparison to something like flow is because when you make a language and you make the tools around the language as like as a requirement it it just it everything will adopt it so much faster flow is not good i know nothing about flow other than it was the alternative to typescript but it did not have all of the bells and whistles that typescript had with all the developer tools and so my my my imaginations is that flow probably does now have those things and maybe it's still not that good but oh flow tooling still sucks ass yeah see yeah there you go and like tools make things so much better this is one of the this is such a and go please is actually a really incredible lsp if you go and use it what you'll find is that the lsp has almost co-pilot like autocompletion because it won't just autocomplete what you're doing it will also like autocomplete one or two steps ahead in the lsp itself it's it's very impressive of lsp it it's a it's a huge w lsp it's probably my favorite lsp out of all of them including rust analyzer it's really really really good as soon as they were augmenting the compiler with tools for automating testing and code vetting not to mention package compiling go command but that wasn't the only thing go got right pike also applauds the go format autof formatting tool partly because the guts of the tool became a library that could reuse in simpler simplifiers analyzers and tools verifying the crucial code is covered by testing suites i will say one thing i love again about go format and the fact that it's it's a language de like i don't like the formatting decisions go went with but i like that they went with a decision and the reason being is that go use javascript and set like any tool like what you got to remember is that any tool that that does these formatters and these linters there's somebody behind the scenes that is working an incredible amount of effort to make these tools work because they're not opinionated and they're all third party making a pretty fire making a prier work within a editor is shockingly difficult and you may not realize this but what what is it n n ls null ls finally just gave up was just like it's too hard to manage all these different things and it's because it is really really really difficult and so having your builder your formatter your lsp all being owned by like all the same thing it makes it amazing none ls exists though it does exist but it's still like you got to remember that none none ls was birthed out of like actual tears not fake tears real actual tears of really hard time someone quit open source because of how hard it is yeah it's not that none ls is somehow doing it better none ls is just literally falling on the sword that's all not to mention that the output of these tools could always be perfectly formatted for humans and for machines the time saved by not arguing over spaces and new lines is worth all the time spent defining a standard format and writing this rather difficult piece of code to automate it interestingly go's package library grew somewhat as an accident as there was no other place to install go code at the beginning yeah if you if you used go during the early years there was no packaging system right like you it was kind of a it kind of sucked like during those early days that was like not very great i think that actually stunted a lot of go's growth to begin with was was their early days they really goofed that up but they really kind of turned it yeah go path sucked balls it did it absolutely did it was so crazy that you had to do that i mean i understand the reason for it it's smart it's like hey we don't need to have a version manager you just say what your path is and it works but it's just like no that sucks trust me that sucks but now pike sees it another thing go got right the existence of a solid well-made library with most of what one needed to write 21st century server code was a major asset it kept the community all working within the same toolkit until we had experience enough to understand what else should be made available another great thing about goes standard library it just there's really everything you need in the standard library like you can use these other things but just you know what i mean but just just the standard library alone you could build pretty great applications just using standard library no dependencies it's shocking how far you can get another thing go got right was its release of a formal specification not only does that lock down behavior when writing a compiler it enables multiple mentations to coexist and agree that on that behavior in turn let's see this in turn helped refine the language pike says and to fine-tune its specification let's go let's go go install at home go not following linux xdg based directory specification yeah but xdg i don't think existed when go started so it's kind of like do you break how go works because something else changed underneath it you got to remember that go started november whatever 20 20 2009 that that's before xdg home right if i'm not mistaken i'm pretty sure that's that's that's before xdg got started am i correct on that i can't remember when that started xtg is 2000 oh it's 2000 oh okay well my bad then yeah 2009 yeah i know okay then yeah go sucks go you should have used you should have used local come on come on go get your together all right early on go issued a compatibility guarantee producing a dramatic a dramatic documented effect on the language uptake pike says so much so that i find it puzzling that many other projects have resisted doing this i'm not really sure what they're trying to say here issued a compatibility guarantee oh yeah okay yeah compatibility guarantee meaning the language will not be breaking backwards compatibil okay yeah that that's good pike also added as an aside that it didn't hurt that go acquired a reputation for fast builds yeah i i'd still say that this is go's biggest thing that i hear a lot about is fast builds what go left out pike also gave the audience a glimpse at the feature that never made it in but he wished it had allowing arbitrary precision integers which he said would have eliminated an entire class of security concerns in a world where long integers can exceed the allocated memory there's still a debate going on about how we handle integer overflow well what if they don't overflow you don't have to think about it at all the runtime cost would be low and we just wish that i'd thought of it in time and be and and done it people may have objected it looks too expensive but what it frees up is amazing you just don't think about integer overflows anymore interesting i guess i've never i don't know i've never i've never in my head thought about this so what it's saying what it's saying is that let's let's just say let's just say you had this right you jump in a note and i got const a equals 232 minus 1 right so we're really really big so if i go a a+ 1 a or a+ 2 in in some world this would cause a problem like if i was a 32-bit integer this would cause a problem so if i go like this we get a we get ourselves a problem right because i just overflowed i went back to the i went back to the beginning right oopsy daisy and so if the compiler just took care of that and said ah you no longer fit within a 32 you're now a 64 i could see why people would like that but to be real the only times i think about the size of an integer is when i am doing like specific sized integer tasks which makes it really really hard for me to kind of reason about why i'd want this does that make sense exactly well because the only time i ever the implicit is i don't think implicit is the devil i think that implicit the right set of implicit operations is really really nice right i mean to be to be really fair when you do a heap allocation it's implicit on where it goes it's not like you actually align your own heap in how the allocation strategy works you know like there is some level of implicit that you do care like that you just don't care about doing protocols would be crazy exactly so that's what i'm thinking about on dono is that exact same thing which is what would happen if you're trying to do if you're trying to do a protocol in which you have a specific bite size that you want to fit and you accidentally roll stuff over right it'd be really it would be so i'm not sure if i think this is a great idea but maybe like maybe i understand it but maybe i don't i'm not sure later he says he'd like to see the compiler do more automatic checking of go's dynamic interfaces and also checking for the possibility of stalled progress deadlocks that could cause resource sharing anything that makes your program safer at compile time is good although he wouldn't want insufferably long compiled times rust mentioned rust me this is definitely a rust mentioned moment this is fantastic this is fantastic like i i i i'm actually on his team which is why i would love to see an option type introduced like i would love to see an option type introduced into go that is fully supported so and and or the ability to say all nils i expect to be options like some sort of like you know like you know how they have like some go experimental behavior it's like you can remain in the standard go way but you can also opt into the option side i would love to see that the oddities of go compiler one other crucial thing that go got right according to pike was its portability that is making it easy to compile code for other platforms it was made possible by ken thompson's compiler written in c programming language even though others argued that the compiler should have been written in go itself or using tools in lovm pike acknowledges thompson's compiler was an odd duck using old ideas and compiler writing albeit mod modestly sized as well as pragmatic and efficient but best of all it was familiar to us which made it easy to make changes quickly as we tried new ideas doing it our way however unorthodox helped us move fast some people were offended by this choice but it was the right one for us at the time this is super cool this is such like a cool statement this is such a cool statement you know how like like i mean you can really replay this statement in a lot of modern contexts how often are you told you need to do something a specific way and that is the only way to be successful like i recently saw somebody say that if you teach somebody who is new to programming if you don't teach them to do react you are setting them up to be a failure right which is a very very limited view on just programming in general and so it's just like when people you know there is there's good wisdom in listening to what people should do and how you should do things but there's also good wisdom in not doing whatever the current prevailing wisdom is if that makes sense you know and so i like this i like this there you got you know obviously it takes wisdom someone like pike probably smart enough to make that kind of tradeoff if you're new to programming it's really hard for you to make that trade-off because you don't even know what you don't know you don't even know what you won't know in 10 years like you you are a decade away from being being there in 2005 russ cox had written a tool transl translate the compiler semi-automatically from c to go and of course today there is an llvm hosted compiler for go and many others as there should be the unknown unknowns oh yeah don't make me get into the the unknown knowns like that's you know we get into the weird part pike's list of what go got right started surprisingly with go's mascot an unnamed cartoon gopher that he called one of the earliest factors in go success really that's actually been one of the largest barriers for me i think i i don't like i don't i don't care i don't want a mascot pike truly believes it was vital to go's growth having a recognizable funny creature that the community could rally around it's goofy yet intelligent demeanor okay i would never use the term intelligent demeanor to describe the gopher its eyes are semi cockey okay look at those eyeballs like they're that's not intelligent demeanor okay that i mean there's a lot of words for it but usually it like we don't typically we we we don't typically associate wisdom and intelligence with being cockeyed whether or not that's you know that could be completely unfounded by us but that's what it is you know what i mean that's just what it is he can build anything sets the tone for the community engagement with the project one of the technical excellence allied with real fun i mean i do like the idea of real fun so maybe maybe i'm just being too harsh on this one yet one design or one decision that was perhaps not the best choice was releasing the gopher's design under creative commons attributions license on the one hand and encourag people to remix them in all fun ways pike acknowledged which in turn helped foster the community spirit why was this not the best way this is like this is the best way what are you talking about you don't want to be like rust russ is a bunch of dummies right the only dude rust foundation was so stupid in their decisions that they literally tried to sell releasing ferris as open to the community as like positive in their decision it's like guess what they didn't even have a choice in it they just made it sound like it was good on their behalf rule 34 rule 34 exists rule 34 does not exist because people give you permission by the very definition of rule 34 it exists without your permission all right let him cook i'm going to let him cook let's see it's a gopher cuddling up to the engineer sucking on the toes look at that guy look at that guy sucking on the toes look at that look at that go sucking on the toes that's just what happens but pike says there were also frustrating arguments to correct attribution or misattributions and to be honest the attribution was often honored only reluctantly or not at all i mean can somebody tell me who drew ferris like i you know it's tough you know it's tough all right so if we're going to do it over we' think hard about the best way to make sure the mascot stays true to his ideals cool story bro that's who cares honestly i don't maybe maybe it's unfair for me not to care because i'm just not in that position to care but i don't care go the go gopher was renee french pike's long-term partner oh so there's a bit of a personal thing rene is feeling slightly slighted because of non-attribution for it pikes talk culminated with go's most impactful decision but he started by describing what the world was like in 2002 when he' first joined google google had seemed to be avoiding the concurrent execution of process threads if not pretty much banning them outright pike remembers which bothered him i've been doing concurrency like things somewhat without even realizing it since 1970s all right in 2002 there were many people who believed threads were a bad idea but that's also a wild that dude what is this take okay we just got to look at this for a second why threads are a bad idea for most purposes okay i guess this is something we should probably i would love to look at at some point but this seems kind of it just feels like a wild take right i gotta go i got to go see that you know what i mean it just hadn't caught the mainstream idea yet go was born partly to address that it ends up being one of the one of of the biggest things that go got right nowadays most mainstream languages have good support for concurrency pike noted but not but at the time it made go seemed like something new go support for concurrency was a major attractor that helped grow early adoption pulling in programmers that hadn't used concurrency before but were intrigued by its possibilities pike believes they absolutely succeeded go helped popularize concurrency as a way to structure server software although he admits that it might have been less impressive to programmers who weren't tackling intrinsically parallel problems like serving h p request i think one thing that's not being mentioned here is a go is way ear earlier than a lot of the async ways you do stuff like async async await or even promise proposal when did promise proposal even come out promise proposal proposal date right like when did it come out does anyone know oh my goodness spec promise proposal date does anyone know when this thing when when can can someone just help me find this someone go find this when did this thing when did it come out when did it come out i don't i don't know when it came out but either way this is you know the fact that we're starting off with the stupid gopher as the reason you know for a huge reason vital for its growth i would argue deeply that this this right here is the biggest reason for go's growth is that it has perhaps the it has the greatest async model that i have seen or the greatest concurrency model that i have ever seen personally j javascript promises were introduced june 2015 with the release of ecmascript 2015 yeah but promises were before that 2012 for promises injs yeah okay but either way almost as good as javascript async model it's dude that's like offensive that you would say that it is significantly better and if you don't understand why i i i say this all the time i mean we've talked too much about this but i will say it one last time ryan winchester let's go pull up ryan winchester dude i hate the fact that i like ryan and it just never autocompletes for him here we go this right here this is why async sucks this exact reason right here this is it this this thing you know what i mean the thing if you don't get it you don't get it soon pik's talk arrived at his grand conclusion here are 14 years after the launch and it's fair it's fair to say that overall it's a pretty good place pikes succinctly summarize other factors in their success okay we can talk about this at some point we got here partly because of a strong standard library that imp implements most basic needs for server code concurrency has a first class component in the language an approach based on composition rather than inheritance a packaging model that clarifies dependency management integrated fast build and testing tools rigorous consistent formatting focus on readability over cleverness a compatib compatibility guarantee now a lot of you may not realize this this like this was not the zeitgeist in 2009 okay the zeist in that time this was like this was like the the pinnacle of java fever i don't think people realize how like against the grain go was at this point and so it's absolutely amazing to see this come out at this time because the thing is is that a lot of people want functional languages to be successful and they they think functional stuff is the best the problem with functional stuff is that you go against the grain so hard if that makes sense it's so different it's so different from what people are used to that it's hard for people to want to even begin using it but go didn't do that go said okay functions are first class citizens you can do all the functional things you wish to you know you kind of could do but it's like a really limited type system so you can't quite do a lot of functional stuff but functions are first class citizens and you can curry if you want to but nonetheless this right here is just awesome right this is just awesome to be here at that early absolutely love it and that's why i think people got into you know that's why people were able to get into it so easy and most of all because of the support of an unbelievably helpful and diverse community of gophers perhaps the most interesting consequence of these matters is that go code looks and works the same regardless of who's writing it is largely free of factions using different subsets of the language and is guaranteed to continue to compile and run as time goes on that may be the first major program let's see that may be a first for a major programming language i think my guess is that lisp might have something to say about that we definitely got that right this is this is great though this is the greatest part of go this might be the greatest part of go by the way we could the full talk is like an hour or else we would have done that lisp mentioned let's go this is great for real by the way there's crazy factions in lisp though this is true lisp may not have changed much it's very lindy as people say but it is most certainly like lisp is your own programming language as as far as i've been i've understood it you create it the way you want to the full talk is good yeah i'd love to i'll probably listen to the full talk on my own it's just that usually full talks i can't do like a lot of thoughts on because you just want to let the person cook you know what i mean it's a little different usually full talks you want to let them cook anyways this is fantastic i i agree with every part but the gopher part gopher part seems a little weird but the concurrency and concurrency like testing people again don't realize how important testing was there there was no like testing is it's just not there you know what i mean testing was not there at all and so to have testing as a part of something to be intrinsically a part of the language incredible to have a build tool that is a part of the language was incredible like java almost got that right but java like to successfully build java you need a degree in maven which is just like or ant which is very very difficult you had to use net beans you had to use net beans anyways you know rust came in and rust took a lot of these rust took a lot of these ideas you know what i mean and russ was smart to take a lot of these ideas like this is smart this is what you should do all right hey the name it's the prime engine