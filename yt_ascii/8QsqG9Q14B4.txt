last week i started refactoring a command line shell application submitted by moody if you haven't watched that part yet you should probably watch that first before watching this video which is part two where i'm going to complete the project what i did last week is mainly a review of the code and i started refactoring the shell environment and in the second final part i'm going to take a closer look at how the decoding encoding and hashing algorithms are integrated with the shell application so let's dive straight into the final part of this refactoring so let's take a look at how we can approach this so first hashing if we go back to this algorithms page we see that we have the documentation here so i don't like that i want to move this documentation to the main fossil so that i have all the text in a single place so let's go here and i'm going to define a hash doc and that's this basically and you see we're now starting to have a problem that well in order to generate the documentation we're going to need access to hashing algorithms so that's the next thing that we're going to need to solve so i need to import that here again i'm going to clean this up later because i don't think this is how it's supposed to work but we'll get to that in a minute the shell is not being used command is not being used so i'm simply going to remove that and these things these come from algorithms and hasher comes from hashing api and we're also going to need the encoding manager there we go so still a bunch of problems obviously but we'll get to that in a minute so the shell it's actually no longer a class so this is no longer being used and i'm also going to delete these things because also they're not being used anymore so currently we've like completely circumvented the whole interface class so let's see what happens if i try to run this now okay so there's clearly some issue with indentation so that's the hash doc function so where does that actually happen of course the initializer is empty so that's probably the issue let's run this again so now we get the shell again let's see what happens if we now try to do this so i type help so that prints the help that's exactly what we want and we can print exit and then it's exiting the shell so at least this part is currently working again and what happens if i try to help bloody bloody blah then that also works it simply ignores those arguments so good so our package is still working that's great next thing what i want to do is clean up the algorithms and the api part because currently it's a kind of a mess in the sense that we have uppercase and lowercase definitions we have the documentation in here which is not really nice so that's the first thing that i'm already going to move take these two documentation take these two strings and then i'm going to put them right here so this is going to be the and called doc and this we for now have to import and we have here the p code dock which is this so now at least all our documentation is in a single place which is much better and i'm going to remove it from this dictionary and same for the hashing algorithm also going to remove the oh not the algorithm itself obviously cloud i'm going to remove that so next thing that i want to do is really simplify this because currently we have hashing dictionary we have hashing list we have an encoding which is both encoding and decoding and we have also a list of algorithms so that doesn't make a whole lot of sense to me so instead what i'm going to do is there's a lot of imports that actually are not needed so i'm going to remove these and then what i'm going to do is change it so that there are basically three constants one for encoding algorithms one for decoding algorithms and one for hashing algorithms and i'm also going to turn all of them in lowercase strings to keep things simple so this constant i'm going to rename encoding algorithms and it's going to be a dictionary i'm starting here because this already has the lowercase characters like so this a is not needed so i think that's a book and then we're going to simply provide the encoding function here as a value foreign like so and then i'm going to copy this and we're going to also create decoding algorithms there we go and now this one we can delete and then here we have the hashing i need to type hashing algorithms like so and again this is a dictionary so the advantage of using a single dictionary now instead of having a list and a dictionary is that we can simply if you want to add another algorithm or remove an algorithm we only have to do it in a single place so blake up blake 2s there we go maybe there's a shorter way in python to actually get the function names and map them directly to dictionary values but for now i'm just going to do it like this and as you can see github copilot is actually able to generate a lot of this for me relatively quickly and i could have probably also asked it to generate the whole thing directly and now this one we also don't need it anymore so now algorithms the only thing that is that is a bunch of imports and then it has three constants encoding algorithms decoding algorithms and hashing algorithms now ideally when you use the shell you wouldn't want to access these constants directly but you would have some sort of simple api on top of this basic structures on top of these algorithms so to make the naming a bit more consistent i'm going to change this to a lowercase and then instead of having encoding api and hashing api what i'm going to do is create simple and api file where i'm going to provide various ways of accessing these algorithms that we're gonna use in the main file and i've already prepared this since this file is actually pretty trivial and will take me a lot of time to type it all out so what i did is i imported these three constants here decoding encoding and hashing algorithms and then i've created a few utility functions that give me some information so for example this gives me the list of available encoding algorithms so that use the keys method of the diction same for decoding algorithms and for hashing algorithms i also have functions for checking whether a certain algorithm is available encoding decoding and hashing maybe you could make this more generic by creating an algorithm type and then simply have that as an enum or something but i've done it like this to keep it simple then i have here actually the wrappers around the actual encoding and decoding enhancing operation so this is replacing the whole complicated encoding api thing that we have here with integer operations which is way too complex but what this actually does is very simple it simply checks is the text string well in that case we're going to encode it because we need bytes and then we get the encoding function by accessing the algorithms and you see i'm also using lower end strip to make sure that it works regardless of whether you're typing uppercase lowercase or whatever and then i'm simply calling that particular encoding function that we got from this dictionary and decoding is actually exactly the same and hashing again is exactly the same there are some duplication here i think you could further improve this by introducing a algorithm category and not simply having one function that depending on the algorithm category accesses different constants but these are also not very long functions so i i don't really mind having a bit of duplication here or if you have another suggestion of how to further improve this let me know in the comments so encoding api i'm going to delete because we won't need that hashing api also going to delete because we don't need that anymore so in the main file we can now further clean up things so instead of directly accessing the constants here you can actually use our simple api so here i can simply write the hashing algos function and then use it in the documentation here and same thing for encoding so encoding algorithms and here we can do the same thing for the decoding algorithms like so this import is no longer needed actually time is not used either these ones are not used this one is no longer used we simply use in the api and let's also remove the source because that's also not necessary and there are some doc comment here that i don't think we need anymore and now in the main file we have a really simple setup so what we of course still need to do is clean up the interface class which we can do now since we've cleaned up the algorithms and the api so i'm going to start with the hashing function and you'll see that it's actually pretty much the same for encoding and decoding as well so i'm going to remove that here and we're going to go up here and i'm going to add the function here so let's just call this hash shell and also here we can make sure that the types are actually properly dealt with a hashel is actually going to get arguments so that's going to be a a list of strings and that's going to terms num since it simply will print a few things and now this function is actually responsible for checking that the arguments make a sense and if not it can display documentation so i'm going to write if argument is not equal to 2 then i'm simply going to print the hash documentation and then return then let's get the text and the algorithm name from the arguments so i think there's still some issue with commas and there's still some issue with indentation i'll fix that in a minute so then i'm going to use the house hashing outgo function from our api to check whether that algorithm actually exists and if not then i'm going to print well let's print false unknown algorithm name i think that looks a bit nicer like so and then what we can do is also print the hash documentation and then simply return now this means we can actually hash the text and we can use our api hash file function that we created so just calling that right here like so and then we're going to pass the text and the hashing algorithm and this is not needed and let me try to fix these there we go and now we finally need to print the hashed text like so so now you see that hash shell as a function is now completely responsible for everything dealing with hashing including the check of the number of arguments and i think that makes a lot of sense because this is also a an argument check and you might want to add more checks depending on the type of command that you want to execute so it makes way more sense to me that this is actually part of the function and not part of default commands versus regular commands etc so now this one we don't need it anymore so that already removes more from our interface class and now what we can do is add the hash function to the list of commands so there we go and now let's run this again and see whether this actually still works so i think there is an import issue yeah so it's let's try this again okay so now i'm going to hash codes and now we're getting a syntax because we see that we didn't supply the right arguments of the hash iron codes and then md5 for example which you should never use as an algorithm because that's pretty outdated so that seems to work fine if i do hash i also get the syntax if i do hash and i do like any random number of arguments i also get the syntax so that works and if i write a command that doesn't exist nothing happens same as before so that seems to work fine so now i've done exactly the same thing for the hashing function for decoding and encoding so that's what you see here it looks almost the same so we check the arguments we check whether the algorithm is available and then we're decoding it and printing the decoded text so the only thing now left is to add it here to the list of commands so now we have encode and decode as well and the whole interface class is no longer needed so i'm simply going to delete that and i don't think this print statement here is needed either so let's see what we have now we now have something that's way more simpler we have a main file where we have all the documentation for the startup screen help hash encoding and decoding so you could optionally move this to a separate file read the documentation from there and then even use it translated value if you wanted to then we have the actual command functions help exit hash decode and encode and we have a single command dictionary that maps the command keys to the command functions and we execute run shell and a main function that prints the start documentation and then runs the shelf so let's run this and verify that this actually still works so i'm going to do encode and let's encode something else now and i'm going to use the base 16 algorithm so then this is what we get and then let's try to decode that and then we get back the original string so this seems to work i'll exit the shell now this final thing that i'd like to do because currently it's kind of a mix up of what is supposed to be part of the shell application and what is in the main file so the main file currently contains the actual decoding encoding functions which i mean it's kind of okay in the main file you would maybe define the if you're building a shell you would define the actual things that you want to be part of the shell you could put it in a separate file so that the main file becomes a bit smaller but what bothers me still a bit is that the there is this commands constant value and we're calling execute and we're running this also in my opinion this part is actually really something that shouldn't be here and that should be part of the shell system the shell system should be responsible for executing commands and for running the actual shell that shouldn't be in the main file but the problem is of course that these things directly depend on this command's dictionary so if i were to move this to let's say the core file where i think it belongs then we have an issue because commands contains references to these functions so a really nice way to think about this is that it's actually a sort of plug-in system so we define a shell and then we define what the commands are we add them to the shell and then the shell knows about them and can access them and to do that we can define a very simple interface of being able to add a command by simply supplying a key and a function that should be run when the command is being typed by the user so that means if we do that that we're going to move these two functions so to copy them over to the core which is the whole shell system and then what i'm going to do is i'm going to define the commands dictionary here and this is a dictionary that takes a string and that contains a callable that gets a list of strings and returns none and initially this dictionary is empty and this will need to import from typing and now the only thing we need is an app command function so that gets a command string it gets a function which is this and then it stores the function in the dictionary of commands there we go so in the main file that's really fun we simply add these commands by calling add command and then we're going to add help which is the help shell we're going to exit we're going to add hash encode and decode and this dictionary is no longer needed and let's also clean up the imports so we simply need to import app command and we also need to import run shell obviously and shell input is now actually a lower level thing that we're not going to need here anymore and so now i feel that the shell system is really cleanly separated in the main function we simply define our functions our shell capabilities that we wanted to have and then in the main function we add these commands so that the shell understands them and we simply call run shell and we're not concerned anymore with any lower level behavior of the actual shell application let's run this one more time to make sure that this still works and let's also try encoding [applause] so md5 is not an encoding algorithm obviously let's try that one more time so a 85 there we go that's apparently iron codes in a 85 encoding and we accept the shell so that concludes the refactoring of this shell application i hope you found this useful and that it gave you some ideas of how you can improve your own code as well there's a couple of things in the code that i'm not yeah completely happy with like one thing is the documentation that's currently in the file itself so i would actually move that out into a separate file so i can replace it by documentation another language also this has shell the encode shell and decode shell functions they have still quite a bit of duplication perhaps one way to solve this is to still introduce again a command class that also defines the number of arguments that is needed the documentation to further reduce duplication but if you have any other suggestions for how to improve this how would you change this code to make it even better let me know in the comments thanks again to moody for supplying the code for this rose it's really brave to have your code criticized like this in public so i hope you found this helpful the final thing it could be an interesting extension of this particular tool is to allow for true plugin mechanism where the functions are actually not defined at all in the scripts but they're loaded on the fly and if you want to learn more about that type of architecture type of plugin system you might want to check out this video next thanks for watching and take care