hello and welcome i'm james murphy from mcoding.io 
where i offer nine week weekend programming   courses today brownian motion if you're watching 
this video you've probably heard of brownian   motion before but the purpose of this video is 
not so much to tell you what brownie emotion is   but rather to give you a way to simulate it so 
that you can play with it yourself surprisingly   simulating brownian motion is actually not that 
difficult i've already imported numpy for doing   some of the math operations and matplotlib for 
plotting the first thing that i'm going to do   is define the number of time steps that i want 
to use and my time horizon so this means that   i'm going to be simulating brownian motion from 
time 0 to time 1 and i'm going to do so using 10   000 sample points next we'll use numpy.linspace 
to make the set of times that we're going to use   so linspace takes the initial time the final time 
and the number of sample points just for your   benefit let's go ahead and print out times with 
a small number of time steps so you can see what   it's doing you can see it's just going in uniform 
increments zero up until one continuing on i think   the next thing that we're going to need is what is 
the time step that is between each of those times   so we'll just take times of one minus times of 
zero the next thing that we need to figure out is   how do we actually get values of the brownian 
motion well almost the characterizing property   of brownian motion is its independent normally 
distributed increments what that means is that   if i have brownian motion at some time t2 and 
i subtract brownian motion at some time t1 well   then this is a random variable and it's normally 
distributed with mean zero and variance t2 minus   t1 so instead of trying to find a single formula 
for the brownian motion i'll just generate all of   these normally distributed increments and then add 
them up so let's make db meaning the increments   of brownian motion the differences between the 
values of the brownian motion that will be a   numpy random normal and let's give 
it a shape or size which is equal to   we're going to need the number of time steps 
minus 1 because the first one is always going   to be zero brownian motion starts at zero then 
we need n minus one for the rest of time steps   so by default this is going to give me mean 
zero variance one and what i need is variance dt   because we're looking at increments of the 
brownian motion which are in times in this   array all of those times consecutive times in 
that array are separated by a distance of dt   from each other so in order to get a variance of 
dt i'll need to multiply by the square root of dt   so let's just do that numpy square root of dt 
times that so db now is an array of differences   of values of brownian motion we still haven't 
constructed any of the values yet just their   differences to get the actual values of brownian 
motion we'll need to start with its value at zero   and then cumulatively add up the differences so 
brownian motion starts at zero so let's just use   numpy.zeros to create the array and it takes 
a shape parameter and we're just gonna have   one zero for now later on we're going to be 
generalizing to simulating multiple brownian   motions or equivalently a single multi-dimensional 
browning motion so if you don't understand why   we're choosing to make this zero an array instead 
of just a scalar just keep that in mind that we're   going to be generalizing in a little bit to 
get the actual values of the brownian motion   we just need to concatenate the initial value 
with the cumulative sum of the increments so   i'll take these things to be concatenated let's 
take b0 and the cumulative sum of the increments   and then we can go ahead and just plot it so we'll 
plot that x values are the times and the y values   are the brownian motion and 
then we'll show the plot   so if we did everything correctly then 
we should see a plot of brownian motion   all right that looks pretty good to me one 
thing that i do want to test is i just want to   make sure that if we used less time points that 
we're still getting the right thing so i do see   that it starts at zero and it's going around 
the value minus one of course it's random but   the values that you get for brownian motion 
shouldn't depend on the number of sample points   but only on the time horizon so if i go out to 
t equals one it shouldn't matter if i take 10   000 sample points i should still have something 
which is around the range plus or minus one and   you can see even though it's a totally different 
sample path different number of sample points   we do end up around one now of course it's 
possible that that doesn't happen but it's just   the most likely thing is to be in that range minus 
one to one if you did this experiment and you   found that when you increase the number of sample 
points that the value of your brownian motion was   increasing then you probably would have messed 
up the scaling so for instance if i delete this   proper scaling by square root of t and then 
run the simulation again so here you can see   that by time one we're getting values that 
are up at like 80 and down to minus 50 almost   minus 60. so if you see that that should be your 
clue that brownie motion doesn't move that much in   that amount of time so if that happens check your 
scaling i'll go ahead and put the proper scaling   back in there okay so that's one brownian motion 
what if we want to increase the number of samples   let's introduce a new parameter d which is 
the number of brownian motions that we're   going to simulate all at once so for now 
let's just have say five brownian motions   so how can we modify this now our times are not 
going to change because they're all living on   the same time axis since our times didn't change 
our dt doesn't change either the first thing that   actually changes is going to be the increments so 
instead of being normally distributed with this   size now we need to just add in a d here the first 
coordinate is going to be our time coordinate and   the second coordinate is going to be our either 
space coordinate if you're thinking of it as a   multi-dimensional brownian motion or the index of 
the brownian motion if you're thinking about it   as a bunch of independent one-dimensional brownian 
motions which is how it will be drawn when we plot   it of course now the initial value of the brownian 
motion is going to be 1 by d because there are   d components of it now oh and by the way if you 
wanted to consider a brownian motion that's not   started at 0 this is exactly where you would 
change it you just put in the numbers that you   want there and then you'll get samples of 
your brownian motion started at that place   there are two things that we need to change on 
this line namely now that our db has more than one   dimension to it we need to specify when we do the 
cumulative sum and when we do the concatenation   what axis we're doing that over so i know that i 
want to sum in time not in space so i want to sum   at the zero axis not the one axis so let's change 
the cumulative sum to axis equals zero and let's   change the concatenation axis to axis equals zero 
again that's because i again want to concatenate   b0 on as the first time step not as a spatial 
dimension then we can go ahead and plot it again   so there you have it it looks like we have a good 
five samples of brownian motion going just for   fun let's bump up the number of brownian motions 
and see what it looks like when we do a hundred if you've never seen a picture like 
this i would encourage you to sit   and stare at it for a while 
it's a little bit mesmerizing even though our brownian motion was made up of 
totally independent increments every single one   was just randomly generated we're starting to see 
some structure here even with a hundred sample   paths there's a clear shape that's emerging where 
the brownian motion really tends to not go outside   of that shape let me bump it up to a thousand here 
just so we can get a little bit better picture of   that shape now we see a very defined shape with 
just a few outliers out of a thousand samples we   have almost a parabolic shape that's emerging if 
you're interested in learning about this property   it's actually a very well known fact you should 
look up what's called the law of the iterated   logarithm for brownian motion it tells you that 
brownian motion really tends not to exceed about   square root of 2t and from the name you can guess 
that there's a logarithm or 2 hiding in there   but that's not for this video this just shows that 
by simulating you can gain a lot of insight into   the statistical properties of a kind of random 
process like brownian motion the last thing that   i wanted to show you is another key insight 
that you can see just by simulating like this   another characteristic factor of brownian 
motion it has so many interesting properties but   one of them is its quadratic variation now the 
quadratic variation isn't something that you would   probably come up in a video just about brownian 
motion it's more of something that you can look   at for a general stochastic process and it just 
turns out to have a very interesting formula   when you put in brownian motion the quadratic 
variation is not a whole lot more than what   it sounds like basically we're just going 
to take differences of the brownian motion   square them and add them so let's take the 
numpy difference of the brownian motion   along the axis zero because remember zero was 
for time and to preserve the original dimensions   of the brownian motion i'll just go ahead and 
prepend zero because the quadratic variation   is something that's defined just like brownian 
motion to start at zero then i'll take those   differences and raise them to the power two then 
i will again use the cumulative sum function   so that i can graph them and again we'll do this 
along axis 0 that's the time axis and then i will   just return it if you didn't quite follow the 
formulas and dimensions that went into this   just consider the case where d equals one then 
all the axis stuff disappears and what you end   up having is basically look at the differences 
of the brownian motion take them to the power two   and add them up so now instead of plotting 
b let's plot the quadratic variation of b huh that's weird when you see this picture you 
might think that i've done something wrong just   to be sure that i haven't accidentally messed up 
the brownian in motion somehow let's go ahead and   plot again just throw that original plot of b back 
in so you can see the brownian motion is still   wiggling all over the place it has all of the 
same properties that we were talking about before   but yet this quadratic variation looks like just a 
line and indeed that is the case the property that   i was alluding to earlier is that the quadratic 
variation of brownian motion is just t at time t   brownian motion has had exactly t quadratic 
variation that's why this looks like the line   y equals x so even though we have the full force 
of all the randomness of brownian motion going   on here we find that when we look at squares of 
differences and add them up all of these different   sample paths look like this just a line so that's 
another key property of brownian motion and it's   really cool that we can actually see it even just 
with our you know finite simulation that's all i   have for today on brownian motion let me know if 
you want to see more on this topic and as always   if you liked the video don't forget to like 
comment and subscribe thanks see you next time