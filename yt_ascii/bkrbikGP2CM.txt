time okay my talk is titled enough team p to write a variant yeah so i heard that this is a good rule that you kind of give people link to the slides so this is a link it's tinyurl.com and then it's enough tmp all small letters 2022. okay so if you want to follow along somewhere you can and if you are on your laptop i will assume that you're following along the slides totally foreign [music] pete to some extent i think basically if you don't know what team is team b is template meta programming right so when we use templates to generate something complicated right more than just substitute everything for a type the most extreme example would be probably hana dushikoa's compile time regular expressions there are also high frequency traders like if you've been to previous talk in room a that was by high frequency traders those people love their templates there are many many applications in the standard libraries there are two there is tuple and variant and because they're in the standard library people do them a lot i have written a variant i think for every standard since 11. in some quality and so we're gonna do very end because with c plus plus 20 we can do it in an hour it's less than 500 lines of code total just because probably not everybody is still familiar with std variant i had the usage here then it broke and so five seconds before the talk i prepared it again this is how i was familiar with variant right this is an interview problem let's say you have excel can you see it okay okay so this is like let's say you're writing an excel and in excel you have cells and by definition of the problem you have in a cell you can have either an int or a string and then there's operation defined like a plus let's say you can int plus int is you know int plus string plus string is concatenation string plus int you convert into a string down to an eight and in plastering you throw an error something like that like again it's not full example it's an interview problem but this interview problem is much easier to solve if you have a variant right so i have a variant between internet string and it can be you know you can assign to it either an interest or a string and it will keep track of what it is and then the killer feature of a variant in my respect is multiple dispatch like imagine you have to select your implementation not based on one type like in virtual functions right but on two types or on n-types right and this is standard visit is a way to dispatch on the variant and it can do multiple dispatch so i dispatch based on my type and the other type and i select the appropriate one follows the problem and so this is what we'll do right okay this is probably barely visible but what is variant under the hood it's a union i'm sorry but it is a union right of all of the possible elements it has an active index and then in visit there is some sort of switch between all of the possible types and we're going to implement all of these components we're going to start with just a bunch of general purpose template meta programming utilities and then we're going to use those utilities to build the variant but first we're going to build up a library a little bit let's start here we're going to find the type by an index right let's say we have a list of types char int double and we want to find an internet right and where is it oh it has index one right and here double is index two okay so how can we implement it well first of all i'm going to talk a little bit about how do you generally organize your code in meta programming if you do a lot of complicated templates usually when we want to do something in private like we'll have either private section of a class or we will have anonymous namespaces both of those things are not available to us really in templates like anonymous name spaces just don't work in headers and a private part of the class doesn't really work with complicated templates because writing friends is really really hard so instead what people do they have namespaces andre was ranting yesterday about the detail namespace the data space is very useful but the problem with detail name spaces you have one detail name space a pair library and so things in different files tend to clash so what you do instead what i recommend doing instead is having also a namespace per file right so here this would be in my file type list and i have like underscore type lists namespace this is my convention this is not very common but still okay a second convention is like if you want to return if we're going to compute like the index of a type based on in a range of types so we compute something based on types if you compute the value based on types as a typical interface is you create a constructs per variable and it has underscore viewing here so i'm finding an index it says context per variable of type size t it has underscore v at the end right in order to implement it i call the internal implementation function right in terms of function is a very simple constructor function like this is just an implementation of find that goes through all of the types and i check oh is this true or not and return the index where it's true the interesting part is here we for every type in the list we call stood same as and compute basically boolean value if it's the same as the type or not yeah you can use two ranges fine that's also fine then there is a little question like what do you do when you are like what do we do if we didn't find the type there are many options then the library obviously returns you the end when you didn't find something here i chose to write a requirement that oh we have to find the type so type i require the type is one of the types so that the index that we found is less than the number of times and this way i can then check for it like for example i could write a concept one-off that's gonna say oh did i find the index and this is a useful concept okay the next utility we're going to write is uint.list right i want to represent a number and i want to use the smallest unsigned integer possible all right so for a hundred uint 8 will be enough for you know 256 i already need unit 16 that kind of stuff similar convention here if you want to return a type you create a using a typedef right with underscore t at the end and this is implemented again by calling a function and you see this leaves in like in utilities file so i call into intuitive namespace the implementation is very simple it is just ifcon's export table you see i'm just checking conditions one after another and returning you know if it's smaller than you ain't marks returning unit eight in 16 marks etc okay the next one is get type by index from a type list so let's say i have a list in chart double and i want to get second type that's going to be a double all right first type that's going to be char this is a surprisingly difficult problem right there is a talk by chris jusia and i believe he will repeat it in the online part at this conference in a track after this called the ends element case study where he talks specifically about this problem how to get a type by index from a type list the reason why it takes a whole talk for him to talk about this is because it's not trivial to do in optimal compile time right you want to if you are doing a lot of complicated meta programming like they do in hft you care about that here i talked to will ray on tpp links like when boss agrees this is reasonable how i'm gonna do this i'm gonna just have a construct expert table so okay we're gonna unroll first 10 types and if the type is index is zero we're going to recharge the first type index is one returns a field you see like you see zero's type first type etc and if there's more than 10 types we're going to recurse i this is why why i'm not just doing why i'm not just doing if n equals zero otherwise recurs why do i do unrolling basically the generally speaking the performance of your compile time should depend on the number of instantiations and so if i just did one if else then i would instantiate the function for each of my types this way however i instantiate only like for every 10 types instantiate a function there's another interesting thing here you see in the previous function when we return the type i just constructed a default constructed it but in general case you can't default construct a type so we need to wrap it into something and we're up at the standard type type identity with just an empty struct with a type definite yep the next one is instance off right we want the concept that will tell us if something is an instance of certain template like vector of int is an instance of vector but int is not instance of a vector and a little bit of a tricky one vector reference is not an instance of a vector maybe we'll talk about that in a second how do we do that well okay this is a concept and the concept just calls into implementation right implementation is done here with the template specialization i have a default case it's gonna say no and i got a specialization that is going to say if it matches like you know if this is a template what and this is an instance of a template what this is going to inherit from true so standard false type and standard two type are just tracked with a constant like so you see i get the value here and this is what they provides it's just an empty struct and has inside value equals false or value equals true yeah is it just common as handy is one caveat with this at instance of only you cannot write a general purpose instance of in c plus plus so because as you have either type name template parameters or you know value template parameters you cannot have either or so in this case i only need a type name template parameters that's going to be enough for me that makes sense you're gonna know for me all right next thing forward i believe this version i took from jonathan mueller's blog we all know how to forward hopefully right you do standard forward you know if you t x this is unpleasant because you need to know the type of t so sometimes you have to write put forward tackle type of x x surprisingly this works like but this is also this is really annoying to type so people use a macro right and this is calcium macro looks so you have it's a static card to this decal type is effectively forward but in line so it's faster to compile and here's a dot dot trick is also really cute so like if you work with g-test you know you have to put braces around things sometimes because it interprets commas as part of the macro commas and not your expression commas well what does that that does it basically says yeah treat them as macro commas but then also unpack them all together so if you have a macro with one parameter this is a cute trick okay and with this i'm ready to do a union if anybody has any question i can try to answer that okay so union is something where we're going to store the data right it's similar to c plus plus than that union but built-in union but you cannot unbark into a built-in union so we need a little bit of support like you see union underscore in chart double and i can construct or construct me the second element you know it's a double i can get an element from there destroy construct the first element and destroy this does forget let's start at the end so how do i write destroy i calls to destroy at and i get the address and how they call construct i would like to do the same thing unfortunately it doesn't work there is so instead i will have to write a constructor right a stood construct at and stood destroy at a super useful primitives from c plus plus 20. they allow you to do placement new effectively at compile time you cannot do placement unit compile time but this one works okay let's look at the union itself so we have the it's it's done as a recursor as okay there is a used to be for a while people did buffers so people just created a bunch of charts and they were like okay this is going to be big enough and we're going to cast pointers to the types we have so that was implementation 11 and 14. but that's not context for friendly you cannot cast pointers to buffers if you want to see that solution there is a deadly stack overflow cost what people do now is they unfortunately have to recurse so we have you know a union that stores the union head tail and then we have a default case with one parameter that just has a head i mentioned that type number of associations is important maybe you could have done here like you know tt0 t1 t223 to reduce the number of instantiations but i wanted something reasonably simple okay so there is a default constructor and then there's a constructor for the head so you see i'm passing the index in this standard wrapper saying okay construct mr zero syntax this is just how you pass compile time parameters you have some struct you have a template parameter with the parameter you want and you pass it and in case in this case this is standard in place index d and then i have if it's not the zeros index i would like to construct whatever the next index is i pass it along to the tail basically there is union size just to tell me how many elements are in the union yeah it's it's again very simple it's done versus template specialization i have a base case and then i specialize it for a union and here i say okay size of ts is going to be my template union size and get so get the implementation of get is very simple right if it's zero forward get head if it's not zero your tail let's say you see we're using tools forward and this becomes very clean implementation compared to me having to retrievals and forwarding myself the tricky part is a requirement right why do we want requirements well because everybody has a get on your gets will clash so you really want to have some sort of constraints so this is only this get matches in theory i could say right instance oh sorry of union that would be my expectation that i could have said that unfortunately this will not compile because of how perfect forwarding works nico mentions that his skin not as his day a little bit as well basically self here will deduce not as a union but it will deduce as union reference sometimes so this is a big kind of controversial topic like standard ranges concepts like forward range and forward iterator they will eat up references standard what's it regular type will not adapt reference which one is it correct i don't know sometimes i remove reference in my concepts so here i didn't and this is why i apply instance off to removing reference sorry uh type name yes this is why i apply instance remove cvref when i do instant self and the second requirement is yes that basically index is less than union size okay thank you very much all right if that makes some sales we're going to go and do a switch all right again we would like to unbucken the switch but that's not possible so this is another important template meta programming technique you because in in all other cases the code gen would be identical regardless of rather whatever technique we do here depending on how we write implementation of our compile time switch like the result will be different so we want to understand what assembly we get in the correct case and then we're gonna try to munch it right so this is a kind of correct case and what do we see we see a jump table specified and basically you know we compute the index and when do jump to the correct position so this is a general like let's first figure out the interface that we're gonna have for our switch right you see i have the switcher class and switcher class accepts how many cases we have as a compile time parameter right i have a parameter here and it accepts kind of a number of cases at compile them and then it has a lambda for each of the cases where the label of the case is accepted as well as compile time parameter all right and then i'm going to call it with a runtime index okay so how do you again how do you pass compile time parameters well you i have a struct it has a size t parameter in it and i have compile time value to generate this track just for i guess cleaner interface there i could have gone and did auto here instead of size t but then what comes is that because compile time doesn't like to do conversions then and i really want size t i don't want any other type you have to basically in all the invocations make sure that this is going to be size t so it's annoying that's why i chose to go with safety here let's look at kind of like conditions so we have a struct and you see here i don't pass any compile time parameters but nevertheless switcher is a struct it's not a function how does it work it's ctad from c plus 17 compile time argument deduction right i have a constructor with two parameters size and operation right and even though size is not used anywhere here oh it matches against this parameter and that's why because c plus plus knows that this is the parameters i want yeah the result type i'm not doing anything fancy just as a result of the first case is going to be result of my switch and the implementation and i'm gonna skip this one this is i took from mikhail dominic in variatric expansion and examples the reason we're going to skip it is because it's not going to give us the result we want it's doing an array of function pointers and it is jumping to the array or to the appropriate function pointer for the case however you can see that there is a call and this is not what we want in assembly so this is not what we're gonna do a second implementation is i learned from sean baxter that clank and gcc can optimize a sequence of ifs into the correct solution so we're going to generate a sequence of ifs and we're going to generate it with a macro i'm sorry basically the macro has two cases like it has ifcon stacks per check first to make sure that we don't try to call some things it doesn't exist if we set 10 cases we don't try to call it with more than 10. right and then it has a runtime check and then i have 10 cases and then i have 100 cases and i'm gonna you know do a thousand cases and if it's more than a thousand recurs right and this will generate me a jump table i'm not going to make it through it looks right but it's not going to be the same as the switch just not quite matches and the compiler generates that one for the switch so the one i actually go from i take from this groundswell audio github and this is actually a switch just basically we generate a case with a macro right and we're just gonna spam a bunch of cases in a switch yeah don't forget to undev your macros for things like that just so they don't pollute a namespace can you not thank you very much okay so with this we kind of build up a little bit of tools to do the visit itself let's see how this looks what are we trying to do so as i mentioned private doesn't really work for templates so what i'm doing instead is i have a details namespace here and i do all the things there and then the private and the accesses and all that stuff is going to be in like surface layer so i have variant data and has index and index is at least this many types we have this utility unit at least i have the size here to help me know how many elements union is to store my data and then index there's a little bit of a question what do you put first like the data or the index and the reason why i think you put should put the data first before the index is that index is very likely to be like a byte and so it's going to mess up your alignment and basically you will have a giant gap between like index and the data right let's keep the all of the no accepts and results for now and just look at the runtime code this is our switch right we have a computed how many cases are going to be in a switch well we had a bunch of variants multiplication of sizes is going to be the number of cases we have overall for each case we need to convert like okay imagine we have like five variants but switch operates on one case like it goes zero one two three four so we need to convert that you know zero into five indexes so first element will be zero zero zero zero zero and zero zero zero zero zero one etc right so there is a class that does it for us and then we call for specific case right there is a little bit of a trick here so you see we call the switcher right the trick is that in this specific case we need to check if the result type is void and if it's not worth if it's void we cannot return in this specific case this is just one of the c plus plus weirdness because okay so basically let's look at this mass class like how do we convert from one index to many indexes [music] it's actually it's the same logic that you would encounter in c arrays right so like you have array with three four and two this is actually a linear array and so i basically implemented the same logic only myself and i you know check that everything matches yeah so like this is like the math just i convert from you know from a scalar index to array of indexes and from array of indexes to scalar index this is not very interesting what's interesting is how do you apply you need to get you need to apply for like every element in the array you need to get an element do template meta programming with a rate and you can't so here we're actually using stood index sequence right index sequence is this type that has a bunch of parameters like a bunch of indexes right now and so it's going to be we're going to convert an array into this index sequence how do we do that right so this is a standard trick like you you what you do is you write your array of indexes into account stacks per variable right that's the first thing and then what you do you unbox for the every element in array because it's a context per variable you can now access it in any template you want so you unbox that array of indexes like you you create an index sequence 0 1 2 3 up to size of the array and then you return the index sequence where you get the element for every index so okay this is going to be index sequence zero one two three up to size of the array then i'm gonna return an index sequence is going to be array zeros so like i zero a1 a2 a3 in an index sequence and now i can mess with it i can do all the template meta programming against it specifically i can unpack it into this or and i can then use it into when getting index from variant this is probably the most complicated thing here kind of have a look at it if it makes some sense index sequence is array or is a sequence of numbers just a template i unpack over it so this is gonna i'm gonna create get the first element from the index this is from the first variant second element from the in the from the sequence from the second element and so on okay if it's still confusing like there's going to be an example to unpack a tuple on cpp reference look at that ah finally that's kind of deals with runtime now we just need to do the com the return type and the no accept and we want to be able to check in concepts that we can visit things so this is i don't know how how well understood it is but okay let's see so let's say i have a concept as i have a function call foo right and all right and it's just going to call x dot foo right and i have a concept can call foo that calls foo which makes sense right then i have a struct and it says can't call fool and compiles i can make it bigger if it needed okay all right however if i type in int it will also say compiles right despite int not having food the thing is right that concepts and everything like that it's checked only at the signature right and like so so like for example one way to make it work actually so this is not this is what's not concept friendly right because concepts will not detect this that this doesn't work so if you want to make a call foof concept friendly right you need to for example require specify in the requirement and that you want us to x.food to work right i say has method foo and now it works or this is preferred right or i can mention it somewhere in the let's say return types that also works so let's let's mrs decal type x dot foo and here i'm gonna say auto and well i should return probably right this also works it says oh it cannot call foo like it's it can however what happens if i just say auto right it should compute the return time well in this case this becomes a hard error this is not concept friendly right so you basically if i write it like this with just auto without mentioning the signature any parameters all right then you will have a hard error even if you try to check that it works in the concept and this is done for you to avoid kind of silly bugs if you made a typo in the template and you have a default implementation right you don't want that to suddenly accept work with default implementation you want to get the bug yeah before c plus plus like constant friendly is my term official terms that everybody uses is finay friendly because this is what khazashi works it has used to work especially before 20. okay so the problem with concept like if we try to specify as with concepts like if we're trying to specify requirement this concept for a variant it doesn't work very well i couldn't get a very nice error message so i'm going to show you a different way to do it we're gonna have a common type utility basically very simple like you know a common type between int and double that's a double right common type double in insert 0 double type between string and int what i'm gonna do here is i'm gonna return this weird thingy called no common type right and what this will give me is when i have a function that returns like whatever this thing right a common type it's going to report me an error sorry well you cannot see this but it says tools no common type int basic string and this is one airline so utilizing named return parameters to indicate errors is a very powerful technique to give your users nice error message how does it work well i have just normal common type this is just the weirdest simple thing i have a concept called error tag it requires if t has an is error inside and then what i can do is if one of them if one of the common types is error right then i'm gonna return that because let's say something inside of it failed like one of the variants couldn't compile one of the visits couldn't compile right otherwise i'm going to try to reach if there's a standard common type to compute the common between all of them i wrote you on that and otherwise i return no common type between all the errors yeah now let's do one case so we're going to compute the result for one specific case let's say i have two variants between a b and c d and i have a visitor right and like in the heroes case like between this one right so when it matches zero zero let's just return me a ref right and so this is zero case a refref in the first case it's going to return ah it's no accept it also returns me if there is no accept or not okay so how does that work well basically both result type and no except i derived in from one common struct all right i just call a function and it just me struct that contains both results information right what does a function do the function uses okay like we had v1 and v2 we want to get a and c right this is what we wrote the mass transformation for like get me zero zero index right this is what we do we unpack that we get those zero and zero zero and then we send it into a structs i was at the specialized in the default case it's gonna return like no invokable type and when it is invokable then i'm going to return invoke result for the return type so yeah and then in the default case no except is false and then if it is invocable then the no accept is actually computed correctly and now we can do the overall visit so let's see what i talked about with error messages right it says cannot call visit whatever substitution failure and not an error blah blah blah and it says not invokable and then it tells me this is my lambda this is the first parameter this is the second parameter i'm really sorry you cannot see it but trust me it says it's in okay so the no accept is very simple like if all of the cases are no except then the result is no except this is just an unpack with end that's it the result is using the common type so we we take for all of the cases we compute one case result and when we throw it into common type and then we check oh if it's an error tag then return it otherwise wrap it and return yeah and finally we need to drop this this is a detailed stuff so we need to put it inside of a variant itself so how does that look sorry so this is where we do the private stuff like so we have the variant and it's private there is data in order to how do you get the data from here right like so i mentioned writing friends is hardened templates so instead what i do is i have the you know my detail namespace and this covariant where i have get data with no concepts that is very simple and i'm gonna friend just that right okay so constructor how do we construct we find an index over type and we can and we assign we constructed that index one signs that index how do we copy we do a visit for detailed stuff right how do we destroy we didn't visit and finally how do we visit we do we visit there is a there is all of the requirements right so we need to what the requirements like all of the variants should be an instance follow variant that's the first thing then no except is i'm writing now except here as if the detail is no accept call because that is computed correctly using our l2s and the result type the result type is i have to duplicate here the same thing i wrote in the detail to get the nice error message right so it again works i have here if zero one sec where is it yep look it says non-invocable with lambda and the parameters says so there are other things i did like this is again url to the slides i'm one of the maintainers of eve symbi library if you want to check that out there is a talk by me joelle falcu there are a couple of introduction to sim detox by me this is my email and twitter and this is sorry this is hopefully that works yep ssl tests test test test and this is implementation of a variant and less than 500 lines of code and with it if you have any questions i'm happy to answer like hopefully you were lost like you know closer to the end questions i'm wondering what the debugging experience is like for debugging these things can you speak to that at all well you can put a breakpoint inside the lambda and then you well you will see i don't know let's see you will say details visit let's say and after details visit you will see the switch here and then you should see your lambda right so it shouldn't be too bad especially with like you know hide my stuff what's up what the what's the visual studio debug thing that says hide mic only my code there's a visual studio debug thing that hides the implication details and for the compile time only parts of this though you can't use a debugger miserable miserables that's a debug experience it's more what i'm talking about yeah is it good of anything for that side or is it just no but i think i think that if you get so like the the one line the point of error messages like trying to generate a small error message is specifically for that like so there was a lot of effort to try to get you like one line that says what's wrong because other approaches will give you just like other everything is wrong or like it will say um like just the giant stack trace if it's not against expert friendly you can also static asserts that's a very reasonable thing to do but that's not gonna be concept friendly like if then you cannot check whether something is invokable which is reasonable which is a reasonable thing to do for your code but for something like a variant where it's very general purpose probably you want to be concept friendly and no except correct thanks okay we've all just got the five minutes back thank you for coming