let me know if this has ever been you coding along in c and something goes wrong on your program you're not entirely sure what so you add a bunch of print statements all over the place to figure out what's going wrong and eventually you can't crack the code so you throw away your code and start over stop doing that in this video we're going to talk about the power of core files and how you can use core files in conjunction with gdb figure out exactly what is wrong with your code and level up your debugging process by using this you can take on your next big project and not worry about complicated crashes that happen as your code gets big let's get into it so for our example today i've written here in inventory simulator the idea is the inventory simulator has a bunch of boxes right i can either print a box i can edit a box where i can quit the program and these boxes are described here by the structure where we have an int that says the box is already in use and the stuff that the box contains and you can stuff up to 64 bytes into a single box the idea is a program runs in an infinite loop and until you tell it to quit you can either print or edit a box you read in the box id from the user and then go about making that action happen via either printing or editing so a decent amount of code here not a huge project obviously but if it you know if you're not familiar with debugging debugging a project of this size could be a little daunting so we're going to use a core file to show you how to make this program work correctly if we can crash it using gdb so let's go ahead and run this program for a little bit and mess around so we have the program compiled we'll do gcc taco inventory inventory.c and we'll use tac g to get debug flags built into the program so we have to eventually debug the core file we'll have all the information that we wrote in our source code reflected in the binary so we'll do attack g there and with that we can now run our programs we have our inventory simulator so if you want to print a box we type p and we could say box let's do two then we see that box 2 returns nothing because nothing is in that box so let's go ahead and edit box cube we'll say we'll edit box number two and what's in the box we'll put aaa bbb ccc cool and then now if we go in we print box two now that data is in that box well what if we wanted to edit that box again we can edit and we'll type box two and it says nope sorry that box is already occupied we can't edit that box so pretty easy functionality here not a whole bunch going on well what happened if we wanted to do edit on box some huge number see how we got a we'll do it again real quick edit one two three four we get this thing called a core dumped what that actually means is that the computer dumps out what's called a core file this doesn't always happen by default and i'll show you how to make it happen in in this case i have a core file that's dumped here the core file is an elf that contains the full state of the program when the program crashed if you don't get a core file when your stuff runs you have to do a few commands the first you're going to run is u limit tax c for core and then type unlimited this means that the kernel is allowed to produce an unlimited amount of core files and then what you have to do is do cat proc cis kernel core pattern for me i made mine dot slash core so that the core file gets produced locally to the crashing program yours may be something different so to change it all you have to do is change to root so now that your root and you can do you know we'll echo new core and we'll write that pattern to this file here and if we cat this the new core pattern is created so if we crash our program again should get a new core file so that means that we now have a core dump from the crashed program that represents the program in the state that it was crashed so now we need to do is use gdb to figure out what went wrong take this core dump and then compare it to the elf and figure out what about the execution broke the program the way we can do this is we do gdb right so you have to have gdb installed where you install gdb is sudo apt install gdb i already have it installed so i won't do that you'll do gdb the name of the offending program so for me it's inventory and then also a third argument to gdb is the core dump you want to analyze so for me we'll do new core and what you'll see here is we actually get a pretty robust output of the program in its crashing state so we say the program terminated with the signal sig sag v or a segmentation fault it terminated in the edit box function where the variable i was given as a parameter and i was this number at inventory.c line 22. that's extremely verbose this tells us exactly where in our program our program crashed we can actually take this and go back and look at our source file and figure out what happens let's go back and check that out right now you can go back here and it said line 22. so that means that we're in our edit box function we have i as a parameter and something about this line is wrong this is what caused it to crash so now what we can do is we can actually look at the assembly instructions in the register states of the program and figure out what went wrong so we can do is we can say examine the instruction at pc and we could say info registers so what this tells us is that we were doing the instruction move the value of eax into this location here so this is rdx offset by rax times one so we'll look at those registers here and we'll say rx and then rdx and this is where we get into an issue so what's happening here is because our index was so big if you look at our source code i only allocated enough memory for a hundred boxes and i was indexing into this gigantic number there's actually an integer overflow that happened here but this gigantic number is what got indexed into in our program and what we have to do is now to fix this make it so that the user is not allowed to index above this 100 so we'll go into our program and we'll say if i is greater than 100 print f you can't do that dave and we'll return zero we have to do the same thing for the read int function because we don't want to give the same issue i'm sorry not reading we want to do this for the that was for edit box and also that for print box because print box can yield the same issue so now we can take these fixes that we've made here we can go through and compile our program with our newly implemented fixes dot c tech g got two warnings here oh we don't actually do return zeros in a void we'll delete those real quick cool no warnings inventory will retest our crashing case and we'll no longer crash the program by using a core file you can instantly see the state that the program crashed in and then use that to back reference and find bugs in your code if you're new to gdb go watch this video on gdb or watch this video that i think you'll like it just as much thanks for watching