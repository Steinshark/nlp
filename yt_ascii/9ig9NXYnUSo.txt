this is just a talk and that is i want to talk about you about something that that we have to know of and know better which is universal or forwarding references and yeah because it becomes more and more important one reason is to deal with views you might need it so let's let's jump in we only have one hour so you all know what references are if we have an object that exists wherever it comes from you can create a copy but you can also create a reference and a reference means you have a temporary additional name you can change the object you refer to over during the lifetime and if you then use the reference of the original object it doesn't matter so if you modify one we modify the other the reference might have additional attributes like being const that means we cannot use the reference to modify it but the original object can still be modified now i'm using interior but we can also use auto here and auto means that the compiler finds out the type so and that all is used that when we can use reference to pass objects by reference instead of passing a pointer which is simulating call by reference and c we use powerback cost by reference in c plus by either passing objects as a const reference are as an unconscious reference as a const reference we just want to skip copying we want to avoid copying and as a non-conscious reference we might want to have clank the argument so it's an it's an out or in out parameter in that case so i don't i think i don't have to tell you the details you know all that so one thing that's important to know is and that is one thing i see not app that everybody not everybody knows that is that references extend lifetimes of temporary objects so i can say here i have a return value a function get value returns a string and by by initializing a reference so here declared as a const reference i extend the lifetime of the temporary normally at the end of this statement otherwise the return value would be destroyed but here we extend the lifetime and to say one thing here is we only extend the lifetime of what is what the reference refers to not anything that is indirectly referred so we can then use the object without the need to really initialize an object which might be a move or copier depending on the exact c plus version you use and well things are optimized away and so on you cannot bind a reference a non-const reference to a temporary object and oh that animation is one though but that that does not compile but you can do something else you can use an r value reference which we have since move semantics which means we have something that is about to die and then in that case we can refer to a temporary object and in that case this object does not become cons which sometimes is needed for example when you use views and then you can pass it around now we might think okay when i use this example let's switch again from just a direct specified type to auto and now we have exactly the same behavior but it's not it's not exactly the same because this is special this auto width to ampersand is special it is a universal reference or a forwarding reference and that's important to understand what that is so coming back to that we will solve this and look into details over this hour so coming back to our value references we introduced sam originally for move semantics so this is what i usually use to teach to motivate move semantics and why we introduced it this is a vector on the left it has pushback just a pushback member and that was before we introduced move semantics and on the right we could push back an object that has a name we say it's an l value we could push back a temporary object returned by get data or just the sum of two strings here which is also temporary object returned by an operation and we cut also even push back it even though we don't need it anymore and in all the letter cases we did originally copy the objects but these were unnecessary copies and it turned out that too much operations are involved especially with strings and they allocate memory so that this code pretty often was not optimized so the you can see well compiler can see it all but there was too much too much involved so we came up with this idea in c plus plus 11 to say well let's introduce another pushback and the other pushback is say taking an r value reference so a new kind of reference the one with two ampersand you have seen that all now that was 11 years ago so and now the the original references are called however your references and now we have different rules that we when we pass an opsec the compiler looks is it an object with a name an l value or an object that is temporary and r value and depending on that it calls the first of the second pushback so one pushback if the caller still needs a value one pushback if the caller no longer needs a value and the only reason we have to specify something with move is to say well hey compiler this has a name yes you you cannot know that i no longer need the value of this object so move says in fact i no longer need this value here i'm i'm most always searching for an acronym for m-o-v-e says this sentence so if somebody has said so i could explain it better so this is not about move semantics this is about universal references but we have to clarify things before we start and jump into details and one thing i also have to clarify is about value categories so value categories when i asked in trainings who knows value categories nobody erases a hand if i ask who knows about l value as a novel you say oh raise a hand and say that's value categories so and let me just ask you in the room who thinks i have understood what an l value is that's a trap question of course you can only lose well okay so let me ask any a simpler question what stands cl for left connected here's somebody from the committee l means left is not true well it's it's no longer true and means locator yeah so what is a we have to talk about that so it all started with cunningham and richly c so 50 years ago we have the 50s birthday of c and we are still compatible to that and that's why we have all this mess now this feeling okay so they wanted to say when thus a statement compile or an expression compile and it's not enough to say the types have to fit because you see it here the type of i is in the type of 42 is end but one of the statement compares of the assignments and one does not compile so there must be something more and instead of writing a long list of 100 things that also have an impact whether something is science we say well on the left hand side there must be an l value yes and there's where the l came from so l was right element can be on the left hand side of an assignment but it was not only for assignments it was for other things like can i take the address can i take the address of something and yes you can take the address of an l value but not of 42 so not of an r value which is the other thing the thing that can only be on the right hand side of an assignment a couple of years later things got complicated because c the programming language c introduce const so now we have something like this const in c and it turned out that you can assign no you cannot assign an end but you can take the address so when i now formulate the rule should i say this is an l value or should i say this is an r value what is the category of this and that was the moment where they thought about it and said okay wait a minute most of the things can still be done but one of the things that cannot no longer be done is to be on the left hand side of an assignment so l no longer meant left it now means locate a value that that's a term written in the c standard you can see it there they have no term for the r now so i don't know so readable value might be the right thing so so that is what it stands for now and then we came up with with move semantics and c plus plus we adopted the whole thing and then we came up with move semantics and in move semantics we created an interesting problem we said if i have an l value an object with a name and i mark it with move can it be on the left hand side of an assignment can i take the address so let me just guess so who thinks that the statement in the middle std move of s gets the value hello who thinks that this compines okay i would say 10 percent thinks that the last statement compiles though that you can take the address of an object marked with move almost nobody well five percent so here's the answer well if this is a string if it's an end then the answer is different nothing is easy in c plus plus you know that okay so there are reasons for this answer we don't have to explain that here and i couldn't do that there are reasons that we wanted to have this behavior so and the problem was with that behavior now what is this is this an l value on r value if i mark s with move what is the expression and the answer was let's come up with the new name let's call it x value a new category x for expiring value and and then turned out but you know most of the things that apply to x values also apply to r values so let's let's do one more move let's say well x value is a special category of r values and the former things that where r values are not x values we'll call them now pr values did you understand what i say no somebody says yes but you knew it all before huh yeah okay so this is what we have now as rule in c plus plus we have in any expression in the program when you compile it either it is an l value on x value on pr value if it's an l value it is a locator valued and that means roughly you can deal with the address of the object in the program it has a location in the program you can use in your code so examples are everything that has a name and string letters are l values so variables spring literals returned l value references functions data members of l values so then the next category is pure r values that's everything else we had before move semantics so and we call it the r values there still are values but now they have a special category so any other literal and those objects that don't have a name temporary object that don't have a name and then we have this special category x value which means usually objects marked with move and move is just a static cast to another value reference so that is you can instead do the static cast to another value reference and that is also has also such category okay let's see whether you got all the rules we have here a declaration on top a function f overloaded for a non-const l value reference and a const aloe vera reference on the left hand side we create a have a class and we create a non-const object and the concept object of that and then we try to call the functions also with the temporary object and what this table shows you what is possible and so what does compile and which priority it has so here you see that for v would listen modifiable l value it has a name you can call both functions but the one with the non-constant value reference is prefect for t which is a non-model l value you cannot pass it to a non-const reference and you can only bind it to a const reference and temporary objects have the same roots temporary objects formally known as r values now exactly being pr values they are still our values because that's the precise category they follow the same rules okay and now when we then extend it to move semantics we have a couple of new situations one of them is we can have our value references so we can declare f to be taken our value our friends okay and we have a new category that is an object marked with move which is an x value and here are the new rules the new rules say first of all and our value reference cannot bind to an l value you know what that's why it's called the naval your front because it refers to our values only and and if it exists it has the highest priority if not that's a fallback and the fallback is a const elway our friends what you see here is if move semantics is not supported we switch back to copy semantics if we have a no move constructor copy constructors used or if we have not overloaded the functions the other one is taking so you know all these who is not already something nobody who is who has learned who has already learned something here in this talk oh my question was wrong good so i can't to the slide where i deeply apologize each and every time i use it i hope it's not my fault but it's important to understand that if you don't know that yet if you have a function take in an r value reference here for a string it can only bind to r values so if you have an l value an object with a name and you pass it you get this famous as an error message cannot bind another reference to an l value yeah you know what that that's how we build did build it we did build it in the rules of the language and of course and in the compilers if you pass string literal that compiles now everybody in this room has to scream but wait a minute what is a category of a spring literal no what what sc category of a string letter l value so what the hell is this guy in front telling you well you could believe him you would believe me everything yeah that's anyway because it's c plus plus it's not because it's me and no that's an l value and it binds to an r value reference so why it's a gas there's a hidden operation yes because the type does not fit so this object is converted to a string that string is a temporary object so a pr value and that is has is an object that has no name and can be bound to another value reference so what you really compile is that okay to pass string you have to move it this slide is not over let's implement this function and that's very important let's implement this function we have s being an r value reference what is the value category of s l value yes it is an object with the name it's a null value so the rules of l values apply and that's funny that means you the function you cannot call yourself that will not compile because you cannot bind the novel your reference to an l value when there is no hidden operation converting it to something else so you have to use move again and that is the secret hidden details of our rules that move semantics has not pass through just because plus when we call this function for an object we mark with move inside the function it has no move schematics until we mark it with move again move also only needs i no longer need this value here and here we say i no longer need this value here and for those who are asking why the hell did you do that if we would say move semantics has passed through then we couldn't use s twice because for the first time the value would be moved away or we would need something like unmove or so move is nothing but a static cost to another value reference so that's funny if you really read this line we cast s to its own type but the point is that a static cast does more than changing a type it has a rule if you pass to another value reference it converts it to an x value it changes the category okay and if you understand this slide and you didn't do that before you understand a lot more and a lot of the things that go behind the scenes in c plus plus okay good so let's use this whole stuff so we have foo constell value reference binds to everything good it's for read-only parameters we have foo for non-cons we only bind to non-const named objects it's an it's an out or in mount parameter then we have foo for another your friends it only binds to objects without a name or those marked with move so to r values which means to pr values or x values and that's when we symmetically want to steal something when the caller says i no longer need the value there's a fourth category i don't know if you know that you can declare a function taking a const r value reference you can do that that's allowed it's a semantic contradiction because you say well i no longer need the value but you are not allowed to to do anything with my value okay there are easier ways to implement that that's that's the first function but in principle that's okay and if you don't use the the semantics of c plus plus we usually apply with this if you just use the formal language rules you have a way to say if something is marked with move and there's cons here's an option to deal with it and what we learned in the standard committee over the past 30 years is there's nothing crazy in the language where we don't find a good use case for it by the way you have that pretty often you just need a console object and mark it with move then you have such a thing which is not a good idea because then you have disabled move semantics and because but pushback we only have is still there for concept x so we fall back to copying and for this reason you could also not use move if you have the const alpha your reference as an argument and really nice is you have a function returning a constraint a couple of programmers do that they say oh i have a return value of value i don't trust you that you use it useful i make it cons and but that means pushback with get value will no longer benefit from move semantics because you have disabled the move it will still compile and be a copy good so wrong topic we talk about universal references but i have to make sure that you all know this now following from this we ran into a problem and the problem was guess we are overloading a function for the main use cases the main applications which is give me an object just to read give me an object so that i can return you something or give me an object where you no longer need the value and then let me call that function for a non-constant object const object or temporary object or an object marked with move in c plus plus very very often we don't call functions directly and not only a c plus that's part of programming that you indirectly you pass through arguments somewhere else and so let's switch to call foo so which means we call a function and that function calls full for us and how do we have to implement these functions so what from what we just learned clear mind these are all l values const l value non-conscell value so we have to make something different that the last two the the one in the middle should call the one in the middle here and the last one should call the last one so we have to do something with that and the difference is the first two functions just pass through the x the the last function has to mark it with move again so that the move semantic is passed through okay so we agreed that we don't want when we write c plus code each and every time we just want to pass something through in generic code and we don't know what we get maybe anything everything write three functions and it gets worse if you have two parameters you need nine functions all combinations and if you have three parameters you need you can compute it yourself and that was the point where we came up with we need something special and what does confuse every programmer in the world is this something special looks as not being something special and that's cool so we came up with the special rule saying we have some special rules for c plus plus for perfect forwarding if you have one function taking one argument and you want to pass it perfectly to the right function with as if you would have called it directly yourself then you need three things you need a template parameter you need to declare an r value reference of the template parameter and you need forward this combination of these three things thus the right thing the magic is that this forward becomes a move if what you pass is an r value so has moved semantics and if what you pass is an l value it does not move when we came up with c plus 11 we didn't have a name for that for this thing what is x oh it's an r value reference of a template parameter and then scott myers came out with the term universal reference why universal reference because think about the the name pattern of our value reference and the other value reference the name comes from where can it refer to so on other your friends can only refer to our values an l value reference can refer to everything well depending on whether it's constant or not good unfortunately the standard committee does not always like what they see that was to be fair a term of the community scott was not part of the senate committee and they came up with a different term and they called it forwarding reference which was very confusing for me because they call x forwarding reference not x if you apply forward they call that forwarding reference it's not forwarding it's like move does not move it only marks it as movable so forwarding reference means you could use it for forwarding but to do that you have to use forward i was at that time not as wise that as i am now which means i didn't understand everything i see now but i i didn't feel comfortable with that we had the discussion what should i use as time in my books in our books the template books we wrote the second edition of the template book there and if i would have known what i know now i would have said no i don't switch to forwarding reference because the point is you not only need it for perfect forwarding that is one use case of what you see here and yeah the use case here you have a universal reference and with forward you forward something okay but now we have two terms and you have to be very careful if you see code if you see code like this you see a function and the function has a declaration with two ampersand you have to be very very carefully look what the thing on the left of the two ampersands is if it's a type it's an r value reference and then the rules apply that say you can only pass r values it only binds to our values so temporary objects or objects marked with move l values you cannot pass l values so if the thing on the left of the two ampersands is a template parameter then formally this is still in other reference but an other reference to a template parameter and for that we have now the special names universal reference of forwarding reference as you like and then different rules apply so you can pass everything but it's it's even more if you have an r value reference a raw r value of friends you know that the object is not const which is not the case here on the right and if you want to forward it to somewhere here move is enough on the right hand side you need forward okay so no i skipped that slide i want to talk a little bit about the details here so just for fun so if you read the standard where can you read this what i told you right now where can you read this in my book yeah in the muslimatics book it's it's written there it's a little bit tricky to read it in the standard so what we have here is the following if you call a function and you have a template and you have an r value reference to a template parameter then what you pass is something where you have to deduce the template parameter t from so the compiler has to find out what is t here so there's a special rule saying that t is not just the type if we have the following situation if the parameter is another you reference to a cv unqualified template parameter see where unqualified means a template parameter that is neither qualified with cons nor with volatile so this case here we have a an a parameter not qualified birth constant volatile and it's an r value reference and if then the argument is an l value that is the case here then the type of t is the type of this is an l value reference to its type so therefore t if you ask t but what is here type and you when you call this function it's a it's an l by reference to c or const lv reference to a c if you pause an l value otherwise t is just the type so now what is the type of x we deduce t now with that we know about the type of t is okay what is the type of x the type of axis something of this as an r value reference so t this type with two ampersands behind so there we have other rules in the standard we call them reference collapsing so if you have a reference to reference what is the resulting type and the answer is if you have different kinds of reference what you get is always an l value reference in except when you bind another value reference to another reference so when anything is already has two ampersands and now you apply two ampersands to it with that rule we now know what the type of x is it is l value reference to c or to can't see if we pass an l value and if we pass an r value it's an r value reference and that is used then by forward to expand to move so move is then a conditional conditional propagation conditional static cost i'm using also some trick i don't explain now which says oh and then with that information we cast to the forward becomes a move this is not for ordinary application programmers this is how we specify and i'm i could not i could never even come come up and think about this it took me years to learn it so that means when we come back to this example if you have the thing on the right here the the t if you pass an l value the t is an l value reference if you pass an r value it's it's just the type and the x is an l value reference or an r value reference so if you ask what is the type of these things inside you get these answers and then we have two ways to do that what you just saw here with not even not only use for templates we also use it for auto so we said oh we need this mechanism not only for templates we also need it when we have not a parameter not something that is a template when we use auto so this to ampersand template parameter is a universal reference and auto two ampersand also is coming back to our example where he said this is special this is not just the now value reference to a string that is returned this is a universal reference and that means the thing on the right can be everything because that is what was the cool thing why we introduced that we want to have something that can bind to everything universally bind to our values and l values so that's why universal reference is such a perfect name for that it was just too universal there was one argument because you cannot find it to to i know it doesn't matter okay good so that's look it and look at this and with another example if you write generic code look look only on the left hand side of this and you declare something with const alto l value reference you can initialize it with everything an l value an r value and r value i mean a temporary object and pr value on x value and the only problem is with this reference whatever we bind to it is const we can no longer modify it from here when we remove the const here in our generic code the point is the thing on the right could be just a function call and you don't know what this function call returns could return everything so so when we want to keep this perfect yeah what do we use but this makes it const which is in many cases okay but there are cases where you don't want to make it cuts so if we remove the cons then the problem is a non-const layout reference whether you write it with a type or with auto does not bind to another value so you cannot use that and the thing on the right gives you back a temporary object and now here's the answer the answer is alto with two ampersand can bind to everything without making it cost yeah it's it's a universal reference but we didn't like that term okay here's one application where we need it this is the range base for loop this is another flavor of the for loop not the one where we fix the back the specification the standard says if you have something declared to iterate over a collection so what we declare is each element inside the loop this is equivalent to this code we take the collection and we iterate over it with an iterator here so that means we have to call begin and end but that means we need it twice we need this object twice and to have an object twice you need a name for it otherwise it's not possible think about this we would have here get data and we would just say this is we call rg dot get get data dot begin and then get data dot end we would call get data twice but what we have to write as code is we call get data and then we call for the result begin and end but we don't want to copy anything here we don't want to initialize a new object we want to take the return object as it is so that's why we declare this as a reference and then call begin and and for it and then we can iterate over this loop so if you have that that code is compiled but i wrote a reference most of my trainings i don't explain what that is but this talk is about universal references and guess what it is one because you have just learned what we need here is something where the thing on the right the thing behind the colon of the range base volume can be everything so in our value on l value cons or not cons and it should not make things const so not cons we have to use a universal reference that's a perfect application of that so what time is it okay there are a couple of things if you know what i had that really create more trouble than what i just told you so one thing we have is how do i specify a universal reference to a specific type which means the problem with the universal reference is that it's generic it can bind to any type but that's not always useful sometimes we want to say this is a function just for strings but the string might be in our value might be an r value might be constant might be not const so how can we specify that it's not easy to do that you have to write something like this so in c pass was 20 which we have now you can have a constraint so we have a template parameter but this could be at everything so we in addition have to say that we require that this template parameter if we remove consciousness and referenceness is a string and but it is it follows the rules of universal references so this function binds to our values and our values and they might be const and might be not cons and sometimes you need that when when you want to support implicit conversions you have to use convertible 2 instead of same as here this is concept of c plus 20 they're looking a little bit like like type trades but type rates with special rules so that you can use them to constrain templates when even so here we support implicit conversions when you even explicit conversions should be allowed you have to use requires constructible from please note plus to confuse the russians you have to change the order of the parameters here another problem we have is how do you specify a generic r value reference that should only apply to our values so because when we say it's a t ampersand ampersand it can also bind to l values but we might say no it can bind to any type but it should be and could only bind to our values but any type of r values so this is this what you want to say very carefully chosen i had to discuss it with a couple of people in the standard committee we came up with different solutions yeah you say yeah yeah can be any type of any type but the thing we get is not an l value reference before c plus was 20 you had to use enable if that's always fun to use enable if so it looks like that if you have heard of if you have never i've heard about the enable if that's good forget it and then i skipped one thing but i just want to point out another interesting question is if you declare this not as t ampersand amazon you call it t iterator and percent ampersand t colon colon iterator and percent emerson what is it another reference or universal reference it's in our algorithms you you really have to bind directly to a template parameter not indirectly and it has to be a local template parameter it's not if it's a template parameter somewhere over there just a local template parameter in the function you declare we should have used a different syntax for that and sometimes we have this nice discussion saying what if we would have taken a different syntax for that maybe 3m percents your reaction is a problem it would look so funny not cool but everybody would understand the code and we would not need all these workarounds i had to think about that when i thought what i told you in the keynote about stood as const and strangeless as khans slightly different slightly the same but slightly different cool is not a good idea in programming precise unique is a good approach so what else let's talk about how do we return something so oh we want to return something perfectly of course when we use auto that means we return an l and excuse me a pr value and a new temporary object we create the return value by the way also the default of lambdas where you don't declare an alarm that the return type the return type is auto so when you have a return statement in a lambda it creates a new object oh uses what the object you return as your return value so you might say here oh wait a minute i know how to perfectly return something it's auto with 20 a universal reference awesome problem solved well that's a reference a reference to something local that's never a good idea it could work it depends what fool gives you back if what fool gives you back is something static and you only refer to that fine if fool returns your temporary object you return a reference to a temporary object not a good idea compilers will warn you that's a good news so for that that was also very ugly workaround to deal with that and for that in c plus 14 we introduced decal type auto deco type auto says maybe a reference maybe not it's a temporary object if this is a temporary object so r value we return by value if it's an l value return by reference roughly speaking the the story is a little bit more complicated but we have no time to do that so in generic code we have a couple of different things when we use auto auto just plain auto means a new object a temporary object of a new object local auto with an ampersand means we refer to something as it is but you cannot bind this to an r value so to a temporary object or an object marked with move const auto reference means yeah we bind to everything but it is const it became const without the cons it is always a reference maybe counts maybe not depending on where we refer to and decker type also means if it's a temporary object it's an object if it's binds to an r value it's a two and to a reference it's still a reference pretty simple huh so and that is where i come back to what most of you have seen yesterday in the keynote where we have this saying where we said oh we have views and the views and cache something and to catch something they they have a problem that means why you are iterating you are using them and you call begin you'll modify them and that means you cannot pass them as a const so we had the example if you call print and the declaration is a cons alto reference that means that you cannot pass this because this was a view that internally caches begin and that means while it iterates or while it starts to iterate while you call begin which is the first step when you iterate it modifies the object and that is not allowed and we had to do that and it could work here but here we had to say whatever we pass keeps its state keeps its category keeps its type and that's why we have universal references universal reference means take it as it is as if i would have used a macro yeah you can universally refer to every expression temporaries and r values as well as l values without making them const and it's very interesting i think when we start again think about that this is our default reference type by default the reference is a reference to what it is and then you do something different to to change to say it's cancer whatsoever but that's would be a different programming language no i'm not writing in a new language okay so universal forwarding reference are used for perfect forwarding and unit me personally referring to expressions without making them const so they they deserve both terms universal reference and forwarding the only what i don't like is i always have to explain a forwarding reference is not forwarding unless you call forward for it it's necessary for generic code taking containers and c plus 20 views please note there's currently no way to declare a generic function that takes both content non-cons and both containers and views and guarantees by the signature not to modify the elements it's not possible to do that an old discussion which i thought was over but it's my fault it's it's there again i'm no longer willing to use the term forwarding reference i think it's a wrong term universal reference is the right thing looking back i don't know why we because we had that time already why we created anyway the mass we have other terms that are also not precisely correct but you should be happy if we only have one term for something then the next question when do we teach our universal or forwarding references to beginners so this is code i i could imagine teaching in the first week do we want to explain that and okay the last thing is when should we use it so still a lot of discussions but it sounds like more and more in c plus plus now with c plus 20 and 23 of course also universal references or forwarding references are part of our basic vocabulary even for ordinary programmers i don't think that's a good thing maybe it's helpful it but it is as it is i can create a size as much as i like that's c plus plus now and we at least at least have to do the best to teach the rules and the understanding and why we have that thank you very much [applause] [music] [applause] are there any questions i think we have two minutes for a question yeah where do we get fresh air yes not so much about universal references more just like a question about like so when when you show the okay so you can construct a string or you can pass a string into a function taking an r value reference to a stud string yeah you can pass a string literal through it and that will implicitly create a temporary stud string and pass that what stops the same thing happening using a copy constructor if you so let's say you've got an an l value string and you pass that what stops a copy constructor being called to produce a temporary object which is then passed as an r value the roads we have so what it's the rules we have and the roads are there to protect you yeah yeah but what's so specific is specifically a ruling language saying that yeah the words the rules you saw though when you saw this about this here these are the rules these are rules and they are not in that way but more or less directly written into the language and so yes you if you have an r value of reference and it does not bind to a non-conscious end of discussion and the reason is we had a good reason for that we wanted to help you recently compiler error messages should help you to find bugs and the reason was if you have an object that is any way you you're saying well it started before we had move semantics so if you have a temporary object what the hell do you want to modify it if you throw it away right after it you probably made something wrong yeah but so so what i mean is like in in the case where you're taking an r value reference so you'd be making you'd be making a temporary if the copy constructor was called wouldn't you so that would be like kind of okay yeah so is there a specific rule which says like in this case like you know if you think about it if you were passing like a string literal yeah then that will implicitly create a string which can be moved which can be not sure i understand the question correctly but the copy constructor is just an application it's a function that follows these rules so we first have to decide where do what are the rules to bind yeah so but in the case of a string literal the compiler is smart enough to know it can it can it can implicitly convert to a stood string yeah we could we could we trust me we have a lot of discussions what we should do with strip i'm not saying we should i'm just wondering what is a specifically a rule in that says your question i think what you're saying is that ace why is it that a string literal is what will pass to a stood string ref ref erence and why would it call the move constructor rather than the copy so no no no yes you should take it offline in the interest of the people outside online and they