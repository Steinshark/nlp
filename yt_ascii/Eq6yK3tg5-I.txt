okay for those who want to follow the slides they are available on my github as well they should be available on the meeting c plus part where the slides are and if you have any questions you can easily reach me either on twitter where i'm quite active in the c plus plus community and via my email which is positioned here if you some little bit of self-advertising i quit my professorship last year so i'm now available if you intend to get c plus training or consulting or code reviews i'm happy to serve you if it fits my schedule now what classes we design and how first some of my philosophy that i more or less borrowed or stole from kevin henny is i think less code equals more software and there's a lot of value in simplicity and this also should show in code and especially my philosophy is don't write code that you don't have to write and part of this talk is about not writing code that you don't have to write and avoiding code that you might write because you think you need to it where you actually don't need it in addition i often strive to look from a high level perspective to actually be able to get my point across and only show those details that are actually relevant and not building up let's say c plus plus from the ground up which is just too big to get your head around and understand everything so i will deliberately leave out parts that you might oh yeah but in my case i need to if you have those cases come to me and i will try to explain to you where you don't need them now one reason to start from one position i start from higher level if you look at what the c plus plus object is it's in the center terminology ac plus this object is let's say a value with a location and a type and if we that's what we model in our classes most often or in other types and these things that we model as types and that's then used as objects very often take different roles the most prominent role is the role of a value which is kind of what and just what's in the value is what makes how the value behaves how all kind of functions work on it and what we can do with it and we can we will look at what a value how value can be perceived and what is on on one of the next slides the second role that an object can actually take is a subject and for a subject it's not only the value it's it's content that is important but also where it is so it the subject has a location and it it more or less announce it itself by being here having a location gives us a lot of properties especially the next role that we can actually form we can create a relation to a location of a c plus object and the relation more or less tells us where something is and that word gives us additional properties like for example making a subject a polymorphic thing by having a relation to a base class and then hide under behind that relation instances of a derived class or of different derived class and so change the behavior of the system and then when we consider building classes around these things there's something very c plus per specific what we have to create all the other things might be created in other languages as well but nc plus plus is has a unique opportunity to actually create what i call manager types those that are clean up maybe we should call them janitorial types because they are the ones that silently clean up our messes that we create and do every kind of garbage collection or other cleanup that's required and that's one of the strengths of c plus plus that allows us to implement those cleanup types on our own or use them throughout our systems these might not be all models on a high level that you create but these are very important one to get your head around and deal with and not to mix up too too much now if you look at the value rep role of an object what is a value we can look far back in in the system and then again that's a citation i borrow from kevlin it's a value is an intangible individual that exists outside time and space and is not subject to change this is from a book by michael jackson which is not the famous pop singer but one who wrote on structured analysis or domain analysis and other software engineering topics in the past now what does it mean a value that is is just the value it doesn't have any other let's say significant properties but its value so a value is a value if we look further we have some other means where scott myers told us when in doubt do as the ins do which comes from the saying when a drone versus romans 2 but nevertheless ins represent values and a lot of c plus for the most most mechanics in c plus stem from the fact that it supports value semantics which is what we can look at in the following now what does it mean outside time and space even though a value can have different representations it's always the same value so if we use 42 and enter that as a literal there are many spellings on how to represent that literal but the behavior within the program is independent of any of these spellings it's always the value 42 with the type end and what's most important is a value is is a value object is in is valid independent of other entities you cannot invalidate the value object remotely by something else it's just this and that's very important you can pass values across to another thread and because the threat the values behavior is independent of where it is the threat behaves by using that value and it's just there and that's an important thing so values just work and we don't have to care a lot about lifetime and the thing values just are now what is value semantics in c plus is closely related but value semantics is actually the property of a type in c plus the major property is its copy ability so you can have an object of that value semantics type and you can copy the object and the copy and the original object have the same value they behave exactly identical and the original is unchanged by that copy so this you cannot distinguish the original and the cop and and the copy and then we have identical but you can copy in which which is what was actually called value semantics and c plus plus now some people argue oh yeah it has to confirm to a concept called regular where it's actually default constructable and comparable but i would say the copyability is the most important aspect of value semantics in c plus plus and we have even types that have value semantics that aren't values and we will come to that in a minute now cons is somehow an aspect that supports value semantic or helps with creating stuff with value semantic because it guarantees that when you copy a cons object it's not mutated so the original always stays the same and then the own copy only has to make sure that the copy copied object actually has the same behavior than the original in addition we can actually use cons to create immutable data structure with which provide value semantics inherently because you cannot change an immutable thing that means you don't don't get into any problems but this is not the topic of this talk there's a great talk by juan pipolivar and his emma library on how to create immutable data structures and use them in c plus plus and very beneficial so we have values and value semantics what else the second thing that i refer to were the thing that i call subject why didn't i call object well because object has a different meaning in c plus plus than in most object-oriented languages so in an object-oriented language like java what i call subject here would then be an object but why it's a subject because the here the identity is the important part so identity is important and once we have something with identity in c plus plot is it tends to have a location and it has a lifetime so it has it comes into at one point in the program it it starts its lifetime and there might be another point in the program where it lifetime ends and that gives some peculiarities because usually something becomes a subject because i create formal relation to it and that means whenever the subject and the relations life lifetime are somehow coupled and if the sub subject lifetimes ends the relation might still be around and that might mean you have a problem with dangling and in general subjects might not be don't need to be copyable because instead of copying them around you form a relation and then refer to it and being able to form a relation it allows us to create polymorphic behavior in the classic sense of object-oriented dynamic polymorphism now what else if we look at the polymorphic subject types this means we have a base class with virtual member functions and we create derived class and instances of the derived classes can be referred to by a base class relation object and it to put those objects on a heap requires that the base class defines a virtual destructor and to not get into problems there's one let's say deficit in the standard library for example unique pointer doesn't detect if it if you form a derived to base conversion with the unique pointer types then there's no check that the base class actually has a virtual instructor which would be possible but isn't implemented actually when concepts were a thing in c plus with weeks there was a paper not directly proposing but talking about making unique pointer safe in that way by providing the corresponding concept but up until now nobody took the courage to actually change unique pointer in a way or its default deleter to get that safeguard in in the sender library a typical thing in a virtual in a polymorphic base class is that we want to prevent copying so we don't have value semantics for these polymorphic types at least not for the base class type and we want to keep the identity so there's no copying would lose the identity property would lose the original subject and the second goal is to prevent the slicing that might happen when you just take the base part bass class part from a derived class object and you copy it around and there are other means of dynamic polymorphism that are more modern or might even be better suited in a value oriented world but that's not the topic today and if you look at relation types this are types that represent the where of another object and they have some also some interesting properties to think about especially when you put them into class types so what is a relation it's always referring to something else another subject so it uses the identity that another subject another object actually has and refers to it and i'd like to introduce you a new german word for those who are not german speaking a relation object actually enables a fan vehicle and i will explain that in in a second it's literally translated it's a you could say it it translates to remote control or remote influence relation objects also enable abstraction abstraction with dynamic polymorphism and it enables the the use of non-copyable objects we already found one category of non-copyable objects the polymorphic types but also there are manager types where you don't support or cannot support copying and those to refer to those you actually need to form a relation to them now what does fan vehicle mean it's kind of you can access or modify an object that is not part of the current expression everything in c plus plus that takes hold of objects and then the types is is an expression and usually you have all the relevant objects within an expression if you write 42 plus one it's two value objects the 42 and the one and then you have the operation plus and the result is the result of the edition 43 again a value but nothing actually has some fan vacuum to actually get a fan vehicle the typical thing in c plus plus is you use references or the most prominent thing is for example you can use a const reference to access a remote object that is actually not directly part taking in the current expression only the reference to it is partaking in the current expression we can and cons references are mainly used for preventing copies where they are not needed where you just want to access the corresponding value there's another the l value references that you can form and these are for remote side effects so you can actually change an object that is not taking part of the current expression so for example you can have a reference and put the plus operator on it and if that's a reference to an end you're not changing the reference at all but you change the object referred to by the reference that is actually incremented and then there's the third form of reference that we can form the r value references and they are mainly used for transfer of ownership and those are also kind of fan vehicle on the original object which might be actually emptied by the transfer of ownership the same things can happen with other types mainly pointers but also with types that have are actually class types like standard span like views like string view or iterator types which might be pointers or not or class types all these have kind of the ability to provide fan vacuum to other objects and the fan welcome only works if that was remote what's what's interferent in german what's free mode is actually there while you use it and this leads us to a lot of technicalities with relation types these are the types where things can really go boom or bang or dang as i said because they refer they are potentially dangling the original object can go out of scope or it can change invalidating what you're actually referring to and this might make your program get undefined behavior so actually whenever you use a relation type you have to put on your superhero cape and track the validity of the relation object and see that it's still valid the typical safe part is if you use these relation type as function parameters some people actually call them function parameter types especially those that come in a disguise as a class type like views or span we have the language relation types like reference and pointers and if you make a class type with the relation remember then that makes your class type also relation type is kind of contagious unless your class have does specific things about managing the relation so unless your class actually becomes a manager now let's look up for the specific c plus things that we can actually form manager types what's a manager whenever you create your own managing type make sure that you manage just a single resource if you need to manage multiple resources in a single type wrap each of them individually in a manager type and then just combine the manager types why getting things right especially when acquiring or releasing a resource can actually fail or can produce an error is really really tricky to get that right when you have more than one resource i personally tried that with a unique resource which i proposed for the standard library which made it in the the standard library fundamentals but never actually was adopted to the center library and because it wasn't adopted i show you how to create your own manager types especially an old a template for your own unique manager in this talk which allows you to create your own unique managers and it's not too complicated to actually follow that now what are the different situations you might want to use a scope manager example from the standard library is a scope block for example which is not copyable and it's just for local scopes where you acquire a lock and whenever you leave the scope the lock is immediately released but you might have other situation where you acquire resource that's not easily duplicable and that you don't need to share transfer the ownership you just keep that locally and pass it down with the relation type down the call hierarchy and then whenever you're done with your function where it's declared it's it's cleaned up afterwards then the second level are unique managers where you have a resource that's not duplicable but your way you want or need to transfer the ownership the classical canonical example from the standard library is the standard unique pointer and these are also not too hard to diy but the most hardest thing to diy is the general manager for the duplicable resources that still require a lot of managing and we cannot just exploit an existing library type that does the managing for you and this is where i can release guidance but i tell you how to detect those types and how let's say i give you a reference frame how to implement them now how do we detect a manager type or how do you create a managed type detecting is whenever a class defines a non-empty non-defaulted instructor this means that you actually manage something the structure has work to do and that works means you do some cleanup work there's a janitor at work that cleans up or a manager that cleans up whatever you perspective of manager you you have and that means you usually have a member that is a relation type and sometimes this relation type comes in the disguise for example if you manage a file handle that is typically represented as an integer and this is not a pointer not a reference type but it still has the relation semantics because it's only valid as long as the corresponding operating system file handle is active and valid and not close and this can happen remotely by some other piece of code closing the file handle and that means your file handle is actually dangling and so it has the properties of a relation type and what a manager has to do it has to care about copying and moving it doesn't have to support this operation but it must keep track if it's supported or not and one guidance okay because you distinguish managers from other types by having them a non-empty destructor never define a structure with an empty body you might think oh it's not a big deal because the compiler it would be exactly behave the same as the compiler would do it yes but that's code that you doesn't need to don't need to write so right did you wrote it so everybody reviewing your code has to think about oh was there something there that got deleted in maintenance or was it a placeholder and something wasn't then that is missing and why is there an empty destructor with an empty body don't do that and the new upcoming misra guidelines will actually have a rule that corresponds to that and there might be some exceptional cases where you not managing a resource but an invariant that is non-local but perceiving how you squeeze your eyes you're actually managing a resource and therefore i'm not going into detail more about those types i usually see them in code examples explaining all kinds of stuff about move and copy that can go wrong and you don't want to write code where move or copies goes wrong now technically look you look at the i already told you that if you have a scope manager that put things in a box and then cleans up it's non-copy non-movable technically in c plus for 17 on because of copyright even be able to return it from a function and copy a lesion takes place then there are the unique monitors where you have the transfer of ownership happening there's which means you have to care about what happens when the resource was transferred so the unique manager has to have the deliberate empty state when it's moved from and then there's a general manager where copyability is a key issue and you might actually only implement or you only need to implement move operations when the copying is quite expensive and you want you want to have move as an optimization which is the second usage of move operations now why do i want you to think about these class categories and types it's to have a mental model about the things that you create is makes it much easier to argue what you actually want to create and how to create on a technical and the once you consider you build things together from other parts you knowing what role the other parts play also helps you to get you the influence and also helps with code review or reading code if you see something a local variable of type string view for example that should trigger the trigger oh it's not a parameter type now we have something hanging around here is it valid so you have to trace the origin of the string view where it re the original object it refers to its subject it relates to and figure out if it's valid so that's kind of a thought model you should trigger immediately when you use things like that and defining classes correctly can actually be overwhelming there are books around with 200 plus pages just talking about move semantics and what you need to do about with the special member functions and how to use them properly and i think you shouldn't know all the details of these 200 plus pages to write a valid the useful class type and the thing is we'll see plus 11 we now have five special member functions we always need to consider according to some sources if we want to write a class correctly we have a destructor and we have a [music] let me see if i can check my so we have a destructor we have the copy constructor we have the copy assignment operator and i want to point out to you that i actually started to define my copy assignment operators for general managers where i have to define them with an ampersand to make them alveolarly qualified so they only apply to an l value on the left hand side which is how they should be defined but the language has the default wrong here in that case for legacy reason and then we have the move operations as well and again we see the move assignment operator actually employs the l value ref qualification to get there important thing if you define move operations make sure when you need to define them that you make them no except otherwise they wouldn't be used for optimization in case of a general manager oh they might you might actually lose your resource and use them in for transfer of ownership so the only useful move operations have are actually qualified qualified with no except in theory you have to think about the three things public protected private to understand if they are actually you could make each of those public protected private usually you will think make things public that i used and not on the protector private part but in theory we can define all of them in each of these categories and then each of the five special member functions can either be not declared at all declared as equal defined as equals default defined as equals delete or with a non-empty body and these are things to get your head around every little do a simple computation you get about 50 possible ways on how to define your classes most of them are ridiculously ridiculous but in theory a novice might not be able to actually figure out which other the good things and then you all have the different spellings that are still considered valid move or copy operations by the standard and this is not a place where you actually want to go and if you look at the table of howard hinnant which he presented at acu to accu 2014 you see the all the different rules the standard has if you define one of the special member functions what actually get what happens with the other special member functions if you don't say anything about them and it even shows the deprecated part where you get copy operations when you define one of the copy operations or destructor which is considered to be wrong by the standard but cannot be changed because it has been that way ever and this is actually the area where scott myers rule of three came from but knowing that table by heart and considering whenever you define a class is really overwhelming and that's not what you want to actually do now just consider it's not only which special member functions you define but also the influence of your sub-object either as base class or as a member variable that you have the good thing is whenever you have a value everything is just fine you can easily combine values all the defaults just work you don't have to talk about the special member function because the compiler provided ones are just okay if you have a relation type as a member of your class like a pointer or whatever then it becomes contagious so your class becomes a relation type like for example span employs a pointer to refer to the area that it relates to and that makes span a relation type because it doesn't have any additional managing capabilities on the other hand if you look at unique pointer unique pointer is a unique manager even though it contains a pointer type as a member it's not it's no longer a relation type because it's managed it is a unique manager type if you look at polymorphic base types if they are defined properly they shouldn't make any problems with slicing or heap allocation but again if you don't do it then well you can get all kind of problems now if we look at the scoped or unique managers each of those are contagious as well if you have a member or base class that's non-copyable your class becomes non-copyable which might be a desirable things otherwise you have to do things around like manage things again and this is where whenever you get up to the general manager which is copying and has value semantics again you're back to step one where the original values are just fine now let's get to the beef how you actually define those types now how do we define a class the best thing is don't declare special members and this is what the rule of zero is about and there's some exceptions where you must and i will tell you more about the exceptions because rule of zero is easy just don't write down declare any of the special member functions if you look at the core guidelines they have quite a weak motivation it says okay it's symbols and gives the cleanest semantics simplicity is very good as a motivating factor but this is where the core guidelines could actually be improved and why what i say with the rule of zero implement your cards in a way that the compiler provided default implementations just work and even if you say oh i know what the compiler would do and i just declare my special member function and define them with equals default and delete just like the compiler would do don't because you might lose triviality or the aggregate ability of your class and you might actually change the behavior in subtle ways even with equals default that are not obvious by that because you might change the overload set or have some other things that might happen there's two exceptions for equals default one is to resurrect the default constructor when you have to define another constructor and the other one is to actually define the virtual structure of a polymorphic base class where you have to define it otherwise it won't be virtual and that's one of the defaults c plus got wrong now when is the rule of zero not well suited whenever your class needs to define a destructor and this was most of the time the case in scott meyer's rule of three and it's in most cases still for the known rule of three and i skip over the some kind of exceptional cases that i usually only find in kind of ex explanation code that's not real word code or in buggy code that shouldn't be written at all now for the polymorphic base class we can refer to the core guidelines who told us okay make it public and virtual and you shouldn't you should prevent slices in that cases and so polymark base class should suppress copy and move operations and again there are some school of thoughts how to prevent copying there's there are the old options in c plus 103 or 98 where you have the private copy operations that's no longer necessary you inherit from non-copyability like boost uncopyable which is a bit less subtle telling you okay i don't intend you to copy that class and in c 11 people are proposing okay just delete the copy operations the problem is you delete the copy constructor and you have to delete that it doesn't go away automatically when you just delete the copy assignment that require requires you to resurrect the default constructor so you get rid of copy you have to actually define three special member functions which is kind of a lot and my opinion is it can be done simpler so less code to write more software you get how to do that simpler well we look very closely at the table and we if you spot if you follow how attendance talk it takes a long time to get the last line and the last line if you look at okay if we actually define a move assignment even if we define it as equals delete we will end up with a situation where we don't get a move constructor and where the copy operations are deleted automatically so they're not compiler provided so we get rid of the copy operations no move at all and the destructor is still there and especially the default constructor is still there because we didn't have to define a specific constructor and this is what i call the rule of this the mova and like destamona it's just if you define a structure for a polymorphic base class or for a scope manager delete the move assignment and you get rid of the copy ability which is a desirable feature in that situation now for a polymorphic base class in my opinion we go there we will have a virtual instructor because we have some other virtual member function and there's a single additional special member function we need to care about which is the move assignment operator that we just define as equals delete and it is a perfectly fine polymorphic base class that is not copyable and it just works and if you can find a simpler way of doing that correctly please tell me because i am happy to make this even simpler now managers these are the most specific c plus first thing that you can actually create them and there's a really good stuff to work about and they employ the ability that c plus plus has deterministic object lifetime and the destructors so we have the thing called resource acquisition is initialization or scope-based resource management and that's where the manager types are important most of the time you would just rely on the manager types provided to you by the sender library like the standard containers or standard string or if you want keep a location like unique manage a unique pointer but you want to if you really want to do it yourself you might end up writing your own managers and the principle is the constructor requires a resource the distractor releases the resource and you need to take care about copying and moving and this is actually the reference to the unique resource where i provide a generic solution for that which i believe is too error prone to actually standardize it's better to diy for your own kinds of resources and the senate doesn't provide one for you and again manage a single resource and we've seen that slide already so let's jump into the details how to actually create our manager types the simplest one is the scope manager and we will have a constructor that requires a resource this typically will come with parameters to actually identify the resource to be acquired and we will have a destructor that releases the resource and it will have a body doing the actual work and because it's non-copyable type we will use apply the rule of distance mover by deleting the move assignment operation and get rid of all support for copy and move operations and we will have some relation type that denotes the resource that is actually managed and this as far as go anything beyond that is very specific to the kind of resource that you actually manage and how you manage that and this is what you have to do as your homework to create a scope manager now a unique manager gets more involved because you need you wanted to support transfer of ownership that might that means that a unique manager either holds a resource or might be in a state where it doesn't hold a resource and the destructor might distinguish these two situation or needs to distinguish these situations so the cleanup must only occur when the the unique manager doesn't does hold an actual resource otherwise you might actually release a resource twice and in case of memory this undefined behavior in case of other resources it might get you in the situation where you either dangle have a dangling use as a resource or a double free or double release of a resource that is undesirable now how do we get there because the unique manager has to have a that extra piece of state for pointers it's easier unique pointer just use the null pointer to denote the release state but for other resource types you might not have the extra valid value in the type to denote the released resource that's where i suggest okay start out with the standard optional of the resource type to denote okay when the option is empty then you don't hold the resource and then the destructor of the unique manager doesn't have to do anything about cleanup and it also allows us to give us a very let's say schematic implementation a sketch or a template for the move operations that you actually require to have you will also have a uni typically for a unique manager a default constructor that just can be defaulted because a default constructed optional will have an empty will be empty and that's the state that it corresponds to the moved from state of a unique manager now if we look at the we will have a constructor that actually acquires the resource to get there and we will have a destructor that does a cleanup and we will have to define the move operations move assignment and move construction and we you see we have from our five special member functions three of them we actually have to define by defining the move operations we don't get any copy operation support which is what we actually want to and this is kind of a new rule of three for move only types where you have defined the destructor and the move assignment and move construction now how do we implement these operations let's glimpse into that and first i'd like to point out this is my one line explanation how move actually works you have on the right hand side a box with a letter in it and the actual move assignment of move construction of left hand side transfers the letter to the left hand side and potentially makes the right hand side empty and if you have a transfer of ownership that actually happens the right hand side is empty but note a copy operation is always a valid move operation if the type supports copying so you actually might duplicate what's in the box and have it at both sides but that's only for general manager where this is supported for a unique manager you actually have to transfer the resource from one side to the other now how do we do that for a move constructor there's nothing on the left hand side so it's kind of nothing there we construct the optional by moving the others optional around but that doesn't necessarily empty the optional if the held resource type is just copying the and the other option is not empty we will get a copy of the resource handle like a pointer or the integer for a file handle so we actually have to make sure that the other object doesn't clean up in its destructor so we actually re reset the option on the right hand side to make sure that it's it will not clean up the resource and that the current constructed object holds onto the resource afterwards a similar thing has to happen on the assignment operator the problem is with the assignment we don't want to lose the resource when we clean up the left-hand side and transferring it to the right-hand side there are some people who say oh we should just don't care i think it's better to have a deliberate move from state when you define a move only type and the deliberate move from state should be empty and therefore we do this check about are we doing a self assignment if not we actually release the the current left hand side and then swap left and right hand side so the right hand side is empty afterwards and if you look at the release operation the release operation actually checks if the optional is empty if not it uses it has you have to write your own code here to really release a resource which is resource specific so i cannot give you a template for that but then afterwards you actually reset the optional and then you will end up and clear the option so the this object is actually empty and this is also what you will actually call from the destructor and that is how you implement your unique manager and the only line that is very specific is how to actually release the resource here and how to actually implement the constructor acquiring the resource like you had with the scope manager now what else for a general manager things get more complicated and more tricky because duplicating the resources depends heavily on the resource what that actually semantically means if it's supported for many memory resources like that vector is the string manage duplication means you duplicate the contents of the memory and the memory region and this is just what happens in in there and if you have a resource where that duplication is expensive it might actually might make sense to additionally support specific move operations to optimize them but that's not a prerequisite to become a to get value semantics and it's only necessary to think about those if the copying happens frequently and is actually expensive and again for a general manager especially if you provide move only operations it might make sense to have a default constructor to create a kind of an empty thing that is corresponds to the move from state but a little bit like the move operation is not actually required to get there and if you look at that we get here if you just support the destructor and the copper operations we end up with scott meyer's rule of three the classic one or some people would say oh it's a rule of five or six because i have to talk about and implement all of these special member functions that we have to care about so we provide value semantics for a resource that doesn't give us value semantics and it only makes sense when the resource is duplicable and it usually requires expert level coding and whenever you can get around without implementing your own general managers go there and reuse the existing ones in the standard library and again the resource must be actually copied or replicable to get reasonable value semantics now getting to our takeaway what actually will we get there from my talk about the role models of our c plus object whenever you create types that are not just value types that just don't work out of the box use them with consideration deviate from value semantics only when needed sometimes it's required for polymorphic basis there are talks about how to get the polymorphic behavior without relying on relation types directly in user code and provide still having value semantics most prominent by sean parent i had some feeble attempts on that as value so you might find talks on youtube by me on how to implement polymorphism without just using virtual in your code bases directly there are other situations scoped and unique managers where it's viable to deviate from value semantics either because copying the stuff is too very expensive and you want to prevent that or because you don't need the copper the value semantics at all because things will live somewhere and the lifetime of the scope where they live is just sufficient to support everything whenever you have relation objects in your code base either in this as a reference or pointer types or in disguise as class types handle them with care put on your let's say goggles that figure out lifetime and figure out if the lifetime is managed well they usually very safe to use as function parameter types and very error prone if you use them somewhere else especially as return types and this is something to watch out for especially if you go into a code base where you see pointers throughout especially as members watch out that you don't have just a non-managing type that is tricky to use and what when we take about special members it doesn't have to be an art and doesn't require hundreds of pages to get your head around just remember the rule of zero rules and it's often good enough and sometimes even the most optimal way of dealing with code and remember premature optimization is the root of all evil and i think some people claim oh no you should take care but don't optimize what you cannot measure and what you haven't measured before and again take away take it home never define a destructor with an empty body if you have code bases doing so just delete them and get rid of that the crafty code and equals default the virtual structure in the base class and then apply the rule of zero in the derived classes if you prevented copy operation in the base class if you want to make your derived classes manager types and use them individually somewhere that's in principle okay just make sure then that you are able to define those operations correctly which might mean that you not apply the rule of this to mova in those cases but this is really very specific and it's rare to have to do so and there might be other means to get there and again remember the three kinds of managers scope-based resource management key to c plus for success especially in contrast to to c and think about the rule of destiny mover for scope managers the rule of three for move only types which are unique managers and the classical rule of the three or the rule of five or six for the general managers if you really need to go there and better get help it's like you're really going to the rocket science part of c plus just to get that right especially if you want to write them generically and there might be people around at conferences that know how to do that but it's not the common of the shell c plasma programmer who knows how to do that safely and what was missing from this talk of running into the end well i didn't tell you a lot about how to cope with the relation object that's part of an extended talk or different talk and that's where you have to put on your protective gear and your scrutiny and analysis and your fire extingui extinguisher or smoke detectors to get rid of potential dangs and make sure that they don't go bang and that's possible the other thing is i didn't tell you how to encapsulate virtual like getting value semantics by using sudvarian for example or encapsulate them with the envelope letter pattern like a shown parent we can show you in in one of his talks and i think i'm done right now and i hope actually somebody listened to that and watched the video or online and again you can access the slides and i'm happy to get contacted with questions or critique on that because i want to learn and not only teach so kind of improve my learning and so far i haven't seen any questions in the chat but it might be that everything is so clear or that nobody actually listened and i hope somebody will actually listen to that and learn something from that well thank you peter that was a nice talk i listened and i know that the others have listened so if you like want to speak with peter about this you can see him in the launch and i'm going to take us now offline as you know yes one one quick question which room in the lounge should i actually head to because i'm kind of extra now yes the big table okay i'm i'm i'm i'll be showing up at the big table in in in in a minute or two when i switched back to who below my system okay you also need some time so you can you can meet peter and the big table in the launch and until then i wish you a happy conference