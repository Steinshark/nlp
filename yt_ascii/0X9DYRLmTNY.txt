so you remember in the past we did, we done two really big numbers in particular in the past. we did graham's number and tree(3) right? so if you remember tree(3) was this number that was that was so big that, you know even just to prove that it was finite, there just wasn't enough time left in the universe to do that. you would have a - the universe would reset itself before you ever got to complete the proof. it's - it's just stupid. it's just - you can't even picture it. and graham's number was so big that if you thought about it your head would collapse to form a black hole. so these were two really crazy numbers but what i really want to talk about today is kind of sort of crazy of crazy. i want to talk about a number which combines both and that's tree of graham's number. (brady: i'm worried the universe is going to collapse on us) well, you know, we need to worry about that. as you might remember from, from those original videos, both tree(3) and graham's number they, they both arise in sort of a sequence. particularly let's remind ourselves what - where graham's number came from sort of very briefly. to get to graham's number we started out with something, which i'll call g(1), which was three arrow arrow arrow arrow three, right? now this was a really big number, now just to remind you what these arrows were; if i have three arrow three that just means 3 to the 3. it's a fancy way of writing 3 to the power 3, which is of course 27. if i take a double arrow well that just means doing a repetition of the single arrow, in this case three times, so that would be three arrow 3 arrow 3, which is 3 to the arrow 27, which is about 7.6 trillion, i think it is. okay? and then if you had three arrows, well that's just repeated double arrows, okay, so that's just repeat repetition of the double arrow. so that's 3 to the 3 to the 3 which is again 3 double arrow - 7.6 trillion, which is basically a power tower of threes. so 3 to the 3 to the 3 to the 3 and so on, that it's 7.6 trillion high. this is just stupidly big numbers. and actually the first sort of rung on the ladder of graham's - graham's ladder, the graham's sequence is actually - it has four arrows. so it's just repetition of three arrows. so this is the first point on graham's sequence, but then you go up right? it's graham - what graham told us to do was actually to sort of build this sequence up, you would then go to g(2) where the number of arrows itself was already this huge number. okay, so you actually now have g(1) arrows, and the arrows as you can see from this, make numbers really really big. so actually now when we start putting really big numbers in the number of arrows, we get crazy big. and he carried on with this sequence until he got to g(64), which was this graham's number. so you have this sequence, 1 - you start off with this, g(1), g(2); until - all the way up to g(64). and you can carry on right? this defines a sequence which you could call g(n), which is basically related to the one before by taking the number of arrows that you had before. so you relate it like that. so this defines the sequence. the tree - trees also gave us a sequence. now if you remember from that video the trees are basically this idea of you play a game with a, with a finite number of seeds, different types of seeds, and you try to grow trees. and the idea is how long can this game go on for? so if you have one type of seed then the game can last a maximum of basically one go. so tree(1) is 1. tree(2), so if you have two different seeds, is three. and then if you have three different seeds then the game literally goes on for - can potentially go on for absolutely ages. this number is massive, okay? it's a really really big number. like, it's actually bigger than graham's number, that's what i told you, okay, so we're going to think a bit more about that. but this is a truly truly gargantuan number and but of course you could carry on with this sequence. you could try tree(4), tree(5), tree(6) - in general some tree n. and you could even think of course about tree of graham's number. so that's what we want to think about. now, so we have two sequences here, right? and the real question i want to ask is is which sequence is better? so let's ask this question, let me, let me write down. [hold music] so we've got these two sequences. we've got tree of n and we've got g of n. so we got the trees and the gs, okay? and we can build this number tree of graham's number, right, which is basically tree of g of 64. but i could also think about going the other way round. what do i mean by that? i mean, do the trees first and then do the gs. so in other words, i'm gonna start playing the game of trees first and then i climb graham's ladder. so what do i mean by that? i mean take tree, in this case of 64, and then evaluate that in graham's sequence. so i'm doing it the other way around. so here i'm climbing graham's ladder first - 64 rungs, and then i'm playing the game of trees. here i'm playing the game of trees with 64 sort of seeds, and then i'm climbing graham's ladder. so which of these numbers is bigger? okay, which is bigger? 
- (brady: oh i, can i have a guess? i got the impression from you in previous videos that) (trees are more powerful) (so i'm gonna say) (that one's bigger.)
- but that's got tree in it as well (brady: yeah, but it's - you're giving the tree less juice there) (you're only giving the tree 64 juice, and there you're giving the tree graham's number juice) i think that's a beautiful way to put it actually brady, and you are right. okay, but let's let's actually explore this a little bit more. let's do it with a much simpler, a simpler pair of sequences, which are basically just powers - so i can imagine a sequence where p to the n is 2 to the n so i basically take, take the 2 to the power of whatever number i'm interested in, and quadratics, okay, so i basically take - if you give me n, i give you n squared. so there's two different sequences. the - neither of these are anywhere near as powerful as tree or g, but they'll illustrate the point. now, as you would put it, in this case the exponent, you know, this one - has more juice, okay? this is more powerful than a quadratic. exponents grow more quickly than quadratics. in this case we can study and ask which is it better to do first or last? okay, which is gonna take us to the bigger place? let's look at this and let's let's start with maybe n equals 1. okay, so if we do q first, we take the quadratic of 1, okay, that gives me 1 and then i have to do p, which is gonna take me to 2. okay, so i'll get 2. if i do the other way round, so i'm going to start with 1, i then need to take its power, that's going to give me 2, and then i need to take the quadratic so that's going to give me 4. okay, so you can see if i do for n equals 1, actually doing this guy last actually seems to win. okay, that's, hmm, doesn't feel quite right. let's try a bigger number. let's do n equals 3. so if i take the quadratic first, that takes 3 to 9. and then i take the power, okay, that takes that gets me to 2 to the 9 which i *think* is 512, quite a big number. now let's do the other way around. okay, so we start off with 3, we take the power, so that's 2 to the 3, which is 8. and then we take the quadratic, 64. so you can see here the minute we went to a slightly bigger number, actually it was indeed advantageous to do the big guy last. okay, and actually as long as you take n bigger than 2, it's always going to be better to do the big guy last. so it is, it is true. you're right brady, the big guy, the most powerful guy, is the one that you should do last if you want to get some really really big numbers. so now let's go back to tree and g. now you - your intuition says that tree is bigger. its correct. but what's the mathematical way of sort of, of measuring that? is there a mathematical measure for that sort of thing, for how fast a sequence grows? okay? does - is there a measure of how fast tree n grows? is there a measure for how fast g n grows? or any other sequence? ok, and there is. and for these growing sequences, the thing that we use is something called the fast growing hierarchies. so we're going to start off with a very - with a, sort of function that does grow but it doesn't grow very quickly. okay, so really, really starting off with basics. and that's the successor function. so this is a very simple guy. it's basically just says take n and go to the next one along 
- (brady: counting?) it's counting, basically. it's the first thing you learn at school, right? so 2 goes to 3, 3 goes to 4, and so on right? so it's growing from - it's a growing sequence. it just doesn't grow very quickly. ok, but this is, this successor function is the basic, is the basis for all the - it's the seed for all these fast-growing hierarchies. ok, so i want something that grows. obviously, this doesn't grow as fast as tree or g. i think we can agree that, right? ok, so let's try and get something that grows a bit faster, but this is the seed for everything else. so what can grow a bit faster? well you define f of 1, okay, which is defined as doing this guy n times. okay, so i'm going to do f lots of times, in fact, i'm gonna do it n times on n. okay, so what is this? so another way of writing that is just f 0 to the n over n. so what am i really doing here? i'm doing - i'm adding 1 to n, n times. where's that gonna take me? that's gonna take me to 2n. 2 times n. yeah, i'm adding n to - n to - i'm adding 1 to n, n times that's gonna take me to 2n. okay, so you can see this has already grown more quickly. this one was just adding 1 each time, this one is now doubling. it's not a much faster growing function, but it is a faster growing function than the successor guy. okay? and we've done it back, we've built it from that successor seed. okay, so let's carry on let's try f(2) we're gonna define it the same way. we're basically gonna say do f(1) n times on n. okay, so what's this going to give me? well, this is basically saying multiply by 2, n times. so that's going to give me 2 to the n, times n. so now we've gone to an exponent, okay, so we've gone from successes, to multiplication - just like by doing repeating, repeated succession to exponentiation, by doing repeated multiplication. i can carry on, okay, what's the next guy? well that basically says do this an n number of times. so, what's that gonna give me? well, i don't want to write it down. this is going to be something that's more like the double arrow. this is actually going to grow more quickly than that guy. just slightly, but it's the same - similar sort of sort of growth rate, but it's slightly more quickly than that. okay, so this is what we called tetration. so you've got successor, multiplication, exponentiation. this is now tetration. and i could carry this on. okay, i could just carry on defining it in the same way by repetition of the one before. next one would be pentation, hexation, and so on - and so on and so forth. okay? and i could do loads of these right, and i go up the whole time - one for every integer right. all the way up. okay, great. now, this gives me a hierarchy for - this gives me a measure for how fast functions grow. i can measure them against these guys.
- (brady: so you could have f(100)?) f of 100, f of a googol, f of - f of graham's number, even, right? okay, and my question is is do these numbers grow faster or, or - which - where does where does the g sequence and the tree sequence appear in this in this hierarchy? is it, is it faster than some of them and not others, you know? okay, what do you think? (brady: oh no, you've got a cheeky smile. so i think you're about to pull something on here. i don't know,) (i mean presumably because this f thing is  infinite, could - it just keeps growing? it) (must get to a point at some point where i can use it to - ) so that's a good point. so it's certainly true that for a given value of n, so if i put say some large value of n in here, i could get a number that was bigger than graham's number. but that's not what i'm asking. i'm asking do these sequences, do any of them grow more quickly than graham's sequence or the tree sequence? so for the same value of n, are they gonna give me bigger numbers? (brady: i feel like you must be able to get there because) (because the way tree works and the way graham works is like set in stone.) (whereas this thing, you can just keep making bigger and bigger until you - until it's fit for purpose.)
- the answer's no. none of these, even if i carried on all the way through all the integers, so all the natural numbers. there's never going to be a sequence that's as fast as either g, the g sequence, or the tree sequence. they're both faster. so they're both, the tree and the g, they grow quicker than any of these. any of these and that's like, woah, that's - what am i gonna do now? okay, so how can i measure them? well, the problem is, is that you're just dealing with finite, okay. look at what we have here. what have we built up here? so i kind of need, i think i need more - so you can see with that, with that sequence of functions, i'd have 0, f(1), f(2). right, they all had an index 0, next one was 1, next one was 2 and 3 and so on right. and in principle i could have had any, any natural number ok. arbitrarily large. but i was restricted to the natural numbers, okay, i can go one beyond. i can go to infinity. what comes after these numbers? well, there's also something important to distinguish about these numbers is that they had an order. okay, there was - they were, you know i have a notion of hierarchy. f(0) doesn't grow as fast as f(1), doesn't grow as fast as f(2) and so on. the indices were important that they had - they came in order. so you can really think of these numbers, these indices as more like ordinals rather than cardinal numbers. cardinal numbers tell you how much, ordinal numbers add a bit of order to that. they add, you know there's first, second, third, and so on. once you've you know, you've gone all the way through the natural numbers where's d'you go next? well infinity, right? so i can talk about infinity, which i just - i write as the ordinal infinity, i write as an omega. and that's basically the final - it's the thing that comes after all the others. all these, all these finite ordinals. the thing that comes after, is ordinal infinity. so that gives me a way to climb a bit higher. so i'm going to define a new type of function. okay, that's labeled by this guy. now, how am i going to do that? so i'm just going to draw some of the fs that we've already already created. okay, so let me just draw a few of them. so f_1 of 1, ok f_1 of 2, f_2 of 1, f_2... ok, so here are some of the, some of the fs that we've - we could carry on right, in all directions.
- (brady: where you've put an) (integer in the, in the place of the n?)
yeah exactly. i'm actually going to look at their values now. ok, so, you know if i go along this way, i'm sort of changing the argument, i'm increasing the argument. if i go this way i'm increasing the index. okay, so let's just plug in some values for what these guys are. this is 2, 4 this is 6, so indeed i grow as i grow that way.
- (brady: that was our, that was that doubling) so this guy is 2, this guy is 8, this guy is 24. this guy is 2, this guy is 2048 - bigger number. this next guy i'm not gonna write it out because it has 121 million digits. this guy is huge.
- (brady: that escalated quickly) that did, that did escalate quickly as umm, what's his name ron whatsit, can't remember his name now okay
- (brady: ron burgundy!)
- ron burgundy, yeah, yeah, yeah so this is gone out of control quite quickly. 
- (brady: amazing thing is, you're only at f_3 here) yeah i know.
- (brady: that escalated really quickly, f can go like) (to the millions and you still say we're nowhere near the power we need to deal with graham's number and - )
- very very true, right, but let's, but what i want to do is i want to create create an f, so like - which i'm going to label with omega, that grows more quickly than anything that's gone before. so, how do i do that? okay. well, what's the quickest way i can grow in this picture? if i start out over here, what's the quickest way to grow? straight along the diagonal, yeah, right you go straight along. if you go this way, you get, well look in two steps, you're suddenly at 121 million digits. if i went to the next step, and i went to f_4 of 4, then i think this guy's somewhere between 10, three arrows, 4 and 10, three arrows, 5. it's in that interval. okay. so going along the diagonal gets you really big, really quickly. in fact, it's much more fast growing than anything that went before. okay, so that's what we're going to call f_omega. something - the base of the guy that picks out the growth along the diagonal. so we can define that. so we just write that as f of omega over n. we're going to define as f of n of n. that's basically saying pick out the diagonal. so this would be the first position, second, third - already 121 million digits - fourth - already this stupidness. all the way down there we're just gonna get crazy. we're gonna get a really, really, fast growing function. okay, now what kind of function is, is this gonna look like? well, actually you can show that this is kind of, generally going to be greater than something that goes like this, where you've got n minus 1 arrows. so this is like kind of building up the arrows. which might sound like something that we've done before, which is how we built graham's number, it built up the arrows and you know, the index kind of went on the arrow. which made you get really, really big. that's why these other functions; these, these guys were never able to do as well as graham. okay, because they weren't really hitting the index on the arrow. okay, the arrow - putting it on the arrow makes it grow much more quickly. so this guy's doing it- it's doing much better. okay, we can talk about our next ordinal, the one after omega. okay, the one after infinity, that's kind of weird. i'm just going to call it omega plus 1. right, now you may say what, what on earth is that? that's clearly nonsense, right? you're talking about infinity plus 1. well, isn't infinity plus 1 just infinity? that's not really true when you're talking about ordinals, depending on how you define it. what i really mean by this, i mean the thing that comes after what went before. what comes after omega, okay, so by definition it's not the same thing. okay, you can't really do that with the cardinals, but you can with ordinals because the order matters. okay, so i can, quite reliably, talk about something that is - that just comes after this ordinal infinity. it's the next one along. how do i get that eh? well, i already know how to add 1 to my sequence of fast-growing functions. i just do it the usual way right? i do f of omega plus 1 is just an application of this guy n times. okay, so it's f of omega n, n. now this is starting to terrify me now because look how fast this guy grew. this was, this was, this was growing with, with putting basically index, indices going on the arrows. this guy's just got off on one now. this is even faster than that. this is, this is mad. i don't even want to yeah, i think you can relate this to these conway chains. but i don't even want to go there about how big this is growing. but i don't need to stop! okay, i could carry on. all right, i could carry on. i could just go, okay omega plus 2, and so on. right, i can keep going, i could keep defining these functions this way, right. eventually i would run out of things to add. well, what do i do then? well, i just add omega. okay, so we're define an omega, this - the limit of this i would then add something on top of that which was this, which i call omega 2. it's a kind of next level of ordinals. okay, but i don't need to stop then. i can carry on. i can do omega 2 plus 1. and all the while i'm defining new functions this way. okay omega - what - omega 2 plus 2. keep going until eventually i run out of the finite numbers to add, and then i just say well the next one is gonna be omega 2 plus omega, which i'm gonna call omega times 3. okay, but now look what i've got. so all the while i've functions that're coming along for the ride, they're just going mad, right? now, so what's next? okay, so so what about i've built now, i've managed to get well, there's like an omega times 1 which is just omega. i've also got omega times 2 and omega times 3. ok, so i can start building this sequence up as well. okay, just by doing these, these repeated additions. okay. well eventually i'm gonna run out. what do i do then? well, i say the next one along is omega times omega, which is omega squared. okay, so i can talk about a function which is growing like f of omega squared, which is - ahh - i don't even know what it is. right? it's mad. it's just gonna be something crazy. i can carry on building these omegas. omega to the omega, omega to the omega to the omega, omega to the omega to the omega to the omega.... until i run out. well, what do i do then? okay well, then there's another ordinal which you call epsilon-naught which is kind of like an ordinal infinity that's just - wow! it's just way out there. way bigger than this guy, way bigger than any of these. and there's a, there's a, there's a growing function which is labelled by that as well. it doesn't even bear thinking about how fast that grows. okay, you can carry on, there's a whole system of this, you can play with this play with this sort of technology all the way. you have epsilon, you can define epsilon-naught,  you can build up more and more; epsilon_1. you can even start talking about epsilon with an index which is epsilon- naught itself. and then you can have another index which is epsilon, epsilon-naught and you can grow, grow, grow, grow, grow. your next thing is called, well the next one is called, sorry, a zeta number. and then there's an eta number, and then eventually you just keep going and use these - these things called veblen hierarchies, and all this. and then eventually you get to a point where you've got something which is just off the scale, massive ordinal. which is called gamma 0. it's called the feferman-schutte ordinal. it's the largest thing that you can create using these kind of recursion methods, and this thing called veblen hierarchy, which we ,go i'm going to - and the point is, is fs that can come along for the ride. does it even bear thinking about what f of gamma 0 grows like ok? this is a crazily fast growing function right? i mean just, it was so far away we didn't even - we didn't even bother to describe it, right? okay, so that's the million dollar question. or the tree three dollar question, right? okay, where does where does the g sequence, the graham sequence, and the tree sequence lie in all of this? (brady: so what what f, what function do we build that's gonna keep pace with tree and - ) exactly, which which of these fs can keep pace with either g or tree? okay, let me tell you. let's do a g first. g we can handle, okay, g doesn't grow as fast as f omega plus 1. it doesn't grow as fast as that. you can kind of see why right? already at f of omega we're starting to see the sort of index appearing on the arrows, which is kind of like how graham's number is built, okay, so graham's sequence, umm, grows - doesn't grow any faster than this guy. okay, what about tree? tree grows faster than this. it grows faster, it even grows faster than this guy. tree grows faster than this. so none of these guys can handle tree. the tree sequence grows faster than all of them. now, you can go beyond gamma 0, if you want to. it all gets really quite messy. so we're not going to go there. safe to say that tree is off the scale fast growing. even faster than this guy. whereas we could handle g. so the answer to the original question was that yes indeed tree does have a lot more juice than g. so tree of graham's number is bigger than graham of tree. essentially. if you'd like some more from this interview, or maybe you'd like to watch some more videos about really big numbers, or you'd like to learn more about trees, check out the links on the screen and down in the video description. there's some stuff there we'd love you to see