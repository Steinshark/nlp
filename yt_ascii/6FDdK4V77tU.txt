okay hello good day and welcome to my my presentation who am i i'm a simplest plus programmer i started my career with networking protocols and then i did quite a lot client server programming at some point i started to use qt and that leads quite naturally to user interfaces so my platforms are linux windows and recently embedded i'm a freelancer you can hire me and i'm somehow concerned about performance in this talk we will start out with a short intro into the field of memory allocators then we will introduce sdl allocators and show how pmr's polymorphic memory resources improve up upon them and that will allow us to understand the two advanced techniques we will discuss in the following we will and close up with some general remarks so memory and performance how do they impact each other we know allocating memories costly and accessing memory is slow cash cashes are important memory locality is important we want to keep the talk on the intermediate level so i won't explain all that and i will just assume you know why this situation is like that with our modern hardware as programmers we can shield ourselves from that complexity by using system memory allocators which are provided by by the runtime of c plus but there is also a long-standing tradition of writing custom memory allocators why is it that is why is it so first of all we can gain performance from by by increasing locality of memory accesses and we can also lower costs of allocations for example when we avoid locks if we don't need to lock the allocator second second reason is that we will be able to place our object in a special origins of memory like shared memory file map memory high bandwidth memory even on program stack we can use it also for security to just to prevent some prevent memory related exploits like chrome is doing or for debugging just printing some debugging for so what did i know about allocators before i started to investigating this topic my first encounter with that was when i've seen a sized block allocator used for for allocating network networking packets simple c plus plus new operator overloading in a class was all that was needed for that and i heard about arenas which i assumed would be just a buffer when where objects will be allocated objects will be placed my second encounter was when i read about an xml parser that implement implementation that we're using lists as internal data we know lists aren't terribly good performance wise because of the inherent non-locality so the the author of of of the parser just used a simple memory buffer backed allocator that just pumped up a pointer when allocating a new new object so with this allocator replacement list performance problems were solved and that just impressed me very much because you know there is this data structure which is inherently bad for performance and nonetheless we can use it and make it make it work next i learned that in game programming that they are using a plethora of allocators because they are constantly creating objects at runtime like meshes sprites texture textures and so on the classic book here the game engine architecture mentions five types of allocators stacked allocators pool allocators aligned allocators single frame allocators so and an example game jack dexter keeps all the time three memory allocators and two of them are have loaded all the data which are needed for the current game level and from the next game level so that we can seamlessly change from one game level to to another so what is the situations in c plus plus we have sdl allocators in in a standard template library an allocator is a template parameter for a for a container originally it they were the allocators were meant to encapsulate different pointer sizes on on some ancient pcs by okay that's that's all in the past apparently they evolved to be just general memory allocation service for containers and they constitute one of building blocks of standard template library however the allocators as they were designed or defined at that time were rather problematic to use the original design was technically lacking in several aspects because of time pressure they didn't want to to compromise the deadline okay we've all all been there so no hard feelings uh in that respect second problem was they were hard to use because as allocator is a part of of the container type a vector of integers using two vectors of integers using different allocators are r doesn't don't have the same type and can't be used with a general function like like a function we've divided here taking just a vector so no there is no no surprise that the allocators as defined then were a little loved and literally used but fortunately there was that company called bloomberg and they have developed they own a locator library before sdl came up and after after that they tried to match both worlds and finally they joined also the committee to work on the allocators so it's their work basically the the idea was to wrap the base class for allocators in an stl conformant allocator wrapper and then always use the wrapper in the signa signatures on stl contain containers so all the containers will have the same signature the second idea was to add a locators parameter and constructor for classes so that it could be passed down the chain in in the container to the contained objects in c plus plus 11 we've got this design partly implemented so the technical issues were solved but allocators were still part of signature of containers again no time and this was respond to split plus 17 so in c 17 a new namespace was introduced pmr and all the almost all the classes bloomberg classes were ported to that to that namespace what is pmr what does it mean some people told me it stands for poor man's rust well maybe and other people tell me it's acronym for pulmonary polymorphic memory resource not much better but wait wait wait should it should it be polymorphic memory allocator and not resource what is that resource thing well the explanation is that the polymorphic allocator name was already taken and it is the name of the general wrapper which we plug in into the standard containers standard container template definition and it it holds a pointer to abstract base class of the real of the object doing real allocation work but they have had to call it something something else and well it was called memory resource and not memory based allocate something well it's it's somehow confusing but we have to get used to it and well let's let's have a look on allocators oh locators i'm still mixing up these two two names allocators and memory resources so what memory resources are provided to to us by standard template library basically you have two types of resource resources monotonic buffer resource and the pool resource where the pool resource can be synchronized and unsynchronized this means with internal locking and without monotonic buffer resource will use a backing buffer yeah yes but a memory buffer to place the allocated objects within and it will only release the allocated memory when the entire resource is destroyed so it's it's a kind of bump up pointer bump up allocator we we've seen before we discussed at the beginning beginning of the presentation so why why the name monotonic because in mathematics if a function is always growing it's called mono monotonic and this buff this memory resource is good for data structures that that are built up only once and then just used and discarded pool resource is somehow different and it is optimized for allocating blocks of given of single sizes and the pool allocator keeps a collection of pools which serve requests for different block sizes each this allocator is good for data structure structures with numerous in numerous insertions and deletions because of memory reuse that means if we are releasing memory for for some object it will be returned to the list of free memory in the pool and then released later and and as we will see later because of it provides quite good memory locality so show me the code here it is here we first defined a buffer which will be used to allocate objects inside of it and then we passed this buffer to a monotonic buffer resource this is this is that pointer bomb bumping up pointer bump up allocator so to say and this monitoring buffer resource can be passed to our containers to the standard containers in constructor and one thing to note here is that we are not used just using vector standard vector but instead standard pmr vector which has built-in support for forwarding of the of the memory resource and its allocator down to the contained objects we can reuse this memory resource by calling its release method it will rewind all the resource to the beginning and and we can start allocating with with a fresh slate pool resource looks somehow different it has several pools of which which cater for different location sizes and each pool manages a collection of chunks that are divided into blocks of this uniform size if a chunk will get exhaust exhausted this chunk will be fetched from the upstream allocator so what is an upstream allocator and or an upstream better and upstream resource well it is kind of is this it is a fallback resource if if memory source exhausts this exhausts sorry it's the memory it owns it can get additional memory from that upstream allocator the default ups allocator when we don't set another special one is our good and trusty new delete resource with that we'll just call new or delete operators global new or delete operators we can also also set the default resource for our default memory resource for our program and why should we do it well basically for testing and debugging we can set a default memory resource for use in a use case you in a unit test and get our debug information so that closes the short introduction of pmrs are there any questions at the up at this point no okay so yes there's only one question not really regarding this but on slide 10 what are the lacking features in the stl allocator lacking features oh it's a very very big topic so i didn't include it here okay so standard allocator instances were defined stateless so they're always compare equal so we as originally defined we we can couldn't program as stateful allocator then pointer types were just short circuited to t to the type to the pointer to the type so no fancy pointers no no no special pointers were allowed and then the problems there were problem all the problems with forwarding the allocators of the containers to the elements it contained it wasn't well defined so this is the part of the standard that messes with this all up and yeah this is a little more explanation but i just wanted to skip it it is a very big topic sorry okay do you have time for another question here's one question pmr a vector api is it compatible to std vector vector pmr let me see okay i will i have to skip to my sorted out yeah it's materials to find it [music] where is it oh i can't find it no yes yeah pmr vector just uses this as the pml polymorphic allocator as as part of its type signature so we don't have to to do it for ourselves and it it also provides some support for allocator when our classes we will discuss this later but the the basic basic features that we it's it's simple typedef where we just fix this allocator to the to to the base of allocators of of the polymorphic allocators yeah so i think we have the chance for more questions on the eq it's it's a big topic so one could make a talk entirely from from these definitions of of allocators and the validators apis and so i wanted to skip it okay so yeah go on with it because we want to have a look of some of the more advanced techniques well okay the first technique is called wing wingout so the monotonic buffer resource has a method called the allocate to which freeze the memory and it's a no operation it is doing nothing interesting well it has as as it follows that the destructor for the element is not called yeah yeah time savings time savings we are increasing our performance but we have another problem when we have a container which contains elements allocated from this monotonic copper resource containers the truck destructor will be still cold and container destructor will call the destructors of the elements so we've gained nothing but there's a trick we just will just use monotonic buffer allocator for the for the container also and at we in this way we involve the destruct destructor of the container and the container never the structure of the container will never invoke the structures of the contained objects so it all just disappears without cost and the allocator just pumps down pointer to the big beginning of the buffer so it's like magic of course caution it's it's not without reason that it's somehow advanced technique technique because no side effects are allowed in the structures because these actors won't be called and if if we are freeing some other resources other than resources other than memory well then we have a resource league another problem with it with that is that we have to take care that that the the container doesn't contain any objects with that were allocated using a different monotonic buffer resource object so that we have always to be very cautious with this technique so probably you probably didn't understa understand anything anything so let us have a look at the code example so we define for example an unsynchronized pool resource because the destructor of pool resource also does nothing and then we defined a polymorphic allocator using pool resource okay and then we will we just construct a vector of list of strings using our pull allocator so can you see it's just a pointer we don't hold to the pointer and is it a memory leak maybe maybe it could be okay and then we use the data push something and push something and push something again and then we are out of the scope so each normally this should be a memory leak because this pointer won't get won't get freed we don't call a delete for that we don't call delete objects on the pool resource it just goes out of scope but as it goes goes out of scope this unsynchronized resource will call its release method in the destructor and everything just wings out without any destructors and the location is almost free so there's a quote it's it's just a very cool technique when i was writing the example code i encountered a couple of problems first i tried to leave as as i was to do it in in the old bloomberg style just to forward the pool resource or poo allocator to the new constructor because bloomberg conveniently over has overridden the global new new operator to use the the allocators well this didn't work because it just crashed because in c 17 there is no such overload unfortunately so i have to look in the standard to to figure out how how to create a new object using a given allocator instance polymorphic allocator instance in c plus 20 there is this very convenient method known as new object where we just have to template it on templatize it on the container type we want to create and everything and it is it is done in one line of code in c 17 it's more complicated because well it's a two two steps process first we have to allocate memory for to contain the new object to be created and then we have to construct this object in this memory so well it's okay not very good support for the programmer it's very low level and also i have a big problems big problem which i initially didn't understand with with this pool resource forwarding should i forward this pool resource to the constructor of vector of list of strings so that it will use it for its internals well i just always got pages pages of some template errors which i didn't unders understand and i had to look at the implementation at the code and well the reason was that at this point the we don't need we can't use the resource because polymorphic allocator construct shouldn't pass resources down the chain well okay so with this the problem was fixed but i didn't understand it we will come to that later so but first let us think about uneven behavior well this all is much too good to be true isn't it you just don't run any constructors you just ignore objects which are well were constructed and is it allowed is it is it kosher or is it undefined behavior for that we have we have to consult the ultimate oracle the c plus standard and in the section basic dot live 0.5 it says that the program might end the lifetime of any object by just reusing the storage and the second possibility by calling a destructor and moreover program is not required to call the destructor explicitly this tells us that wink out is basically safe up to a point because any program that that depends on the site ef effect effects produced by the destructor has an undefined behavior so this is there is that gotcha again we don't we can't have any any side effects other than freeing memory in in such emitted destruction oh okay now i provided to you some an excerpt from real codebase it's c plus plus active framework cif and here we have part of implementation of json data representations json's representation data structure so now that we learned about wink in and monotonic and offer and resources we can understand what the code what the this command says and it says this national abstraction is designed to allocate its entire states in a monotonic buffer resource okay it's clear now isn't it and this minimizes memory allocations because we have just a a simple bump up the pointer bump up for allocations and also enable us to wink out the entire json object we know now what wink out is we yes i think so entire adjacent object by simply reclaiming the memory without having to call a single destructor and that is clear also the api is not optimized for convenience or safety the the key word here is safety because well there is undefined behavior lurking if we if we have some some side effects it's not safe since the only place we use this api is json but it's okay because they are using it internally okay another example this wink out trick is is used are protocol buffers google protocol buffers they are it's it's it's a framework for for serializing and deserializing data structures and for in c plus plus the backend we can enable and sorry an arena allocator which uses a large piece of pre-allocated memory called arena of course and we can win out the whole serialized serialized data structure when the arena gets destroyed or and or goes out of scope just like we were doing in our monotonic data resource example however strings string fields are not allocated located on the heap and they are allocated on the heap and not on the arena i don't know why i never found an explanation for that so there is one feature which still stl doesn't provide we can register this structure destructors to be run on on on destroying when when the arena gets destroyed for external objects if the depending on some internal arena objects but also for internal objects if should they have some side effects and and should they require these structures to be run and we can reset the arena to to the its its original state just as we did it with with monotonic buffer resource well the second advanced technique we want to discuss is called localize it localized garbage collection so we know that large graphs created with chat pointers have been known to overflow the stack on destruction that's because each node's destructor will recursively call the destructor for the next node in the graph and that will be can that can result in unbounded recast recursion and a crash and stack overflow even worse the problems even even even more tragic if there might may also be cycles in in graphs so what is our idea to solve this problem well we just use our our previous technique and wink out the entire graph at once not calling any destructors avoiding stuck overflows and deep recursions and well very elegant solution we don't have we don't need any any language extensions any any new [music] smart pointers and the code you can see the code here we have some some we have graph nodes we'd have outgoing edges and payload and first we allocate the buffer to be used for looking for for the monotonic buffer resource and then we give it to the allocator called buffalo in this example and then we allocate new graph nodes connect them and and just play with them okay and and on the amp at the end of the scope of course buffer allocator and the his memory resource will be reclaimed and none of the construct that structures will be called and everything will be winked out just like that problem solved we have to notice that we aren't used aren't using smart pointers fields we here we are using naked pointers okay and when creating objects for the localized garbage collection example i encountered the same problems as with this this first drink out example where where i allocated the vector of list of strings so naive mode crashes c plus plus 17 in sequester 17 we need is two stage allocation and construction and in c plus 20 we just use our new object method convenience method of of the allocator the difference here is that graphnode somehow [music] needed the memory resource to be passed in in this called new object and it is it is that is very different from the previous example well this wasn't allowed i i tried to to solve this this conundrum and the reason is that allocator that this graph node is isn't is not defined as an allocator aware class what is an allocator word class okay it's complicated but we can make a graph node allocator aware by typedeffingthis allocator type to to be a polymorphic allocator and then well look here the last line of example with that the allocator don't have to be passed down the buffer allocator will pass down himself to the graph node so so this is this was a localized collection and it essentially is a wink out with naked pointers but a very very elegant solution of a pesky problem and we have the same caveats as with wink out and another problem why aren't we using we are using naked pointers and and it's it shouldn't be [music] the case in modern c plus well can we use smart pointers after all well not really because they don't really mix well with with morphic memory resources one of the creators of of of designers of bmrs john lakers said that certain certain standard facilities like sharepoint that managed object lifetimes don't mix well with memory resources because they neither track nor extend allocator lifetimes they are just independent mechanisms and well there's this is a behavior at this point so like [music] but pr pmrs smart pointers support polymorphic memory resources well yes and no we can give and we can pass an allocator in in constructive shared pointers to just we and it will be used to allocate its shared memory pointer the shared pointer internals we can also create a complete shared pointer using pmr using which will use memory resource with this new allocate shared factory method and in this case sharedpointer will use our allocator for its internals for its managed object objects and will it will also pass the allocator down to to sub-objects of of its managed object well however sharepoint itself is not a locator aware it doesn't have copy move extra copy move cons extended copy move constructors like like normal look at our classes have no has it get allocated method and this what does it mean it means that the container of smart pointers won't for forward and its allocator to the elements well there's it's anti-climax somehow well i there is at least a recent extension recent extent no sorry the a new feature in cbs plus 20 destructors when we can tag a distractor with with standard dist destroying delete type and this means that a destructor that delete that delete expressions won't execute the structure and in this way we can just disable some some of the structures to be to be called and i even tried to come up and i even came up with a scheme of using this feature with chat pointer in a graph that could work but i'm not really sure it's if if it's defined or not well defined or not it's complicated so summing up allocators are difficult to write so but every developer can just use the allocators provided to us by the standard template library the second point is allocators are not only for performance but therefore there are also they can also do a lot of other things we discussed are there any costs involved yes of course we have to learn learn about these classes the containers will be harder to test winking out is inherently from experts only says they said john lakers and there are a couple of gotchas like container that containers shouldn't outlive its allocator that shared pointer are not a location error and so on can we do better well we removed the type defect dependency from on allocator using pmrs bar but we have still problems allocator where classes require non-trivial structures compiler generated copy operations won't work with them and move operations all also so it would be very convenient if we could could push all that hard work down to the compiler and indeed there will be maybe well in detail maybe there is a language proposal on the way where we can just write okay i have this hash map from string to list of something and i just want to use this allocator for that and and compiler will do what what is needed to make it happen so thank you thank you for your time and for your attention and are there any questions at this point yeah so thank you mike and actually there's nothing on the q a board so any questions anyhow cool then everything was clear very well i like it yeah so else everybody is invited for the q a table and the launch so mike and to me we will stay there for your questions and mark wait for your questions there so