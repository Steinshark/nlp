nice full house that's what we like to see so i'm greg law co-founder of undo.io i'm joined by chris senior solutions architect and we're going to talk to you about gdb because well because debugging is hard i think it's a well-known quote by kernaghan that debugging is twice as hard as writing the code in the first place so if you're as smart as you can be when you write the code you are by definition not clever enough to debug it well i think that's a that's a good it's a good quote i think what he means by that really is keep it simple when you write the code but i think there's an interesting priority to that which is that debugability is like the limiting factor on how good we can make the software right as humans we basically we write software to be at the level at the edge of our ability to comprehend it and usually just beyond right so debugging i think completely dominates software development i don't think we talk about it nearly enough there's lots of tools out there we only have one hour so we're just going to cover some very small parts of just one tool gdb which i'm going to assume that everybody well i don't need to assume let's have a show of hands so who who has used gdb like ever pretty much everybody good that's what i was hoping for who's used it in the last two months see okay in the last month okay this is what you can usually see so we've got i mean we've kind of got a skewed sample here right we've got people who are deaf right like you you are by definition interested in the topic because you've come to this talk but it's not something that people get out all the time it tends to be a bit of a tool of last resort there is a lot to it a lot of depth the idea of this talk is not that you come away being an expert and like knowing how to do all this stuff it's not a tutorial firm believer and you only really learn something when you do it but hopefully there's a lot that you just probably don't know is there right it is very i learned something new every time i give this talk or one of these talks i learn something new i just learned something new this morning when we were practicing with chris and he showed me something that i didn't even know you could do which is which he'll show you with python interactive in in a moment so yeah i learned something new every time the point of this is just a bit of a smorgasbord getting out there you hear about it and then when you need it maybe in a month's time maybe in a year's time you might hopefully you'll think oh yeah that was that thing i saw maybe i can look it up on the documentation right so it's just a bunch of stuff but you have to like the thing the trouble with these tools is gdb is probably quite extreme in this regard the documentation is pretty good actually it's pretty pretty comprehensive makes sense it has good examples but only if you know it's there right you can only kind of use the documentation if you know what to search for or you can google it but again only if you know it exists so this is just going to get the stuff out there you're going to kind of know it exists and then you can hopefully look it up so i i would i'd like to distinguish between easy to use and easy to learn gdb is definitely not easy to learn but it is quite easy to use once you know what you're doing can be very actually very effective way of finding out what your code is doing and i often start my talks with i think tui mode actually it's becoming more well known but i think it still wins the prize for like that combination of least well known and most useful so maybe do another show of hands who has used 2e mode on gdb okay most maybe half okay who uses it like as their default thing use it all just oh wow like hardly anybody okay interesting i always use it i just like just think it's the it's the best way around of course you can be using gdp from within emacs or from within c line or vs code or something and then maybe you don't need it but you know often we're i don't know we're sshing onto a box or something like that and we don't have the the luxury of the of the of the graphical interface so let's go very quick tour through 2e mode text user interface so here's the classic let's compile it i'd like to compile it dash g3 because that gives a slightly better debug experience although it won't make any difference on this tiny program we run it into load it up into gdb start so here we are so this is what's called this i mean this is a text user interface really isn't it but it's the cli command line interface and we can get into tui mode in a number of different ways we could actually just start gdb-2e but obviously i haven't done that here i can go probably the most the easiest one is i can just go layout source so choose the different layouts and there we are i've got my curses tui mode and i get that context so i can see what the program is doing and i can go back with is it like layout cli no how do i go back layout prev no see and i learn what i don't know but i can go back with ctrl x a that does work so ctrl x a will toggle between tui mode and cli mode if i i'm going to just start that again right because i wanted to show you something else so that's control x a what's all layout so it's going to go control x2 i get to look up the assembly code which is sometimes useful and if i go ctrl x2 again i get kind of both why don't i have any i don't know anyway whatever so now i've got uh the assembly disassembly here and and this and the source code at the top so that's kind of useful i can actually cycle through this again ctrl x2 and i'll get to see the registers why is it telling me registers are unavailable i don't know because like clearly they're there whatever that's usually better anyway let's go back to the like that's usually that's what i spent most of my time in when i'm in gtb uh we can one one of the things that if you're into emote again this is the easy to use hard to learn often let's get a back trace for example often with with gdb we'll do up and down arrows to get through the command history right but when i go up and down arrows i just move that window up and down so there's a number of things i can do here i can go ctrl p for previous command and control n for next which is kind of the standard kind of gnu binding read line bindings or i can go this is something i learned the last time i gave this talk focus command and that will put the focus in the command window now our power and down arrow do what they always did so that's kind of cool what else can we say i think that's most of what i wanted to talk about oh and ctrl l to refresh the screen so tui mode often goes horribly wrong i mean sometimes kind of by design so i'm running i'm running the the inferior the debuggy inside the debugger so they're sharing a terminal so when i'm about to type next when i type next it's going to execute that printf and it's going to draw all over my nice two-way window right so well didn't do quite what i was expecting but it's a bit of a mess like i don't know what's going on here i'm going over on the right but control l and everything is redrawn so you will need that quite a lot it usually works sometimes that's not quite enough and you have to come out of two mode and back into two mode but most of the time it kind of does what you need and what you want all right chris python i have to use this mic which is going to make typing a lot more fun or because it's going to have to do i do the tv thing yeah see i have a mic stand now so yes we have python fully available integrated i'm now slightly worried that greg's points so let's let's just start this quickly gdb hello always hello world type thing so let's just do a start and we'll look slightly more adventurous low meeting c plus 2022. oh you've prepared look at this it's almost like on yours coming okay so we have python here so people might iphone print hello everyone wonderful as we saw on the slide i will reach it oh yeah that one yeah just on the side we also have the interactive mode so single commands you've just seen window honestly that's great that sometimes you want to do something a bit more complicated so you can just start the python line and then you've got multi-line python so print oh yeah but multi-line and and with ctrl d as you might be familiar and then until the exit and execute the entire site you've got there and then as we saw on the side i'm not going to go back to that because i'll just get confused again so we can do the python interactive at this point we're now in an interactive python note the prompts different instead of one we've got three so now i can do print and patient we want to get our printing on our access done immediately so this is allowing us to do some of the python things that everything's available to us that you'd expect with python so you can go into the outside world you can bring all sorts of modules in here if i go back to the slides now and we'll go to the next slide oh sorry first we can also source python scripts and you'll see me doing that in a little bit we also have access to gdb so we've got the format over to there everything in python but we also have a gdb module we can use so let's go back i'll control d let's go out of that again so let's say we want to do python gdb.execute list and you might think well that's kind of pointless because i could have just typed list obviously it's continuing the list so it's not doing the same thing but if you've got a complex python function you can use this to access the state of what's going on exe commands even navigate so you can have your python's scripts modifying code continuing setting your breakpoints and all sorts of dynamic and funky stuff i'll let you figure out what you want to do there so that's that but there's also things like printing the program counter so i can print that again with python i can print gdb dot e var oh no pause and eval you've got an extra quote there okay good and we can access this data so we're able to access expressions as well from gdb all of this is accessible to your python code so you can do all sorts of funny things obviously as i say you're not going to be doing this interactively the way i've just demonstrated it this is for integrating into scripts and no more funky things later but hopefully this gives you the basic understanding of what's there let's go back the slides custom fonts so you can see you can just set the font in gdb so set from prompts so by default we have gdb why would you want to do this well for my colleagues and i we we spend a lot of time debugging gdp itself so you might want to have one window which is clearly the gdb that you're debugging and another window which is clearly the gpb that's debugging it more realistically for people in more normal use cases you might have like a client server session maybe remote debugging on two separate hosts you might want to label one as clients on one a server so you know exactly which session you're in when you're trying to debug multiple processes that can't be easily managed under the same thing although greg will show you why it's a bit multiverse just debugging later but you can also use python and you can see here we're using the hook pump so rather than looking at slideware let me equip this and do gdb so this is an example program i'll start it you can see we've got a gdp prompt but if i source prompt dot pi we've now got more interesting prompts we've got the time of day i can start stepping and you can see we've got the frame that we're in details of where we are as i step through this very simple code it's not done anything really interesting this is purely showing just as we're stepping on we can get we can do interactive things of our font to get useful information there again this can provide all sorts of value maybe you're wanting to track specific users or you've got a whole load of transactions in flight you need to remind yourself what one you're working on of a metadata you might want to pull out of the state of your system and have it at that at the prompt for you so you can see what you're doing we it's an alternative way of displaying things rather than having like the display feature that we'll talk about later briefly to output things every time you stop this is just there all the time and constantly updating which also can help if you've got multiple processes running maybe you've got the multiple threads running and some of that when you're non-stop state you can keep track of your memory usage maybe you want to put that there all sorts of things so that's great i've shown you how to do let's actually have a look at how this is done so now what we did find with it we'll try this earlier and you can't read all of that so let's take off this in touch coloring so we've imported gdb this is going to be needed you can see within the gb select frame so this is how we got the function name we're in also using time so we can get the time of day basically we have a function my prompt hook and we're going to associate that with gdp contact so this is how you register for events so every time the prompt is being displayed it's going to call this and this is going to work out what the current time is find out what the frame is and display that data in the problem so that's the string there we go that so very basic simple way of doing that let's go back to slides so i think what match should be worth saying so i'm i'm guessing for most people they're happy with the regular gdb prompt but i think it's a that's a really nice demo of just the kinds of things you can do right this is just not like hey python and gdb is cool because you can change the prompt python gdp is cool is because you can if you can imagine it you can probably do it right and you can hook right into gdb and sort of change its behavior in whatever mad way that you've you want to okay you've done a wonderful mic stand job there yeah i found my i found my vocation yeah okay so another use of python is pretty princess if you're probably coming princess or standard library which apprentice you may not necessarily have an understanding of how they work what's going on behind the scenes but they're basically python that's like this on the slides you can see there's an inner and a two string so when you're printing a certain type once it's hooked up with frankly the boilerplate at the bottom so anytime a my struct is printed it's going to call this it'll do the two string and this allows you to do some funky printing options so if i come back here [music] let's go over to here and quit and gdb on this one start so we've got a example here where we've got this value t also just got a lot you can see it's got two elements and we can see i've got the good a bad and i'm ugly or maybe a good a no canary and a bad canary i might have to rename them let's just advance to line 24. so these have now been insulated i can print no no there's no god we can we can be good and we can see yeah that that's sort of great it's very raw standard data structure i can pee bad it's like yeah those decimal numbers are not pretty clear what's going on and fundamentally this is very raw if i source value dot pi and i try that again let's go back to pretty good we've now got just the data and everything's happy i think mark okay well you've hidden things you don't really care about so that's often the case you've got data structures that have a whole load of stuff that isn't necessarily critically important to the way you're working some of it's just how your system is glued together let's look at the p-band i think now we've been able to identify that it's bad so we're providing metadata analysis of the variable as well so this can be extra helpful i can do the p no canary and again uninitialized data this is very straightforward i'm sorry that's just very quickly i'm not going to go through the details i will turn the fonts off so you can see the text so again we have the two string function we're accessing the values and we're checking have we got the good value output data is it corrupt show that it's corrupt and output the the full content and it's not initialized up with that so the idea being you can do pretty much anything you want and you can see it again at the bottom we have pretty much the same four lines of boilerplate which in this instance is associating the value t type okay so that's a quick example i've got another quick one you haven't got time to this one gone in yeah very quickly why not i've got to lose time that's okay you're doing a great job there yeah i'm not having to hold that heavy microphone my arm's getting tired okay let's try here another example squares so here we have a slightly more complicated data structure it's a linked list there's that should be reasonably obvious to people so we've got the pointer to the next element and the number one squares and we've got a bit of code which is just going to populate by 10 entries of that so again let's advance to line 22. and i can pee star squares we can see the first element so again the second one actually this is getting a bit cramped when height source eight i don't care about source code i want to show you what i'm typing here so an extra bit of two for you you can change the height of the source window so yeah so i can do this i can go back up i can go again and we can follow it down that's not great let's look at a slightly more complicated pretty printer this one is designed for this particular linked list so if i go back to what i did before the first one we're printing we've got a squares list we're actually iterating down the list finding all the entries and displaying it here's a map i can still do what i did before you know it doesn't change any of the way the expressions are evaluated so if i do that we'll see just the last eight values well in the full ten so everything's still working the printing is happening once the expression has been evaluated if that's not clear let's have a look at how this is done i'm not going to explain it in great detail for time that i will again i think support fix the fonts two string again the children allows you to do more complicated structures so it allows you to look at it and then finally display hint map says it's a map one value to another it's like you can you've got this i can close recorded and we'll be happy to help you understand this stuff from the from that but there's plenty of documentation on pretty printers lots of stuff out there and they can get far more complicated than this if you want to you can do things like crc checking the data structure for example if you've got a crc in it why not check it and validate it and answer whether the data structure is bad or not when you're printing all sorts of things you can do when you have access thank you chris let's do another show of hands who uses pretty printers with gdb oh not many a few a couple all right so i i sorry for sdl oh that's cheating but yeah so stl comes with so if using stl there's usually pretty printers like in the distro to help you do that i'm going to make a promise to you if you i just lost a bit awkward right if you write some pretty printers your future self will thank you you'll be glad you did they're a bit of a pain you can see here you know it is unfortunate that you need quite so much boilerplate not quite convinced you do i always expect somebody's going to tell me you don't need that much boilerplate but as far as i can figure out you do whatever we all know how to copy paste it is a significant quality of life enhancement i think if you if you write pretty printers for your main data structures okay right gdp in it it's not going to suit too much on this one but here's some i i think try to keep it simple i have had several occasions now of customers i'm saying oh your tool doesn't work and we try and figure out what's going on and they've got things like obviously it's more than once a run command in their gdp init and that just makes life really hard i think don't do that but there is but these are some useful things so set history save on so this is you know so when you're doing that up arrow to get your command history you can you know we'll remember it across across gdb sessions which is very useful pretty printing patination whatever i really wouldn't put too much more in your gdb in it just source what you need to also though which which gdb in it well annoyingly we have we can have several so you can have a gdp init.gdb init in your current working directory from which you launched udb you can have a dot gdb in it in your home directory so which obviously is gonna there we are look at that so i completely lied i've got more stuff than that in my gdp in it but you can have gdp in it in your home directory which obviously will apply to any gdb you start from whichever directory and there's also a system gdb in it which depends on your distro depends on the way the gdb was built but if you go man gdb it will at least tell you so somewhere let's do that then that's what i was trying to think of maybe yeah right so there we go so on ubuntu it's built such so you've got a system ygdb in etc and in etsy and it will do these gd and it's in an order and i forget which one it is i'm sure the documentation would tell us so there we go right remote debugging i'm going to show this one very quickly yeah if we leave the mic there what happens does it pick you up if i move away okay so we might be bugging as we saw on the slide that's basically a very simple it's all called gdp server so i've got two windows here so on this side i'll launch ddb and now i do target remote local 2000 and so this is now going to connect gdp to the cdb server you can see on the right side connection okay we're at the very start of the application it is actually running but we're at the start of it so let's just set a 10 temporary grade point at main and we'll continue to main so on our source code i could do this sufficiently small you can sort of see what's going on but fundamentally what i'm going to do is hit next and we can see it's outputting so we can do this divide in this instance it's on the local host but it's just an ip address you can use wherever you need to so second that example i mentioned before we have a client and a service type thing where you try to debug both sides this is quite possibly a way you'll be connecting to one of those targets to do that something allows you to keep things efficiently on your site i think that's pretty much it for that one right what's next yes break points okay so we all know about breakpoints so i'm not going to ask her a share of hands i'm sure everyone's done break points but there are lots of break points lots of different types of break points so break food that's our normal kind of breakpoint tea break i only figured out relatively recently i don't know if this is a deliberate pun but i like it so tea break i encourage like all good englishmen we should all take a tea break but temporary break point so yeah you set the break point you run as soon as the breakpoint is hit it will then be removed deleted it's not just that it's proof gdp was written by an english one because when you start in gdb you set a tea break so you start with a tbr [laughter] our break is a regular expression breakpoint so this allows you just to rather than a line number or a symbol to break on you can give a regular expression and any function name that matches that regular expression will get a breakpoint set on it so if you're not careful you can set thousands of break points kind of by mistake but that can be very useful you know maybe i've you know got a common prefix of a sort of module and i want to put a breakpoint on all of them i can do that easily with our break thread specific breakpoints should note that if you do a thread specific break point might be done here break through thread three all threads will stop when they hit that break point but gdb will silently continue them if they're not to thread that we're interested in this is not the thread we're looking for conditional breakpoints you can so you can have pretty much any expression following the breakpoint and then it will only again well gdp again the program will stop every time it hits the breakpoint gdb will evaluate it however if you're doing remote debugging you can configure and your remote debug server your ddb server is capable you can get it to do the evaluation of the expression in the server which stops it pinging back to the host evaluating some expression probably fetching lots of data that could take a really long time depending on you know the latency of your connection of your remote debugging so you can do agent debug agent breakpoint evaluation if you're if your gdp server is up to it the default gdp server is and yeah if we can delete them we can disable and enable them and we can just type disable on its own and that will disable all breakpoints and watch points and catch points talking of which so then we have watch points my formatting is a bit broken never mind right so we've got regular watch now watch points are i think anyway a bit confusing until you've figured out quite how they work so we're what we're what we're watching an expression right so you if if gdp can it will use hardware assistance it will program the cpu to stop when the watched data is actually modified so before going barreling on who who uses watch points show hands oh it's more niche than i thought okay right so what point sometimes it's called a data break point it's what's called in microsoft land right so we're going to right we set up a point we're going to run and gdp will stop when the watched data changes two types two broad types hardware and software watch points hardware watch points and almost certainly what you want because the program runs at basically full speed as long as the cpu supports it they are limited in number like x86 only supports four i think arm64 will support 64 or 16 maybe um but that's usually enough right if you're unlucky and you get a software watch point gdb will single step your program one machine instruction at a time and evaluate that expression between every single step and stop when it changes so that will run like super slowly and if you're not careful you can end up it's really easy to end up with a software watch point by mistake because like it doesn't tell you let me show you [music] let me show you so what have we got here what's a suitable i want to i think structs will do so here's a program so i can watch x like that that will put up that will put a watch point on x but notice slightly difference here between watch x is a structure right and it's quite it's a big-ish structure if i watch x dot a hardware watch point right so that's it's really easy to miss it's sort of historical it's because gdb had support for these watch points before mostly there was hardware support for them so then hardware watch points got added later so if gdp can it will use a hardware watch point which as i say is what you want it will evaluate the expression entirely so if i go like watch foo points to bar points to bars it will stop whenever the value of that expression changes which doesn't isn't quite the same as stopping every time the data that any of that memory is written to because they might be written to you with the same value just you know not changing it and then gdb won't stop maybe i don't often i don't want that though particularly if i've got some kind of memory corruption problem i really care about the like the raw memory right not the not the not the expression so with any i don't know i think since gdb 9 or something you can do watch dash l or watch dash location which will just figure out where that address where that expression resides in memory and watch that our watch so if you remember our break regular expression breakpoint watch something completely different nothing at all to do with radical expressions it's a read-only watch point so there's another classic bit of gdb ui we can also have a watch for an access watch point which will stop whenever the memory is read or written and of course not just when it's changed for specific watch points now in theory unlike break points it's very specific watch points if they're harder watch points will only need to stop when the on the gdp will apply watch points to the individual threads so you may i haven't actually tested this but you may find if gdp at least if gdp is any good the other threads will run kind of full speed unencumbered so if you've got one thread that's hitting a watch point like loads of times and you don't want to slow down by hitting that thread specific watch point should be nice and efficient i think and of course we can have conditional watch points and it's all part of the same namespace right so they'll get enough watch points and and break points and catch points all get a number and they all live in the same namespace and you can delete and disable and enable them like that we also have catch points which are which kind of cool so they can catch various interesting things that might happen system calls being a good example also c plus plus exceptions both when they're thrown and when they're caught and when they're rethrown in fact and i can catch things like fork and exec and other stuff so catch points are kind of just stop when various interesting things happen if i want to know what's available tab complete is often your friend so tap tab and so you can see i can catch asserts and yeah and exceptions i think actually though exceptions is for ada so you probably don't want that you probably want catch throw yeah catch catch or catch throw or catch free throw okay i'm gonna show a little pro a little demo now kind of trying to wrap a bunch of this stuff together how are we doing for time i think we're okay right so multi-process debugging so chris talked before about so maybe you've got some sort of you know distributed application client server whatever and you want to debug multiple things at the same time i can just start two copies of gdb maybe i'll change the prompt on one of them at least to not completely confuse myself or maybe i want to control it all from the same gdb which has various advantages and let's look at how we might do that so i'm going to do actually i'm going to do a similar thing that christie let's get a split window like that all right and now let me try and remember this demo so we want to i want to it's a gdp patch don't want to say bash okay you remember that and i do oh yeah right thank you yeah that's what i wanted to do complete brain frog right so let's let's look at a program let's let's just this is just an arbitrary command right and i wanted to debug some of that make it a bit more interesting now let me actually let me get so we can see both these at the same time why doesn't that okay detach this list i think attached current time so we so that's the pid of bash on the right hand side so let's just attach gdb to that all right so of course now if i type enter on the right hand side nothing happens bash is paused why while we are debugging it okay so i'm going to i want to want to hook when it when i ran that cat command i want to hook that and i'm going to do a multi-process debugging thing as well so let's put a catch point on on fork and another catch point on exec now notice i didn't i could have said catch cisco fork that probably wouldn't quite do what i want because on a modern linux system it's not really going to call fork it's going to call clone or probably clone 2 or maybe even cloned three there are different types of fork catch fork will just put a catchment on all of the fork forky things and the same with exec you've got exact ve and all of that so that's just a nice so i can just go catch four can catch exec and let's run the program so didn't expect that anyway right so let's just do that again cat hello dot c right so here we are so i have we've got a catch point on fork now by default when gdp one of when the program being debugged forks gdp will continue to trace the parent and allow the child just to run sort of you know untraced now i can change that set follow fork mode and i can set it to follow either the child or the parent so i could change it to follow the child but i don't want to follow e just one or the other i want to follow both so what i'm going to do now is set detach on fork which defaults to on but if i set it to off so let's go let's look at look at our assembly code here so we just after the cisco the fork so ox38 is probably the cisco number four well one of the forks when we're actually inside the cisco is what it's called a you get two traps if you're doing petri cisco you get a cisco entry stop an assist called exit stop so i think we'll be at a cisco entry stop it hasn't done the fork yet it's just about to and if i do next i to just next over that run one instruction now it should have done that fork so if i look at what's in rx that looks like a pid so i'm probably looking at the parent and if i go info inferiors yeah look we've got two we're debugging two things at the same time two copies of bash at the same time it's just done a fork this works very like with threads right when you're debugging threads and you go info threads or you go thread three just you just do the same with inferiors so if i go inferior two well it's just on a fork so it looks awfully like the two look awfully similar don't they but of course rx which is the return value from the fork is zero in the child because that's how fork works right so that's all good so now i'm debugging both these things at the same time if i continue the child what i'll see if i remember correctly as well everything's going to lock up if i just continue the child yeah that's kind of depressing so what's happened what's happened here is they've got i think very locks are locked locks are are held as some kind of there's something preventing that child from running but if i go back to the parent continue that let's just see where we are so that is inside the weight that follows the fork so now it's waiting for its child so now if i go back to inferior two and continue well now we hit the exec catch point so look we've execed cat here i don't know why that doesn't select anyway we've exactly we've exact cat so if i now continue from there we should see cat runs to completion info inferiors so that inferior still exists but it's not doing anything like it's exited and so i can go back to parent and continue and okay it's done in the fork for some reason i don't know why bash is you know running something else so there we go so so multiple inferiors at the same time i i think i expect in fact now i know you can do this with remote debugging as well so i might be using one gdb to control processes on different machines even at the same time that's most of what we just covered except there are other ways to add inferiors the one that i just showed how you probably want to do it i think which is by following fork but maybe i want to attach to different processes at the same time you can do that i can just create an inferior by going and by ad inferior and and then i can just attach just with the attach command to an arbitrary process or indeed using right debugging at that point so ad inferior kind of creates a kind of not shell that's the not the wrong word to use but a kind of kind of null inferior that then i can populate by attaching it or whatever chris now by default in gdp when you started talking you've got multiple threats going if you hit a breakpoint on any photo or photo stops man this is great if you want to see what's going on and see exactly the same but that's not always what you want so there's a concept of non-stop mode if you set it on what this means is only the thread the breakpoint stops the others continue running and then you can start and continue stopped and since one fans there's also things like fun apply to apply different performance you can see first one to support pointer or do a back trace i'll do a very quick example of this you can be friends so here we have our reds basically we're just going to launch 10 threads before i create and then sleep at zero the threads are really doing much they're just constantly rolled through square rooting a random number so it's not doing anything complex but the main thread is going to stop at lighting 33 to sleep to sleep so the main thread is going to stop mine 30 feet sleep so let's just put a break point on 33 and we can continue and we see we've spawn the threads i'm not going to look at the code as much anymore so let's source to eight gives a bit more space so if i do info frets at this point you can see they're all there they're all basically stopped wherever they happen to be until that time we can do the which is also thread apply one two three p so we can print the program counter the first stop let's look at one stop mode as a comparison and see how things differ so i'll just i have to kill this because you can't have any when you change that so set non-stop on at this point info break s we still have that break point of 33 so the main thread is going to get to that one stop so i can just run this so we've won starting out launched our new fed and fed i'm on has hit that great point and find an infrastrates now we can see the elephants are still running this also means if i do that apply for a possible it can only apply to the stop thread so the other kinds of money you can't that and that's not the state that let's try to learn at that time if i look at the source code there's just enough to see if we scroll up we saw that while loop was zoom pass background so what i can do just to bring those auto switching holes is for the brake point of mine 17. obviously all the folks have hit that so info threads that also up to the same place as you might expect at this point you know that's something doesn't work so that's a very quick model thread taking this out with them and the non-stop mode i'm waiting so this allows you to tackle your multi-federal application whatever makes the most sense to you and particularly useful if you've got like a other threads that might time out that's doing some kind of heartbeat or some kind of you know application like that then stopping the threads in gdp can be a non-starter but non-stop mode allows you to do that and if you're really lucky gdp non-stop mode won't even crash your mate your mileage may vary right yeah so calling inferior function so i'm sure i'm sure many people have done this call foo i can call the function foo often actually that's people do that to pretty print because they've got some pretty printer in their program they want to invoke and yeah and they haven't been good people in good past themselves and pastels and they haven't got a python pretty printer so we can call so we call functions that's quite a common use case but you can do anything right and and the function will just you know run and do whatever it runs it might leave side effects you can also just print the result of an expression right so i can go call foo or i can print foo here and the same thing right because i've said you've got to run that function if i've got c plus plus and i've got operator overloading print food plus bar might result in inferior functions being called print erno will result in an inferior function being called because erno is thread local and it runs a little bit of code to get the threat the address of erno and sometimes although i think this does the very latest version of gdb aren't so bad at this but if you do something like this call strip copy this actually is going to do i mean obviously it's going to do an inferior function call of strip copy but it's also going to do an inferior function call of malloc to malloc some space for this literal string and then copy that string in and then run strip copy so gdb sometimes can catch you out and i speak from personal experience if you happen to be debugging a custom malloc operation that gets confusing right how long do we have no there's never enough time isn't it right time travel debugging i'm gonna do another quick poll who has heard of time travel debugging okay and who's used it his niche you see it well this this one like i'm a bit biased but this will change your lives right let's so gdb has inbuilt time travel debugging or reverse sometimes it's called reverse debugging that shell's being debugged isn't it i'm gonna get rid of that ah that's crashed yeah nothing to see here never happened yeah gdp didn't just ruin everything i didn't need to shout out that was stupid okay time travel debugging so debugging time travel debugging is so useful i think because when you're debugging you really want to know what happened and the big limitation of most debuggers is they don't tell you what happened they tell you what's happening they tell you what's happening right now at this point you've stopped i you can do a back trace and get some kind of historical what happened but that's really limited right it's the kind of sliver of of your program's execution so we are meeting cpp so i have here a program sort which just basically gets some rand get some random data and sorts them using a bubble sort and if i run it here it usually doesn't print anything out but it usually works but i know i happen to know that there is a bug so if we run this for long enough it will sec fault promise yeah see i never lie right so let's well let's load that up let's load the core file so there it is so gdp yeah okay trace not very much use so that looks like some kind of stack smash of course the core file just gives you this snapshot at the very end of the program execution but i want to know what happened i want to know how i got here so i'm going to use gdb's inbuilt time travel debugging which works it is very slow but this is a short program so that's okay so and i'm going to do some other tricks as well so start so i'm going to put a breakpoint on main i'm going to attach some commands to that breakpoint so every time break breakpoint 2 is hit now we're going to issue these commands first one is going to be enable recording and then it's going to continue and that's it i'm going to put another breakpoint on exit i'm going to attach some commands to that which is just going to be to rerun the program so if i get to exit without faulting it's just going to rerun i'm going to set confirmation off because otherwise it's going to cost me more time when i want to restart step pagination off because that's just annoying and continue so so we're just running round and round every time it gets to the exit breakpoint it's obviously run successfully without segmenting so it runs again enables recording you can see how slow this is right this runs in a blink of an eye normally what gdb is doing is single step every single instruction and see what changed but eventually it stopped because it's hit that segfold back trace still garbage right but here i can go reverse step i so like a step i like step instruction but go back one and look at that now when now i'm in where i would expect to be so this is looking really like you know snack stack corruption let's look at the stack pointer stack pointer is that so if i look at let's say long star star stack pointer so that is the return address right if i look at if i look at the didn't mean to do that i'm going to do that i look at the i'm at the ret instruction retful fetched will pop the values of the stack pointer points to it's a full descending stack and that is the return address and if i want to look at that memory which i'm going to do with the x command for examine that memory doesn't exist so okay that's kind of what i was expecting but the question is why did that happen right why is my why does my stack contain garbage well i'm going to do something that's super useful with time travel debugging which is to set a watch point set a watch point and then you run backwards that will run backwards until the data changes and that will tell me exactly who stomped on my stack now there is a catch in later versions of gdb sadly with this inbuilt time travel debugging watch points seem to be broken which is super sad because like the probably the most useful the killer feature of time travel debugging but the good news is it's only hardware we figure this out on the train chris and i yesterday it's only hardware watch points that are that are broken so if i set can use hardware watch points to zero now gdb will use software watch points as i said earlier on you don't want software watch points really because they're really slow and gdp single steps and sees whether it's changed and it does another single step and it just takes forever but process record which is what in built gdp time travel debugging is called does that anyway that's how it works so actually soft software watch points are no problem or at least no worse than not you know then uh than than hardware watch points so let's just get back to the view i wanted so so now i'm going to set a watch point on the address it could be location that's why i was basically it's got to be a location watch point otherwise it's going to change the stat point every time long star star pointer now reverse continue we'll go back to when that location on the stack was written which should have been when the function was called right because it's supposed to be the return address but we know it's not ah look at that who would have thought it it's writing into the into the local array print i it's writing into the fifth element of the array and what is array it's an array of only 32 elements because if you look here i've gone percent size of array and of course that's the size of the ram bytes not elements so a whole bunch of stuff coming together there show the power of time travel debugging if you want time travel debugging that runs with decent performance and you're doing more than you know a few thousand instructions you want to look probably at either rr which is an open source time travel debugger that's available or there's some product from this company called undo which claims to do the same it's really good i think we've got a couple of minutes left yeah so we're always you know more content than we've got time to do a whole bunch of stuff maybe as we've only got two minutes we've got a few minutes question any questions we've got a bit more content we can run through but there might be some questions no question yes question is if i have a gdb server can i have several gdbs connecting to that gdp zero at the same time i don't know but i'm going to guess no i'd be very surprised yeah yeah but actually i don't i'm not going to guess maybe we'll try it afterwards maybe it would work yes question yes so the difference between watch national and normal watches yeah watch without the dash i will watch the expression and so yeah so so if i in my demo if i'd forgotten to do watch l let's delete that watch point let's run to the end that's rsi so if i go watch star like that forgotten the dash l and then i reverse continue it doesn't go very far all right let's continue again because the result of that expression looking at the stack pointer has changed because the stack pointer has changed the connect component inputs that expression have changed so the watch point triggers dash out but i wanted to look for that memory corruption so i used dash l you actually dash l is just really a convenience thing you can just take the address and then watch you know you can go i can go watch star long star and then just like paste in the the hex address there and that has the same effect but watch josh l is a bit more convenient except sometimes i haven't worked out when sometimes it doesn't work just gives you an error that it can't do it and in that case you can just yeah watch what the address points to okay oh there's lots of questions okay yeah can hardware watch points do expressions yes gdp is quite smart at this so if i've got an expression with multiple sort of component parts it will put a hardware watch point on each of the address each of the bits of memory that combine to result in the evaluation of that expression so if my expression is too complex it'll run out of hardware watch points and then it can't and then it will probably fall back it's kind of inconsistent here so if i just try to set five regular hardware watch points it sets them and then when i continue the program gdb says i couldn't set all the hardware watch points so i can't continue so it stopped if it's trying to do a single watch point that that it can't use the hardware watch points to construct it then falls back to a software watch point like transparently so yeah it's a bit bit confusing but yes you can use hardware watch points on quite complex expressions and it's kind of cool yeah works pretty well yes can you use the name of the thread when you specify the thread i don't think so but we can try we can try like i've only got one thread here but that's probably okay so i can go thread name blah so if i go thread blah i don't think it'll work now i think it has to be the numeric id that's a really good point so if you how do you predict what the thread number is yeah now you you could write some python to do this i'm pretty sure yeah yeah probably time probably at time maybe it's a question what about do you mean what about lldb the the yeah yeah i don't know what about it it's fine i mean i've just i just tend to use gdb my experience really nobody types lldb people use lldb because like it's what xcode uses and some other stuff but people tend to type gdb and i think gdp just has it's just richer there's more i think a lot of some of these features like a little db i think now has the python and it has a bunch of this stuff but and it has some stuff that gdp doesn't so they're just kind of different tools the same job i guess but i can't do a talk with ldb because i don't use it all right we better stop there because i'm outstate our welcome but thank you very much everybody [applause]