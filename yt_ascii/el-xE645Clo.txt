so good morning everybody and welcome to my talk about contemporary c plus plus in action i hope you've been enjoying the first day so far at least i did so let me give you an outline of what i will be doing in the next 90 minutes or so i will give you a demotivation of this talk because actually i wasn't meant to give any talks this year at all for personal reasons but yeah i actually did it anyway and what i've what i will be presenting is kind of an experiment that i've been conducting during the preparation of this talk in the end i will give you a demo of the results of this experiment and finally my conclusion of the outcome for those who don't know me yet i'm an electrical engineer i'm building computers and software for probably 40 years and even more and i develop hardware and software in the field of signal processing professionally for more than 30 years now and for quite some time and also involved into the work of dc plus standards committee and i'm actually now an official member of the german national body mostly i'm working on evolution this is the development of the language and also the study group 15 which is about tooling i'm employed at a tiny company in the south of germany in the field of industrial quality inspection systems customized to the needs of our customers so what is the motivation as i said this is an experiment at the beginning of the year every time i was looking into social media like twitter or redhead or similar i always encountered people who were very outspoken about the current status of c plus plus and the work of the standards committee and these people seem to know that the truth about c plus plus like c plus plus is dead the community cares only about nerds yeah the committee cares only about library writers the committee is way too slow and doesn't deliver anything the other 50 people say oh the committee is way too fast only half baked chunk is coming out of it you noticed the keynote yesterday yeah and then committee is just a bureaucratic bunch of people who don't know what the reality actually is and some say hmm c plus plus or free is the only thing that you need to care about everything else is just syntactic sugar everything what you do right now is useless okay but is this really true let's see let's do a reality check at around this time in the year i didn't submit any talk proposal fill nash came to me by email and said you know what i will running this conference in england c plus plus on c and i want you to come and give a talk about modules i said no phil not once again i've been giving so many talks about modules in the first couple of years your conferences in 10 weeks of time i can't prepare anything meaningful in 10 weeks this is not possible but what's bugging me is this this this stuff that i've been showing before that c plus is not worth anymore to do something in reasonable there and i'm a member of the committee and i feel a little bit offended by this truth so i want to contact an experiment what about the following idea what if a disadvantage myself as much as possible and write an meaningful application from scratch and implement something that is not trivial and i want to use as many things i have no clue about call language features standard library features third-party libraries that i've never been using before or stuff that have been failing quite reasonably quite recently for example core routines a totally failed at call routines just a week before and so i said hmm i want to make an application with all of the stuff that i failed or have no clue about like c plus plus 23 core routines concepts infinite ranges what i'm allowed to do is using stuff that came out from the work of wt21 this is the c plus committee in from the time frame before 2020. and my objective has been to come up with something that is using all of these features and work together as smoothly as possible this is the reason why the talk is contemporary c plus plus in action but what does contemporary c plus plus actually mean is it ancient c plus plus 98 or o3 well let's admit the old standards from the very beginning of c plus plus still shaped the landscape of c plus plus there are many things that that we all are using every day without even noticing how old this stuff actually is or is it the renaissance of c plus plus that has been happening with c plus plus 11 and the completion in c plus plus 14. maybe or is it c plus plus 17 what i consider or would characterize as industrial the industrial version of dc plus plus standard with all the nuts and bolts and the little pieces that came with c plus plus 17 it makes our life so much easier if we are actually using c plus plus 17. or is it the next the second big bang of c plus plus that was happening with c plus plus 20 and it's now completing with c plus plus 23. yeah i think it's actually all of them every thing that has been coming from these language standards and has stood the test of time is something that i would consider contemporary c plus plus something that you should use today or should adopt in your own code basis and this is the motivation and the characterization that i give for contemporary c plus plus and to the second half of the talk title in action what does this mean as i said before i'm an engineer and this demo applications that should be something similar to my daily work that i'm quite familiar with and it should contain all the engineering stuff that i deal with every day like data collection and data processing a quick detour on the bottom right you see an fpga that has been mentioned just in the sponsor video or in yesterday's talk by philip unde who was talking about the foundations of gpu programming what actually is running here on this fpga is c plus plus code that have been written in five years ago and something like that it has 200 dsps on this fpga that i designed myself and that was slowering the c plus plus code onto micro programs running on these fpega's on these custom-made these fees and i will need something like data visualization near time real networking of course library usage from libraries that are not written in-house alternate of course libraries that we implement by ourselves and interface design all of the pictures you've seen here is stuff that we are using in our company or dealing with this is party in particular my current project here so this experiment the specification of the demo code that i will be implementing here it's a client server application it has a server port it has a client part and all of that is combined into one application server will create a list of given endpoints that clients can connect to and as soon as a client connects it will scan a given directory for the contents in this directory endlessly over and over again as soon as the iteration is done it will start over and look at the actual current contents of this directory and if it happened to be two files in there it will decode each of these two files into individual video frames send them at the correct time as mentioned in the frame in the individual file to the client and since the these frames over the network if they happen to be no file currently in the directory it will send filler frames such that the client would have at least kind of a heartbeat the client connects to one of the server endpoints that the server is listening to it will receive individual video frames from the network connection and present them in some kind of a gui window nothing fancy and the application itself should behave like our industrial applications do we want clean shutdown in every situation we don't want to terminate because of unknown reasons or whatever it might happen there and every communication over the network should be guarded with timeouts in an industrial settings you probably do the same there's no io without any time out accompanying this eye operation and of course error handling needs to be done properly not just crashing as said before a short disclaimer yes there is of course significant amounts of c plus plus 23 in there and that are totally rise on c plus plus 20. and as i usually do this is the following the almost always auto style and for those a little bit allergic to compile time programming yeah it's in there too and my naming follows the chemical case style i hope you can stand it just for the sake of simplicity and brevity please assume that these names using directories of namespaces exist without mentioning it on the slides and also namespace alias definitions like if it's a file system rts for ranges and dws for ranges views yeah my types begin before lowercase t things are different capital letter and erdmember function non-selected amount per function have fun trailing underscore just to give you an idea how the code would look like and how to understand it as i said i can use stuff from pre c plus plus 20 time frame work of dwg 21 and i'm using the aco library here which is an semi-standardized implementation of the networking tiers that was published by the iso in 2018 and it contains an asynchronous networking a set of functions and an execution framework for those i'm also using something to handle the g files any decoding of that if you're familiar with the ffmpeg tools the underlying functionality is implemented by a library called lib av and it can handle virtually everything related to media formats for the gui part i'm using the scl library it's an open source library to handle multimedia i o and in particular it provides minimal windowing and it really excels in simplicity and i'm also using two functions from our in-house code base for example an options person both the lip av library and the sdl library are c libraries and c libraries usually allocate objects on the heap and this will probably lead to manual memory management indeterminate responsibilities potential memory leaks potential memory retention because you may forget to release them in time accidental copying accidental sharing all the good stuff that we expect from the libraries so instead of code like shown on the bottom 50 pointers where it's not clear is its owning or is it just referring yeah the allocation functions the release functions yeah we want don't want to deal with such kind of things so instead of doing that i wanted to make them value types c plus plus is d language for value types sometimes i think it's kind of forgotten that the the fundamental thing of c plus plus is is value types and not reference semantics i think many people too many people are just setting out for reference semantics and now have to deal with problems like dangling references pointers whatever it might be no we want value types and the reason for that we get constructors destructors and we have therefore well-defined lifetimes we have uniqueness every object allocated on the heap is an individual thing and it's unique in its own kind so we don't have sharing and we actually prohibit copying and we can propagate constants for the integrity of the objects on the heap the most important aspect of value types is the independence each instance of an value type is independent of all the other instances there's no sharing in there there's no referencing to them so you can easily reason about the code if you use value types and coming from that is the ease of composability you can put them into your own types and treat them just like you treat an end or something like that so i created a wrapper class that takes such keep allocated objects from c libraries plus allocation function and and the free function and the result of that is a properly wrapped c type as a value type just by giving the necessary parts as template parameters here and as you can see on the bottom of the slide you can use now these object types just like regular c types different constructor and everything and a destructor and guaranteed lifetimes so i don't show the code in there this is a little bit involved so i spare you that you can look at at the code later on if everything is up on github so you can look at it in detail and study it if you need if you don't want to if we look at the specification we have multiple parts to implement here the first part deals with video and the decoding of video files i'm using this wrapper here to wrap four of the lip av jects codex files frames and packets this part here and two of these can never be empty so i as you say can see you can derive from these wrapped c class types and in this particular color case i guarantee that these are never empty and constructed within proper backing on the heap and the first type that i have to implement here and provide is something that i want to use to represent my decoded video frames to send them over the network to the client so i have a frame header with a couple of properties like the width and the height of a frame some other meta data like the format and the sequence number and if you look closely you will see here that the bit allocation of these bit fields are not literals there's a function call in here at the top of the slide you see a constable function called format bits that calculates the amount of bits you need to represent these enumerations of the pixel format this is something that came with c plus plus 20 and makes such kind of things much more easier than it has been before it's just a regular function using regular standard library functionality to calculate all you need it also has a couple of property functions and predicates to figure out what kind of frame we are dealing with here and the most interesting and most important part here this particular class is trivial which means every constructor in here does actually nothing and you can trivially copy it which means you can mem copy this object you can serialize it to disk and deserialize it again and you can send the contents for the the considering bias underneath over the network to a different machine and the second part that is also important here it also has a trivial destructure and both of these features make them something that is called since c plus plus 23 an implicit lifetime type so we will use this particular feature later on when we come to that point pixels are represented as consecutive sequences of constant bytes and a frame is just decomposition of an header and a anti-pixels that make up the frame with a constructor that can give us a filler frame this is something but a darkness for a given duration of time and if we actually happen to have a fully decoded video frame coming out of the lip av library we can now wrap these pieces together into our own video frame type by constructing a header out of the properties and here the c plus plus 20 designated initializes come in really handy i think this is much easier to read than a regular cut structure is the pixels are just a view into the allocated store of the decoded pixels within the lip av library and this is everything you need to do to get a video frame out of this library at this point here we get at the core of all the video frame decoding this function make frames takes in the directory that you want to iterate over 40 contents and it generates it returns a new kind of class that comes with c plus plus 23 this is called a generator this is probably not that well known today but it's actually missing piece from c plus 20 where co routines came into the language we had no language no library support for core routines and the generator is probably one that will be maybe the the most popular one what the generator is isn't type that represents a range and this is sitting in front of a core routine that will generate the individual elements of this range that you can iterate over i don't want to go more into detail this is not something that the time allows here right now but i start here with is a function called infinitive infinite path source that takes this given directory and it will as the name implies an infinite stream of file system paths and with infinite i really mean infinite you can't get a size out of it you don't have an end and meaningful and and irreferenceable and so you there's no chance to store the contents of this function into a collection the only thing that you can do is to lazily execute the file paths generated by this function by iterating over the sequence and i can't actually put it into a pipeline of ranges use but if seen yesterday in the keynote by nico here i take advantage of these use first i filter by looking at the extension of these files if it's a good chance to actually think that the contents might be achieved in the next step i will take the filter to view and try to get a lip av file object that represents each of these given paths that have survived the filter operation before by trying to open it as a chip file and in the second transform stage i will take in open flip av files and try to find a decoder for the contents of this file what i get out of this pre-processing stream is pair of files and decoders for each of these pre-processed media files if we actually have a decoder that's been created by this view pipeline i will print a nice lock message onto the console this is yet another new function from c plus plus 23 no mercy out and then i will yield all of the elements that come out of the decoding process from decoding this pair of files and decoders if there is no such decoder because maybe the contents haven't been a chip file or the file extension wasn't correct or whatever it may be i just will send out a filler frame as seen before what we have here the whole function as shown here on the on the slide is itself once again an infinite range now it's an infinite range of decoded video frames if you look at the pieces in the in the view pipeline the filter is done by this has extension function which happens to be a compile time function as seen before this function here doesn't generate any code it's executed and exists only at compile time and what it does it yields a constructed closure object out of the lambda expression here and because of that taking inner string view is perfectly safe despite the reference semantics of string use because the arguments have to leave for the whole lifetime of the program this openness shift transform takes in the path and returns and lib av file as i mentioned before by trying to opening such a file from debuff and creating a lip av file object out of it and in the next stage it will look at the contents of the lip av file and check out if the content is actually really a gif file what you see here this particular construct is what steve abrahams is referring to as come on how do you call it functional modification you see on the left hand side and the right hand side you have the the same variable that it's just passed through this except only to function here that comes with value types quite handy and here we have it it takes the live av file returns a lib a b file and it's looking at the contents of the data stream it has to be a video stream and it also has to be of type gif and if this test fails we just close the file and drop it on the floor and move on with the next file [music] opening the video decoder is just the same we associate lib av file object within within decoder if the actual content is really a file a video stream and not only a still image and then you can try to construct and open a decoder and pass it on to the next stage in our processing pipeline here which is this decode frame function takes this pair of file and decoder and itself will generate video frames and returns a generator object in this particular case this is no longer an in an infinite range in this case it's a finite range after acquiring some assets the actual decoding process can start and as long as we are not at the end of the file content and we actually can successfully read data out of the file we can send the data packet red to the decoder try to receive a decoded video frame and if this is successful we can yield a fully decoded video frame according to our frame header and and pixel format structure out of the result from the receive frame and the lip av decoding process what we see here are two nested while function while loops without all the craft that you usually see if you look at examples from lip av file decoding this is not too difficult in fact this is a more or less textbook implementation what do you find in signal processing multi rate signal processing all this kind of stuff it's just as you learn it at university or some other language so educational sources the problem here the results of the video decoding process can be obtained and must be obtained a diverse possible place you can obtain results it's on the innermost scope of this loop nest here what can you do if you don't have core routines to return the results of this decoding process you've actually one choice that comes immediately to mind you pass in a callback and you can call the callback with the decoded video frame but this comes at a very very high price you actually give up control over your stack you have no more control about what's going on on the other side of the callable that you pass in here to pass out the the decoded video frames this is something that you can't do in in an industrial context this is just not possible and the other option is and this is usually refer to in the textbooks oh dealing with this kind of problem is something that you can do by yourself what you actually have to do is you need to invert the control flow and implement a state machine so that the the result of the decoding process can actually be passed out of the function by the return channel and not everybody is happy about implementing state machines and reversing control flow disco routines come in extremely handy here returning the results by co-yield gives us the benefit of the compiler providing us the inversion of control flow and the state machine just for free how nice is that and finally let's look at the infinite half source function it itself now a generator if you compare it to the code i've been showing at the cpv con in the github repository you will notice i'm no longer using an iterator here iterators can be used for this purpose just as well now i've i've turned it into a generator which is a method to represent infinite ranges and just be by doing that i got rid of the distributed state machine to implement this infinite generation of of file system paths and also decode became much shorter it's just a fifth of the original code before and it's pretty straightforward to code it's actually just an a for loop which never ends to iterating therefore it's an infinite range and as you can see here by the static asserts the generator type models the concept of a range and also the concept of a visible of a viewable range which means we can pass it into the view pipeline that you've seen before and this completes the whole video decoding kind of stuff if we recapitulate on the contents of this section of code i've been showing for the topics has been infinite ranges core routines and value types this this is the topic of this section here so we can actually check some of the specification i've been giving in the in the beginning let's move on to the next part networking as i mentioned before i'm working in an industrial context where every eye operation needs to be protected by a timeout we need something that they can used to start two operations at the same time and figuring out which one of these is the first one to complete so my example here is a read with a timeout decode shown the pseudocode takes a socket and the timer and as soon as we start a time to read the initiating functions from the underlying library will initiate operations in the operating system socket read and timer weight and then it will no longer take care about what's going on here until the operating system comes back and calling into our code possibly on a different thread 50 outcome of the operations hopefully with a successful read but in some cases this may not happen and the timeout will happen before usually it should happen after the return from the read operation the interesting thing here is if we bundle up these resources the socket and the timer into object composition composition-like thing we have to make sure that these objects live long enough for the callbacks from the operating system to actually call into a still existing object so we have shared ownership we have possibly multiple threats involved here so we need to take care of that and in addition to that in in this asynchronous world sometimes it may be that the original color of the times read operation is no longer interested in the result of this operation so we need some kind of stuff that we can notify this in these operations in flight oh i don't care anymore please cancel all all the outstanding operations the same is true if either one of these gets called back from the operating system then the other operations still in flight needs to be canceled here so this kind of stuff is not easy we have multi-freading we have concurrency we have shared ownership yeah yeah this is not really something that is for the faint at heart how can we improve on that if we look at in this particular case the aco functions we have two initiating operations the async region timer async white weight that takes the necessary resources and you have to additionally pass in the callback function and the scrollable object takes an error code to tell if we have success or if we have an disappointment here and possibly additional data and the interesting part is on the bottom of the screen we need to pass into for example if we implement it as lambdas also references to ourselves that immediately means we have to i have stuff that's allocated on the heap in the neck we can improve from that if we no longer have individual callback arguments but bundle them up into a tuple of this error code and possibly additional data and this gives us the benefit of dealing with just one object here that is being returned from the from the callback operations from the operating system and in particular in the next step we can turn them into or pack them into availables are from the core routine world this is the stuff that andrea's voice has been referring to and talking about in this talk yesterday this is the stuff that you can correlate on later on in this co-routine world if you look at the call site on the bottom we see with this oh what's going on here the call side is extremely simple you get what previously has been the arguments to the callback now out of the color weight expression and possibly can deconstruct it into individual entities again but the problem is now we have two co-await operations we cannot correlate in parallel as we all learned yesterday this co-routine kind of stuff is highly customizable we have lots of levers to pull and buttons to push to compose higher level operations out of these availables but if you happen to be a noob like i am i have no clue about core routines this is probably not something that i want to do by myself and asia doesn't let us down it actually provides now since a few versions uncomposing operator that takes in two of these availables and returns a single available with some type of the result types of each of these former availables here so if you look at the call side at the bottom code becomes really simple and easy to understand and easy to use just go wait on decomposed operation that initiates both the read and devoid at the same time actually it's the curve weight operation that does the that's the start of the of these operations on the execute framework if we look at the beginning example once again it would probably look more like this we have an enable shade from this once again this is on the heap we have usually neater callback to return the result out of this compost operation we have the callback functions here once again and this is strategic declaration we have no implementation here we have no calls out here space is just not enough and with all these functionality provided by the library and call routines we can actually implemented it with just one line of code how cool is that and now we have enough space to actually look at the call side and the member functions of this thing object the socket the timer and possibly also data is now moved into a function block scope and this is actually the best thing that can happen here if you have value types on the function block scope nobody else has access to them these are completely independent of everything else that is going on in your program the lifetime is completely determined these entities live until the end of the function and because each invocation of dysfunction has its own frame this is immediately scalable to multi-freading and you don't have to do anything to protect you against shared access or possible sharing that it might happen to have on the left hand side of the slide here and because of the guaranteed independence and lifetime you can actually correlate to a function that is completely nested within this function context and can this called coroutine time treat here can borrow the socket the timer and the data without having problems with whatever might be on the left hand side so you get all the good stuff and the benefits that you can reap out of using functions instead of objects using value types instead of yeah he allocated reference types and this is the reason why the developer of the seo library chris colhof is referring to this in his videos that are confined on youtube this is the reason why c plus plus 20 is the awesomest language for network programming with c plus 23 we can actually go a step further now i'm have implemented a flattened function that takes this variant out of the composed asynchronous operation and flattens the tuples in the variant into an expected type it also has this expected type has a success channel in this particular case it's a size t here and it has a disappointment error channel which is represented by an error code here in fact you can use any type that you like at this particular piece but the ac libraries is using this error code can a kind of thing for everything error related here and if you look at once again at the button of the code with the call site it's now even easier than it has been before you get an expected out of decomposed operation that has in one place the successful result or the reason for a failure here and this is the reason why i call c plus plus 23 the even more also must language for network programming how does it look like in practice okay as seen before the results are just tuples of an error code and then an optional additional type in here and the aci library provides us an option to to tell that we want everything every member function in sockets timers listeners this kind of stuff represented as tuples wrapped into availables and we want new types socket acceptor timer that by default uses co routine availables in the interface so that the use of these types is much easier than it has been before with if you look at the the reference documentation of the aco library this is particularly helpful and probably not that well known if you are using seo library or boost acu for the same and as shown before of our result type is an expected using it's based on the suit error code and it may return for example a size t if you transfer data or it can return a socket in case of a listener so now we can actually implement our networking primitives and this is just as simple and primitive we borrow a socket timer and and in the sand case a couple of buffers to send over the network and we get an available that represent expected of size this is just awaiting decomposed operation flattening it out and returning it to the caller the similar thing for receiving data from the network in this particular case we provide the buffer to our beyond we want our data to be filled into and we just get an available with an expected size as well and deferred operation is the connect it takes a bunch of endpoints that we want to possibly connect to other one will do and of course the protecting timer and the outcome is either something happened that we can't produce and can't connect or we get a socket out of it flattening operation is taking in a very end of either the first result or the second one and it will the calculated type of the success channel this is just one possible type here type identity will do we don't have two results strange tm template meta programming here it's just as easy as that and the variant will then be visited by a generic lambda with the active result tuple and this is mapped then onto an expected with the pre-computed return type and if we happen to have a disappointment or we can't produce a result because of a timeout we pass it through the error channel of the expected otherwise we pass the computer type through the result channel of the expected we also have a function that we can take any kind of object and demote this object into a a span of constant bytes that make up the object representation of this given object and pass it on to the ac library as a buffer so what we have now it's a couple of primitives for sending data receiving data over the network and connecting to server endpoints these are the three basic networking operations that we need to communicate over networks but this is only half of asynchronous networking we need something that we can operate on and schedule our asynchronous operations on and here comes a new kind of thing into play executors it's kind of a thing that members of the committee are probably not that happy to talk about because we still don't get executors in c plus plus 23 but seo implements executors in particular the executors has been specified in the networking ts in particular proposal po443 but i will not talk about executive either not at all aco actually has something better than executors it has execute contexts this is a high level abstraction that is sitting on top of executors and it's actually the primary interface for interfacing with the client code i don't want to talk about this either except for one thing these execution contexts of acu gives us the option to augment them with user definable services on top of those that are actually provided by acl and what i will provide here is a stop service and a stop service will give us access to a stop source if you remember in yesterday's keynote by nico where we have the your suit is threats and one of the good things that come with these jay frets are these stop sources and so what i do here is make these execution contexts quite similar in functionality to j threads jay frets have an implicit stop saws that are part of the favorite and this augmented execution context is also providing access to a stop source and because of that now we have means to do remote control termination of asynchronous operations because everywhere where you're using these asynchronous primitives you also have access to a stop source and can react on if somebody in the application is requesting a stop so let's look at a little bit of code here this is the implementation of such a stop service with lots of bale boilerplate this is probably not that much known for users to acu but the interesting thing is it wraps and contains a stop source from the standard library you can add an existing object of a stop source to an existing executor you can pull it out again and on top of that i have a function here you can ask an object for the related stop source by getting the stop source out of the ox execution context that is related to the given object and what does that mean this get context kind of thing takes any type of object and it's asking do you happen to be an execution context if so we're done otherwise hey do we have access to in context to an are you an executor for example are you derived from an executor or just an asia executor as it comes out of the library then you can ask the executor for the context or if it's just an aco related object like for example a socket do we have an executor then give me the executor and i can fill out the execution context and you can then pull out the stop source out of it and if none of these is true well let's complain a bit what you see here this if const expert leather implemented is something that is part of c plus plus 17 i don't know how many of you are familiar with this kind of stuff what's going on here only one of these if cons expert branches is actually not discarded and generates code or the false branches cost nothing in this implementation of the function body i was asked after giving the talk for the first time why do i tools it do it this way i had to have an if letter it's just kind of an overload kind of thing why don't you use overloading yeah and the answer is simple the predicates i'm using here is execution context is executor has executed are not mutually exclusive so depending on the type that you're passing in here more than one overload may actually be viable and this is the reason why i'm using this const expert it is if contact letter to partition the set of possible types at as function arguments into exactly the kind of thing that i want to deal of reason on and and generate code on and all of that is just the underpinning of this most important function here in the executor section of the code this is the abode function if we think back to the beginning of the asynchronous composed operations we need something to abort operations if we're no longer interested in the outcome and the results and what this abode function does it takes in a couple of objects at least one and it will return a stop callback this is an object type from the standard library it will listen on a stop source and as soon as the stops us is requesting a stop it will execute the call operator of the lambda that i'm showing here and the and the the body of the function call of this lambda expression is unfold over the comma operator invoking an underscore abort operation on each of these objects passed in here and each of these abort operations that are executed in sequence as soon as the stops us signaling a stop request is yet another of these const export letters that are inspecting the type of the given object here if for example it works to call a function called close on the given object we will do that and on top of that this is a function that can be found by argument dependent lookup so you can customize your own objects executing on an on an execution context just like you need to and if you don't have a free function called close we can ask the object do we have a member function close or do we have a council member function we're happy with that as well and if none of this works yeah we need to complain another time so what we have now is something that can listen to stop sources that come with the execution context of our asynchronous execution framework what you now need is the other part some means to actually schedule operations on the execution framework so let's make a scheduler it takes in an execution context and an existing subsource will add desktop source to the execution context and then it will return a closer closure from the lambda expressions shown here and the call operator of this lambda expression takes in a piece of work and some arguments that come with this piece of work and it will one try to figure out has this piece of work to be executed asynchronously if so pass it on for execution on the asynchronous execution framework if it needs to be executed synchronously we immediately invoke this piece of work and if none of these is true yeah another reason to complain so this is the other half that's missing has been missing to actually schedule work on the executors now everything is in place to actually implement our server it's just a simple function it takes an execution context a list of endpoints the directory that needs to be observed and for each of these endpoints it will schedule and accept connections function that is used and it takes an x and an acceptor that is listening on a given endpoint this acceptor is a by value function argument which means that you know can place a watchdog into the block the function block scope of this function here actually it's a task implemented by a core routine that is taking care of this acceptor and it will listen on to you on the stop source that's coming in through the execution context and as soon as somebody is requesting a stop this watchdog here will fire and close the acceptor as long as the acceptor is open we accept incoming connections and if we get a socket out of it then they can create another asynchronous task that will stream the videos to the client just the same here again the stream video takes in the circuit by value it creates a timer and now we have two entities here that need to take care of and the support operation will close the socket and the timer as soon as the stop is requested we have a new kind of thing here this is a similar to a starting gate at a horse race and this range base for loop is the other end of this make a frame thing that you have been seen before this make frame function as we remember returns a generator that represents an infinite range and here we are iterating over this infinite range and we get on each iteration step a frame out of it and with this starting gate we can wait for the correct time point to send it out over the network if anything goes wrong this task will close and everything will fold back this is the whole server he had to speak starting gate is just another case of returning a closure that prepares a timer for us to look at the at the time information in the video frame and wait foreign foreign timer and then returning the available out of it so what you have here at this point so we have a stage the stage is the execution context the x the asynchronous execution framework it has the stop service and we say schedule the piece of work called serve these endpoints using a given set of assets in this particular case the path to the directory and this will spawn a couple of tasks on this execution framework on my machine this is two acceptors one for each endpoint and as soon as a client connects it will create connection tasks that will strip the data out to the client now to the client side very similar similar another task show videos on it's operating on the context it takes in a gui window now and a set of endpoints that are available to connect to our server we try to connect to the server any endpoint will do and as soon as this succeeds we passed the socket the timer and the window on to the actual task that will present the videos on the screen if anything goes wrong we arrive here and now we can pull the stop source out of our execution context and the request to stop because we are no longer interested in further running the code our tasks to receive data from the network and present it on the gui is here it takes the circuit timer the window and once again we place a watchdog here and on top of that we have a memory resource that adapts to the amount of data we need to allocate to actually pull in the pixels that make the contents of a video frame and as long as the socket is open we can receive frames from the network connections into [music] the memory resource and if we actually got a valid video frame we can adapt the gui window resize for example and present the contents the pixels onto the screen and on each receive frame we will lock what we received onto the terminal to figure out what's going on your try to receive a single frame it can ever either be evolve on frame with swiss lip content without visible contents for example these filler frames that i've been talking before or it can be no frame at all as a placeholder if something goes wrong so to receive a video frame from the network we borrow a socket a timer and this memory resource and the first thing we have to do to receive the video frame header and how do we do that we have a range of bytes correctly aligned of the correct size and try to receive this amount of bytes from the network what we get is just bytes if it's the correct size and we actually got something we can now and must now start the lifetime of an object that is represented by the bytes that you have received from the network this is different from what we know from c in c plus plus you need to make sure that we access objects within their lifetime and if we receive just a bunch of bites from wherever we don't have an object within its lifetime delay we have the bytes but we have no no object yet and this is the reason why we added in c plus 23 a new library function called start lifetime s and we pass in a pointer to the underlying bytes and ask for a particular type of object to then be used after we have started its lifetime and this is the reason why in the beginning i was looking for something that is trivial and has a trivial destructor and these two things are in this particular case enough to make this type of an implicit lifetime type so that i can invoke this standard library function on it and get a valid object out of it so i get a header can't ask for the amount of pixels that are represented by this header ask the memory resource for the correct amount of data to receive the pixels in there if we actually need to receive pixels we can receive it from the network if any everything goes goes right we get hopefully the correct amount of data or if we happen to have an error in our expected we just drop everything on the floor and at this point if we actually got a valid amount of pixels we can reconstruct a video frame and return it to the caller otherwise yeah we just say we have no picture for you today and this is the hall client the next part digui we're using the sdl library frap dc types into proper value types by the wrapper that i've been showing before and yeah we need to represent the dimensions of something just the width and the height and now we can in typical object-oriented manner model our video frame within a constructor and the already mentioned member functions update from the particular properties of the header and the 370 pixels on there it has a couple of member objects here nothing too fancy but now we're using these value types from the scl library to compose our gui window here the constructor is more or less uninteresting here but the update frame function member function takes in the header information looks at the header and figures out if it's the actually the first frame in a sequence and if so it looks for does it have pixels in there if not we hide the window and destroy the texture object where the d pickles would be presented later on otherwise yep we store some of these meta information figure out the source format the byte order ndp and the color ordering here create a texture to to present the the decoded video on there and show the window in the end now they can present the pixels by asking for mapping detector that is living on the video memory into the cpu memory put it over there and present it in the end and lastly we need to drive the events that come from the underlying operating system for example the the window messages on on windows or whatever it is implemented on the on linux or macro this is everything that is it needs to be pulled from time to time and if the user is clicking on the close button it will tell no we are no longer interested in further execution here if you look at the specification there has been a part about handle input from users if they are no longer interested in looking at the videos this input can come from the terminal and what we do here is listening to signals in this particular case aco is providing us something that can wait for a thick end or a thick term signal coming from the operating system once again we have the watchdog and it's awaiting for one of these signals to arrive and as soon as it does we request a stop of the application the same from the gui we have a timer to pull the event queue of the underlying gui framework of the operating system and as soon as a close event is signaled we request the stop again now we have all pieces together to actually implement the whole application this is the main function takes in parameters from the command line creates this other endpoints by resolving the name of the server on the port to endpoints for example ip4 v4 addresses ipv6 addresses whatever it is resolved to we have our execution context here we have our stop source we can make our scheduler and we can schedule starting the server on these endpoints with the given media directory and we can also schedule declined that is receiving the data and showing it on the window and we can schedule handling events from the terminal and we can schedule handling events from the gui if you want to you could split this into an into a part that is only handling the server you can split it into something that is only handling the client and as we've seen nothing is shared here we can actually schedule multiple of these this immediately scales out to us many instances of anything that you have resources for because what you've created here this is the whole picture now on this stage are the acceptors from the server the connections we have the video player we have the handler for determinal events we have the handler for the gui events and all of these actors are listening to the stop source that's part of our execution framework so what you've seen so far generated from c plus 23 expected trend line stop source stop token stop callback spans ranges use concepts requires expressions core routines structured bindings fold expressions compile time decisions compile time functions compile time reflection in a very simple way value types strong types compiler generated closure types compilation generated state machines and this is this is the stuff that the whole application is composed from but there is one more aspect related to composition and this is source code composition let's look at domain cpt again yes the specification of the whole application but now becomes clear we are just importing the standard library actually this is pre-compiled pre-compiled and it's coming from a pmi cache in my case the same for the seo library executor and all the other pieces that i've been showing before each one of these is implemented as a module in fact besides the main translation unit here this main cpv function i have compiled within the project eight name modules 20 even the individual parts here i have one cross project header unit this is dc resource wrapper and have pre-compiled and taken from a cache four name modules for external libraries seo boost program options lip av and sdl and i have a modularized c plus 23 standard library this is compiled from the msvc open source and i have added generator implemented by one of the microsoft developers case recorder and an implementation of print and start lifetime as by myself in fact everything that c plus plus 20 has to offer in regards to modules is represented in this code at least one translation unit you don't need to look at the slide here in detail because i've been talking about this kind of stuff last year in my talk about modules but if you are looking into modules and one probably want to use it in your own code base this is a reference implementation of everything that could that you need to know or may want to know about modules there's everything in here for example there is one module called the whole kabul that is a module composed from pieces of our in-house code base it has just two functions that are exported the full implementation is a private module fragment if you don't know what it is just look at my talk from last year and this is using and importing a third-party library in this particular case boost program options and this in turn will refer to a couple more boost headers and well at least 24 20 or more boost libraries i can't tell how many there actually are it's at least 24. and this makes clear using modules is much easier than including all the header files that come with these 24 boost libraries into your translation unit compile it once and just use it later on similar to the c library stl also implemented as a module in this particular case is a little bit more complicated it's a multi-part module and the sdl library is a static library in this particular case that is completely compiled in here it consists of a global module fragment with all the headers that need to live outside of the module ever has a module per view with the exported interfaces of the sdl and an implementation this is compiled separately with c semantics because this is what the scl library actually requires you can mix and match it in modules you're not limited to c plus code here and the problem with c libraries is that in many cases parts of the interface are implemented as macros and you can't export markers from name modules this is just not possible and it's kind of an irony i'm using macros to get rid of democracy by the use of a technique called x macros if you're not familiar with x macros just look up generative programming by andre alexandrescu and you will find more about these x macro kind of thing it's a useful technique it can be taken advantage of here and of course i have a module called stood this is simple just compile everything from this rendered library into one named module everything what that is in the specification in the tables with the c plus plus headers and the wrapped c headers and if you have been following for example a discussion in the standard committee about is it actually a good idea to put everything into one module the whole standard library in just one module doesn't this take too many resources or does it take too much time to use the standard library in in its whole yeah the results speak for itself here i did a measurement comparing what if i include all of these headers from the standard library or compare it how would it how long does it take to import it it's just about making the api available i'm not using anything from the library i'm just making it available how long does it take to do that using it the traditional include world or the new order of modules and i think it's quite clear why the committee decided to go with exactly one module for the whole library if you include everything on my machine takes roughly two seconds to make the whole api available and this is 122 000 lines with meaningful content after pre-processing and then i have two possible choices to make a module out of it either by re-exporting the whole standard library as a header unit this takes 50 milliseconds 15 milliseconds and the pmi is about 30 megabytes and if if i actually make it a proper name module the amount to import the amount of time to import the whole standard library becomes unmeasurable it's below the granularity of the time that i have and i think this is one of the best things of c plus 23. if you happen to have a compiler under library implementation that makes this possible you no longer have to figure out where do i find default operation over an container and learn now this is actually called accumulate in this word an algorithm but it's in the numeric header just import everything and you're done now let's head over to the compiler and check if dakota has been presenting to you the last hour or so if it actually compiles and does something meaningful i think the code is readable the size is okay good and this doesn't work here on this table too bad here we have decode again as seen before let's recompile it compiles all of the modules and the main function in release board here maybe it's a little bit too large on the screen huh let's run it oh come on this is opened over here the code has done something but where's the video you see accept connections at localhost on ipv6 accept connections on localhost and ipv4 but that's it hmm what's missing has anybody a clue exactly the only thing that's been coded here is scheduling work on the execution framework this execution framework needs a thread to execute on it's just an abstraction over the threads we have a thread at hand it's the main thread here so let's just add the missing piece compiling once again and run it [applause] if you're interested this is 800 lines of code so mouse doesn't work let's wrap up my conclusion of this experiment i think contemporary c plus plus is simple it's concise it's safe to use it is composable and it's enjoyable compiling this way makes so much more fun then everything i've done in the past here are some resources there are two videos put out by chris cornhof the author of the asia library why c plus plus 20 is the awesomest language for network programming and cancellation in depth my demo code can be found on github also the implementation of aco as a module stl as a module and also the standard library i've been using here where you can find me oops what's going on and with that i'm done with my talk i hope you enjoyed it [applause] i hope you enjoyed it and i'm ready to take questions if you have some hi thank you for the talk the question how how would you test such an application there are a lot of i o code would you test it with unit test component tests well parts of this code in particular networking code is actually in production at our company i've put it into our code base because it's so nice you need mocks of course you need mugs but actually this is not that difficult because the networking primitives are so simple implementing a mock is a piece of cake this is my answer to testing here and this is my experience and this is what we are doing in our company thank you and actually the mocks are just simple servers listening on the same network as you would probably do in production you can use the local connections and do anything with it hi i see that your demo runs on windows and msvc yes have you tried running it on another operating system or compiler and do you foresee some portability issues or something that's not entirely ready on other ecosystems so what i've been using here is 100 portable except for the stuff that is coming from our in-house code base in particular the options part of the command line but i think this is not nothing important here you can throw your own com ment light parser and everything else is portable i haven't tried to compile it on a different platform for one i'm a total new when it comes to linux i don't have a mac and the compilers like gcc and clang are not there to compile this code the same is true for the standard library provided with these compilers these libraries are not yet in a shape that that can be compiled as a module they are actively working on it and they make pretty decent process in the past couple of months but to get at this point that i've been showing here it's probably taking much more effort to actually compile it and make it available this is a sad story but this is how life goes microsoft is has been very keen on implementing modules because the benefits are so huge talk to any team at microsoft about what it gives an unperformance to use modules you will be surprised and the uptake as far as i know is quite good at the microsoft teams i don't disagree i just have clients on other platforms yep the answer to the open source world is just the same as every time contribute implement the compiler and the modules implementation yeah just kidding hi thank you for the impressive demo do you have any sources for documentation about the azure framework because i know the two videos from kiskov himself i hope they will continue the the story somewhere as or sometime and i sometimes when it find it a little bit difficult to go through the other documentation and the examples and understand how the the insights work so do you have any sources for other documentation book recommendations or something saudi reference implement is reference documentation of asia on on the website of criticalhof is not enough for you there's there's a lot of background information there and a lot of examples that you can look at i'm not programming c plus for so long and not i'm not so keen in c plus plus so for me i need sometimes a little bit more beginner friendly oh so this makes it very difficult well in this particular case i would recommend to use my primitives here thank you yeah i don't know what to answer everybody who is familiar with the acl library knows using it without these particular primitives is really challenging i don't know please a show of hands who is familiar with seo who likes it okay who likes the particular interface related to pre-core routines okay okay thank you you're welcome you've painted a very nice rosy picture so far and i'm pretty sure there are some painful moments in the experience of riding can you share those painful moments and in writing this piece of code some difficult moment we had a difficult moment has to actually make acu into a module this was really challenging to the compiler and the first time that it's completely working is with the latest edition of visual studio compiler so that i can use it safely everything else was quite simple to implement the biggest part was googling for libraries that i can use here looking at examples that i can break in i actually made this c wrapper such that i could just take example code from maybe stack overflow or other sources on the internet and drop it into here and then read out all the stuff that is no longer required if you have value types so it was a breeze it if you remember i had 10 weeks of time to implement this and hardly any time that i could spend on working on this code i couldn't afford any problems with this code because the experiment would just have failed and i would have to go back hide under a rock remove myself from the c plus community and only program cobolt in the future so we actually do have an online question and i want to honor that we are still working with c plus 14 network due to safety standards cross compiler related limitations any thoughts on how to make best adventure how to take best advantage of at least some of these features best references and write better code 14. let me phrase my answer answer this way i'm terribly sorry that you're using c plus plus 14. a few pieces of this code here can be implemented with c plus plus 17. and of course if you throw out all of the module stuff and do ac or the old way you can actually implement this application but it's no fun really no fun you have to to all the inversion of control by yourself you have to implement state machines by yourself you have to get rid of all of the generators implement everything by iterators it's just no fun so again thank you for your talk my question would be with your the function you you mentioned begin lifetime as well i'm not sure the exact name is sad lifetime is thanks how does what do you do in a nutshell and how does it deal with potentially underlined bytes for the object that's trying to represent this is not on the plate of dysfunction you need to make sure that divides that you're providing are correctly aligned so that at this particular piece of memory there can the type of object that you want to start a lifetime of really safely and according to the language rules live this is the reason why i have this align s according to the requirements of the particular type and i have to make sure that the constructors and destructors are empty they don't do anything here this is the key to objects that you can start lifetime as using this particular special function this is nothing but a means to talk to the compiler take whatever is coming in here and pretend you have constructed it yourself it's just you're talking to the compiler you don't execute any code here you can achieve just the same in this particular case with pre-c plus 23 code if you do a placement queue it's exactly the same exchange data between yeah i think this function start lifetime as is really important in many parts of existing code this is probably suffering from ub many people say okay you can do type earning using unions or you can do a reinterpret costs but none of these actually start a lifetime of an object if you're referring to the objects with these kind of techniques that have been for example reinterpret cast you immediately have undefined behavior in your code and a compiler who notices that could actually do anything different behavior here what platform are you working on what platform are you developing on so you have to sanitize this randy ub sanitizer and it should tell you oh sorry no picture for you today thanks again welcome interesting online curious simple question do the available debugger support core routines properly or is it much harder to debug the caller code i can only speak of t microsoft visual studio debugger and it has no problems at all debugging call routines okay thank you for your great keynote and the online audience requested that you may want to join them later in the libido launch i would like to give you some you know time for having lunch and recovering but let me know when when you would be available for questions online i have to figure out how to do that but maybe i can do it okay [applause]