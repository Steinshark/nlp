and you've been doing a lot of oh camo recently and i've just started doing okay i've solved advent of code day one through three and i'm just starting to play around with spawning a child process reading its standard out doing doing the lsp tools i'm going to do that little lsp debugging thing i'm just gonna do it all in all camel i decided i just want to be able to take files and pipe it in and just have a nice view into what's happening as opposed to trying to read those actual files which are all really long and kind of annoying to read and so because you know i'm using structured logging with rust and so it just makes it really simple and so i have some initial thoughts of oh camel but you've been doing it a bit longer so i'd like to hear some of your thoughts about it and what are some of the struggles you had in learning oh camel or commonly referred to in this community as toe camel interesting token well that's a new one i'm not familiar with the distribution yeah so my so the first thing is i think obviously i think this is kind of obvious for everyone who tries it at first two it's their first one of like an ml style is that it's just sitting on your lap for this part is that like the syntax is very different and so for some people that's going to be pretty off-putting right for like the first time that they they use it so i think that that's probably like the first thought off the rip but i'd be interested to know what your thought of the syntax is after trying a little bit trying it a little bit because like i like it now so so the syntax really hasn't caught me too much it's more like you know they say like when you're learning a new language i've never learned a new language by the way but they say when you're learning a new language that you still dream in the language you knew and when you speak you do this like translation in your head you take in the language you know and then translate it into the thoughts and in the other language and then that's like kind of how you have to do this translation mechanism i'm still in the translation mechanism category where i co camp and i relate it to a language i understand and so it's like i'm constantly doing this relation game which is okay which is the part of any learning experience but at the same time because i'm not quite fluent in it things feel foreign though i really do mostly get it like it feels easy to learn obviously i'm still a little bit worried about doing like string concatenation versus adding two numbers versus adding a float versus adding whatever right i know that there's like some uniformity and type in inference that is super cool but that's kind of like my first take on on the syntax which is it's virtually no different and you can still do procedural if you wanted to right like there's still while loops which i think is great yes so so that's sort of like after the initial impressions with oh camel and like literally the first time maybe that you read an ml style syntax i think some of the good stuff about it is you start seeing like oh i don't have to write types for anything because it has real type inference and it's really good real-time inference not type definition inference which is different yeah not just making up new types so the difference is that there's always only one type for everything like everything always only has one type which is not the same thing as like typescript just says like we can figure out all the types that this thing could be kind of because it like whatever whatever it means when like there's an annie somewhere in the mix yep but but so so i think like that part feels really good and and is really really nice i think the and like the type system itself is is good i think it feels sound and the way that you do it feels really sturdy like you write something and then you feel pretty good that it's going to work very similar to the feeling that you get when you write rust i think right where you feel like oh it compiled and my types are correct i mean except when you have magic numbers which i saw when you were doing last night you were had some magic numbers problems to solve for the advent of code but yeah yeah okay so the thing that i wrote let me jump in there on the inference let's go back and forth on these you'll lead it i'll do the i'll do the thing i really like the inference so i've always been a very big hater of typescript inference i've always said hey i think that you're really using this language wrong and a big reason i'll explain a bit more why i say type definition inference versus type inference so in typescript when you return a grab bag of properties key values it actually creates a type in that moment and says your type is in this shape and the problem with that is that you didn't really there's no hard definition of it if you add a different return statement it just simply gets unions together it's this or this and it keeps on happening in this kind of way where it doesn't really guide you to write code in a way that produces consistent results instead it just allows you to do anything and when you want to change something it doesn't break at your return point it breaks at the usage point and that to me seems like a really bad kind of a trade-off and so that's why i all always always always just do return typing because i feel like i don't like definitions being created i want to be the one that creates the definitions and then says when types are being used and i feel like oh camel kind of does that so far as as far as i can tell is that it you have to kind of you have to obey type system in a certain way and you have to define when types are being used when you need some sort of complex type or it can infer the more simpler stuff yeah it can actually infer almost like in in practice practically like everything in terms of like day-to-day style coding things obviously there are cases where you're going to need to write stuff down and the reason that it can do that is because it can everything can always only have one type so you can't return string and number right or array of numbers or array of strings you have to return some type that could hold both of those as a variant right where you would have like a variant that says list of nums or list of strings and then you have to handle those on the downstream consumer you can't just like only do one of them right yeah tuples are fine to return but the tuples will all have the same type yep which could have like a type they're called type holes right so it could be like i know that it's going to be a tuple with like length two right but they could both be sort of like generics is how you think about it in a different language right like yeah over types right yes parametrics yeah you're already literally turning into like a functional nerd you're like wow i gotta use these big long words to explain this nice i you know i it's actually a super cool concept i don't quite get it and then the module level polymorphism that was going on with a maps obviously a big hurdle the first time you see it because it feels super excusing but yes i think i think i'm like i'm drawing pictures now which i think are drawing boxes which i think is the step one to any learning process all right what's the next thing enough with this inference business yeah so the next part that i've felt so far that feels good as a result of the inference is that when you want to refactor something it feels very easy because if you basically have inference like all the way through these things then if you have a bunch of intermediate levels of stuff right then you don't have to change those just because you change the type at the top is this because of a what's called parametric polymorphism yes it is right so it's like if you had if if in rust right i changed the like type of something right and i want to change the return type of something from like a to b now i have to go to all the places that like relied on this function returning a even if i don't use a right i'm just literally like passing it through everywhere i'm actually not doing anything with a i'm just passing it through now you have to go fix all those which is extra worse if now b also has a lifetime yeah yeah yes yes okay so i'm totally on that team where when you when you make changes in rust when you do refactoring the same same goes with typescript to a similar extent which is when you make changes you have this really really really like long kind of refactor chain that's going on yeah it can be a little bit tricky people are saying your mic's a little a little goofy i turned it down just a touch i don't know it could also just be discord sucks discord sucks for sure but you sound a little bit clearer but yes discord is okay totally ruining this i really like that i really like that take because you know with typescript you do a lot of these programmatic types right you define a type and then you define like this programmatic mapping doing key of type of and grabbing things and and when you change that all of a sudden it's like this this huge kind of wave through your program just like rust with a lifetime that's exceptionally difficult whereas i love this idea of of parametric polymorphism is that what you call it yeah i love that idea because then your types they type they go from like it's not even top down right there's like there's definition points based on like operators used and stuff like that and then those points are like the key points that kind of everything else can just flow through as various versions i love that yeah so so that's sort of like a result of inference and like alongside that the other thing that i enjoy is that it's still garbage collected but it's pretty fast for garbage collected language right so then i don't have to think about lifetimes which tends to make it like simpler to get stuff done i mean i think that that is in general like objectively true probably that if you don't have to think about it for most cases then it's just simpler to make it happen like i want to pass around a callback that's actually easy to do yeah great example i can never figure out whether i'm supposed to use fn fn once fn mute oh it's actually not fm you're passing a closure all these asyn closures don't have to say and you're like oh no i just i can't you need to mutate something and it's like boom fn mute and then it's just like it that the mute also because it's like a type it spreads the exact same list which is very interesting like i love the idea of specifying mutations but it also is leaky it's just like it just grows outwards so and we've talked a little bit about where i see like some of the future of okmul potentially going with the work that's been done like being done by jane street and others right with this idea that maybe there will be parts of the language where you can opt in to effectively no garbage collection right because you're going to be able to just stack put these on like a data stack and they'll get allocated and deallocated like without having to do garbage collection right so that's so that's like a big win in terms of where i see the future of okamo going which makes me happy like i like where it's looking yeah which is a good feeling to have even if that doesn't land say for five years right you're like oh maybe it's not gonna land for five years well that's okay like i at least like the direction is something i like that makes me happy comparatively to thinking oh we're just gonna have c plus plus 37 and like proliferation of new features that i can't keep up with right so that that's maybe somewhat different yeah yeah the i always believe c plus plus best way to describe it is that features continue until morale improves right like yeah is that we do well i felt like it should have done better it did not it did horrible which is surprising because it's amazing all right well i i like this oh camel talk i'm very excited here's like here's to month two i'm only like 10 hours into actual programming of vocamo but i love it yes nice i'm making you a site in oak camel so soon you'll be able to have something real to do with okay well which will be fun yes no i like that there's still a lot of mystery when it comes to oh camo but i'm excited about it i'm excited yeah all right hey tj where can people find you at they can find me right now on twitch.tv slash teach underscore tv facts