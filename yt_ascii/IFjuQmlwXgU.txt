welcome back to mcoding. i'm james murphy. if you had to pick, what would you say 
 is your most disliked dunder method in python? maybe dunder new and all of the 
 metaclass glory that goes with that? or maybe you've seen my video about 
 plus equals and don't like the in-place methods? or hey, nobody likes taking the 
 time to write a wrapper, maybe that's it? well, i've got a different choice. one that's so disliked in the python community that if you so much as ask 
 what it does on stack overflow, you will be inundated with 
 comments telling you not to use it. what dunder is it that could 
 possibly harbor this much hate? it's none other than dunder del. so, in this video, let's check out `__del__`. see what it's supposed to do, 
 hone in on some of those pitfalls. and, of course, see some 
 more robust alternatives at the end. first up, how does `__del__` relate to the `del` keyword?   well, there are three ways 
 that you can use the `del` keyword. you can say `del x[something]`. and that usage corresponds 
 exactly to calling the `__delitem__` method. you can call it with `del x.something`. and that corresponds 
 exactly to the `__delattr__` method. finally, there's just `del x`, which 
 does not call the `__del__` method. this is our first hint 
 about why people don't like `del`. `__delitem__` and `__delattr__` are 
 very straightforward. nobody hates those. `str(x)` calls `__str__` `repr(x)` calls `__repr__` `len(x)` calls `__len__` but `del x` does not call `__del__`. but it kind of looks like it does. if i run this example, i see the `__del__` printout. but if i comment out `del x`, it still gets called. let's throw in some print statements at the start, just before we call `del`, and at the end, 
 so we see exactly when this `__del__` is being called. we see start, then just before 
 `del`, then the `__del__` printout, and then end. so, it seems like `del` is triggering `__del__`. when we comment out `__del__`, it appears 
 that it's getting called after the end of the function. so, is this like manual 
 versus explicit garbage collection? well, still no. if we create another variable `y` and assign it to `x`, then even if we manually delete `x`, we don't see the `__del__` 
 until after the end of the function. `__del__` is, of course, short for "delete." this function is supposed 
 to run before the object is deleted. but there's a big difference between the 
 object itself and the name that you assigned to it. every object in python has 
 what's called a reference count. the reference count tells you how 
 many things are referencing that object. assigning a name like `x` to point 
 to an object increases its reference count. if i create another 
 name like `y` for the same object, that also increases the reference count. so, what the `del` keyword is doing 
 here is actually just deleting the name `x`. this effectively just reduces the 
 reference count of the object by one. but we don't want to delete the 
 object if there are still things referencing it. so, `__del__` is actually supposed to 
 be run when the object's ref count hits zero. if we didn't have the `y` variable, then 
 `del x` here deletes the only reference to the object. so its ref count goes to 
 zero, and it should be deleted. that's why `del` sometimes calls `__del__`. but that's kind of just circumstantial. but even once you understand 
 that `del x` doesn't directly call `__del__`, there's still a lot of confusion around `__del__`. you might think that `__del__` 
 is a great place to put cleanup code. maybe i open up a file descriptor, and 
 then when nobody's using it anymore, close it. the main problem with this idea is that 
 the documentation for `__del__` explicitly states that it may just never be called. not a great property for cleanup code. the first reason `__del__` may never 
 be called is because of reference cycles. suppose i have an `x` and a `y`. maybe it's a tree structure, so `x` 
 has some children and `y` is one of them. then, i include a back 
 reference to `x` as the parent of `y`. so, `x`'s children have a reference to `y`, and then `y` has a reference back up to `x`. this is called a reference cycle. and when you have a reference cycle, it's 
 impossible for either of the ref counts of `x` or `y` to hit zero. even after this function returns. and it's 
 impossible to access `x` or `y` ever again because they were just local variables. their ref counts won't go to 
 zero because they're still referencing each other. furthermore, even if an 
 object's ref count hits zero, python explicitly states that that doesn't 
 guarantee the object's `__del__` is called at that time. now, in cpython, which is the 
 python that 99% of you are going to be using, cpython does call `__del__` 
 immediately when the ref count hits zero. and for reference cycles, there's a garbage collector 
 which periodically runs and detects these kinds of cycles. as long as the interpreter didn't flat-out crash, cpython does a really good job of 
 ensuring that the garbage collector runs and all of your objects' 
 `__del__` methods are called. but still, the docs insist 
 that this might not happen. so you can't really depend on it. oh, and by the way, since the time 
 that `__del__` is called isn't guaranteed, it's basically impossible for you to be able to 
 handle any errors that might propagate out of them. therefore, the interpreter just completely 
 ignores exceptions raised in a `__del__` method. it'll still print the traceback. but as you can see, it still ran the code afterward. oh yeah, and remember, if `__del__` is called at all, it might be called while 
 the interpreter is shutting down. this `__del__` tries to 
 dump some state into a json file. remember, exceptions get ignored if 
 anything goes wrong trying to open this file. and then, if python happens to wait until 
 the interpreter is shutting down to call this `__del__`, then this `json` module, which is a 
 global variable, may have already been deleted. in cpython, in practice, using 
 even a relatively oldish version like 3.7, i haven't actually run into this issue. but once again, the documentation 
 won't make any promises and says you need to watch out for this. what else could there possibly 
 be that's more confusing about `del`? with all the lack of promises 
 about even basic functionality, you wouldn't think `del` 
 would support that many features. but it actually purposefully supports 
 the idea of so-called resurrecting an object that's about to be deleted. let's say this `__del__` method is called because there are no more outside 
 accessible references to the `self` variable. well, we can just put `self` into a global variable. thereby increasing its 
 reference count back up to 1. of course, it's kind of your 
 own fault if you do something like this. but python guarantees you 
 are allowed to do this. if you increase the ref 
 count of an object inside `__del__`, then its memory won't be 
 reclaimed by the garbage collector. it will survive until another day. but you know they're not letting you get away 
 without throwing another curveball in there, right? if an object is resurrected, then when it dies again, its `__del__` method may 
 be called, or it might not be called. so, you also need to make sure that your 
 `__del__` doesn't do anything nasty if it gets called twice. i already mentioned that exceptions 
 from `__del__` get ignored, right? okay, so how about we just get to an example where it does something useful 
 and it should theoretically be okay to use? this class makes a temporary directory. when you create an instance, it 
 creates an actual temp file. you can manually call `remove` on it. or the file is removed when it's garbage collected. notice that the first time we 
 call `remove`, it sets `name` to `none`. this means that if `remove` 
 is called multiple times, either by the user or 
 by `__del__` being called multiple times, nothing will happen after the first time. we're definitely depending 
 here on cpython's unadvertised property that garbage collection will happen before shutdown. and it will happen early enough in 
 shutdown that this module, `shell_util`, will still exist. i'm definitely not confident given all those restrictions. but it does seem to work with the 
 current version of python that i'm using. so, if `__del__` is so finicky, 
 it might never get called, it might get called twice, it ignores 
 exceptions, globals might no longer exist. how am i supposed to reliably 
 clean up the resources used in my code? the most robust solution is to use a `with` statement. define `__enter__` and `__exit__` methods. and make sure that you call your 
 cleanup code in the `__exit__` method. then you can use the class like this. we just say `with`, we create a new instance as `d`. do whatever we need to do inside the `with` block. then when the `with` block is over, 
 python guarantees that the `remove` method is called. the behavior of the `with` statement 
 is much more precisely defined. and you can depend on it. this is slightly limiting though. we have to use the `with` statement. what if i don't know when 
 i want to delete my temp file? maybe i'm making a text editor. and i want to delete this temp file 
 whenever the user is not looking at it anymore. that might not be confinable to a `with` block. but certainly, if python has no more 
 references to the object, then it's fine to delete. if you really want to support cases 
 where you can't use `with` statements, there is another alternative. let's leave our `__enter__` and `__exit__` methods. we still want to encourage people 
 to do it the right way. go ahead and delete the `__del__`. then use the `weakref` module 
 to create a finalizer for our object. we can manually 
 call the finalizer in our `remove` method. it's even fine to call it multiple times. we can also check if a finalizer has 
 already run by checking its `alive` property. a finalizer does have some 
 of the same pitfalls as `__del__`. in particular, they have the 
 same exception-ignoring behavior. however, python makes much stronger 
 guarantees that finalizers will run and when they'll run. in particular, when the interpreter shuts down, all remaining finalizers that are still alive and haven't been disabled will be called. and they'll be called in the 
 reverse order that they were created in. it's also guaranteed that these 
 finalizers will run early in the shutdown process, before any global variables 
 like modules have been deleted. and, of course, by design, finalizers 
 are allowed to be called multiple times. and their effects will only happen the 
 first time they're called. this makes them a more robust and dependable solution compared to 
`__del__` when you can't use a `with` statement. i didn't really say much about 
 what weak references are. normal references, like 
 assigning the name `x` to a variable, increase the reference count. those are called strong references. and they would keep 
 the object from being garbage collected. but we obviously don't want the finalizer 
 of our object to keep it from being garbage collected. its whole purpose is to run 
 right before the object is garbage collected. so, it's actually possible 
 to create so-called weak references that don't increase the reference count 
 and don't prevent it from being garbage collected. if you want to hear more about 
 them, make sure to leave a comment. that's all i've got. see you in the next one. and don't forget to slap that 
 like button an odd number of times.