it's amazing how easy it is to take the process of converting source code to machine code for granted we invoke the compiler and out pops our binary that we can run and not really think about it but if you want to improve our skills as a developer it is crucial that we understand the steps that get our code for being human readable to a place where the computer can execute it the topics we're going to discuss today are each extremely complicated in their own right but by spending 10 minutes a day on each one of these topics you can over time become a 10x developer without even thinking about it in this video we're going to discuss the idea of compilers executable file formats and how we get that executable off the disk loaded into ram and executing on our computer and before we start some of you here may be brand new to computer science maybe you've written zero lines of code what if i told you there's a way that you could learn computer science that was free and easy that didn't break the bank and did not cost thousands of dollars the sponsor of today's video is brilliant.org brilliant is the best way to learn data science math and computer science interactively my favorite part about brilliant is that it's not a boring lecture series where you sit there for an hour and watch a video and then take a test afterward the content is bite size it allows you to learn as you go if you're not sure where to start with programming if you're new here the new thinking and code course gets you designing real world programs that solve real world problems and after watching this video you can go to my url www.brilliant.org the level learning for a free 30-day trial and 20 off your first annual subscription thanks again brilliant for sponsoring this video and it all starts by picking a programming language at the end of the day computers can only understand machine code the ones and zeros that correspond to specific transistors in the hardware of the cpu that make the cpu do things now we could crack open the intel assembly manual and write the binary by hand ourselves this is entirely possible but crazy no one in their right mind would do this except for maybe this guy if we make a simple mistake in our binary and miss a single bit we could accidentally flip the entire logic of our program from a jump if to a jump not it to fix this we have programming languages a code that is more human readable than the machine code that eventually becomes a machine code that our cpu can understand but there's a problem we tried to feed the source code directly into the cpu the cpu would have no idea what we're talking about the cpu does not speak our english-like language and would not be able to run our code so we need a tool that will convert our human code into the machine code for us hence compilers compilers take our human-like code c for example and convert it into the ones and zeros the cpu knows how to run this is done in a roughly three stage process flexing parsing and co-generation in the lexing stage the compiler takes our strings and turns them into tokens each token representing a different part of the expression also during the lexical analysis the compiler makes sure that our code adheres to the grammar of the language here for example int xx is not valid c code once all of our code has been converted into tokens the compiling moves to the next stage of parsing the tokens are parsed into a structure known as an abstract syntax tree where the tree represents the functional nature of our program in terms of what it is actually meant to execute as a series of tokenized expression now certain compilers like llvm for example may convert our code into what is called an intermediate representation or an ir an ir is a universal assembly language that is meant to represent the features of a cpu without adhering to a specific computer architecture once our ir has been generated we move on to code generation where the compiler outputs the specific cpu target machine code for our processor in this case intel assembly but the compiler can't just output a binary blob it has to output a format that the operating system knows how to interpret which brings us to our next topic executable file formats when we run the code that we write a lot goes on under the hood for example we may have to link in external libraries like lib c or we may have to handle uninitialized variables that go into a particular area of memory all of these things have to be stored in a way that the operating system knows how to deal with them otherwise our code will not function to handle this the compiler has to know what format to put our code into so that the operating system and the compiler get along in this video we're talking about the executable linkable format better known as the elf the file format that linux uses for its executables now the elf has a lot of features but the ones we're going to talk about are the elf header the elf segments and the elf sections the elf header is pretty simple it just specifies that this is a file format of an elf and describes a few things like the number of segments and sections the most important part of the elf are the segments here your text segment where your code lives in your program is readable and executable and here your data segment or predefined data goes is readable and writable but not executable each of these give the kernel specific information about how to load our compiled code into memory this elf format is used by the kernel to load the program correctly into memory it is extremely important that your segments are formatted correctly otherwise the kernel won't load your program into memory all of this is stored in the elf format once the compiler has produced this file we arrive at the final stage of the process and arguably one of the most complicated executing the program now the finale we've all waited for this moment we get to run our program how amazing well let's take a step back it gets pretty complicated pretty fast to start the parent process needs to inform the operating system that it wants to run your program now you may be thinking wait a minute of the parent process what is that i only wrote this piece of code here not the parent when you run a program every program needs to have a parent process the process that told the kernel that it wants to run your program when you run your program on the command line you run it in a shell sh sh is the parent of that process because sh told the kernel that your program needs to be ran the parent program in linux for example will inform the operating system system that it wants to run your program by invoking what is called a syscall in linux exec ee the exec vesus call will take as parameters the program path and the arguments to the program that you wrote the system call is a way to alert the kernel hey i want to run this program and the action of running a program is a function that only the kernel can do in its privileged environment a privilege that you don't have as the user when the kernel gets this signal to run your program it does a few really important things first the kernel will take your elf and try to identify three locations in the elf the text segment again where the code lives the data segment where the data lives it's already been initialized in the bss segment data that lives in your elf but has not been initialized yet any variable basically that has the number zero at default will be put into the bss the kernel allocates all of these segments in memory based off of the metadata in the elf format that your compiler emitted before but there is one more very important segment that we did not talk about pt interp yeah so plot twist when you run a program in linux you actually end up running two programs your program gets loaded by the kernel but the kernel looks into your elf and looks for a thing called the loader for your program remember how i said before that your program may depend on external libraries or things like that that needed to be loaded in at runtime for your program to work properly the kernel brings in a program called the dynamic linker that runs alongside your program when it starts the dynamic linker then goes through and parses your elf and tries to find all of the symbols that have not been resolved that need external linkage for example in c in linux if your code depends on libc the dynamic linker that comes with your program when it gets executed by the kernel will go around and look for liv c and try to populate all of your entries in your global offset table before the program runs once the dynamic linker has gone through and found all of the resolutions for your program it will eventually pass off code control to your program and your code gets to run by executing your start symbol amazing we've gotten to the end wow what an adventure i am exhausted i'm also sweating my ass off because i'm in a different studio that's not in my house and i have my lights up too bright the world of programming is amazing many a deep rabbit hole but each one of these topics we talked about is a way that if you just spend 10 minutes a day learning a new little thing about that topic you'll become a next level programmer now before you go if you want to figure out how nasa writes space proof code code that doesn't crash in space check this video out