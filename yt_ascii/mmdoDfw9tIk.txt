all right gooden morgan v gates that's about the well i have a bit more german than that but i won't attempt to do this in german i'm not that i'm not that talented i'm kevin carpenter we're going to be talking about tooling intuition my day job i write credit card software so when you swipe your credit card i have software that answers it if you're in the us my code is not especially complicated you know it has things that are old and new and we won't be looking at the code in this one in this particular talk but just a little bit about me and what i do for the day job this is a back to basics talk and so i'm going to jokingly say if you were in the quiz last night and you understood a lot of that then you might prefer randomness or something because this is going over the goal of the talk is you know i was thinking about how i started doing bugs you know you you're coding something and something comes up and how do you end up figuring out what that is and how do we build about that so tooling intuition so of course when i started doing the talk you know i know intuition is for me but then i'm like all right well i need to look up and get the definition for it and you know the ability to understand something immediately without the need for conscious reasoning you know that kind of aha moment you look at something you're like oh that's what that is you know and i wish i had a lot more of that and so that was like i said i'm going how do i build on that you know we shall allow our intuition to guide us and i think that's i think we all end up doing that a lot when we're writing code and so i wanted to delve into that more so as i turned around and googled intuition of course i ended up seeing this little graph and it's small for a reason and so you know being google and being a developer does anybody get this reference the squirrel is this more of an americ thing it's like we say squirrel and oh look at that it's shiny so i clicked on the graph and i'm like okay so intuition is going all the way back to the'00s which i figured but then i'm like i noticed there's at least three points on this graph that are kind of tall so i'm started going well when was intuition used and so we'll start with'77 and so if you google intuition for'77 it came up with several points but intuition is that function of intelligence by which an object presented by the mind itself is apprehended so like i was saying that aha moment you turn around you look at something and and you see it and it just you know you know that's what it is right but then i'm like how did we get that many hits for'77 and as it turns out i found you know as i followed down this chain william david ross father of institutional or intuitionism which i didn't know was actually a thing he talks about the fact of you know knowing something in the same way his particular view is more of a moral sense but the part that i found interesting about this quote was the non-empirical or priori knowledge you know that idea that you didn't have prior knowledge about it and i i don't know that i agree with that because intuition is something that's built on i think based on our experiences but it was still you know an interesting point and evidently his particular book that he wrote did have intuition listed 741 times out of 641 pages so i think for'77 he probably you know was one of the first people that ever google stuffed keywords you know but now this is much earlier but since i'm in germany emanuel kant the mere form of intuition without substance is in in itself no object but merely formal condition of an object as phenomena as pure space and pure time how many of you love templates oh okay a few a few that's fair to me this was like trying to parse a template error as i heard that i'm like okay but then he had thoughts without content or void intuition without concepts as blind and i mean that's kind of deep and but i was good with that but his favorite quote that he had that i took which really doesn't have much to do with intuition is rules for happiness something to do someone to love and something to hope for so i just had to throw that in there so we go up to 1967 our next point on the graph so googling intuition there the major role of intuition is to provide a conceptual foundation that suggests direction which new research research should take raymond l wilder so if i replace the word research with debugging that's probably what i spend most of my day doing and so i i i thought that that pointed well to it raymond wilder also talks about the fact of the role of intuition in research is to provide an educated guess and i think that's an important part too because there's a lot of times when we're going through our code and we think well i think it's this and so you know you'll kind of work your way down that path and see where that ends up leading to and i that's the part i really liked about the quote was it's like progress can be cannot be made without it and even a false guess may lead to progress right even when we get it wrong we still get something right and and i can appreciate that so he also had intuition is used by modern mathematics mean the accumulation of attitudes including beliefs and opinions derived from experience both individual and cultural so the particular paper that raymond wilder had here you know did get more into mathematician and or into mathema itics and i thought that was interesting because it's cpp conon i want to say in 2018 and i was trying to look up the particular talk i saw a talk where the speaker actually looked at methods and as you can see we're going to use contrived examples in this talk but they looked at methods by the way of mathematical and so if we look at this method mathematically a bite's going to be how many possible combinations i mean one bite anyone 256 bits right okay am i wrong am i missing it okay yeah if i have something wrong you can correct me i'm i'm all game for that so if a is 256 bits or possibilities and we multiply that by b we have a possible set of 65,536 this isn't really intuition though right right this is more reasoning we reason about the code and there's a lot of code i think that you know that's one of the big things at least when i'm writing code you have to read it reason about it in the case of the quiz last night there was not much that i was reasoning about but so reasoning but not necessarily intuition so you know we're we're we're to my final end where i was running off on my tangent on intuition and you know intuition for 2009 19 i mean with the amount of hits that's there it's like intuition is now the new in thing but evidently it's only the in thing for red wine so you know and that doesn't really help us much for our code maybe okay so the key points i want to take away from the intuition is that you know it's a function of the intelligence intuition is theological view that some moral truths can be known without logical inference the roll into tion in research is to provide the educated guest which may prove to be true or false and of course the rules for happiness i think are just good rules for happiness so when i was getting ready to do the talk i had asked colleagues to send me screenshots of their particular development environments and the one thing i thought was interesting is at least at least all of the people that i work with everybody likes dark backgrounds is that the same here is there anybody that uses light oh okay all right i i'm learning so you know we're doing intuition and then we're talking about tools and i think in general we all use a lot of different interfaces multiple os's you know i had everybody from linux and windows and you know macintosh and and windows on macintosh and windows on linux and linux on you know how that all goes with our virtual machines um so but we all use a lot of common tools there's you know a whole handful of editors that we use compilers and such and really the thing is is that i think when it comes down to it we all end up at the same problems so we can turn around and spend some time going through some of those problems so just to give an overview of some of the you know different interfaces c lion visual studio code is anybody familiar with the red c c++ logo there oh that makes me happy so that c++ builder i it was i i liked it at one point in time but they use a version of this stl that is supposedly version 11 compatible we'll leave it at that but then we have our compilers right so intel clay microsoft's compiler c++ builder gcc and static analyzers so clang tidy or clang d if you're using clang d now pbs studio reshaper or excuse me resharper c++ check sonar source you'll notice i have sonar source logo down in the bottom i just happen to like sonar source i'll i have a slide in here later while show some comparisons but the tool for their lter works well with with our work that we do otherwise i'm not affiliated of sonor source so of all those tools tools how well do you use them and are they doing everything that they can for you right i mean that's where i want to try to get to all right so from my experience i get three types of problems when i'm building code and writing new code compile time syntax errors i give templates its own category i do love templates i'm just not that good at them and i'm getting better link time you know you're compiling something and suddenly a symbol cannot be found i put missing libraries and versioning issues because i've experienced you know those when we are building such but of course you know that's where i'm siging three types of problems at least and then runtime your logical errors semantic errors and various other types of errors i mean that's i think where we spend most of our time debugging things is when we're in the runtime and you're outside of this code being able to be analyzed so this was me in the 90s this is turbo c++ and i you know i wanted to show this because if you're new to programming then when you get an error at least for me when i was younger and even now still you you can kind of see and sorry for the red there but you'll notice that i got the cursor there by the semicolon in our method and so you know i'm going to do the simplest error we have which is to remove a semicolon now back in the 90s if you removed a semicolon and this is all in one file if you actually had a semicolon removed in a file that was included in a file that was included then this list went even longer but basically missing one semicolon from an old compiler and suddenly every line of code you have was wrong in some way and yeah my younger me this this was a little bit you know really where am i going to start fortunately we've gotten better and if i put this on my coling back in you know of course it it does build and run if anybody wants to run turbo c3 on your windows box you can actually download it i did it just for this i don't think i'll open it again you know just saying but that's what it was like to codee in the 90s at least for me and so we'll look at something newer so you'll notice i'm going to i'm just i'm guessing if you're in the back does the font come out all right okay so we're going to look at the same kind of an error you can see i'm already missing the semicolon you'll notice that i have the compiler explorer logo so later on you'll be able to get a qr code if you do want to download the powerpoint slides i did try to make sure to link everything with compile explorer so you can actually look at the code samples but the thing we're going to go through over the next few minutes well next half hour probably is different compile different compilers and options and what it ends up giving us back because again my thought was how did i build an intuition for when a bug happens and you know from where i started back there with c++ in the 99s our error messages have gotten better but it all depends upon what you're using and what version you might be on the job that i work at when i first started there we were still stuck on c++ 11 with you know cl or with gcc 4 at the time and so in this case here if we compile this particular code with gcc 4 you know we get the fact that we're missing a a semicolon and that it needs to be before the return okay so if i didn't do c++ in college and i decide to put it before the return right i can do that and it does work right i mean that's you know and so that was gcc 4 of course now if we even take clang so clang so clang three this is an old version of clang right and so one of the things i was always told was that cang when it first came out was being built a lot for its tooling and and so if you take that same code it at least gives you hey you you don't want to just put it in front of the return you actually want to put it at the end of the line and so i get this is you know this is where i'm like they are kind of contrived examples but my bigger point is that the tools that we pick matter you know and and what you end up doing with the tool can get you more information so when you're starting off learning to develop in c++ you want to use the best tools you can get and and best might be a little bit of a loaded statement but i think you understand what i'm saying go with the newer tools if you do the same thing in clang 17 you know now they'll actually give you the line numbers and some nice layout and so again these are small examples because i was trying to make sure we could fit things onto slides too but i think i think you see the point where we're getting there and gcc has actually gotten better if you're using a modern version of gcc you get roughly the same and i think that's also interesting because clang and gcc seem to have started to catch up with each other from their output so jason turner has his hello world and and i heard someone say it's the most complicated hello world that they've ever seen so um this is using features oh sorry about that this is using features of c++ 14 so if we try to compile it in clang we end up getting an error because of an expected expression even using an old compiler if you make sure that you're using your compiler options though then you know it compiles and works well so that covers our basic syntax errors we'll we'll leave it that where that's at and we'll move along to templates and so i'd asked this question before some of you really love templates actually we should all love templates right because if you use any standard library you're using the templates and i don't necessarily write as many templates but i use the template library a lot so so template errors can anybody does does anybody see what the error is going to be in this yeah a couple okay all right so the point i want to make make is there is a very small error but that's that's the start of it and it actually yeah it it goes on for about 300 lines so so this was why i never lik templates and actually the company where i work at for some of the people that originally you know okay for an old guy like me when i started when we didn't have templates i always wanted to avoid templates because i would get an error like this and i would probably turn whiter than i already am you know like oh no what am i going to do but how do we break down you know what's going on with an error that's like this and so this is with gcc 49 you know we're i i left as as i'm adding compiler options they will mostly stay in because i just want to keep showing that you know you want to make sure you're using the right options when you're compiling code so if we take clay trunk and we compile that same code though it's still going to give an error but now we actually have something of value right because here we're you know as i'm reading through this it's like okay invalid operan in binary expression so that's still i mean it's better than what the other one was right so out of curiosity does anybody know where we're using a binary expression in those three lines of code yeah yeah so when we're doing the compare you have a binary expression of course because you're looking for the equals and as it's pointing out the values don't match and if we look there it even tells us that the stood vector int and constant are the two that don't match right and so compiler errors if you're actually using a more modern compiler you can get better output and thereby make it easier to fix so all of you use wall yeah okay i see do all of you use wall no no okay it's i a lot of people do that's all right i i didn't for the longest time when i first started our company you know we were not the warnings and errors are all on all the time and so but with template errors it's helpful so if we do the same code again and look at it well that just proved oh that just proved me wrong we get the same looking error there sorry there i have an error in a slide but if we look at so sorry i have a duplicate slide there i apologize but with wall we actually now get you know an even more the variable a is uninitialized first so because we're doing wall we're getting all the warnings and so yes it is uninitialize but it's also telling us on line seven that the stood find is where the bulk of our problem is at and so this is why you want to be using all of your compiler options because that error that that you know was so scary to me before this actually gives the compiler does so much more work for us now than it ever used to and but if you're not actually turning these things on then you're not going to know and it help have the compiler help you i guess is more to my point and so as that points out there you know it actually tells us that exactly what the invalid expr ression is and so we have clear detail of what's going on there and so yeah if we turn it into a stood vector now of course that a compiles fine and and the problem is solved so template errors are template errors don't have to be so scary if you use the tools that you have then you will be you'll be thinking yourself and and and when you're doing stuff just in the standard library because that's my point it's like if i actually write a template then i create far more errors than you know even what the template library there does but the compiler can make all the difference that way all right so everyone should wall wxtra and pantic the amount of options that the compilers have is just huge i i think the it's probably 10 12 pages of options and so that link there is the link to the actual warnings for trunk but for me wall wxtra and pantic there is you know the always have your warnings become errors when we're doing something in production i absolutely do that i think it's a good thing to do but even if everybody just uses a couple of these you know my goal is to help you improve your code that little bit and so even if the first step is just adding wall pendan does c++ the compiler extensions and so pantic we end up using it if you're ending up moving your code between different systems then pendan can help make sure that you're not using an extension on one system that is not available on the other so i have it listed there it's your mileage may vary and so i was reading a c++ reddit where somebody's like you know what compile options should you end up having and they were saying in fact everyone should go to this particular best practices so jason turner you know as i pointed out he has that nice obus skated hello world he also has a best practices where he goes through and lists the different compiler options to use this particular site also has some cmake setups and such like that so if you haven't done a lot of cmake projects and you need boiler plates that is definitely a good place to check out boy i'm everything that i had hidden is suddenly showing up so if has anyone seen this talk i know phil has so i picked out so bryce bryce leachi works for nvidia and he's he did a talk that's ai assisted software engineering and i'm i'm putting this slide in here specifically one bryce is actually pointing asking him to turn down the lights but i like this particular shot in the slide because i'm like bryce is pointing to the future so they have a project called cy so talking about templates for ai assisted software how many of you like co-pilot how well has it worked for you yeah that's what that's what so so i do recommend you go see you you watch this talk because at the same time how many of you get your code right the first time right so that's kind of his point we want ai to be right the first time but yet you know we seldom do but the reason i wanted to put this in here is they him and a couple other people worked on a tool called cy and cy will take the output from the compiler and help you figure out what went wrong and it can even go into the fact of being used inside of a cicd chain and actually se suggest patches and such like that so if you want more exciting ways to work with your templates and your errors that you're getting out i would say check out that project all right so syntax errors templates we've got those couple covered let's move on to linkers so linking errors missing libraries versioning and basically cannot find symbols how many of you get that part when you're compiling something and you know so let me just go with the example first so link or errors so again a contrived example but it's going to give us the part that we want to see you know so we have a struck it's got a pure virtual destructor we have another one that is inheriting inheriting from it you have an x turn for x there a void fu when that gets compiled in an old version of gcc it actually works it compiles clean it doesn't really run i mean and obviously this isn't doing anything but the point i'm trying to make is that you're using an older compiler and and it actually compiles and links if you end up using a new compiler with all of our fun stuff turned on though you're going to get a different output and so you end up getting the fact that you have undefined references okay so do all of you understand an undefined reference do you well how many people from m hands get have have and dealt with and have an easy time with undefined references okay so an undefined reference so when we're building code and there's some great talks that are about how the compiler works you have two stages right you have the compiler that does its compiling of the code to make sure that it is syntactically correct and creates an object file but then what ends up happening is the compiler will take each of those object files and link them together so if it can't find something then that's where we get an undefined reference error so basically an undefined reference error is saying hey you know i know you're telling me to call this function but i can't find a definition for it and even when something's in the same file that can happen because in this case here x is marked x turn right so we're not actually defining x we're just saying that x is an external variable so so it'll still compile clean but it actually can't find x and similarly with fu fu we have a not a definition for it but a declaration for it and so this is meant to be able to show the fact that if you turn around and have you know have you ever had a parameter off when you're you know you have two files you have a parameter missing in one and so when it goes to link it might compile fine but but you end up getting the compiler error how do you solve these you know for me i end up having to turn around and walk through you know the particular lines of code kind of like we just did and say okay so if the file is saying that it can't find it you know what is it trying to link to what file is not being included this is actually you know you know in hindsight as i'm talking about this is kind of a bad example but normally when i'm getting errors like this i did a project in my last talk where we're doing lib http and json and i was building it on the mac and so if you turned on https on the mac it's kind of complicated when building it it wants a specific version of the ssl library and so when we get errors like this sometimes the best thing that you're going to end up doing is falling down the rabb and starting to dig through and and ask questions you know whether you're searching for the particular era directly on google i mean how many people spend hours on google copying and pasting an error and to see what they can find yeah but what does that end up doing when we end up figuring it out that ends up building that experience and so then the next time you get it it's not quite as bad and like you know so i'm trying to pull this part together that's where i'm like we're trying to build an intuition over time and and unfortunately as much as we want to have that intuition just hit us and happen you know like always be able to see what the answer is and no sometimes it's just the fact of the struggling through it so with playing we get a little bit more detailed information but it's still the same part and it fails with an exit the undefined references again when you have that then you know that you've you're just you're missing a particular method it needs to be able to be called all right so link time errors i don't run into the i do many of you run into link time errors more or your compile time errors compile time all right what about runtime nothing happens at runtime right i mean it runs on my machine so runtime errors what the compiler doesn't catch so i have logical errors and semantic errors and we're going to look at an example that's a semantic first and but all of these particular types of errors they're the harder ones because you know the code looks right it compiles the compiler is not really telling you anything to help you out with it so we have this particular method here excuse me and i want to take look at it and i want to see if anybody can kind of take a a bit of reasoning about what kind of error we might get so if we compile it it compiles and runs but the program returns zero with the product of zero so it is not actually you know getting us the product it's not multiplying through the numbers one two 3 four and five and and putting them together but why so all right well if we take clang trunk and we do the same compile with our wall and extra and all of our compiler options so product's not initialized so on one hand you know i'm saying runtime errors are hard to find but the compiler difference actually pulled that out for us right and so you know when you're first learning some of those errors can be caught because the compiler you know the compilers have gotten smarter they can turn around and say hey you know this particular item needs to be initialized or this isn't being used so the best way that i found to find runtime errors is test cases anybody here use catch so yeah phil uses catch so these are actually test cases that i have from this is actually test code that i do have from work because we use a lot of binary coded decimal in visa transactions and so i do find it easier when i'm getting something that is not actually producing the result that i want to for me it's easier to debug this small test case than it is to necessarily debug the app right now unlike phil i have not fully mastered the part of test driven development so i do end up writing a lot more code and then we write test cases after and and i do need to improve on that but when you have an error that is you know you're having a hard time reproducing i think one of the best things that we can end up doing is turning around and using a test harness such as catch to be able to turn around and go in and write a specific test case so that then you can look at each one of your particular methods and make sure it's at least returning the result you want i don't have it included in this slide but you know i started off with these particular ones because when you do binary coded decimal we're actually you know taking two decimal numbers and compressing it down to one bite and so that's what this is code is testing for but then we also turned around and created a method that randomized the amount of numbers that were being passed in and did a bit more fun and the more advanced tests you generate we actually found multiple errors in our original algorithm because you ended up hitting edge cases you know and it's always easy to test for the one known case but the edge cases end up becoming harder to find unless you you know start throwing in random data and interestingly enough how many of you actually saw phil's talk okay so for phil that was half the room so you if you haven't seen the talk you want to watch the talk it's it's really good but catch 2 has a lot of great features including a generator feature which then allows you to build that particular data out and it can help help you find those test cases those edge cases so those are our three kinds of errors you know that i've i've found and had to work with and and build against compile time link time runtime and i wanted to turn around and you know it's kind of funny i'm i'm looking at the clock now and i'm running really short or really long on time but then at the same time when i was going through and practicing i was going slower so i'm obviously speaking and and moving faster but so static analyzers how many of you use a static analyzer with your code okay so which is your favorite if you might if just clang clang d clang tidy how many are actually using clang d i'm curious specifically so if you use clang tidy and as i understand cang d will work with all kinds of other editors the envm that was shown as the idees were popping in i like vim but you know i i use a mouse i'm i'm happy with a mouse but clang d will actually give you these kinds of errors live right in your code as you're you know moving your mouse over the top of a piece of code it'll tell you when something is wrong before you ever have to hit compile clang tidy i think does a great job as well but the thing that i wanted to show here which i thought was interesting is that don't just use one because you know i actually use the sonar linter and clang d at the same time and as we're looking here there's actually you know there are some things that cang d and sonar pick up on the same way and maybe they talk about them a little different but then there's a lot of things that sonar picks up on that cang d doesn't and i you know my my intuition on it is that you know and not actually just intuition but understanding how sonar works they're actually trying you know that's their their sl is clean your code or you know if i believe it's along that lines and and so that's actually what they're doing is they're you know pointing out areas of code that should be cleaned up and all of these can be everything's configurable right at least for us our clay tidy there's a lot of things that we turn off i do understand the point of you don't want too much noise but i think when we're learning i'd rather have a false positive than you know than missing something that is an absolute negative right so so our compilers matter clang you know as i've kind of showed in a few of those examples generally does a good job at reporting we use both compilers every day and work if i build something in gcc i also then turn around and build it in cang because cang will actually give me different results and error messages than what gcc does you use the newest compiler that you can we're still stuck to c++ 17 where i work but we still use the latest and we just turn around and put the standard line in so that we make sure we're not using something that we're not supposed to and that we're being compliant with the code that we're supposed to write and even older compilers as i was showing when we were going and you added the stood 14 you know if you're stuck on an older compiler then you know again use your command line arguments so you can say hey this is the standard i'm trying to be at and so add your compiler options when i started and put together the abstract for this talk i had planned on doing more with microsoft visual studio how many visual studio developers do we have wow okay well i greatly apologize i think when it comes down to the error messages and stuff we see a lot of the same things but i will say you know so in my previous position i used visual studio and mfc a lot i don't miss mfc i i will say that but visual studio you know has some great i i love visual studio i really do i just don't end up using it every day but some of the same things that we're talking about you know it's like the compiler options they're named differently but they're all there and at the same time you know if you're using visual studio a lot of these things they're just on by default you know i think microsoft does a good job even with their static analys and tools and they have it wrapped in well incidentally i will say there's one thing that i miss when i'm on linux and with any id ide that i've seen in linux the wonderful thing you can do in visual studio you know if you're going through and doing debugging and you have a stood string you can actually change that string while you're running right which is not something you can actually do inside any of the gcc or clang so you can change numbers you can change you know other variable types but stood string is one of those ones that you can view but you can't go through and change and so i talked and to you know see line if if somebody wants to fix that i will i will change i will change my editor that's for sure all right so this quote from albert einstein i really like it's not that i'm so smart it's just that i stay with problems longer you know i can think of days where i've spent literally days looking at one particular error trying to figure it out and you know writing one small test case or writing another piece or pulling out a piece of sample code because you're just trying to dig through it hours on the internet and so every time that we end up building through and and sitting through those things though we all learn that little bit more which makes the next bug that much easier to get through so i gotta i w you know i pluged jason turner a few times here because i do think that he does a really good job if you haven't seen his cpp weekly he does some great job at going through and explaining various features you know whether it's a compiler feature code reviews basic projects to start off for the half the room that's doing microsoft visual studio you you know it is standard c++ but he is a bit more on the side of of the linux and compilers such there and so yeah we can all work on building our intuition use every resource you can and if you have any questions let me know so i talks are not always my thing as that hasn't shown up as being obvious however i work as a i i'm speaker liaison at cppcon and i do volunteering for these other ones the qr code there is just a link to the slides if you end up wanting to get any of the links in there if you are interested in any of these other conferences whether volunteering or you want to submit a talk by all means let me know i i will say the one thing that's great about submitting a talk it's it is nervous depending upon if you like to speak or not getting up here but even kevn was saying you know the way that he ends up learning something or learning more about something is to give a talk on it because you know where you start in a talk and sometimes where you end up it's surprising and then you know in hindsight i still have a whole bunch more slides that i was working down to be able to add here but you're trying to figure out what content you can fit in so give a talk thank you [applause] and we have plenty of time if anybody does have questions by all means hi thanks a lot one thing i'd like to add regarding template error messages do you know about kem miller script from victoria romeo no i do not this script can greatly collapse template error messages into readable types again so it will will de expand something like basic string of char of char trades back to an std string ah okay and will just put basically get rid of 90% of all this mess that the compiler outputs that's excellent i will make sure to get a look at that and if i end up doing the talk again i'll make sure to add a slide for it too thank you so we got an online question here what is the difference between clang tidy and clang d from the name of it i guess both would be llvm and free yes so both are llvm and free the difference is clang tidy clang tidy you run separately so a lot of the code editors like visual studio code before we started using clang d you could turn around and set up a build job so that it would run clang tidy and it would give you that same output let me just scroll back here to this slide one second so this output here is what clang tidy would end up doing and you can see it marked there you know cang tidy found a particular thing on line 85 column 11 clang d is fully built into the interface like intellisense i'll say on steroids because and you know i haven't used intellisense inside visual studio as much anym cuz like i said i'm not in visual studio but at least with visual studio code intellisense is nice and it'll help you find you know a particular function or method but clang d basically gives you clang tidy live all the time so if you type something wrong it's going to turn around and tell you right there and then in a popup box at least in visual studio code that this is exactly the error that you're having so clang d is interactive clang tidy is a run and get result that's probably the way i'd explain it anything else all right thank you