i'm excited for this one we're going to talk about firestar networks i love five-star networks they're brilliant i they're one of those things in cryptography where you just think wow that's very clever that's really elegant and it's not even that complicated and yet you just think that's that's great the fascial network was designed roughly around the 70s when horst feistel who worked for ibm who was a german physicist with the nsa he helped develop the data encryption standard dez all right now dez was as we know from the previous video replaced by aes eventually mostly because of its short key length but des the structure of des is something called a firestore cipher or a firestar network and there are a few of these around two fish for example is a fiesta cipher five society use in padding schemes like the padding scheme used for digital signatures on certificates physical ciphers are used for key schedules they're used in all over cryptography and they're very very cool so that's what i wanted to talk about today all right so a firestore cipher is not actually a a cypher in and of itself it's essentially a kind of framework for building encryption algorithms it's a structure and then you put in some encryption rounds and a key and things like this and then it turns it into a cipher for you right and it has some really neat properties so i'm going to draw it out and then we'll talk about the interesting properties that it has so you start with a block and we're going to split that block in two and then we're going to take this as the right hand side and this is the left hand side we're going to take the right hand side down we're going to put it through some kind of function right which is going to be some kind of pseudo-random function like a hash or an encryption round or something like this we're going to take it out here we're going to xor it with the left and then we're going to bring the left down and we're going to bring them right down here and this is your next block so when you say left you'll mean the left hand side of that block on the right hand side doesn't have to be exactly half and half ah very good question so in this case yes but in general no you have unbalanced visual ciphers where the left and the right are different sizes for this demonstration they're going to be the same size as as as near as i can draw it i'm not very good at drawing so the next round is exactly the same we take whatever this new right is we bring it around we go through f we xor it with the left and we come down here like this and so on right and you can repeat this process as many times as you like for however many rounds and then at the very end after the last round you flip the output like this now this is a structure for encryption in the sense that you can put in any f here and you sort of build yourself a cipher now this f obviously needs to be somewhat reasonable but what's so incredibly clever about this encryption algorithm is how you decrypt it to decrypt using the same file so you encrypt by putting your block in here it goes through here it goes through here it goes through here and it goes to as many rounds as you want and you get some output to decrypt it you pick that up and you put it in the top and you run it again and even if this f is a one-way hash function that can't be reversed that still decrypts it what come on i mean this is this is why i love faster cyphers so we're just going to do it we're going to start with lnr and we're going to work through and we'll see that it does actually reverse itself right which is just amazing i mean maybe you've seen a faster psychopath maybe you know this happens right but i think when the first time i learned about this i thought that is that it's awesome so let's do this this is the left this is the right now for the sake of argument they're the same size in this one the right is going to come down here and it's going to go through this function so we're going to put in a key into this f and it's a lot more secure to make these a sub key so lots of different keys for each round so it's going to be key 1 this is going to be key 2 like this this f is a round function that combines whatever comes in with the key and mixes it up and sends it out here this r comes through this f yeah and it's xored with this l and this comes down to here so this element is l xor f with r and k one so i mean that's going to look like gibberish as far as like i said this side is fairly straightforward the r just comes straight down and turns into an r like that so let's do the next round this is going to come down here and go through here and then it's going to be xored with this r so this output here is r xor f of this which is l i'm going to run out of space l xor f of r k k1 of k2 like that does that is that right i think it's right maybe it's a good thing that we didn't do three rounds or four rounds of this because this could take me quite a while by hand this one is going to get copied down so this is going to be l xor f of r and k one now both of these will look like gibberish we're going to switch them around here i won't draw them in quite yet right but this one comes down here and this one comes down here feel free to animate it sure thanks for that all right so now we're going to see how we can decrypt this back to l and r and all we have to do is take this put it in the top and we have to swap our sub keys around because of course the rounds are happening in a different order so i'm going to draw this exact same structure again on the next piece of paper so that we have something new to work on otherwise i'm going to get very confused so this could be a competition how fast can you draw a physical cipher from memory so go that i mean they're not nearly wide enough for me to fit my stuff in all right let's go again i think that's right you know so the keys need to be in a different order so this is going to be k2 coming in here and this is going to be k1 coming in here reversing these keys you know arguably not too much of a problem that would be a list of data or something like that very straightforward all right so let's put let's copy our data our cipher text in we're sort of going to do we're going to do that and plug them in like this see what i'm doing so i'm going to draw them in so bear with me this one is going to be over here r xor f of l xor f r k 1 k 2. and we'll just pretend that green line's a little bit further along right and this one is just l xor f of r k1 and then we're going to see what happens can you remember what it was that's really interesting about xor if you do it again a second time it's the reversible thing right it's a reversible thing right that's the key to this whole thing when you xor something with the same thing again it undoes it right so what happens here is l f of r 1 is going to come through here and turn into f of l f of r k 1 k 2 which is this bit so that's going to come in x all of this and we're just going to get r out again here this gets copied down here so l xor f of r k1 so let's go again r comes in here it becomes f of r k1 xor with this this becomes l r gets passed down here l goes to here r goes to here and this will work for any number of rounds and for any round function right which is super cool and it's going to be a combination of all of these so this one times this one plus this one times this one plus this one times this one plus this one times this one and then we repeat this process for each of the values so we're taking bits and bytes from all of these in this column jumbling them up moving them around shifting them and there is a reverse inverse matrix for