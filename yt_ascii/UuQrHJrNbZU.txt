so i'm going to talk about formal mathematics or computer-based formal mathematics so i'll be talking about about the mathematical challenges in get in in in in building a formal ma a formal mathematical proof for a computer like not just the practical challenges of entering it on a computer and so on and so forth but actually showing that there are some mathematical and conceptual challenges to doing that ths ales talked on your channel about lean i think the the improve of lean if this is the case then this is the case so how do i prove an implication so people should be already aware by just looking into that or the many other videos on the inter on on youtube of the appearance of these theorem provs and so on and so forth but i just here like tell you what is the goal of that to remind people the ma the the the philosophical or the mathematical or the high level goal of writing for mathematical proof so you basically want so we'll just write to you a very simple proof right if we just say aristotle is a man and that's i would just call that assumption one and assumption two all men are mortal then from those two assumptions i i hope everyone agrees that we can derive that are total is mortal so when i say for mathematics i mean like writing down a mathematical proof down to that level of unambiguity it's crystal clear what we're talking about there aren't any conceptual leaps there aren't any logical leaps is just as clear as that right if you try to write a proof like that as i said like you can do it to the computer on lean isabel other improvers but the challenge of entering it on a computer is one thing but there's also a fundamental challenge of translating a proof that is intended for a human to understand into a proof that is as unambiguous as this one okay so there are many challenges with that some of them can be just pure tedium for example right like it it can just be the that you have so many symmetric like that that you prove consider so many symmetric cases and so on and so forth but some of them are also less tedious and and really are just about translating a graphical argument for example to a verbal argument and i will focus on this like having a graphical argument to a verbal one and you will see by in the process what are the challenges of translating informal proofs to or some of the challenge of translating informal proofs to formal proofs so like for example verbalizing the graphical argument that i will discuss with you now on the number file i think there was a video a few years ago on the so- called stable marriage problem these two are going to say to hell with this arrangement and run off together so that's what we want to avoid so this is a very related problem here we here we have the problem so-called online matching right that's mathemat problem in computer science and economics mathematical economics and operations research called online matching what is the problem we quite simply have some sellers right right so you have s1 s2 s3 s4 five and six so let's say this one sells t-shirts shorts shoes socks and so on and so forth and you have buyers and every every buyer is interested in in a few of what the sellers are interested in but every buyer can only afford one item and every seller is only selling one one item what that means is that every buyer can only be matched to one seller so this is one constraint right that every buyer can only be matched to one seller and every seller can only be match to to one buyer and the constraint is the following in this problem that the buyers are arriving online so here we have b12 2 3 4 5 and six so just imagine with me that all of them weren't there and then only one arrives b1 arrives with its preferences right so b1 for example is interested in what s1 is selling and what s3 is selling the computational problem is the following when a buyer like that arrives with the preferences you have to decide immediately for that specific buyer if you're going to grant any of the preferences or not if of course there is an available seller right and so we set two constraints right so so the first one is everybody can be mapped to one seller and seller can be m to one buyer and and and and the buyers arrive online and you have to decide online whether you will grant their their their preferences or no for example the goal is to match as many buyers to as many sellers the algorithm we're talking about is is an algorith called ranking it's due to carp and vasani and vasani from 199 it's a very well studied math algorithm in in the theory of computing so i will just show you how it operates so this algorithm simply does the following so as as i said the buyers arrive in in order so b1 2 and then till 6 so let's say b1 arrives so firstly we it it it randomly permutes those sellers right before it starts so i i'm here assuming that those s1 to s6 have already randomly have already been randomly permuted once you randomly prute them you're done with the sellers you don't do anything there and then whenever a buyer arrives you just match it to the topmost available seller in the list of sellers so for example for b1 what are its preferences s1 and s3 so you just simply match it to s1 and then b2 arrives right what are the its preferences s1 s2 and s4 so what is the top available seller it is s2 and then b3 what are its preferences s1 2 and four then you will map it to four and b4 what are its preferences it's one and three and three is available see you map it to three and buyer five arrives what are its preferences four and five you m it to five and six arrives what are the preferences it's just five and five is not available so you cannot map it to anything one of the most important things to understand about this algorithm if you're trying to mathematically study it behavior is to know how its output changes if one of the buyers just doesn't show up what is the difference between when the buyer is there and when the buyer is not there so if we just assume that buyer two will not show up right what happens so then this means that three arrives right and then seller number two is available right because it was not mapped to buy number two so then two will be mapped to three this four will be available right that means that buyer number four arrives nothing changes for it because it's top preference is that is available is still three so that's still there when five arrives by five arrives it top available preference is now available four because four was mapped to three and it's no longer mapped to three right and then six can also get mapped to five because five used to be mapped to five in when when when bar two was there and it's no longer is mapped to it so five is free so maybe let me just label the edges that were dropped from the original matching after after b2 is no longer there so to highlight what edges still remain from the previous matching versus what edges have disappeared i will just use this marker so this edge remains this edge is gone so i'll just use this wiggly line this edge was introduced right this edge was gone so i'll use this wiggly line again this edge is still there and this edge was introduced this edge was gone so now what is the difference between the two behaviors right what's the difference between the output in the two cases the difference between the two matchings is just a sequence of edges a wiggly and a purely red edge right not so not this dark very like like this black one no so either a wiggly edge that was removed from a previous matching and then replaced by a red one right so so what is the difference between the two matchings it simply is a list a sequence of edges such that one of them belongs to the old matching and one of them belongs to the new one so you have wiggly old matching red new wiggly old red new wiggly old red new i hope you are convinced that when you will drop b2 each seller will go down to the next available buyer so you have like this cascading of the matching so instead of those wiggly lines like you notice all the lines were shift it down a little bit right so this is very clear when you do it graphically like that but if you want to describe it in a computer for a computer first of all i won't even talk about proving that it's always going to be this the that the difference is always going to be an alternating path in terms of u one one path is a me one one edge is is a member one one edge of the mat matching is a member of the old matching and another is a member in the new one i won't talk about proving that i'll just talk about describing the situation and show you how complicated it can be because what we'll have to do now is basically have this graph that is very easily understandable as a graph we need to turn it into a verbal one for a computer or for formal mathematical proof so i will just try and show you how to do that for this figure and it's or this path that is the difference between the two matchings and then how complicated that could be right what is the difference between the matchings as i said it's like a path like this boom boom boom how did this path arise or what what is the description of this path so you can describe this path by just saying okay this is a path that zig across the two sides i'll just say we have as function zig right so this function in order like so so to describe that path we need to define a function firstly zig that takes a buyer and tells you in this path that constitutes the difference between the two matchings what is the seller on the other side that is matched to that buyer so zig is simply it takes a buyer returns the seller to which takes a buyer b to which b was matched in the old man matching right so for every buyer you will see that in this path that is a difference we always go from this buyer to the one to s2 right and then we go back from s2 to s3 and from b3 we go to s4 which is also the the the original seller to which b3 was matched and then you go from four to five and then from five you go to five again so so every time you going from this side to that side you go from a buyer to the seller to which it was originally matching all right the other part of this path is if you take a seller right so we'll just call this the zag side so it zigzags so the so so so there's a function that tells you what is the buyer to which a seller is matched right this function takes a seller and returns the buyer to which the seller s would be matched after one buyer drops out after b2 drops out for example so after in our case here after b2 drops out okay this is just the first part of the description of the path right now now we want to also that that cannot a computer cannot understand that yet why because you need to understand returns the so so like we have this part there of the definition which we might want like if we want to pursue this definition fully we might want to even elaborate and i will just write start the description of that other part so the buyer to which s would be matched after two drops out that is not like in order for you to write something in a in a form of proof it has to be abundantly clear right this is like the buyer to which s would be matched after b2 drops out is not very clear which one is that you have to actually unfold that and turn it into something clear again right for example what what what are the conditions so this buyer has to be a buyer because for computer it's not always obvious that other buyer you will have to then observe how that path is constructed but that buyer has to arrive after the original buyer to which s was mapped right so you will not match s to something that is before b2 for example like s2 will have to be matched to something that arrives after it of course that other buyer will have to be interested in what this s is selling and there isn't any buyer arriving between that new buyer and the old buyer that is interested in what s is selling and that is not matched to something above s so as you can see i mean the point here is is is is not for you to really verify these conditions but it is to show you the process that when you're trying to describe something like that to a computer you really need to study a situation that might be very easily explained to a human and then see all of these possible corner cases that you want to avoid so other than putting the proof in a computer one like like this is the other consideration that you need to take when you're doing form proofs like you you will need before even touching computer you will need to think if your original proof or your original argument or your original situation is at that level of detail or not and if not you will have to write down something like this and a lot of times in fact this can be mathematically interesting this can show you new mathematical ideas when we're writing down these details and exploring all the corner cases and it can lead to to new proofs and even can lead to shorter proofs so for this specific algorithm for example this is a part of work i've done with with monom un christ m liner the mathematical study of this algorith has been done for six times at least right three of those papers just talk about this figure and assume it's so obvious what will happen when you remove a buyer and and that's why like this this always reasoning about this figure is just one line but when we did the proof in a form of mathematical proof that turns out reasoning about this figure and this graphical part of the reasoning turns out to be almost 40% or 60% of the effort like so so it's it can just show you that like it it can be a completely different proof that so so this is something oh yeah that's basically what i wanted to talk about like and presumably you can then apply this same thing to different yes different matching problems matching problems that's the word i'm looking for yeah yeah yeah yeah yeah so it's yeah yeah you have to but but i think as i said like when you're writing a formal mathematical proof from equivalent to an an an informal proof one part is just tedium of entering something into computer and actually we had to go on a whiteboard and study all of these corner cases and what is the actual description like it was much more than just the tedium of entering something on a computer does that does makes sense yeah and often those corner cases and things that's because you're trying to avoid unintended consequences exactly exactly yeah yeah yeah i mean what what sorts of consequences could happen if you missed those the computer makes the wrong assumption or well what well well in a so so so form mathematical system will usually not will just tell you that this is not approve and you will have and that's how we actually knew were were first aware of these con cases because firstly thought that this is going to be a very simple part of the project because in all informal proofs this is just a oneliner right so we thought this is going to be simple but then we tred to prove it and the computer just simply didn't accept our proof because you have to write a proof into these proof assistants and they check your proof they don't try to prove it all on their own right and they just didn't prove it no proof yeah no proof exactly so you have to do that and it yeah took four weeks or so but yeah it was rewarding yeah to make get people to understand it is to use these these proof systems now they not export but just sent a rubbishy export key for some other reason fair enough right so the question then becomes how do we break