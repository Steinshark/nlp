all right so a few years ago i wanted to see if it was possible to implement coroutines using c++ 17 this is the result the the entire implementation is around 200 lines of code and i also wrote some taste cases which i mean oh you don't see it okay so once again yeah this is this is the implementation and here are the taste cases and apparently it still runs and works so oh okay so what you're about to see some truly horrible code and i apologized before it so be prepared so if we talk about cortin since we need two things coroutine is a function that we can puse and we can resume there are many ways to implement resume here you can see three of them like inlay jump or computed goto the problem is that none of them is available on msvc x64 which was the platform that i'm using so instead i wrote an assembly procedure that smashes the r address and this is how i implemented resume so this assembly procedure simply has a move that moves from the register of the return address to from the register of the argument to the return address and then it returns so it essentially jumps and this is used to to implement the resume so when we enter the cod in we first check if we need to resume somewhere and then we resume to it but the problem is that after after assuming the compiler may assume that some variables are in the registers which might not be the case because we're jumping to an arbitrary instruction so again i wrote an empty assembly procedure just to force the the compiler to reload the the variables again and so after yelding we need to call this procedure to to reload the variables to to the registers then i again abused the return address to find out where we stopped to get the address from where we need to resume to by creating a no inline function and using the built-in return address and now we have a working puse and resume so we can puse anywhere store the return address and when we go back to the function we can resume to where we stopped the the entire stack and parameters are all in the vars variable that the the cor routin takes as parameter and for making it a little bit nicer i used macros but another property of co routines is that we need to manage lifetime so here if we eld in the middle and then go back if we exit the function by returning the variables will be destroyed which is not good so i created a struct that contains that will contain all the the the variables in the coroutine frame and then i create i declare a new frame which inherits from the previous frame and add another variable so that we can calculate the entire the the size of all the the current variables in the corin frame all right so counter is a struct that recursively inherits from itself and this frame t we can use this frame macro to get the the value of the last counter and get the current cortin frame and then after yeah and so when we we instead of declaring a variable we need to declare like a new coroutine frames that contains the variable as a data member and once again we can wrap it in macros just to make the code a little bit more nicer we also need a way to find out the the entire space storage for the coroutine frame so for every variable we also so the the cortin function takes an i template parameter and we can use it to pass out the storage requirements for each one of the the co routine frame types and finally the storage is the maximum of all the the cin frame requirements we also need some weight to clean up so every frame has functions to to clean up after himself and destroy the variable and destroy the the variables of the the frame that it inherits from and there are two two structs to stop propagation so that it doesn't go all the way and destroy variables in in different scopes and so we need to add call to the lifetime cleaning functions so once again i used macos and this is the code finally you can see an example of how the co how how it looks like i mean this is pretty disgusting but it works thank [applause] you