hi everyone in this episode we'll entry working on the appearance of the water by having the color depend on how deep the water is okay so first things first i am on a different computer today and something i noticed is that when i zoom out i'm getting these strange artifacts in the different biomes and what i realized is causing this is mipmapping which is essentially where a texture is scaled to multiple resolutions and so the filtered a little bit so that when you're viewing the object from further away it can use one of the lower resolution textures so that the details aren't quite as sharp however that is causing some havoc here so i'd like to disable that so i'm going to go into the color generator script and here where we're creating the texture first of all specify a texture format i'll just use rgb a32 and then for map mapping i'll say false okay next up i'm going to open the color settings file and here i want to create a gradient for the ocean color okay so we can save that and go back to the color generator and shiah we could create a separate texture for the ocean but i think it's very simpler if we just store it in the first half of this texture so i'm actually going to double the width of the texture to make this texture resolution times two and then the first half will be the ocean so coming down to update colors i first will want this loop to now go up to text resolution multiplied by two and then we can say if i is less than texture resolution then we'll sample from the ocean gradient otherwise we'll sample from the biome gradient so above here i'm just going to define this a gradient color variable that we're using and then i'm going to copy this and inside there we can evaluate from the settings dot ocean color alright otherwise we will be getting our color from the biome gradient now this inside here should be a value between zero and one but in this case i is starting at a value of texture resolution so we should subtract texture resolution from there just like sabaa okay so now as you may recall in our shadow we are reading from the texture based on the elevation of the vertices but this is slightly problematic when it comes to the ocean because we're clamping the vertices there to a minimum height so that we get this nice smooth surface which means that we don't actually have any depth information for the shader to use to determine the color by so what we're going to do instead is store that information in the mesh uvs let's start by going to our noise filters like the rigid noise filter and the simple noise filter could open that up and i want this to no longer clamp the value to be 0 or above because we want to know how deep the ocean use so i'll remove that there and i'll also open up the simple noise filter and remove that clamp there alright and then let's go into the shape generator and we're going to change this calculate point on planet method a little bit first of all i'll change the name to calculate unscaled elevation and this is an auger to return a float and so we won't multiply it by the point on unit sphere and i'm also not anxious scale it by the planet radius then we can have a separate method also returning a float i'll call this get scaled elevation this takes in a float for the unscaled elevation and shear i first of all want to clamp the unscaled elevation to be equal or greater than 0 so i'll say math f dot max between 0 and the unskilled elevation and then we can scale this by the planet radius by saying elevation is equal to settings to our planet radius multiplied by 1 plus the elevation and then we can just return that value all right so let's now go into the terrain face class and in the construct mesh method we can have a float unscaled elevation equal to shape generator dot calculator unscaled elevation and then we can say that the vertices with an index of i is equal to point one unit sphere multiplied by shape generator dot get scaled elevation passing in the unscaled elevation i'll right now we want to set the uvs so uv i i want to set its y-axis remember we're using the x axis of the uvs for the biomes so i'll set that to the unscaled elevation now we do want to be sure when we're creating these uvs that they're actually have the right size they could be wrong if we're changing the resolution of the planet so in parentheses here i'll say that if mesh dot u v dot length is equal to the vertices array length then it's the right size and we can just use mesh dot uv as our starting point otherwise we want to set it to a new vector to array that has the length of the vertices array all right now the other thing we need to be careful of is coming down to this update uvs method here we're currently assigning a new vector to to the uvs which will be overwriting any information we provide over here so instead of doing that i'll just say uv with an x of i dot x is equal to color generator dot biome % from point like so ok and then let's also just up here set the new uv 's equal to the existing movies that were not overwriting that either ok i'll save that and go into unity and i'm going to just regenerate the planet quickly and then you can see it's all messed up at the moment because we need to update the shader but i'm going to quickly go on to the ocean color gradiant share and just set this to a nice dark blue at the base coming up to a light blue along the shore just something like that alright and then i'll open up the planet shader so as i saying earlier we're currently using the positions of the vertices to ultimately sample from the texture but we now instead want to use the elevation data stored in the uv channel so i am going to delete those two nodes and now to read from the uv channel we do have this uv input node but to try and keep this graph at least a little bit organized i'm going to move it over there and actually just create a new uv and put up here and i'm going to split this so that i can get just the y component that i want and now what i want to try get is a value that goes from 0 at the base of the ocean a sort at the lowest point i mean to 1 at the shoreline so in order to do that we're going to need to go from the minimum elevation to zero so let me just delete this connection here and have a value of 0 there that's the height at the shore and then we'll use the elevation as the time and that should give us that so just to visualize this quickly let's drag that into the color output save this and i'll quickly add a new tab here for the game view and this looks roughly how i'd expect with these dark regions sort of in the ocean here and then coming up to pure white at the shoreline and above okay now going back to the shader we want another value that goes from 0 at the shoreline to 1 at the peak of the highest mountain so let's create another inverse lap node this is going to go from zero to the maximum elevation and on the end we'll pass in the actual elevator that and to visualize this let me drag that into the color save the asset and go into the game view and here we can see we've got that all right now remember that our texture is split into two parts the first half is the ocean and the second half is the land so i want this value which is for sampling from the land to go from 0.5 to 1 and the value that's for something from the ocean to go from 0 to 0.5 so let me quickly first just delete these connections since those are just cluttering things up at the moment and then i mean to drag this into a lap node where that goes into the time slot and i should go from 0 to 0.5 and then i'll drag this into another lab node and this will go from 0.5 to 1 ok now i ultimately want to add these two together like so and then drag this into the x component of the uv that we'll be sampling the texture but i want this to have a weight of 0 if we're currently above the shoreline in which case this should have a weight of 1 if we're below the shoreline then this should have a weight of 1 and this should have a weight of 0 so the way we could do that is by taking this value here and flooring it which is to say rounding it down and now if i just drag this into the color output and save this you'll see that what we get is a black or value of 0 in the oceans and white or value of 1 in all the land regions so we can take this and do a multiplication with this value here pass that into the add there and then we'll take 1 minus this value and use that to do a multiplication with this pass that in there and this is getting a little scruffy so let me just tidy this up and now i will i drag the color from the texture into the output notah and try saving this go into the game and here you can see we've got the gradient for our ocean and also the gradient for the land alright now the last thing i'd like to do this episode is just allow the water to reflect the sun a little bit more and we can do this by increasing the smoothness of the master off boccia but i don't want that to affect the land so now we have this node here which if we just look at the output of this quickly this is giving us a value of 1 for the ocean so we can use that as a mask so let's go back onto the shader and i'm going to add a vector 1 property here i'll call the smoothness and then i am just going to do a multiplication with this mask value here and the smoothness property and then i'll pass that into the smoothness of the output yeah and let me just put this back alright so we can now save that go into unity so let me close that and on the planet material we now have the smoothness property and you can see if we increase that the water is now reflecting the sun but over the land it has no effect all right i'm just quickly going to play with my water gradient a little bit so i've gone to the planet and i'll just speed this up as i fiddle with the ocean color for a minute but i think that's looking kind of nice the one thing that i still need to do is go on to the biomes here and just remove the ocean color from each of these gradients so i'll delete that there go to this one delete that and this last one as well alright that is everything for this episode so until next time cheers