uh hello everybody i am satya and today i am going to talk about an ad stable architecture for c plus plus sdk the name of the architecture is siv which stands for component interface binder and the purpose of this architecture is to bind two c plus plus components together and also insert the ava stability i am a developer at tomtom and prior to that i had worked at adobe for acrobat where i had a very pleasant experience because of sdk of acrobat so what had happened was that we had a very old plug-in of acrobat that was compiled using like acrobat 5 sdk and we were able to use that plug-in in binary form with acrobat 10. so five version difference and much had changed in the sdk and still the binary plugin was compatible with the latest acrobat of that time with that wonderful experience i wondered would we have expected similar area stability had the sdk of acrobat was based on c plus plus so i started my personal github project with the aim of finding a solution that can help us create avi stable library in c plus and today i will be talking about the work that i did during my free time and i hope i will be able to cover the core of the architecture that i have developed of course i will not be able to talk about everything because c plus plus is vast and area stability is complex but my aim is to cover the basic architecture that i have created and for the purpose of this talk we will confine ourselves to just one aspect of avi stability that is the binary compatibility of an older client to work with new library so the acrobatic story i told them told you acrobat when it was an executable for the purpose of sdk it's a library and plugin was the plant of this library because it was compiled using the sdk exported by the acrobat fine in this presentation we will discuss three different examples and in all those examples we will have a shared library which is also known as dll on windows and so on linux live systems and we will start with a very simple example where a shared library will export a simple class and we will see what architectural element we need to put in place to ensure aviation and for this example we will start with a demo in the next example we will see a slightly more complex scenario where instead of standalone class we will have a hierarchy of class that will be exported from the library then in the third example we will see a shared library that uses an interface class whose implementation would be provided by the client program and then we will see what kind of architecture we need to have to ensure api stability in that case also and for this also we'll have a demo so after all these examples i will present you a sim tool that that i have created which can implement this sieve architecture automatically and then i will give you a report of the case history that i did with a real library and in the end we will touch upon things that we could not talk about in the presentation so the first thing in this presentation now is the demo so so what i have is in the demo is a simple library that exports a simple circle class and in this class if this is a very trivial c plus plus class it has constructor destructors and the name of the class is circle and it has few non-virtual functions and it has a virtual function also and some data members so it's an example of a very trivial kind of c cross plus class that you might have seen and that's it about the library on the client side client is an executable that instantiates an object of circle and then makes use of that and how it makes use of that is it invokes methods from the object of circle and prints the output so it's a very trivial program but the point here is we will see how we can ensure every stability here so what i will do is i will run this program and we see this output so this is what we can expect right and since my talk is about api stability i have another set of client library program but this time this library uses sieve architecture and i have entered the program the same program simple class but it its name is cb5 so basically this program depends on the library that uses sieve architecture to export its sdk okay so if i run this program we see exactly the same output because essentially those both the client and the library are actually the same program it's just that they used slightly different sdk fine now imagine in the next version of the library what happened is that we made some changes in the class like like we decided that our circle class should also have information about the center of circle and such changes can happen right so i have i add two data members to store the center of the circle and we also decided that our circle class should also have a method to compute perimeter of the circle so i add another function perimeter and i'm purposefully adding this for a perimeter function before the existing virtual function so because we know that if we add a new virtual function before an existing one it will disrupt the virtual table and it will be the library will become incompatible with the existing client right so fine so this is the only change we will do in the library and we will not touch the client now what i will do is i will build the libraries so i use ninja to build so ninja simple class library so this is the library on which on which the original program depends on and as i have said i have another library that uses sieve architecture so i have saved a simple class library simplified so this is the cv the simplified library essentially the same program but it uses sieve architecture this is the library on which the cv5 version of the program depends so i'm just compiling the libraries the clients remain the same so now after this we are in a situation where we have client program that was compiled using the previous sdk of the library but now the library has changed okay now we'll see how those programs behave so first i will run the original program what we see is a different output it is different than what we had on here right and this is what the avi in stability is the existing client is no longer compatible with the new library fine what about if we run the cb5 one so if i run the cb51 we see exactly the same output as we had seen earlier and this is what the avi stability is the existing client is still compatible even when the library made the changes in its class which disrupted its object layout and which disrupted its virtual table so i hope it sets the context for the nitty-gritty of the architecture discussion that we will now go into so the ask here is that we want to export this simple class from the library in a way that we want to ensure avi stability so before we go into the nitty gritty i would like to mention a talk that was given by stephanos at cppcon in 2014 so his idea was that from a c plus plus library we can export to c like objects like c functions opec pointer function pointers those kind of thing and on the client side we can rebuild the c plus plus apis using the c api exporter from the library so that's why he named it hourglass pattern because the client can use the broad c plus plus library can also use bro c plus plus only in the middle we have a theme api it was a great talk but it did not cover few things like it did not talk about virtual function interface classes inheritance and these are the things we actually use in the c plus plus library right and i had a talk with the stiffness over the email and he said that his talk was mainly about avi isolation and not about avi stability but nevertheless i think the core of the architecture of the hourglass interface can be extended to support avi stability as well and if you don't know about our glass pattern that is perfectly fine we don't need that in this presentation what we need is the idea of using an opaque pointer from the different component we will see that as well in this presentation so okay so what we can do about a c plus plus class from a library is that instead of exporting c plus plus class which we know that can be fragile if we did make some changes that i showed in the demo so we can avoid exporting the class edges so what we can do is instead of exporting class we can export c style functions so the original c plus plus class that we had seen it had six methods like it had a constructor it had a copy constructor it had a destructor and two non-virtual functions radius set radius and it had a virtual function area right so corresponding to all those methods of the class we can create three c c style functions in such a way that the first parameter of all these functions will take a pointer of circle and the implementation of this these functions will just be to delegate to the method of the object that it receives as the first parameter except the first constructor which will only return a pointer of circle it will not take the pointer of the circle class but other than that all those methods of corresponding to all the methods of the class we can have a free style function and we can export these functions from the library and on the client side we can build the class i will show you how but i have slightly different idea and i will explain you why i have slightly different idea so my proposal is that instead of exporting these functions from library what we can do is we can export something i call method table so method table is nothing but a table of function pointers and here you see i am implementing method table using struct so struct method table circle it has six it has six function pointer types and it has also one member num methods just to keep the track of the number of methods that are present in the table so this is what we can export and if you notice the signature of all these function pointers are exactly same as the function definitions we saw in the previous slide and one thing also to note here is that instead of circle pointer for all these function signature i am using circle impul pointer which is essentially the same as circle but it is something to keep in mind i will tell you why when we go to the client side so from the library side what my proposal is that instead of exporting a c plus plus class or three functions we should export a method table so here i am initializing this method table with the pointers to the functions we had seen in the previous slide and ah i'm using dll export so that is actually the definition of the export will depend upon compiler the point is that we should be exporting just this symbol the g method table circle corresponding to the class circle from the library now we can go to the client side so library did not export a class right so on the client side what we can do is we can define a circle class just for the client so here you see the original circle class definition on the left side but the circle class definition on the client side we can have the same name because there is no violation of the odr principle because library did not export this class at all on the client side we can have a circle class with exactly the same behavior but it will have a data member p impul which is a pointer to the circle impul and circle impul on the client side will just be a forward declare class and nowhere on the client side there will be any definition of circle impulse so this is the perfect pointer that client will use and in reality this p impulse will actually be pointing to an object of the circle class on the left side we will quickly see what so we can call this class as a proxy class because it will have exactly the same behavior as the original class but it will not be the same class but it will have a pinp impulse data member that will be pointing to the live site class okay since we have a fresh declaration of class on the client side we need to have an implementation of this class as well right on the client side but how to have the implementation of this class if we remember library had exported the method table so on the client side we can import this method table and if you notice the declaration of method table on the client side is exactly same as the declaration on the library side because they have to be same except the circle impul here is just a forward declared class which on the library side was exactly same as the circle class remember okay so the last line you see dll input g method table circle will actually import the method table that is exported from the library and then once we have this method table we can provide the implementation of all the methods of the circle class on the client side so for example the circle constructor that constructs from the radius value it can call the create function of the method table and the return value of that it can store it in its p input data member similarly the copy constructor it can call the copy mat function in the method table passing the p impulse data member of the object from which it wants to copy from and then again initializes p input data member and rest of the methods like destructor will call the delete function passing the p input and all the methods can be implemented exactly in the same way the point to notice is that the first parameter of all this invocation of the function point of the method table they have to be p input data number right and the rest of the parameters will be exactly the same as the as the parameters of the method okay now we have a complete class definition on the client side which uses method table to implement itself let's see how it will actually work in real scenario so suppose the client program instantiates an object of circle and calls a method for example an area what will happen so the client side constructor of the circle will get involved right and we had seen that it delegates to the function point of the method table and here in this diagram i am representing method table as a class which conceptually it is right so we can say that method table is a class with those from methods corresponding to all the function pointers it has and the method table then delegates to the actual method of the class in the library side right so for the case of constructor it was calling new circle right and from that a pointer of circle will be returned and when that pointer arrives on the client side that will be accepted as a circle input pointer which will be an opaque pointer on the client side and with that the client side object of circle we initialize its p input data member with the boundary it receives now the circle object is fully formed and any method in location for example area it will go to the implementation of the method on the client side which then call the function pointer present in the method table passing the people data member as the first parameter right remember and then it goes to the library side where it delegates to the method of the object it receives in the first parameter right so then the call will eventually happen at the to the method of the circle class on the library side which will compute the area and return it and that value will all the way back come to the client side so this is how the whole class can be used by the client side even when library did not export the class fine so how it will actually maintain av stability so if we notice we did not export in the class from the library right so any change in the object layout on the library side or the virtual table layout that will not affect the client right because it wasn't exported any change in that will not affect the client but we did export method table and any disruption method table will impact the client so but method table is something that is in our hand we as an author of the library can take a full control of method table about how we can modify it in the next version so what i propose is that no matter where we add the method in the class definition on the library side all function pointer new function pointer entries corresponding to the new method of the class will only go at the end so the two changes you see in the next version of the method table here the first change is the number of methods earlier it was six now it is seven and the second change is that the function pointer corresponding to the perimeter of the class will go at the end and we had added perimeter before area if you remember in the demo right and because of that the existing client that uses method table to implement its proxy classes will keep seeing the function pointers in the method table exactly at the same location where it expects them to be present right because we added things on the other end fine and because of that we will answer reversibility now the thing is i have introduced method table and we c plus plus developers are well aware about virtual table that is generated by the compiler so a confusion can arise but but there are distinct differences between the two the the method table is basically it's not a replacement of virtual table we had seen that the method table was containing function pointers corresponding to all methods of the class right constructor destructor virtual function pure non virtual function right right so it's not a replacement it is only a mechanism for cross component function called call and it is the method table that is shared between the components one component exports it and other component consumes it and that makes virtual table with which is generated by the compiler remain local so a virtual table that is created inside a component that virtual table is only used in that component since we did not export the class we did not export virtual table and because of that virtual table remains local fine by now you might be wondering why we actually needed method table we could have achieved everything whatever we have achieved till now even if we had exported from the library pure c style functions y method table and that is indeed right so we could have achieved whatever achieved we saw till now we could have achieved with pure c functions exported from the library and on the client side the proxy class definitions could have used those three functions exported from the library but method table use of method table actually makes it very easy to support backward compatibility so suppose in the next version of the library when we added a new function on to the class if we on the client side when we need to define when we need to implement the new method since we know that this is not the first version of the library so it may happen the client that is compiled using this sdk of library might actually be using the old version of library right that can happen we don't know what will happen on the client machine we received our library but on the client machine it ended up that it is still using old library and there is the new client right so the method implementation on the client side need to be updated defensive for the new methods so basically if if it is working with a previous library the function pointer corresponding to the new method will not be available in the method table right so we need to be a bit careful there we need to check whether the function pointer corresponding to method table is present there or not and to check that is very trivial so because in the next version of library we had seen there there were seven methods in the class so we can just check number of methods in the method table if it is not adequate we can throw a exception and here i am throwing std bad function call and the client that compiles itself with the new sdk of the library that can decide whether it wants to claim backward compatibility or not if it wants to claim backward compatibility then it has few choices like it can decide not to use the new functionality right if it will not use new functionality fine it will also work with the previous library but if the client wants to be backward compatible and also want to use the new functions then it should be ready to accept to handle the exception bad function called thrown from the client side implementation of the class right and with that it can after handling this exception it can mend its ways and manage things nicely so because of that i made the design choice to use method table instead of freestyle functions we we have reasons other regions also to use method table we will see in the in the next example so but this was one of the reason why i made this choice fine the last difference between method table and virtual table is that virtual table inherits what do i mean by that is that the virtual table corresponding to the derived class also has entries corresponding to the functions that are defined only in the base class right but for the method table since method table is is only for cross component function call it does not need to participate in the runtime polymorphic call it does not need to inherit right so that is one of the crucial difference and we will see it in the next example so that's ends the first example now we move to the second example which we have a slightly complete complicated scenario where we have an inheritance of the classes rather than just a standalone class so what we have in this example is that we have a base class and we have a derived class deriving from the base class and i am using struct in this example because that helps save some space on the slides and as we know they are actually same as plus fine so base class here in this example contains two virtual functions f and g and the derived class overrides one of that virtual function of the base class like g and it adds another virtual function of its own that is h and we want to export these classes from the library ensuring avi stability again what i mean by that is that for example in the next version of library if we add new virtual function in the base class then what will happen is that the virtual table of the derived class will get disrupted right even if we add new virtual function at the end in the base class right so basically this is one of the workaround people use to add virtual function only at the end that will not disrupt virtual table of that particular class but if there are derived classes then the derived class the perfect table of their class will will get disrupted right and that will that will break the compatibility with existing client so we want our architecture to handle this case also and the other thing that can happen in the hierarchy of plus is that the derived class the next version of the library can start deriving from some more parent classes such things do happen in real life right a class can start implementing one more interface class that that does happen so we we we want to know what we can do with the architecture that can ensure a visibility even in that case and by the way this is a choice if you think that you don't your library will not go under such changes you can decide not to use this part of the architecture or you can make some tweaking here and there fine but ah the point is that the architecture i am talking about does support such kind of resilience in the library as well fine so we no longer export classes in this architecture right so we now want to export this class in the derived class so we will have to export method table so we will have to export method table corresponding to the base class in a very similar way as we have seen in the previous example just to note one thing is that the free function g when it delegates to the class method it will do an exact delegation like it will use base column column g because as i said method table is not for polymorphic call decision it doesn't want to participate in that and this function this free function g will only be called from the method implementation on the client side of the class so if if a decision has been made to call the base class g we need to make sure that base class z only should be called even when the p base here the pointer b base is pointing to the derived class right so this is the only thing we need to notice here so we have the method table corresponding to the base class now we go to the derived class again the very similar thing that we will have to have three functions corresponding to all the methods of the derived class but one thing to note here is that we will also need to have a function that can give us a base class pointer given the derived class pointer i know it's very trivial we just need to return the pointer that we receive in the parameter and i will show you why we need it please bear with me we will see that in the next slide and since we no longer export function we export method table so our method table will have an entry for this function as well fine so this is one thing to note here the other thing to note here is that as i had said method table does not inherit so the method table of the derived class here will only have function pointers corresponding to the methods that are relevant for this particular class nothing more than that and we have seen the difference between method table and virtual table that method table does not inherit so i'm making that point again fine now we can go back to the client side and see what we need to have on the client side so on the client side again we will have to have proxy class definitions for all the classes that library had right so for the base class we will have a proxy class this with the same name again and when i say proxy class it means this class will have a p input data member which will be pointing to the object of a class on the different component here we are on the client side so the p impulse here in the base class will be pointing an object of the base class on the library side fine so only thing to note here in the base class is that the two things we add to the proxy class the p input data member and the constructor that constructs from the implementation pointer they will be marked protected because it's a base class derived class would like to use them and then all the implementation of the methods will be just to delete will be by just delegating the call to the function pointers in the method table fine now we can see the definition of the derived class on the client side again things will be very simple we will have a proxy class definition which will have a p input data member the one thing to notice here is that the constructor of the derived class that constructs from the implementation pointer will be calling the base class constructor that constructs from the implementation pointer of the base class and while calling it calling the best class constructor it will be passing the value value that it receives as a return written value from cast to base so basically it will first call cast to base function that will go to the library side because library had the implementation right and this function on the library side receive the derived class pointer which is actually the drive class pointer on the library side because it from client side it is the p input data member which is an object of the derived class on on the library side and that function will return a pointer of the base class of the derived class object right and with that the base class pimple will get initialized so what we will achieve is that if we see the object layout of the classes on the client side and the library side on the client side the base class part of the drag class will have its own pimple data member and the derived class as a whole will also have its p input data number they will get initialized in such a way that they will be pointing to the exact location of their corresponding part on the library side and suppose in the next version of the library our derived class start deriving from some more parent classes so that we don't know how the object layout will be created by the compiler but since we are calling cast to base function all the time from the client that function will ensure that the p input data member of the base class will keep pointing to the correct location on the of the object on the library side so that will ensure api stability even in that case okay so that ends the second example now we move to the third example which is an interface class and for that also we have a demo so i will go back to that code fine so in this example what we have is we have just reset let's let me go to the interface class okay in this example what we have is we have again a circle class and this this time it's a trim down version and this circle class has a draw method which gets a pointer of context and the context is basically an interface class which has a method draw circle a pure virtual method that's why i am calling it an interface class and the expectation is that an implementation of this context should have the draw functions implemented and for example the draw circle you should draw a circle and the implementation of the draw method on the library side what it does is it cause the draw circle a method of the context pointer passing the radius of the circle so that's it on the library side and on the client side which is again an executable and library when i say library or i always mean share library and on the client side what we have is client implements this this context interface and overrides the pure virtual method of the base class and it doesn't do anything fancy it only locks the draw call that it receives and the client program instantiates an object of draw logger and it instantiates an object of circle and then it cause the draw method of the circle passing the pointer of the logger object it had created right okay so what i will do now is i will run this program before that i will clear the screen to keep things clean okay so the name of the program is interface class so if i run it we get this output and this is what we can expect right and as you might have guessed that we now have and the set of the client library program and this time they are simplified so if i run the simplified version i get exactly the same output because essentially they are the same program just that the cv5 versions use the c architecture fine now imagine that in next version of the library we make some changes so for example we decided that our contest interface should also have methods to draw ellipse that can happen right so we added a new new pure virtual function in the context class and again purposefully i'm adding this function before an existing one fine so that's the only change that we will do in the library and on the client side we will again leave it unchanged and again we will compile just the libraries so ninja interface class library and interface class library cv file again this is the library on which the original program depends and this is the library on which the simplified version of the program depends fine i'm building them now we are again in the situation that we have the client programs which were compiled using the previous version of the sdk of the library but now the libraries have changed and again i will run those programs so if i run the original program i guess you can guess what will happen it it crashes so because we know that the virtual table that is understood by the library is different than what client understands right so because of that crash is one of the expected behavior okay so what if we run the simplified version when we run simplified version it it is exactly the same output as before so this is what i meant by avi stability even when we made changes in the library side interface that the virtual table of the interface class whose implementation is provided by the client we still ensure area stability so this is what i wanted to demo and now again we will go into the nitty-gritty of the architecture how it it is possible and admittedly it is going to be a bit more complex than the previous examples that we saw but i hope i will try my best to to explain it so fine so what we had is we had a library library program and we had a client program that we had an interface class and a regular class and client implemented that interface class right if we notice in this example it is also the library that is making use of a class that is defined on the client side right so the draw logger class that was defined by the client the method of it the draw circle method was eventually called by the library right so in a way in this example it should also be the client that should export its class right and how we export class in this architecture we don't export classes right what we do is we export method table so on the client side we need to have a method table corresponding to the implementation class of the context interface in the client side so we will have a declaration of method table on the client side we will have a free function again which will take the first pointer as the context pointer exactly in the same way that we had seen in the previous examples and it will delegate to the draw circle method of the context pointer all on the client side and we need to write this free function into a method table and export it but we have a little problem on the client side because it's not the library that compiles using the client right it's otherwise the client programs are compiled using the headers of the library and it links against the library right so all the symbols exported by the library is available to the client but it's not other way around so here we have a method table defined on the client side we want that method table to pass on to the library so that we can use it right because we had seen that library was making a function call of the class defined on the client side right so we need to pass on this method table to the library and since we cannot pass it on at compile time or link time we had we have to do it at runtime we will see how and again if we go to the library side since library wants to use a class that is defined on the client side it has to have a proxy class definition right because in this architecture we had seen that a component doesn't use doesn't use a class that is defined by the other component right it uses it through a proxy and the implementation of that proxy is done using method table we had seen that in the previous examples so similarly we will have to have a proxy class definition on the library side and that proxy class will actually mimic the behavior of the implementation class that is defined on the client side so here i am defining a generic context that represents any any implementation of interface pointer sorry interface class on the client side and since it is it represents any implementation on the client side it has to derive from the context interface right and as i said it is a proxy class what do i mean by proxy class is that it has to have a p input data number which will be a pointer of an object class and again that the full definition of that implementation class will be in the other component here in this example it will be on the client side and as i said library doesn't have the freedom to use the method table that is exported by client right it can only have that method table at a runtime so it will have to have a data member corresponding to the method table as well and because of that the constructor of this generic context class will need to get these two pointers as the parameter and then it will initialize these two members with those pointers that it receives once we have the implementers for implementation pointer and the method table pointer we can implement the draw circle method by just delegating to the function pointer present in the method right and again the first parameter will be p input data member and the next parameters will be exactly same as what the parameters of the method is fine now to create this an object of generic context we need to have an implementation pointer and method table pointer and they are only available to the client right so only client can create them so basically client will use this class right to use this client by the client from the library we need to export this class but we don't export class in this architecture what we do is we export method table so we will have three functions to create this create an object of this class and a free function to delete an object of this class and we need to bundle them up into a method table and export export that instead from the library right fine so that's what what we will do for the interface and if you remember we had another class also right that library was exporting so we will have to export a method table corresponding to that class as well fine now we can go to the client side so as i said in this architecture we don't use any class of the other component directly we use it through the proxy and that holds for the interface class as well so this class so we'll on the client side we will have a contest class declaration a proxy class declaration and since it's a proxy it will have to have a p input data member which will be a pointer to an implementation class fine but what i say that on the client side for the context class we will also need one more thing and that will be a default constructor we did not have this default constructor in the lavish site class definition but we need it here and this architecture actually demands it as i said in this example we don't have the freedom to for the library to access all the symbols exported by the client right we can only so we can only provide the method table to the library side at runtime and what i propose is that we can use this default constructor as a vehicle to transfer implementation pointer and method table pointer to the library side so the implementation of this default constructor on the client side what we can do is we can initialize the p input data member by calling the create function on the method table of the generic context and we will pass the this pointer and the pointer of the method table that client had defined right and we had seen the definition on the library side the generic context was getting a pointer of the implementation class and a pointer of the method right so this will actually create an object generally context object on the library side and it will return a pointer of the generic context that is defined that is created on the library side and that will be received as a pointer of implementation class on the client side with which the p input data member of the context interface will get initialized fine and then we will have the destructor of the context which will just call the delete function on the context method table passing the p input okay now we move to the circle class again we'll have a proxy class definition for the circle class as well it's exactly in the same line that we have seen in the previous example but i would like to draw your attention to the draw method of this circle class nothing easier but just want to focus is that the method the the method implementation of draw circle draw will call the draw function pointer present in the method table and the two parameter that it will pass the first parameter is always p impulse right and the second parameter is the same as the parameter of the method right but library does not understand the context class defined on the client side right right because client side classes are different than what what are there on the library side but the p input present in the client side class is the one that is an object of the class on the library side right so we need to pass the p input present in the context class as a second parameter fine now we are done with the discussion about this architecture let's see how it will actually work in the real case so on the client side we have what we do is we create an instance of draw logger so when we do it since draw logger is a derived class of context class the constructor the default constructor of context class will get called right and what we had done in the implementation of the default constructor of context is that it was calling a create function of the method table of the general context right so basically it was creating an instance of generic context on the library side passing the this pointer and the pointer of the method table right and what the value of this will be this pointer it will be the pointer of the this object we are creating here so the pointer of the logger itself right so this is what we will be passing to the generic context on the library side and that will create an instance of generic context and that will be received here and will be stored as the p input data member of the contest based class right okay next what we do is we call the draw method of the circle class passing the pointer of the logger so we had seen the previous slide the implementation of the draw method on the client side it was passing the p input of the circle and then the p input of the context remember and what is that pimple here in the context it is the pointer to the generic context so basically when the draw method of circle is called the call goes to the library side draw draw method through the method table of course and then the p contest that receives here in the library side it is actually a pointer of generic context and as we know the generic context on the library side is actually a proxy class of the implementation done in the client side right proxy class is the one that has the pim pimple data member that points to the object of the different component so the generic context on the library side has a p input data member that is actually pointing to the object of draw logger right so when library costs draw circle here the call eventually goes to the method implemented on the client side and this is how we sorry this is how we achieve the library calling client side method it using the method table and since we have seen that the method table is crucial in implementing in answering ada stability we we know that it will be avi abstable and we had seen the demo fine so we are done with the discussion of the three examples now i present you my tool that i have developed so basically the rule of the architecture we talked about are very strict rule very clear rules right so what i propose is that we can have a tool that can read the headers as a library author we would like to publish and that tool can and see that header pass it and then create the the the generate the code that implements this sieve architecture so what i mean by that is that since all the code like definition of method table initialization of method table and export it that is the part of the library side blue code the extra code and that this tool can generate and it can generate the proxy class declaration and the implementation of proxy class that uses method table exported by the library this tool can generate that also and this tool can generate method tables separately because it is something that is common between the two components and the other benefit of exporting this method tools separately is that when we change the library in the next version we can feed this tool the previous definition of method table so that this tool will understand that it can only add new function pointers in the method only at the end and that that was crucial for eva stability right and this is what you actually saw in the two demo that i gave you so this tool was actually working behind the scene and ensured avi stability which was not possible without this fine so we can have this tool and i have already had this tool and i have a github page where i have developed it and finally how good this architecture is or is it viable in the real case so what i did is i did a case study with a real library so i chose podophill library which is an open source pdf library it's a fairly complex library but it's not huge but good enough for my cases today so it exports around 200 of the classes but it's not a very big library and what i did is i simplified this library meaning is that i ran my tool on the headers of this library which generated the library side blue code and the sdk of this library and then i compiled all the test programs and example programs which are part of this library so when if you get this library you will also get test programs and some sample programs example programs and there are around 30 of them so i ran all those test programs and example programs and compared the result and here are the report so we saw some significant change in the battery size of the library so the library was originally around 1.7 mb but the cb5 version of the library was almost 200 percent bigger than that and sorry as you can guess the the additional size of the library will actually depend upon how many methods are there right how many methods are there in the in the library that the public methods that it wants to export it doesn't depend on the complexity of the method because the what extra we add are just the three functions which delegates to the methods of the class right so they have to be very small inside a small in the generated code part when we create the manual right but since this library wasn't used in itself like so basically the implementation of those methods of class methods were not taking up much size in itself because of that we saw large size change in the bandwidth size which i think will not be the case if we have a large library but if we have the similar number of classes fine and we saw some more some changes in the client side so this is the size you see here the cumulative size diff of all the client programs so these are actually the combined size of all the test programs and example programs as i said they are around 30 of them the size there was the additional size because of the simplified architecture was that it was 100 more exercise again the same holds true here as well the programs they were itself were not very complex and because of that even the delegation things were significant compared to that fine and the memory uses of the simplified programs was around five percent less than five percent actually around four percent extra memory usage and this is something that we can expect right but here again the extra memory consumption will actually depend upon the number of instances of the class that happens on the client side right and it will want to be much because the client side classes are actually shallow classes they don't have much in them they only have p input data member that they point to the library side right and the performance report is that the cumulative extra time difference of the all the programs was less than half a percent and i didn't do anything fancy here what i did is i wrote a script on linux to run all those programs one after another in quick succession and i use the time command to measure the complete time of of all the programs and here is the report and this is again if you notice the extra runtime cost will actually be constant all the time because we only do delegation right so it won't take much it will only be constant so again depending upon how complex your algorithm is on the client side or the library side this percentage scheme can go up or down finally so it was the case study report but what examples we saw are not the only thing that can happen in a c plus first library right and especially in the modern c plus library we have many more things but the good thing is that i already have working examples for almost all of the things that are possible and that are listed here and you can have a look for all those examples and i have a github page for that and yeah that's it for my talk thank you you