reverse engineering is the dark art of taking code that somebody else wrote and taking it apart to see what it does it's kind of like a rubik's cube actually i'm not really sure how that analogy works out now maybe it's a piece of malware maybe you're trying to figure out what this malicious piece of code on your computer did and by the way also lock bit an international ransomware organization just got rolled up by the fbi god you love to see it or maybe it's simpler than that maybe it's just a puzzle and by taking apart this puzzle you learn something new or kind of neat about computing these puzzles are called crackme challenges and by solving one typically you make yourself a better programmer by learning a little bit about how computers work at a fundamental level also don't worry about these empty boxes i'm just moving now today we're going to solve a fairly straightforward crackme one for the arm architecture but not in the way that you're probably used to we're going to use a program called anger and that's an anger without an e and it has some really really interesting properties now if you're new here this is lowle learning a channel where i do videos about low-l computer programming and software security if that interests you hit the subscribe button and leave a like now let's get into that crack me i'm not like physically going anywhere i'm not sure why i'm motioned this way now come on take a seat we're going to download this one called towels armageddon i'm choosing this one because it's an arm architecture binary for those of you that are new and may want to be doing this stuff or trying to learn the art of assembly language reverse engineering i highly recommend the arm architecture because it's a reduced instruction set computer architecture which is really really simple to understand compared to some of the variable length ones like intel i've got it downloaded here and we have the file here it's going to be called armageddon ex sense it's an arm binary we can kind of check that and make sure that it is what they say it is it's a 32-bit least significant bit so little indian arm binary great it's dynamically linked and it's stripped stripped meaning that it has no debug information there's no fancy symbols kind of tell what's going on in the binary so what i like to do when i'm doing any of these crack mes is first just run strings on it i know strings is kind of like the go-to as like a joke noob tool to figure out like if the flag is just put in the binary you'll just see it pop out but i also like to use strings on binaries to figure out what i'm getting myself into right i can typically pretty quickly in a binary see from strings like what's going on so let's kind of look at the functions here it loads up the loader obviously depends on libc that makes sense we call a function a couple function calls so we have exit scan f puts abort print f and then libc start man and i'm not seeing any other symbol names eventually they're going to probably print some prompt you oh it's from umd that's pretty cool umd ctf 2019 the code did not validate otherwise we enter a code and then that's it okay so it looks like we're going to put in some kind of code that is 41 characters long and then from there we're going to get a flag pretty pretty straightforward awesome so what we're going to do is we're going to put this into gidra gidra is the reverse engineering framework by the nsa it's open source it's really cool gidra 11 just came out which means gidra dark mode exists so that's freaking awesome if you're new to the world of everse engineering what we're looking at here is the actual binary code right so on the left is the disassembly which is this the assembly code broken into the assembly operations and then on the right is ged's interpretation of what that code looked like in c obviously we don't have debug information so we don't know what the source code was but gidra is doing its best to lift that into a meaningful representation using the c programming language let's take a look and see what what kind of trouble we're getting into here so the reason i went to this function is because it is called from the entry point right so any binary that uses libc the entry symbol gets called that calls libc start main and that first function here is always the main function that's how lib start main is is derived so we can go ahead and hit the f key to turn this into a function and you'll see that now it's not purple we're not in like this weird error state and i'm going to increase the font size a little bit for you guys if you guys if you guys needed that on mobile please do me a favor say thanks tri l in the chat very cool i also want you guys be able to see this cool so we have that going going on and we can see here that the program looks pretty simple we print out the prompt we say enter code and then we do scanf into the stack using some format string and i the format string is that percent 41s this means we're going to input 41 characters of string data and then do some operation on them so we're just going to rename this this variable our data right and we can do that by pressing l and then typing our data and we'll just call that format to we're trying to turn all of these labels into things we can just easily read in english because the less nonsense we have the more easy it is to understand what the code is actually doing i did notice in the description of the challenge they said it features some very light arm assembly obfuscation it was originally released umd cf 2019 okay but what's cool is that we can see that obfuscation happening in the assembly but ged's lifter gidra is like you know interpreter into c doesn't have to worry about it but what you're actually seeing here is after every function or after literally every assembly instruction it's branching ahead to the next instruction and there's garbage data in the middle we can actually see that pretty straightforward if we go to the binary and try to object dump it it's very difficult to see what's going on in the program so we see the call to liy start main here and we can tell where the main symbol is by the r0o value in the liy start main call it's going to be at 1040 and then 1040 or 10400 contains the variable 14804 so we can go to that and so this is our start symbol right but now what's happening is because we don't have control flow information we have arrows that are showing us what's happening we have a branch to this label and then this instruction runs and then another branch so it oates the code in a way that makes it very difficult to interpret rising gedra we getting really really useful information in the in the form of c and not in the form of assembly that's been aisc by the compiler the challenge is to input the correct data and get a flag out of it right so we have to know what the good data is and then it'll print out the you did it string so i think what's happening here is this is them decoding the you didit string right so what's what's going on here we have a bunch of i'm trying to get my fat head out of the way so you guys can see this but yeah there's there's some basic binary alisation going on here where they have some string and a counter so we'll rename this counter yeah so they're literally just like adding some values exloring it and taking it apart but we're actually worried about is finding out the data that's required to go into this program to get to this point so if we go to one of these functions for example let's see what's going on here we have so this is the input this going to be a care star cu that's our our input to the program if string of 1 * string of 27 * string of 15 okay blah blah blah blah equals does not equal some magic value the code did not validate okay so we're seeing some initial constraints on the value here that we have to solve so we have to figure out some kind of math that makes all of these things possible okay so let's see what else we can do if the code keeps going like this it's going to be very painful because you know it looks like we have multiple validations to check yeah okay if if this minus this times this is not equal to this value and i'm i'm guessing that like every one of these validation functions is going to be like that okay yeah so this is quickly turning into a very painful math problem h let's see so what we're going to do is we're going to use a library called anger as the description here says anger is an open-source binary analysis platform for python it comes with both static and dynamic symbol can colic analysis providing tools to solve a variety of tasks the primary one we're going to look at today is this idea of symbolic execution specifically with constraint solving what's really really cool is anger has this idea of pathfinders so if you consider the program as we are trying to run the program to its completion where we get to the puts stage where it puts this magical value we need to get there by avoiding all of these exit statements right we want to avoid any code that goes to exit we can even tell anger to specifically avoid the exit function the way anger works is anger takes the constraints required to execute a program so the registers and what values they need to contain to continue program execution and they boil them down to effectively a math problem and then by using a constraint solver like microsoft z3 they can turn the constraints into a math problem that they can solve so by using anger on this we can literally just turn the input required to get to this point in the program into a math problem that z3 will burn on and give us the relevant the required input to get to the end of the problem okay i know forgive me for writing python but anger is a library written for python and personally i think for doing binary exploitation and reverse engineering task python is a really great language so what we're going to do here is we're going to write the imports to import anger and then import clery clarp is the constraint solver that's used in anger to do the math effectively to to solve the input for the problem right and then also we want to import cis i want to do i want to be able to change the name of the program off of cis argv so we'll have our function called main it'll take argv as input and then we'll say that the path name to the file equals argv of one very cool and then what we do to make a project in anger we just say anger. project and path name and then we go from there we're going to be using a simulation to explore how to get to a good address while avoiding bad addresses and again we do that by saying we want to get to our you know print the flag function without hitting the exit function we're going to use this example for the majority of our problem now the start address we have to create a state where the problem will start in right and we can start the problem we'll say right here at 14 ac3 so that'll be our start address for our our solver and then the good address is going to be the address after we print our data right so right here at the return address i want to get to this address that is our our good address so we'll take that very good and then also so our avoid address right we want to avoid particular parts of the problem in particular we want to avoid any call to exit so we can go to the global offset table instruction for exit and we can avoid this right here this 10 3b 0 wonderful and then so we're literally going to take the code that came from the example over there and just make it so that we set up the same simulation state okay so what we have here is our initial state this is us creating a blank simulation state for anger to solve with right and the address we're going to start that state in as it class to the binary is that start address right after the function gets called we have the simulation which is just turning that initial state into a sim manager which is a factory within anger and then we also want it to explore to find all of those good addresses and avoid all those bad addresses now if the simulation runs and it finds a path that is solvable to get to ideally and realistically there only can be one of those right we only have one flag or one answer to the problem so we'll extract that simulation now the issue with this problem right now now is that we haven't given anger the thing that it needs to solve right this is what we call our symbolic value by treating the input of this problem as symbolic it'll create a tree of all the possible states that it could be and then use that to solve the problem to give us the flag so let's create that flag that we're going to put into our problem okay and here we have the input size of the flag and then the input value of the flag we're using clar to create a bit vector symbolic again that's a symbolic value that will be treated as a piece of math that we have to solve later and this is the size right it's a 32 by flag times 8 bytes it could be longer it could be shorter but by partially constraining just part of the flag it may enable anger to solve the rest of the flag if it's longer now the issue with this is we're saying that it's a bite vector of 32 * 8 bytes right or it's a bit vector of 32 * 8 bits from a mathematical perspective if we don't constrain that down to less of a key space the explosion for the inputs that might be possible to the program is exponential so what we have to do is we have to constrain our inputs to only be inputs that we can meaningfully give to our problems i think asky characters white space stuff like that okay and we do that just here we say for every bite in the input value chopped into 8 bit segments right so we take eight bits at a time so a single bite and we add to our simulation state that every bite has to be greater than hex a which is a new line character and less than 7f which is the maximum value of asky printable characters and this makes sense right because we're reducing the key space in half to make it so that anger can solve our problem and also it makes sense because we can't type higher than 7f on a regular english keyboard right so this converts a much larger tree of gigantic inputs and reduces it by an entire order by cutting the keyspace in over half and then finally we have one more thing we have to do we have to say that the flag is equal to s.s solver which is the clar solver in the simulation state. eval our input value right so we'll go ahead and do that and there we go so in theory if this works we should be able to do just print just print flag and also print s.p. dumps s. or cy. standard out. file number so we're just going to have we're going to print the flag that we found through our mathematical operation and we're also going to print the dump of the standard out of the binary or of this run which should have the congratulations you solve the problem message and then one thing we also have to do is have to actually say that the input to the pro program is going to be our input value right so we we made this this symbolic value but we didn't actually give it to the program so now we say that standard in is equal to input val very good okay so we go ahead and do that and let's run it okay so this is where things get a little hairy so you noticed how it ran and immediately ended the issue here is that that means that we ran the program and we created a state that was not mathematically solvable so that means that something about our program is incorrect and what actually this turns into is it is known that passing input to a program in anger via scanf is typically very problematic so instead of starting the program here what we're going to do is we are going to create a state on the stack that emulates after scanf is ran and instead of giving our flag as standard into the program we're going to put our symbolic value on the stack right and that's going to be at sp minus hex 34 let's go do that right now okay so what we did is we actually removed it from standard in because again we're not going to treat it like we're giving it into the program via standard in we're going to do instead is we are going to in simulation create a stack frame by setting the base pointer equal to the stack pointer and then subtracting the stack pointer by some value right to create that stack frame and then what we're going to do is we are going to store into our initial state at the bp minus hex 38 our input value which again is that symbolic going to be solved by the math solver piece of the equation into that problem and then same thing we're going to let the simulation explorer run and if it finds any paths that get it to that solve the equation on the input value so with all that being said let's go ahead and solve this problem and see what trou we can get into solve armageddon and again this is going to take a second because it has to go through figure out the math to get to the point where we solve that the the final state and then do the actual mathematical operations to give us the number cool so we found a state that the output the standard out was code validated successfully and the the flag is this long number from clarp and it's printing it as a decimal so what we have to do in python is we have to get the hex value of this decimal and then we have to extract this and we're going to turn this into a string by doing bytes from hex we'll do bytes. from heex b a bing that's not correct bite stop from hex in quotes and then we okay there we go umd cf- armish satisfying and the joke there being that we had to use a sat solver to get this to work so let's put this in the program and see if we can't run it and i'm assuming there's a second bracket that i missed so armagon arm is satisfying code did not validate interesting okay okay let's just make this a little longer let's see if i can solve any more of these may have won fight i know i should have added this to the script stop yelling at me i can smell it in theing comments you should have just typed this into your script bro yeah i got it there we go umd ctf arm is so satisfying with a little salt at the end there so let's do that armageddon boom code validated successfully hey guys i hope you enjoyed this video i love ctf i love capture the flag reverse engineering is fun try this out write the script yourself learn a little bit about that sat solvers about anger and we'll see you in the next one check out this other video where i cracked a different crack me and learned something pretty sweet see you there