computers suck at division i realized this when i was coding some arm assembly trying to solve what i thought was a relatively simple problem the prompt was to write a function in assembly of course that would convert a fahrenheit temperature into celsius the equation for this is quite simple the degree is in fahrenheit minus 32 times 5 divided by 9 yields the degrees in celsius this seems simple enough but it quickly turned into something that was much more complicated as i was writing the code setting up the stack and making room for local variables was an easy and familiar task next i did the first part of the equation subtract 32. great success i felt like i was on my way to a quick low-level victory but here i encountered my first problem the fraction because 5 over 9 is not a whole regular number i would have to use the arm processor's floating point unit or fpu to do floating point math to get my answer the problem was that not all arm processors have an fpu and without an fpu i would have to rely on lib c's floating point approximation libraries to just do the math for me and that felt like cheating surely there is an easier way instead of treating five over nine like a fraction i decided to treat it like two separate operations first multiply by five and then divide by nine finally the light at the end of the tunnel was beginning to show and this is where the story takes a slight turn i quickly learned that arm cores didn't have a division instruction until 2004 and that most of the smaller cortex m series processors still don't support signed or unsigned division how is this possible did the algorithms executed by those chips just never include division after banging my head against a wall for a few hours i decided to write the function in godbolt and see what the assembler produced for the arm solution what stuck out to me was this magic number here instead of doing a division operation my input was being multiplied by this large constant instead of just accepting that compilers and computers are blackmagic with deep mythical undertakings i dove deeper it turns out that the number here is being used to do what is referred to as fixed point multiplication wait multiplication i thought we were doing division hold your horses we'll get there the algorithm we're being asked to do was to multiply by 5 and then divide by nine because we can't divide by nine because there are no divide instructions what we could do instead is multiply by one over nine the issue with one over nine is that it is not a whole number and again we can't use floats this is where fixed point representation comes into play we can represent 1 over 9 as a binary fixed point number like this one over nine is an infinitely repeating binary pattern but we can approximate the value to a certain point by truncating the pattern at this point here because we can't store the decimal point in binary like we can with floats we'll just make the decimal point implied by scaling the number we scale the number by shifting the decimal point in binary to the right by multiplying it by a very high power of two the exact power of two that you use depends on the accuracy that you want from the number and the number of bits you have to work with so boiling that all down this number here is the result of 2 to the power of 33 divided by 9 and then we add 1 to approximate for the data that we lose by truncating the repeating pattern arm with this power i felt like i was finally ready to solve the problem because i didn't want to cheat and just use the number they gave me i decided to use my own magical constant using the same mathematical principle i use this number here which is just 2 to the power of 32 divided by 9 plus 1. in theory it would provide the same results with just a bit less accuracy at higher input values but working with degrees i wasn't too worried about that finally i could write my code first i subtracted 32 from my input number next i multiplied it by five and finally to approximate the division by 9 i would do a 64-bit multiplication where the result of the operation goes into two separate registers here the high 32 bits are in r0 and the low 32 bits are in r4 because the high 32 bits are in r0 we don't have to do any bit shifting in r0 by default contains our answer using this harness i'm able to check to see if my function converts 86 degrees fahrenheit to the correct answer of 30 in celsius we try it out and great success after i finished the problem i wanted to figure out why arm chips didn't have divide instructions and it's all kind of odd to me after some digging the answer seemed pretty straightforward division is such a slow algorithm that chip designers typically create a separate set of circuits in the chip to accelerate the operation these circuits take up a ton of silicon dye space and are extremely expensive to make because of this arm decided they just weren't needed and for certain variants of the cortex m0 they still don't hey guys thanks for watching i really enjoyed making that video if you liked it as well do me a favor hit like hit subscribe and then go watch this video about how i hacked my own server using a buffer overflow with strings i'll see you there